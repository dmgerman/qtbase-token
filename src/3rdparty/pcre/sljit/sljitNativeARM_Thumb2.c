begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"ARM-Thumb2"
name|SLJIT_CPUINFO
return|;
block|}
end_function
begin_comment
comment|/* Length of an instruction word. */
end_comment
begin_typedef
DECL|typedef|sljit_ins
typedef|typedef
name|sljit_ui
name|sljit_ins
typedef|;
end_typedef
begin_comment
comment|/* Last register + 1. */
end_comment
begin_define
DECL|macro|TMP_REG1
define|#
directive|define
name|TMP_REG1
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NO_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NO_REGISTERS + 3)
end_define
begin_define
DECL|macro|TMP_PC
define|#
directive|define
name|TMP_PC
value|(SLJIT_NO_REGISTERS + 4)
end_define
begin_define
DECL|macro|TMP_FREG1
define|#
directive|define
name|TMP_FREG1
value|(0)
end_define
begin_define
DECL|macro|TMP_FREG2
define|#
directive|define
name|TMP_FREG2
value|(SLJIT_FLOAT_REG6 + 1)
end_define
begin_comment
comment|/* See sljit_emit_enter and sljit_emit_op0 if you want to change them. */
end_comment
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|10
block|,
literal|11
block|,
literal|13
block|,
literal|3
block|,
literal|4
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|COPY_BITS
define|#
directive|define
name|COPY_BITS
parameter_list|(
name|src
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|bits
parameter_list|)
define|\
value|((from>= to ? (src>> (from - to)) : (src<< (to - from)))& (((1<< bits) - 1)<< to))
end_define
begin_comment
comment|/* Thumb16 encodings. */
end_comment
begin_define
DECL|macro|RD3
define|#
directive|define
name|RD3
parameter_list|(
name|rd
parameter_list|)
value|(reg_map[rd])
end_define
begin_define
DECL|macro|RN3
define|#
directive|define
name|RN3
parameter_list|(
name|rn
parameter_list|)
value|(reg_map[rn]<< 3)
end_define
begin_define
DECL|macro|RM3
define|#
directive|define
name|RM3
parameter_list|(
name|rm
parameter_list|)
value|(reg_map[rm]<< 6)
end_define
begin_define
DECL|macro|RDN3
define|#
directive|define
name|RDN3
parameter_list|(
name|rdn
parameter_list|)
value|(reg_map[rdn]<< 8)
end_define
begin_define
DECL|macro|IMM3
define|#
directive|define
name|IMM3
parameter_list|(
name|imm
parameter_list|)
value|(imm<< 6)
end_define
begin_define
DECL|macro|IMM8
define|#
directive|define
name|IMM8
parameter_list|(
name|imm
parameter_list|)
value|(imm)
end_define
begin_comment
comment|/* Thumb16 helpers. */
end_comment
begin_define
DECL|macro|SET_REGS44
define|#
directive|define
name|SET_REGS44
parameter_list|(
name|rd
parameter_list|,
name|rn
parameter_list|)
define|\
value|((reg_map[rn]<< 3) | (reg_map[rd]& 0x7) | ((reg_map[rd]& 0x8)<< 4))
end_define
begin_define
DECL|macro|IS_2_LO_REGS
define|#
directive|define
name|IS_2_LO_REGS
parameter_list|(
name|reg1
parameter_list|,
name|reg2
parameter_list|)
define|\
value|(reg_map[reg1]<= 7&& reg_map[reg2]<= 7)
end_define
begin_define
DECL|macro|IS_3_LO_REGS
define|#
directive|define
name|IS_3_LO_REGS
parameter_list|(
name|reg1
parameter_list|,
name|reg2
parameter_list|,
name|reg3
parameter_list|)
define|\
value|(reg_map[reg1]<= 7&& reg_map[reg2]<= 7&& reg_map[reg3]<= 7)
end_define
begin_comment
comment|/* Thumb32 encodings. */
end_comment
begin_define
DECL|macro|RD4
define|#
directive|define
name|RD4
parameter_list|(
name|rd
parameter_list|)
value|(reg_map[rd]<< 8)
end_define
begin_define
DECL|macro|RN4
define|#
directive|define
name|RN4
parameter_list|(
name|rn
parameter_list|)
value|(reg_map[rn]<< 16)
end_define
begin_define
DECL|macro|RM4
define|#
directive|define
name|RM4
parameter_list|(
name|rm
parameter_list|)
value|(reg_map[rm])
end_define
begin_define
DECL|macro|RT4
define|#
directive|define
name|RT4
parameter_list|(
name|rt
parameter_list|)
value|(reg_map[rt]<< 12)
end_define
begin_define
DECL|macro|DD4
define|#
directive|define
name|DD4
parameter_list|(
name|dd
parameter_list|)
value|((dd)<< 12)
end_define
begin_define
DECL|macro|DN4
define|#
directive|define
name|DN4
parameter_list|(
name|dn
parameter_list|)
value|((dn)<< 16)
end_define
begin_define
DECL|macro|DM4
define|#
directive|define
name|DM4
parameter_list|(
name|dm
parameter_list|)
value|(dm)
end_define
begin_define
DECL|macro|IMM5
define|#
directive|define
name|IMM5
parameter_list|(
name|imm
parameter_list|)
define|\
value|(COPY_BITS(imm, 2, 12, 3) | ((imm& 0x3)<< 6))
end_define
begin_define
DECL|macro|IMM12
define|#
directive|define
name|IMM12
parameter_list|(
name|imm
parameter_list|)
define|\
value|(COPY_BITS(imm, 11, 26, 1) | COPY_BITS(imm, 8, 12, 3) | (imm& 0xff))
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Instrucion forms                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* dot '.' changed to _    I immediate form (possibly followed by number of immediate bits). */
end_comment
begin_define
DECL|macro|ADCI
define|#
directive|define
name|ADCI
value|0xf1400000
end_define
begin_define
DECL|macro|ADCS
define|#
directive|define
name|ADCS
value|0x4140
end_define
begin_define
DECL|macro|ADC_W
define|#
directive|define
name|ADC_W
value|0xeb400000
end_define
begin_define
DECL|macro|ADD
define|#
directive|define
name|ADD
value|0x4400
end_define
begin_define
DECL|macro|ADDS
define|#
directive|define
name|ADDS
value|0x1800
end_define
begin_define
DECL|macro|ADDSI3
define|#
directive|define
name|ADDSI3
value|0x1c00
end_define
begin_define
DECL|macro|ADDSI8
define|#
directive|define
name|ADDSI8
value|0x3000
end_define
begin_define
DECL|macro|ADD_W
define|#
directive|define
name|ADD_W
value|0xeb000000
end_define
begin_define
DECL|macro|ADDWI
define|#
directive|define
name|ADDWI
value|0xf2000000
end_define
begin_define
DECL|macro|ADD_SP
define|#
directive|define
name|ADD_SP
value|0xb000
end_define
begin_define
DECL|macro|ADD_W
define|#
directive|define
name|ADD_W
value|0xeb000000
end_define
begin_define
DECL|macro|ADD_WI
define|#
directive|define
name|ADD_WI
value|0xf1000000
end_define
begin_define
DECL|macro|ANDI
define|#
directive|define
name|ANDI
value|0xf0000000
end_define
begin_define
DECL|macro|ANDS
define|#
directive|define
name|ANDS
value|0x4000
end_define
begin_define
DECL|macro|AND_W
define|#
directive|define
name|AND_W
value|0xea000000
end_define
begin_define
DECL|macro|ASRS
define|#
directive|define
name|ASRS
value|0x4100
end_define
begin_define
DECL|macro|ASRSI
define|#
directive|define
name|ASRSI
value|0x1000
end_define
begin_define
DECL|macro|ASR_W
define|#
directive|define
name|ASR_W
value|0xfa40f000
end_define
begin_define
DECL|macro|ASR_WI
define|#
directive|define
name|ASR_WI
value|0xea4f0020
end_define
begin_define
DECL|macro|BICI
define|#
directive|define
name|BICI
value|0xf0200000
end_define
begin_define
DECL|macro|BKPT
define|#
directive|define
name|BKPT
value|0xbe00
end_define
begin_define
DECL|macro|BLX
define|#
directive|define
name|BLX
value|0x4780
end_define
begin_define
DECL|macro|BX
define|#
directive|define
name|BX
value|0x4700
end_define
begin_define
DECL|macro|CLZ
define|#
directive|define
name|CLZ
value|0xfab0f080
end_define
begin_define
DECL|macro|CMPI
define|#
directive|define
name|CMPI
value|0x2800
end_define
begin_define
DECL|macro|CMP_W
define|#
directive|define
name|CMP_W
value|0xebb00f00
end_define
begin_define
DECL|macro|EORI
define|#
directive|define
name|EORI
value|0xf0800000
end_define
begin_define
DECL|macro|EORS
define|#
directive|define
name|EORS
value|0x4040
end_define
begin_define
DECL|macro|EOR_W
define|#
directive|define
name|EOR_W
value|0xea800000
end_define
begin_define
DECL|macro|IT
define|#
directive|define
name|IT
value|0xbf00
end_define
begin_define
DECL|macro|LSLS
define|#
directive|define
name|LSLS
value|0x4080
end_define
begin_define
DECL|macro|LSLSI
define|#
directive|define
name|LSLSI
value|0x0000
end_define
begin_define
DECL|macro|LSL_W
define|#
directive|define
name|LSL_W
value|0xfa00f000
end_define
begin_define
DECL|macro|LSL_WI
define|#
directive|define
name|LSL_WI
value|0xea4f0000
end_define
begin_define
DECL|macro|LSRS
define|#
directive|define
name|LSRS
value|0x40c0
end_define
begin_define
DECL|macro|LSRSI
define|#
directive|define
name|LSRSI
value|0x0800
end_define
begin_define
DECL|macro|LSR_W
define|#
directive|define
name|LSR_W
value|0xfa20f000
end_define
begin_define
DECL|macro|LSR_WI
define|#
directive|define
name|LSR_WI
value|0xea4f0010
end_define
begin_define
DECL|macro|MOV
define|#
directive|define
name|MOV
value|0x4600
end_define
begin_define
DECL|macro|MOVS
define|#
directive|define
name|MOVS
value|0x0000
end_define
begin_define
DECL|macro|MOVSI
define|#
directive|define
name|MOVSI
value|0x2000
end_define
begin_define
DECL|macro|MOVT
define|#
directive|define
name|MOVT
value|0xf2c00000
end_define
begin_define
DECL|macro|MOVW
define|#
directive|define
name|MOVW
value|0xf2400000
end_define
begin_define
DECL|macro|MOV_W
define|#
directive|define
name|MOV_W
value|0xea4f0000
end_define
begin_define
DECL|macro|MOV_WI
define|#
directive|define
name|MOV_WI
value|0xf04f0000
end_define
begin_define
DECL|macro|MUL
define|#
directive|define
name|MUL
value|0xfb00f000
end_define
begin_define
DECL|macro|MVNS
define|#
directive|define
name|MVNS
value|0x43c0
end_define
begin_define
DECL|macro|MVN_W
define|#
directive|define
name|MVN_W
value|0xea6f0000
end_define
begin_define
DECL|macro|MVN_WI
define|#
directive|define
name|MVN_WI
value|0xf06f0000
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
value|0xbf00
end_define
begin_define
DECL|macro|ORNI
define|#
directive|define
name|ORNI
value|0xf0600000
end_define
begin_define
DECL|macro|ORRI
define|#
directive|define
name|ORRI
value|0xf0400000
end_define
begin_define
DECL|macro|ORRS
define|#
directive|define
name|ORRS
value|0x4300
end_define
begin_define
DECL|macro|ORR_W
define|#
directive|define
name|ORR_W
value|0xea400000
end_define
begin_define
DECL|macro|POP
define|#
directive|define
name|POP
value|0xbd00
end_define
begin_define
DECL|macro|POP_W
define|#
directive|define
name|POP_W
value|0xe8bd0000
end_define
begin_define
DECL|macro|PUSH
define|#
directive|define
name|PUSH
value|0xb500
end_define
begin_define
DECL|macro|PUSH_W
define|#
directive|define
name|PUSH_W
value|0xe92d0000
end_define
begin_define
DECL|macro|RSB_WI
define|#
directive|define
name|RSB_WI
value|0xf1c00000
end_define
begin_define
DECL|macro|RSBSI
define|#
directive|define
name|RSBSI
value|0x4240
end_define
begin_define
DECL|macro|SBCI
define|#
directive|define
name|SBCI
value|0xf1600000
end_define
begin_define
DECL|macro|SBCS
define|#
directive|define
name|SBCS
value|0x4180
end_define
begin_define
DECL|macro|SBC_W
define|#
directive|define
name|SBC_W
value|0xeb600000
end_define
begin_define
DECL|macro|SMULL
define|#
directive|define
name|SMULL
value|0xfb800000
end_define
begin_define
DECL|macro|STR_SP
define|#
directive|define
name|STR_SP
value|0x9000
end_define
begin_define
DECL|macro|SUBS
define|#
directive|define
name|SUBS
value|0x1a00
end_define
begin_define
DECL|macro|SUBSI3
define|#
directive|define
name|SUBSI3
value|0x1e00
end_define
begin_define
DECL|macro|SUBSI8
define|#
directive|define
name|SUBSI8
value|0x3800
end_define
begin_define
DECL|macro|SUB_W
define|#
directive|define
name|SUB_W
value|0xeba00000
end_define
begin_define
DECL|macro|SUBWI
define|#
directive|define
name|SUBWI
value|0xf2a00000
end_define
begin_define
DECL|macro|SUB_SP
define|#
directive|define
name|SUB_SP
value|0xb080
end_define
begin_define
DECL|macro|SUB_WI
define|#
directive|define
name|SUB_WI
value|0xf1a00000
end_define
begin_define
DECL|macro|SXTB
define|#
directive|define
name|SXTB
value|0xb240
end_define
begin_define
DECL|macro|SXTB_W
define|#
directive|define
name|SXTB_W
value|0xfa4ff080
end_define
begin_define
DECL|macro|SXTH
define|#
directive|define
name|SXTH
value|0xb200
end_define
begin_define
DECL|macro|SXTH_W
define|#
directive|define
name|SXTH_W
value|0xfa0ff080
end_define
begin_define
DECL|macro|TST
define|#
directive|define
name|TST
value|0x4200
end_define
begin_define
DECL|macro|UMULL
define|#
directive|define
name|UMULL
value|0xfba00000
end_define
begin_define
DECL|macro|UXTB
define|#
directive|define
name|UXTB
value|0xb2c0
end_define
begin_define
DECL|macro|UXTB_W
define|#
directive|define
name|UXTB_W
value|0xfa5ff080
end_define
begin_define
DECL|macro|UXTH
define|#
directive|define
name|UXTH
value|0xb280
end_define
begin_define
DECL|macro|UXTH_W
define|#
directive|define
name|UXTH_W
value|0xfa1ff080
end_define
begin_define
DECL|macro|VABS_F32
define|#
directive|define
name|VABS_F32
value|0xeeb00ac0
end_define
begin_define
DECL|macro|VADD_F32
define|#
directive|define
name|VADD_F32
value|0xee300a00
end_define
begin_define
DECL|macro|VCMP_F32
define|#
directive|define
name|VCMP_F32
value|0xeeb40a40
end_define
begin_define
DECL|macro|VDIV_F32
define|#
directive|define
name|VDIV_F32
value|0xee800a00
end_define
begin_define
DECL|macro|VMOV_F32
define|#
directive|define
name|VMOV_F32
value|0xeeb00a40
end_define
begin_define
DECL|macro|VMRS
define|#
directive|define
name|VMRS
value|0xeef1fa10
end_define
begin_define
DECL|macro|VMUL_F32
define|#
directive|define
name|VMUL_F32
value|0xee200a00
end_define
begin_define
DECL|macro|VNEG_F32
define|#
directive|define
name|VNEG_F32
value|0xeeb10a40
end_define
begin_define
DECL|macro|VSTR_F32
define|#
directive|define
name|VSTR_F32
value|0xed000a00
end_define
begin_define
DECL|macro|VSUB_F32
define|#
directive|define
name|VSUB_F32
value|0xee300a40
end_define
begin_function
DECL|function|push_inst16
specifier|static
name|sljit_si
name|push_inst16
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|inst
parameter_list|)
block|{
name|sljit_uh
modifier|*
name|ptr
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|sljit_uh
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uh
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|inst
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_inst32
specifier|static
name|sljit_si
name|push_inst32
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|inst
parameter_list|)
block|{
name|sljit_uh
modifier|*
name|ptr
init|=
operator|(
name|sljit_uh
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
decl_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|inst
operator|>>
literal|16
expr_stmt|;
operator|*
name|ptr
operator|=
name|inst
expr_stmt|;
name|compiler
operator|->
name|size
operator|+=
literal|2
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_imm32_const
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_imm32_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_uw
name|imm
parameter_list|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOVW
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|12
argument_list|,
literal|16
argument_list|,
literal|4
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|11
argument_list|,
literal|26
argument_list|,
literal|1
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|8
argument_list|,
literal|12
argument_list|,
literal|3
argument_list|)
operator||
operator|(
name|imm
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOVT
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|12
operator|+
literal|16
argument_list|,
literal|16
argument_list|,
literal|4
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|11
operator|+
literal|16
argument_list|,
literal|26
argument_list|,
literal|1
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|8
operator|+
literal|16
argument_list|,
literal|12
argument_list|,
literal|3
argument_list|)
operator||
operator|(
operator|(
name|imm
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
operator|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|modify_imm32_const
specifier|static
name|SLJIT_INLINE
name|void
name|modify_imm32_const
parameter_list|(
name|sljit_uh
modifier|*
name|inst
parameter_list|,
name|sljit_uw
name|new_imm
parameter_list|)
block|{
name|sljit_si
name|dst
init|=
name|inst
index|[
literal|1
index|]
operator|&
literal|0x0f00
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xfbf0
operator|)
operator|==
operator|(
name|MOVW
operator|>>
literal|16
operator|)
operator|)
operator|&&
operator|(
operator|(
name|inst
index|[
literal|2
index|]
operator|&
literal|0xfbf0
operator|)
operator|==
operator|(
name|MOVT
operator|>>
literal|16
operator|)
operator|)
operator|&&
name|dst
operator|==
operator|(
name|inst
index|[
literal|3
index|]
operator|&
literal|0x0f00
operator|)
argument_list|)
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|MOVW
operator|>>
literal|16
operator|)
operator||
name|COPY_BITS
argument_list|(
name|new_imm
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|new_imm
argument_list|,
literal|11
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|dst
operator||
name|COPY_BITS
argument_list|(
name|new_imm
argument_list|,
literal|8
argument_list|,
literal|12
argument_list|,
literal|3
argument_list|)
operator||
operator|(
name|new_imm
operator|&
literal|0xff
operator|)
expr_stmt|;
name|inst
index|[
literal|2
index|]
operator|=
operator|(
name|MOVT
operator|>>
literal|16
operator|)
operator||
name|COPY_BITS
argument_list|(
name|new_imm
argument_list|,
literal|12
operator|+
literal|16
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|new_imm
argument_list|,
literal|11
operator|+
literal|16
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inst
index|[
literal|3
index|]
operator|=
name|dst
operator||
name|COPY_BITS
argument_list|(
name|new_imm
argument_list|,
literal|8
operator|+
literal|16
argument_list|,
literal|12
argument_list|,
literal|3
argument_list|)
operator||
operator|(
operator|(
name|new_imm
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|detect_jump_type
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|detect_jump_type
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uh
modifier|*
name|code_ptr
parameter_list|,
name|sljit_uh
modifier|*
name|code
parameter_list|)
block|{
name|sljit_sw
name|diff
decl_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
block|{
comment|/* Branch to ARM code is not optimized yet. */
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|u
operator|.
name|target
operator|&
literal|0x1
operator|)
condition|)
return|return
literal|0
return|;
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|target
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|code_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
call|(
name|sljit_sw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|code_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_BL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|127
operator|&&
name|diff
operator|>=
operator|-
literal|128
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|B_TYPE1
expr_stmt|;
return|return
literal|5
return|;
block|}
if|if
condition|(
name|diff
operator|<=
literal|524287
operator|&&
name|diff
operator|>=
operator|-
literal|524288
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|B_TYPE2
expr_stmt|;
return|return
literal|4
return|;
block|}
comment|/* +1 comes from the prefix IT instruction. */
name|diff
operator|--
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|8388607
operator|&&
name|diff
operator|>=
operator|-
literal|8388608
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|B_TYPE3
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_BL
condition|)
block|{
if|if
condition|(
name|diff
operator|<=
literal|8388607
operator|&&
name|diff
operator|>=
operator|-
literal|8388608
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|BL_TYPE6
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|diff
operator|<=
literal|1023
operator|&&
name|diff
operator|>=
operator|-
literal|1024
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|B_TYPE4
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|diff
operator|<=
literal|8388607
operator|&&
name|diff
operator|>=
operator|-
literal|8388608
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|B_TYPE5
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|inline_set_jump_addr
specifier|static
name|SLJIT_INLINE
name|void
name|inline_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|,
name|sljit_si
name|flush
parameter_list|)
block|{
name|sljit_uh
modifier|*
name|inst
init|=
operator|(
name|sljit_uh
operator|*
operator|)
name|addr
decl_stmt|;
name|modify_imm32_const
argument_list|(
name|inst
argument_list|,
name|new_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|set_jump_instruction
specifier|static
name|SLJIT_INLINE
name|void
name|set_jump_instruction
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|)
block|{
name|sljit_si
name|type
init|=
operator|(
name|jump
operator|->
name|flags
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|sljit_sw
name|diff
decl_stmt|;
name|sljit_uh
modifier|*
name|jump_inst
decl_stmt|;
name|sljit_si
name|s
decl_stmt|,
name|j1
decl_stmt|,
name|j2
decl_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|type
operator|==
literal|0
argument_list|)
condition|)
block|{
name|inline_set_jump_addr
argument_list|(
name|jump
operator|->
name|addr
argument_list|,
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|&
literal|0x1
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|target
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|addr
operator|+
literal|4
argument_list|)
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
else|else
name|diff
operator|=
operator|(
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
argument_list|)
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|addr
operator|+
literal|4
argument_list|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|jump_inst
operator|=
operator|(
name|sljit_uh
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
comment|/* Encoding T1 of 'B' instruction */
name|SLJIT_ASSERT
argument_list|(
name|diff
operator|<=
literal|127
operator|&&
name|diff
operator|>=
operator|-
literal|128
operator|&&
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
operator|)
argument_list|)
expr_stmt|;
name|jump_inst
index|[
literal|0
index|]
operator|=
literal|0xd000
operator||
operator|(
name|jump
operator|->
name|flags
operator|&
literal|0xf00
operator|)
operator||
operator|(
name|diff
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* Encoding T3 of 'B' instruction */
name|SLJIT_ASSERT
argument_list|(
name|diff
operator|<=
literal|524287
operator|&&
name|diff
operator|>=
operator|-
literal|524288
operator|&&
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
operator|)
argument_list|)
expr_stmt|;
name|jump_inst
index|[
literal|0
index|]
operator|=
literal|0xf000
operator||
name|COPY_BITS
argument_list|(
name|jump
operator|->
name|flags
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|,
literal|4
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|diff
argument_list|,
literal|11
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|diff
argument_list|,
literal|19
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jump_inst
index|[
literal|1
index|]
operator|=
literal|0x8000
operator||
name|COPY_BITS
argument_list|(
name|diff
argument_list|,
literal|17
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|diff
argument_list|,
literal|18
argument_list|,
literal|11
argument_list|,
literal|1
argument_list|)
operator||
operator|(
name|diff
operator|&
literal|0x7ff
operator|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
argument_list|)
expr_stmt|;
operator|*
name|jump_inst
operator|++
operator|=
name|IT
operator||
operator|(
operator|(
name|jump
operator|->
name|flags
operator|>>
literal|4
operator|)
operator|&
literal|0xf0
operator|)
operator||
literal|0x8
expr_stmt|;
name|diff
operator|--
expr_stmt|;
name|type
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Encoding T2 of 'B' instruction */
name|SLJIT_ASSERT
argument_list|(
name|diff
operator|<=
literal|1023
operator|&&
name|diff
operator|>=
operator|-
literal|1024
operator|&&
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
operator|)
argument_list|)
expr_stmt|;
name|jump_inst
index|[
literal|0
index|]
operator|=
literal|0xe000
operator||
operator|(
name|diff
operator|&
literal|0x7ff
operator|)
expr_stmt|;
return|return;
block|}
name|SLJIT_ASSERT
argument_list|(
name|diff
operator|<=
literal|8388607
operator|&&
name|diff
operator|>=
operator|-
literal|8388608
argument_list|)
expr_stmt|;
comment|/* Really complex instruction form for branches. */
name|s
operator|=
operator|(
name|diff
operator|>>
literal|23
operator|)
operator|&
literal|0x1
expr_stmt|;
name|j1
operator|=
operator|(
operator|~
operator|(
name|diff
operator|>>
literal|21
operator|)
operator|^
name|s
operator|)
operator|&
literal|0x1
expr_stmt|;
name|j2
operator|=
operator|(
operator|~
operator|(
name|diff
operator|>>
literal|22
operator|)
operator|^
name|s
operator|)
operator|&
literal|0x1
expr_stmt|;
name|jump_inst
index|[
literal|0
index|]
operator|=
literal|0xf000
operator||
operator|(
name|s
operator|<<
literal|10
operator|)
operator||
name|COPY_BITS
argument_list|(
name|diff
argument_list|,
literal|11
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|jump_inst
index|[
literal|1
index|]
operator|=
operator|(
name|j1
operator|<<
literal|13
operator|)
operator||
operator|(
name|j2
operator|<<
literal|11
operator|)
operator||
operator|(
name|diff
operator|&
literal|0x7ff
operator|)
expr_stmt|;
comment|/* The others have a common form. */
if|if
condition|(
name|type
operator|==
literal|5
condition|)
comment|/* Encoding T4 of 'B' instruction */
name|jump_inst
index|[
literal|1
index|]
operator||=
literal|0x9000
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|6
condition|)
comment|/* Encoding T1 of 'BL' instruction */
name|jump_inst
index|[
literal|1
index|]
operator||=
literal|0xd000
expr_stmt|;
else|else
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|sljit_uh
modifier|*
name|code
decl_stmt|;
name|sljit_uh
modifier|*
name|code_ptr
decl_stmt|;
name|sljit_uh
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_uh
modifier|*
name|buf_end
decl_stmt|;
name|sljit_uw
name|half_count
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_uh
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|compiler
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uh
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|code_ptr
operator|=
name|code
expr_stmt|;
name|half_count
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|compiler
operator|->
name|labels
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
do|do
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_uh
operator|*
operator|)
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
operator|(
name|buf
operator|->
name|used_size
operator|>>
literal|1
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|code_ptr
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
comment|/* These structures are ordered by their address. */
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
operator|||
name|label
operator|->
name|size
operator|>=
name|half_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
operator|||
name|jump
operator|->
name|addr
operator|>=
name|half_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
operator|||
name|const_
operator|->
name|addr
operator|>=
name|half_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|half_count
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
operator|(
name|sljit_uw
operator|)
name|code_ptr
operator|)
operator||
literal|0x1
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|&&
name|jump
operator|->
name|addr
operator|==
name|half_count
condition|)
block|{
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
operator|-
operator|(
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
operator|)
condition|?
literal|10
else|:
literal|8
operator|)
expr_stmt|;
name|code_ptr
operator|-=
name|detect_jump_type
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|const_
operator|&&
name|const_
operator|->
name|addr
operator|==
name|half_count
condition|)
block|{
name|const_
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
name|code_ptr
operator|++
expr_stmt|;
name|half_count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
do|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|buf
condition|)
do|;
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|half_count
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
operator|(
name|sljit_uw
operator|)
name|code_ptr
operator|)
operator||
literal|0x1
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|-
name|code
operator|<=
operator|(
name|sljit_sw
operator|)
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
name|set_jump_instruction
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
name|SLJIT_CACHE_FLUSH
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
name|compiler
operator|->
name|executable_size
operator|=
name|compiler
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uh
argument_list|)
expr_stmt|;
comment|/* Set thumb mode flag. */
return|return
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|sljit_uw
operator|)
name|code
operator||
literal|0x1
operator|)
return|;
block|}
end_function
begin_define
DECL|macro|INVALID_IMM
define|#
directive|define
name|INVALID_IMM
value|0x80000000
end_define
begin_function
DECL|function|get_imm
specifier|static
name|sljit_uw
name|get_imm
parameter_list|(
name|sljit_uw
name|imm
parameter_list|)
block|{
comment|/* Thumb immediate form. */
name|sljit_si
name|counter
decl_stmt|;
if|if
condition|(
name|imm
operator|<=
literal|0xff
condition|)
return|return
name|imm
return|;
if|if
condition|(
operator|(
name|imm
operator|&
literal|0xffff
operator|)
operator|==
operator|(
name|imm
operator|>>
literal|16
operator|)
condition|)
block|{
comment|/* Some special cases. */
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xff00
operator|)
condition|)
return|return
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
operator|(
name|imm
operator|&
literal|0xff
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xff
operator|)
condition|)
return|return
operator|(
literal|2
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|imm
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
return|;
if|if
condition|(
operator|(
name|imm
operator|&
literal|0xff00
operator|)
operator|==
operator|(
operator|(
name|imm
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
condition|)
return|return
operator|(
literal|3
operator|<<
literal|12
operator|)
operator||
operator|(
name|imm
operator|&
literal|0xff
operator|)
return|;
block|}
comment|/* Assembly optimization: count leading zeroes? */
name|counter
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xffff0000
operator|)
condition|)
block|{
name|counter
operator|+=
literal|16
expr_stmt|;
name|imm
operator|<<=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|counter
operator|+=
literal|8
expr_stmt|;
name|imm
operator|<<=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|counter
operator|+=
literal|4
expr_stmt|;
name|imm
operator|<<=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|counter
operator|+=
literal|2
expr_stmt|;
name|imm
operator|<<=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|counter
operator|+=
literal|1
expr_stmt|;
name|imm
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* Since imm>= 128, this must be true. */
name|SLJIT_ASSERT
argument_list|(
name|counter
operator|<=
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|&
literal|0x00ffffff
condition|)
return|return
name|INVALID_IMM
return|;
comment|/* Cannot be encoded. */
return|return
operator|(
operator|(
name|imm
operator|>>
literal|24
operator|)
operator|&
literal|0x7f
operator|)
operator||
name|COPY_BITS
argument_list|(
name|counter
argument_list|,
literal|4
argument_list|,
literal|26
argument_list|,
literal|1
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|counter
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
literal|3
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|counter
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|load_immediate
specifier|static
name|sljit_si
name|load_immediate
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_uw
name|imm
parameter_list|)
block|{
name|sljit_uw
name|tmp
decl_stmt|;
if|if
condition|(
name|imm
operator|>=
literal|0x10000
condition|)
block|{
name|tmp
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_WI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|tmp
argument_list|)
return|;
name|tmp
operator|=
name|get_imm
argument_list|(
operator|~
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MVN_WI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|tmp
argument_list|)
return|;
block|}
comment|/* set low 16 bits, set hi 16 bits to 0. */
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOVW
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|12
argument_list|,
literal|16
argument_list|,
literal|4
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|11
argument_list|,
literal|26
argument_list|,
literal|1
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|8
argument_list|,
literal|12
argument_list|,
literal|3
argument_list|)
operator||
operator|(
name|imm
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set hi 16 bit if needed. */
if|if
condition|(
name|imm
operator|>=
literal|0x10000
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOVT
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|12
operator|+
literal|16
argument_list|,
literal|16
argument_list|,
literal|4
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|11
operator|+
literal|16
argument_list|,
literal|26
argument_list|,
literal|1
argument_list|)
operator||
name|COPY_BITS
argument_list|(
name|imm
argument_list|,
literal|8
operator|+
literal|16
argument_list|,
literal|12
argument_list|,
literal|3
argument_list|)
operator||
operator|(
operator|(
name|imm
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
operator|)
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|ARG1_IMM
define|#
directive|define
name|ARG1_IMM
value|0x0010000
end_define
begin_define
DECL|macro|ARG2_IMM
define|#
directive|define
name|ARG2_IMM
value|0x0020000
end_define
begin_define
DECL|macro|KEEP_FLAGS
define|#
directive|define
name|KEEP_FLAGS
value|0x0040000
end_define
begin_define
DECL|macro|SET_MULOV
define|#
directive|define
name|SET_MULOV
value|0x0080000
end_define
begin_comment
comment|/* SET_FLAGS must be 0x100000 as it is also the value of S bit (can be used for optimization). */
end_comment
begin_define
DECL|macro|SET_FLAGS
define|#
directive|define
name|SET_FLAGS
value|0x0100000
end_define
begin_define
DECL|macro|UNUSED_RETURN
define|#
directive|define
name|UNUSED_RETURN
value|0x0200000
end_define
begin_define
DECL|macro|SLOW_DEST
define|#
directive|define
name|SLOW_DEST
value|0x0400000
end_define
begin_define
DECL|macro|SLOW_SRC1
define|#
directive|define
name|SLOW_SRC1
value|0x0800000
end_define
begin_define
DECL|macro|SLOW_SRC2
define|#
directive|define
name|SLOW_SRC2
value|0x1000000
end_define
begin_function
DECL|function|emit_op_imm
specifier|static
name|sljit_si
name|emit_op_imm
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_uw
name|arg1
parameter_list|,
name|sljit_uw
name|arg2
parameter_list|)
block|{
comment|/* dst must be register, TMP_REG1 	   arg1 must be register, TMP_REG1, imm 	   arg2 must be register, TMP_REG2, imm */
name|sljit_si
name|reg
decl_stmt|;
name|sljit_uw
name|imm
decl_stmt|,
name|negated_imm
decl_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|ARG1_IMM
operator||
name|ARG2_IMM
operator|)
operator|)
operator|==
operator|(
name|ARG1_IMM
operator||
name|ARG2_IMM
operator|)
argument_list|)
condition|)
block|{
comment|/* Both are immediates. */
name|flags
operator|&=
operator|~
name|ARG1_IMM
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TMP_REG1
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|ARG1_IMM
operator||
name|ARG2_IMM
operator|)
condition|)
block|{
name|reg
operator|=
operator|(
name|flags
operator|&
name|ARG2_IMM
operator|)
condition|?
name|arg1
else|:
name|arg2
expr_stmt|;
name|imm
operator|=
operator|(
name|flags
operator|&
name|ARG2_IMM
operator|)
condition|?
name|arg2
else|:
name|arg1
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
literal|0xffff
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator|&&
operator|(
name|flags
operator|&
name|ARG2_IMM
operator|)
operator|&&
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
return|return
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|imm
argument_list|)
return|;
case|case
name|SLJIT_NOT
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
return|return
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
operator|~
name|imm
argument_list|)
return|;
comment|/* Since the flags should be set, we just fallback to the register mode. 			   Although I could do some clever things here, "NOT IMM" does not worth the efforts. */
break|break;
case|case
name|SLJIT_CLZ
case|:
comment|/* No form with immediate operand. */
break|break;
case|case
name|SLJIT_ADD
case|:
name|negated_imm
operator|=
operator|(
name|sljit_uw
operator|)
operator|-
operator|(
name|sljit_sw
operator|)
name|imm
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|reg
argument_list|,
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|imm
operator|<=
literal|0x7
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADDSI3
operator||
name|IMM3
argument_list|(
name|imm
argument_list|)
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|negated_imm
operator|<=
literal|0x7
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SUBSI3
operator||
name|IMM3
argument_list|(
name|negated_imm
argument_list|)
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|reg
operator|==
name|dst
condition|)
block|{
if|if
condition|(
name|imm
operator|<=
literal|0xff
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADDSI8
operator||
name|IMM8
argument_list|(
name|imm
argument_list|)
operator||
name|RDN3
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|negated_imm
operator|<=
literal|0xff
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SUBSI8
operator||
name|IMM8
argument_list|(
name|negated_imm
argument_list|)
operator||
name|RDN3
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
block|{
if|if
condition|(
name|imm
operator|<=
literal|0xfff
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADDWI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM12
argument_list|(
name|imm
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|negated_imm
operator|<=
literal|0xfff
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SUBWI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM12
argument_list|(
name|negated_imm
argument_list|)
argument_list|)
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADD_WI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
break|break;
case|case
name|SLJIT_ADDC
case|:
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADCI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
break|break;
case|case
name|SLJIT_SUB
case|:
if|if
condition|(
name|flags
operator|&
name|ARG2_IMM
condition|)
block|{
name|negated_imm
operator|=
operator|(
name|sljit_uw
operator|)
operator|-
operator|(
name|sljit_sw
operator|)
name|imm
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|reg
argument_list|,
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|imm
operator|<=
literal|0x7
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SUBSI3
operator||
name|IMM3
argument_list|(
name|imm
argument_list|)
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|negated_imm
operator|<=
literal|0x7
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADDSI3
operator||
name|IMM3
argument_list|(
name|negated_imm
argument_list|)
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|reg
operator|==
name|dst
condition|)
block|{
if|if
condition|(
name|imm
operator|<=
literal|0xff
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SUBSI8
operator||
name|IMM8
argument_list|(
name|imm
argument_list|)
operator||
name|RDN3
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|negated_imm
operator|<=
literal|0xff
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADDSI8
operator||
name|IMM8
argument_list|(
name|negated_imm
argument_list|)
operator||
name|RDN3
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|imm
operator|<=
literal|0xff
operator|&&
operator|(
name|flags
operator|&
name|UNUSED_RETURN
operator|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|CMPI
operator||
name|IMM8
argument_list|(
name|imm
argument_list|)
operator||
name|RDN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
block|{
if|if
condition|(
name|imm
operator|<=
literal|0xfff
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SUBWI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM12
argument_list|(
name|imm
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|negated_imm
operator|<=
literal|0xfff
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADDWI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM12
argument_list|(
name|negated_imm
argument_list|)
argument_list|)
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SUB_WI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|imm
operator|==
literal|0
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|reg
argument_list|,
name|dst
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|RSBSI
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|RSB_WI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
block|}
break|break;
case|case
name|SLJIT_SUBC
case|:
if|if
condition|(
name|flags
operator|&
name|ARG2_IMM
condition|)
block|{
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SBCI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
block|}
break|break;
case|case
name|SLJIT_MUL
case|:
comment|/* No form with immediate operand. */
break|break;
case|case
name|SLJIT_AND
case|:
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ANDI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
name|imm
operator|=
name|get_imm
argument_list|(
operator|~
operator|(
operator|(
name|flags
operator|&
name|ARG2_IMM
operator|)
condition|?
name|arg2
else|:
name|arg1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|BICI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
break|break;
case|case
name|SLJIT_OR
case|:
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ORRI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
name|imm
operator|=
name|get_imm
argument_list|(
operator|~
operator|(
operator|(
name|flags
operator|&
name|ARG2_IMM
operator|)
condition|?
name|arg2
else|:
name|arg1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ORNI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
break|break;
case|case
name|SLJIT_XOR
case|:
name|imm
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|EORI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|imm
argument_list|)
return|;
break|break;
case|case
name|SLJIT_SHL
case|:
if|if
condition|(
name|flags
operator|&
name|ARG2_IMM
condition|)
block|{
name|imm
operator|&=
literal|0x1f
expr_stmt|;
if|if
condition|(
name|imm
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOVS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_W
operator||
name|SET_FLAGS
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|LSLSI
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
operator||
operator|(
name|imm
operator|<<
literal|6
operator|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|LSL_WI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM5
argument_list|(
name|imm
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SLJIT_LSHR
case|:
if|if
condition|(
name|flags
operator|&
name|ARG2_IMM
condition|)
block|{
name|imm
operator|&=
literal|0x1f
expr_stmt|;
if|if
condition|(
name|imm
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOVS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_W
operator||
name|SET_FLAGS
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|LSRSI
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
operator||
operator|(
name|imm
operator|<<
literal|6
operator|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|LSR_WI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM5
argument_list|(
name|imm
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SLJIT_ASHR
case|:
if|if
condition|(
name|flags
operator|&
name|ARG2_IMM
condition|)
block|{
name|imm
operator|&=
literal|0x1f
expr_stmt|;
if|if
condition|(
name|imm
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOVS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_W
operator||
name|SET_FLAGS
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ASRSI
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|reg
argument_list|)
operator||
operator|(
name|imm
operator|<<
literal|6
operator|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ASR_WI
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM5
argument_list|(
name|imm
argument_list|)
argument_list|)
return|;
block|}
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|ARG2_IMM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TMP_REG2
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TMP_REG1
expr_stmt|;
block|}
block|}
comment|/* Both arguments are registers. */
switch|switch
condition|(
name|flags
operator|&
literal|0xffff
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
case|case
name|SLJIT_MOV_P
case|:
case|case
name|SLJIT_MOVU
case|:
case|case
name|SLJIT_MOVU_UI
case|:
case|case
name|SLJIT_MOVU_SI
case|:
case|case
name|SLJIT_MOVU_P
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator|&&
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_UB
case|:
case|case
name|SLJIT_MOVU_UB
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator|&&
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|UXTB
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|UXTB_W
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_SB
case|:
case|case
name|SLJIT_MOVU_SB
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator|&&
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SXTB
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SXTB_W
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_UH
case|:
case|case
name|SLJIT_MOVU_UH
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator|&&
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|UXTH
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|UXTH_W
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_SH
case|:
case|case
name|SLJIT_MOVU_SH
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator|&&
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SXTH
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SXTH_W
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_NOT
case|:
name|SLJIT_ASSERT
argument_list|(
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MVNS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MVN_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_CLZ
case|:
name|SLJIT_ASSERT
argument_list|(
name|arg1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|CLZ
operator||
name|RN4
argument_list|(
name|arg2
argument_list|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SET_FLAGS
condition|)
block|{
if|if
condition|(
name|reg_map
index|[
name|dst
index|]
operator|<=
literal|7
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|CMPI
operator||
name|RDN3
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADD_WI
operator||
name|SET_FLAGS
operator||
name|RN4
argument_list|(
name|dst
argument_list|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_ADD
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_3_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADDS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg1
argument_list|)
operator||
name|RM3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|SET_REGS44
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADD_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_ADDC
case|:
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADCS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADC_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_3_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SUBS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg1
argument_list|)
operator||
name|RM3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SUB_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_SUBC
case|:
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SBCS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SBC_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_MUL
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MUL
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
name|SLJIT_ASSERT
argument_list|(
name|reg_map
index|[
name|TMP_REG2
index|]
operator|<=
literal|7
operator|&&
name|dst
operator|!=
name|TMP_REG2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SMULL
operator||
name|RT4
argument_list|(
name|dst
argument_list|)
operator||
name|RD4
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cmp TMP_REG2, dst asr #31. */
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|CMP_W
operator||
name|RN4
argument_list|(
name|TMP_REG2
argument_list|)
operator||
literal|0x70e0
operator||
name|RM4
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ANDS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|UNUSED_RETURN
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|TST
operator||
name|RD3
argument_list|(
name|arg1
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
block|}
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|AND_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_OR
case|:
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ORRS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ORR_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_XOR
case|:
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|EORS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|EOR_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_SHL
case|:
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|LSLS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|LSL_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_LSHR
case|:
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|LSRS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|LSR_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_ASHR
case|:
if|if
condition|(
name|dst
operator|==
name|arg1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|KEEP_FLAGS
operator|)
operator|&&
name|IS_2_LO_REGS
argument_list|(
name|dst
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ASRS
operator||
name|RD3
argument_list|(
name|dst
argument_list|)
operator||
name|RN3
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ASR_W
operator||
operator|(
name|flags
operator|&
name|SET_FLAGS
operator|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|arg1
argument_list|)
operator||
name|RM4
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
block|}
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|STORE
define|#
directive|define
name|STORE
value|0x01
end_define
begin_define
DECL|macro|SIGNED
define|#
directive|define
name|SIGNED
value|0x02
end_define
begin_define
DECL|macro|WORD_SIZE
define|#
directive|define
name|WORD_SIZE
value|0x00
end_define
begin_define
DECL|macro|BYTE_SIZE
define|#
directive|define
name|BYTE_SIZE
value|0x04
end_define
begin_define
DECL|macro|HALF_SIZE
define|#
directive|define
name|HALF_SIZE
value|0x08
end_define
begin_define
DECL|macro|UPDATE
define|#
directive|define
name|UPDATE
value|0x10
end_define
begin_define
DECL|macro|ARG_TEST
define|#
directive|define
name|ARG_TEST
value|0x20
end_define
begin_define
DECL|macro|IS_WORD_SIZE
define|#
directive|define
name|IS_WORD_SIZE
parameter_list|(
name|flags
parameter_list|)
value|(!(flags& (BYTE_SIZE | HALF_SIZE)))
end_define
begin_define
DECL|macro|OFFSET_CHECK
define|#
directive|define
name|OFFSET_CHECK
parameter_list|(
name|imm
parameter_list|,
name|shift
parameter_list|)
value|(!(argw& ~(imm<< shift)))
end_define
begin_comment
comment|/*   1st letter:   w = word   b = byte   h = half    2nd letter:   s = signed   u = unsigned    3rd letter:   l = load   s = store */
end_comment
begin_decl_stmt
DECL|variable|sljit_mem16
specifier|static
name|SLJIT_CONST
name|sljit_uw
name|sljit_mem16
index|[
literal|12
index|]
init|=
block|{
comment|/* w u l */
literal|0x5800
comment|/* ldr */
block|,
comment|/* w u s */
literal|0x5000
comment|/* str */
block|,
comment|/* w s l */
literal|0x5800
comment|/* ldr */
block|,
comment|/* w s s */
literal|0x5000
comment|/* str */
block|,
comment|/* b u l */
literal|0x5c00
comment|/* ldrb */
block|,
comment|/* b u s */
literal|0x5400
comment|/* strb */
block|,
comment|/* b s l */
literal|0x5600
comment|/* ldrsb */
block|,
comment|/* b s s */
literal|0x5400
comment|/* strb */
block|,
comment|/* h u l */
literal|0x5a00
comment|/* ldrh */
block|,
comment|/* h u s */
literal|0x5200
comment|/* strh */
block|,
comment|/* h s l */
literal|0x5e00
comment|/* ldrsh */
block|,
comment|/* h s s */
literal|0x5200
comment|/* strh */
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sljit_mem16_imm5
specifier|static
name|SLJIT_CONST
name|sljit_uw
name|sljit_mem16_imm5
index|[
literal|12
index|]
init|=
block|{
comment|/* w u l */
literal|0x6800
comment|/* ldr imm5 */
block|,
comment|/* w u s */
literal|0x6000
comment|/* str imm5 */
block|,
comment|/* w s l */
literal|0x6800
comment|/* ldr imm5 */
block|,
comment|/* w s s */
literal|0x6000
comment|/* str imm5 */
block|,
comment|/* b u l */
literal|0x7800
comment|/* ldrb imm5 */
block|,
comment|/* b u s */
literal|0x7000
comment|/* strb imm5 */
block|,
comment|/* b s l */
literal|0x0000
comment|/* not allowed */
block|,
comment|/* b s s */
literal|0x7000
comment|/* strb imm5 */
block|,
comment|/* h u l */
literal|0x8800
comment|/* ldrh imm5 */
block|,
comment|/* h u s */
literal|0x8000
comment|/* strh imm5 */
block|,
comment|/* h s l */
literal|0x0000
comment|/* not allowed */
block|,
comment|/* h s s */
literal|0x8000
comment|/* strh imm5 */
block|, }
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|MEM_IMM8
define|#
directive|define
name|MEM_IMM8
value|0xc00
end_define
begin_define
DECL|macro|MEM_IMM12
define|#
directive|define
name|MEM_IMM12
value|0x800000
end_define
begin_decl_stmt
DECL|variable|sljit_mem32
specifier|static
name|SLJIT_CONST
name|sljit_uw
name|sljit_mem32
index|[
literal|12
index|]
init|=
block|{
comment|/* w u l */
literal|0xf8500000
comment|/* ldr.w */
block|,
comment|/* w u s */
literal|0xf8400000
comment|/* str.w */
block|,
comment|/* w s l */
literal|0xf8500000
comment|/* ldr.w */
block|,
comment|/* w s s */
literal|0xf8400000
comment|/* str.w */
block|,
comment|/* b u l */
literal|0xf8100000
comment|/* ldrb.w */
block|,
comment|/* b u s */
literal|0xf8000000
comment|/* strb.w */
block|,
comment|/* b s l */
literal|0xf9100000
comment|/* ldrsb.w */
block|,
comment|/* b s s */
literal|0xf8000000
comment|/* strb.w */
block|,
comment|/* h u l */
literal|0xf8300000
comment|/* ldrh.w */
block|,
comment|/* h u s */
literal|0xf8200000
comment|/* strsh.w */
block|,
comment|/* h s l */
literal|0xf9300000
comment|/* ldrsh.w */
block|,
comment|/* h s s */
literal|0xf8200000
comment|/* strsh.w */
block|, }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Helper function. Dst should be reg + value, using at most 1 instruction, flags does not set. */
end_comment
begin_function
DECL|function|emit_set_delta
specifier|static
name|sljit_si
name|emit_set_delta
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_sw
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|<=
literal|0xfff
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADDWI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM12
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
name|value
operator|=
name|get_imm
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADD_WI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|value
argument_list|)
return|;
block|}
else|else
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|<=
literal|0xfff
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SUBWI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|IMM12
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
name|value
operator|=
name|get_imm
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|INVALID_IMM
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SUB_WI
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
name|RN4
argument_list|(
name|reg
argument_list|)
operator||
name|value
argument_list|)
return|;
block|}
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_comment
comment|/* Can perform an operation using at most 1 instruction. */
end_comment
begin_function
DECL|function|getput_arg_fast
specifier|static
name|sljit_si
name|getput_arg_fast
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|sljit_si
name|tmp
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|UPDATE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf
operator|)
operator|&&
operator|!
operator|(
name|arg
operator|&
literal|0xf0
operator|)
operator|&&
name|argw
operator|<=
literal|0xff
operator|&&
name|argw
operator|>=
operator|-
literal|0xff
condition|)
block|{
name|flags
operator|&=
operator|~
name|UPDATE
expr_stmt|;
name|arg
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|ARG_TEST
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|argw
operator|>=
literal|0
condition|)
name|argw
operator||=
literal|0x200
expr_stmt|;
else|else
block|{
name|argw
operator|=
operator|-
name|argw
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
name|argw
operator|>=
literal|0
operator|&&
operator|(
name|argw
operator|&
literal|0xff
operator|)
operator|<=
literal|0xff
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM8
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
literal|0x100
operator||
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|flags
operator|&
name|ARG_TEST
operator|)
condition|?
name|SLJIT_SUCCESS
else|:
literal|0
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|&
literal|0xf0
argument_list|)
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
name|tmp
operator|=
operator|(
name|arg
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|arg
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|ARG_TEST
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|argw
operator|&&
name|IS_3_LO_REGS
argument_list|(
name|reg
argument_list|,
name|arg
argument_list|,
name|tmp
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|sljit_mem16
index|[
name|flags
index|]
operator||
name|RD3
argument_list|(
name|reg
argument_list|)
operator||
name|RN3
argument_list|(
name|arg
argument_list|)
operator||
name|RM3
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|RM4
argument_list|(
name|tmp
argument_list|)
operator||
operator|(
name|argw
operator|<<
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf
operator|)
operator|||
name|argw
operator|>
literal|0xfff
operator|||
name|argw
operator|<
operator|-
literal|0xff
condition|)
return|return
operator|(
name|flags
operator|&
name|ARG_TEST
operator|)
condition|?
name|SLJIT_SUCCESS
else|:
literal|0
return|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|ARG_TEST
argument_list|)
condition|)
return|return
literal|1
return|;
name|arg
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|IS_2_LO_REGS
argument_list|(
name|reg
argument_list|,
name|arg
argument_list|)
operator|&&
name|sljit_mem16_imm5
index|[
name|flags
index|]
condition|)
block|{
name|tmp
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|IS_WORD_SIZE
argument_list|(
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|OFFSET_CHECK
argument_list|(
literal|0x1f
argument_list|,
literal|2
argument_list|)
condition|)
name|tmp
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|BYTE_SIZE
condition|)
block|{
if|if
condition|(
name|OFFSET_CHECK
argument_list|(
literal|0x1f
argument_list|,
literal|0
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|flags
operator|&
name|HALF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OFFSET_CHECK
argument_list|(
literal|0x1f
argument_list|,
literal|1
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|!=
literal|3
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|sljit_mem16_imm5
index|[
name|flags
index|]
operator||
name|RD3
argument_list|(
name|reg
argument_list|)
operator||
name|RN3
argument_list|(
name|arg
argument_list|)
operator||
operator|(
name|argw
operator|<<
operator|(
literal|6
operator|-
name|tmp
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* SP based immediate. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|==
name|SLJIT_LOCALS_REG
argument_list|)
operator|&&
name|OFFSET_CHECK
argument_list|(
literal|0xff
argument_list|,
literal|2
argument_list|)
operator|&&
name|IS_WORD_SIZE
argument_list|(
name|flags
argument_list|)
operator|&&
name|reg_map
index|[
name|reg
index|]
operator|<=
literal|7
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|STR_SP
operator||
operator|(
operator|(
name|flags
operator|&
name|STORE
operator|)
condition|?
literal|0
else|:
literal|0x800
operator|)
operator||
name|RDN3
argument_list|(
name|reg
argument_list|)
operator||
operator|(
name|argw
operator|>>
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|argw
operator|>=
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM12
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|argw
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM8
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
operator|-
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/* see getput_arg below.    Note: can_cache is called only for binary operators. Those    operators always uses word arguments without write back. */
end_comment
begin_function
DECL|function|can_cache
specifier|static
name|sljit_si
name|can_cache
parameter_list|(
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
comment|/* Simple operation except for updates. */
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf0
operator|)
operator|||
operator|!
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf
operator|)
condition|)
block|{
if|if
condition|(
call|(
name|sljit_uw
call|)
argument_list|(
name|argw
operator|-
name|next_argw
argument_list|)
operator|<=
literal|0xfff
operator|||
call|(
name|sljit_uw
call|)
argument_list|(
name|next_argw
operator|-
name|argw
argument_list|)
operator|<=
literal|0xfff
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|argw
operator|==
name|next_argw
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
operator|(
call|(
name|sljit_uw
call|)
argument_list|(
name|argw
operator|-
name|next_argw
argument_list|)
operator|<=
literal|0xfff
operator|||
call|(
name|sljit_uw
call|)
argument_list|(
name|next_argw
operator|-
name|argw
argument_list|)
operator|<=
literal|0xfff
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Emit the necessary instructions. See can_cache above. */
end_comment
begin_function
DECL|function|getput_arg
specifier|static
name|sljit_si
name|getput_arg
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|sljit_si
name|tmp_r
decl_stmt|;
name|sljit_sw
name|tmp
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|next_arg
operator|=
literal|0
expr_stmt|;
name|next_argw
operator|=
literal|0
expr_stmt|;
block|}
name|tmp_r
operator|=
operator|(
name|flags
operator|&
name|STORE
operator|)
condition|?
name|TMP_REG3
else|:
name|reg
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|UPDATE
argument_list|)
condition|)
block|{
name|flags
operator|&=
operator|~
name|UPDATE
expr_stmt|;
comment|/* Update only applies if a base register exists. */
if|if
condition|(
name|arg
operator|&
literal|0xf
condition|)
block|{
comment|/* There is no caching here. */
name|tmp
operator|=
operator|(
name|arg
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
name|arg
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|argw
operator|&
operator|~
literal|0xfff
operator|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM12
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADDWI
operator||
name|RD4
argument_list|(
name|arg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|IMM12
argument_list|(
name|argw
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|argw
operator|==
name|compiler
operator|->
name|cache_argw
condition|)
block|{
name|tmp
operator|=
name|TMP_REG3
expr_stmt|;
name|argw
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|emit_set_delta
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|tmp
operator|=
name|TMP_REG3
expr_stmt|;
name|argw
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argw
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|tmp
operator|=
name|TMP_REG3
expr_stmt|;
name|argw
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|argw
operator|&=
literal|0x3
expr_stmt|;
if|if
condition|(
operator|!
name|argw
operator|&&
name|IS_3_LO_REGS
argument_list|(
name|reg
argument_list|,
name|arg
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|sljit_mem16
index|[
name|flags
index|]
operator||
name|RD3
argument_list|(
name|reg
argument_list|)
operator||
name|RN3
argument_list|(
name|arg
argument_list|)
operator||
name|RM3
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|SET_REGS44
argument_list|(
name|arg
argument_list|,
name|tmp
argument_list|)
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|RM4
argument_list|(
name|tmp
argument_list|)
operator||
operator|(
name|argw
operator|<<
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADD_W
operator||
name|RD4
argument_list|(
name|arg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|RM4
argument_list|(
name|tmp
argument_list|)
operator||
operator|(
name|argw
operator|<<
literal|6
operator|)
argument_list|)
return|;
block|}
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|arg
operator|&
literal|0xf0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|)
operator|&
operator|~
literal|0xfff
operator|)
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM12
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
operator|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|compiler
operator|->
name|cache_argw
operator|-
name|argw
operator|)
operator|&
operator|~
literal|0xff
operator|)
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM8
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
operator|(
name|compiler
operator|->
name|cache_argw
operator|-
name|argw
operator|)
argument_list|)
return|;
if|if
condition|(
name|emit_set_delta
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM12
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
literal|0
argument_list|)
return|;
block|}
block|}
name|next_arg
operator|=
operator|(
name|arg
operator|&
literal|0xf
operator|)
operator|&&
operator|(
name|arg
operator|==
name|next_arg
operator|)
expr_stmt|;
name|arg
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|arg
operator|&&
name|compiler
operator|->
name|cache_arg
operator|==
name|SLJIT_MEM
operator|&&
name|compiler
operator|->
name|cache_argw
operator|==
name|argw
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|RM4
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
return|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
if|if
condition|(
name|next_arg
operator|&&
name|emit_set_delta
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
operator||
name|arg
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
expr_stmt|;
if|if
condition|(
name|next_arg
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|SET_REGS44
argument_list|(
name|TMP_REG3
argument_list|,
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
operator||
name|arg
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arg
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
argument_list|)
operator||
name|RM4
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|sljit_mem32
index|[
name|flags
index|]
operator||
name|MEM_IMM12
operator||
name|RT4
argument_list|(
name|reg
argument_list|)
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem2
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg1
parameter_list|,
name|sljit_sw
name|arg1w
parameter_list|,
name|sljit_si
name|arg2
parameter_list|,
name|sljit_sw
name|arg2w
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|,
name|arg2
argument_list|,
name|arg2w
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Entry, exit                                                          */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|;
name|sljit_ins
name|push
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|push
operator|=
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|5
condition|)
name|push
operator||=
literal|1
operator|<<
literal|11
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|4
condition|)
name|push
operator||=
literal|1
operator|<<
literal|10
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|3
condition|)
name|push
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|2
condition|)
name|push
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|1
condition|)
name|push
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|scratches
operator|>=
literal|5
condition|)
name|push
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
name|FAIL_IF
argument_list|(
name|saveds
operator|>=
literal|3
condition|?
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|PUSH_W
operator||
operator|(
literal|1
operator|<<
literal|14
operator|)
operator||
name|push
argument_list|)
else|:
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|PUSH
operator||
name|push
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stack must be aligned to 8 bytes: */
name|size
operator|=
operator|(
literal|3
operator|+
name|saveds
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|local_size
operator|+=
name|size
expr_stmt|;
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|local_size
operator|-=
name|size
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
if|if
condition|(
name|local_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|local_size
operator|<=
operator|(
literal|127
operator|<<
literal|2
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|SUB_SP
operator||
operator|(
name|local_size
operator|>>
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|emit_op_imm
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
operator||
name|ARG2_IMM
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|;
name|CHECK_ERROR_VOID
argument_list|()
expr_stmt|;
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
operator|(
literal|3
operator|+
name|saveds
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|local_size
operator|+=
name|size
expr_stmt|;
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|local_size
operator|-=
name|size
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ins
name|pop
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|<=
operator|(
literal|127
operator|<<
literal|2
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADD_SP
operator||
operator|(
name|compiler
operator|->
name|local_size
operator|>>
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|emit_op_imm
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
operator||
name|ARG2_IMM
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pop
operator|=
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|5
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|11
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|4
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|10
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|3
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|2
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|1
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|5
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
return|return
name|compiler
operator|->
name|saveds
operator|>=
literal|3
condition|?
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|POP_W
operator||
operator|(
literal|1
operator|<<
literal|15
operator|)
operator||
name|pop
argument_list|)
else|:
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|POP
operator||
name|pop
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
specifier|extern
name|unsigned
name|int
name|__aeabi_uidivmod
parameter_list|(
name|unsigned
name|int
name|numerator
parameter_list|,
name|int
name|unsigned
name|denominator
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__aeabi_idivmod
parameter_list|(
name|int
name|numerator
parameter_list|,
name|int
name|denominator
parameter_list|)
function_decl|;
else|#
directive|else
error|#
directive|error
literal|"Software divmod functions are needed"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_BREAKPOINT
case|:
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|BKPT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_NOP
case|:
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_UMUL
case|:
case|case
name|SLJIT_SMUL
case|:
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UMUL
condition|?
name|UMULL
else|:
name|SMULL
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<<
literal|16
operator|)
operator||
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
argument_list|)
return|;
case|case
name|SLJIT_UDIV
case|:
case|case
name|SLJIT_SDIV
case|:
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|4
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
literal|0xf84d2d04
comment|/* str r2, [sp, #-4]! */
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
literal|0xf84dcd04
comment|/* str ip, [sp, #-4]! */
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
literal|0xf84d2d08
comment|/* str r2, [sp, #-8]! */
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|FAIL_IF
argument_list|(
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_FAST_CALL
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UDIV
condition|?
name|SLJIT_FUNC_OFFSET
argument_list|(
name|__aeabi_uidivmod
argument_list|)
else|:
name|SLJIT_FUNC_OFFSET
argument_list|(
name|__aeabi_idivmod
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Software divmod functions are needed"
endif|#
directive|endif
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|4
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
literal|0xf85dcb04
comment|/* ldr ip, [sp], #4 */
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
literal|0xf85d2b04
comment|/* ldr r2, [sp], #4 */
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|3
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
literal|0xf85d2b08
comment|/* ldr r2, [sp], #8 */
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|,
name|flags
decl_stmt|;
name|sljit_si
name|op_flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_SCRATCH_REG1
operator|&&
name|dst
operator|<=
name|TMP_REG3
operator|)
condition|?
name|dst
else|:
name|TMP_REG1
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_P
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
case|case
name|SLJIT_MOV_P
case|:
name|flags
operator|=
name|WORD_SIZE
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UB
case|:
name|flags
operator|=
name|BYTE_SIZE
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_ub
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SB
case|:
name|flags
operator|=
name|BYTE_SIZE
operator||
name|SIGNED
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_sb
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UH
case|:
name|flags
operator|=
name|HALF_SIZE
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_uh
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SH
case|:
name|flags
operator|=
name|HALF_SIZE
operator||
name|SIGNED
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_sh
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOVU
case|:
case|case
name|SLJIT_MOVU_UI
case|:
case|case
name|SLJIT_MOVU_SI
case|:
case|case
name|SLJIT_MOVU_P
case|:
name|flags
operator|=
name|WORD_SIZE
operator||
name|UPDATE
expr_stmt|;
break|break;
case|case
name|SLJIT_MOVU_UB
case|:
name|flags
operator|=
name|BYTE_SIZE
operator||
name|UPDATE
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_ub
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOVU_SB
case|:
name|flags
operator|=
name|BYTE_SIZE
operator||
name|SIGNED
operator||
name|UPDATE
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_sb
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOVU_UH
case|:
name|flags
operator|=
name|HALF_SIZE
operator||
name|UPDATE
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_uh
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOVU_SH
case|:
name|flags
operator|=
name|HALF_SIZE
operator||
name|SIGNED
operator||
name|UPDATE
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_sh
operator|)
name|srcw
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_imm
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
operator||
name|ARG2_IMM
argument_list|,
name|dst_r
argument_list|,
name|TMP_REG1
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dst_r
operator|!=
name|TMP_REG1
condition|)
return|return
name|emit_op_imm
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst_r
argument_list|,
name|TMP_REG1
argument_list|,
name|src
argument_list|)
return|;
name|dst_r
operator|=
name|src
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|STORE
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
else|else
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|STORE
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|op
operator|==
name|SLJIT_NEG
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
operator||
name|op_flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
name|flags
operator|=
operator|(
name|GET_FLAGS
argument_list|(
name|op_flags
argument_list|)
condition|?
name|SET_FLAGS
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|op_flags
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
name|KEEP_FLAGS
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG2
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|flags
operator||=
name|ARG2_IMM
expr_stmt|;
else|else
name|srcw
operator|=
name|src
expr_stmt|;
name|emit_op_imm
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|op
argument_list|,
name|dst_r
argument_list|,
name|TMP_REG1
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|STORE
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
else|else
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|STORE
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|,
name|flags
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_SCRATCH_REG1
operator|&&
name|dst
operator|<=
name|TMP_REG3
operator|)
condition|?
name|dst
else|:
name|TMP_REG1
expr_stmt|;
name|flags
operator|=
operator|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|?
name|SET_FLAGS
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
name|KEEP_FLAGS
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|!
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
operator||
name|ARG_TEST
argument_list|,
name|TMP_REG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
name|flags
operator||=
name|SLOW_DEST
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC1
expr_stmt|;
block|}
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
operator|)
operator|==
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
name|src1
operator|=
name|TMP_REG1
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
name|src2
operator|=
name|TMP_REG2
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
name|flags
operator||=
name|ARG1_IMM
expr_stmt|;
else|else
name|src1w
operator|=
name|src1
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
name|flags
operator||=
name|ARG2_IMM
expr_stmt|;
else|else
name|src2w
operator|=
name|src2
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
name|flags
operator||=
name|UNUSED_RETURN
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MUL
operator|&&
operator|(
name|op
operator|&
name|SLJIT_SET_O
operator|)
condition|)
name|flags
operator||=
name|SET_MULOV
expr_stmt|;
name|emit_op_imm
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst_r
argument_list|,
name|src1w
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SLOW_DEST
operator|)
condition|)
block|{
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
return|return
name|compiler
operator|->
name|error
return|;
block|}
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
argument_list|,
name|TMP_REG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|check_sljit_get_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|reg_map
index|[
name|reg
index|]
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_custom
argument_list|(
name|compiler
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
operator|*
operator|(
name|sljit_uh
operator|*
operator|)
name|instruction
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
operator|*
operator|(
name|sljit_ins
operator|*
operator|)
name|instruction
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Floating point operators                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function
begin_define
DECL|macro|FPU_LOAD
define|#
directive|define
name|FPU_LOAD
value|(1<< 20)
end_define
begin_function
DECL|function|emit_fop_mem
specifier|static
name|sljit_si
name|emit_fop_mem
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|sljit_sw
name|tmp
decl_stmt|;
name|sljit_uw
name|imm
decl_stmt|;
name|sljit_sw
name|inst
init|=
name|VSTR_F32
operator||
operator|(
name|flags
operator|&
operator|(
name|SLJIT_SINGLE_OP
operator||
name|FPU_LOAD
operator|)
operator|)
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
comment|/* Fast loads and stores. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|&
literal|0xf0
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADD_W
operator||
name|RD4
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|RM4
argument_list|(
operator|(
name|arg
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
argument_list|)
operator||
operator|(
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|SLJIT_MEM
operator||
name|TMP_REG2
expr_stmt|;
name|argw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf
operator|)
operator|&&
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|argw
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
literal|0x800000
operator||
name|RN4
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
operator||
operator|(
name|argw
operator|>>
literal|2
operator|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|-
name|argw
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
name|RN4
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
operator||
operator|(
operator|-
name|argw
operator|>>
literal|2
operator|)
argument_list|)
return|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|arg
operator|&
literal|0xf0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
condition|)
block|{
name|tmp
operator|=
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
literal|0x800000
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
operator||
operator|(
name|tmp
operator|>>
literal|2
operator|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|-
name|tmp
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
operator||
operator|(
operator|-
name|tmp
operator|>>
literal|2
operator|)
argument_list|)
return|;
if|if
condition|(
name|emit_set_delta
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|TMP_REG3
argument_list|,
name|tmp
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
literal|0x800000
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|arg
operator|&
literal|0xf
condition|)
block|{
if|if
condition|(
name|emit_set_delta
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|argw
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
literal|0x800000
operator||
name|RN4
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
name|argw
operator|&
operator|~
literal|0x3fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ADD_WI
operator||
name|RD4
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|imm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
literal|0x800000
operator||
name|RN4
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
operator||
operator|(
operator|(
name|argw
operator|&
literal|0x3fc
operator|)
operator|>>
literal|2
operator|)
argument_list|)
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
operator|-
name|argw
operator|&
operator|~
literal|0x3fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
name|INVALID_IMM
condition|)
block|{
name|argw
operator|=
operator|-
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|SUB_WI
operator||
name|RD4
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|RN4
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|imm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
name|RN4
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
operator||
operator|(
operator|(
name|argw
operator|&
literal|0x3fc
operator|)
operator|>>
literal|2
operator|)
argument_list|)
return|;
block|}
block|}
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|(
name|arg
operator|&
literal|0xf
operator|)
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|&
literal|0xf
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|SET_REGS44
argument_list|(
name|TMP_REG3
argument_list|,
operator|(
name|arg
operator|&
literal|0xf
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
literal|0x800000
operator||
name|RN4
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|DD4
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
operator|(
name|SLJIT_SINGLE_OP
operator|==
literal|0x100
operator|)
argument_list|,
name|float_transfer_bit_error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|op
operator|^=
name|SLJIT_SINGLE_OP
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CMPD
condition|)
block|{
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|dst
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VCMP_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst
argument_list|)
operator||
name|DM4
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VMRS
argument_list|)
return|;
block|}
name|dst_r
operator|=
operator|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
operator|)
condition|?
name|TMP_FREG1
else|:
name|dst
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst_r
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOVD
case|:
if|if
condition|(
name|src
operator|!=
name|dst_r
condition|)
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VMOV_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst_r
argument_list|)
operator||
name|DM4
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_NEGD
case|:
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VNEG_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst_r
argument_list|)
operator||
name|DM4
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_ABSD
case|:
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VABS_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst_r
argument_list|)
operator||
name|DM4
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
return|return
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|op
operator|^=
name|SLJIT_SINGLE_OP
expr_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
operator|)
condition|?
name|TMP_FREG1
else|:
name|dst
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
block|{
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
block|{
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADDD
case|:
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VADD_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst_r
argument_list|)
operator||
name|DN4
argument_list|(
name|src1
argument_list|)
operator||
name|DM4
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_SUBD
case|:
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VSUB_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst_r
argument_list|)
operator||
name|DN4
argument_list|(
name|src1
argument_list|)
operator||
name|DM4
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MULD
case|:
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VMUL_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst_r
argument_list|)
operator||
name|DN4
argument_list|(
name|src1
argument_list|)
operator||
name|DM4
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DIVD
case|:
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|VDIV_F32
operator||
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|DD4
argument_list|(
name|dst_r
argument_list|)
operator||
name|DN4
argument_list|(
name|src1
argument_list|)
operator||
name|DM4
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
return|return
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_undef
DECL|macro|FPU_LOAD
undef|#
directive|undef
name|FPU_LOAD
end_undef
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Other instructions                                                   */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|dst
operator|<=
name|TMP_REG3
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|dst
argument_list|,
name|TMP_REG3
argument_list|)
argument_list|)
return|;
comment|/* Memory. */
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
argument_list|,
name|TMP_REG3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
comment|/* TMP_REG3 is used for caching. */
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|TMP_REG2
argument_list|,
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|<=
name|TMP_REG3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|TMP_REG3
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG3
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
block|{
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOV
operator||
name|SET_REGS44
argument_list|(
name|TMP_REG3
argument_list|,
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|BLX
operator||
name|RN3
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Conditional instructions                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|get_cc
specifier|static
name|sljit_uw
name|get_cc
parameter_list|(
name|sljit_si
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
return|return
literal|0x0
return|;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
return|return
literal|0x1
return|;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
return|return
literal|0x3
return|;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
return|return
literal|0x2
return|;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
return|return
literal|0x8
return|;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
return|return
literal|0x9
return|;
case|case
name|SLJIT_C_SIG_LESS
case|:
return|return
literal|0xb
return|;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
return|return
literal|0xa
return|;
case|case
name|SLJIT_C_SIG_GREATER
case|:
return|return
literal|0xc
return|;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
return|return
literal|0xd
return|;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
return|return
literal|0x6
return|;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
return|return
literal|0x7
return|;
default|default:
comment|/* SLJIT_JUMP */
return|return
literal|0xe
return|;
block|}
block|}
end_function
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_si
name|cc
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
comment|/* In ARM, we don't need to touch the arguments. */
name|PTR_FAIL_IF
argument_list|(
name|emit_imm32_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
name|SLJIT_JUMP
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|IS_COND
expr_stmt|;
name|cc
operator|=
name|get_cc
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|cc
operator|<<
literal|8
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|IT
operator||
operator|(
name|cc
operator|<<
literal|4
operator|)
operator||
literal|0x8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|SLJIT_JUMP
condition|)
name|PTR_FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|BX
operator||
name|RN3
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|jump
operator|->
name|flags
operator||=
name|IS_BL
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|BLX
operator||
name|RN3
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|jump
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
comment|/* In ARM, we don't need to touch the arguments. */
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
operator||
operator|(
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
operator|)
condition|?
name|IS_BL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_imm32_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|BX
else|:
name|BLX
operator|)
operator||
name|RN3
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
operator|<=
name|TMP_REG3
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|BX
else|:
name|BLX
operator|)
operator||
name|RN3
argument_list|(
name|src
argument_list|)
argument_list|)
return|;
name|FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|TMP_PC
else|:
name|TMP_REG1
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|BLX
operator||
name|RN3
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|,
name|flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|sljit_ins
name|ins
decl_stmt|;
name|sljit_uw
name|cc
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_flags
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|cc
operator|=
name|get_cc
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REG3
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|SLJIT_ADD
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|IT
operator||
operator|(
name|cc
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|cc
operator|&
literal|0x1
operator|)
operator|^
literal|0x1
operator|)
operator|<<
literal|3
operator|)
operator||
literal|0x4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
index|[
name|dst_r
index|]
operator|>
literal|7
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_WI
operator||
name|RD4
argument_list|(
name|dst_r
argument_list|)
operator||
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_WI
operator||
name|RD4
argument_list|(
name|dst_r
argument_list|)
operator||
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOVSI
operator||
name|RDN3
argument_list|(
name|dst_r
argument_list|)
operator||
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOVSI
operator||
name|RDN3
argument_list|(
name|dst_r
argument_list|)
operator||
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dst_r
operator|==
name|TMP_REG2
condition|?
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
else|:
name|SLJIT_SUCCESS
return|;
block|}
name|ins
operator|=
operator|(
name|op
operator|==
name|SLJIT_AND
condition|?
name|ANDI
else|:
operator|(
name|op
operator|==
name|SLJIT_OR
condition|?
name|ORRI
else|:
name|EORI
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|SLJIT_OR
operator|||
name|op
operator|==
name|SLJIT_XOR
operator|)
operator|&&
name|dst
operator|<=
name|TMP_REG3
operator|&&
name|dst
operator|==
name|src
condition|)
block|{
comment|/* Does not change the other bits. */
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|IT
operator||
operator|(
name|cc
operator|<<
literal|4
operator|)
operator||
literal|0x8
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ins
operator||
name|RN4
argument_list|(
name|src
argument_list|)
operator||
name|RD4
argument_list|(
name|dst
argument_list|)
operator||
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SLJIT_SET_E
condition|)
block|{
comment|/* The condition must always be set, even if the ORRI/EORI is not executed above. */
if|if
condition|(
name|reg_map
index|[
name|dst
index|]
operator|<=
literal|7
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOVS
operator||
name|RD3
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|RN3
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_W
operator||
name|SET_FLAGS
operator||
name|RD4
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|RM4
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
argument_list|,
name|TMP_REG1
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|IT
operator||
operator|(
name|cc
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|cc
operator|&
literal|0x1
operator|)
operator|^
literal|0x1
operator|)
operator|<<
literal|3
operator|)
operator||
literal|0x4
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ins
operator||
name|RN4
argument_list|(
name|src
argument_list|)
operator||
name|RD4
argument_list|(
name|dst_r
argument_list|)
operator||
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|ins
operator||
name|RN4
argument_list|(
name|src
argument_list|)
operator||
name|RD4
argument_list|(
name|dst_r
argument_list|)
operator||
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|==
name|TMP_REG2
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SLJIT_SET_E
condition|)
block|{
comment|/* The condition must always be set, even if the ORR/EORI is not executed above. */
if|if
condition|(
name|reg_map
index|[
name|dst_r
index|]
operator|<=
literal|7
condition|)
return|return
name|push_inst16
argument_list|(
name|compiler
argument_list|,
name|MOVS
operator||
name|RD3
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|RN3
argument_list|(
name|dst_r
argument_list|)
argument_list|)
return|;
return|return
name|push_inst32
argument_list|(
name|compiler
argument_list|,
name|MOV_W
operator||
name|SET_FLAGS
operator||
name|RD4
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|RM4
argument_list|(
name|dst_r
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|sljit_si
name|dst_r
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REG3
operator|)
condition|?
name|dst
else|:
name|TMP_REG1
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_imm32_const
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
name|init_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_SIZE
operator||
name|STORE
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const_
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
name|inline_set_jump_addr
argument_list|(
name|addr
argument_list|,
name|new_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
block|{
name|sljit_uh
modifier|*
name|inst
init|=
operator|(
name|sljit_uh
operator|*
operator|)
name|addr
decl_stmt|;
name|modify_imm32_const
argument_list|(
name|inst
argument_list|,
name|new_constant
argument_list|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
