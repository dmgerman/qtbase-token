begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"SPARC"
name|SLJIT_CPUINFO
return|;
block|}
end_function
begin_comment
comment|/* Length of an instruction word    Both for sparc-32 and sparc-64 */
end_comment
begin_typedef
DECL|typedef|sljit_ins
typedef|typedef
name|sljit_ui
name|sljit_ins
typedef|;
end_typedef
begin_function
DECL|function|sparc_cache_flush
specifier|static
name|void
name|sparc_cache_flush
parameter_list|(
name|sljit_ins
modifier|*
name|from
parameter_list|,
name|sljit_ins
modifier|*
name|to
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__SUNPRO_C
argument_list|)
operator|&&
name|__SUNPRO_C
operator|<
literal|0x590
asm|__asm (
comment|/* if (from == to) return */
literal|"cmp %i0, %i1\n"
literal|"be .leave\n"
literal|"nop\n"
comment|/* loop until from>= to */
literal|".mainloop:\n"
literal|"flush %i0\n"
literal|"add %i0, 8, %i0\n"
literal|"cmp %i0, %i1\n"
literal|"bcs .mainloop\n"
literal|"nop\n"
comment|/* The comparison was done above. */
literal|"bne .leave\n"
comment|/* nop is not necessary here, since the 		   sub operation has no side effect. */
literal|"sub %i0, 4, %i0\n"
literal|"flush %i0\n"
literal|".leave:"
block|)
function|;
end_function
begin_else
else|#
directive|else
end_else
begin_if
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|from
operator|==
name|to
argument_list|)
condition|)
return|return;
end_if
begin_do
do|do
block|{
asm|__asm__
specifier|volatile
asm|( 			"flush %0\n" 			: : "r"(from) 		);
comment|/* Operates at least on doubleword. */
name|from
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|from
operator|<
name|to
condition|)
do|;
end_do
begin_if
if|if
condition|(
name|from
operator|==
name|to
condition|)
block|{
comment|/* Flush the last word. */
name|from
operator|--
expr_stmt|;
asm|__asm__
specifier|volatile
asm|( 			"flush %0\n" 			: : "r"(from) 		);
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_comment
unit|}
comment|/* TMP_REG2 is not used by getput_arg */
end_comment
begin_define
DECL|macro|TMP_REG1
define|#
directive|define
name|TMP_REG1
value|(SLJIT_NUMBER_OF_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NUMBER_OF_REGISTERS + 3)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NUMBER_OF_REGISTERS + 4)
end_define
begin_define
DECL|macro|TMP_LINK
define|#
directive|define
name|TMP_LINK
value|(SLJIT_NUMBER_OF_REGISTERS + 5)
end_define
begin_define
DECL|macro|TMP_FREG1
define|#
directive|define
name|TMP_FREG1
value|(0)
end_define
begin_define
DECL|macro|TMP_FREG2
define|#
directive|define
name|TMP_FREG2
value|((SLJIT_NUMBER_OF_FLOAT_REGISTERS + 1)<< 1)
end_define
begin_decl_stmt
DECL|macro|TMP_FREG2
unit|static
DECL|variable|reg_map
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NUMBER_OF_REGISTERS
operator|+
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|13
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|23
block|,
literal|22
block|,
literal|21
block|,
literal|20
block|,
literal|19
block|,
literal|18
block|,
literal|17
block|,
literal|16
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|,
literal|14
block|,
literal|1
block|,
literal|11
block|,
literal|12
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Instrucion forms                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|D
define|#
directive|define
name|D
parameter_list|(
name|d
parameter_list|)
value|(reg_map[d]<< 25)
end_define
begin_define
DECL|macro|DA
define|#
directive|define
name|DA
parameter_list|(
name|d
parameter_list|)
value|((d)<< 25)
end_define
begin_define
DECL|macro|S1
define|#
directive|define
name|S1
parameter_list|(
name|s1
parameter_list|)
value|(reg_map[s1]<< 14)
end_define
begin_define
DECL|macro|S2
define|#
directive|define
name|S2
parameter_list|(
name|s2
parameter_list|)
value|(reg_map[s2])
end_define
begin_define
DECL|macro|S1A
define|#
directive|define
name|S1A
parameter_list|(
name|s1
parameter_list|)
value|((s1)<< 14)
end_define
begin_define
DECL|macro|S2A
define|#
directive|define
name|S2A
parameter_list|(
name|s2
parameter_list|)
value|(s2)
end_define
begin_define
DECL|macro|IMM_ARG
define|#
directive|define
name|IMM_ARG
value|0x2000
end_define
begin_define
DECL|macro|DOP
define|#
directive|define
name|DOP
parameter_list|(
name|op
parameter_list|)
value|((op)<< 5)
end_define
begin_define
DECL|macro|IMM
define|#
directive|define
name|IMM
parameter_list|(
name|imm
parameter_list|)
value|(((imm)& 0x1fff) | IMM_ARG)
end_define
begin_define
DECL|macro|DR
define|#
directive|define
name|DR
parameter_list|(
name|dr
parameter_list|)
value|(reg_map[dr])
end_define
begin_define
DECL|macro|OPC1
define|#
directive|define
name|OPC1
parameter_list|(
name|opcode
parameter_list|)
value|((opcode)<< 30)
end_define
begin_define
DECL|macro|OPC2
define|#
directive|define
name|OPC2
parameter_list|(
name|opcode
parameter_list|)
value|((opcode)<< 22)
end_define
begin_define
DECL|macro|OPC3
define|#
directive|define
name|OPC3
parameter_list|(
name|opcode
parameter_list|)
value|((opcode)<< 19)
end_define
begin_define
DECL|macro|SET_FLAGS
define|#
directive|define
name|SET_FLAGS
value|OPC3(0x10)
end_define
begin_define
DECL|macro|ADD
define|#
directive|define
name|ADD
value|(OPC1(0x2) | OPC3(0x00))
end_define
begin_define
DECL|macro|ADDC
define|#
directive|define
name|ADDC
value|(OPC1(0x2) | OPC3(0x08))
end_define
begin_define
DECL|macro|AND
define|#
directive|define
name|AND
value|(OPC1(0x2) | OPC3(0x01))
end_define
begin_define
DECL|macro|ANDN
define|#
directive|define
name|ANDN
value|(OPC1(0x2) | OPC3(0x05))
end_define
begin_define
DECL|macro|CALL
define|#
directive|define
name|CALL
value|(OPC1(0x1))
end_define
begin_define
DECL|macro|FABSS
define|#
directive|define
name|FABSS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x09))
end_define
begin_define
DECL|macro|FADDD
define|#
directive|define
name|FADDD
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x42))
end_define
begin_define
DECL|macro|FADDS
define|#
directive|define
name|FADDS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x41))
end_define
begin_define
DECL|macro|FCMPD
define|#
directive|define
name|FCMPD
value|(OPC1(0x2) | OPC3(0x35) | DOP(0x52))
end_define
begin_define
DECL|macro|FCMPS
define|#
directive|define
name|FCMPS
value|(OPC1(0x2) | OPC3(0x35) | DOP(0x51))
end_define
begin_define
DECL|macro|FDIVD
define|#
directive|define
name|FDIVD
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x4e))
end_define
begin_define
DECL|macro|FDIVS
define|#
directive|define
name|FDIVS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x4d))
end_define
begin_define
DECL|macro|FDTOI
define|#
directive|define
name|FDTOI
value|(OPC1(0x2) | OPC3(0x34) | DOP(0xd2))
end_define
begin_define
DECL|macro|FDTOS
define|#
directive|define
name|FDTOS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0xc6))
end_define
begin_define
DECL|macro|FITOD
define|#
directive|define
name|FITOD
value|(OPC1(0x2) | OPC3(0x34) | DOP(0xc8))
end_define
begin_define
DECL|macro|FITOS
define|#
directive|define
name|FITOS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0xc4))
end_define
begin_define
DECL|macro|FMOVS
define|#
directive|define
name|FMOVS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x01))
end_define
begin_define
DECL|macro|FMULD
define|#
directive|define
name|FMULD
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x4a))
end_define
begin_define
DECL|macro|FMULS
define|#
directive|define
name|FMULS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x49))
end_define
begin_define
DECL|macro|FNEGS
define|#
directive|define
name|FNEGS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x05))
end_define
begin_define
DECL|macro|FSTOD
define|#
directive|define
name|FSTOD
value|(OPC1(0x2) | OPC3(0x34) | DOP(0xc9))
end_define
begin_define
DECL|macro|FSTOI
define|#
directive|define
name|FSTOI
value|(OPC1(0x2) | OPC3(0x34) | DOP(0xd1))
end_define
begin_define
DECL|macro|FSUBD
define|#
directive|define
name|FSUBD
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x46))
end_define
begin_define
DECL|macro|FSUBS
define|#
directive|define
name|FSUBS
value|(OPC1(0x2) | OPC3(0x34) | DOP(0x45))
end_define
begin_define
DECL|macro|JMPL
define|#
directive|define
name|JMPL
value|(OPC1(0x2) | OPC3(0x38))
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
value|(OPC1(0x0) | OPC2(0x04))
end_define
begin_define
DECL|macro|OR
define|#
directive|define
name|OR
value|(OPC1(0x2) | OPC3(0x02))
end_define
begin_define
DECL|macro|ORN
define|#
directive|define
name|ORN
value|(OPC1(0x2) | OPC3(0x06))
end_define
begin_define
DECL|macro|RDY
define|#
directive|define
name|RDY
value|(OPC1(0x2) | OPC3(0x28) | S1A(0))
end_define
begin_define
DECL|macro|RESTORE
define|#
directive|define
name|RESTORE
value|(OPC1(0x2) | OPC3(0x3d))
end_define
begin_define
DECL|macro|SAVE
define|#
directive|define
name|SAVE
value|(OPC1(0x2) | OPC3(0x3c))
end_define
begin_define
DECL|macro|SETHI
define|#
directive|define
name|SETHI
value|(OPC1(0x0) | OPC2(0x04))
end_define
begin_define
DECL|macro|SLL
define|#
directive|define
name|SLL
value|(OPC1(0x2) | OPC3(0x25))
end_define
begin_define
DECL|macro|SLLX
define|#
directive|define
name|SLLX
value|(OPC1(0x2) | OPC3(0x25) | (1<< 12))
end_define
begin_define
DECL|macro|SRA
define|#
directive|define
name|SRA
value|(OPC1(0x2) | OPC3(0x27))
end_define
begin_define
DECL|macro|SRAX
define|#
directive|define
name|SRAX
value|(OPC1(0x2) | OPC3(0x27) | (1<< 12))
end_define
begin_define
DECL|macro|SRL
define|#
directive|define
name|SRL
value|(OPC1(0x2) | OPC3(0x26))
end_define
begin_define
DECL|macro|SRLX
define|#
directive|define
name|SRLX
value|(OPC1(0x2) | OPC3(0x26) | (1<< 12))
end_define
begin_define
DECL|macro|SUB
define|#
directive|define
name|SUB
value|(OPC1(0x2) | OPC3(0x04))
end_define
begin_define
DECL|macro|SUBC
define|#
directive|define
name|SUBC
value|(OPC1(0x2) | OPC3(0x0c))
end_define
begin_define
DECL|macro|TA
define|#
directive|define
name|TA
value|(OPC1(0x2) | OPC3(0x3a) | (8<< 25))
end_define
begin_define
DECL|macro|WRY
define|#
directive|define
name|WRY
value|(OPC1(0x2) | OPC3(0x30) | DA(0))
end_define
begin_define
DECL|macro|XOR
define|#
directive|define
name|XOR
value|(OPC1(0x2) | OPC3(0x03))
end_define
begin_define
DECL|macro|XNOR
define|#
directive|define
name|XNOR
value|(OPC1(0x2) | OPC3(0x07))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
end_if
begin_define
DECL|macro|MAX_DISP
define|#
directive|define
name|MAX_DISP
value|(0x1fffff)
end_define
begin_define
DECL|macro|MIN_DISP
define|#
directive|define
name|MIN_DISP
value|(-0x200000)
end_define
begin_define
DECL|macro|DISP_MASK
define|#
directive|define
name|DISP_MASK
value|(0x3fffff)
end_define
begin_define
DECL|macro|BICC
define|#
directive|define
name|BICC
value|(OPC1(0x0) | OPC2(0x2))
end_define
begin_define
DECL|macro|FBFCC
define|#
directive|define
name|FBFCC
value|(OPC1(0x0) | OPC2(0x6))
end_define
begin_define
DECL|macro|SLL_W
define|#
directive|define
name|SLL_W
value|SLL
end_define
begin_define
DECL|macro|SDIV
define|#
directive|define
name|SDIV
value|(OPC1(0x2) | OPC3(0x0f))
end_define
begin_define
DECL|macro|SMUL
define|#
directive|define
name|SMUL
value|(OPC1(0x2) | OPC3(0x0b))
end_define
begin_define
DECL|macro|UDIV
define|#
directive|define
name|UDIV
value|(OPC1(0x2) | OPC3(0x0e))
end_define
begin_define
DECL|macro|UMUL
define|#
directive|define
name|UMUL
value|(OPC1(0x2) | OPC3(0x0a))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SLL_W
define|#
directive|define
name|SLL_W
value|SLLX
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|SIMM_MAX
define|#
directive|define
name|SIMM_MAX
value|(0x0fff)
end_define
begin_define
DECL|macro|SIMM_MIN
define|#
directive|define
name|SIMM_MIN
value|(-0x1000)
end_define
begin_comment
comment|/* dest_reg is the absolute name of the register    Useful for reordering instructions in the delay slot. */
end_comment
begin_function
DECL|function|push_inst
specifier|static
name|sljit_si
name|push_inst
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|ins
parameter_list|,
name|sljit_si
name|delay_slot
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|ptr
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|delay_slot
operator|&
name|DST_INS_MASK
operator|)
operator|==
name|UNMOVABLE_INS
operator|||
operator|(
name|delay_slot
operator|&
name|DST_INS_MASK
operator|)
operator|==
name|MOVABLE_INS
operator|||
operator|(
name|delay_slot
operator|&
name|DST_INS_MASK
operator|)
operator|==
operator|(
operator|(
name|ins
operator|>>
literal|25
operator|)
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ins
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
name|compiler
operator|->
name|delay_slot
operator|=
name|delay_slot
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|detect_jump_type
specifier|static
name|SLJIT_INLINE
name|sljit_ins
modifier|*
name|detect_jump_type
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ins
modifier|*
name|code_ptr
parameter_list|,
name|sljit_ins
modifier|*
name|code
parameter_list|)
block|{
name|sljit_sw
name|diff
decl_stmt|;
name|sljit_uw
name|target_addr
decl_stmt|;
name|sljit_ins
modifier|*
name|inst
decl_stmt|;
name|sljit_ins
name|saved_inst
decl_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
return|return
name|code_ptr
return|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
name|target_addr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|target_addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|inst
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_CALL
condition|)
block|{
comment|/* Call is always patchable on sparc 32. */
name|jump
operator|->
name|flags
operator||=
name|PATCH_CALL
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_MOVABLE
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|inst
index|[
operator|-
literal|1
index|]
operator|=
name|CALL
expr_stmt|;
name|jump
operator|->
name|addr
operator|-=
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
return|return
name|inst
return|;
block|}
name|inst
index|[
literal|0
index|]
operator|=
name|CALL
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|NOP
expr_stmt|;
return|return
name|inst
operator|+
literal|1
return|;
block|}
else|#
directive|else
comment|/* Both calls and BPr instructions shall not pass this point. */
error|#
directive|error
literal|"Implementation required"
endif|#
directive|endif
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
name|inst
operator|--
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_MOVABLE
condition|)
block|{
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|target_addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|inst
operator|-
literal|1
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|MAX_DISP
operator|&&
name|diff
operator|>=
name|MIN_DISP
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
name|inst
operator|--
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
block|{
name|saved_inst
operator|=
name|inst
index|[
literal|0
index|]
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
literal|1
index|]
operator|^
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|saved_inst
expr_stmt|;
block|}
else|else
block|{
name|inst
index|[
literal|1
index|]
operator|=
name|inst
index|[
literal|0
index|]
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|BICC
operator||
name|DA
argument_list|(
literal|0x8
argument_list|)
expr_stmt|;
block|}
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|inst
expr_stmt|;
return|return
name|inst
operator|+
literal|1
return|;
block|}
block|}
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|target_addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|inst
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|MAX_DISP
operator|&&
name|diff
operator|>=
name|MIN_DISP
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
name|inst
index|[
literal|0
index|]
operator|^=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
else|else
name|inst
index|[
literal|0
index|]
operator|=
name|BICC
operator||
name|DA
argument_list|(
literal|0x8
argument_list|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|NOP
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|inst
expr_stmt|;
return|return
name|inst
operator|+
literal|1
return|;
block|}
return|return
name|code_ptr
return|;
block|}
end_function
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|sljit_ins
modifier|*
name|code
decl_stmt|;
name|sljit_ins
modifier|*
name|code_ptr
decl_stmt|;
name|sljit_ins
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_ins
modifier|*
name|buf_end
decl_stmt|;
name|sljit_uw
name|word_count
decl_stmt|;
name|sljit_uw
name|addr
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|CHECK_PTR
argument_list|(
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|compiler
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|code_ptr
operator|=
name|code
expr_stmt|;
name|word_count
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|compiler
operator|->
name|labels
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
do|do
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
operator|(
name|buf
operator|->
name|used_size
operator|>>
literal|2
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|code_ptr
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
operator|||
name|label
operator|->
name|size
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
operator|||
name|jump
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
operator|||
name|const_
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
comment|/* These structures are ordered by their address. */
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|&&
name|jump
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|code_ptr
operator|=
name|detect_jump_type
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|const_
operator|&&
name|const_
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|const_
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
name|code_ptr
operator|++
expr_stmt|;
name|word_count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
do|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|buf
condition|)
do|;
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|-
name|code
operator|<=
operator|(
name|sljit_si
operator|)
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
do|do
block|{
name|addr
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_CALL
condition|)
block|{
name|addr
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|addr
operator|-
name|jump
operator|->
name|addr
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|sljit_sw
operator|)
name|addr
operator|<=
literal|0x1fffffff
operator|&&
operator|(
name|sljit_sw
operator|)
name|addr
operator|>=
operator|-
literal|0x20000000
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator|=
name|CALL
operator||
operator|(
name|addr
operator|&
literal|0x3fffffff
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_B
condition|)
block|{
name|addr
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|addr
operator|-
name|jump
operator|->
name|addr
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|sljit_sw
operator|)
name|addr
operator|<=
name|MAX_DISP
operator|&&
operator|(
name|sljit_sw
operator|)
name|addr
operator|>=
name|MIN_DISP
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
operator|~
name|DISP_MASK
operator|)
operator||
operator|(
name|addr
operator|&
name|DISP_MASK
operator|)
expr_stmt|;
break|break;
block|}
comment|/* Set the fields of immediate loads. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffc00000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
literal|0xfffffc00
operator|)
operator||
operator|(
name|addr
operator|&
literal|0x3ff
operator|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Implementation required"
endif|#
directive|endif
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
name|compiler
operator|->
name|executable_size
operator|=
operator|(
name|code_ptr
operator|-
name|code
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Entry, exit                                                          */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Creates an index in data_transfer_insts array. */
end_comment
begin_define
DECL|macro|LOAD_DATA
define|#
directive|define
name|LOAD_DATA
value|0x01
end_define
begin_define
DECL|macro|WORD_DATA
define|#
directive|define
name|WORD_DATA
value|0x00
end_define
begin_define
DECL|macro|BYTE_DATA
define|#
directive|define
name|BYTE_DATA
value|0x02
end_define
begin_define
DECL|macro|HALF_DATA
define|#
directive|define
name|HALF_DATA
value|0x04
end_define
begin_define
DECL|macro|INT_DATA
define|#
directive|define
name|INT_DATA
value|0x06
end_define
begin_define
DECL|macro|SIGNED_DATA
define|#
directive|define
name|SIGNED_DATA
value|0x08
end_define
begin_comment
comment|/* Separates integer and floating point registers */
end_comment
begin_define
DECL|macro|GPR_REG
define|#
directive|define
name|GPR_REG
value|0x0f
end_define
begin_define
DECL|macro|DOUBLE_DATA
define|#
directive|define
name|DOUBLE_DATA
value|0x10
end_define
begin_define
DECL|macro|SINGLE_DATA
define|#
directive|define
name|SINGLE_DATA
value|0x12
end_define
begin_define
DECL|macro|MEM_MASK
define|#
directive|define
name|MEM_MASK
value|0x1f
end_define
begin_define
DECL|macro|WRITE_BACK
define|#
directive|define
name|WRITE_BACK
value|0x00020
end_define
begin_define
DECL|macro|ARG_TEST
define|#
directive|define
name|ARG_TEST
value|0x00040
end_define
begin_define
DECL|macro|ALT_KEEP_CACHE
define|#
directive|define
name|ALT_KEEP_CACHE
value|0x00080
end_define
begin_define
DECL|macro|CUMULATIVE_OP
define|#
directive|define
name|CUMULATIVE_OP
value|0x00100
end_define
begin_define
DECL|macro|IMM_OP
define|#
directive|define
name|IMM_OP
value|0x00200
end_define
begin_define
DECL|macro|SRC2_IMM
define|#
directive|define
name|SRC2_IMM
value|0x00400
end_define
begin_define
DECL|macro|REG_DEST
define|#
directive|define
name|REG_DEST
value|0x00800
end_define
begin_define
DECL|macro|REG2_SOURCE
define|#
directive|define
name|REG2_SOURCE
value|0x01000
end_define
begin_define
DECL|macro|SLOW_SRC1
define|#
directive|define
name|SLOW_SRC1
value|0x02000
end_define
begin_define
DECL|macro|SLOW_SRC2
define|#
directive|define
name|SLOW_SRC2
value|0x04000
end_define
begin_define
DECL|macro|SLOW_DEST
define|#
directive|define
name|SLOW_DEST
value|0x08000
end_define
begin_comment
comment|/* SET_FLAGS (0x10<< 19) also belong here! */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitNativeSPARC_32.c"
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"sljitNativeSPARC_64.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|options
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|fscratches
argument_list|,
name|fsaveds
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|set_emit_enter
argument_list|(
name|compiler
argument_list|,
name|options
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|fscratches
argument_list|,
name|fsaveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|local_size
operator|=
operator|(
name|local_size
operator|+
name|SLJIT_LOCALS_OFFSET
operator|+
literal|7
operator|)
operator|&
operator|~
literal|0x7
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
if|if
condition|(
name|local_size
operator|<=
name|SIMM_MAX
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SAVE
operator||
name|D
argument_list|(
name|SLJIT_SP
argument_list|)
operator||
name|S1
argument_list|(
name|SLJIT_SP
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|local_size
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
operator|-
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SAVE
operator||
name|D
argument_list|(
name|SLJIT_SP
argument_list|)
operator||
name|S1
argument_list|(
name|SLJIT_SP
argument_list|)
operator||
name|S2
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Arguments are in their appropriate registers. */
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|options
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|fscratches
argument_list|,
name|fsaveds
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|set_set_context
argument_list|(
name|compiler
argument_list|,
name|options
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|fscratches
argument_list|,
name|fsaveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
operator|(
name|local_size
operator|+
name|SLJIT_LOCALS_OFFSET
operator|+
literal|7
operator|)
operator|&
operator|~
literal|0x7
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|SLJIT_MOV
operator|||
operator|!
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|SLJIT_R0
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JMPL
operator||
name|D
argument_list|(
literal|0
argument_list|)
operator||
name|S1A
argument_list|(
literal|31
argument_list|)
operator||
name|IMM
argument_list|(
literal|8
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|RESTORE
operator||
name|D
argument_list|(
name|SLJIT_R0
argument_list|)
operator||
name|S1
argument_list|(
name|src
argument_list|)
operator||
name|S2
argument_list|(
literal|0
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
end_if
begin_define
DECL|macro|ARCH_32_64
define|#
directive|define
name|ARCH_32_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ARCH_32_64
define|#
directive|define
name|ARCH_32_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|b
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|data_transfer_insts
specifier|static
name|SLJIT_CONST
name|sljit_ins
name|data_transfer_insts
index|[
literal|16
operator|+
literal|4
index|]
init|=
block|{
comment|/* u w s */
name|ARCH_32_64
argument_list|(
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x04
argument_list|)
comment|/* stw */
argument_list|,
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x0e
argument_list|)
comment|/* stx */
argument_list|)
block|,
comment|/* u w l */
name|ARCH_32_64
argument_list|(
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x00
argument_list|)
comment|/* lduw */
argument_list|,
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x0b
argument_list|)
comment|/* ldx */
argument_list|)
block|,
comment|/* u b s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x05
argument_list|)
comment|/* stb */
block|,
comment|/* u b l */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x01
argument_list|)
comment|/* ldub */
block|,
comment|/* u h s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x06
argument_list|)
comment|/* sth */
block|,
comment|/* u h l */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x02
argument_list|)
comment|/* lduh */
block|,
comment|/* u i s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x04
argument_list|)
comment|/* stw */
block|,
comment|/* u i l */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x00
argument_list|)
comment|/* lduw */
block|,
comment|/* s w s */
name|ARCH_32_64
argument_list|(
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x04
argument_list|)
comment|/* stw */
argument_list|,
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x0e
argument_list|)
comment|/* stx */
argument_list|)
block|,
comment|/* s w l */
name|ARCH_32_64
argument_list|(
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x00
argument_list|)
comment|/* lduw */
argument_list|,
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x0b
argument_list|)
comment|/* ldx */
argument_list|)
block|,
comment|/* s b s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x05
argument_list|)
comment|/* stb */
block|,
comment|/* s b l */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x09
argument_list|)
comment|/* ldsb */
block|,
comment|/* s h s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x06
argument_list|)
comment|/* sth */
block|,
comment|/* s h l */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x0a
argument_list|)
comment|/* ldsh */
block|,
comment|/* s i s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x04
argument_list|)
comment|/* stw */
block|,
comment|/* s i l */
name|ARCH_32_64
argument_list|(
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x00
argument_list|)
comment|/* lduw */
argument_list|,
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x08
argument_list|)
comment|/* ldsw */
argument_list|)
block|,
comment|/* d   s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x27
argument_list|)
block|,
comment|/* d   l */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x23
argument_list|)
block|,
comment|/* s   s */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x24
argument_list|)
block|,
comment|/* s   l */
name|OPC1
argument_list|(
literal|3
argument_list|)
operator||
name|OPC3
argument_list|(
literal|0x20
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt
begin_undef
DECL|macro|ARCH_32_64
undef|#
directive|undef
name|ARCH_32_64
end_undef
begin_comment
comment|/* Can perform an operation using at most 1 instruction. */
end_comment
begin_function
DECL|function|getput_arg_fast
specifier|static
name|sljit_si
name|getput_arg_fast
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
operator|||
operator|!
operator|(
name|arg
operator|&
name|REG_MASK
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|&&
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
operator|)
operator|||
operator|(
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|&&
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Works for both absoulte and relative addresses (immediate case). */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|ARG_TEST
argument_list|)
condition|)
return|return
literal|1
return|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
operator|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
condition|?
name|D
argument_list|(
name|reg
argument_list|)
else|:
name|DA
argument_list|(
name|reg
argument_list|)
operator|)
operator||
name|S1
argument_list|(
name|arg
operator|&
name|REG_MASK
argument_list|)
operator||
operator|(
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
condition|?
name|S2
argument_list|(
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
argument_list|)
else|:
name|IMM
argument_list|(
name|argw
argument_list|)
operator|)
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|&&
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|)
condition|?
name|DR
argument_list|(
name|reg
argument_list|)
else|:
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* See getput_arg below.    Note: can_cache is called only for binary operators. Those    operators always uses word arguments without write back. */
end_comment
begin_function
DECL|function|can_cache
specifier|static
name|sljit_si
name|can_cache
parameter_list|(
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
name|arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
argument_list|)
expr_stmt|;
comment|/* Simple operation except for updates. */
if|if
condition|(
name|arg
operator|&
name|OFFS_REG_MASK
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|argw
argument_list|)
expr_stmt|;
name|next_argw
operator|&=
literal|0x3
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|==
operator|(
name|next_arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|&&
name|argw
operator|==
name|next_argw
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|<=
name|SIMM_MAX
operator|&&
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|>=
name|SIMM_MIN
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Emit the necessary instructions. See can_cache above. */
end_comment
begin_function
DECL|function|getput_arg
specifier|static
name|sljit_si
name|getput_arg
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|sljit_si
name|base
decl_stmt|,
name|arg2
decl_stmt|,
name|delay_slot
decl_stmt|;
name|sljit_ins
name|dest
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|next_arg
operator|=
literal|0
expr_stmt|;
name|next_argw
operator|=
literal|0
expr_stmt|;
block|}
name|base
operator|=
name|arg
operator|&
name|REG_MASK
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|&
name|OFFS_REG_MASK
argument_list|)
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|argw
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Using the cache. */
if|if
condition|(
operator|(
operator|(
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|)
operator|==
name|compiler
operator|->
name|cache_arg
operator|)
operator|&&
operator|(
name|argw
operator|==
name|compiler
operator|->
name|cache_argw
operator|)
condition|)
name|arg2
operator|=
name|TMP_REG3
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|==
operator|(
name|next_arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|&&
name|argw
operator|==
operator|(
name|next_argw
operator|&
literal|0x3
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|arg2
operator|=
name|TMP_REG3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|)
operator|&&
name|reg
operator|!=
name|base
operator|&&
name|reg
operator|!=
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
condition|)
name|arg2
operator|=
name|reg
expr_stmt|;
else|else
comment|/* It must be a mov operation, so tmp1 must be free to use. */
name|arg2
operator|=
name|TMP_REG1
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLL_W
operator||
name|D
argument_list|(
name|arg2
argument_list|)
operator||
name|S1
argument_list|(
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
argument_list|)
operator||
name|IMM_ARG
operator||
name|argw
argument_list|,
name|DR
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Using the cache. */
if|if
condition|(
operator|(
name|compiler
operator|->
name|cache_arg
operator|==
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|)
operator|<=
name|SIMM_MAX
operator|&&
operator|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|)
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|argw
operator|!=
name|compiler
operator|->
name|cache_argw
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|D
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|S1
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
block|}
name|arg2
operator|=
name|TMP_REG3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|<=
name|SIMM_MAX
operator|&&
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|>=
name|SIMM_MIN
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|arg2
operator|=
name|TMP_REG3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|)
operator|&&
name|reg
operator|!=
name|base
condition|)
name|arg2
operator|=
name|reg
expr_stmt|;
else|else
comment|/* It must be a mov operation, so tmp1 must be free to use. */
name|arg2
operator|=
name|TMP_REG1
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|arg2
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dest
operator|=
operator|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
condition|?
name|D
argument_list|(
name|reg
argument_list|)
else|:
name|DA
argument_list|(
name|reg
argument_list|)
operator|)
expr_stmt|;
name|delay_slot
operator|=
operator|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|&&
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|)
condition|?
name|DR
argument_list|(
name|reg
argument_list|)
else|:
name|MOVABLE_INS
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|dest
operator||
name|S1
argument_list|(
name|arg2
argument_list|)
operator||
name|IMM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|dest
operator||
name|S1
argument_list|(
name|base
argument_list|)
operator||
name|S2
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|dest
operator||
name|S1
argument_list|(
name|base
argument_list|)
operator||
name|S2
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|D
argument_list|(
name|base
argument_list|)
operator||
name|S1
argument_list|(
name|base
argument_list|)
operator||
name|S2
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|base
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem2
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg1
parameter_list|,
name|sljit_sw
name|arg1w
parameter_list|,
name|sljit_si
name|arg2
parameter_list|,
name|sljit_sw
name|arg2w
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|,
name|arg2
argument_list|,
name|arg2w
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op
specifier|static
name|sljit_si
name|emit_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* arg1 goes to TMP_REG1 or src reg 	   arg2 goes to TMP_REG2, imm or src reg 	   TMP_REG3 can be used for caching 	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
name|sljit_si
name|dst_r
init|=
name|TMP_REG2
decl_stmt|;
name|sljit_si
name|src1_r
decl_stmt|;
name|sljit_sw
name|src2_r
init|=
literal|0
decl_stmt|;
name|sljit_si
name|sugg_src2_r
init|=
name|TMP_REG2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ALT_KEEP_CACHE
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst
operator|==
name|SLJIT_UNUSED
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
name|flags
operator||=
name|REG_DEST
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|sugg_src2_r
operator|=
name|dst_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|!
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|ARG_TEST
argument_list|,
name|TMP_REG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
name|flags
operator||=
name|SLOW_DEST
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IMM_OP
condition|)
block|{
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src2w
condition|)
block|{
if|if
condition|(
name|src2w
operator|<=
name|SIMM_MAX
operator|&&
name|src2w
operator|>=
name|SIMM_MIN
condition|)
block|{
name|flags
operator||=
name|SRC2_IMM
expr_stmt|;
name|src2_r
operator|=
name|src2w
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
operator|&&
operator|(
name|flags
operator|&
name|CUMULATIVE_OP
operator|)
operator|&&
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src1w
condition|)
block|{
if|if
condition|(
name|src1w
operator|<=
name|SIMM_MAX
operator|&&
name|src1w
operator|>=
name|SIMM_MIN
condition|)
block|{
name|flags
operator||=
name|SRC2_IMM
expr_stmt|;
name|src2_r
operator|=
name|src1w
expr_stmt|;
comment|/* And swap arguments. */
name|src1
operator|=
name|src2
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
name|src2
operator|=
name|SLJIT_IMM
expr_stmt|;
comment|/* src2w = src2_r unneeded. */
block|}
block|}
block|}
comment|/* Source 1. */
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src1
argument_list|)
condition|)
name|src1_r
operator|=
name|src1
expr_stmt|;
elseif|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|src1w
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
else|else
name|src1_r
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC1
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
comment|/* Source 2. */
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src2
argument_list|)
condition|)
block|{
name|src2_r
operator|=
name|src2
expr_stmt|;
name|flags
operator||=
name|REG2_SOURCE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REG_DEST
operator|)
operator|&&
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|dst_r
operator|=
name|src2_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
condition|)
block|{
if|if
condition|(
name|src2w
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
else|else
block|{
name|src2_r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|)
operator|&&
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
condition|)
name|dst_r
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC2
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
operator|)
operator|==
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|src2_r
operator|==
name|TMP_REG2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_single_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|src1_r
argument_list|,
name|src2_r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SLOW_DEST
operator|)
condition|)
block|{
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
return|return
name|compiler
operator|->
name|error
return|;
block|}
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_BREAKPOINT
case|:
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|TA
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
case|case
name|SLJIT_NOP
case|:
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
case|case
name|SLJIT_LUMUL
case|:
case|case
name|SLJIT_LSMUL
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_LUMUL
condition|?
name|UMUL
else|:
name|SMUL
operator|)
operator||
name|D
argument_list|(
name|SLJIT_R0
argument_list|)
operator||
name|S1
argument_list|(
name|SLJIT_R0
argument_list|)
operator||
name|S2
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_R0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|RDY
operator||
name|D
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|)
return|;
else|#
directive|else
error|#
directive|error
literal|"Implementation required"
endif|#
directive|endif
case|case
name|SLJIT_UDIVMOD
case|:
case|case
name|SLJIT_SDIVMOD
case|:
case|case
name|SLJIT_UDIVI
case|:
case|case
name|SLJIT_SDIVI
case|:
name|SLJIT_COMPILE_ASSERT
argument_list|(
operator|(
name|SLJIT_UDIVMOD
operator|&
literal|0x2
operator|)
operator|==
literal|0
operator|&&
name|SLJIT_UDIVI
operator|-
literal|0x2
operator|==
name|SLJIT_UDIVMOD
argument_list|,
name|bad_div_opcode_assignments
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
if|if
condition|(
operator|(
name|op
operator||
literal|0x2
operator|)
operator|==
name|SLJIT_UDIVI
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|WRY
operator||
name|S1
argument_list|(
literal|0
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRA
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|S1
argument_list|(
name|SLJIT_R0
argument_list|)
operator||
name|IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|WRY
operator||
name|S1
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|<=
name|SLJIT_SDIVMOD
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|D
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|S1
argument_list|(
literal|0
argument_list|)
operator||
name|S2
argument_list|(
name|SLJIT_R0
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
operator|(
name|op
operator||
literal|0x2
operator|)
operator|==
name|SLJIT_UDIVI
condition|?
name|UDIV
else|:
name|SDIV
operator|)
operator||
name|D
argument_list|(
name|SLJIT_R0
argument_list|)
operator||
name|S1
argument_list|(
name|SLJIT_R0
argument_list|)
operator||
name|S2
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_R0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_UDIVI
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SMUL
operator||
name|D
argument_list|(
name|SLJIT_R1
argument_list|)
operator||
name|S1
argument_list|(
name|SLJIT_R0
argument_list|)
operator||
name|S2
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUB
operator||
name|D
argument_list|(
name|SLJIT_R1
argument_list|)
operator||
name|S1
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|S2
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_R1
argument_list|)
argument_list|)
return|;
else|#
directive|else
error|#
directive|error
literal|"Implementation required"
endif|#
directive|endif
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|flags
init|=
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|?
name|SET_FLAGS
else|:
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|flags
operator||
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|flags
operator||
name|INT_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|flags
operator||
name|INT_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|flags
operator||
name|BYTE_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|flags
operator||
name|BYTE_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|flags
operator||
name|HALF_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|flags
operator||
name|HALF_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU
case|:
case|case
name|SLJIT_MOVU_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|flags
operator||
name|WORD_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|flags
operator||
name|INT_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|flags
operator||
name|INT_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|flags
operator||
name|BYTE_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|flags
operator||
name|BYTE_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|flags
operator||
name|HALF_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|flags
operator||
name|HALF_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NOT
case|:
case|case
name|SLJIT_CLZ
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NEG
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|flags
init|=
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|?
name|SET_FLAGS
else|:
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
case|case
name|SLJIT_ADDC
case|:
case|case
name|SLJIT_MUL
case|:
case|case
name|SLJIT_AND
case|:
case|case
name|SLJIT_OR
case|:
case|case
name|SLJIT_XOR
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|CUMULATIVE_OP
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
case|case
name|SLJIT_SUBC
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SHL
case|:
case|case
name|SLJIT_LSHR
case|:
case|case
name|SLJIT_ASHR
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
name|src2w
operator|&=
literal|0x1f
expr_stmt|;
else|#
directive|else
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|CHECK_REG_INDEX
argument_list|(
name|check_sljit_get_register_index
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg_map
index|[
name|reg
index|]
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_float_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_float_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|CHECK_REG_INDEX
argument_list|(
name|check_sljit_get_float_register_index
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
operator|<<
literal|1
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_op_custom
argument_list|(
name|compiler
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|*
operator|(
name|sljit_ins
operator|*
operator|)
name|instruction
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Floating point operators                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SLJIT_IS_FPU_AVAILABLE
return|return
name|SLJIT_IS_FPU_AVAILABLE
return|;
else|#
directive|else
comment|/* Available by default. */
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function
begin_define
DECL|macro|FLOAT_DATA
define|#
directive|define
name|FLOAT_DATA
parameter_list|(
name|op
parameter_list|)
value|(DOUBLE_DATA | ((op& SLJIT_SINGLE_OP)>> 7))
end_define
begin_define
DECL|macro|SELECT_FOP
define|#
directive|define
name|SELECT_FOP
parameter_list|(
name|op
parameter_list|,
name|single
parameter_list|,
name|double
parameter_list|)
value|((op& SLJIT_SINGLE_OP) ? single : double)
end_define
begin_define
DECL|macro|FLOAT_TMP_MEM_OFFSET
define|#
directive|define
name|FLOAT_TMP_MEM_OFFSET
value|(22 * sizeof(sljit_sw))
end_define
begin_function
DECL|function|sljit_emit_fop1_convw_fromd
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|sljit_emit_fop1_convw_fromd
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
else|else
name|src
operator|<<=
literal|1
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FSTOI
argument_list|,
name|FDTOI
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_FREG1
argument_list|)
operator||
name|S2A
argument_list|(
name|src
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|SINGLE_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
argument_list|,
name|FLOAT_TMP_MEM_OFFSET
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
argument_list|,
name|FLOAT_TMP_MEM_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|dst
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
argument_list|,
name|FLOAT_TMP_MEM_OFFSET
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
argument_list|,
name|FLOAT_TMP_MEM_OFFSET
argument_list|)
return|;
block|}
comment|/* Store the integer value from a VFP register. */
return|return
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|SINGLE_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1_convd_fromw
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|sljit_emit_fop1_convd_fromw
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_r
init|=
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
operator|(
name|dst
operator|<<
literal|1
operator|)
else|:
name|TMP_FREG1
decl_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CONVD_FROMI
condition|)
name|srcw
operator|=
operator|(
name|sljit_si
operator|)
name|srcw
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|src
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
argument_list|,
name|FLOAT_TMP_MEM_OFFSET
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
argument_list|,
name|FLOAT_TMP_MEM_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
expr_stmt|;
name|srcw
operator|=
name|FLOAT_TMP_MEM_OFFSET
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|SINGLE_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FITOS
argument_list|,
name|FITOD
argument_list|)
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S2A
argument_list|(
name|TMP_FREG1
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
return|return
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1_cmp
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|sljit_emit_fop1_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
else|else
name|src1
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
else|else
name|src2
operator|<<=
literal|1
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FCMPS
argument_list|,
name|FCMPD
argument_list|)
operator||
name|S1A
argument_list|(
name|src1
argument_list|)
operator||
name|S2A
argument_list|(
name|src2
argument_list|)
argument_list|,
name|FCC_IS_SET
operator||
name|MOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
operator|(
name|SLJIT_SINGLE_OP
operator|==
literal|0x100
operator|)
operator|&&
operator|!
operator|(
name|DOUBLE_DATA
operator|&
literal|0x2
operator|)
argument_list|,
name|float_transfer_bit_error
argument_list|)
expr_stmt|;
name|SELECT_FOP1_OPERATION_WITH_CHECKS
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CONVD_FROMS
condition|)
name|op
operator|^=
name|SLJIT_SINGLE_OP
expr_stmt|;
name|dst_r
operator|=
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
operator|(
name|dst
operator|<<
literal|1
operator|)
else|:
name|TMP_FREG1
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst_r
expr_stmt|;
block|}
else|else
name|src
operator|<<=
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_DMOV
case|:
if|if
condition|(
name|src
operator|!=
name|dst_r
condition|)
block|{
if|if
condition|(
name|dst_r
operator|!=
name|TMP_FREG1
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FMOVS
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S2A
argument_list|(
name|src
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FMOVS
operator||
name|DA
argument_list|(
name|dst_r
operator||
literal|1
argument_list|)
operator||
name|S2A
argument_list|(
name|src
operator||
literal|1
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_r
operator|=
name|src
expr_stmt|;
block|}
break|break;
case|case
name|SLJIT_DNEG
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FNEGS
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S2A
argument_list|(
name|src
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|!=
name|src
operator|&&
operator|!
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FMOVS
operator||
name|DA
argument_list|(
name|dst_r
operator||
literal|1
argument_list|)
operator||
name|S2A
argument_list|(
name|src
operator||
literal|1
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DABS
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FABSS
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S2A
argument_list|(
name|src
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|!=
name|src
operator|&&
operator|!
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FMOVS
operator||
name|DA
argument_list|(
name|dst_r
operator||
literal|1
argument_list|)
operator||
name|S2A
argument_list|(
name|src
operator||
literal|1
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_CONVD_FROMS
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FSTOD
argument_list|,
name|FDTOS
argument_list|)
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S2A
argument_list|(
name|src
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|^=
name|SLJIT_SINGLE_OP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|dst_r
operator|=
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
operator|(
name|dst
operator|<<
literal|1
operator|)
else|:
name|TMP_FREG2
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|SLOW_SRC1
expr_stmt|;
block|}
else|else
name|src1
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|SLOW_SRC2
expr_stmt|;
block|}
else|else
name|src2
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
operator|)
operator|==
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_DADD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FADDS
argument_list|,
name|FADDD
argument_list|)
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S1A
argument_list|(
name|src1
argument_list|)
operator||
name|S2A
argument_list|(
name|src2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DSUB
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FSUBS
argument_list|,
name|FSUBD
argument_list|)
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S1A
argument_list|(
name|src1
argument_list|)
operator||
name|S2A
argument_list|(
name|src2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DMUL
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FMULS
argument_list|,
name|FMULD
argument_list|)
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S1A
argument_list|(
name|src1
argument_list|)
operator||
name|S2A
argument_list|(
name|src2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DDIV
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FDIVS
argument_list|,
name|FDIVD
argument_list|)
operator||
name|DA
argument_list|(
name|dst_r
argument_list|)
operator||
name|S1A
argument_list|(
name|src1
argument_list|)
operator||
name|S2A
argument_list|(
name|src2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_r
operator|==
name|TMP_FREG2
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
argument_list|,
name|TMP_FREG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_undef
DECL|macro|FLOAT_DATA
undef|#
directive|undef
name|FLOAT_DATA
end_undef
begin_undef
DECL|macro|SELECT_FOP
undef|#
directive|undef
name|SELECT_FOP
end_undef
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Other instructions                                                   */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|D
argument_list|(
name|dst
argument_list|)
operator||
name|S1
argument_list|(
literal|0
argument_list|)
operator||
name|S2
argument_list|(
name|TMP_LINK
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
comment|/* Memory. */
return|return
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_LINK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|D
argument_list|(
name|TMP_LINK
argument_list|)
operator||
name|S1
argument_list|(
literal|0
argument_list|)
operator||
name|S2
argument_list|(
name|src
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_LINK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_LINK
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_LINK
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JMPL
operator||
name|D
argument_list|(
literal|0
argument_list|)
operator||
name|S1
argument_list|(
name|TMP_LINK
argument_list|)
operator||
name|IMM
argument_list|(
literal|8
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Conditional instructions                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|CHECK_PTR
argument_list|(
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|delay_slot
operator|=
name|UNMOVABLE_INS
expr_stmt|;
return|return
name|label
return|;
block|}
end_function
begin_function
DECL|function|get_cc
specifier|static
name|sljit_ins
name|get_cc
parameter_list|(
name|sljit_si
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_EQUAL
case|:
case|case
name|SLJIT_MUL_NOT_OVERFLOW
case|:
case|case
name|SLJIT_D_NOT_EQUAL
case|:
comment|/* Unordered. */
return|return
name|DA
argument_list|(
literal|0x1
argument_list|)
return|;
case|case
name|SLJIT_NOT_EQUAL
case|:
case|case
name|SLJIT_MUL_OVERFLOW
case|:
case|case
name|SLJIT_D_EQUAL
case|:
return|return
name|DA
argument_list|(
literal|0x9
argument_list|)
return|;
case|case
name|SLJIT_LESS
case|:
case|case
name|SLJIT_D_GREATER
case|:
comment|/* Unordered. */
return|return
name|DA
argument_list|(
literal|0x5
argument_list|)
return|;
case|case
name|SLJIT_GREATER_EQUAL
case|:
case|case
name|SLJIT_D_LESS_EQUAL
case|:
return|return
name|DA
argument_list|(
literal|0xd
argument_list|)
return|;
case|case
name|SLJIT_GREATER
case|:
case|case
name|SLJIT_D_GREATER_EQUAL
case|:
comment|/* Unordered. */
return|return
name|DA
argument_list|(
literal|0xc
argument_list|)
return|;
case|case
name|SLJIT_LESS_EQUAL
case|:
case|case
name|SLJIT_D_LESS
case|:
return|return
name|DA
argument_list|(
literal|0x4
argument_list|)
return|;
case|case
name|SLJIT_SIG_LESS
case|:
return|return
name|DA
argument_list|(
literal|0x3
argument_list|)
return|;
case|case
name|SLJIT_SIG_GREATER_EQUAL
case|:
return|return
name|DA
argument_list|(
literal|0xb
argument_list|)
return|;
case|case
name|SLJIT_SIG_GREATER
case|:
return|return
name|DA
argument_list|(
literal|0xa
argument_list|)
return|;
case|case
name|SLJIT_SIG_LESS_EQUAL
case|:
return|return
name|DA
argument_list|(
literal|0x2
argument_list|)
return|;
case|case
name|SLJIT_OVERFLOW
case|:
case|case
name|SLJIT_D_UNORDERED
case|:
return|return
name|DA
argument_list|(
literal|0x7
argument_list|)
return|;
case|case
name|SLJIT_NOT_OVERFLOW
case|:
case|case
name|SLJIT_D_ORDERED
case|:
return|return
name|DA
argument_list|(
literal|0xf
argument_list|)
return|;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|DA
argument_list|(
literal|0x8
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|CHECK_PTR
argument_list|(
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|type
operator|<
name|SLJIT_D_EQUAL
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|IS_COND
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|compiler
operator|->
name|delay_slot
operator|&
name|DST_INS_MASK
operator|)
operator|!=
name|UNMOVABLE_INS
operator|)
operator|&&
operator|!
operator|(
name|compiler
operator|->
name|delay_slot
operator|&
name|ICC_IS_SET
operator|)
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_MOVABLE
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BICC
operator||
name|get_cc
argument_list|(
name|type
operator|^
literal|1
argument_list|)
operator||
literal|5
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Implementation required"
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|<
name|SLJIT_JUMP
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|IS_COND
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|compiler
operator|->
name|delay_slot
operator|&
name|DST_INS_MASK
operator|)
operator|!=
name|UNMOVABLE_INS
operator|)
operator|&&
operator|!
operator|(
name|compiler
operator|->
name|delay_slot
operator|&
name|FCC_IS_SET
operator|)
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_MOVABLE
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FBFCC
operator||
name|get_cc
argument_list|(
name|type
operator|^
literal|1
argument_list|)
operator||
literal|5
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Implementation required"
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|(
name|compiler
operator|->
name|delay_slot
operator|&
name|DST_INS_MASK
operator|)
operator|!=
name|UNMOVABLE_INS
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_MOVABLE
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_CALL
expr_stmt|;
block|}
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JMPL
operator||
name|D
argument_list|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|?
name|TMP_LINK
else|:
literal|0
argument_list|)
operator||
name|S1
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|IMM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|jump
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|sljit_si
name|src_r
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
name|src_r
operator|=
name|src
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
if|if
condition|(
operator|(
name|compiler
operator|->
name|delay_slot
operator|&
name|DST_INS_MASK
operator|)
operator|!=
name|UNMOVABLE_INS
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_MOVABLE
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_CALL
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JMPL
operator||
name|D
argument_list|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|?
name|TMP_LINK
else|:
literal|0
argument_list|)
operator||
name|S1
argument_list|(
name|src_r
argument_list|)
operator||
name|IMM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_si
name|reg
decl_stmt|,
name|flags
init|=
operator|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|?
name|SET_FLAGS
else|:
literal|0
operator|)
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_emit_op_flags
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|op
operator|<
name|SLJIT_ADD
operator|&&
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_ADD
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
name|type
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|type
operator|<
name|SLJIT_D_EQUAL
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BICC
operator||
name|get_cc
argument_list|(
name|type
argument_list|)
operator||
literal|3
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FBFCC
operator||
name|get_cc
argument_list|(
name|type
argument_list|)
operator||
literal|3
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|D
argument_list|(
name|reg
argument_list|)
operator||
name|S1
argument_list|(
literal|0
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|D
argument_list|(
name|reg
argument_list|)
operator||
name|S1
argument_list|(
literal|0
argument_list|)
operator||
name|IMM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_ADD
condition|)
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|CUMULATIVE_OP
operator||
name|IMM_OP
operator||
name|ALT_KEEP_CACHE
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
return|return
operator|(
name|reg
operator|==
name|TMP_REG2
operator|)
condition|?
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
else|:
name|SLJIT_SUCCESS
return|;
else|#
directive|else
error|#
directive|error
literal|"Implementation required"
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|sljit_si
name|reg
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|CHECK_PTR
argument_list|(
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SLOW_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|init_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const_
return|;
block|}
end_function
end_unit
