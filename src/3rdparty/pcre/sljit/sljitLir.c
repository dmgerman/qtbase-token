begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_include
include|#
directive|include
file|"sljitLir.h"
end_include
begin_define
DECL|macro|CHECK_ERROR
define|#
directive|define
name|CHECK_ERROR
parameter_list|()
define|\
value|do { \ 		if (SLJIT_UNLIKELY(compiler->error)) \ 			return compiler->error; \ 	} while (0)
end_define
begin_define
DECL|macro|CHECK_ERROR_PTR
define|#
directive|define
name|CHECK_ERROR_PTR
parameter_list|()
define|\
value|do { \ 		if (SLJIT_UNLIKELY(compiler->error)) \ 			return NULL; \ 	} while (0)
end_define
begin_define
DECL|macro|FAIL_IF
define|#
directive|define
name|FAIL_IF
parameter_list|(
name|expr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(expr)) \ 			return compiler->error; \ 	} while (0)
end_define
begin_define
DECL|macro|PTR_FAIL_IF
define|#
directive|define
name|PTR_FAIL_IF
parameter_list|(
name|expr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(expr)) \ 			return NULL; \ 	} while (0)
end_define
begin_define
DECL|macro|FAIL_IF_NULL
define|#
directive|define
name|FAIL_IF_NULL
parameter_list|(
name|ptr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(!(ptr))) { \ 			compiler->error = SLJIT_ERR_ALLOC_FAILED; \ 			return SLJIT_ERR_ALLOC_FAILED; \ 		} \ 	} while (0)
end_define
begin_define
DECL|macro|PTR_FAIL_IF_NULL
define|#
directive|define
name|PTR_FAIL_IF_NULL
parameter_list|(
name|ptr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(!(ptr))) { \ 			compiler->error = SLJIT_ERR_ALLOC_FAILED; \ 			return NULL; \ 		} \ 	} while (0)
end_define
begin_define
DECL|macro|PTR_FAIL_WITH_EXEC_IF
define|#
directive|define
name|PTR_FAIL_WITH_EXEC_IF
parameter_list|(
name|ptr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(!(ptr))) { \ 			compiler->error = SLJIT_ERR_EX_ALLOC_FAILED; \ 			return NULL; \ 		} \ 	} while (0)
end_define
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_UNSUPPORTED
operator|&&
name|SLJIT_CONFIG_UNSUPPORTED
operator|)
end_if
begin_define
DECL|macro|GET_OPCODE
define|#
directive|define
name|GET_OPCODE
parameter_list|(
name|op
parameter_list|)
define|\
value|((op)& ~(SLJIT_INT_OP | SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))
end_define
begin_define
DECL|macro|GET_FLAGS
define|#
directive|define
name|GET_FLAGS
parameter_list|(
name|op
parameter_list|)
define|\
value|((op)& (SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O | SLJIT_SET_C))
end_define
begin_define
DECL|macro|GET_ALL_FLAGS
define|#
directive|define
name|GET_ALL_FLAGS
parameter_list|(
name|op
parameter_list|)
define|\
value|((op)& (SLJIT_INT_OP | SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))
end_define
begin_define
DECL|macro|TYPE_CAST_NEEDED
define|#
directive|define
name|TYPE_CAST_NEEDED
parameter_list|(
name|op
parameter_list|)
define|\
value|(((op)>= SLJIT_MOV_UB&& (op)<= SLJIT_MOV_SH) || ((op)>= SLJIT_MOVU_UB&& (op)<= SLJIT_MOVU_SH))
end_define
begin_define
DECL|macro|BUF_SIZE
define|#
directive|define
name|BUF_SIZE
value|4096
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_32BIT_ARCHITECTURE
operator|&&
name|SLJIT_32BIT_ARCHITECTURE
operator|)
end_if
begin_define
DECL|macro|ABUF_SIZE
define|#
directive|define
name|ABUF_SIZE
value|2048
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ABUF_SIZE
define|#
directive|define
name|ABUF_SIZE
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Parameter parsing. */
end_comment
begin_define
DECL|macro|REG_MASK
define|#
directive|define
name|REG_MASK
value|0x3f
end_define
begin_define
DECL|macro|OFFS_REG
define|#
directive|define
name|OFFS_REG
parameter_list|(
name|reg
parameter_list|)
value|(((reg)>> 8)& REG_MASK)
end_define
begin_define
DECL|macro|OFFS_REG_MASK
define|#
directive|define
name|OFFS_REG_MASK
value|(REG_MASK<< 8)
end_define
begin_define
DECL|macro|TO_OFFS_REG
define|#
directive|define
name|TO_OFFS_REG
parameter_list|(
name|reg
parameter_list|)
value|((reg)<< 8)
end_define
begin_comment
comment|/* When reg cannot be unused. */
end_comment
begin_define
DECL|macro|FAST_IS_REG
define|#
directive|define
name|FAST_IS_REG
parameter_list|(
name|reg
parameter_list|)
value|((reg)<= REG_MASK)
end_define
begin_comment
comment|/* When reg can be unused. */
end_comment
begin_define
DECL|macro|SLOW_IS_REG
define|#
directive|define
name|SLOW_IS_REG
parameter_list|(
name|reg
parameter_list|)
value|((reg)> 0&& (reg)<= REG_MASK)
end_define
begin_comment
comment|/* Jump flags. */
end_comment
begin_define
DECL|macro|JUMP_LABEL
define|#
directive|define
name|JUMP_LABEL
value|0x1
end_define
begin_define
DECL|macro|JUMP_ADDR
define|#
directive|define
name|JUMP_ADDR
value|0x2
end_define
begin_comment
comment|/* SLJIT_REWRITABLE_JUMP is 0x1000. */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86
operator|&&
name|SLJIT_CONFIG_X86
operator|)
end_if
begin_define
DECL|macro|PATCH_MB
define|#
directive|define
name|PATCH_MB
value|0x4
end_define
begin_define
DECL|macro|PATCH_MW
define|#
directive|define
name|PATCH_MW
value|0x8
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_define
DECL|macro|PATCH_MD
define|#
directive|define
name|PATCH_MD
value|0x10
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
end_if
begin_define
DECL|macro|IS_BL
define|#
directive|define
name|IS_BL
value|0x4
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
end_if
begin_define
DECL|macro|CPOOL_SIZE
define|#
directive|define
name|CPOOL_SIZE
value|512
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
end_if
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|0x04
end_define
begin_define
DECL|macro|IS_BL
define|#
directive|define
name|IS_BL
value|0x08
end_define
begin_comment
comment|/* conditional + imm8 */
end_comment
begin_define
DECL|macro|PATCH_TYPE1
define|#
directive|define
name|PATCH_TYPE1
value|0x10
end_define
begin_comment
comment|/* conditional + imm20 */
end_comment
begin_define
DECL|macro|PATCH_TYPE2
define|#
directive|define
name|PATCH_TYPE2
value|0x20
end_define
begin_comment
comment|/* IT + imm24 */
end_comment
begin_define
DECL|macro|PATCH_TYPE3
define|#
directive|define
name|PATCH_TYPE3
value|0x30
end_define
begin_comment
comment|/* imm11 */
end_comment
begin_define
DECL|macro|PATCH_TYPE4
define|#
directive|define
name|PATCH_TYPE4
value|0x40
end_define
begin_comment
comment|/* imm24 */
end_comment
begin_define
DECL|macro|PATCH_TYPE5
define|#
directive|define
name|PATCH_TYPE5
value|0x50
end_define
begin_comment
comment|/* BL + imm24 */
end_comment
begin_define
DECL|macro|PATCH_BL
define|#
directive|define
name|PATCH_BL
value|0x60
end_define
begin_comment
comment|/* 0xf00 cc code for branches */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_64
operator|&&
name|SLJIT_CONFIG_ARM_64
operator|)
end_if
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|0x004
end_define
begin_define
DECL|macro|IS_CBZ
define|#
directive|define
name|IS_CBZ
value|0x008
end_define
begin_define
DECL|macro|IS_BL
define|#
directive|define
name|IS_BL
value|0x010
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x020
end_define
begin_define
DECL|macro|PATCH_COND
define|#
directive|define
name|PATCH_COND
value|0x040
end_define
begin_define
DECL|macro|PATCH_ABS48
define|#
directive|define
name|PATCH_ABS48
value|0x080
end_define
begin_define
DECL|macro|PATCH_ABS64
define|#
directive|define
name|PATCH_ABS64
value|0x100
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC
operator|&&
name|SLJIT_CONFIG_PPC
operator|)
end_if
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|0x004
end_define
begin_define
DECL|macro|IS_CALL
define|#
directive|define
name|IS_CALL
value|0x008
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x010
end_define
begin_define
DECL|macro|PATCH_ABS_B
define|#
directive|define
name|PATCH_ABS_B
value|0x020
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_define
DECL|macro|PATCH_ABS32
define|#
directive|define
name|PATCH_ABS32
value|0x040
end_define
begin_define
DECL|macro|PATCH_ABS48
define|#
directive|define
name|PATCH_ABS48
value|0x080
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|REMOVE_COND
define|#
directive|define
name|REMOVE_COND
value|0x100
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS
operator|&&
name|SLJIT_CONFIG_MIPS
operator|)
end_if
begin_define
DECL|macro|IS_MOVABLE
define|#
directive|define
name|IS_MOVABLE
value|0x004
end_define
begin_define
DECL|macro|IS_JAL
define|#
directive|define
name|IS_JAL
value|0x008
end_define
begin_define
DECL|macro|IS_CALL
define|#
directive|define
name|IS_CALL
value|0x010
end_define
begin_define
DECL|macro|IS_BIT26_COND
define|#
directive|define
name|IS_BIT26_COND
value|0x020
end_define
begin_define
DECL|macro|IS_BIT16_COND
define|#
directive|define
name|IS_BIT16_COND
value|0x040
end_define
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|(IS_BIT26_COND | IS_BIT16_COND)
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x080
end_define
begin_define
DECL|macro|PATCH_J
define|#
directive|define
name|PATCH_J
value|0x100
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
end_if
begin_define
DECL|macro|PATCH_ABS32
define|#
directive|define
name|PATCH_ABS32
value|0x200
end_define
begin_define
DECL|macro|PATCH_ABS48
define|#
directive|define
name|PATCH_ABS48
value|0x400
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* instruction types */
end_comment
begin_define
DECL|macro|MOVABLE_INS
define|#
directive|define
name|MOVABLE_INS
value|0
end_define
begin_comment
comment|/* 1 - 31 last destination register */
end_comment
begin_comment
comment|/* no destination (i.e: store) */
end_comment
begin_define
DECL|macro|UNMOVABLE_INS
define|#
directive|define
name|UNMOVABLE_INS
value|32
end_define
begin_comment
comment|/* FPU status register */
end_comment
begin_define
DECL|macro|FCSR_FCC
define|#
directive|define
name|FCSR_FCC
value|33
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_TILEGX
operator|&&
name|SLJIT_CONFIG_TILEGX
operator|)
end_if
begin_define
DECL|macro|IS_JAL
define|#
directive|define
name|IS_JAL
value|0x04
end_define
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|0x08
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x10
end_define
begin_define
DECL|macro|PATCH_J
define|#
directive|define
name|PATCH_J
value|0x20
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
end_if
begin_define
DECL|macro|IS_MOVABLE
define|#
directive|define
name|IS_MOVABLE
value|0x04
end_define
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|0x08
end_define
begin_define
DECL|macro|IS_CALL
define|#
directive|define
name|IS_CALL
value|0x10
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x20
end_define
begin_define
DECL|macro|PATCH_CALL
define|#
directive|define
name|PATCH_CALL
value|0x40
end_define
begin_comment
comment|/* instruction types */
end_comment
begin_define
DECL|macro|MOVABLE_INS
define|#
directive|define
name|MOVABLE_INS
value|0
end_define
begin_comment
comment|/* 1 - 31 last destination register */
end_comment
begin_comment
comment|/* no destination (i.e: store) */
end_comment
begin_define
DECL|macro|UNMOVABLE_INS
define|#
directive|define
name|UNMOVABLE_INS
value|32
end_define
begin_define
DECL|macro|DST_INS_MASK
define|#
directive|define
name|DST_INS_MASK
value|0xff
end_define
begin_comment
comment|/* ICC_SET is the same as SET_FLAGS. */
end_comment
begin_define
DECL|macro|ICC_IS_SET
define|#
directive|define
name|ICC_IS_SET
value|(1<< 23)
end_define
begin_define
DECL|macro|FCC_IS_SET
define|#
directive|define
name|FCC_IS_SET
value|(1<< 24)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Stack management. */
end_comment
begin_define
DECL|macro|GET_SAVED_REGISTERS_SIZE
define|#
directive|define
name|GET_SAVED_REGISTERS_SIZE
parameter_list|(
name|scratches
parameter_list|,
name|saveds
parameter_list|,
name|extra
parameter_list|)
define|\
value|(((scratches< SLJIT_NUMBER_OF_SCRATCH_REGISTERS ? 0 : (scratches - SLJIT_NUMBER_OF_SCRATCH_REGISTERS)) + \ 		(saveds< SLJIT_NUMBER_OF_SAVED_REGISTERS ? saveds : SLJIT_NUMBER_OF_SAVED_REGISTERS) + \ 		extra) * sizeof(sljit_sw))
end_define
begin_define
DECL|macro|ADJUST_LOCAL_OFFSET
define|#
directive|define
name|ADJUST_LOCAL_OFFSET
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p) == (SLJIT_MEM1(SLJIT_SP))) \ 		(i) += SLJIT_LOCALS_OFFSET;
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !(defined SLJIT_CONFIG_UNSUPPORTED&& SLJIT_CONFIG_UNSUPPORTED) */
end_comment
begin_comment
comment|/* Utils can still be used even if SLJIT_CONFIG_UNSUPPORTED is set. */
end_comment
begin_include
include|#
directive|include
file|"sljitUtils.c"
end_include
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_UNSUPPORTED
operator|&&
name|SLJIT_CONFIG_UNSUPPORTED
operator|)
end_if
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_EXECUTABLE_ALLOCATOR
operator|&&
name|SLJIT_EXECUTABLE_ALLOCATOR
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitExecAllocator.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Argument checking features. */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
end_if
begin_comment
comment|/* Returns with error when an invalid argument is passed. */
end_comment
begin_define
DECL|macro|CHECK_ARGUMENT
define|#
directive|define
name|CHECK_ARGUMENT
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(!(x))) \ 			return 1; \ 	} while (0)
end_define
begin_define
DECL|macro|CHECK_RETURN_TYPE
define|#
directive|define
name|CHECK_RETURN_TYPE
value|sljit_si
end_define
begin_define
DECL|macro|CHECK_RETURN_OK
define|#
directive|define
name|CHECK_RETURN_OK
value|return 0
end_define
begin_define
DECL|macro|CHECK
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(x)) { \ 			compiler->error = SLJIT_ERR_BAD_ARGUMENT; \ 			return SLJIT_ERR_BAD_ARGUMENT; \ 		} \ 	} while (0)
end_define
begin_define
DECL|macro|CHECK_PTR
define|#
directive|define
name|CHECK_PTR
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(x)) { \ 			compiler->error = SLJIT_ERR_BAD_ARGUMENT; \ 			return NULL; \ 		} \ 	} while (0)
end_define
begin_define
DECL|macro|CHECK_REG_INDEX
define|#
directive|define
name|CHECK_REG_INDEX
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(x)) { \ 			return -2; \ 		} \ 	} while (0)
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
end_elif
begin_comment
comment|/* Assertion failure occures if an invalid argument is passed. */
end_comment
begin_undef
DECL|macro|SLJIT_ARGUMENT_CHECKS
undef|#
directive|undef
name|SLJIT_ARGUMENT_CHECKS
end_undef
begin_define
DECL|macro|SLJIT_ARGUMENT_CHECKS
define|#
directive|define
name|SLJIT_ARGUMENT_CHECKS
value|1
end_define
begin_define
DECL|macro|CHECK_ARGUMENT
define|#
directive|define
name|CHECK_ARGUMENT
parameter_list|(
name|x
parameter_list|)
value|SLJIT_ASSERT(x)
end_define
begin_define
DECL|macro|CHECK_RETURN_TYPE
define|#
directive|define
name|CHECK_RETURN_TYPE
value|void
end_define
begin_define
DECL|macro|CHECK_RETURN_OK
define|#
directive|define
name|CHECK_RETURN_OK
value|return
end_define
begin_define
DECL|macro|CHECK
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|CHECK_PTR
define|#
directive|define
name|CHECK_PTR
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|CHECK_REG_INDEX
define|#
directive|define
name|CHECK_REG_INDEX
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_elif
begin_comment
comment|/* Arguments are not checked. */
end_comment
begin_define
DECL|macro|CHECK_RETURN_TYPE
define|#
directive|define
name|CHECK_RETURN_TYPE
value|void
end_define
begin_define
DECL|macro|CHECK_RETURN_OK
define|#
directive|define
name|CHECK_RETURN_OK
value|return
end_define
begin_define
DECL|macro|CHECK
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|CHECK_PTR
define|#
directive|define
name|CHECK_PTR
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|CHECK_REG_INDEX
define|#
directive|define
name|CHECK_REG_INDEX
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Arguments are not checked. */
end_comment
begin_define
DECL|macro|CHECK
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
end_define
begin_define
DECL|macro|CHECK_PTR
define|#
directive|define
name|CHECK_PTR
parameter_list|(
name|x
parameter_list|)
end_define
begin_define
DECL|macro|CHECK_REG_INDEX
define|#
directive|define
name|CHECK_REG_INDEX
parameter_list|(
name|x
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SLJIT_ARGUMENT_CHECKS */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Public functions                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_X86
operator|&&
name|SLJIT_CONFIG_X86
operator|)
end_if
begin_define
DECL|macro|SLJIT_NEEDS_COMPILER_INIT
define|#
directive|define
name|SLJIT_NEEDS_COMPILER_INIT
value|1
end_define
begin_decl_stmt
DECL|variable|compiler_initialized
specifier|static
name|sljit_si
name|compiler_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* A thread safe initialization. */
end_comment
begin_function_decl
specifier|static
name|void
name|init_compiler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_create_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_compiler
modifier|*
name|sljit_create_compiler
parameter_list|(
name|void
modifier|*
name|allocator_data
parameter_list|)
block|{
name|struct
name|sljit_compiler
modifier|*
name|compiler
init|=
operator|(
expr|struct
name|sljit_compiler
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_compiler
argument_list|)
argument_list|,
name|allocator_data
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
return|return
name|NULL
return|;
name|SLJIT_ZEROMEM
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_compiler
argument_list|)
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
operator|==
literal|1
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_ub
argument_list|)
operator|==
literal|1
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_sh
argument_list|)
operator|==
literal|2
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_uh
argument_list|)
operator|==
literal|2
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|==
literal|4
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_ui
argument_list|)
operator|==
literal|4
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|sljit_p
argument_list|)
operator|==
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|sljit_p
argument_list|)
operator|==
literal|8
operator|)
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_p
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|==
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|==
literal|8
operator|)
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|==
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|==
literal|8
operator|)
argument_list|,
name|invalid_integer_types
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|SLJIT_INT_OP
operator|==
name|SLJIT_SINGLE_OP
argument_list|,
name|int_op_and_single_op_must_be_the_same
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|SLJIT_REWRITABLE_JUMP
operator|!=
name|SLJIT_SINGLE_OP
argument_list|,
name|rewritable_jump_and_single_op_must_not_be_the_same
argument_list|)
expr_stmt|;
comment|/* Only the non-zero members must be set. */
name|compiler
operator|->
name|error
operator|=
name|SLJIT_SUCCESS
expr_stmt|;
name|compiler
operator|->
name|allocator_data
operator|=
name|allocator_data
expr_stmt|;
name|compiler
operator|->
name|buf
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|BUF_SIZE
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|ABUF_SIZE
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compiler
operator|->
name|buf
operator|||
operator|!
name|compiler
operator|->
name|abuf
condition|)
block|{
if|if
condition|(
name|compiler
operator|->
name|buf
condition|)
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|buf
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|abuf
condition|)
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|abuf
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|compiler
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|compiler
operator|->
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|compiler
operator|->
name|buf
operator|->
name|used_size
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|->
name|used_size
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
operator|-
literal|1
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
operator|-
literal|1
expr_stmt|;
name|compiler
operator|->
name|fscratches
operator|=
operator|-
literal|1
expr_stmt|;
name|compiler
operator|->
name|fsaveds
operator|=
operator|-
literal|1
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|compiler
operator|->
name|args
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|compiler
operator|->
name|cpool
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|CPOOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|+
name|CPOOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ub
argument_list|)
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compiler
operator|->
name|cpool
condition|)
block|{
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|buf
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|abuf
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|compiler
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|compiler
operator|->
name|cpool_unique
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
operator|(
name|compiler
operator|->
name|cpool
operator|+
name|CPOOL_SIZE
operator|)
expr_stmt|;
name|compiler
operator|->
name|cpool_diff
operator|=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS
operator|&&
name|SLJIT_CONFIG_MIPS
operator|)
name|compiler
operator|->
name|delay_slot
operator|=
name|UNMOVABLE_INS
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|compiler
operator|->
name|delay_slot
operator|=
name|UNMOVABLE_INS
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_NEEDS_COMPILER_INIT
operator|&&
name|SLJIT_NEEDS_COMPILER_INIT
operator|)
if|if
condition|(
operator|!
name|compiler_initialized
condition|)
block|{
name|init_compiler
argument_list|()
expr_stmt|;
name|compiler_initialized
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|compiler
return|;
block|}
end_function
begin_function
DECL|function|sljit_free_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_compiler
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|curr
decl_stmt|;
name|void
modifier|*
name|allocator_data
init|=
name|compiler
operator|->
name|allocator_data
decl_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|allocator_data
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|buf
condition|)
block|{
name|curr
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|curr
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|compiler
operator|->
name|abuf
expr_stmt|;
while|while
condition|(
name|buf
condition|)
block|{
name|curr
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|curr
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|cpool
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLJIT_FREE
argument_list|(
name|compiler
argument_list|,
name|allocator_data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_compiler_memory_error
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_compiler_memory_error
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
if|if
condition|(
name|compiler
operator|->
name|error
operator|==
name|SLJIT_SUCCESS
condition|)
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_ALLOC_FAILED
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
end_if
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
comment|/* Remove thumb mode flag. */
name|SLJIT_FREE_EXEC
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|sljit_uw
operator|)
name|code
operator|&
operator|~
literal|0x1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
end_elif
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
comment|/* Resolve indirection. */
name|code
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
operator|(
name|sljit_uw
operator|*
operator|)
name|code
operator|)
expr_stmt|;
name|SLJIT_FREE_EXEC
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
name|SLJIT_FREE_EXEC
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_set_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_label
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_LIKELY
argument_list|(
operator|!
operator|!
name|jump
argument_list|)
operator|&&
name|SLJIT_LIKELY
argument_list|(
operator|!
operator|!
name|label
argument_list|)
condition|)
block|{
name|jump
operator|->
name|flags
operator|&=
operator|~
name|JUMP_ADDR
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|JUMP_LABEL
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|label
operator|=
name|label
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sljit_set_target
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_target
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uw
name|target
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_LIKELY
argument_list|(
operator|!
operator|!
name|jump
argument_list|)
condition|)
block|{
name|jump
operator|->
name|flags
operator|&=
operator|~
name|JUMP_LABEL
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|JUMP_ADDR
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Private functions                                                    */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|ensure_buf
specifier|static
name|void
modifier|*
name|ensure_buf
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|size
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|ret
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|new_frag
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|<=
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|buf
operator|->
name|used_size
operator|+
name|size
operator|<=
operator|(
name|BUF_SIZE
operator|-
operator|(
name|sljit_uw
operator|)
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_memory_fragment
argument_list|,
name|memory
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|compiler
operator|->
name|buf
operator|->
name|memory
operator|+
name|compiler
operator|->
name|buf
operator|->
name|used_size
expr_stmt|;
name|compiler
operator|->
name|buf
operator|->
name|used_size
operator|+=
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
name|new_frag
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|BUF_SIZE
argument_list|,
name|compiler
operator|->
name|allocator_data
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|new_frag
argument_list|)
expr_stmt|;
name|new_frag
operator|->
name|next
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|compiler
operator|->
name|buf
operator|=
name|new_frag
expr_stmt|;
name|new_frag
operator|->
name|used_size
operator|=
name|size
expr_stmt|;
return|return
name|new_frag
operator|->
name|memory
return|;
block|}
end_function
begin_function
DECL|function|ensure_abuf
specifier|static
name|void
modifier|*
name|ensure_abuf
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|size
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|ret
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|new_frag
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|<=
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|abuf
operator|->
name|used_size
operator|+
name|size
operator|<=
operator|(
name|ABUF_SIZE
operator|-
operator|(
name|sljit_uw
operator|)
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_memory_fragment
argument_list|,
name|memory
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|compiler
operator|->
name|abuf
operator|->
name|memory
operator|+
name|compiler
operator|->
name|abuf
operator|->
name|used_size
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|->
name|used_size
operator|+=
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
name|new_frag
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|ABUF_SIZE
argument_list|,
name|compiler
operator|->
name|allocator_data
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|new_frag
argument_list|)
expr_stmt|;
name|new_frag
operator|->
name|next
operator|=
name|compiler
operator|->
name|abuf
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|=
name|new_frag
expr_stmt|;
name|new_frag
operator|->
name|used_size
operator|=
name|size
expr_stmt|;
return|return
name|new_frag
operator|->
name|memory
return|;
block|}
end_function
begin_function
DECL|function|sljit_alloc_memory
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_alloc_memory
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_64BIT_ARCHITECTURE
operator|&&
name|SLJIT_64BIT_ARCHITECTURE
operator|)
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|128
condition|)
return|return
name|NULL
return|;
name|size
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|64
condition|)
return|return
name|NULL
return|;
name|size
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
endif|#
directive|endif
return|return
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|reverse_buf
specifier|static
name|SLJIT_INLINE
name|void
name|reverse_buf
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
init|=
name|compiler
operator|->
name|buf
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|tmp
decl_stmt|;
do|do
block|{
name|tmp
operator|=
name|buf
operator|->
name|next
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|tmp
expr_stmt|;
block|}
do|while
condition|(
name|buf
operator|!=
name|NULL
condition|)
do|;
name|compiler
operator|->
name|buf
operator|=
name|prev
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_emit_enter
specifier|static
name|SLJIT_INLINE
name|void
name|set_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
name|compiler
operator|->
name|fscratches
operator|=
name|fscratches
expr_stmt|;
name|compiler
operator|->
name|fsaveds
operator|=
name|fsaveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|set_set_context
specifier|static
name|SLJIT_INLINE
name|void
name|set_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
name|compiler
operator|->
name|fscratches
operator|=
name|fscratches
expr_stmt|;
name|compiler
operator|->
name|fsaveds
operator|=
name|fsaveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|set_label
specifier|static
name|SLJIT_INLINE
name|void
name|set_label
parameter_list|(
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|,
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|label
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
condition|)
name|compiler
operator|->
name|last_label
operator|->
name|next
operator|=
name|label
expr_stmt|;
else|else
name|compiler
operator|->
name|labels
operator|=
name|label
expr_stmt|;
name|compiler
operator|->
name|last_label
operator|=
name|label
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_jump
specifier|static
name|SLJIT_INLINE
name|void
name|set_jump
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|)
block|{
name|jump
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|jump
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_jump
condition|)
name|compiler
operator|->
name|last_jump
operator|->
name|next
operator|=
name|jump
expr_stmt|;
else|else
name|compiler
operator|->
name|jumps
operator|=
name|jump
expr_stmt|;
name|compiler
operator|->
name|last_jump
operator|=
name|jump
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_const
specifier|static
name|SLJIT_INLINE
name|void
name|set_const
parameter_list|(
name|struct
name|sljit_const
modifier|*
name|const_
parameter_list|,
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|const_
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|const_
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_const
condition|)
name|compiler
operator|->
name|last_const
operator|->
name|next
operator|=
name|const_
expr_stmt|;
else|else
name|compiler
operator|->
name|consts
operator|=
name|const_
expr_stmt|;
name|compiler
operator|->
name|last_const
operator|=
name|const_
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|ADDRESSING_DEPENDS_ON
define|#
directive|define
name|ADDRESSING_DEPENDS_ON
parameter_list|(
name|exp
parameter_list|,
name|reg
parameter_list|)
define|\
value|(((exp)& SLJIT_MEM)&& (((exp)& REG_MASK) == reg || OFFS_REG(exp) == reg))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
end_if
begin_define
DECL|macro|FUNCTION_CHECK_OP
define|#
directive|define
name|FUNCTION_CHECK_OP
parameter_list|()
define|\
value|CHECK_ARGUMENT(!GET_FLAGS(op) || !(op& SLJIT_KEEP_FLAGS)); \ 	switch (GET_OPCODE(op)) { \ 	case SLJIT_NOT: \ 	case SLJIT_CLZ: \ 	case SLJIT_AND: \ 	case SLJIT_OR: \ 	case SLJIT_XOR: \ 	case SLJIT_SHL: \ 	case SLJIT_LSHR: \ 	case SLJIT_ASHR: \ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O | SLJIT_SET_C))); \ 		break; \ 	case SLJIT_NEG: \ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_C))); \ 		break; \ 	case SLJIT_MUL: \ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_C))); \ 		break; \ 	case SLJIT_ADD: \ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_U | SLJIT_SET_S))); \ 		break; \ 	case SLJIT_SUB: \ 		break; \ 	case SLJIT_ADDC: \ 	case SLJIT_SUBC: \ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O))); \ 		break; \ 	case SLJIT_BREAKPOINT: \ 	case SLJIT_NOP: \ 	case SLJIT_LUMUL: \ 	case SLJIT_LSMUL: \ 	case SLJIT_MOV: \ 	case SLJIT_MOV_UI: \ 	case SLJIT_MOV_P: \ 	case SLJIT_MOVU: \ 	case SLJIT_MOVU_UI: \ 	case SLJIT_MOVU_P: \
comment|/* Nothing allowed */
value|\ 		CHECK_ARGUMENT(!(op& (SLJIT_INT_OP | SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))); \ 		break; \ 	default: \
comment|/* Only SLJIT_INT_OP or SLJIT_SINGLE_OP is allowed. */
value|\ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))); \ 		break; \ 	}
end_define
begin_define
DECL|macro|FUNCTION_CHECK_FOP
define|#
directive|define
name|FUNCTION_CHECK_FOP
parameter_list|()
define|\
value|CHECK_ARGUMENT(!GET_FLAGS(op) || !(op& SLJIT_KEEP_FLAGS)); \ 	switch (GET_OPCODE(op)) { \ 	case SLJIT_DCMP: \ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))); \ 		CHECK_ARGUMENT((op& (SLJIT_SET_E | SLJIT_SET_S))); \ 		break; \ 	default: \
comment|/* Only SLJIT_INT_OP or SLJIT_SINGLE_OP is allowed. */
value|\ 		CHECK_ARGUMENT(!(op& (SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))); \ 		break; \ 	}
end_define
begin_define
DECL|macro|FUNCTION_CHECK_IS_REG
define|#
directive|define
name|FUNCTION_CHECK_IS_REG
parameter_list|(
name|r
parameter_list|)
define|\
value|(((r)>= SLJIT_R0&& (r)< (SLJIT_R0 + compiler->scratches)) || \ 	((r)> (SLJIT_S0 - compiler->saveds)&& (r)<= SLJIT_S0))
end_define
begin_define
DECL|macro|FUNCTION_CHECK_IS_REG_OR_UNUSED
define|#
directive|define
name|FUNCTION_CHECK_IS_REG_OR_UNUSED
parameter_list|(
name|r
parameter_list|)
define|\
value|((r) == SLJIT_UNUSED || \ 	((r)>= SLJIT_R0&& (r)< (SLJIT_R0 + compiler->scratches)) || \ 	((r)> (SLJIT_S0 - compiler->saveds)&& (r)<= SLJIT_S0))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
end_if
begin_define
DECL|macro|CHECK_NOT_VIRTUAL_REGISTER
define|#
directive|define
name|CHECK_NOT_VIRTUAL_REGISTER
parameter_list|(
name|p
parameter_list|)
define|\
value|CHECK_ARGUMENT((p)< SLJIT_R3 || (p)> SLJIT_R6);
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|CHECK_NOT_VIRTUAL_REGISTER
define|#
directive|define
name|CHECK_NOT_VIRTUAL_REGISTER
parameter_list|(
name|p
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|FUNCTION_CHECK_SRC
define|#
directive|define
name|FUNCTION_CHECK_SRC
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|CHECK_ARGUMENT(compiler->scratches != -1&& compiler->saveds != -1); \ 	if (FUNCTION_CHECK_IS_REG(p)) \ 		CHECK_ARGUMENT((i) == 0); \ 	else if ((p) == SLJIT_IMM) \ 		; \ 	else if ((p) == (SLJIT_MEM1(SLJIT_SP))) \ 		CHECK_ARGUMENT((i)>= 0&& (i)< compiler->logical_local_size); \ 	else { \ 		CHECK_ARGUMENT((p)& SLJIT_MEM); \ 		CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG_OR_UNUSED((p)& REG_MASK)); \ 		CHECK_NOT_VIRTUAL_REGISTER((p)& REG_MASK); \ 		if ((p)& OFFS_REG_MASK) { \ 			CHECK_ARGUMENT(((p)& REG_MASK) != SLJIT_UNUSED); \ 			CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(OFFS_REG(p))); \ 			CHECK_NOT_VIRTUAL_REGISTER(OFFS_REG(p)); \ 			CHECK_ARGUMENT(!((i)& ~0x3)); \ 		} \ 		CHECK_ARGUMENT(!((p)& ~(SLJIT_MEM | SLJIT_IMM | REG_MASK | OFFS_REG_MASK))); \ 	}
end_define
begin_define
DECL|macro|FUNCTION_CHECK_DST
define|#
directive|define
name|FUNCTION_CHECK_DST
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|CHECK_ARGUMENT(compiler->scratches != -1&& compiler->saveds != -1); \ 	if (FUNCTION_CHECK_IS_REG_OR_UNUSED(p)) \ 		CHECK_ARGUMENT((i) == 0); \ 	else if ((p) == (SLJIT_MEM1(SLJIT_SP))) \ 		CHECK_ARGUMENT((i)>= 0&& (i)< compiler->logical_local_size); \ 	else { \ 		CHECK_ARGUMENT((p)& SLJIT_MEM); \ 		CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG_OR_UNUSED((p)& REG_MASK)); \ 		CHECK_NOT_VIRTUAL_REGISTER((p)& REG_MASK); \ 		if ((p)& OFFS_REG_MASK) { \ 			CHECK_ARGUMENT(((p)& REG_MASK) != SLJIT_UNUSED); \ 			CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(OFFS_REG(p))); \ 			CHECK_NOT_VIRTUAL_REGISTER(OFFS_REG(p)); \ 			CHECK_ARGUMENT(!((i)& ~0x3)); \ 		} \ 		CHECK_ARGUMENT(!((p)& ~(SLJIT_MEM | SLJIT_IMM | REG_MASK | OFFS_REG_MASK))); \ 	}
end_define
begin_define
DECL|macro|FUNCTION_FCHECK
define|#
directive|define
name|FUNCTION_FCHECK
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|CHECK_ARGUMENT(compiler->fscratches != -1&& compiler->fsaveds != -1); \ 	if (((p)>= SLJIT_FR0&& (p)< (SLJIT_FR0 + compiler->fscratches)) || \ 			((p)> (SLJIT_FS0 - compiler->fsaveds)&& (p)<= SLJIT_FS0)) \ 		CHECK_ARGUMENT(i == 0); \ 	else if ((p) == (SLJIT_MEM1(SLJIT_SP))) \ 		CHECK_ARGUMENT((i)>= 0&& (i)< compiler->logical_local_size); \ 	else { \ 		CHECK_ARGUMENT((p)& SLJIT_MEM); \ 		CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG_OR_UNUSED((p)& REG_MASK)); \ 		CHECK_NOT_VIRTUAL_REGISTER((p)& REG_MASK); \ 		if ((p)& OFFS_REG_MASK) { \ 			CHECK_ARGUMENT(((p)& REG_MASK) != SLJIT_UNUSED); \ 			CHECK_ARGUMENT(FUNCTION_CHECK_IS_REG(OFFS_REG(p))); \ 			CHECK_NOT_VIRTUAL_REGISTER(OFFS_REG(p)); \ 			CHECK_ARGUMENT(((p)& OFFS_REG_MASK) != TO_OFFS_REG(SLJIT_SP)&& !(i& ~0x3)); \ 		} \ 		CHECK_ARGUMENT(!((p)& ~(SLJIT_MEM | SLJIT_IMM | REG_MASK | OFFS_REG_MASK))); \ 	}
end_define
begin_define
DECL|macro|FUNCTION_CHECK_OP1
define|#
directive|define
name|FUNCTION_CHECK_OP1
parameter_list|()
define|\
value|if (GET_OPCODE(op)>= SLJIT_MOVU&& GET_OPCODE(op)<= SLJIT_MOVU_P) { \ 		CHECK_ARGUMENT(!(src& SLJIT_MEM) || (src& REG_MASK) != SLJIT_SP); \ 		CHECK_ARGUMENT(!(dst& SLJIT_MEM) || (dst& REG_MASK) != SLJIT_SP); \ 		if ((src& SLJIT_MEM)&& (src& REG_MASK)) \ 			CHECK_ARGUMENT((dst& REG_MASK) != (src& REG_MASK)&& OFFS_REG(dst) != (src& REG_MASK)); \ 	}
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SLJIT_ARGUMENT_CHECKS */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_if
begin_function
DECL|function|sljit_compiler_verbose
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_compiler_verbose
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|FILE
modifier|*
name|verbose
parameter_list|)
block|{
name|compiler
operator|->
name|verbose
operator|=
name|verbose
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_64BIT_ARCHITECTURE
operator|&&
name|SLJIT_64BIT_ARCHITECTURE
operator|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN64
end_ifdef
begin_define
DECL|macro|SLJIT_PRINT_D
define|#
directive|define
name|SLJIT_PRINT_D
value|"I64"
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SLJIT_PRINT_D
define|#
directive|define
name|SLJIT_PRINT_D
value|"l"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SLJIT_PRINT_D
define|#
directive|define
name|SLJIT_PRINT_D
value|""
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|sljit_verbose_reg
define|#
directive|define
name|sljit_verbose_reg
parameter_list|(
name|compiler
parameter_list|,
name|r
parameter_list|)
define|\
value|do { \ 		if ((r)< (SLJIT_R0 + compiler->scratches)) \ 			fprintf(compiler->verbose, "r%d", (r) - SLJIT_R0); \ 		else \ 			fprintf(compiler->verbose, "s%d", SLJIT_NUMBER_OF_REGISTERS - (r)); \ 	} while (0)
end_define
begin_define
DECL|macro|sljit_verbose_param
define|#
directive|define
name|sljit_verbose_param
parameter_list|(
name|compiler
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p)& SLJIT_IMM) \ 		fprintf(compiler->verbose, "#%" SLJIT_PRINT_D "d", (i)); \ 	else if ((p)& SLJIT_MEM) { \ 		if ((p)& REG_MASK) { \ 			fputc('[', compiler->verbose); \ 			sljit_verbose_reg(compiler, (p)& REG_MASK); \ 			if ((p)& OFFS_REG_MASK) { \ 				fprintf(compiler->verbose, " + "); \ 				sljit_verbose_reg(compiler, OFFS_REG(p)); \ 				if (i) \ 					fprintf(compiler->verbose, " * %d", 1<< (i)); \ 			} \ 			else if (i) \ 				fprintf(compiler->verbose, " + %" SLJIT_PRINT_D "d", (i)); \ 			fputc(']', compiler->verbose); \ 		} \ 		else \ 			fprintf(compiler->verbose, "[#%" SLJIT_PRINT_D "d]", (i)); \ 	} else if (p) \ 		sljit_verbose_reg(compiler, p); \ 	else \ 		fprintf(compiler->verbose, "unused");
end_define
begin_define
DECL|macro|sljit_verbose_fparam
define|#
directive|define
name|sljit_verbose_fparam
parameter_list|(
name|compiler
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p)& SLJIT_MEM) { \ 		if ((p)& REG_MASK) { \ 			fputc('[', compiler->verbose); \ 			sljit_verbose_reg(compiler, (p)& REG_MASK); \ 			if ((p)& OFFS_REG_MASK) { \ 				fprintf(compiler->verbose, " + "); \ 				sljit_verbose_reg(compiler, OFFS_REG(p)); \ 				if (i) \ 					fprintf(compiler->verbose, "%d", 1<< (i)); \ 			} \ 			else if (i) \ 				fprintf(compiler->verbose, "%" SLJIT_PRINT_D "d", (i)); \ 			fputc(']', compiler->verbose); \ 		} \ 		else \ 			fprintf(compiler->verbose, "[#%" SLJIT_PRINT_D "d]", (i)); \ 	} \ 	else { \ 		if ((p)< (SLJIT_FR0 + compiler->fscratches)) \ 			fprintf(compiler->verbose, "fr%d", (p) - SLJIT_FR0); \ 		else \ 			fprintf(compiler->verbose, "fs%d", SLJIT_NUMBER_OF_FLOAT_REGISTERS - (p)); \ 	}
end_define
begin_decl_stmt
DECL|variable|op0_names
specifier|static
name|SLJIT_CONST
name|char
modifier|*
name|op0_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"breakpoint"
block|,
operator|(
name|char
operator|*
operator|)
literal|"nop"
block|,
operator|(
name|char
operator|*
operator|)
literal|"lumul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"lsmul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"udivmod"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sdivmod"
block|,
operator|(
name|char
operator|*
operator|)
literal|"udivi"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sdivi"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|op1_names
specifier|static
name|SLJIT_CONST
name|char
modifier|*
name|op1_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"mov"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov_ub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov_sb"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov_uh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov_sh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov_ui"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov_si"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov_p"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu_ub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu_sb"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu_uh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu_sh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu_ui"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu_si"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu_p"
block|,
operator|(
name|char
operator|*
operator|)
literal|"not"
block|,
operator|(
name|char
operator|*
operator|)
literal|"neg"
block|,
operator|(
name|char
operator|*
operator|)
literal|"clz"
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|op2_names
specifier|static
name|SLJIT_CONST
name|char
modifier|*
name|op2_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"add"
block|,
operator|(
name|char
operator|*
operator|)
literal|"addc"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"subc"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"and"
block|,
operator|(
name|char
operator|*
operator|)
literal|"or"
block|,
operator|(
name|char
operator|*
operator|)
literal|"xor"
block|,
operator|(
name|char
operator|*
operator|)
literal|"shl"
block|,
operator|(
name|char
operator|*
operator|)
literal|"lshr"
block|,
operator|(
name|char
operator|*
operator|)
literal|"ashr"
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fop1_names
specifier|static
name|SLJIT_CONST
name|char
modifier|*
name|fop1_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"mov"
block|,
operator|(
name|char
operator|*
operator|)
literal|"conv"
block|,
operator|(
name|char
operator|*
operator|)
literal|"conv"
block|,
operator|(
name|char
operator|*
operator|)
literal|"conv"
block|,
operator|(
name|char
operator|*
operator|)
literal|"conv"
block|,
operator|(
name|char
operator|*
operator|)
literal|"conv"
block|,
operator|(
name|char
operator|*
operator|)
literal|"cmp"
block|,
operator|(
name|char
operator|*
operator|)
literal|"neg"
block|,
operator|(
name|char
operator|*
operator|)
literal|"abs"
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fop2_names
specifier|static
name|SLJIT_CONST
name|char
modifier|*
name|fop2_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"add"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"div"
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|JUMP_PREFIX
define|#
directive|define
name|JUMP_PREFIX
parameter_list|(
name|type
parameter_list|)
define|\
value|((type& 0xff)<= SLJIT_MUL_NOT_OVERFLOW ? ((type& SLJIT_INT_OP) ? "i_" : "") \ 	: ((type& 0xff)<= SLJIT_D_ORDERED ? ((type& SLJIT_SINGLE_OP) ? "s_" : "d_") : ""))
end_define
begin_decl_stmt
DECL|variable|jump_names
specifier|static
name|char
modifier|*
name|jump_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"not_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"less"
block|,
operator|(
name|char
operator|*
operator|)
literal|"greater_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"greater"
block|,
operator|(
name|char
operator|*
operator|)
literal|"less_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sig_less"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sig_greater_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sig_greater"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sig_less_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"not_overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mul_overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mul_not_overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"not_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"less"
block|,
operator|(
name|char
operator|*
operator|)
literal|"greater_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"greater"
block|,
operator|(
name|char
operator|*
operator|)
literal|"less_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"unordered"
block|,
operator|(
name|char
operator|*
operator|)
literal|"ordered"
block|,
operator|(
name|char
operator|*
operator|)
literal|"jump"
block|,
operator|(
name|char
operator|*
operator|)
literal|"fast_call"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call0"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call1"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call2"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call3"
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SLJIT_VERBOSE */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Arch dependent                                                       */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_if
begin_function
DECL|function|check_sljit_generate_code
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|compiler
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
comment|/* All jumps have target. */
name|CHECK_ARGUMENT
argument_list|(
name|jump
operator|->
name|flags
operator|&
operator|(
name|JUMP_LABEL
operator||
name|JUMP_ADDR
operator|)
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_enter
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
operator|!
operator|(
name|options
operator|&
operator|~
name|SLJIT_DOUBLE_ALIGNMENT
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|args
operator|>=
literal|0
operator|&&
name|args
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|scratches
operator|>=
literal|0
operator|&&
name|scratches
operator|<=
name|SLJIT_NUMBER_OF_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|saveds
operator|>=
literal|0
operator|&&
name|saveds
operator|<=
name|SLJIT_NUMBER_OF_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|scratches
operator|+
name|saveds
operator|<=
name|SLJIT_NUMBER_OF_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|args
operator|<=
name|saveds
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|fscratches
operator|>=
literal|0
operator|&&
name|fscratches
operator|<=
name|SLJIT_NUMBER_OF_FLOAT_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|fsaveds
operator|>=
literal|0
operator|&&
name|fsaveds
operator|<=
name|SLJIT_NUMBER_OF_FLOAT_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|fscratches
operator|+
name|fsaveds
operator|<=
name|SLJIT_NUMBER_OF_FLOAT_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|local_size
operator|>=
literal|0
operator|&&
name|local_size
operator|<=
name|SLJIT_MAX_LOCAL_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  enter options:none args:%d scratches:%d saveds:%d fscratches:%d fsaveds:%d local_size:%d\n"
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|fscratches
argument_list|,
name|fsaveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_set_context
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
operator|!
operator|(
name|options
operator|&
operator|~
name|SLJIT_DOUBLE_ALIGNMENT
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|args
operator|>=
literal|0
operator|&&
name|args
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|scratches
operator|>=
literal|0
operator|&&
name|scratches
operator|<=
name|SLJIT_NUMBER_OF_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|saveds
operator|>=
literal|0
operator|&&
name|saveds
operator|<=
name|SLJIT_NUMBER_OF_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|scratches
operator|+
name|saveds
operator|<=
name|SLJIT_NUMBER_OF_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|args
operator|<=
name|saveds
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|fscratches
operator|>=
literal|0
operator|&&
name|fscratches
operator|<=
name|SLJIT_NUMBER_OF_FLOAT_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|fsaveds
operator|>=
literal|0
operator|&&
name|fsaveds
operator|<=
name|SLJIT_NUMBER_OF_FLOAT_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|fscratches
operator|+
name|fsaveds
operator|<=
name|SLJIT_NUMBER_OF_FLOAT_REGISTERS
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|local_size
operator|>=
literal|0
operator|&&
name|local_size
operator|<=
name|SLJIT_MAX_LOCAL_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  set_context options:none args:%d scratches:%d saveds:%d fscratches:%d fsaveds:%d local_size:%d\n"
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|fscratches
argument_list|,
name|fsaveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_return
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|compiler
operator|->
name|scratches
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|SLJIT_UNUSED
condition|)
block|{
name|CHECK_ARGUMENT
argument_list|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOV_P
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
block|}
else|else
name|CHECK_ARGUMENT
argument_list|(
name|src
operator|==
literal|0
operator|&&
name|srcw
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_UNUSED
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  return\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  return.%s "
argument_list|,
name|op1_names
index|[
name|op
operator|-
name|SLJIT_OP1_BASE
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fast_enter
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  fast_enter "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fast_return
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  fast_return "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op0
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|op
operator|>=
name|SLJIT_BREAKPOINT
operator|&&
name|op
operator|<=
name|SLJIT_LSMUL
operator|)
operator|||
operator|(
operator|(
name|op
operator|&
operator|~
name|SLJIT_INT_OP
operator|)
operator|>=
name|SLJIT_UDIVMOD
operator|&&
operator|(
name|op
operator|&
operator|~
name|SLJIT_INT_OP
operator|)
operator|<=
name|SLJIT_SDIVI
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|op
operator|<
name|SLJIT_LUMUL
operator|||
name|compiler
operator|->
name|scratches
operator|>=
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s\n"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|op0_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_OP0_BASE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op1
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_MOV
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_CLZ
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_OP
argument_list|()
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_OP1
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s%s%s%s%s%s%s "
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|op1_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_OP1_BASE
index|]
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|""
else|:
literal|".e"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_U
operator|)
condition|?
literal|""
else|:
literal|".u"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_S
operator|)
condition|?
literal|""
else|:
literal|".s"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_O
operator|)
condition|?
literal|""
else|:
literal|".o"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_C
operator|)
condition|?
literal|""
else|:
literal|".c"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|""
else|:
literal|".k"
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op2
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_ADD
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_ASHR
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_OP
argument_list|()
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s%s%s%s%s%s%s "
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|op2_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_OP2_BASE
index|]
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|""
else|:
literal|".e"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_U
operator|)
condition|?
literal|""
else|:
literal|".u"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_S
operator|)
condition|?
literal|""
else|:
literal|".s"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_O
operator|)
condition|?
literal|""
else|:
literal|".o"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_C
operator|)
condition|?
literal|""
else|:
literal|".c"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|""
else|:
literal|".k"
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_get_register_index
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|reg
operator|>
literal|0
operator|&&
name|reg
operator|<=
name|SLJIT_NUMBER_OF_REGISTERS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_get_float_register_index
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_get_float_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|reg
operator|>
literal|0
operator|&&
name|reg
operator|<=
name|SLJIT_NUMBER_OF_FLOAT_REGISTERS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op_custom
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86
operator|&&
name|SLJIT_CONFIG_X86
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<
literal|16
argument_list|)
expr_stmt|;
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|size
operator|==
literal|2
operator|&&
operator|(
operator|(
operator|(
name|sljit_sw
operator|)
name|instruction
operator|)
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|size
operator|==
literal|4
operator|&&
operator|(
operator|(
operator|(
name|sljit_sw
operator|)
name|instruction
operator|)
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|CHECK_ARGUMENT
argument_list|(
name|size
operator|==
literal|4
operator|&&
operator|(
operator|(
operator|(
name|sljit_sw
operator|)
name|instruction
operator|)
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  op_custom"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|" 0x%x"
argument_list|,
operator|(
operator|(
name|sljit_ub
operator|*
operator|)
name|instruction
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fop1
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_DMOV
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_DABS
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_FOP
argument_list|()
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CONVD_FROMS
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s "
argument_list|,
name|fop1_names
index|[
name|SLJIT_CONVD_FROMS
operator|-
name|SLJIT_FOP1_BASE
index|]
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s.fromd"
else|:
literal|"d.froms"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s "
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|,
name|fop1_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_FOP1_BASE
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fop1_cmp
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fop1_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_DCMP
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_FOP
argument_list|()
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s%s%s "
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|,
name|fop1_names
index|[
name|SLJIT_DCMP
operator|-
name|SLJIT_FOP1_BASE
index|]
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|".e"
else|:
literal|""
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SET_S
operator|)
condition|?
literal|".s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fop1_convw_fromd
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fop1_convw_fromd
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_CONVW_FROMD
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_CONVI_FROMD
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_FOP
argument_list|()
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s.from%s "
argument_list|,
name|fop1_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_FOP1_BASE
index|]
argument_list|,
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CONVI_FROMD
operator|)
condition|?
literal|"i"
else|:
literal|"w"
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fop1_convd_fromw
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fop1_convd_fromw
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_CONVD_FROMW
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_CONVD_FROMI
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_FOP
argument_list|()
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s.from%s "
argument_list|,
name|fop1_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_FOP1_BASE
index|]
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|,
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CONVD_FROMI
operator|)
condition|?
literal|"i"
else|:
literal|"w"
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fop2
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_DADD
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_DDIV
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_FOP
argument_list|()
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s "
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|,
name|fop2_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_FOP2_BASE
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_label
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"label:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_jump
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
literal|0xff
operator||
name|SLJIT_REWRITABLE_JUMP
operator||
name|SLJIT_INT_OP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|>=
name|SLJIT_EQUAL
operator|&&
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_CALL3
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<
name|SLJIT_JUMP
operator|||
operator|!
operator|(
name|type
operator|&
name|SLJIT_INT_OP
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_CALL0
operator|||
operator|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|-
name|SLJIT_CALL0
operator|)
operator|<=
name|compiler
operator|->
name|scratches
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  jump%s.%s%s\n"
argument_list|,
operator|!
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|?
literal|""
else|:
literal|".r"
argument_list|,
name|JUMP_PREFIX
argument_list|(
name|type
argument_list|)
argument_list|,
name|jump_names
index|[
name|type
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_cmp
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
literal|0xff
operator||
name|SLJIT_REWRITABLE_JUMP
operator||
name|SLJIT_INT_OP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|>=
name|SLJIT_EQUAL
operator|&&
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_SIG_LESS_EQUAL
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  cmp%s.%s%s "
argument_list|,
operator|!
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|?
literal|""
else|:
literal|".r"
argument_list|,
operator|(
name|type
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|"i_"
else|:
literal|""
argument_list|,
name|jump_names
index|[
name|type
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fcmp
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
literal|0xff
operator||
name|SLJIT_REWRITABLE_JUMP
operator||
name|SLJIT_SINGLE_OP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|>=
name|SLJIT_D_EQUAL
operator|&&
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_D_ORDERED
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  fcmp%s.%s%s "
argument_list|,
operator|!
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|?
literal|""
else|:
literal|".r"
argument_list|,
operator|(
name|type
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s_"
else|:
literal|"d_"
argument_list|,
name|jump_names
index|[
name|type
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|compiler
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_ijump
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
name|CHECK_RETURN_OK
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
name|type
operator|>=
name|SLJIT_JUMP
operator|&&
name|type
operator|<=
name|SLJIT_CALL3
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|type
operator|<=
name|SLJIT_CALL0
operator|||
operator|(
name|type
operator|-
name|SLJIT_CALL0
operator|)
operator|<=
name|compiler
operator|->
name|scratches
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  ijump.%s "
argument_list|,
name|jump_names
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op_flags
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|CHECK_ARGUMENT
argument_list|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
literal|0xff
operator||
name|SLJIT_INT_OP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|>=
name|SLJIT_EQUAL
operator|&&
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_D_ORDERED
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MOV_UI
operator|||
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MOV_SI
operator|||
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_AND
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_XOR
operator|)
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_U
operator||
name|SLJIT_SET_S
operator||
name|SLJIT_SET_O
operator||
name|SLJIT_SET_C
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|CHECK_ARGUMENT
argument_list|(
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_KEEP_FLAGS
operator|)
operator|)
operator|!=
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_KEEP_FLAGS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<
name|SLJIT_ADD
condition|)
block|{
name|CHECK_ARGUMENT
argument_list|(
name|src
operator|==
name|SLJIT_UNUSED
operator|&&
name|srcw
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK_ARGUMENT
argument_list|(
name|src
operator|==
name|dst
operator|&&
name|srcw
operator|==
name|dstw
argument_list|)
expr_stmt|;
block|}
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  flags.%s%s%s%s "
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_OP2_BASE
condition|?
name|op2_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_OP2_BASE
index|]
else|:
name|op1_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|-
name|SLJIT_OP1_BASE
index|]
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|""
else|:
literal|".e"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|""
else|:
literal|".k"
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|SLJIT_UNUSED
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", %s%s\n"
argument_list|,
name|JUMP_PREFIX
argument_list|(
name|type
argument_list|)
argument_list|,
name|jump_names
index|[
name|type
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_get_local_base
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  local_base "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", #%"
name|SLJIT_PRINT_D
literal|"d\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_const
specifier|static
name|SLJIT_INLINE
name|CHECK_RETURN_TYPE
name|check_sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|init_value
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  const "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", #%"
name|SLJIT_PRINT_D
literal|"d\n"
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CHECK_RETURN_OK
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SLJIT_ARGUMENT_CHECKS || SLJIT_VERBOSE */
end_comment
begin_define
DECL|macro|SELECT_FOP1_OPERATION_WITH_CHECKS
define|#
directive|define
name|SELECT_FOP1_OPERATION_WITH_CHECKS
parameter_list|(
name|compiler
parameter_list|,
name|op
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|SLJIT_COMPILE_ASSERT(!(SLJIT_CONVW_FROMD& 0x1)&& !(SLJIT_CONVD_FROMW& 0x1), \ 		invalid_float_opcodes); \ 	if (GET_OPCODE(op)>= SLJIT_CONVW_FROMD&& GET_OPCODE(op)<= SLJIT_DCMP) { \ 		if (GET_OPCODE(op) == SLJIT_DCMP) { \ 			CHECK(check_sljit_emit_fop1_cmp(compiler, op, dst, dstw, src, srcw)); \ 			ADJUST_LOCAL_OFFSET(dst, dstw); \ 			ADJUST_LOCAL_OFFSET(src, srcw); \ 			return sljit_emit_fop1_cmp(compiler, op, dst, dstw, src, srcw); \ 		} \ 		if ((GET_OPCODE(op) | 0x1) == SLJIT_CONVI_FROMD) { \ 			CHECK(check_sljit_emit_fop1_convw_fromd(compiler, op, dst, dstw, src, srcw)); \ 			ADJUST_LOCAL_OFFSET(dst, dstw); \ 			ADJUST_LOCAL_OFFSET(src, srcw); \ 			return sljit_emit_fop1_convw_fromd(compiler, op, dst, dstw, src, srcw); \ 		} \ 		CHECK(check_sljit_emit_fop1_convd_fromw(compiler, op, dst, dstw, src, srcw)); \ 		ADJUST_LOCAL_OFFSET(dst, dstw); \ 		ADJUST_LOCAL_OFFSET(src, srcw); \ 		return sljit_emit_fop1_convd_fromw(compiler, op, dst, dstw, src, srcw); \ 	} \ 	CHECK(check_sljit_emit_fop1(compiler, op, dst, dstw, src, srcw)); \ 	ADJUST_LOCAL_OFFSET(dst, dstw); \ 	ADJUST_LOCAL_OFFSET(src, srcw);
end_define
begin_function
DECL|function|emit_mov_before_return
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_mov_before_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
comment|/* Return if don't need to do anything. */
if|if
condition|(
name|op
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_64BIT_ARCHITECTURE
operator|&&
name|SLJIT_64BIT_ARCHITECTURE
operator|)
comment|/* At the moment the pointer size is always equal to sljit_sw. May be changed in the future. */
if|if
condition|(
name|src
operator|==
name|SLJIT_RETURN_REG
operator|&&
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|op
operator|==
name|SLJIT_MOV_P
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
else|#
directive|else
if|if
condition|(
name|src
operator|==
name|SLJIT_RETURN_REG
operator|&&
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|op
operator|==
name|SLJIT_MOV_UI
operator|||
name|op
operator|==
name|SLJIT_MOV_SI
operator|||
name|op
operator|==
name|SLJIT_MOV_P
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* CPU description section */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_32BIT_ARCHITECTURE
operator|&&
name|SLJIT_32BIT_ARCHITECTURE
operator|)
end_if
begin_define
DECL|macro|SLJIT_CPUINFO_PART1
define|#
directive|define
name|SLJIT_CPUINFO_PART1
value|" 32bit ("
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_64BIT_ARCHITECTURE
operator|&&
name|SLJIT_64BIT_ARCHITECTURE
operator|)
end_elif
begin_define
DECL|macro|SLJIT_CPUINFO_PART1
define|#
directive|define
name|SLJIT_CPUINFO_PART1
value|" 64bit ("
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"Internal error: CPU type info missing"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_LITTLE_ENDIAN
operator|&&
name|SLJIT_LITTLE_ENDIAN
operator|)
end_if
begin_define
DECL|macro|SLJIT_CPUINFO_PART2
define|#
directive|define
name|SLJIT_CPUINFO_PART2
value|"little endian + "
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_BIG_ENDIAN
operator|&&
name|SLJIT_BIG_ENDIAN
operator|)
end_elif
begin_define
DECL|macro|SLJIT_CPUINFO_PART2
define|#
directive|define
name|SLJIT_CPUINFO_PART2
value|"big endian + "
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"Internal error: CPU type info missing"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
operator|)
end_if
begin_define
DECL|macro|SLJIT_CPUINFO_PART3
define|#
directive|define
name|SLJIT_CPUINFO_PART3
value|"unaligned)"
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SLJIT_CPUINFO_PART3
define|#
directive|define
name|SLJIT_CPUINFO_PART3
value|"aligned)"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|SLJIT_CPUINFO
define|#
directive|define
name|SLJIT_CPUINFO
value|SLJIT_CPUINFO_PART1 SLJIT_CPUINFO_PART2 SLJIT_CPUINFO_PART3
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86
operator|&&
name|SLJIT_CONFIG_X86
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitNativeX86_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeARM_32.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeARM_32.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeARM_T2_32.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_64
operator|&&
name|SLJIT_CONFIG_ARM_64
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeARM_64.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_PPC
operator|&&
name|SLJIT_CONFIG_PPC
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativePPC_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_MIPS
operator|&&
name|SLJIT_CONFIG_MIPS
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeMIPS_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_SPARC
operator|&&
name|SLJIT_CONFIG_SPARC
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeSPARC_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_TILEGX
operator|&&
name|SLJIT_CONFIG_TILEGX
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeTILEGX_64.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_MIPS
operator|&&
name|SLJIT_CONFIG_MIPS
operator|)
end_if
begin_function
DECL|function|sljit_emit_cmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* Default compare for most architectures. */
name|sljit_si
name|flags
decl_stmt|,
name|tmp_src
decl_stmt|,
name|condition
decl_stmt|;
name|sljit_sw
name|tmp_srcw
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|CHECK_PTR
argument_list|(
name|check_sljit_emit_cmp
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|condition
operator|=
name|type
operator|&
literal|0xff
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_64
operator|&&
name|SLJIT_CONFIG_ARM_64
operator|)
if|if
condition|(
operator|(
name|condition
operator|==
name|SLJIT_EQUAL
operator|||
name|condition
operator|==
name|SLJIT_NOT_EQUAL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|!
name|src1w
condition|)
block|{
name|src1
operator|=
name|src2
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
name|src2
operator|=
name|SLJIT_IMM
expr_stmt|;
name|src2w
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|!
name|src2w
condition|)
return|return
name|emit_cmp_to0
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
argument_list|)
condition|)
block|{
comment|/* Immediate is prefered as second argument by most architectures. */
switch|switch
condition|(
name|condition
condition|)
block|{
case|case
name|SLJIT_LESS
case|:
name|condition
operator|=
name|SLJIT_GREATER
expr_stmt|;
break|break;
case|case
name|SLJIT_GREATER_EQUAL
case|:
name|condition
operator|=
name|SLJIT_LESS_EQUAL
expr_stmt|;
break|break;
case|case
name|SLJIT_GREATER
case|:
name|condition
operator|=
name|SLJIT_LESS
expr_stmt|;
break|break;
case|case
name|SLJIT_LESS_EQUAL
case|:
name|condition
operator|=
name|SLJIT_GREATER_EQUAL
expr_stmt|;
break|break;
case|case
name|SLJIT_SIG_LESS
case|:
name|condition
operator|=
name|SLJIT_SIG_GREATER
expr_stmt|;
break|break;
case|case
name|SLJIT_SIG_GREATER_EQUAL
case|:
name|condition
operator|=
name|SLJIT_SIG_LESS_EQUAL
expr_stmt|;
break|break;
case|case
name|SLJIT_SIG_GREATER
case|:
name|condition
operator|=
name|SLJIT_SIG_LESS
expr_stmt|;
break|break;
case|case
name|SLJIT_SIG_LESS_EQUAL
case|:
name|condition
operator|=
name|SLJIT_SIG_GREATER_EQUAL
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|condition
operator||
operator|(
name|type
operator|&
operator|(
name|SLJIT_INT_OP
operator||
name|SLJIT_REWRITABLE_JUMP
operator|)
operator|)
expr_stmt|;
name|tmp_src
operator|=
name|src1
expr_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src2
operator|=
name|tmp_src
expr_stmt|;
name|tmp_srcw
operator|=
name|src1w
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
name|src2w
operator|=
name|tmp_srcw
expr_stmt|;
block|}
if|if
condition|(
name|condition
operator|<=
name|SLJIT_NOT_ZERO
condition|)
name|flags
operator|=
name|SLJIT_SET_E
expr_stmt|;
elseif|else
if|if
condition|(
name|condition
operator|<=
name|SLJIT_LESS_EQUAL
condition|)
name|flags
operator|=
name|SLJIT_SET_U
expr_stmt|;
else|else
name|flags
operator|=
name|SLJIT_SET_S
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|PTR_FAIL_IF
argument_list|(
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
operator||
name|flags
operator||
operator|(
name|type
operator|&
name|SLJIT_INT_OP
operator|)
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|condition
operator||
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fcmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|flags
decl_stmt|,
name|condition
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|CHECK_PTR
argument_list|(
name|check_sljit_emit_fcmp
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|condition
operator|=
name|type
operator|&
literal|0xff
expr_stmt|;
name|flags
operator|=
operator|(
name|condition
operator|<=
name|SLJIT_D_NOT_EQUAL
operator|)
condition|?
name|SLJIT_SET_E
else|:
name|SLJIT_SET_S
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|SLJIT_SINGLE_OP
condition|)
name|flags
operator||=
name|SLJIT_SINGLE_OP
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|SLJIT_DCMP
operator||
name|flags
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|condition
operator||
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_X86
operator|&&
name|SLJIT_CONFIG_X86
operator|)
end_if
begin_function
DECL|function|sljit_get_local_base
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|CHECK
argument_list|(
name|check_sljit_get_local_base
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SP
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
operator||
name|SLJIT_KEEP_FLAGS
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_SP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|offset
argument_list|)
return|;
return|return
name|sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_SP
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SLJIT_CONFIG_UNSUPPORTED */
end_comment
begin_comment
comment|/* Empty function bodies for those machines, which are not (yet) supported. */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"unsupported"
return|;
block|}
end_function
begin_function
DECL|function|sljit_create_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_compiler
modifier|*
name|sljit_create_compiler
parameter_list|(
name|void
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_free_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_compiler
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_alloc_memory
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_alloc_memory
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_if
begin_function
DECL|function|sljit_compiler_verbose
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_compiler_verbose
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|FILE
modifier|*
name|verbose
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|scratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|fscratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|fsaveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|scratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|fscratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|fsaveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_cmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fcmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_label
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_target
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_target
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uw
name|target
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_local_base
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|initval
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|initval
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|new_addr
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|new_constant
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
end_unit
