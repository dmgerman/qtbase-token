begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_include
include|#
directive|include
file|"sljitLir.h"
end_include
begin_define
DECL|macro|CHECK_ERROR
define|#
directive|define
name|CHECK_ERROR
parameter_list|()
define|\
value|do { \ 		if (SLJIT_UNLIKELY(compiler->error)) \ 			return compiler->error; \ 	} while (0)
end_define
begin_define
DECL|macro|CHECK_ERROR_PTR
define|#
directive|define
name|CHECK_ERROR_PTR
parameter_list|()
define|\
value|do { \ 		if (SLJIT_UNLIKELY(compiler->error)) \ 			return NULL; \ 	} while (0)
end_define
begin_define
DECL|macro|CHECK_ERROR_VOID
define|#
directive|define
name|CHECK_ERROR_VOID
parameter_list|()
define|\
value|do { \ 		if (SLJIT_UNLIKELY(compiler->error)) \ 			return; \ 	} while (0)
end_define
begin_define
DECL|macro|FAIL_IF
define|#
directive|define
name|FAIL_IF
parameter_list|(
name|expr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(expr)) \ 			return compiler->error; \ 	} while (0)
end_define
begin_define
DECL|macro|PTR_FAIL_IF
define|#
directive|define
name|PTR_FAIL_IF
parameter_list|(
name|expr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(expr)) \ 			return NULL; \ 	} while (0)
end_define
begin_define
DECL|macro|FAIL_IF_NULL
define|#
directive|define
name|FAIL_IF_NULL
parameter_list|(
name|ptr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(!(ptr))) { \ 			compiler->error = SLJIT_ERR_ALLOC_FAILED; \ 			return SLJIT_ERR_ALLOC_FAILED; \ 		} \ 	} while (0)
end_define
begin_define
DECL|macro|PTR_FAIL_IF_NULL
define|#
directive|define
name|PTR_FAIL_IF_NULL
parameter_list|(
name|ptr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(!(ptr))) { \ 			compiler->error = SLJIT_ERR_ALLOC_FAILED; \ 			return NULL; \ 		} \ 	} while (0)
end_define
begin_define
DECL|macro|PTR_FAIL_WITH_EXEC_IF
define|#
directive|define
name|PTR_FAIL_WITH_EXEC_IF
parameter_list|(
name|ptr
parameter_list|)
define|\
value|do { \ 		if (SLJIT_UNLIKELY(!(ptr))) { \ 			compiler->error = SLJIT_ERR_EX_ALLOC_FAILED; \ 			return NULL; \ 		} \ 	} while (0)
end_define
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_UNSUPPORTED
operator|&&
name|SLJIT_CONFIG_UNSUPPORTED
operator|)
end_if
begin_define
DECL|macro|GET_OPCODE
define|#
directive|define
name|GET_OPCODE
parameter_list|(
name|op
parameter_list|)
define|\
value|((op)& ~(SLJIT_INT_OP | SLJIT_SET_E | SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))
end_define
begin_define
DECL|macro|GET_FLAGS
define|#
directive|define
name|GET_FLAGS
parameter_list|(
name|op
parameter_list|)
define|\
value|((op)& (SLJIT_SET_E | SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C))
end_define
begin_define
DECL|macro|GET_ALL_FLAGS
define|#
directive|define
name|GET_ALL_FLAGS
parameter_list|(
name|op
parameter_list|)
define|\
value|((op)& (SLJIT_INT_OP | SLJIT_SET_E | SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))
end_define
begin_define
DECL|macro|TYPE_CAST_NEEDED
define|#
directive|define
name|TYPE_CAST_NEEDED
parameter_list|(
name|op
parameter_list|)
define|\
value|(((op)>= SLJIT_MOV_UB&& (op)<= SLJIT_MOV_SH) || ((op)>= SLJIT_MOVU_UB&& (op)<= SLJIT_MOVU_SH))
end_define
begin_define
DECL|macro|BUF_SIZE
define|#
directive|define
name|BUF_SIZE
value|4096
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_32BIT_ARCHITECTURE
operator|&&
name|SLJIT_32BIT_ARCHITECTURE
operator|)
end_if
begin_define
DECL|macro|ABUF_SIZE
define|#
directive|define
name|ABUF_SIZE
value|2048
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ABUF_SIZE
define|#
directive|define
name|ABUF_SIZE
value|4096
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Jump flags. */
end_comment
begin_define
DECL|macro|JUMP_LABEL
define|#
directive|define
name|JUMP_LABEL
value|0x1
end_define
begin_define
DECL|macro|JUMP_ADDR
define|#
directive|define
name|JUMP_ADDR
value|0x2
end_define
begin_comment
comment|/* SLJIT_REWRITABLE_JUMP is 0x1000. */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_define
DECL|macro|PATCH_MB
define|#
directive|define
name|PATCH_MB
value|0x4
end_define
begin_define
DECL|macro|PATCH_MW
define|#
directive|define
name|PATCH_MW
value|0x8
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_define
DECL|macro|PATCH_MD
define|#
directive|define
name|PATCH_MD
value|0x10
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
end_if
begin_define
DECL|macro|IS_BL
define|#
directive|define
name|IS_BL
value|0x4
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
end_if
begin_define
DECL|macro|CPOOL_SIZE
define|#
directive|define
name|CPOOL_SIZE
value|512
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
end_if
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|0x04
end_define
begin_define
DECL|macro|IS_BL
define|#
directive|define
name|IS_BL
value|0x08
end_define
begin_comment
comment|/* cannot be encoded as branch */
end_comment
begin_define
DECL|macro|B_TYPE0
define|#
directive|define
name|B_TYPE0
value|0x00
end_define
begin_comment
comment|/* conditional + imm8 */
end_comment
begin_define
DECL|macro|B_TYPE1
define|#
directive|define
name|B_TYPE1
value|0x10
end_define
begin_comment
comment|/* conditional + imm20 */
end_comment
begin_define
DECL|macro|B_TYPE2
define|#
directive|define
name|B_TYPE2
value|0x20
end_define
begin_comment
comment|/* IT + imm24 */
end_comment
begin_define
DECL|macro|B_TYPE3
define|#
directive|define
name|B_TYPE3
value|0x30
end_define
begin_comment
comment|/* imm11 */
end_comment
begin_define
DECL|macro|B_TYPE4
define|#
directive|define
name|B_TYPE4
value|0x40
end_define
begin_comment
comment|/* imm24 */
end_comment
begin_define
DECL|macro|B_TYPE5
define|#
directive|define
name|B_TYPE5
value|0x50
end_define
begin_comment
comment|/* BL + imm24 */
end_comment
begin_define
DECL|macro|BL_TYPE6
define|#
directive|define
name|BL_TYPE6
value|0x60
end_define
begin_comment
comment|/* 0xf00 cc code for branches */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_define
DECL|macro|UNCOND_B
define|#
directive|define
name|UNCOND_B
value|0x04
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x08
end_define
begin_define
DECL|macro|ABSOLUTE_B
define|#
directive|define
name|ABSOLUTE_B
value|0x10
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_define
DECL|macro|IS_MOVABLE
define|#
directive|define
name|IS_MOVABLE
value|0x04
end_define
begin_define
DECL|macro|IS_JAL
define|#
directive|define
name|IS_JAL
value|0x08
end_define
begin_define
DECL|macro|IS_BIT26_COND
define|#
directive|define
name|IS_BIT26_COND
value|0x10
end_define
begin_define
DECL|macro|IS_BIT16_COND
define|#
directive|define
name|IS_BIT16_COND
value|0x20
end_define
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|(IS_BIT26_COND | IS_BIT16_COND)
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x40
end_define
begin_define
DECL|macro|PATCH_J
define|#
directive|define
name|PATCH_J
value|0x80
end_define
begin_comment
comment|/* instruction types */
end_comment
begin_define
DECL|macro|MOVABLE_INS
define|#
directive|define
name|MOVABLE_INS
value|0
end_define
begin_comment
comment|/* 1 - 31 last destination register */
end_comment
begin_comment
comment|/* no destination (i.e: store) */
end_comment
begin_define
DECL|macro|UNMOVABLE_INS
define|#
directive|define
name|UNMOVABLE_INS
value|32
end_define
begin_comment
comment|/* FPU status register */
end_comment
begin_define
DECL|macro|FCSR_FCC
define|#
directive|define
name|FCSR_FCC
value|33
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
end_if
begin_define
DECL|macro|IS_MOVABLE
define|#
directive|define
name|IS_MOVABLE
value|0x04
end_define
begin_define
DECL|macro|IS_COND
define|#
directive|define
name|IS_COND
value|0x08
end_define
begin_define
DECL|macro|IS_CALL
define|#
directive|define
name|IS_CALL
value|0x10
end_define
begin_define
DECL|macro|PATCH_B
define|#
directive|define
name|PATCH_B
value|0x20
end_define
begin_define
DECL|macro|PATCH_CALL
define|#
directive|define
name|PATCH_CALL
value|0x40
end_define
begin_comment
comment|/* instruction types */
end_comment
begin_define
DECL|macro|MOVABLE_INS
define|#
directive|define
name|MOVABLE_INS
value|0
end_define
begin_comment
comment|/* 1 - 31 last destination register */
end_comment
begin_comment
comment|/* no destination (i.e: store) */
end_comment
begin_define
DECL|macro|UNMOVABLE_INS
define|#
directive|define
name|UNMOVABLE_INS
value|32
end_define
begin_define
DECL|macro|DST_INS_MASK
define|#
directive|define
name|DST_INS_MASK
value|0xff
end_define
begin_comment
comment|/* ICC_SET is the same as SET_FLAGS. */
end_comment
begin_define
DECL|macro|ICC_IS_SET
define|#
directive|define
name|ICC_IS_SET
value|(1<< 23)
end_define
begin_define
DECL|macro|FCC_IS_SET
define|#
directive|define
name|FCC_IS_SET
value|(1<< 24)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
end_if
begin_define
DECL|macro|SLJIT_HAS_VARIABLE_LOCALS_OFFSET
define|#
directive|define
name|SLJIT_HAS_VARIABLE_LOCALS_OFFSET
value|1
end_define
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
end_if
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|(3 * sizeof(sljit_sw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_define
DECL|macro|SLJIT_HAS_FIXED_LOCALS_OFFSET
define|#
directive|define
name|SLJIT_HAS_FIXED_LOCALS_OFFSET
value|1
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN64
end_ifdef
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|((4 + 2) * sizeof(sljit_sw))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|(sizeof(sljit_sw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
end_if
begin_define
DECL|macro|SLJIT_HAS_FIXED_LOCALS_OFFSET
define|#
directive|define
name|SLJIT_HAS_FIXED_LOCALS_OFFSET
value|1
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
end_if
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|((6 + 8) * sizeof(sljit_sw))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|(2 * sizeof(sljit_sw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_define
DECL|macro|SLJIT_HAS_FIXED_LOCALS_OFFSET
define|#
directive|define
name|SLJIT_HAS_FIXED_LOCALS_OFFSET
value|1
end_define
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|((6 + 8) * sizeof(sljit_sw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_define
DECL|macro|SLJIT_HAS_FIXED_LOCALS_OFFSET
define|#
directive|define
name|SLJIT_HAS_FIXED_LOCALS_OFFSET
value|1
end_define
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|(4 * sizeof(sljit_sw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
end_if
begin_define
DECL|macro|SLJIT_HAS_FIXED_LOCALS_OFFSET
define|#
directive|define
name|SLJIT_HAS_FIXED_LOCALS_OFFSET
value|1
end_define
begin_define
DECL|macro|FIXED_LOCALS_OFFSET
define|#
directive|define
name|FIXED_LOCALS_OFFSET
value|(23 * sizeof(sljit_sw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_HAS_VARIABLE_LOCALS_OFFSET
operator|&&
name|SLJIT_HAS_VARIABLE_LOCALS_OFFSET
operator|)
end_if
begin_define
DECL|macro|ADJUST_LOCAL_OFFSET
define|#
directive|define
name|ADJUST_LOCAL_OFFSET
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p) == (SLJIT_MEM1(SLJIT_LOCALS_REG))) \ 		(i) += compiler->locals_offset;
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_HAS_FIXED_LOCALS_OFFSET
operator|&&
name|SLJIT_HAS_FIXED_LOCALS_OFFSET
operator|)
end_elif
begin_define
DECL|macro|ADJUST_LOCAL_OFFSET
define|#
directive|define
name|ADJUST_LOCAL_OFFSET
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p) == (SLJIT_MEM1(SLJIT_LOCALS_REG))) \ 		(i) += FIXED_LOCALS_OFFSET;
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ADJUST_LOCAL_OFFSET
define|#
directive|define
name|ADJUST_LOCAL_OFFSET
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !(defined SLJIT_CONFIG_UNSUPPORTED&& SLJIT_CONFIG_UNSUPPORTED) */
end_comment
begin_comment
comment|/* Utils can still be used even if SLJIT_CONFIG_UNSUPPORTED is set. */
end_comment
begin_include
include|#
directive|include
file|"sljitUtils.c"
end_include
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_UNSUPPORTED
operator|&&
name|SLJIT_CONFIG_UNSUPPORTED
operator|)
end_if
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_EXECUTABLE_ALLOCATOR
operator|&&
name|SLJIT_EXECUTABLE_ALLOCATOR
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitExecAllocator.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
operator|&&
operator|!
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
end_if
begin_error
error|#
directive|error
error|SLJIT_SSE2_AUTO cannot be enabled without SLJIT_SSE2
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Public functions                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
operator|||
operator|(
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
operator|&&
operator|(
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
operator|)
operator|)
end_if
begin_define
DECL|macro|SLJIT_NEEDS_COMPILER_INIT
define|#
directive|define
name|SLJIT_NEEDS_COMPILER_INIT
value|1
end_define
begin_decl_stmt
DECL|variable|compiler_initialized
specifier|static
name|sljit_si
name|compiler_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* A thread safe initialization. */
end_comment
begin_function_decl
specifier|static
name|void
name|init_compiler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_create_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_compiler
modifier|*
name|sljit_create_compiler
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sljit_compiler
modifier|*
name|compiler
init|=
operator|(
expr|struct
name|sljit_compiler
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_compiler
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
return|return
name|NULL
return|;
name|SLJIT_ZEROMEM
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_compiler
argument_list|)
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
operator|==
literal|1
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_ub
argument_list|)
operator|==
literal|1
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_sh
argument_list|)
operator|==
literal|2
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_uh
argument_list|)
operator|==
literal|2
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|==
literal|4
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_ui
argument_list|)
operator|==
literal|4
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|sljit_p
argument_list|)
operator|==
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|sljit_p
argument_list|)
operator|==
literal|8
operator|)
operator|&&
sizeof|sizeof
argument_list|(
name|sljit_p
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|==
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|==
literal|8
operator|)
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|==
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|==
literal|8
operator|)
argument_list|,
name|invalid_integer_types
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|SLJIT_INT_OP
operator|==
name|SLJIT_SINGLE_OP
argument_list|,
name|int_op_and_single_op_must_be_the_same
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|SLJIT_REWRITABLE_JUMP
operator|!=
name|SLJIT_SINGLE_OP
argument_list|,
name|rewritable_jump_and_single_op_must_not_be_the_same
argument_list|)
expr_stmt|;
comment|/* Only the non-zero members must be set. */
name|compiler
operator|->
name|error
operator|=
name|SLJIT_SUCCESS
expr_stmt|;
name|compiler
operator|->
name|buf
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|BUF_SIZE
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|ABUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compiler
operator|->
name|buf
operator|||
operator|!
name|compiler
operator|->
name|abuf
condition|)
block|{
if|if
condition|(
name|compiler
operator|->
name|buf
condition|)
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|abuf
condition|)
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|abuf
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|compiler
operator|->
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|compiler
operator|->
name|buf
operator|->
name|used_size
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|->
name|used_size
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
operator|-
literal|1
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|compiler
operator|->
name|args
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|compiler
operator|->
name|cpool
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|CPOOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|+
name|CPOOL_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compiler
operator|->
name|cpool
condition|)
block|{
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|buf
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|abuf
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|compiler
operator|->
name|cpool_unique
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
operator|(
name|compiler
operator|->
name|cpool
operator|+
name|CPOOL_SIZE
operator|)
expr_stmt|;
name|compiler
operator|->
name|cpool_diff
operator|=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
name|compiler
operator|->
name|delay_slot
operator|=
name|UNMOVABLE_INS
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
name|compiler
operator|->
name|delay_slot
operator|=
name|UNMOVABLE_INS
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_NEEDS_COMPILER_INIT
operator|&&
name|SLJIT_NEEDS_COMPILER_INIT
operator|)
if|if
condition|(
operator|!
name|compiler_initialized
condition|)
block|{
name|init_compiler
argument_list|()
expr_stmt|;
name|compiler_initialized
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|compiler
return|;
block|}
end_function
begin_function
DECL|function|sljit_free_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_compiler
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|curr
decl_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|buf
condition|)
block|{
name|curr
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|curr
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|compiler
operator|->
name|abuf
expr_stmt|;
while|while
condition|(
name|buf
condition|)
block|{
name|curr
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|curr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|SLJIT_FREE
argument_list|(
name|compiler
operator|->
name|cpool
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLJIT_FREE
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
end_if
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
comment|/* Remove thumb mode flag. */
name|SLJIT_FREE_EXEC
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|sljit_uw
operator|)
name|code
operator|&
operator|~
literal|0x1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
end_elif
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
comment|/* Resolve indirection. */
name|code
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
operator|(
name|sljit_uw
operator|*
operator|)
name|code
operator|)
expr_stmt|;
name|SLJIT_FREE_EXEC
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
name|SLJIT_FREE_EXEC
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_set_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_label
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_LIKELY
argument_list|(
operator|!
operator|!
name|jump
argument_list|)
operator|&&
name|SLJIT_LIKELY
argument_list|(
operator|!
operator|!
name|label
argument_list|)
condition|)
block|{
name|jump
operator|->
name|flags
operator|&=
operator|~
name|JUMP_ADDR
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|JUMP_LABEL
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|label
operator|=
name|label
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sljit_set_target
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_target
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uw
name|target
parameter_list|)
block|{
if|if
condition|(
name|SLJIT_LIKELY
argument_list|(
operator|!
operator|!
name|jump
argument_list|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|jump
operator|->
name|flags
operator|&=
operator|~
name|JUMP_LABEL
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|JUMP_ADDR
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Private functions                                                    */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|ensure_buf
specifier|static
name|void
modifier|*
name|ensure_buf
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|size
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|ret
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|new_frag
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|<=
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|buf
operator|->
name|used_size
operator|+
name|size
operator|<=
operator|(
name|BUF_SIZE
operator|-
operator|(
name|sljit_uw
operator|)
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_memory_fragment
argument_list|,
name|memory
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|compiler
operator|->
name|buf
operator|->
name|memory
operator|+
name|compiler
operator|->
name|buf
operator|->
name|used_size
expr_stmt|;
name|compiler
operator|->
name|buf
operator|->
name|used_size
operator|+=
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
name|new_frag
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|BUF_SIZE
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|new_frag
argument_list|)
expr_stmt|;
name|new_frag
operator|->
name|next
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|compiler
operator|->
name|buf
operator|=
name|new_frag
expr_stmt|;
name|new_frag
operator|->
name|used_size
operator|=
name|size
expr_stmt|;
return|return
name|new_frag
operator|->
name|memory
return|;
block|}
end_function
begin_function
DECL|function|ensure_abuf
specifier|static
name|void
modifier|*
name|ensure_abuf
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|size
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|ret
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|new_frag
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|<=
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|abuf
operator|->
name|used_size
operator|+
name|size
operator|<=
operator|(
name|ABUF_SIZE
operator|-
operator|(
name|sljit_uw
operator|)
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_memory_fragment
argument_list|,
name|memory
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|compiler
operator|->
name|abuf
operator|->
name|memory
operator|+
name|compiler
operator|->
name|abuf
operator|->
name|used_size
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|->
name|used_size
operator|+=
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
name|new_frag
operator|=
operator|(
expr|struct
name|sljit_memory_fragment
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|ABUF_SIZE
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|new_frag
argument_list|)
expr_stmt|;
name|new_frag
operator|->
name|next
operator|=
name|compiler
operator|->
name|abuf
expr_stmt|;
name|compiler
operator|->
name|abuf
operator|=
name|new_frag
expr_stmt|;
name|new_frag
operator|->
name|used_size
operator|=
name|size
expr_stmt|;
return|return
name|new_frag
operator|->
name|memory
return|;
block|}
end_function
begin_function
DECL|function|sljit_alloc_memory
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_alloc_memory
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_64BIT_ARCHITECTURE
operator|&&
name|SLJIT_64BIT_ARCHITECTURE
operator|)
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|128
condition|)
return|return
name|NULL
return|;
name|size
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|64
condition|)
return|return
name|NULL
return|;
name|size
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
endif|#
directive|endif
return|return
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|reverse_buf
specifier|static
name|SLJIT_INLINE
name|void
name|reverse_buf
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
init|=
name|compiler
operator|->
name|buf
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_memory_fragment
modifier|*
name|tmp
decl_stmt|;
do|do
block|{
name|tmp
operator|=
name|buf
operator|->
name|next
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|tmp
expr_stmt|;
block|}
do|while
condition|(
name|buf
operator|!=
name|NULL
condition|)
do|;
name|compiler
operator|->
name|buf
operator|=
name|prev
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_label
specifier|static
name|SLJIT_INLINE
name|void
name|set_label
parameter_list|(
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|,
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|label
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
condition|)
name|compiler
operator|->
name|last_label
operator|->
name|next
operator|=
name|label
expr_stmt|;
else|else
name|compiler
operator|->
name|labels
operator|=
name|label
expr_stmt|;
name|compiler
operator|->
name|last_label
operator|=
name|label
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_jump
specifier|static
name|SLJIT_INLINE
name|void
name|set_jump
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|)
block|{
name|jump
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|jump
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_jump
condition|)
name|compiler
operator|->
name|last_jump
operator|->
name|next
operator|=
name|jump
expr_stmt|;
else|else
name|compiler
operator|->
name|jumps
operator|=
name|jump
expr_stmt|;
name|compiler
operator|->
name|last_jump
operator|=
name|jump
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_const
specifier|static
name|SLJIT_INLINE
name|void
name|set_const
parameter_list|(
name|struct
name|sljit_const
modifier|*
name|const_
parameter_list|,
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|const_
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|const_
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_const
condition|)
name|compiler
operator|->
name|last_const
operator|->
name|next
operator|=
name|const_
expr_stmt|;
else|else
name|compiler
operator|->
name|consts
operator|=
name|const_
expr_stmt|;
name|compiler
operator|->
name|last_const
operator|=
name|const_
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|ADDRESSING_DEPENDS_ON
define|#
directive|define
name|ADDRESSING_DEPENDS_ON
parameter_list|(
name|exp
parameter_list|,
name|reg
parameter_list|)
define|\
value|(((exp)& SLJIT_MEM)&& (((exp)& 0xf) == reg || (((exp)>> 4)& 0xf) == reg))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
end_if
begin_define
DECL|macro|FUNCTION_CHECK_OP
define|#
directive|define
name|FUNCTION_CHECK_OP
parameter_list|()
define|\
value|SLJIT_ASSERT(!GET_FLAGS(op) || !(op& SLJIT_KEEP_FLAGS)); \ 	switch (GET_OPCODE(op)) { \ 	case SLJIT_NOT: \ 	case SLJIT_CLZ: \ 	case SLJIT_AND: \ 	case SLJIT_OR: \ 	case SLJIT_XOR: \ 	case SLJIT_SHL: \ 	case SLJIT_LSHR: \ 	case SLJIT_ASHR: \ 		SLJIT_ASSERT(!(op& (SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C))); \ 		break; \ 	case SLJIT_NEG: \ 		SLJIT_ASSERT(!(op& (SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_C))); \ 		break; \ 	case SLJIT_MUL: \ 		SLJIT_ASSERT(!(op& (SLJIT_SET_E | SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_C))); \ 		break; \ 	case SLJIT_CMPD: \ 		SLJIT_ASSERT(!(op& (SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))); \ 		SLJIT_ASSERT((op& (SLJIT_SET_E | SLJIT_SET_S))); \ 		break; \ 	case SLJIT_ADD: \ 		SLJIT_ASSERT(!(op& (SLJIT_SET_S | SLJIT_SET_U))); \ 		break; \ 	case SLJIT_SUB: \ 		break; \ 	case SLJIT_ADDC: \ 	case SLJIT_SUBC: \ 		SLJIT_ASSERT(!(op& (SLJIT_SET_E | SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_O))); \ 		break; \ 	case SLJIT_BREAKPOINT: \ 	case SLJIT_NOP: \ 	case SLJIT_UMUL: \ 	case SLJIT_SMUL: \ 	case SLJIT_MOV: \ 	case SLJIT_MOV_P: \ 	case SLJIT_MOVU: \ 	case SLJIT_MOVU_P: \
comment|/* Nothing allowed */
value|\ 		SLJIT_ASSERT(!(op& (SLJIT_INT_OP | SLJIT_SET_E | SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))); \ 		break; \ 	default: \
comment|/* Only SLJIT_INT_OP or SLJIT_SINGLE_OP is allowed. */
value|\ 		SLJIT_ASSERT(!(op& (SLJIT_SET_E | SLJIT_SET_S | SLJIT_SET_U | SLJIT_SET_O | SLJIT_SET_C | SLJIT_KEEP_FLAGS))); \ 		break; \ 	}
end_define
begin_define
DECL|macro|FUNCTION_CHECK_IS_REG
define|#
directive|define
name|FUNCTION_CHECK_IS_REG
parameter_list|(
name|r
parameter_list|)
define|\
value|((r) == SLJIT_UNUSED || \ 	((r)>= SLJIT_SCRATCH_REG1&& (r)<= SLJIT_SCRATCH_REG1 - 1 + compiler->scratches) || \ 	((r)>= SLJIT_SAVED_REG1&& (r)<= SLJIT_SAVED_REG1 - 1 + compiler->saveds))
end_define
begin_define
DECL|macro|FUNCTION_CHECK_SRC
define|#
directive|define
name|FUNCTION_CHECK_SRC
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|SLJIT_ASSERT(compiler->scratches != -1&& compiler->saveds != -1); \ 	if (FUNCTION_CHECK_IS_REG(p)) \ 		SLJIT_ASSERT((i) == 0&& (p) != SLJIT_UNUSED); \ 	else if ((p) == SLJIT_IMM) \ 		; \ 	else if ((p) == (SLJIT_MEM1(SLJIT_LOCALS_REG))) \ 		SLJIT_ASSERT((i)>= 0&& (i)< compiler->logical_local_size); \ 	else if ((p)& SLJIT_MEM) { \ 		SLJIT_ASSERT(FUNCTION_CHECK_IS_REG((p)& 0xf)); \ 		if ((p)& 0xf0) { \ 			SLJIT_ASSERT(FUNCTION_CHECK_IS_REG(((p)>> 4)& 0xf)); \ 			SLJIT_ASSERT(!((i)& ~0x3)); \ 		} \ 		SLJIT_ASSERT(((p)>> 9) == 0); \ 	} \ 	else \ 		SLJIT_ASSERT_STOP();
end_define
begin_define
DECL|macro|FUNCTION_CHECK_DST
define|#
directive|define
name|FUNCTION_CHECK_DST
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|SLJIT_ASSERT(compiler->scratches != -1&& compiler->saveds != -1); \ 	if (FUNCTION_CHECK_IS_REG(p)) \ 		SLJIT_ASSERT((i) == 0); \ 	else if ((p) == (SLJIT_MEM1(SLJIT_LOCALS_REG))) \ 		SLJIT_ASSERT((i)>= 0&& (i)< compiler->logical_local_size); \ 	else if ((p)& SLJIT_MEM) { \ 		SLJIT_ASSERT(FUNCTION_CHECK_IS_REG((p)& 0xf)); \ 		if ((p)& 0xf0) { \ 			SLJIT_ASSERT(FUNCTION_CHECK_IS_REG(((p)>> 4)& 0xf)); \ 			SLJIT_ASSERT(!((i)& ~0x3)); \ 		} \ 		SLJIT_ASSERT(((p)>> 9) == 0); \ 	} \ 	else \ 		SLJIT_ASSERT_STOP();
end_define
begin_define
DECL|macro|FUNCTION_FCHECK
define|#
directive|define
name|FUNCTION_FCHECK
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p)>= SLJIT_FLOAT_REG1&& (p)<= SLJIT_FLOAT_REG6) \ 		SLJIT_ASSERT(i == 0); \ 	else if ((p)& SLJIT_MEM) { \ 		SLJIT_ASSERT(FUNCTION_CHECK_IS_REG((p)& 0xf)); \ 		if ((p)& 0xf0) { \ 			SLJIT_ASSERT(FUNCTION_CHECK_IS_REG(((p)>> 4)& 0xf)); \ 			SLJIT_ASSERT(((p)& 0xf0) != (SLJIT_LOCALS_REG<< 4)&& !(i& ~0x3)); \ 		} else \ 			SLJIT_ASSERT((((p)>> 4)& 0xf) == 0); \ 		SLJIT_ASSERT(((p)>> 9) == 0); \ 	} \ 	else \ 		SLJIT_ASSERT_STOP();
end_define
begin_define
DECL|macro|FUNCTION_CHECK_OP1
define|#
directive|define
name|FUNCTION_CHECK_OP1
parameter_list|()
define|\
value|if (GET_OPCODE(op)>= SLJIT_MOVU&& GET_OPCODE(op)<= SLJIT_MOVU_P) { \ 		SLJIT_ASSERT(!(src& SLJIT_MEM) || (src& 0xf) != SLJIT_LOCALS_REG); \ 		SLJIT_ASSERT(!(dst& SLJIT_MEM) || (dst& 0xf) != SLJIT_LOCALS_REG); \ 		if ((src& SLJIT_MEM)&& (src& 0xf)) \ 			SLJIT_ASSERT((dst& 0xf) != (src& 0xf)&& ((dst>> 4)& 0xf) != (src& 0xf)); \ 	}
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_if
begin_function
DECL|function|sljit_compiler_verbose
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_compiler_verbose
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|FILE
modifier|*
name|verbose
parameter_list|)
block|{
name|compiler
operator|->
name|verbose
operator|=
name|verbose
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|reg_names
specifier|static
name|char
modifier|*
name|reg_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"<noreg>"
block|,
operator|(
name|char
operator|*
operator|)
literal|"t1"
block|,
operator|(
name|char
operator|*
operator|)
literal|"t2"
block|,
operator|(
name|char
operator|*
operator|)
literal|"t3"
block|,
operator|(
name|char
operator|*
operator|)
literal|"te1"
block|,
operator|(
name|char
operator|*
operator|)
literal|"te2"
block|,
operator|(
name|char
operator|*
operator|)
literal|"s1"
block|,
operator|(
name|char
operator|*
operator|)
literal|"s2"
block|,
operator|(
name|char
operator|*
operator|)
literal|"s3"
block|,
operator|(
name|char
operator|*
operator|)
literal|"se1"
block|,
operator|(
name|char
operator|*
operator|)
literal|"se2"
block|,
operator|(
name|char
operator|*
operator|)
literal|"lcr"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|freg_names
specifier|static
name|char
modifier|*
name|freg_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"<noreg>"
block|,
operator|(
name|char
operator|*
operator|)
literal|"float_r1"
block|,
operator|(
name|char
operator|*
operator|)
literal|"float_r2"
block|,
operator|(
name|char
operator|*
operator|)
literal|"float_r3"
block|,
operator|(
name|char
operator|*
operator|)
literal|"float_r4"
block|,
operator|(
name|char
operator|*
operator|)
literal|"float_r5"
block|,
operator|(
name|char
operator|*
operator|)
literal|"float_r6"
block|}
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN64
end_ifdef
begin_define
DECL|macro|SLJIT_PRINT_D
define|#
directive|define
name|SLJIT_PRINT_D
value|"I64"
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SLJIT_PRINT_D
define|#
directive|define
name|SLJIT_PRINT_D
value|"l"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SLJIT_PRINT_D
define|#
directive|define
name|SLJIT_PRINT_D
value|""
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|sljit_verbose_param
define|#
directive|define
name|sljit_verbose_param
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p)& SLJIT_IMM) \ 		fprintf(compiler->verbose, "#%" SLJIT_PRINT_D "d", (i)); \ 	else if ((p)& SLJIT_MEM) { \ 		if ((p)& 0xf) { \ 			if (i) { \ 				if (((p)>> 4)& 0xf) \ 					fprintf(compiler->verbose, "[%s + %s * %d]", reg_names[(p)& 0xF], reg_names[((p)>> 4)& 0xF], 1<< (i)); \ 				else \ 					fprintf(compiler->verbose, "[%s + #%" SLJIT_PRINT_D "d]", reg_names[(p)& 0xF], (i)); \ 			} \ 			else { \ 				if (((p)>> 4)& 0xf) \ 					fprintf(compiler->verbose, "[%s + %s]", reg_names[(p)& 0xF], reg_names[((p)>> 4)& 0xF]); \ 				else \ 					fprintf(compiler->verbose, "[%s]", reg_names[(p)& 0xF]); \ 			} \ 		} \ 		else \ 			fprintf(compiler->verbose, "[#%" SLJIT_PRINT_D "d]", (i)); \ 	} else \ 		fprintf(compiler->verbose, "%s", reg_names[p]);
end_define
begin_define
DECL|macro|sljit_verbose_fparam
define|#
directive|define
name|sljit_verbose_fparam
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|if ((p)& SLJIT_MEM) { \ 		if ((p)& 0xf) { \ 			if (i) { \ 				if (((p)>> 4)& 0xf) \ 					fprintf(compiler->verbose, "[%s + %s * %d]", reg_names[(p)& 0xF], reg_names[((p)>> 4)& 0xF], 1<< (i)); \ 				else \ 					fprintf(compiler->verbose, "[%s + #%" SLJIT_PRINT_D "d]", reg_names[(p)& 0xF], (i)); \ 			} \ 			else { \ 				if (((p)>> 4)& 0xF) \ 					fprintf(compiler->verbose, "[%s + %s]", reg_names[(p)& 0xF], reg_names[((p)>> 4)& 0xF]); \ 				else \ 					fprintf(compiler->verbose, "[%s]", reg_names[(p)& 0xF]); \ 			} \ 		} \ 		else \ 			fprintf(compiler->verbose, "[#%" SLJIT_PRINT_D "d]", (i)); \ 	} else \ 		fprintf(compiler->verbose, "%s", freg_names[p]);
end_define
begin_decl_stmt
DECL|variable|op_names
specifier|static
name|SLJIT_CONST
name|char
modifier|*
name|op_names
index|[]
init|=
block|{
comment|/* op0 */
operator|(
name|char
operator|*
operator|)
literal|"breakpoint"
block|,
operator|(
name|char
operator|*
operator|)
literal|"nop"
block|,
operator|(
name|char
operator|*
operator|)
literal|"umul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"smul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"udiv"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sdiv"
block|,
comment|/* op1 */
operator|(
name|char
operator|*
operator|)
literal|"mov"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov.ub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov.sb"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov.uh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov.sh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov.ui"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov.si"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov.p"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu.ub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu.sb"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu.uh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu.sh"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu.ui"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu.si"
block|,
operator|(
name|char
operator|*
operator|)
literal|"movu.p"
block|,
operator|(
name|char
operator|*
operator|)
literal|"not"
block|,
operator|(
name|char
operator|*
operator|)
literal|"neg"
block|,
operator|(
name|char
operator|*
operator|)
literal|"clz"
block|,
comment|/* op2 */
operator|(
name|char
operator|*
operator|)
literal|"add"
block|,
operator|(
name|char
operator|*
operator|)
literal|"addc"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"subc"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"and"
block|,
operator|(
name|char
operator|*
operator|)
literal|"or"
block|,
operator|(
name|char
operator|*
operator|)
literal|"xor"
block|,
operator|(
name|char
operator|*
operator|)
literal|"shl"
block|,
operator|(
name|char
operator|*
operator|)
literal|"lshr"
block|,
operator|(
name|char
operator|*
operator|)
literal|"ashr"
block|,
comment|/* fop1 */
operator|(
name|char
operator|*
operator|)
literal|"cmp"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mov"
block|,
operator|(
name|char
operator|*
operator|)
literal|"neg"
block|,
operator|(
name|char
operator|*
operator|)
literal|"abs"
block|,
comment|/* fop2 */
operator|(
name|char
operator|*
operator|)
literal|"add"
block|,
operator|(
name|char
operator|*
operator|)
literal|"sub"
block|,
operator|(
name|char
operator|*
operator|)
literal|"mul"
block|,
operator|(
name|char
operator|*
operator|)
literal|"div"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jump_names
specifier|static
name|char
modifier|*
name|jump_names
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"c_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_not_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_less"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_greater_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_greater"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_less_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_sig_less"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_sig_greater_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_sig_greater"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_sig_less_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_not_overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_mul_overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_mul_not_overflow"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_not_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_less"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_greater_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_greater"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_less_equal"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_unordered"
block|,
operator|(
name|char
operator|*
operator|)
literal|"c_float_ordered"
block|,
operator|(
name|char
operator|*
operator|)
literal|"jump"
block|,
operator|(
name|char
operator|*
operator|)
literal|"fast_call"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call0"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call1"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call2"
block|,
operator|(
name|char
operator|*
operator|)
literal|"call3"
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Arch dependent                                                       */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|check_sljit_generate_code
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|compiler
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
comment|/* All jumps have target. */
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
operator|(
name|JUMP_LABEL
operator||
name|JUMP_ADDR
operator|)
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_enter
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|scratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|args
operator|>=
literal|0
operator|&&
name|args
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|scratches
operator|>=
literal|0
operator|&&
name|scratches
operator|<=
name|SLJIT_NO_TMP_REGISTERS
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|saveds
operator|>=
literal|0
operator|&&
name|saveds
operator|<=
name|SLJIT_NO_GEN_REGISTERS
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|args
operator|<=
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|local_size
operator|>=
literal|0
operator|&&
name|local_size
operator|<=
name|SLJIT_MAX_LOCAL_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  enter args=%d scratches=%d saveds=%d local_size=%d\n"
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_set_context
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|scratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|args
operator|>=
literal|0
operator|&&
name|args
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|scratches
operator|>=
literal|0
operator|&&
name|scratches
operator|<=
name|SLJIT_NO_TMP_REGISTERS
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|saveds
operator|>=
literal|0
operator|&&
name|saveds
operator|<=
name|SLJIT_NO_GEN_REGISTERS
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|args
operator|<=
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|local_size
operator|>=
literal|0
operator|&&
name|local_size
operator|<=
name|SLJIT_MAX_LOCAL_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  set_context args=%d scratches=%d saveds=%d local_size=%d\n"
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_return
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|op
operator|!=
name|SLJIT_UNUSED
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOV_P
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
block|}
else|else
name|SLJIT_ASSERT
argument_list|(
name|src
operator|==
literal|0
operator|&&
name|srcw
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_UNUSED
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  return\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  return %s "
argument_list|,
name|op_names
index|[
name|op
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fast_enter
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  fast_enter "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fast_return
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  fast_return "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op0
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|op
operator|>=
name|SLJIT_BREAKPOINT
operator|&&
name|op
operator|<=
name|SLJIT_SMUL
operator|)
operator|||
operator|(
operator|(
name|op
operator|&
operator|~
name|SLJIT_INT_OP
operator|)
operator|>=
name|SLJIT_UDIV
operator|&&
operator|(
name|op
operator|&
operator|~
name|SLJIT_INT_OP
operator|)
operator|<=
name|SLJIT_SDIV
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s\n"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|op_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op1
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_MOV
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_CLZ
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_OP
argument_list|()
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_OP1
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s%s%s%s%s%s%s "
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|op_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|""
else|:
literal|".e"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_S
operator|)
condition|?
literal|""
else|:
literal|".s"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_U
operator|)
condition|?
literal|""
else|:
literal|".u"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_O
operator|)
condition|?
literal|""
else|:
literal|".o"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_C
operator|)
condition|?
literal|""
else|:
literal|".c"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|""
else|:
literal|".k"
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op2
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_ADD
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_ASHR
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_OP
argument_list|()
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s%s%s%s%s%s%s "
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|op_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|""
else|:
literal|".e"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_S
operator|)
condition|?
literal|""
else|:
literal|".s"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_U
operator|)
condition|?
literal|""
else|:
literal|".u"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_O
operator|)
condition|?
literal|""
else|:
literal|".o"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_C
operator|)
condition|?
literal|""
else|:
literal|".c"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|""
else|:
literal|".k"
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_get_register_index
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|reg
operator|>
literal|0
operator|&&
name|reg
operator|<=
name|SLJIT_NO_REGISTERS
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op_custom
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fop1
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_CMPD
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_ABSD
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_OP
argument_list|()
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s%s%s "
argument_list|,
name|op_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|""
else|:
literal|".e"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_S
operator|)
condition|?
literal|""
else|:
literal|".s"
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fop2
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_ADDD
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_DIVD
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_OP
argument_list|()
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %s%s "
argument_list|,
name|op_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_label
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"label:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_jump
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
literal|0xff
operator||
name|SLJIT_REWRITABLE_JUMP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|>=
name|SLJIT_C_EQUAL
operator|&&
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_CALL3
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  jump%s<%s>\n"
argument_list|,
operator|!
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|?
literal|""
else|:
literal|".r"
argument_list|,
name|jump_names
index|[
name|type
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_cmp
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
literal|0xff
operator||
name|SLJIT_REWRITABLE_JUMP
operator||
name|SLJIT_INT_OP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|>=
name|SLJIT_C_EQUAL
operator|&&
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_C_SIG_LESS_EQUAL
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_SRC
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_CHECK_SRC
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %scmp%s<%s> "
argument_list|,
operator|!
operator|(
name|type
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
operator|!
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|?
literal|""
else|:
literal|".r"
argument_list|,
name|jump_names
index|[
name|type
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_fcmp
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|sljit_is_fpu_available
argument_list|()
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|type
operator|&
operator|~
operator|(
literal|0xff
operator||
name|SLJIT_REWRITABLE_JUMP
operator||
name|SLJIT_SINGLE_OP
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|>=
name|SLJIT_C_FLOAT_EQUAL
operator|&&
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_C_FLOAT_ORDERED
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_FCHECK
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FUNCTION_FCHECK
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  %scmp%s<%s> "
argument_list|,
operator|(
name|type
operator|&
name|SLJIT_SINGLE_OP
operator|)
condition|?
literal|"s"
else|:
literal|"d"
argument_list|,
operator|!
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|?
literal|""
else|:
literal|".r"
argument_list|,
name|jump_names
index|[
name|type
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_fparam
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_ijump
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|skip_checks
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|skip_checks
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|type
operator|>=
name|SLJIT_JUMP
operator|&&
name|type
operator|<=
name|SLJIT_CALL3
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_SRC
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  ijump<%s> "
argument_list|,
name|jump_names
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_op_flags
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|type
operator|>=
name|SLJIT_C_EQUAL
operator|&&
name|type
operator|<
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MOV_UI
operator|||
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MOV_SI
operator|||
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_AND
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_XOR
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_S
operator||
name|SLJIT_SET_U
operator||
name|SLJIT_SET_O
operator||
name|SLJIT_SET_C
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_KEEP_FLAGS
operator|)
operator|)
operator|!=
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_KEEP_FLAGS
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<
name|SLJIT_ADD
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|src
operator|==
name|SLJIT_UNUSED
operator|&&
name|srcw
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|src
operator|==
name|dst
operator|&&
name|srcw
operator|==
name|dstw
argument_list|)
expr_stmt|;
block|}
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  op_flags<%s%s%s%s> "
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|""
else|:
literal|"i"
argument_list|,
name|op_names
index|[
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_E
operator|)
condition|?
literal|""
else|:
literal|".e"
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|""
else|:
literal|".k"
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|SLJIT_UNUSED
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|",<%s>\n"
argument_list|,
name|jump_names
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_get_local_base
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  local_base "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", #%"
name|SLJIT_PRINT_D
literal|"d\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|check_sljit_emit_const
specifier|static
name|SLJIT_INLINE
name|void
name|check_sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
comment|/* If debug and verbose are disabled, all arguments are unused. */
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|init_value
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|FUNCTION_CHECK_DST
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
operator|!
name|compiler
operator|->
name|verbose
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|"  const "
argument_list|)
expr_stmt|;
name|sljit_verbose_param
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|compiler
operator|->
name|verbose
argument_list|,
literal|", #%"
name|SLJIT_PRINT_D
literal|"d\n"
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|emit_mov_before_return
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_mov_before_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
comment|/* Return if don't need to do anything. */
if|if
condition|(
name|op
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_64BIT_ARCHITECTURE
operator|&&
name|SLJIT_64BIT_ARCHITECTURE
operator|)
comment|/* At the moment the pointer size is always equal to sljit_sw. May be changed in the future. */
if|if
condition|(
name|src
operator|==
name|SLJIT_RETURN_REG
operator|&&
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|op
operator|==
name|SLJIT_MOV_P
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
else|#
directive|else
if|if
condition|(
name|src
operator|==
name|SLJIT_RETURN_REG
operator|&&
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|op
operator|==
name|SLJIT_MOV_UI
operator|||
name|op
operator|==
name|SLJIT_MOV_SI
operator|||
name|op
operator|==
name|SLJIT_MOV_P
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* CPU description section */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_32BIT_ARCHITECTURE
operator|&&
name|SLJIT_32BIT_ARCHITECTURE
operator|)
end_if
begin_define
DECL|macro|SLJIT_CPUINFO_PART1
define|#
directive|define
name|SLJIT_CPUINFO_PART1
value|" 32bit ("
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_64BIT_ARCHITECTURE
operator|&&
name|SLJIT_64BIT_ARCHITECTURE
operator|)
end_elif
begin_define
DECL|macro|SLJIT_CPUINFO_PART1
define|#
directive|define
name|SLJIT_CPUINFO_PART1
value|" 64bit ("
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"Internal error: CPU type info missing"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_LITTLE_ENDIAN
operator|&&
name|SLJIT_LITTLE_ENDIAN
operator|)
end_if
begin_define
DECL|macro|SLJIT_CPUINFO_PART2
define|#
directive|define
name|SLJIT_CPUINFO_PART2
value|"little endian + "
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_BIG_ENDIAN
operator|&&
name|SLJIT_BIG_ENDIAN
operator|)
end_elif
begin_define
DECL|macro|SLJIT_CPUINFO_PART2
define|#
directive|define
name|SLJIT_CPUINFO_PART2
value|"big endian + "
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"Internal error: CPU type info missing"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
operator|)
end_if
begin_define
DECL|macro|SLJIT_CPUINFO_PART3
define|#
directive|define
name|SLJIT_CPUINFO_PART3
value|"unaligned)"
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SLJIT_CPUINFO_PART3
define|#
directive|define
name|SLJIT_CPUINFO_PART3
value|"aligned)"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|SLJIT_CPUINFO
define|#
directive|define
name|SLJIT_CPUINFO
value|SLJIT_CPUINFO_PART1 SLJIT_CPUINFO_PART2 SLJIT_CPUINFO_PART3
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitNativeX86_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeX86_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeARM_v5.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeARM_v5.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeARM_Thumb2.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativePPC_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativePPC_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeMIPS_common.c"
end_include
begin_elif
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
end_elif
begin_include
include|#
directive|include
file|"sljitNativeSPARC_common.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_function
DECL|function|sljit_emit_cmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* Default compare for most architectures. */
name|sljit_si
name|flags
decl_stmt|,
name|tmp_src
decl_stmt|,
name|condition
decl_stmt|;
name|sljit_sw
name|tmp_srcw
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_cmp
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|condition
operator|=
name|type
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
argument_list|)
condition|)
block|{
comment|/* Immediate is prefered as second argument by most architectures. */
switch|switch
condition|(
name|condition
condition|)
block|{
case|case
name|SLJIT_C_LESS
case|:
name|condition
operator|=
name|SLJIT_C_GREATER
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
name|condition
operator|=
name|SLJIT_C_LESS_EQUAL
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER
case|:
name|condition
operator|=
name|SLJIT_C_LESS
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
name|condition
operator|=
name|SLJIT_C_GREATER_EQUAL
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS
case|:
name|condition
operator|=
name|SLJIT_C_SIG_GREATER
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|condition
operator|=
name|SLJIT_C_SIG_LESS_EQUAL
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
name|condition
operator|=
name|SLJIT_C_SIG_LESS
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|condition
operator|=
name|SLJIT_C_SIG_GREATER_EQUAL
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|condition
operator||
operator|(
name|type
operator|&
operator|(
name|SLJIT_INT_OP
operator||
name|SLJIT_REWRITABLE_JUMP
operator|)
operator|)
expr_stmt|;
name|tmp_src
operator|=
name|src1
expr_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src2
operator|=
name|tmp_src
expr_stmt|;
name|tmp_srcw
operator|=
name|src1w
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
name|src2w
operator|=
name|tmp_srcw
expr_stmt|;
block|}
if|if
condition|(
name|condition
operator|<=
name|SLJIT_C_NOT_ZERO
condition|)
name|flags
operator|=
name|SLJIT_SET_E
expr_stmt|;
elseif|else
if|if
condition|(
name|condition
operator|<=
name|SLJIT_C_LESS_EQUAL
condition|)
name|flags
operator|=
name|SLJIT_SET_U
expr_stmt|;
else|else
name|flags
operator|=
name|SLJIT_SET_S
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|PTR_FAIL_IF
argument_list|(
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
operator||
name|flags
operator||
operator|(
name|type
operator|&
name|SLJIT_INT_OP
operator|)
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|condition
operator||
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fcmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|flags
decl_stmt|,
name|condition
decl_stmt|;
name|check_sljit_emit_fcmp
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|condition
operator|=
name|type
operator|&
literal|0xff
expr_stmt|;
name|flags
operator|=
operator|(
name|condition
operator|<=
name|SLJIT_C_FLOAT_NOT_EQUAL
operator|)
condition|?
name|SLJIT_SET_E
else|:
name|SLJIT_SET_S
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|SLJIT_SINGLE_OP
condition|)
name|flags
operator||=
name|SLJIT_SINGLE_OP
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CMPD
operator||
name|flags
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|condition
operator||
operator|(
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|&&
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_function
DECL|function|sljit_get_local_base
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_get_local_base
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
operator||
name|SLJIT_KEEP_FLAGS
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|offset
argument_list|)
return|;
return|return
name|sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SLJIT_CONFIG_UNSUPPORTED */
end_comment
begin_comment
comment|/* Empty function bodies for those machines, which are not (yet) supported. */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"unsupported"
return|;
block|}
end_function
begin_function
DECL|function|sljit_create_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_compiler
modifier|*
name|sljit_create_compiler
parameter_list|(
name|void
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_free_compiler
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_compiler
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_alloc_memory
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_alloc_memory
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_if
begin_function
DECL|function|sljit_compiler_verbose
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_compiler_verbose
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|FILE
modifier|*
name|verbose
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_free_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|scratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|scratches
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|saveds
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_cmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fcmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_label
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_target
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_target
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uw
name|target
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_local_base
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|initval
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|dstw
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|initval
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|new_addr
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|new_constant
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
end_unit
