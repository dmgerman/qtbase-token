begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|()
block|{
return|return
literal|"x86"
name|SLJIT_CPUINFO
return|;
block|}
end_function
begin_comment
comment|/*    32b register indexes:      0 - EAX      1 - ECX      2 - EDX      3 - EBX      4 - none      5 - EBP      6 - ESI      7 - EDI */
end_comment
begin_comment
comment|/*    64b register indexes:      0 - RAX      1 - RCX      2 - RDX      3 - RBX      4 - none      5 - RBP      6 - RSI      7 - RDI      8 - R8   - From now on REX prefix is required      9 - R9     10 - R10     11 - R11     12 - R12     13 - R13     14 - R14     15 - R15 */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
end_if
begin_comment
comment|/* Last register + 1. */
end_comment
begin_define
DECL|macro|TMP_REGISTER
define|#
directive|define
name|TMP_REGISTER
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|CHECK_EXTRA_REGS
define|#
directive|define
name|CHECK_EXTRA_REGS
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|,
define|do) \ 	if (p>= SLJIT_TEMPORARY_EREG1&& p<= SLJIT_TEMPORARY_EREG2) { \ 		w = compiler->temporaries_start + (p - SLJIT_TEMPORARY_EREG1) * sizeof(sljit_w); \ 		p = SLJIT_MEM1(SLJIT_LOCALS_REG); \ 		do; \ 	} \ 	else if (p>= SLJIT_SAVED_EREG1&& p<= SLJIT_SAVED_EREG2) { \ 		w = compiler->saveds_start + (p - SLJIT_SAVED_EREG1) * sizeof(sljit_w); \ 		p = SLJIT_MEM1(SLJIT_LOCALS_REG); \ 		do; \ 	}
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SLJIT_CONFIG_X86_32 */
end_comment
begin_comment
comment|/* Last register + 1. */
end_comment
begin_define
DECL|macro|TMP_REGISTER
define|#
directive|define
name|TMP_REGISTER
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NO_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NO_REGISTERS + 3)
end_define
begin_comment
comment|/* Note: r12& 0x7 == 0b100, which decoded as SIB byte present    Note: avoid to use r12 and r13 for memory addessing    therefore r12 is better for SAVED_EREG than SAVED_REG. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_WIN64
end_ifndef
begin_comment
comment|/* 1st passed in rdi, 2nd argument passed in rsi, 3rd in rdx. */
end_comment
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|1
block|,
literal|8
block|,
literal|11
block|,
literal|3
block|,
literal|15
block|,
literal|14
block|,
literal|13
block|,
literal|12
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* low-map. reg_map& 0x7. */
end_comment
begin_decl_stmt
DECL|variable|reg_lmap
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_lmap
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* 1st passed in rcx, 2nd argument passed in rdx, 3rd in r8. */
end_comment
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|11
block|,
literal|13
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|14
block|,
literal|12
block|,
literal|15
block|,
literal|10
block|,
literal|8
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* low-map. reg_map& 0x7. */
end_comment
begin_decl_stmt
DECL|variable|reg_lmap
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_lmap
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|6
block|,
literal|4
block|,
literal|7
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|REX_W
define|#
directive|define
name|REX_W
value|0x48
end_define
begin_define
DECL|macro|REX_R
define|#
directive|define
name|REX_R
value|0x44
end_define
begin_define
DECL|macro|REX_X
define|#
directive|define
name|REX_X
value|0x42
end_define
begin_define
DECL|macro|REX_B
define|#
directive|define
name|REX_B
value|0x41
end_define
begin_define
DECL|macro|REX
define|#
directive|define
name|REX
value|0x40
end_define
begin_typedef
DECL|typedef|sljit_uhw
typedef|typedef
name|unsigned
name|int
name|sljit_uhw
typedef|;
end_typedef
begin_typedef
DECL|typedef|sljit_hw
typedef|typedef
name|int
name|sljit_hw
typedef|;
end_typedef
begin_define
DECL|macro|IS_HALFWORD
define|#
directive|define
name|IS_HALFWORD
parameter_list|(
name|x
parameter_list|)
value|((x)<= 0x7fffffffll&& (x)>= -0x80000000ll)
end_define
begin_define
DECL|macro|NOT_HALFWORD
define|#
directive|define
name|NOT_HALFWORD
parameter_list|(
name|x
parameter_list|)
value|((x)> 0x7fffffffll || (x)< -0x80000000ll)
end_define
begin_define
DECL|macro|CHECK_EXTRA_REGS
define|#
directive|define
name|CHECK_EXTRA_REGS
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|,
define|do)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SLJIT_CONFIG_X86_32 */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
end_if
begin_define
DECL|macro|TMP_FREG
define|#
directive|define
name|TMP_FREG
value|(SLJIT_FLOAT_REG4 + 1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Size flags for emit_x86_instruction: */
end_comment
begin_define
DECL|macro|EX86_BIN_INS
define|#
directive|define
name|EX86_BIN_INS
value|0x0010
end_define
begin_define
DECL|macro|EX86_SHIFT_INS
define|#
directive|define
name|EX86_SHIFT_INS
value|0x0020
end_define
begin_define
DECL|macro|EX86_REX
define|#
directive|define
name|EX86_REX
value|0x0040
end_define
begin_define
DECL|macro|EX86_NO_REXW
define|#
directive|define
name|EX86_NO_REXW
value|0x0080
end_define
begin_define
DECL|macro|EX86_BYTE_ARG
define|#
directive|define
name|EX86_BYTE_ARG
value|0x0100
end_define
begin_define
DECL|macro|EX86_HALF_ARG
define|#
directive|define
name|EX86_HALF_ARG
value|0x0200
end_define
begin_define
DECL|macro|EX86_PREF_66
define|#
directive|define
name|EX86_PREF_66
value|0x0400
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
end_if
begin_define
DECL|macro|EX86_PREF_F2
define|#
directive|define
name|EX86_PREF_F2
value|0x0800
end_define
begin_define
DECL|macro|EX86_SSE2
define|#
directive|define
name|EX86_SSE2
value|0x1000
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|INC_SIZE
define|#
directive|define
name|INC_SIZE
parameter_list|(
name|s
parameter_list|)
value|(*buf++ = (s), compiler->size += (s))
end_define
begin_define
DECL|macro|INC_CSIZE
define|#
directive|define
name|INC_CSIZE
parameter_list|(
name|s
parameter_list|)
value|(*code++ = (s), compiler->size += (s))
end_define
begin_define
DECL|macro|PUSH_REG
define|#
directive|define
name|PUSH_REG
parameter_list|(
name|r
parameter_list|)
value|(*buf++ = (0x50 + (r)))
end_define
begin_define
DECL|macro|POP_REG
define|#
directive|define
name|POP_REG
parameter_list|(
name|r
parameter_list|)
value|(*buf++ = (0x58 + (r)))
end_define
begin_define
DECL|macro|RET
define|#
directive|define
name|RET
parameter_list|()
value|(*buf++ = (0xc3))
end_define
begin_define
DECL|macro|RETN
define|#
directive|define
name|RETN
parameter_list|(
name|n
parameter_list|)
value|(*buf++ = (0xc2), *buf++ = n, *buf++ = 0)
end_define
begin_comment
comment|/* r32, r/m32 */
end_comment
begin_define
DECL|macro|MOV_RM
define|#
directive|define
name|MOV_RM
parameter_list|(
name|mod
parameter_list|,
name|reg
parameter_list|,
name|rm
parameter_list|)
value|(*buf++ = (0x8b), *buf++ = (mod)<< 6 | (reg)<< 3 | (rm))
end_define
begin_function
DECL|function|get_jump_code
specifier|static
name|sljit_ub
name|get_jump_code
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
return|return
literal|0x84
return|;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
return|return
literal|0x85
return|;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
return|return
literal|0x82
return|;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
return|return
literal|0x83
return|;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
return|return
literal|0x87
return|;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
return|return
literal|0x86
return|;
case|case
name|SLJIT_C_SIG_LESS
case|:
return|return
literal|0x8c
return|;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
return|return
literal|0x8d
return|;
case|case
name|SLJIT_C_SIG_GREATER
case|:
return|return
literal|0x8f
return|;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
return|return
literal|0x8e
return|;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
return|return
literal|0x80
return|;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
return|return
literal|0x81
return|;
case|case
name|SLJIT_C_FLOAT_NAN
case|:
return|return
literal|0x8a
return|;
case|case
name|SLJIT_C_FLOAT_NOT_NAN
case|:
return|return
literal|0x8b
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function_decl
specifier|static
name|sljit_ub
modifier|*
name|generate_far_jump_code
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_function_decl
specifier|static
name|sljit_ub
modifier|*
name|generate_fixed_jump
parameter_list|(
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_w
name|addr
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|generate_near_jump_code
specifier|static
name|sljit_ub
modifier|*
name|generate_near_jump_code
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_ub
modifier|*
name|code
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|short_jump
decl_stmt|;
name|sljit_uw
name|label_addr
decl_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
condition|)
name|label_addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
expr_stmt|;
else|else
name|label_addr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
name|short_jump
operator|=
call|(
name|sljit_w
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|2
operator|)
argument_list|)
operator|>=
operator|-
literal|128
operator|&&
call|(
name|sljit_w
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|2
operator|)
argument_list|)
operator|<=
literal|127
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
call|(
name|sljit_w
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|1
operator|)
argument_list|)
operator|>
literal|0x7fffffffll
operator|||
call|(
name|sljit_w
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|1
operator|)
argument_list|)
operator|<
operator|-
literal|0x80000000ll
condition|)
return|return
name|generate_far_jump_code
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|type
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|SLJIT_JUMP
condition|)
block|{
if|if
condition|(
name|short_jump
condition|)
operator|*
name|code_ptr
operator|++
operator|=
literal|0xeb
expr_stmt|;
else|else
operator|*
name|code_ptr
operator|++
operator|=
literal|0xe9
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
block|{
name|short_jump
operator|=
literal|0
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
literal|0xe8
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|short_jump
condition|)
block|{
operator|*
name|code_ptr
operator|++
operator|=
name|get_jump_code
argument_list|(
name|type
argument_list|)
operator|-
literal|0x10
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|code_ptr
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|get_jump_code
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|short_jump
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_MB
expr_stmt|;
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_MW
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
else|#
directive|else
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_hw
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|code_ptr
return|;
block|}
end_function
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|sljit_ub
modifier|*
name|code_ptr
decl_stmt|;
name|sljit_ub
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_ub
modifier|*
name|buf_end
decl_stmt|;
name|sljit_ub
name|len
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
comment|/* Second code generation pass. */
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|code_ptr
operator|=
name|code
expr_stmt|;
name|label
operator|=
name|compiler
operator|->
name|labels
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
do|do
block|{
name|buf_ptr
operator|=
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
name|buf
operator|->
name|used_size
expr_stmt|;
do|do
block|{
name|len
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* The code is already generated. */
name|SLJIT_MEMMOVE
argument_list|(
name|code_ptr
argument_list|,
name|buf_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|code_ptr
operator|+=
name|len
expr_stmt|;
name|buf_ptr
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|buf_ptr
operator|>=
literal|4
condition|)
block|{
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|)
name|code_ptr
operator|=
name|generate_near_jump_code
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|,
operator|*
name|buf_ptr
operator|-
literal|4
argument_list|)
expr_stmt|;
else|else
name|code_ptr
operator|=
name|generate_far_jump_code
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
operator|*
name|buf_ptr
operator|-
literal|4
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|0
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|1
condition|)
block|{
name|const_
operator|->
name|addr
operator|=
operator|(
operator|(
name|sljit_uw
operator|)
name|code_ptr
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
name|code_ptr
operator|++
operator|=
operator|(
operator|*
name|buf_ptr
operator|==
literal|2
operator|)
condition|?
literal|0xe8
comment|/* call */
else|:
literal|0xe9
comment|/* jmp */
expr_stmt|;
name|buf_ptr
operator|++
expr_stmt|;
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|code_ptr
operator|=
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|buf_ptr
operator|-
operator|(
operator|(
name|sljit_w
operator|)
name|code_ptr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
operator|)
expr_stmt|;
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|code_ptr
operator|=
name|generate_fixed_jump
argument_list|(
name|code_ptr
argument_list|,
operator|*
operator|(
name|sljit_w
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
literal|1
operator|)
argument_list|,
operator|*
name|buf_ptr
argument_list|)
expr_stmt|;
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|buf_ptr
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
name|buf_ptr
operator|==
name|buf_end
argument_list|)
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|buf
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_MB
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_b
argument_list|)
operator|)
argument_list|)
operator|>=
operator|-
literal|128
operator|&&
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_b
argument_list|)
operator|)
argument_list|)
operator|<=
literal|127
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_ub
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_ub
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_b
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_MW
condition|)
block|{
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_ASSERT
argument_list|(
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_hw
argument_list|)
operator|)
argument_list|)
operator|>=
operator|-
literal|0x80000000ll
operator|&&
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_hw
argument_list|)
operator|)
argument_list|)
operator|<=
literal|0x7fffffffll
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_hw
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_hw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_hw
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_ASSERT
argument_list|(
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_hw
argument_list|)
operator|)
argument_list|)
operator|>=
operator|-
literal|0x80000000ll
operator|&&
call|(
name|sljit_w
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_hw
argument_list|)
operator|)
argument_list|)
operator|<=
literal|0x7fffffffll
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_hw
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_hw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_hw
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
elseif|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_MD
condition|)
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
expr_stmt|;
endif|#
directive|endif
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
comment|/* Maybe we waste some space because of short jumps. */
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|<=
name|code
operator|+
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
name|compiler
operator|->
name|executable_size
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|code
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function_decl
specifier|static
name|int
name|emit_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|emit_non_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|emit_mov
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|emit_save_flags
specifier|static
name|SLJIT_INLINE
name|int
name|emit_save_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x9c
expr_stmt|;
comment|/* pushfd */
else|#
directive|else
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|6
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|6
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x9c
expr_stmt|;
comment|/* pushfq */
operator|*
name|buf
operator|++
operator|=
literal|0x48
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
literal|0x8d
expr_stmt|;
comment|/* lea esp/rsp, [esp/rsp + sizeof(sljit_w)] */
operator|*
name|buf
operator|++
operator|=
literal|0x64
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|1
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_restore_flags
specifier|static
name|SLJIT_INLINE
name|int
name|emit_restore_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|keep_flags
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
else|#
directive|else
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|6
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|6
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x48
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
literal|0x8d
expr_stmt|;
comment|/* lea esp/rsp, [esp/rsp - sizeof(sljit_w)] */
operator|*
name|buf
operator|++
operator|=
literal|0x64
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|sljit_ub
operator|)
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x9d
expr_stmt|;
comment|/* popfd / popfq */
name|compiler
operator|->
name|flags_saved
operator|=
name|keep_flags
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef
begin_include
include|#
directive|include
file|<malloc.h>
end_include
begin_function
DECL|function|sljit_touch_stack
specifier|static
name|void
name|SLJIT_CALL
name|sljit_touch_stack
parameter_list|(
name|sljit_w
name|local_size
parameter_list|)
block|{
comment|/* Workaround for calling _chkstk. */
name|alloca
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitNativeX86_32.c"
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"sljitNativeX86_64.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|emit_mov
specifier|static
name|int
name|emit_mov
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
comment|/* No destination, doesn't need to setup flags. */
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8b
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x89
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
return|return
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
literal|0xb8
operator|+
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
condition|)
block|{
if|if
condition|(
name|NOT_HALFWORD
argument_list|(
name|srcw
argument_list|)
condition|)
return|return
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|srcw
argument_list|)
return|;
block|}
else|else
return|return
name|emit_do_imm32
argument_list|(
name|compiler
argument_list|,
operator|(
name|reg_map
index|[
name|dst
index|]
operator|>=
literal|8
operator|)
condition|?
name|REX_B
else|:
literal|0
argument_list|,
literal|0xb8
operator|+
name|reg_lmap
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
operator|&&
name|NOT_HALFWORD
argument_list|(
name|srcw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x89
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
endif|#
directive|endif
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xc7
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8b
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* Memory to memory move. Requires two instruction. */
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8b
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x89
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|EMIT_MOV
define|#
directive|define
name|EMIT_MOV
parameter_list|(
name|compiler
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|FAIL_IF(emit_mov(compiler, dst, dstw, src, srcw));
end_define
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|int
name|size
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_BREAKPOINT
case|:
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xcc
expr_stmt|;
break|break;
case|case
name|SLJIT_NOP
case|:
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0x90
expr_stmt|;
break|break;
case|case
name|SLJIT_UMUL
case|:
case|case
name|SLJIT_SMUL
case|:
case|case
name|SLJIT_UDIV
case|:
case|case
name|SLJIT_SDIV
case|:
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
ifdef|#
directive|ifdef
name|_WIN64
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_TEMPORARY_REG1
index|]
operator|==
literal|0
operator|&&
name|reg_map
index|[
name|SLJIT_TEMPORARY_REG2
index|]
operator|==
literal|2
operator|&&
name|reg_map
index|[
name|TMP_REGISTER
index|]
operator|>
literal|7
argument_list|,
name|invalid_register_assignment_for_div_mul
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_TEMPORARY_REG1
index|]
operator|==
literal|0
operator|&&
name|reg_map
index|[
name|SLJIT_TEMPORARY_REG2
index|]
operator|<
literal|7
operator|&&
name|reg_map
index|[
name|TMP_REGISTER
index|]
operator|==
literal|2
argument_list|,
name|invalid_register_assignment_for_div_mul
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|mode32
operator|=
name|op
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_UDIV
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|||
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|buf
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0x33
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|SLJIT_SDIV
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|||
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CDQ instruction */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0x99
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|compiler
operator|->
name|mode32
condition|)
block|{
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0x99
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|buf
operator|=
literal|0x99
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xc0
operator||
operator|(
operator|(
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
name|reg_map
index|[
name|TMP_REGISTER
index|]
else|:
name|reg_map
index|[
name|SLJIT_TEMPORARY_REG2
index|]
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_WIN64
name|size
operator|=
operator|(
operator|!
name|compiler
operator|->
name|mode32
operator|||
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
else|#
directive|else
name|size
operator|=
operator|(
operator|!
name|compiler
operator|->
name|mode32
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
endif|#
directive|endif
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
condition|)
operator|*
name|buf
operator|++
operator|=
name|REX_W
operator||
operator|(
operator|(
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
name|REX_B
else|:
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|>=
name|SLJIT_UDIV
condition|)
operator|*
name|buf
operator|++
operator|=
name|REX_B
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xc0
operator||
operator|(
operator|(
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
name|reg_lmap
index|[
name|TMP_REGISTER
index|]
else|:
name|reg_lmap
index|[
name|SLJIT_TEMPORARY_REG2
index|]
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
condition|)
operator|*
name|buf
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xc0
operator||
name|reg_map
index|[
name|SLJIT_TEMPORARY_REG2
index|]
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_UMUL
case|:
operator|*
name|buf
operator||=
literal|4
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|SLJIT_SMUL
case|:
operator|*
name|buf
operator||=
literal|5
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|SLJIT_UDIV
case|:
operator|*
name|buf
operator||=
literal|6
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|SLJIT_SDIV
case|:
operator|*
name|buf
operator||=
literal|7
operator|<<
literal|3
expr_stmt|;
break|break;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|ENCODE_PREFIX
define|#
directive|define
name|ENCODE_PREFIX
parameter_list|(
name|prefix
parameter_list|)
define|\
value|do { \ 		code = (sljit_ub*)ensure_buf(compiler, 1 + 1); \ 		FAIL_IF(!code); \ 		INC_CSIZE(1); \ 		*code = (prefix); \ 	} while (0)
end_define
begin_function
DECL|function|emit_mov_byte
specifier|static
name|int
name|emit_mov_byte
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|sign
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|int
name|dst_r
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|int
name|work_r
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
operator|&&
operator|!
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* Empty instruction. */
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
return|return
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
literal|0xb8
operator|+
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|srcw
argument_list|)
return|;
endif|#
directive|endif
block|}
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BYTE_ARG
operator||
name|EX86_NO_REXW
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xc6
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|dst_r
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
name|src
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|reg_map
index|[
name|src
index|]
operator|>=
literal|4
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|dst_r
operator|==
name|TMP_REGISTER
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_r
operator|=
name|src
expr_stmt|;
else|#
directive|else
name|dst_r
operator|=
name|src
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
elseif|else
if|if
condition|(
name|src
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src
operator|<=
name|SLJIT_NO_REGISTERS
operator|&&
name|reg_map
index|[
name|src
index|]
operator|>=
literal|4
condition|)
block|{
comment|/* src, dst are registers. */
name|SLJIT_ASSERT
argument_list|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
index|[
name|dst
index|]
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|dst
operator|!=
name|src
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
name|sign
condition|?
literal|0xbe
else|:
literal|0xb6
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dst
operator|!=
name|src
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
block|{
comment|/* shl reg, 24 */
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|24
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
literal|0x4
operator|<<
literal|3
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|24
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
comment|/* shr/sar reg, 24 */
operator|*
name|code
operator||=
literal|0x7
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* and dst, 0xff */
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BIN_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
operator|(
name|code
operator|+
literal|1
operator|)
operator||=
literal|0x4
operator|<<
literal|3
expr_stmt|;
block|}
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
endif|#
directive|endif
else|else
block|{
comment|/* src can be memory addr or reg_map[src]< 4 on x86_32 architectures. */
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
name|sign
condition|?
literal|0xbe
else|:
literal|0xb6
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|dst_r
operator|==
name|TMP_REGISTER
condition|)
block|{
comment|/* Find a non-used register, whose reg_map[src]< 4. */
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_TEMPORARY_REG1
condition|)
block|{
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|==
operator|(
name|SLJIT_TEMPORARY_REG2
operator|<<
literal|4
operator|)
condition|)
name|work_r
operator|=
name|SLJIT_TEMPORARY_REG3
expr_stmt|;
else|else
name|work_r
operator|=
name|SLJIT_TEMPORARY_REG2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
operator|(
name|SLJIT_TEMPORARY_REG1
operator|<<
literal|4
operator|)
condition|)
name|work_r
operator|=
name|SLJIT_TEMPORARY_REG1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_TEMPORARY_REG2
condition|)
name|work_r
operator|=
name|SLJIT_TEMPORARY_REG3
expr_stmt|;
else|else
name|work_r
operator|=
name|SLJIT_TEMPORARY_REG2
expr_stmt|;
block|}
if|if
condition|(
name|work_r
operator|==
name|SLJIT_TEMPORARY_REG1
condition|)
block|{
name|ENCODE_PREFIX
argument_list|(
literal|0x90
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|work_r
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x87
expr_stmt|;
block|}
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|work_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x88
expr_stmt|;
if|if
condition|(
name|work_r
operator|==
name|SLJIT_TEMPORARY_REG1
condition|)
block|{
name|ENCODE_PREFIX
argument_list|(
literal|0x90
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|work_r
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x87
expr_stmt|;
block|}
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x88
expr_stmt|;
block|}
else|#
directive|else
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_REX
operator||
name|EX86_NO_REXW
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x88
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_mov_half
specifier|static
name|int
name|emit_mov_half
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|sign
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|int
name|dst_r
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
operator|&&
operator|!
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* Empty instruction. */
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
return|return
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
literal|0xb8
operator|+
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|srcw
argument_list|)
return|;
endif|#
directive|endif
block|}
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_HALF_ARG
operator||
name|EX86_NO_REXW
operator||
name|EX86_PREF_66
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xc7
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|dst_r
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|src
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src
operator|<=
name|SLJIT_NO_REGISTERS
operator|)
condition|)
name|dst_r
operator|=
name|src
expr_stmt|;
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
name|sign
condition|?
literal|0xbf
else|:
literal|0xb7
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_NO_REXW
operator||
name|EX86_PREF_66
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x89
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_unary
specifier|static
name|int
name|emit_unary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|un_index
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
operator|(
name|un_index
operator|)
operator|<<
literal|3
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|src
operator|&&
name|dstw
operator|==
name|srcw
condition|)
block|{
comment|/* Same input and output */
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
operator|(
name|un_index
operator|)
operator|<<
literal|3
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
operator|(
name|un_index
operator|)
operator|<<
literal|3
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
operator|(
name|un_index
operator|)
operator|<<
literal|3
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_not_with_flags
specifier|static
name|int
name|emit_not_with_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
literal|0x2
operator|<<
literal|3
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x0b
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
literal|0x2
operator|<<
literal|3
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x0b
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
literal|0x2
operator|<<
literal|3
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x0b
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_clz
specifier|static
name|int
name|emit_clz
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|int
name|dst_r
decl_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst
operator|==
name|SLJIT_UNUSED
argument_list|)
condition|)
block|{
comment|/* Just set the zero flag. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xf7
expr_stmt|;
operator|*
name|code
operator||=
literal|0x2
operator|<<
literal|3
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|31
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|63
else|:
literal|31
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
literal|0x5
operator|<<
literal|3
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|src
operator|&
name|SLJIT_IMM
argument_list|)
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
literal|0xbd
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
condition|)
name|dst_r
operator|=
name|dst
expr_stmt|;
else|else
block|{
comment|/* Find an unused temporary register. */
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|!=
name|SLJIT_TEMPORARY_REG1
operator|&&
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
operator|(
name|SLJIT_TEMPORARY_REG1
operator|<<
literal|4
operator|)
condition|)
name|dst_r
operator|=
name|SLJIT_TEMPORARY_REG1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|!=
name|SLJIT_TEMPORARY_REG2
operator|&&
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
operator|(
name|SLJIT_TEMPORARY_REG2
operator|<<
literal|4
operator|)
condition|)
name|dst_r
operator|=
name|SLJIT_TEMPORARY_REG2
expr_stmt|;
else|else
name|dst_r
operator|=
name|SLJIT_TEMPORARY_REG3
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|32
operator|+
literal|31
argument_list|)
expr_stmt|;
else|#
directive|else
name|dst_r
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|64
operator|+
literal|63
else|:
literal|32
operator|+
literal|31
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|mode32
operator|=
name|op
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
literal|0x45
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BIN_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|31
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BIN_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|63
else|:
literal|31
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
operator|(
name|code
operator|+
literal|1
operator|)
operator||=
literal|0x6
operator|<<
literal|3
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x87
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|int
name|update
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|int
name|dst_is_ereg
init|=
literal|0
decl_stmt|;
name|int
name|src_is_ereg
init|=
literal|0
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|src_is_ereg
value|0
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
name|op
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
name|dst_is_ereg
operator|=
literal|1
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|,
name|src_is_ereg
operator|=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_MOV
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<=
name|SLJIT_MOVU_SI
condition|)
block|{
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|SLJIT_MOV
operator|+
literal|7
operator|==
name|SLJIT_MOVU
argument_list|,
name|movu_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOVU
condition|)
block|{
name|update
operator|=
literal|1
expr_stmt|;
name|op
operator|-=
literal|7
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_MOV_UB
case|:
name|srcw
operator|=
operator|(
name|unsigned
name|char
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SB
case|:
name|srcw
operator|=
operator|(
name|signed
name|char
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UH
case|:
name|srcw
operator|=
operator|(
name|unsigned
name|short
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SH
case|:
name|srcw
operator|=
operator|(
name|signed
name|short
operator|)
name|srcw
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
case|case
name|SLJIT_MOV_UI
case|:
name|srcw
operator|=
operator|(
name|unsigned
name|int
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SI
case|:
name|srcw
operator|=
operator|(
name|signed
name|int
operator|)
name|srcw
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst_is_ereg
argument_list|)
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|update
argument_list|)
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|!
name|src_is_ereg
operator|&&
operator|(
name|src
operator|&
literal|0xf
operator|)
operator|&&
operator|(
name|srcw
operator|!=
literal|0
operator|||
operator|(
name|src
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src
operator|&
literal|0xf
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8d
expr_stmt|;
name|src
operator|&=
name|SLJIT_MEM
operator||
literal|0xf
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst_is_ereg
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|op
operator|==
name|SLJIT_MOV_UI
operator|||
name|op
operator|==
name|SLJIT_MOV_SI
operator|)
operator|||
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|dst
operator|==
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UB
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_byte
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|unsigned
name|char
operator|)
name|srcw
else|:
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SB
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_byte
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|signed
name|char
operator|)
name|srcw
else|:
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UH
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_half
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|unsigned
name|short
operator|)
name|srcw
else|:
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SH
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_half
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|signed
name|short
operator|)
name|srcw
else|:
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
case|case
name|SLJIT_MOV_UI
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_int
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|unsigned
name|int
operator|)
name|srcw
else|:
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SI
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_int
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|signed
name|int
operator|)
name|srcw
else|:
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst_is_ereg
argument_list|)
operator|&&
name|dst
operator|==
name|TMP_REGISTER
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|update
argument_list|)
operator|&&
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|&&
operator|(
name|dstw
operator|!=
literal|0
operator|||
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
operator|&
literal|0xf
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8d
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_NOT
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_SET_E
argument_list|)
condition|)
return|return
name|emit_not_with_flags
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
return|return
name|emit_unary
argument_list|(
name|compiler
argument_list|,
literal|0x2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NEG
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_unary
argument_list|(
name|compiler
argument_list|,
literal|0x3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_CLZ
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_clz
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
DECL|macro|src_is_ereg
undef|#
directive|undef
name|src_is_ereg
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_define
DECL|macro|BINARY_IMM
define|#
directive|define
name|BINARY_IMM
parameter_list|(
name|_op_imm_
parameter_list|,
name|_op_mr_
parameter_list|,
name|immw
parameter_list|,
name|arg
parameter_list|,
name|argw
parameter_list|)
define|\
value|if (IS_HALFWORD(immw) || compiler->mode32) { \ 		code = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, immw, arg, argw); \ 		FAIL_IF(!code); \ 		*(code + 1) |= (_op_imm_); \ 	} \ 	else { \ 		FAIL_IF(emit_load_imm64(compiler, TMP_REG2, immw)); \ 		code = emit_x86_instruction(compiler, 1, TMP_REG2, 0, arg, argw); \ 		FAIL_IF(!code); \ 		*code = (_op_mr_); \ 	}
end_define
begin_define
DECL|macro|BINARY_EAX_IMM
define|#
directive|define
name|BINARY_EAX_IMM
parameter_list|(
name|_op_eax_imm_
parameter_list|,
name|immw
parameter_list|)
define|\
value|FAIL_IF(emit_do_imm32(compiler, (!compiler->mode32) ? REX_W : 0, (_op_eax_imm_), immw))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|BINARY_IMM
define|#
directive|define
name|BINARY_IMM
parameter_list|(
name|_op_imm_
parameter_list|,
name|_op_mr_
parameter_list|,
name|immw
parameter_list|,
name|arg
parameter_list|,
name|argw
parameter_list|)
define|\
value|code = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, immw, arg, argw); \ 	FAIL_IF(!code); \ 	*(code + 1) |= (_op_imm_);
end_define
begin_define
DECL|macro|BINARY_EAX_IMM
define|#
directive|define
name|BINARY_EAX_IMM
parameter_list|(
name|_op_eax_imm_
parameter_list|,
name|immw
parameter_list|)
define|\
value|FAIL_IF(emit_do_imm(compiler, (_op_eax_imm_), immw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|emit_cum_binary
specifier|static
name|int
name|emit_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_TEMPORARY_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_TEMPORARY_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|op_eax_imm
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src2
operator|<=
name|TMP_REGISTER
condition|)
block|{
comment|/* Special exception for sljit_emit_cond_value. */
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_mr
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_mr
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* Only for cumulative operations. */
if|if
condition|(
name|dst
operator|==
name|src2
operator|&&
name|dstw
operator|==
name|src2w
condition|)
block|{
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_TEMPORARY_REG1
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_TEMPORARY_REG1
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|op_eax_imm
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src1
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_mr
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_mr
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* General version. */
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This version requires less memory writing. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_non_cum_binary
specifier|static
name|int
name|emit_non_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_TEMPORARY_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_TEMPORARY_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|op_eax_imm
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src2
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_mr
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_mr
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* General version. */
if|if
condition|(
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
operator|)
operator|&&
name|dst
operator|!=
name|src2
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This version requires less memory writing. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|op_rm
expr_stmt|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_mul
specifier|static
name|int
name|emit_mul
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|int
name|dst_r
decl_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
comment|/* Register destination. */
if|if
condition|(
name|dst_r
operator|==
name|src1
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
literal|0xaf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst_r
operator|==
name|src2
operator|&&
operator|!
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
literal|0xaf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|src2
operator|=
name|dst_r
expr_stmt|;
name|src2w
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|src1w
operator|<=
literal|127
operator|&&
name|src1w
operator|>=
operator|-
literal|128
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x6b
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
name|INC_CSIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
operator|(
name|sljit_b
operator|)
name|src1w
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x69
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
name|INC_CSIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|code
operator|=
name|src1w
expr_stmt|;
block|}
else|#
directive|else
elseif|else
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x69
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
name|INC_CSIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_hw
operator|*
operator|)
name|code
operator|=
operator|(
name|sljit_hw
operator|)
name|src1w
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|!=
name|src2
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
literal|0xaf
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
comment|/* Note: src1 is NOT immediate. */
if|if
condition|(
name|src2w
operator|<=
literal|127
operator|&&
name|src2w
operator|>=
operator|-
literal|128
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x6b
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
name|INC_CSIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
operator|(
name|sljit_b
operator|)
name|src2w
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x69
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
name|INC_CSIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|code
operator|=
name|src2w
expr_stmt|;
block|}
else|#
directive|else
elseif|else
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x69
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
name|INC_CSIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_hw
operator|*
operator|)
name|code
operator|=
operator|(
name|sljit_hw
operator|)
name|src2w
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|!=
name|src1
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
literal|0xaf
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Neither argument is immediate. */
if|if
condition|(
name|ADDRESSING_DEPENDS_ON
argument_list|(
name|src2
argument_list|,
name|dst_r
argument_list|)
condition|)
name|dst_r
operator|=
name|TMP_REGISTER
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|code
operator|=
literal|0xaf
expr_stmt|;
block|}
if|if
condition|(
name|dst_r
operator|==
name|TMP_REGISTER
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_lea_binary
specifier|static
name|int
name|emit_lea_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|int
name|dst_r
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
comment|/* These cases better be left to handled by normal way. */
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
if|if
condition|(
name|dst
operator|==
name|src2
operator|&&
name|dstw
operator|==
name|src2w
condition|)
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
name|dst_r
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
name|src1
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src1
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
if|if
condition|(
name|src2
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src2
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
comment|/* It is not possible to be both SLJIT_LOCALS_REG. */
if|if
condition|(
name|src1
operator|!=
name|SLJIT_LOCALS_REG
operator|||
name|src2
operator|!=
name|SLJIT_LOCALS_REG
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|src1
argument_list|,
name|src2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8d
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src1
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|src2w
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src1
argument_list|)
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8d
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src2
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src2
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src2
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|src1w
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src2
argument_list|)
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x8d
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
condition|)
block|{
if|if
condition|(
name|dst_r
operator|==
name|TMP_REGISTER
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
DECL|function|emit_cmp_binary
specifier|static
name|int
name|emit_cmp_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|src1
operator|==
name|SLJIT_TEMPORARY_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|src1
operator|==
name|SLJIT_TEMPORARY_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
literal|0x3d
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src1
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src1
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
literal|0x7
operator|<<
literal|3
argument_list|,
literal|0x39
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x3b
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src2
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src2
operator|<=
name|SLJIT_NO_REGISTERS
operator|&&
operator|!
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x39
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_REGISTER
expr_stmt|;
name|src1w
operator|=
literal|0
expr_stmt|;
block|}
name|BINARY_IMM
argument_list|(
literal|0x7
operator|<<
literal|3
argument_list|,
literal|0x39
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x3b
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_test_binary
specifier|static
name|int
name|emit_test_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|src1
operator|==
name|SLJIT_TEMPORARY_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|src1
operator|==
name|SLJIT_TEMPORARY_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
literal|0xa9
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|src2
operator|==
name|SLJIT_TEMPORARY_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|src2
operator|==
name|SLJIT_TEMPORARY_REG1
operator|&&
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
literal|0xa9
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src1
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src1
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|||
name|compiler
operator|->
name|mode32
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xf7
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x85
expr_stmt|;
block|}
else|#
directive|else
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xf7
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x85
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src2
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|src2
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|||
name|compiler
operator|->
name|mode32
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xf7
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x85
expr_stmt|;
block|}
else|#
directive|else
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xf7
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x85
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|||
name|compiler
operator|->
name|mode32
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xf7
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x85
expr_stmt|;
block|}
else|#
directive|else
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0xf7
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0x85
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_shift
specifier|static
name|int
name|emit_shift
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|mode
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|||
operator|(
name|src2
operator|==
name|SLJIT_PREF_SHIFT_REG
operator|)
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
block|{
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|SLJIT_PREF_SHIFT_REG
operator|&&
name|src2
operator|==
name|SLJIT_PREF_SHIFT_REG
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|SLJIT_PREF_SHIFT_REG
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
operator|&&
name|dst
operator|!=
name|src2
operator|&&
operator|!
name|ADDRESSING_DEPENDS_ON
argument_list|(
name|src2
argument_list|,
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This case is really difficult, since ecx itself may used for 		   addressing, and we must ensure to work even in that case. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* [esp - 4] is reserved for eflags. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
operator|-
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator||=
name|mode
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* [esp - 4] is reserved for eflags. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
operator|-
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_shift_with_flags
specifier|static
name|int
name|emit_shift_with_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|mode
parameter_list|,
name|int
name|set_flags
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
comment|/* The CPU does not set flags if the shift count is 0. */
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|src2w
operator|&
literal|0x3f
operator|)
operator|!=
literal|0
operator|||
operator|(
name|compiler
operator|->
name|mode32
operator|&&
operator|(
name|src2w
operator|&
literal|0x1f
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|src2w
operator|&
literal|0x1f
operator|)
operator|!=
literal|0
condition|)
return|return
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|set_flags
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
return|;
comment|/* OR dst, src, 0 */
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x0b
argument_list|,
literal|0x09
argument_list|,
literal|0x1
operator|<<
literal|3
argument_list|,
literal|0x0d
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|set_flags
condition|)
return|return
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_cmp_binary
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
return|return
name|emit_cmp_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
name|op
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_MUL
condition|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|emit_lea_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
return|return
name|compiler
operator|->
name|error
return|;
block|}
else|else
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x03
argument_list|,
literal|0x01
argument_list|,
literal|0x0
operator|<<
literal|3
argument_list|,
literal|0x05
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_ADDC
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
comment|/* C flag must be restored. */
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x13
argument_list|,
literal|0x11
argument_list|,
literal|0x2
operator|<<
literal|3
argument_list|,
literal|0x15
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|emit_lea_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|src2w
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
return|return
name|compiler
operator|->
name|error
return|;
block|}
else|else
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|emit_cmp_binary
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
return|return
name|emit_non_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x2b
argument_list|,
literal|0x29
argument_list|,
literal|0x5
operator|<<
literal|3
argument_list|,
literal|0x2d
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUBC
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
comment|/* C flag must be restored. */
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
return|return
name|emit_non_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x1b
argument_list|,
literal|0x19
argument_list|,
literal|0x3
operator|<<
literal|3
argument_list|,
literal|0x1d
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_MUL
case|:
return|return
name|emit_mul
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|emit_test_binary
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x23
argument_list|,
literal|0x21
argument_list|,
literal|0x4
operator|<<
literal|3
argument_list|,
literal|0x25
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_OR
case|:
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x0b
argument_list|,
literal|0x09
argument_list|,
literal|0x1
operator|<<
literal|3
argument_list|,
literal|0x0d
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_XOR
case|:
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
literal|0x33
argument_list|,
literal|0x31
argument_list|,
literal|0x6
operator|<<
literal|3
argument_list|,
literal|0x35
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SHL
case|:
return|return
name|emit_shift_with_flags
argument_list|(
name|compiler
argument_list|,
literal|0x4
operator|<<
literal|3
argument_list|,
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_LSHR
case|:
return|return
name|emit_shift_with_flags
argument_list|(
name|compiler
argument_list|,
literal|0x5
operator|<<
literal|3
argument_list|,
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_ASHR
case|:
return|return
name|emit_shift_with_flags
argument_list|(
name|compiler
argument_list|,
literal|0x7
operator|<<
literal|3
argument_list|,
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_get_register_index
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|check_sljit_get_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|reg
operator|==
name|SLJIT_TEMPORARY_EREG1
operator|||
name|reg
operator|==
name|SLJIT_TEMPORARY_EREG2
operator|||
name|reg
operator|==
name|SLJIT_SAVED_EREG1
operator|||
name|reg
operator|==
name|SLJIT_SAVED_EREG2
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
return|return
name|reg_map
index|[
name|reg
index|]
return|;
block|}
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_custom
argument_list|(
name|compiler
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<
literal|16
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|SLJIT_MEMMOVE
argument_list|(
name|buf
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* --------------------------------------------------------------------- */
comment|/*  Floating point operators                                             */
comment|/* --------------------------------------------------------------------- */
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
DECL|variable|sse2_available
specifier|static
name|int
name|sse2_available
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
comment|/* Alignment + 2 * 16 bytes. */
DECL|variable|sse2_data
specifier|static
name|sljit_i
name|sse2_data
index|[
literal|3
operator|+
literal|4
operator|+
literal|4
index|]
decl_stmt|;
DECL|variable|sse2_buffer
specifier|static
name|sljit_i
modifier|*
name|sse2_buffer
decl_stmt|;
DECL|function|init_compiler
specifier|static
name|void
name|init_compiler
parameter_list|()
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
name|int
name|features
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|sse2_buffer
operator|=
operator|(
name|sljit_i
operator|*
operator|)
operator|(
operator|(
operator|(
name|sljit_uw
operator|)
name|sse2_data
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
operator|)
expr_stmt|;
name|sse2_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sse2_buffer
index|[
literal|1
index|]
operator|=
literal|0x80000000
expr_stmt|;
name|sse2_buffer
index|[
literal|4
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|sse2_buffer
index|[
literal|5
index|]
operator|=
literal|0x7fffffff
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
ifdef|#
directive|ifdef
name|__GNUC__
comment|/* AT&T syntax. */
asm|asm ( 		"pushl %%ebx\n" 		"movl $0x1, %%eax\n" 		"cpuid\n" 		"popl %%ebx\n" 		"movl %%edx, %0\n" 		: "=g" (features) 		: 		: "%eax", "%ecx", "%edx" 	);
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
comment|/* Intel syntax. */
asm|__asm {
asm|mov eax, 1
asm|push ebx
asm|cpuid
asm|pop ebx
asm|mov features, edx
asm|}
else|#
directive|else
error|#
directive|error
literal|"SLJIT_SSE2_AUTO is not implemented for this C compiler"
endif|#
directive|endif
name|sse2_available
operator|=
operator|(
name|features
operator|>>
literal|26
operator|)
operator|&
literal|0x1
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Always available. */
return|return
literal|1
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
DECL|function|emit_sse2
specifier|static
name|int
name|emit_sse2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|opcode
parameter_list|,
name|int
name|xmm1
parameter_list|,
name|int
name|xmm2
parameter_list|,
name|sljit_w
name|xmm2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
operator||
name|EX86_PREF_F2
operator||
name|EX86_SSE2
argument_list|,
name|xmm1
argument_list|,
literal|0
argument_list|,
name|xmm2
argument_list|,
name|xmm2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|=
name|opcode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_sse2_logic
specifier|static
name|int
name|emit_sse2_logic
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|opcode
parameter_list|,
name|int
name|xmm1
parameter_list|,
name|int
name|xmm2
parameter_list|,
name|sljit_w
name|xmm2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
operator||
name|EX86_PREF_66
operator||
name|EX86_SSE2
argument_list|,
name|xmm1
argument_list|,
literal|0
argument_list|,
name|xmm2
argument_list|,
name|xmm2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|=
name|opcode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_sse2_load
specifier|static
name|SLJIT_INLINE
name|int
name|emit_sse2_load
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
return|return
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
literal|0x10
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
DECL|function|emit_sse2_store
specifier|static
name|SLJIT_INLINE
name|int
name|emit_sse2_store
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|)
block|{
return|return
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
literal|0x11
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_fop1
argument_list|(
expr|struct
name|sljit_compiler
operator|*
name|compiler
argument_list|,
name|int
name|op
argument_list|,
else|#
directive|else
specifier|static
name|int
name|sljit_emit_sse2_fop1
argument_list|(
argument|struct sljit_compiler *compiler
argument_list|,
argument|int op
argument_list|,
endif|#
directive|endif
argument|int dst
argument_list|,
argument|sljit_w dstw
argument_list|,
argument|int src
argument_list|,
argument|sljit_w srcw
argument_list|)
block|{
name|int
name|dst_r
block|;
name|CHECK_ERROR
argument_list|()
argument_list|;
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_FCMP
condition|)
block|{
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dst
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
name|dst_r
operator|=
name|dst
expr_stmt|;
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|emit_sse2_logic
argument_list|(
name|compiler
argument_list|,
literal|0x2e
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
if|if
condition|(
name|op
operator|==
name|SLJIT_FMOV
condition|)
block|{
if|if
condition|(
name|dst
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
return|return
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
if|if
condition|(
name|src
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|src
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|)
return|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|TMP_FREG
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_FREG
argument_list|)
return|;
block|}
if|if
condition|(
name|dst
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|src
condition|)
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_FNEG
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2_logic
argument_list|(
name|compiler
argument_list|,
literal|0x57
argument_list|,
name|dst_r
argument_list|,
name|SLJIT_MEM0
argument_list|()
argument_list|,
operator|(
name|sljit_w
operator|)
name|sse2_buffer
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FABS
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2_logic
argument_list|(
name|compiler
argument_list|,
literal|0x54
argument_list|,
name|dst_r
argument_list|,
name|SLJIT_MEM0
argument_list|()
argument_list|,
call|(
name|sljit_w
call|)
argument_list|(
name|sse2_buffer
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_r
operator|==
name|TMP_FREG
condition|)
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_FREG
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_fop2
argument_list|(
expr|struct
name|sljit_compiler
operator|*
name|compiler
argument_list|,
name|int
name|op
argument_list|,
else|#
directive|else
specifier|static
name|int
name|sljit_emit_sse2_fop2
argument_list|(
argument|struct sljit_compiler *compiler
argument_list|,
argument|int op
argument_list|,
endif|#
directive|endif
argument|int dst
argument_list|,
argument|sljit_w dstw
argument_list|,
argument|int src1
argument_list|,
argument|sljit_w src1w
argument_list|,
argument|int src2
argument_list|,
argument|sljit_w src2w
argument_list|)
block|{
name|int
name|dst_r
block|;
name|CHECK_ERROR
argument_list|()
argument_list|;
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dst
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|src1
condition|)
empty_stmt|;
comment|/* Do nothing here. */
elseif|else
if|if
condition|(
name|dst
operator|==
name|src2
operator|&&
operator|(
name|op
operator|==
name|SLJIT_FADD
operator|||
name|op
operator|==
name|SLJIT_FMUL
operator|)
condition|)
block|{
comment|/* Swap arguments. */
name|src2
operator|=
name|src1
expr_stmt|;
name|src2w
operator|=
name|src1w
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|TMP_FREG
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|TMP_FREG
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_FADD
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
literal|0x58
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FSUB
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
literal|0x5c
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FMUL
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
literal|0x59
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FDIV
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
literal|0x5e
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_r
operator|==
name|TMP_FREG
condition|)
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_FREG
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
operator|||
operator|!
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
DECL|function|emit_fld
specifier|static
name|int
name|emit_fld
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|src
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|src
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
block|{
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xd9
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xc0
operator|+
name|src
operator|-
literal|1
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|buf
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xdd
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_fop
specifier|static
name|int
name|emit_fop
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|st_arg
parameter_list|,
name|sljit_ub
name|st_arg2
parameter_list|,
name|sljit_ub
name|m64fp_arg
parameter_list|,
name|sljit_ub
name|m64fp_arg2
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|src
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|src
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
block|{
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|st_arg
expr_stmt|;
operator|*
name|buf
operator|=
name|st_arg2
operator|+
name|src
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|buf
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|m64fp_arg
expr_stmt|;
operator|*
name|buf
operator||=
name|m64fp_arg2
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_fop_regs
specifier|static
name|int
name|emit_fop_regs
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|st_arg
parameter_list|,
name|sljit_ub
name|st_arg2
parameter_list|,
name|int
name|src
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|st_arg
expr_stmt|;
operator|*
name|buf
operator|=
name|st_arg2
operator|+
name|src
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_fop1
argument_list|(
expr|struct
name|sljit_compiler
operator|*
name|compiler
argument_list|,
name|int
name|op
argument_list|,
else|#
directive|else
specifier|static
name|int
name|sljit_emit_fpu_fop1
argument_list|(
argument|struct sljit_compiler *compiler
argument_list|,
argument|int op
argument_list|,
endif|#
directive|endif
argument|int dst
argument_list|,
argument|sljit_w dstw
argument_list|,
argument|int src
argument_list|,
argument|sljit_w srcw
argument_list|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|sljit_ub
operator|*
name|buf
block|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
argument_list|;
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_FCMP
condition|)
block|{
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|FAIL_IF
argument_list|(
name|emit_fld
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_fop
argument_list|(
name|compiler
argument_list|,
literal|0xd8
argument_list|,
literal|0xd8
argument_list|,
literal|0xdc
argument_list|,
literal|0x3
operator|<<
literal|3
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy flags. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xdf
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xe0
expr_stmt|;
comment|/* Note: lahf is not supported on all x86-64 architectures. */
operator|*
name|buf
operator|++
operator|=
literal|0x9e
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|src
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|src
operator|<=
name|SLJIT_FLOAT_REG4
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_fld
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xdf
argument_list|,
literal|0xe8
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_fld
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_fld
argument_list|(
name|compiler
argument_list|,
name|dst
operator|+
operator|(
operator|(
name|dst
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_FLOAT_REG4
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xdf
argument_list|,
literal|0xe8
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xdd
argument_list|,
literal|0xd8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|FAIL_IF
argument_list|(
name|emit_fld
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_FNEG
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xd9
argument_list|,
literal|0xe0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FABS
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xd9
argument_list|,
literal|0xe1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|FAIL_IF
argument_list|(
name|emit_fop
argument_list|(
name|compiler
argument_list|,
literal|0xdd
argument_list|,
literal|0xd8
argument_list|,
literal|0xdd
argument_list|,
literal|0x3
operator|<<
literal|3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_fop2
argument_list|(
expr|struct
name|sljit_compiler
operator|*
name|compiler
argument_list|,
name|int
name|op
argument_list|,
else|#
directive|else
specifier|static
name|int
name|sljit_emit_fpu_fop2
argument_list|(
argument|struct sljit_compiler *compiler
argument_list|,
argument|int op
argument_list|,
endif|#
directive|endif
argument|int dst
argument_list|,
argument|sljit_w dstw
argument_list|,
argument|int src1
argument_list|,
argument|sljit_w src1w
argument_list|,
argument|int src2
argument_list|,
argument|sljit_w src2w
argument_list|)
block|{
name|CHECK_ERROR
argument_list|()
block|;
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|src1
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|src1
operator|<=
name|SLJIT_FLOAT_REG4
operator|&&
name|dst
operator|==
name|src1
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_fld
argument_list|(
name|compiler
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_FADD
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xc0
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FSUB
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xe8
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FMUL
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xc8
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FDIV
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xf8
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|FAIL_IF
argument_list|(
name|emit_fld
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|src2
operator|<=
name|SLJIT_FLOAT_REG4
operator|&&
name|dst
operator|==
name|src2
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_FADD
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xc0
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FSUB
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xe0
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FMUL
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xc8
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FDIV
case|:
name|FAIL_IF
argument_list|(
name|emit_fop_regs
argument_list|(
name|compiler
argument_list|,
literal|0xde
argument_list|,
literal|0xf0
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_FADD
case|:
name|FAIL_IF
argument_list|(
name|emit_fop
argument_list|(
name|compiler
argument_list|,
literal|0xd8
argument_list|,
literal|0xc0
argument_list|,
literal|0xdc
argument_list|,
literal|0x0
operator|<<
literal|3
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FSUB
case|:
name|FAIL_IF
argument_list|(
name|emit_fop
argument_list|(
name|compiler
argument_list|,
literal|0xd8
argument_list|,
literal|0xe0
argument_list|,
literal|0xdc
argument_list|,
literal|0x4
operator|<<
literal|3
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FMUL
case|:
name|FAIL_IF
argument_list|(
name|emit_fop
argument_list|(
name|compiler
argument_list|,
literal|0xd8
argument_list|,
literal|0xc8
argument_list|,
literal|0xdc
argument_list|,
literal|0x1
operator|<<
literal|3
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_FDIV
case|:
name|FAIL_IF
argument_list|(
name|emit_fop
argument_list|(
name|compiler
argument_list|,
literal|0xd8
argument_list|,
literal|0xf0
argument_list|,
literal|0xdc
argument_list|,
literal|0x6
operator|<<
literal|3
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|FAIL_IF
argument_list|(
name|emit_fop
argument_list|(
name|compiler
argument_list|,
literal|0xdd
argument_list|,
literal|0xd8
argument_list|,
literal|0xdd
argument_list|,
literal|0x3
operator|<<
literal|3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2_AUTO
operator|&&
name|SLJIT_SSE2_AUTO
operator|)
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
if|if
condition|(
name|sse2_available
condition|)
return|return
name|sljit_emit_sse2_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
else|else
return|return
name|sljit_emit_fpu_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src1w
parameter_list|,
name|int
name|src2
parameter_list|,
name|sljit_w
name|src2w
parameter_list|)
block|{
if|if
condition|(
name|sse2_available
condition|)
return|return
name|sljit_emit_sse2_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
else|else
return|return
name|sljit_emit_fpu_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* --------------------------------------------------------------------- */
comment|/*  Conditional instructions                                             */
comment|/* --------------------------------------------------------------------- */
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
comment|/* We should restore the flags before the label, 	   since other taken jumps has their own flags as well. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|label
return|;
block|}
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_JUMP
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
block|}
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL1
condition|)
name|PTR_FAIL_IF
argument_list|(
name|call_with_args
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Worst case size. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|compiler
operator|->
name|size
operator|+=
operator|(
name|type
operator|>=
name|SLJIT_JUMP
operator|)
condition|?
literal|5
else|:
literal|6
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|size
operator|+=
operator|(
name|type
operator|>=
name|SLJIT_JUMP
operator|)
condition|?
operator|(
literal|10
operator|+
literal|3
operator|)
else|:
operator|(
literal|2
operator|+
literal|10
operator|+
literal|3
operator|)
expr_stmt|;
endif|#
directive|endif
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|type
operator|+
literal|4
expr_stmt|;
return|return
name|jump
return|;
block|}
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|src
parameter_list|,
name|sljit_w
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|<=
name|SLJIT_JUMP
condition|)
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL1
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
if|if
condition|(
name|src
operator|==
name|SLJIT_TEMPORARY_REG3
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|src
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_LOCALS_REG
operator|&&
name|type
operator|>=
name|SLJIT_CALL3
condition|)
block|{
if|if
condition|(
name|src
operator|&
literal|0xf0
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
else|else
name|srcw
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|src
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_LOCALS_REG
condition|)
block|{
if|if
condition|(
name|src
operator|&
literal|0xf0
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
else|else
name|srcw
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
operator|*
operator|(
name|type
operator|-
name|SLJIT_CALL0
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
operator|&&
name|defined
argument_list|(
name|_WIN64
argument_list|)
if|if
condition|(
name|src
operator|==
name|SLJIT_TEMPORARY_REG3
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|call_with_args
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|==
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF_NULL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
comment|/* Worst case size. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|compiler
operator|->
name|size
operator|+=
literal|5
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|size
operator|+=
literal|10
operator|+
literal|3
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF_NULL
argument_list|(
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|type
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
comment|/* REX_W is not necessary (src is not immediate). */
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|code
operator||=
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
operator|)
condition|?
operator|(
literal|2
operator|<<
literal|3
operator|)
else|:
operator|(
literal|4
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_emit_cond_value
name|SLJIT_API_FUNC_ATTRIBUTE
name|int
name|sljit_emit_cond_value
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|sljit_ub
name|cond_set
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|int
name|reg
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_cond_value
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
name|cond_set
operator|=
literal|0x94
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
name|cond_set
operator|=
literal|0x95
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
name|cond_set
operator|=
literal|0x92
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
name|cond_set
operator|=
literal|0x93
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
name|cond_set
operator|=
literal|0x97
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
name|cond_set
operator|=
literal|0x96
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS
case|:
name|cond_set
operator|=
literal|0x9c
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|cond_set
operator|=
literal|0x9d
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
name|cond_set
operator|=
literal|0x9f
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|cond_set
operator|=
literal|0x9e
expr_stmt|;
break|break;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
name|cond_set
operator|=
literal|0x90
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
name|cond_set
operator|=
literal|0x91
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_NAN
case|:
name|cond_set
operator|=
literal|0x9a
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_NOT_NAN
case|:
name|cond_set
operator|=
literal|0x9b
expr_stmt|;
break|break;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|reg
operator|=
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|&&
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Set low register to conditional flag. */
operator|*
name|buf
operator|++
operator|=
operator|(
name|reg_map
index|[
name|reg
index|]
operator|<=
literal|7
operator|)
condition|?
literal|0x40
else|:
name|REX_B
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xC0
operator||
name|reg_lmap
index|[
name|reg
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|REX_W
operator||
operator|(
name|reg_map
index|[
name|reg
index|]
operator|<=
literal|7
condition|?
literal|0
else|:
operator|(
name|REX_B
operator||
name|REX_R
operator|)
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xb6
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xC0
operator||
operator|(
name|reg_lmap
index|[
name|reg
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_lmap
index|[
name|reg
index|]
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|TMP_REGISTER
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV
condition|)
block|{
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV
condition|)
block|{
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_TEMPORARY_REG3
condition|)
block|{
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|3
operator|+
literal|3
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|3
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* Set low byte to conditional flag. */
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xC0
operator||
name|reg_map
index|[
name|dst
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xb6
expr_stmt|;
operator|*
name|buf
operator|=
literal|0xC0
operator||
operator|(
name|reg_map
index|[
name|dst
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|dst
index|]
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|3
operator|+
literal|3
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|3
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* Set al to conditional flag. */
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xC0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xb6
expr_stmt|;
if|if
condition|(
name|dst
operator|>=
name|SLJIT_SAVED_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
condition|)
operator|*
name|buf
operator|=
literal|0xC0
operator||
operator|(
name|reg_map
index|[
name|dst
index|]
operator|<<
literal|3
operator|)
expr_stmt|;
else|else
block|{
operator|*
name|buf
operator|=
literal|0xC0
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_TEMPORARY_REG3
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xC0
operator||
name|reg_map
index|[
name|dst
index|]
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|3
operator|+
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|3
operator|+
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Set al to conditional flag. */
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xC0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xb6
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0xC0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0x90
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst
parameter_list|,
name|sljit_w
name|dstw
parameter_list|,
name|sljit_w
name|init_value
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|buf
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|int
name|reg
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
operator|(
name|dst
operator|>=
name|SLJIT_TEMPORARY_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_NO_REGISTERS
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|init_value
argument_list|)
condition|)
return|return
name|NULL
return|;
else|#
directive|else
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
name|dst
operator|=
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
name|init_value
argument_list|)
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
name|buf
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|reg
operator|==
name|TMP_REGISTER
operator|&&
name|dst
operator|!=
name|SLJIT_UNUSED
condition|)
if|if
condition|(
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
return|return
name|const_
return|;
block|}
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|addr
operator|=
name|new_addr
operator|-
operator|(
name|addr
operator|+
literal|4
operator|)
expr_stmt|;
else|#
directive|else
operator|*
operator|(
name|sljit_uw
operator|*
operator|)
name|addr
operator|=
name|new_addr
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_w
name|new_constant
parameter_list|)
block|{
operator|*
operator|(
name|sljit_w
operator|*
operator|)
name|addr
operator|=
name|new_constant
expr_stmt|;
block|}
end_function
end_unit
