begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"x86"
name|SLJIT_CPUINFO
return|;
block|}
end_function
begin_comment
comment|/*    32b register indexes:      0 - EAX      1 - ECX      2 - EDX      3 - EBX      4 - none      5 - EBP      6 - ESI      7 - EDI */
end_comment
begin_comment
comment|/*    64b register indexes:      0 - RAX      1 - RCX      2 - RDX      3 - RBX      4 - none      5 - RBP      6 - RSI      7 - RDI      8 - R8   - From now on REX prefix is required      9 - R9     10 - R10     11 - R11     12 - R12     13 - R13     14 - R14     15 - R15 */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
end_if
begin_comment
comment|/* Last register + 1. */
end_comment
begin_define
DECL|macro|TMP_REGISTER
define|#
directive|define
name|TMP_REGISTER
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|CHECK_EXTRA_REGS
define|#
directive|define
name|CHECK_EXTRA_REGS
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|,
define|do) \ 	if (p>= SLJIT_TEMPORARY_EREG1&& p<= SLJIT_TEMPORARY_EREG2) { \ 		w = compiler->scratches_start + (p - SLJIT_TEMPORARY_EREG1) * sizeof(sljit_sw); \ 		p = SLJIT_MEM1(SLJIT_LOCALS_REG); \ 		do; \ 	} \ 	else if (p>= SLJIT_SAVED_EREG1&& p<= SLJIT_SAVED_EREG2) { \ 		w = compiler->saveds_start + (p - SLJIT_SAVED_EREG1) * sizeof(sljit_sw); \ 		p = SLJIT_MEM1(SLJIT_LOCALS_REG); \ 		do; \ 	}
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SLJIT_CONFIG_X86_32 */
end_comment
begin_comment
comment|/* Last register + 1. */
end_comment
begin_define
DECL|macro|TMP_REGISTER
define|#
directive|define
name|TMP_REGISTER
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NO_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NO_REGISTERS + 3)
end_define
begin_comment
comment|/* Note: r12& 0x7 == 0b100, which decoded as SIB byte present    Note: avoid to use r12 and r13 for memory addessing    therefore r12 is better for SAVED_EREG than SAVED_REG. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_WIN64
end_ifndef
begin_comment
comment|/* 1st passed in rdi, 2nd argument passed in rsi, 3rd in rdx. */
end_comment
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|1
block|,
literal|8
block|,
literal|11
block|,
literal|3
block|,
literal|15
block|,
literal|14
block|,
literal|13
block|,
literal|12
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* low-map. reg_map& 0x7. */
end_comment
begin_decl_stmt
DECL|variable|reg_lmap
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_lmap
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* 1st passed in rcx, 2nd argument passed in rdx, 3rd in r8. */
end_comment
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|11
block|,
literal|13
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|14
block|,
literal|15
block|,
literal|4
block|,
literal|10
block|,
literal|8
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* low-map. reg_map& 0x7. */
end_comment
begin_decl_stmt
DECL|variable|reg_lmap
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_lmap
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|6
block|,
literal|7
block|,
literal|4
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|REX_W
define|#
directive|define
name|REX_W
value|0x48
end_define
begin_define
DECL|macro|REX_R
define|#
directive|define
name|REX_R
value|0x44
end_define
begin_define
DECL|macro|REX_X
define|#
directive|define
name|REX_X
value|0x42
end_define
begin_define
DECL|macro|REX_B
define|#
directive|define
name|REX_B
value|0x41
end_define
begin_define
DECL|macro|REX
define|#
directive|define
name|REX
value|0x40
end_define
begin_define
DECL|macro|IS_HALFWORD
define|#
directive|define
name|IS_HALFWORD
parameter_list|(
name|x
parameter_list|)
value|((x)<= 0x7fffffffll&& (x)>= -0x80000000ll)
end_define
begin_define
DECL|macro|NOT_HALFWORD
define|#
directive|define
name|NOT_HALFWORD
parameter_list|(
name|x
parameter_list|)
value|((x)> 0x7fffffffll || (x)< -0x80000000ll)
end_define
begin_define
DECL|macro|CHECK_EXTRA_REGS
define|#
directive|define
name|CHECK_EXTRA_REGS
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|,
define|do)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SLJIT_CONFIG_X86_32 */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
end_if
begin_define
DECL|macro|TMP_FREG
define|#
directive|define
name|TMP_FREG
value|(0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Size flags for emit_x86_instruction: */
end_comment
begin_define
DECL|macro|EX86_BIN_INS
define|#
directive|define
name|EX86_BIN_INS
value|0x0010
end_define
begin_define
DECL|macro|EX86_SHIFT_INS
define|#
directive|define
name|EX86_SHIFT_INS
value|0x0020
end_define
begin_define
DECL|macro|EX86_REX
define|#
directive|define
name|EX86_REX
value|0x0040
end_define
begin_define
DECL|macro|EX86_NO_REXW
define|#
directive|define
name|EX86_NO_REXW
value|0x0080
end_define
begin_define
DECL|macro|EX86_BYTE_ARG
define|#
directive|define
name|EX86_BYTE_ARG
value|0x0100
end_define
begin_define
DECL|macro|EX86_HALF_ARG
define|#
directive|define
name|EX86_HALF_ARG
value|0x0200
end_define
begin_define
DECL|macro|EX86_PREF_66
define|#
directive|define
name|EX86_PREF_66
value|0x0400
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
end_if
begin_define
DECL|macro|EX86_SSE2
define|#
directive|define
name|EX86_SSE2
value|0x0800
end_define
begin_define
DECL|macro|EX86_PREF_F2
define|#
directive|define
name|EX86_PREF_F2
value|0x1000
end_define
begin_define
DECL|macro|EX86_PREF_F3
define|#
directive|define
name|EX86_PREF_F3
value|0x2000
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Instrucion forms                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|ADD
define|#
directive|define
name|ADD
value|(
comment|/* BINARY */
value|0<< 3)
end_define
begin_define
DECL|macro|ADD_EAX_i32
define|#
directive|define
name|ADD_EAX_i32
value|0x05
end_define
begin_define
DECL|macro|ADD_r_rm
define|#
directive|define
name|ADD_r_rm
value|0x03
end_define
begin_define
DECL|macro|ADD_rm_r
define|#
directive|define
name|ADD_rm_r
value|0x01
end_define
begin_define
DECL|macro|ADDSD_x_xm
define|#
directive|define
name|ADDSD_x_xm
value|0x58
end_define
begin_define
DECL|macro|ADC
define|#
directive|define
name|ADC
value|(
comment|/* BINARY */
value|2<< 3)
end_define
begin_define
DECL|macro|ADC_EAX_i32
define|#
directive|define
name|ADC_EAX_i32
value|0x15
end_define
begin_define
DECL|macro|ADC_r_rm
define|#
directive|define
name|ADC_r_rm
value|0x13
end_define
begin_define
DECL|macro|ADC_rm_r
define|#
directive|define
name|ADC_rm_r
value|0x11
end_define
begin_define
DECL|macro|AND
define|#
directive|define
name|AND
value|(
comment|/* BINARY */
value|4<< 3)
end_define
begin_define
DECL|macro|AND_EAX_i32
define|#
directive|define
name|AND_EAX_i32
value|0x25
end_define
begin_define
DECL|macro|AND_r_rm
define|#
directive|define
name|AND_r_rm
value|0x23
end_define
begin_define
DECL|macro|AND_rm_r
define|#
directive|define
name|AND_rm_r
value|0x21
end_define
begin_define
DECL|macro|ANDPD_x_xm
define|#
directive|define
name|ANDPD_x_xm
value|0x54
end_define
begin_define
DECL|macro|BSR_r_rm
define|#
directive|define
name|BSR_r_rm
value|(
comment|/* GROUP_0F */
value|0xbd)
end_define
begin_define
DECL|macro|CALL_i32
define|#
directive|define
name|CALL_i32
value|0xe8
end_define
begin_define
DECL|macro|CALL_rm
define|#
directive|define
name|CALL_rm
value|(
comment|/* GROUP_FF */
value|2<< 3)
end_define
begin_define
DECL|macro|CDQ
define|#
directive|define
name|CDQ
value|0x99
end_define
begin_define
DECL|macro|CMOVNE_r_rm
define|#
directive|define
name|CMOVNE_r_rm
value|(
comment|/* GROUP_0F */
value|0x45)
end_define
begin_define
DECL|macro|CMP
define|#
directive|define
name|CMP
value|(
comment|/* BINARY */
value|7<< 3)
end_define
begin_define
DECL|macro|CMP_EAX_i32
define|#
directive|define
name|CMP_EAX_i32
value|0x3d
end_define
begin_define
DECL|macro|CMP_r_rm
define|#
directive|define
name|CMP_r_rm
value|0x3b
end_define
begin_define
DECL|macro|CMP_rm_r
define|#
directive|define
name|CMP_rm_r
value|0x39
end_define
begin_define
DECL|macro|DIV
define|#
directive|define
name|DIV
value|(
comment|/* GROUP_F7 */
value|6<< 3)
end_define
begin_define
DECL|macro|DIVSD_x_xm
define|#
directive|define
name|DIVSD_x_xm
value|0x5e
end_define
begin_define
DECL|macro|INT3
define|#
directive|define
name|INT3
value|0xcc
end_define
begin_define
DECL|macro|IDIV
define|#
directive|define
name|IDIV
value|(
comment|/* GROUP_F7 */
value|7<< 3)
end_define
begin_define
DECL|macro|IMUL
define|#
directive|define
name|IMUL
value|(
comment|/* GROUP_F7 */
value|5<< 3)
end_define
begin_define
DECL|macro|IMUL_r_rm
define|#
directive|define
name|IMUL_r_rm
value|(
comment|/* GROUP_0F */
value|0xaf)
end_define
begin_define
DECL|macro|IMUL_r_rm_i8
define|#
directive|define
name|IMUL_r_rm_i8
value|0x6b
end_define
begin_define
DECL|macro|IMUL_r_rm_i32
define|#
directive|define
name|IMUL_r_rm_i32
value|0x69
end_define
begin_define
DECL|macro|JE_i8
define|#
directive|define
name|JE_i8
value|0x74
end_define
begin_define
DECL|macro|JMP_i8
define|#
directive|define
name|JMP_i8
value|0xeb
end_define
begin_define
DECL|macro|JMP_i32
define|#
directive|define
name|JMP_i32
value|0xe9
end_define
begin_define
DECL|macro|JMP_rm
define|#
directive|define
name|JMP_rm
value|(
comment|/* GROUP_FF */
value|4<< 3)
end_define
begin_define
DECL|macro|LEA_r_m
define|#
directive|define
name|LEA_r_m
value|0x8d
end_define
begin_define
DECL|macro|MOV_r_rm
define|#
directive|define
name|MOV_r_rm
value|0x8b
end_define
begin_define
DECL|macro|MOV_r_i32
define|#
directive|define
name|MOV_r_i32
value|0xb8
end_define
begin_define
DECL|macro|MOV_rm_r
define|#
directive|define
name|MOV_rm_r
value|0x89
end_define
begin_define
DECL|macro|MOV_rm_i32
define|#
directive|define
name|MOV_rm_i32
value|0xc7
end_define
begin_define
DECL|macro|MOV_rm8_i8
define|#
directive|define
name|MOV_rm8_i8
value|0xc6
end_define
begin_define
DECL|macro|MOV_rm8_r8
define|#
directive|define
name|MOV_rm8_r8
value|0x88
end_define
begin_define
DECL|macro|MOVSD_x_xm
define|#
directive|define
name|MOVSD_x_xm
value|0x10
end_define
begin_define
DECL|macro|MOVSD_xm_x
define|#
directive|define
name|MOVSD_xm_x
value|0x11
end_define
begin_define
DECL|macro|MOVSXD_r_rm
define|#
directive|define
name|MOVSXD_r_rm
value|0x63
end_define
begin_define
DECL|macro|MOVSX_r_rm8
define|#
directive|define
name|MOVSX_r_rm8
value|(
comment|/* GROUP_0F */
value|0xbe)
end_define
begin_define
DECL|macro|MOVSX_r_rm16
define|#
directive|define
name|MOVSX_r_rm16
value|(
comment|/* GROUP_0F */
value|0xbf)
end_define
begin_define
DECL|macro|MOVZX_r_rm8
define|#
directive|define
name|MOVZX_r_rm8
value|(
comment|/* GROUP_0F */
value|0xb6)
end_define
begin_define
DECL|macro|MOVZX_r_rm16
define|#
directive|define
name|MOVZX_r_rm16
value|(
comment|/* GROUP_0F */
value|0xb7)
end_define
begin_define
DECL|macro|MUL
define|#
directive|define
name|MUL
value|(
comment|/* GROUP_F7 */
value|4<< 3)
end_define
begin_define
DECL|macro|MULSD_x_xm
define|#
directive|define
name|MULSD_x_xm
value|0x59
end_define
begin_define
DECL|macro|NEG_rm
define|#
directive|define
name|NEG_rm
value|(
comment|/* GROUP_F7 */
value|3<< 3)
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
value|0x90
end_define
begin_define
DECL|macro|NOT_rm
define|#
directive|define
name|NOT_rm
value|(
comment|/* GROUP_F7 */
value|2<< 3)
end_define
begin_define
DECL|macro|OR
define|#
directive|define
name|OR
value|(
comment|/* BINARY */
value|1<< 3)
end_define
begin_define
DECL|macro|OR_r_rm
define|#
directive|define
name|OR_r_rm
value|0x0b
end_define
begin_define
DECL|macro|OR_EAX_i32
define|#
directive|define
name|OR_EAX_i32
value|0x0d
end_define
begin_define
DECL|macro|OR_rm_r
define|#
directive|define
name|OR_rm_r
value|0x09
end_define
begin_define
DECL|macro|POP_r
define|#
directive|define
name|POP_r
value|0x58
end_define
begin_define
DECL|macro|POP_rm
define|#
directive|define
name|POP_rm
value|0x8f
end_define
begin_define
DECL|macro|POPF
define|#
directive|define
name|POPF
value|0x9d
end_define
begin_define
DECL|macro|PUSH_i32
define|#
directive|define
name|PUSH_i32
value|0x68
end_define
begin_define
DECL|macro|PUSH_r
define|#
directive|define
name|PUSH_r
value|0x50
end_define
begin_define
DECL|macro|PUSH_rm
define|#
directive|define
name|PUSH_rm
value|(
comment|/* GROUP_FF */
value|6<< 3)
end_define
begin_define
DECL|macro|PUSHF
define|#
directive|define
name|PUSHF
value|0x9c
end_define
begin_define
DECL|macro|RET_near
define|#
directive|define
name|RET_near
value|0xc3
end_define
begin_define
DECL|macro|RET_i16
define|#
directive|define
name|RET_i16
value|0xc2
end_define
begin_define
DECL|macro|SBB
define|#
directive|define
name|SBB
value|(
comment|/* BINARY */
value|3<< 3)
end_define
begin_define
DECL|macro|SBB_EAX_i32
define|#
directive|define
name|SBB_EAX_i32
value|0x1d
end_define
begin_define
DECL|macro|SBB_r_rm
define|#
directive|define
name|SBB_r_rm
value|0x1b
end_define
begin_define
DECL|macro|SBB_rm_r
define|#
directive|define
name|SBB_rm_r
value|0x19
end_define
begin_define
DECL|macro|SAR
define|#
directive|define
name|SAR
value|(
comment|/* SHIFT */
value|7<< 3)
end_define
begin_define
DECL|macro|SHL
define|#
directive|define
name|SHL
value|(
comment|/* SHIFT */
value|4<< 3)
end_define
begin_define
DECL|macro|SHR
define|#
directive|define
name|SHR
value|(
comment|/* SHIFT */
value|5<< 3)
end_define
begin_define
DECL|macro|SUB
define|#
directive|define
name|SUB
value|(
comment|/* BINARY */
value|5<< 3)
end_define
begin_define
DECL|macro|SUB_EAX_i32
define|#
directive|define
name|SUB_EAX_i32
value|0x2d
end_define
begin_define
DECL|macro|SUB_r_rm
define|#
directive|define
name|SUB_r_rm
value|0x2b
end_define
begin_define
DECL|macro|SUB_rm_r
define|#
directive|define
name|SUB_rm_r
value|0x29
end_define
begin_define
DECL|macro|SUBSD_x_xm
define|#
directive|define
name|SUBSD_x_xm
value|0x5c
end_define
begin_define
DECL|macro|TEST_EAX_i32
define|#
directive|define
name|TEST_EAX_i32
value|0xa9
end_define
begin_define
DECL|macro|TEST_rm_r
define|#
directive|define
name|TEST_rm_r
value|0x85
end_define
begin_define
DECL|macro|UCOMISD_x_xm
define|#
directive|define
name|UCOMISD_x_xm
value|0x2e
end_define
begin_define
DECL|macro|XCHG_EAX_r
define|#
directive|define
name|XCHG_EAX_r
value|0x90
end_define
begin_define
DECL|macro|XCHG_r_rm
define|#
directive|define
name|XCHG_r_rm
value|0x87
end_define
begin_define
DECL|macro|XOR
define|#
directive|define
name|XOR
value|(
comment|/* BINARY */
value|6<< 3)
end_define
begin_define
DECL|macro|XOR_EAX_i32
define|#
directive|define
name|XOR_EAX_i32
value|0x35
end_define
begin_define
DECL|macro|XOR_r_rm
define|#
directive|define
name|XOR_r_rm
value|0x33
end_define
begin_define
DECL|macro|XOR_rm_r
define|#
directive|define
name|XOR_rm_r
value|0x31
end_define
begin_define
DECL|macro|XORPD_x_xm
define|#
directive|define
name|XORPD_x_xm
value|0x57
end_define
begin_define
DECL|macro|GROUP_0F
define|#
directive|define
name|GROUP_0F
value|0x0f
end_define
begin_define
DECL|macro|GROUP_F7
define|#
directive|define
name|GROUP_F7
value|0xf7
end_define
begin_define
DECL|macro|GROUP_FF
define|#
directive|define
name|GROUP_FF
value|0xff
end_define
begin_define
DECL|macro|GROUP_BINARY_81
define|#
directive|define
name|GROUP_BINARY_81
value|0x81
end_define
begin_define
DECL|macro|GROUP_BINARY_83
define|#
directive|define
name|GROUP_BINARY_83
value|0x83
end_define
begin_define
DECL|macro|GROUP_SHIFT_1
define|#
directive|define
name|GROUP_SHIFT_1
value|0xd1
end_define
begin_define
DECL|macro|GROUP_SHIFT_N
define|#
directive|define
name|GROUP_SHIFT_N
value|0xc1
end_define
begin_define
DECL|macro|GROUP_SHIFT_CL
define|#
directive|define
name|GROUP_SHIFT_CL
value|0xd3
end_define
begin_define
DECL|macro|MOD_REG
define|#
directive|define
name|MOD_REG
value|0xc0
end_define
begin_define
DECL|macro|MOD_DISP8
define|#
directive|define
name|MOD_DISP8
value|0x40
end_define
begin_define
DECL|macro|INC_SIZE
define|#
directive|define
name|INC_SIZE
parameter_list|(
name|s
parameter_list|)
value|(*inst++ = (s), compiler->size += (s))
end_define
begin_define
DECL|macro|PUSH_REG
define|#
directive|define
name|PUSH_REG
parameter_list|(
name|r
parameter_list|)
value|(*inst++ = (PUSH_r + (r)))
end_define
begin_define
DECL|macro|POP_REG
define|#
directive|define
name|POP_REG
parameter_list|(
name|r
parameter_list|)
value|(*inst++ = (POP_r + (r)))
end_define
begin_define
DECL|macro|RET
define|#
directive|define
name|RET
parameter_list|()
value|(*inst++ = (RET_near))
end_define
begin_define
DECL|macro|RET_I16
define|#
directive|define
name|RET_I16
parameter_list|(
name|n
parameter_list|)
value|(*inst++ = (RET_i16), *inst++ = n, *inst++ = 0)
end_define
begin_comment
comment|/* r32, r/m32 */
end_comment
begin_define
DECL|macro|MOV_RM
define|#
directive|define
name|MOV_RM
parameter_list|(
name|mod
parameter_list|,
name|reg
parameter_list|,
name|rm
parameter_list|)
value|(*inst++ = (MOV_r_rm), *inst++ = (mod)<< 6 | (reg)<< 3 | (rm))
end_define
begin_comment
comment|/* Multithreading does not affect these static variables, since they store    built-in CPU features. Therefore they can be overwritten by different threads    if they detect the CPU features in the same time. */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
operator|&&
operator|(
name|defined
name|SLJIT_DETECT_SSE2
operator|&&
name|SLJIT_DETECT_SSE2
operator|)
end_if
begin_decl_stmt
DECL|variable|cpu_has_sse2
specifier|static
name|sljit_si
name|cpu_has_sse2
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|cpu_has_cmov
specifier|static
name|sljit_si
name|cpu_has_cmov
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_if
if|#
directive|if
name|_MSC_VER
operator|>=
literal|1400
end_if
begin_include
include|#
directive|include
file|<intrin.h>
end_include
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"MSVC does not support inline assembly in 64 bit mode"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _MSC_VER&& SLJIT_CONFIG_X86_64 */
end_comment
begin_function
DECL|function|get_cpu_features
specifier|static
name|void
name|get_cpu_features
parameter_list|(
name|void
parameter_list|)
block|{
name|sljit_ui
name|features
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|||
name|defined
argument_list|(
name|__SUNPRO_C
argument_list|)
comment|/* AT&T syntax. */
asm|__asm__ ( 		"pushl %%ebx\n" 		"movl $0x1, %%eax\n" 		"cpuid\n" 		"popl %%ebx\n" 		"movl %%edx, %0\n" 		: "=g" (features) 		: 		: "%eax", "%ecx", "%edx" 	);
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
comment|/* Intel syntax. */
asm|__asm {
asm|mov eax, 1
asm|push ebx
asm|cpuid
asm|pop ebx
asm|mov features, edx
asm|}
else|#
directive|else
error|#
directive|error
literal|"SLJIT_DETECT_SSE2 is not implemented for this C compiler"
endif|#
directive|endif
else|#
directive|else
comment|/* SLJIT_CONFIG_X86_32 */
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|||
name|defined
argument_list|(
name|__SUNPRO_C
argument_list|)
comment|/* AT&T syntax. */
asm|__asm__ ( 		"pushq %%rbx\n" 		"movl $0x1, %%eax\n" 		"cpuid\n" 		"popq %%rbx\n" 		"movl %%edx, %0\n" 		: "=g" (features) 		: 		: "%rax", "%rcx", "%rdx" 	);
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|int
name|CPUInfo
index|[
literal|4
index|]
decl_stmt|;
name|__cpuid
argument_list|(
name|CPUInfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|features
operator|=
operator|(
name|sljit_ui
operator|)
name|CPUInfo
index|[
literal|3
index|]
expr_stmt|;
else|#
directive|else
asm|__asm {
asm|mov eax, 1
asm|push rbx
asm|cpuid
asm|pop rbx
asm|mov features, edx
asm|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SLJIT_CONFIG_X86_32 */
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
operator|&&
operator|(
name|defined
name|SLJIT_DETECT_SSE2
operator|&&
name|SLJIT_DETECT_SSE2
operator|)
name|cpu_has_sse2
operator|=
operator|(
name|features
operator|>>
literal|26
operator|)
operator|&
literal|0x1
expr_stmt|;
endif|#
directive|endif
name|cpu_has_cmov
operator|=
operator|(
name|features
operator|>>
literal|15
operator|)
operator|&
literal|0x1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_jump_code
specifier|static
name|sljit_ub
name|get_jump_code
parameter_list|(
name|sljit_si
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
return|return
literal|0x84
comment|/* je */
return|;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
return|return
literal|0x85
comment|/* jne */
return|;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
return|return
literal|0x82
comment|/* jc */
return|;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
return|return
literal|0x83
comment|/* jae */
return|;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
return|return
literal|0x87
comment|/* jnbe */
return|;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
return|return
literal|0x86
comment|/* jbe */
return|;
case|case
name|SLJIT_C_SIG_LESS
case|:
return|return
literal|0x8c
comment|/* jl */
return|;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
return|return
literal|0x8d
comment|/* jnl */
return|;
case|case
name|SLJIT_C_SIG_GREATER
case|:
return|return
literal|0x8f
comment|/* jnle */
return|;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
return|return
literal|0x8e
comment|/* jle */
return|;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
return|return
literal|0x80
comment|/* jo */
return|;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
return|return
literal|0x81
comment|/* jno */
return|;
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
return|return
literal|0x8a
comment|/* jp */
return|;
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
return|return
literal|0x8b
comment|/* jpo */
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function_decl
specifier|static
name|sljit_ub
modifier|*
name|generate_far_jump_code
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_si
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_function_decl
specifier|static
name|sljit_ub
modifier|*
name|generate_fixed_jump
parameter_list|(
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_sw
name|addr
parameter_list|,
name|sljit_si
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|generate_near_jump_code
specifier|static
name|sljit_ub
modifier|*
name|generate_near_jump_code
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_ub
modifier|*
name|code
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_si
name|short_jump
decl_stmt|;
name|sljit_uw
name|label_addr
decl_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
condition|)
name|label_addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
expr_stmt|;
else|else
name|label_addr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
name|short_jump
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|2
operator|)
argument_list|)
operator|>=
operator|-
literal|128
operator|&&
call|(
name|sljit_sw
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|2
operator|)
argument_list|)
operator|<=
literal|127
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
call|(
name|sljit_sw
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|1
operator|)
argument_list|)
operator|>
literal|0x7fffffffll
operator|||
call|(
name|sljit_sw
call|)
argument_list|(
name|label_addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|1
operator|)
argument_list|)
operator|<
operator|-
literal|0x80000000ll
condition|)
return|return
name|generate_far_jump_code
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|type
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|SLJIT_JUMP
condition|)
block|{
if|if
condition|(
name|short_jump
condition|)
operator|*
name|code_ptr
operator|++
operator|=
name|JMP_i8
expr_stmt|;
else|else
operator|*
name|code_ptr
operator|++
operator|=
name|JMP_i32
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
block|{
name|short_jump
operator|=
literal|0
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|CALL_i32
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|short_jump
condition|)
block|{
operator|*
name|code_ptr
operator|++
operator|=
name|get_jump_code
argument_list|(
name|type
argument_list|)
operator|-
literal|0x10
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|code_ptr
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|get_jump_code
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|short_jump
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_MB
expr_stmt|;
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_MW
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
else|#
directive|else
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|code_ptr
return|;
block|}
end_function
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|sljit_ub
modifier|*
name|code
decl_stmt|;
name|sljit_ub
modifier|*
name|code_ptr
decl_stmt|;
name|sljit_ub
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_ub
modifier|*
name|buf_end
decl_stmt|;
name|sljit_ub
name|len
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
comment|/* Second code generation pass. */
name|code
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|code_ptr
operator|=
name|code
expr_stmt|;
name|label
operator|=
name|compiler
operator|->
name|labels
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
do|do
block|{
name|buf_ptr
operator|=
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
name|buf
operator|->
name|used_size
expr_stmt|;
do|do
block|{
name|len
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* The code is already generated. */
name|SLJIT_MEMMOVE
argument_list|(
name|code_ptr
argument_list|,
name|buf_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|code_ptr
operator|+=
name|len
expr_stmt|;
name|buf_ptr
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|buf_ptr
operator|>=
literal|4
condition|)
block|{
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|)
name|code_ptr
operator|=
name|generate_near_jump_code
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|,
operator|*
name|buf_ptr
operator|-
literal|4
argument_list|)
expr_stmt|;
else|else
name|code_ptr
operator|=
name|generate_far_jump_code
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
operator|*
name|buf_ptr
operator|-
literal|4
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|0
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|1
condition|)
block|{
name|const_
operator|->
name|addr
operator|=
operator|(
operator|(
name|sljit_uw
operator|)
name|code_ptr
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
name|code_ptr
operator|++
operator|=
operator|(
operator|*
name|buf_ptr
operator|==
literal|2
operator|)
condition|?
name|CALL_i32
else|:
name|JMP_i32
expr_stmt|;
name|buf_ptr
operator|++
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|code_ptr
operator|=
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|buf_ptr
operator|-
operator|(
operator|(
name|sljit_sw
operator|)
name|code_ptr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|)
expr_stmt|;
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|code_ptr
operator|=
name|generate_fixed_jump
argument_list|(
name|code_ptr
argument_list|,
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
literal|1
operator|)
argument_list|,
operator|*
name|buf_ptr
argument_list|)
expr_stmt|;
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|buf_ptr
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
name|buf_ptr
operator|==
name|buf_end
argument_list|)
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|buf
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_MB
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
operator|)
argument_list|)
operator|>=
operator|-
literal|128
operator|&&
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
operator|)
argument_list|)
operator|<=
literal|127
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_ub
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_ub
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_MW
condition|)
block|{
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_ASSERT
argument_list|(
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
operator|>=
operator|-
literal|0x80000000ll
operator|&&
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
operator|<=
literal|0x7fffffffll
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_si
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_ASSERT
argument_list|(
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
operator|>=
operator|-
literal|0x80000000ll
operator|&&
call|(
name|sljit_sw
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
operator|<=
literal|0x7fffffffll
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_si
call|)
argument_list|(
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
elseif|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_MD
condition|)
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|jump
operator|->
name|addr
operator|=
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
expr_stmt|;
endif|#
directive|endif
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
comment|/* Maybe we waste some space because of short jumps. */
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|<=
name|code
operator|+
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
name|compiler
operator|->
name|executable_size
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|code
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function_decl
specifier|static
name|sljit_si
name|emit_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|sljit_si
name|emit_non_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|sljit_si
name|emit_mov
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|emit_save_flags
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_save_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
else|#
directive|else
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|6
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|6
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
endif|#
directive|endif
operator|*
name|inst
operator|++
operator|=
name|LEA_r_m
expr_stmt|;
comment|/* lea esp/rsp, [esp/rsp + sizeof(sljit_sw)] */
operator|*
name|inst
operator|++
operator|=
literal|0x64
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0x24
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
operator|(
name|sljit_ub
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|PUSHF
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|1
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_restore_flags
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_restore_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|keep_flags
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|POPF
expr_stmt|;
else|#
directive|else
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|6
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|6
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|POPF
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
endif|#
directive|endif
operator|*
name|inst
operator|++
operator|=
name|LEA_r_m
expr_stmt|;
comment|/* lea esp/rsp, [esp/rsp - sizeof(sljit_sw)] */
operator|*
name|inst
operator|++
operator|=
literal|0x64
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0x24
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
operator|(
name|sljit_ub
operator|)
operator|-
operator|(
name|sljit_sb
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
name|keep_flags
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef
begin_include
include|#
directive|include
file|<malloc.h>
end_include
begin_function
DECL|function|sljit_grow_stack
specifier|static
name|void
name|SLJIT_CALL
name|sljit_grow_stack
parameter_list|(
name|sljit_sw
name|local_size
parameter_list|)
block|{
comment|/* Workaround for calling the internal _chkstk() function on Windows. 	This function touches all 4k pages belongs to the requested stack space, 	which size is passed in local_size. This is necessary on Windows where 	the stack can only grow in 4k steps. However, this function just burn 	CPU cycles if the stack is large enough, but you don't know it in advance. 	I think this is a bad design even if it has some reasons. */
name|alloca
argument_list|(
name|local_size
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitNativeX86_32.c"
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"sljitNativeX86_64.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|emit_mov
specifier|static
name|sljit_si
name|emit_mov
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
comment|/* No destination, doesn't need to setup flags. */
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_r_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_r
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
return|return
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
name|MOV_r_i32
operator|+
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
condition|)
block|{
if|if
condition|(
name|NOT_HALFWORD
argument_list|(
name|srcw
argument_list|)
condition|)
return|return
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|srcw
argument_list|)
return|;
block|}
else|else
return|return
name|emit_do_imm32
argument_list|(
name|compiler
argument_list|,
operator|(
name|reg_map
index|[
name|dst
index|]
operator|>=
literal|8
operator|)
condition|?
name|REX_B
else|:
literal|0
argument_list|,
name|MOV_r_i32
operator|+
name|reg_lmap
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
operator|&&
name|NOT_HALFWORD
argument_list|(
name|srcw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_r
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
endif|#
directive|endif
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_i32
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_r_rm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* Memory to memory move. Requires two instruction. */
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_r_rm
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_r
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|EMIT_MOV
define|#
directive|define
name|EMIT_MOV
parameter_list|(
name|compiler
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|FAIL_IF(emit_mov(compiler, dst, dstw, src, srcw));
end_define
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|sljit_si
name|size
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_BREAKPOINT
case|:
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|INT3
expr_stmt|;
break|break;
case|case
name|SLJIT_NOP
case|:
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|NOP
expr_stmt|;
break|break;
case|case
name|SLJIT_UMUL
case|:
case|case
name|SLJIT_SMUL
case|:
case|case
name|SLJIT_UDIV
case|:
case|case
name|SLJIT_SDIV
case|:
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
ifdef|#
directive|ifdef
name|_WIN64
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|==
literal|0
operator|&&
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|==
literal|2
operator|&&
name|reg_map
index|[
name|TMP_REGISTER
index|]
operator|>
literal|7
argument_list|,
name|invalid_register_assignment_for_div_mul
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|==
literal|0
operator|&&
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|<
literal|7
operator|&&
name|reg_map
index|[
name|TMP_REGISTER
index|]
operator|==
literal|2
argument_list|,
name|invalid_register_assignment_for_div_mul
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|mode32
operator|=
name|op
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_UDIV
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|||
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|XOR_r_rm
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|SLJIT_SDIV
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|||
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|CDQ
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|compiler
operator|->
name|mode32
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|CDQ
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|=
name|CDQ
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator|=
name|MOD_REG
operator||
operator|(
operator|(
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
name|reg_map
index|[
name|TMP_REGISTER
index|]
else|:
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_WIN64
name|size
operator|=
operator|(
operator|!
name|compiler
operator|->
name|mode32
operator|||
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
else|#
directive|else
name|size
operator|=
operator|(
operator|!
name|compiler
operator|->
name|mode32
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
endif|#
directive|endif
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
condition|)
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
operator|(
operator|(
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
name|REX_B
else|:
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|>=
name|SLJIT_UDIV
condition|)
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator|=
name|MOD_REG
operator||
operator|(
operator|(
name|op
operator|>=
name|SLJIT_UDIV
operator|)
condition|?
name|reg_lmap
index|[
name|TMP_REGISTER
index|]
else|:
name|reg_lmap
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
condition|)
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator|=
name|MOD_REG
operator||
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_UMUL
case|:
operator|*
name|inst
operator||=
name|MUL
expr_stmt|;
break|break;
case|case
name|SLJIT_SMUL
case|:
operator|*
name|inst
operator||=
name|IMUL
expr_stmt|;
break|break;
case|case
name|SLJIT_UDIV
case|:
operator|*
name|inst
operator||=
name|DIV
expr_stmt|;
break|break;
case|case
name|SLJIT_SDIV
case|:
operator|*
name|inst
operator||=
name|IDIV
expr_stmt|;
break|break;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|ENCODE_PREFIX
define|#
directive|define
name|ENCODE_PREFIX
parameter_list|(
name|prefix
parameter_list|)
define|\
value|do { \ 		inst = (sljit_ub*)ensure_buf(compiler, 1 + 1); \ 		FAIL_IF(!inst); \ 		INC_SIZE(1); \ 		*inst = (prefix); \ 	} while (0)
end_define
begin_function
DECL|function|emit_mov_byte
specifier|static
name|sljit_si
name|emit_mov_byte
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|sign
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|dst_r
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|sljit_si
name|work_r
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
operator|&&
operator|!
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* Empty instruction. */
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
return|return
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
name|MOV_r_i32
operator|+
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_i32
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
endif|#
directive|endif
block|}
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BYTE_ARG
operator||
name|EX86_NO_REXW
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm8_i8
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
name|src
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|reg_map
index|[
name|src
index|]
operator|>=
literal|4
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|dst_r
operator|==
name|TMP_REGISTER
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_r
operator|=
name|src
expr_stmt|;
else|#
directive|else
name|dst_r
operator|=
name|src
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
elseif|else
if|if
condition|(
name|src
operator|<=
name|TMP_REGISTER
operator|&&
name|reg_map
index|[
name|src
index|]
operator|>=
literal|4
condition|)
block|{
comment|/* src, dst are registers. */
name|SLJIT_ASSERT
argument_list|(
name|dst
operator|>=
name|SLJIT_SCRATCH_REG1
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
index|[
name|dst
index|]
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|dst
operator|!=
name|src
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|sign
condition|?
name|MOVSX_r_rm8
else|:
name|MOVZX_r_rm8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dst
operator|!=
name|src
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
block|{
comment|/* shl reg, 24 */
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|24
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|SHL
expr_stmt|;
comment|/* sar reg, 24 */
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|24
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|SAR
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BIN_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xff
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
operator|(
name|inst
operator|+
literal|1
operator|)
operator||=
name|AND
expr_stmt|;
block|}
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
endif|#
directive|endif
else|else
block|{
comment|/* src can be memory addr or reg_map[src]< 4 on x86_32 architectures. */
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|sign
condition|?
name|MOVSX_r_rm8
else|:
name|MOVZX_r_rm8
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|dst_r
operator|==
name|TMP_REGISTER
condition|)
block|{
comment|/* Find a non-used register, whose reg_map[src]< 4. */
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_SCRATCH_REG1
condition|)
block|{
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|==
operator|(
name|SLJIT_SCRATCH_REG2
operator|<<
literal|4
operator|)
condition|)
name|work_r
operator|=
name|SLJIT_SCRATCH_REG3
expr_stmt|;
else|else
name|work_r
operator|=
name|SLJIT_SCRATCH_REG2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
operator|(
name|SLJIT_SCRATCH_REG1
operator|<<
literal|4
operator|)
condition|)
name|work_r
operator|=
name|SLJIT_SCRATCH_REG1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_SCRATCH_REG2
condition|)
name|work_r
operator|=
name|SLJIT_SCRATCH_REG3
expr_stmt|;
else|else
name|work_r
operator|=
name|SLJIT_SCRATCH_REG2
expr_stmt|;
block|}
if|if
condition|(
name|work_r
operator|==
name|SLJIT_SCRATCH_REG1
condition|)
block|{
name|ENCODE_PREFIX
argument_list|(
name|XCHG_EAX_r
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|work_r
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|XCHG_r_rm
expr_stmt|;
block|}
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|work_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm8_r8
expr_stmt|;
if|if
condition|(
name|work_r
operator|==
name|SLJIT_SCRATCH_REG1
condition|)
block|{
name|ENCODE_PREFIX
argument_list|(
name|XCHG_EAX_r
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|work_r
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|XCHG_r_rm
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm8_r8
expr_stmt|;
block|}
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_REX
operator||
name|EX86_NO_REXW
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm8_r8
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_mov_half
specifier|static
name|sljit_si
name|emit_mov_half
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|sign
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|dst_r
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
operator|&&
operator|!
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* Empty instruction. */
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
return|return
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
name|MOV_r_i32
operator|+
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_i32
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
endif|#
directive|endif
block|}
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_HALF_ARG
operator||
name|EX86_NO_REXW
operator||
name|EX86_PREF_66
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_i32
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
name|src
operator|<=
name|TMP_REGISTER
condition|)
name|dst_r
operator|=
name|src
expr_stmt|;
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|sign
condition|?
name|MOVSX_r_rm16
else|:
name|MOVZX_r_rm16
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_NO_REXW
operator||
name|EX86_PREF_66
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_r
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_unary
specifier|static
name|sljit_si
name|emit_unary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|opcode
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|opcode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|src
operator|&&
name|dstw
operator|==
name|srcw
condition|)
block|{
comment|/* Same input and output */
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|opcode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|opcode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|opcode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_not_with_flags
specifier|static
name|sljit_si
name|emit_not_with_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|NOT_rm
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|OR_r_rm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|NOT_rm
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|OR_r_rm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|NOT_rm
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|OR_r_rm
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_clz
specifier|static
name|sljit_si
name|emit_clz
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op_flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|dst_r
decl_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|op_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst
operator|==
name|SLJIT_UNUSED
argument_list|)
condition|)
block|{
comment|/* Just set the zero flag. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_F7
expr_stmt|;
operator|*
name|inst
operator||=
name|NOT_rm
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|31
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|!
operator|(
name|op_flags
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|63
else|:
literal|31
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|SHR
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|src
operator|&
name|SLJIT_IMM
argument_list|)
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|BSR_r_rm
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
name|dst_r
operator|=
name|dst
expr_stmt|;
else|else
block|{
comment|/* Find an unused temporary register. */
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|!=
name|SLJIT_SCRATCH_REG1
operator|&&
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
operator|(
name|SLJIT_SCRATCH_REG1
operator|<<
literal|4
operator|)
condition|)
name|dst_r
operator|=
name|SLJIT_SCRATCH_REG1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|!=
name|SLJIT_SCRATCH_REG2
operator|&&
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
operator|(
name|SLJIT_SCRATCH_REG2
operator|<<
literal|4
operator|)
condition|)
name|dst_r
operator|=
name|SLJIT_SCRATCH_REG2
expr_stmt|;
else|else
name|dst_r
operator|=
name|SLJIT_SCRATCH_REG3
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|32
operator|+
literal|31
argument_list|)
expr_stmt|;
else|#
directive|else
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|!
operator|(
name|op_flags
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|64
operator|+
literal|63
else|:
literal|32
operator|+
literal|31
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|mode32
operator|=
name|op_flags
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cpu_has_cmov
operator|==
operator|-
literal|1
condition|)
name|get_cpu_features
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpu_has_cmov
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|CMOVNE_r_rm
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|JE_i8
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|dst_r
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
else|#
directive|else
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|JE_i8
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|3
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
operator|(
name|reg_map
index|[
name|dst_r
index|]
operator|>=
literal|8
condition|?
name|REX_R
else|:
literal|0
operator|)
operator||
operator|(
name|reg_map
index|[
name|TMP_REGISTER
index|]
operator|>=
literal|8
condition|?
name|REX_B
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_lmap
index|[
name|dst_r
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_lmap
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BIN_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|31
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_BIN_INS
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|!
operator|(
name|op_flags
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|63
else|:
literal|31
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
operator|(
name|inst
operator|+
literal|1
operator|)
operator||=
name|XOR
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|XCHG_r_rm
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|update
init|=
literal|0
decl_stmt|;
name|sljit_si
name|op_flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|sljit_si
name|dst_is_ereg
init|=
literal|0
decl_stmt|;
name|sljit_si
name|src_is_ereg
init|=
literal|0
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|src_is_ereg
value|0
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
name|dst_is_ereg
operator|=
literal|1
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|,
name|src_is_ereg
operator|=
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
name|op_flags
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_P
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|op_flags
operator|&
name|SLJIT_INT_OP
condition|)
block|{
if|if
condition|(
name|src
operator|<=
name|TMP_REGISTER
operator|&&
name|src
operator|==
name|dst
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_CAST_NEEDED
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOV_UI
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_MOVU_SI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOVU_UI
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_UI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOV_SI
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_MOVU_UI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOVU_SI
expr_stmt|;
endif|#
directive|endif
block|}
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|SLJIT_MOV
operator|+
literal|8
operator|==
name|SLJIT_MOVU
argument_list|,
name|movu_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOVU
condition|)
block|{
name|update
operator|=
literal|1
expr_stmt|;
name|op
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_MOV_UB
case|:
name|srcw
operator|=
operator|(
name|sljit_ub
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SB
case|:
name|srcw
operator|=
operator|(
name|sljit_sb
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UH
case|:
name|srcw
operator|=
operator|(
name|sljit_uh
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SH
case|:
name|srcw
operator|=
operator|(
name|sljit_sh
operator|)
name|srcw
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
case|case
name|SLJIT_MOV_UI
case|:
name|srcw
operator|=
operator|(
name|sljit_ui
operator|)
name|srcw
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SI
case|:
name|srcw
operator|=
operator|(
name|sljit_si
operator|)
name|srcw
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst_is_ereg
argument_list|)
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|update
argument_list|)
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|!
name|src_is_ereg
operator|&&
operator|(
name|src
operator|&
literal|0xf
operator|)
operator|&&
operator|(
name|srcw
operator|!=
literal|0
operator|||
operator|(
name|src
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src
operator|&
literal|0xf
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|LEA_r_m
expr_stmt|;
name|src
operator|&=
name|SLJIT_MEM
operator||
literal|0xf
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst_is_ereg
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|||
name|op
operator|==
name|SLJIT_MOV_UI
operator|||
name|op
operator|==
name|SLJIT_MOV_SI
operator|||
name|op
operator|==
name|SLJIT_MOV_P
operator|)
operator|||
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|dst
operator|==
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_P
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UB
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_byte
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SB
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_byte
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_UH
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_half
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SH
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_half
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
case|case
name|SLJIT_MOV_UI
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_int
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MOV_SI
case|:
name|FAIL_IF
argument_list|(
name|emit_mov_int
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst_is_ereg
argument_list|)
operator|&&
name|dst
operator|==
name|TMP_REGISTER
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|update
argument_list|)
operator|&&
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|dst
operator|&
literal|0xf
operator|)
operator|&&
operator|(
name|dstw
operator|!=
literal|0
operator|||
operator|(
name|dst
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
operator|&
literal|0xf
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|LEA_r_m
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op_flags
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_NOT
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op_flags
operator|&
name|SLJIT_SET_E
argument_list|)
condition|)
return|return
name|emit_not_with_flags
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
return|return
name|emit_unary
argument_list|(
name|compiler
argument_list|,
name|NOT_rm
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NEG
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op_flags
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_unary
argument_list|(
name|compiler
argument_list|,
name|NEG_rm
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_CLZ
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op_flags
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_clz
argument_list|(
name|compiler
argument_list|,
name|op_flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
DECL|macro|src_is_ereg
undef|#
directive|undef
name|src_is_ereg
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
end_if
begin_define
DECL|macro|BINARY_IMM
define|#
directive|define
name|BINARY_IMM
parameter_list|(
name|op_imm
parameter_list|,
name|op_mr
parameter_list|,
name|immw
parameter_list|,
name|arg
parameter_list|,
name|argw
parameter_list|)
define|\
value|if (IS_HALFWORD(immw) || compiler->mode32) { \ 		inst = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, immw, arg, argw); \ 		FAIL_IF(!inst); \ 		*(inst + 1) |= (op_imm); \ 	} \ 	else { \ 		FAIL_IF(emit_load_imm64(compiler, TMP_REG2, immw)); \ 		inst = emit_x86_instruction(compiler, 1, TMP_REG2, 0, arg, argw); \ 		FAIL_IF(!inst); \ 		*inst = (op_mr); \ 	}
end_define
begin_define
DECL|macro|BINARY_EAX_IMM
define|#
directive|define
name|BINARY_EAX_IMM
parameter_list|(
name|op_eax_imm
parameter_list|,
name|immw
parameter_list|)
define|\
value|FAIL_IF(emit_do_imm32(compiler, (!compiler->mode32) ? REX_W : 0, (op_eax_imm), immw))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|BINARY_IMM
define|#
directive|define
name|BINARY_IMM
parameter_list|(
name|op_imm
parameter_list|,
name|op_mr
parameter_list|,
name|immw
parameter_list|,
name|arg
parameter_list|,
name|argw
parameter_list|)
define|\
value|inst = emit_x86_instruction(compiler, 1 | EX86_BIN_INS, SLJIT_IMM, immw, arg, argw); \ 	FAIL_IF(!inst); \ 	*(inst + 1) |= (op_imm);
end_define
begin_define
DECL|macro|BINARY_EAX_IMM
define|#
directive|define
name|BINARY_EAX_IMM
parameter_list|(
name|op_eax_imm
parameter_list|,
name|immw
parameter_list|)
define|\
value|FAIL_IF(emit_do_imm(compiler, (op_eax_imm), immw))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|emit_cum_binary
specifier|static
name|sljit_si
name|emit_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_SCRATCH_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_SCRATCH_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|op_eax_imm
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|<=
name|TMP_REGISTER
condition|)
block|{
comment|/* Special exception for sljit_emit_op_flags. */
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_mr
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_mr
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* Only for cumulative operations. */
if|if
condition|(
name|dst
operator|==
name|src2
operator|&&
name|dstw
operator|==
name|src2w
condition|)
block|{
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_SCRATCH_REG1
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_SCRATCH_REG1
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|op_eax_imm
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_mr
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_mr
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* General version. */
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This version requires less memory writing. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_non_cum_binary
specifier|static
name|sljit_si
name|emit_non_cum_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|op_rm
parameter_list|,
name|sljit_ub
name|op_mr
parameter_list|,
name|sljit_ub
name|op_imm
parameter_list|,
name|sljit_ub
name|op_eax_imm
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_SCRATCH_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dst
operator|==
name|SLJIT_SCRATCH_REG1
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|op_eax_imm
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_mr
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_mr
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* General version. */
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
operator|&&
name|dst
operator|!=
name|src2
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This version requires less memory writing. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|op_imm
argument_list|,
name|op_mr
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|op_rm
expr_stmt|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_mul
specifier|static
name|sljit_si
name|emit_mul
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|dst_r
decl_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
comment|/* Register destination. */
if|if
condition|(
name|dst_r
operator|==
name|src1
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst_r
operator|==
name|src2
operator|&&
operator|!
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|src2
operator|=
name|dst_r
expr_stmt|;
name|src2w
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|src1w
operator|<=
literal|127
operator|&&
name|src1w
operator|>=
operator|-
literal|128
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm_i8
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
operator|(
name|sljit_sb
operator|)
name|src1w
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm_i32
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|inst
operator|=
name|src1w
expr_stmt|;
block|}
else|#
directive|else
elseif|else
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm_i32
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
operator|(
name|sljit_si
operator|)
name|src1w
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|!=
name|src2
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
comment|/* Note: src1 is NOT immediate. */
if|if
condition|(
name|src2w
operator|<=
literal|127
operator|&&
name|src2w
operator|>=
operator|-
literal|128
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm_i8
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
operator|(
name|sljit_sb
operator|)
name|src2w
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm_i32
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|inst
operator|=
name|src2w
expr_stmt|;
block|}
else|#
directive|else
elseif|else
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm_i32
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
operator|(
name|sljit_si
operator|)
name|src2w
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|!=
name|src1
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Neither argument is immediate. */
if|if
condition|(
name|ADDRESSING_DEPENDS_ON
argument_list|(
name|src2
argument_list|,
name|dst_r
argument_list|)
condition|)
name|dst_r
operator|=
name|TMP_REGISTER
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|IMUL_r_rm
expr_stmt|;
block|}
if|if
condition|(
name|dst_r
operator|==
name|TMP_REGISTER
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_lea_binary
specifier|static
name|sljit_si
name|emit_lea_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|dst_r
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
comment|/* These cases better be left to handled by normal way. */
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
if|if
condition|(
name|dst
operator|==
name|src2
operator|&&
name|dstw
operator|==
name|src2w
condition|)
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
name|src1
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|if
condition|(
name|src2
operator|<=
name|TMP_REGISTER
operator|||
name|src2
operator|==
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|src1
argument_list|,
name|src2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|LEA_r_m
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src1
argument_list|)
argument_list|,
operator|(
name|sljit_si
operator|)
name|src2w
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src1
argument_list|)
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|LEA_r_m
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src2
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src2
argument_list|)
argument_list|,
operator|(
name|sljit_si
operator|)
name|src1w
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|src2
argument_list|)
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|LEA_r_m
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
condition|)
block|{
if|if
condition|(
name|dst_r
operator|==
name|TMP_REGISTER
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
DECL|function|emit_cmp_binary
specifier|static
name|sljit_si
name|emit_cmp_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|src1
operator|==
name|SLJIT_SCRATCH_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|src1
operator|==
name|SLJIT_SCRATCH_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|CMP_EAX_i32
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src1
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|BINARY_IMM
argument_list|(
name|CMP
argument_list|,
name|CMP_rm_r
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|CMP_r_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src2
operator|<=
name|TMP_REGISTER
operator|&&
operator|!
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|CMP_rm_r
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_REGISTER
expr_stmt|;
name|src1w
operator|=
literal|0
expr_stmt|;
block|}
name|BINARY_IMM
argument_list|(
name|CMP
argument_list|,
name|CMP_rm_r
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|CMP_r_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_test_binary
specifier|static
name|sljit_si
name|emit_test_binary
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|src1
operator|==
name|SLJIT_SCRATCH_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|src1
operator|==
name|SLJIT_SCRATCH_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|>
literal|127
operator|||
name|src2w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|TEST_EAX_i32
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|src2
operator|==
name|SLJIT_SCRATCH_REG1
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
operator|&&
operator|(
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|src2
operator|==
name|SLJIT_SCRATCH_REG1
operator|&&
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src1w
operator|>
literal|127
operator|||
name|src1w
operator|<
operator|-
literal|128
operator|)
condition|)
block|{
endif|#
directive|endif
name|BINARY_EAX_IMM
argument_list|(
name|TEST_EAX_i32
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src1
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|||
name|compiler
operator|->
name|mode32
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|GROUP_F7
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|TEST_rm_r
expr_stmt|;
block|}
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|GROUP_F7
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|TEST_rm_r
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|src2
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src1w
argument_list|)
operator|||
name|compiler
operator|->
name|mode32
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|GROUP_F7
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|TEST_rm_r
expr_stmt|;
block|}
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|GROUP_F7
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|src2
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|TEST_rm_r
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|IS_HALFWORD
argument_list|(
name|src2w
argument_list|)
operator|||
name|compiler
operator|->
name|mode32
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|GROUP_F7
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|TEST_rm_r
expr_stmt|;
block|}
else|#
directive|else
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|GROUP_F7
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|TEST_rm_r
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_shift
specifier|static
name|sljit_si
name|emit_shift
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|mode
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|||
operator|(
name|src2
operator|==
name|SLJIT_PREF_SHIFT_REG
operator|)
condition|)
block|{
if|if
condition|(
name|dst
operator|==
name|src1
operator|&&
name|dstw
operator|==
name|src1w
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|SLJIT_PREF_SHIFT_REG
operator|&&
name|src2
operator|==
name|SLJIT_PREF_SHIFT_REG
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|dst
operator|==
name|SLJIT_PREF_SHIFT_REG
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
operator|&&
name|dst
operator|!=
name|src2
operator|&&
operator|!
name|ADDRESSING_DEPENDS_ON
argument_list|(
name|src2
argument_list|,
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This case is really difficult, since ecx itself may used for 		   addressing, and we must ensure to work even in that case. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* [esp+0] contains the flags. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
operator||
name|EX86_SHIFT_INS
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator||=
name|mode
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|SLJIT_PREF_SHIFT_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_shift_with_flags
specifier|static
name|sljit_si
name|emit_shift_with_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|mode
parameter_list|,
name|sljit_si
name|set_flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* The CPU does not set flags if the shift count is 0. */
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
operator|(
name|src2w
operator|&
literal|0x3f
operator|)
operator|!=
literal|0
operator|||
operator|(
name|compiler
operator|->
name|mode32
operator|&&
operator|(
name|src2w
operator|&
literal|0x1f
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|src2w
operator|&
literal|0x1f
operator|)
operator|!=
literal|0
condition|)
return|return
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|set_flags
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
return|;
comment|/* OR dst, src, 0 */
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
name|OR_r_rm
argument_list|,
name|OR_rm_r
argument_list|,
name|OR
argument_list|,
name|OR_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|set_flags
condition|)
return|return
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_cmp_binary
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_shift
argument_list|(
name|compiler
argument_list|,
name|mode
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
return|return
name|emit_cmp_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
name|op
operator|&
name|SLJIT_INT_OP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_MUL
condition|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|emit_lea_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
return|return
name|compiler
operator|->
name|error
return|;
block|}
else|else
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
name|ADD_r_rm
argument_list|,
name|ADD_rm_r
argument_list|,
name|ADD
argument_list|,
name|ADD_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_ADDC
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
comment|/* C flag must be restored. */
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
name|ADC_r_rm
argument_list|,
name|ADC_rm_r
argument_list|,
name|ADC
argument_list|,
name|ADC_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|emit_lea_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|src2w
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
return|return
name|compiler
operator|->
name|error
return|;
block|}
else|else
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
operator|&&
operator|!
name|compiler
operator|->
name|flags_saved
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|emit_cmp_binary
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
return|return
name|emit_non_cum_binary
argument_list|(
name|compiler
argument_list|,
name|SUB_r_rm
argument_list|,
name|SUB_rm_r
argument_list|,
name|SUB
argument_list|,
name|SUB_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUBC
case|:
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
comment|/* C flag must be restored. */
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_save_flags
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
return|return
name|emit_non_cum_binary
argument_list|(
name|compiler
argument_list|,
name|SBB_r_rm
argument_list|,
name|SBB_rm_r
argument_list|,
name|SBB
argument_list|,
name|SBB_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_MUL
case|:
return|return
name|emit_mul
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|emit_test_binary
argument_list|(
name|compiler
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
name|AND_r_rm
argument_list|,
name|AND_rm_r
argument_list|,
name|AND
argument_list|,
name|AND_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_OR
case|:
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
name|OR_r_rm
argument_list|,
name|OR_rm_r
argument_list|,
name|OR
argument_list|,
name|OR_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_XOR
case|:
return|return
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
name|XOR_r_rm
argument_list|,
name|XOR_rm_r
argument_list|,
name|XOR
argument_list|,
name|XOR_EAX_i32
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SHL
case|:
return|return
name|emit_shift_with_flags
argument_list|(
name|compiler
argument_list|,
name|SHL
argument_list|,
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_LSHR
case|:
return|return
name|emit_shift_with_flags
argument_list|(
name|compiler
argument_list|,
name|SHR
argument_list|,
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_ASHR
case|:
return|return
name|emit_shift_with_flags
argument_list|(
name|compiler
argument_list|,
name|SAR
argument_list|,
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|check_sljit_get_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|if
condition|(
name|reg
operator|==
name|SLJIT_TEMPORARY_EREG1
operator|||
name|reg
operator|==
name|SLJIT_TEMPORARY_EREG2
operator|||
name|reg
operator|==
name|SLJIT_SAVED_EREG1
operator|||
name|reg
operator|==
name|SLJIT_SAVED_EREG2
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
return|return
name|reg_map
index|[
name|reg
index|]
return|;
block|}
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_custom
argument_list|(
name|compiler
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<
literal|16
argument_list|)
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|SLJIT_MEMMOVE
argument_list|(
name|inst
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* --------------------------------------------------------------------- */
comment|/*  Floating point operators                                             */
comment|/* --------------------------------------------------------------------- */
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
comment|/* Alignment + 2 * 16 bytes. */
DECL|variable|sse2_data
specifier|static
name|sljit_si
name|sse2_data
index|[
literal|3
operator|+
operator|(
literal|4
operator|+
literal|4
operator|)
operator|*
literal|2
index|]
decl_stmt|;
DECL|variable|sse2_buffer
specifier|static
name|sljit_si
modifier|*
name|sse2_buffer
decl_stmt|;
DECL|function|init_compiler
specifier|static
name|void
name|init_compiler
parameter_list|(
name|void
parameter_list|)
block|{
name|sse2_buffer
operator|=
operator|(
name|sljit_si
operator|*
operator|)
operator|(
operator|(
operator|(
name|sljit_uw
operator|)
name|sse2_data
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
operator|)
expr_stmt|;
comment|/* Single precision constants. */
name|sse2_buffer
index|[
literal|0
index|]
operator|=
literal|0x80000000
expr_stmt|;
name|sse2_buffer
index|[
literal|4
index|]
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/* Double precision constants. */
name|sse2_buffer
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|sse2_buffer
index|[
literal|9
index|]
operator|=
literal|0x80000000
expr_stmt|;
name|sse2_buffer
index|[
literal|12
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|sse2_buffer
index|[
literal|13
index|]
operator|=
literal|0x7fffffff
expr_stmt|;
block|}
endif|#
directive|endif
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
if|#
directive|if
operator|(
name|defined
name|SLJIT_DETECT_SSE2
operator|&&
name|SLJIT_DETECT_SSE2
operator|)
if|if
condition|(
name|cpu_has_sse2
operator|==
operator|-
literal|1
condition|)
name|get_cpu_features
argument_list|()
expr_stmt|;
return|return
name|cpu_has_sse2
return|;
else|#
directive|else
comment|/* SLJIT_DETECT_SSE2 */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* SLJIT_DETECT_SSE2 */
else|#
directive|else
comment|/* SLJIT_SSE2 */
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
DECL|function|emit_sse2
specifier|static
name|sljit_si
name|emit_sse2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|opcode
parameter_list|,
name|sljit_si
name|single
parameter_list|,
name|sljit_si
name|xmm1
parameter_list|,
name|sljit_si
name|xmm2
parameter_list|,
name|sljit_sw
name|xmm2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
operator||
operator|(
name|single
condition|?
name|EX86_PREF_F3
else|:
name|EX86_PREF_F2
operator|)
operator||
name|EX86_SSE2
argument_list|,
name|xmm1
argument_list|,
literal|0
argument_list|,
name|xmm2
argument_list|,
name|xmm2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|opcode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_sse2_logic
specifier|static
name|sljit_si
name|emit_sse2_logic
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|opcode
parameter_list|,
name|sljit_si
name|pref66
parameter_list|,
name|sljit_si
name|xmm1
parameter_list|,
name|sljit_si
name|xmm2
parameter_list|,
name|sljit_sw
name|xmm2w
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|2
operator||
operator|(
name|pref66
condition|?
name|EX86_PREF_66
else|:
literal|0
operator|)
operator||
name|EX86_SSE2
argument_list|,
name|xmm1
argument_list|,
literal|0
argument_list|,
name|xmm2
argument_list|,
name|xmm2w
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|=
name|opcode
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|emit_sse2_load
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_sse2_load
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|single
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
return|return
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
name|MOVSD_x_xm
argument_list|,
name|single
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
DECL|function|emit_sse2_store
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_sse2_store
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|single
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|)
block|{
return|return
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
name|MOVSD_xm_x
argument_list|,
name|single
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
block|}
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CMPD
condition|)
block|{
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dst
operator|<=
name|SLJIT_FLOAT_REG6
condition|)
name|dst_r
operator|=
name|dst
expr_stmt|;
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|emit_sse2_logic
argument_list|(
name|compiler
argument_list|,
name|UCOMISD_x_xm
argument_list|,
operator|!
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
if|if
condition|(
name|op
operator|==
name|SLJIT_MOVD
condition|)
block|{
if|if
condition|(
name|dst
operator|<=
name|SLJIT_FLOAT_REG6
condition|)
return|return
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
if|if
condition|(
name|src
operator|<=
name|SLJIT_FLOAT_REG6
condition|)
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|)
return|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|TMP_FREG
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_FREG
argument_list|)
return|;
block|}
if|if
condition|(
name|dst
operator|>=
name|SLJIT_FLOAT_REG1
operator|&&
name|dst
operator|<=
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|src
condition|)
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_NEGD
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2_logic
argument_list|(
name|compiler
argument_list|,
name|XORPD_x_xm
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
name|SLJIT_MEM0
argument_list|()
argument_list|,
call|(
name|sljit_sw
call|)
argument_list|(
name|op
operator|&
name|SLJIT_SINGLE_OP
condition|?
name|sse2_buffer
else|:
name|sse2_buffer
operator|+
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_ABSD
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2_logic
argument_list|(
name|compiler
argument_list|,
name|ANDPD_x_xm
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
name|SLJIT_MEM0
argument_list|()
argument_list|,
call|(
name|sljit_sw
call|)
argument_list|(
name|op
operator|&
name|SLJIT_SINGLE_OP
condition|?
name|sse2_buffer
operator|+
literal|4
else|:
name|sse2_buffer
operator|+
literal|12
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_r
operator|==
name|TMP_FREG
condition|)
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_FREG
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dst
operator|<=
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|src1
condition|)
empty_stmt|;
comment|/* Do nothing here. */
elseif|else
if|if
condition|(
name|dst
operator|==
name|src2
operator|&&
operator|(
name|op
operator|==
name|SLJIT_ADDD
operator|||
name|op
operator|==
name|SLJIT_MULD
operator|)
condition|)
block|{
comment|/* Swap arguments. */
name|src2
operator|=
name|src1
expr_stmt|;
name|src2w
operator|=
name|src1w
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|TMP_FREG
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dst_r
operator|=
name|TMP_FREG
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_sse2_load
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|TMP_FREG
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADDD
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
name|ADDSD_x_xm
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_SUBD
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
name|SUBSD_x_xm
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MULD
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
name|MULSD_x_xm
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DIVD
case|:
name|FAIL_IF
argument_list|(
name|emit_sse2
argument_list|(
name|compiler
argument_list|,
name|DIVSD_x_xm
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_r
operator|==
name|TMP_FREG
condition|)
return|return
name|emit_sse2_store
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_FREG
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
else|#
directive|else
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
comment|/* Should cause an assertion fail. */
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_UNSUPPORTED
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
comment|/* Should cause an assertion fail. */
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_UNSUPPORTED
expr_stmt|;
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
endif|#
directive|endif
comment|/* --------------------------------------------------------------------- */
comment|/*  Conditional instructions                                             */
comment|/* --------------------------------------------------------------------- */
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
comment|/* We should restore the flags before the label, 	   since other taken jumps has their own flags as well. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|label
return|;
block|}
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|&
literal|0xff
operator|)
operator|<=
name|SLJIT_JUMP
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
block|}
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL1
condition|)
name|PTR_FAIL_IF
argument_list|(
name|call_with_args
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Worst case size. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|compiler
operator|->
name|size
operator|+=
operator|(
name|type
operator|>=
name|SLJIT_JUMP
operator|)
condition|?
literal|5
else|:
literal|6
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|size
operator|+=
operator|(
name|type
operator|>=
name|SLJIT_JUMP
operator|)
condition|?
operator|(
literal|10
operator|+
literal|3
operator|)
else|:
operator|(
literal|2
operator|+
literal|10
operator|+
literal|3
operator|)
expr_stmt|;
endif|#
directive|endif
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF_NULL
argument_list|(
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|type
operator|+
literal|4
expr_stmt|;
return|return
name|jump
return|;
block|}
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|<=
name|SLJIT_JUMP
condition|)
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL1
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
if|if
condition|(
name|src
operator|==
name|SLJIT_SCRATCH_REG3
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|==
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator|&&
name|type
operator|>=
name|SLJIT_CALL3
condition|)
name|srcw
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
operator|&&
name|defined
argument_list|(
name|_WIN64
argument_list|)
if|if
condition|(
name|src
operator|==
name|SLJIT_SCRATCH_REG3
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REGISTER
expr_stmt|;
block|}
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|call_with_args
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|==
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF_NULL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
comment|/* Worst case size. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
name|compiler
operator|->
name|size
operator|+=
literal|5
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|size
operator|+=
literal|10
operator|+
literal|3
expr_stmt|;
endif|#
directive|endif
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF_NULL
argument_list|(
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|type
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
comment|/* REX_W is not necessary (src is not immediate). */
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_FF
expr_stmt|;
operator|*
name|inst
operator||=
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
operator|)
condition|?
name|CALL_rm
else|:
name|JMP_rm
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_ub
name|cond_set
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|sljit_si
name|reg
decl_stmt|;
else|#
directive|else
comment|/* CHECK_EXTRA_REGS migh overwrite these values. */
name|sljit_si
name|dst_save
init|=
name|dst
decl_stmt|;
name|sljit_sw
name|dstw_save
init|=
name|dstw
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_flags
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|flags_saved
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|emit_restore_flags
argument_list|(
name|compiler
argument_list|,
name|op
operator|&
name|SLJIT_KEEP_FLAGS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* setcc = jcc + 0x10. */
name|cond_set
operator|=
name|get_jump_code
argument_list|(
name|type
argument_list|)
operator|+
literal|0x10
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|reg
operator|=
operator|(
name|op
operator|==
name|SLJIT_MOV
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Set low register to conditional flag. */
operator|*
name|inst
operator|++
operator|=
operator|(
name|reg_map
index|[
name|reg
index|]
operator|<=
literal|7
operator|)
condition|?
name|REX
else|:
name|REX_B
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|reg_lmap
index|[
name|reg
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
operator|(
name|reg_map
index|[
name|reg
index|]
operator|<=
literal|7
condition|?
literal|0
else|:
operator|(
name|REX_B
operator||
name|REX_R
operator|)
operator|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOVZX_r_rm8
expr_stmt|;
operator|*
name|inst
operator|=
name|MOD_REG
operator||
operator|(
name|reg_lmap
index|[
name|reg
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_lmap
index|[
name|reg
index|]
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|TMP_REGISTER
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<
name|SLJIT_ADD
condition|)
block|{
name|compiler
operator|->
name|mode32
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SLJIT_MOV
expr_stmt|;
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
else|#
directive|else
comment|/* SLJIT_CONFIG_X86_64 */
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<
name|SLJIT_ADD
operator|&&
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_map
index|[
name|dst
index|]
operator|<=
literal|4
condition|)
block|{
comment|/* Low byte is accessible. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|3
operator|+
literal|3
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|3
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* Set low byte to conditional flag. */
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|reg_map
index|[
name|dst
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOVZX_r_rm8
expr_stmt|;
operator|*
name|inst
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|dst
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|dst
index|]
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* Low byte is not accessible. */
if|if
condition|(
name|cpu_has_cmov
operator|==
operator|-
literal|1
condition|)
name|get_cpu_features
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpu_has_cmov
condition|)
block|{
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* a xor reg, reg operation would overwrite the flags. */
name|EMIT_MOV
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
comment|/* cmovcc = setcc - 0x50. */
operator|*
name|inst
operator|++
operator|=
name|cond_set
operator|-
literal|0x50
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|dst
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
operator|+
literal|3
operator|+
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
operator|+
literal|3
operator|+
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|XCHG_EAX_r
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
comment|/* Set al to conditional flag. */
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
literal|0
comment|/* eax */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOVZX_r_rm8
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|dst
index|]
operator|<<
literal|3
operator|)
operator||
literal|0
comment|/* eax */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|XCHG_EAX_r
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* Set TMP_REGISTER to the bit. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
operator|+
literal|3
operator|+
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
operator|+
literal|3
operator|+
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|XCHG_EAX_r
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
comment|/* Set al to conditional flag. */
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|cond_set
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
literal|0
comment|/* eax */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOVZX_r_rm8
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
literal|0
operator|<<
literal|3
operator|)
comment|/* eax */
operator||
literal|0
comment|/* eax */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|XCHG_EAX_r
operator|+
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|<
name|SLJIT_ADD
condition|)
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst_save
argument_list|,
name|dstw_save
argument_list|,
name|dst_save
argument_list|,
name|dstw_save
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
comment|/* SLJIT_CONFIG_X86_64 */
block|}
DECL|function|sljit_get_local_base
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_get_local_base
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|NOT_HALFWORD
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REGISTER
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|SLJIT_ASSERT
argument_list|(
name|emit_lea_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
argument_list|)
expr_stmt|;
return|return
name|compiler
operator|->
name|error
return|;
else|#
directive|else
return|return
name|emit_lea_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
return|return
name|emit_lea_binary
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|offset
argument_list|)
return|;
return|return
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|sljit_si
name|reg
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
operator|(
name|dst
operator|<=
name|TMP_REGISTER
operator|)
condition|?
name|dst
else|:
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|init_value
argument_list|)
condition|)
return|return
name|NULL
return|;
else|#
directive|else
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
name|dst
operator|=
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
name|init_value
argument_list|)
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
if|if
condition|(
name|reg
operator|==
name|TMP_REGISTER
operator|&&
name|dst
operator|!=
name|SLJIT_UNUSED
condition|)
if|if
condition|(
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REGISTER
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
return|return
name|const_
return|;
block|}
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|addr
operator|=
name|new_addr
operator|-
operator|(
name|addr
operator|+
literal|4
operator|)
expr_stmt|;
else|#
directive|else
operator|*
operator|(
name|sljit_uw
operator|*
operator|)
name|addr
operator|=
name|new_addr
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
block|{
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|addr
operator|=
name|new_constant
expr_stmt|;
block|}
end_function
end_unit
