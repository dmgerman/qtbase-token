begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/*    This file contains a simple executable memory allocator     It is assumed, that executable code blocks are usually medium (or sometimes    large) memory blocks, and the allocator is not too frequently called (less    optimized than other allocators). Thus, using it as a generic allocator is    not suggested.     How does it work:      Memory is allocated in continuous memory areas called chunks by alloc_chunk()      Chunk format:      [ block ][ block ] ... [ block ][ block terminator ]     All blocks and the block terminator is started with block_header. The block    header contains the size of the previous and the next block. These sizes    can also contain special values.      Block size:        0 - The block is a free_block, with a different size member.        1 - The block is a block terminator.        n - The block is used at the moment, and the value contains its size.      Previous block size:        0 - This is the first block of the memory chunk.        n - The size of the previous block.     Using these size values we can go forward or backward on the block chain.    The unused blocks are stored in a chain list pointed by free_blocks. This    list is useful if we need to find a suitable memory area when the allocator    is called.     When a block is freed, the new free block is connected to its adjacent free    blocks if possible.       [ free block ][ used block ][ free block ]    and "used block" is freed, the three blocks are connected together:      [           one big free block           ] */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  System (OS) functions                                                */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* 64 KByte. */
end_comment
begin_define
DECL|macro|CHUNK_SIZE
define|#
directive|define
name|CHUNK_SIZE
value|0x10000
end_define
begin_comment
comment|/*    alloc_chunk / free_chunk :      * allocate executable system memory chunks      * the size is always divisible by CHUNK_SIZE    allocator_grab_lock / allocator_release_lock :      * make the allocator thread safe      * can be empty if the OS (or the application) does not support threading      * only the allocator requires this lock, sljit is fully thread safe        as it only uses local variables */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef
begin_function
DECL|function|alloc_chunk
specifier|static
name|SLJIT_INLINE
name|void
modifier|*
name|alloc_chunk
parameter_list|(
name|sljit_uw
name|size
parameter_list|)
block|{
return|return
name|VirtualAlloc
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|MEM_COMMIT
operator||
name|MEM_RESERVE
argument_list|,
name|PAGE_EXECUTE_READWRITE
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|free_chunk
specifier|static
name|SLJIT_INLINE
name|void
name|free_chunk
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|sljit_uw
name|size
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|VirtualFree
argument_list|(
name|chunk
argument_list|,
literal|0
argument_list|,
name|MEM_RELEASE
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|alloc_chunk
specifier|static
name|SLJIT_INLINE
name|void
modifier|*
name|alloc_chunk
parameter_list|(
name|sljit_uw
name|size
parameter_list|)
block|{
name|void
modifier|*
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|MAP_ANON
name|retval
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dev_zero
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|open_dev_zero
argument_list|()
condition|)
return|return
name|NULL
return|;
block|}
name|retval
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|dev_zero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|retval
operator|!=
name|MAP_FAILED
operator|)
condition|?
name|retval
else|:
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|free_chunk
specifier|static
name|SLJIT_INLINE
name|void
name|free_chunk
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|sljit_uw
name|size
parameter_list|)
block|{
name|munmap
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Common functions                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|CHUNK_MASK
define|#
directive|define
name|CHUNK_MASK
value|(~(CHUNK_SIZE - 1))
end_define
begin_struct
DECL|struct|block_header
struct|struct
name|block_header
block|{
DECL|member|size
name|sljit_uw
name|size
decl_stmt|;
DECL|member|prev_size
name|sljit_uw
name|prev_size
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|free_block
struct|struct
name|free_block
block|{
DECL|member|header
name|struct
name|block_header
name|header
decl_stmt|;
DECL|member|next
name|struct
name|free_block
modifier|*
name|next
decl_stmt|;
DECL|member|prev
name|struct
name|free_block
modifier|*
name|prev
decl_stmt|;
DECL|member|size
name|sljit_uw
name|size
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|AS_BLOCK_HEADER
define|#
directive|define
name|AS_BLOCK_HEADER
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|)
define|\
value|((struct block_header*)(((sljit_ub*)base) + offset))
end_define
begin_define
DECL|macro|AS_FREE_BLOCK
define|#
directive|define
name|AS_FREE_BLOCK
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|)
define|\
value|((struct free_block*)(((sljit_ub*)base) + offset))
end_define
begin_define
DECL|macro|MEM_START
define|#
directive|define
name|MEM_START
parameter_list|(
name|base
parameter_list|)
value|((void*)(((sljit_ub*)base) + sizeof(struct block_header)))
end_define
begin_define
DECL|macro|ALIGN_SIZE
define|#
directive|define
name|ALIGN_SIZE
parameter_list|(
name|size
parameter_list|)
value|(((size) + sizeof(struct block_header) + 7)& ~7)
end_define
begin_decl_stmt
DECL|variable|free_blocks
specifier|static
name|struct
name|free_block
modifier|*
name|free_blocks
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allocated_size
specifier|static
name|sljit_uw
name|allocated_size
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|total_size
specifier|static
name|sljit_uw
name|total_size
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|sljit_insert_free_block
specifier|static
name|SLJIT_INLINE
name|void
name|sljit_insert_free_block
parameter_list|(
name|struct
name|free_block
modifier|*
name|free_block
parameter_list|,
name|sljit_uw
name|size
parameter_list|)
block|{
name|free_block
operator|->
name|header
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|free_block
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|free_block
operator|->
name|next
operator|=
name|free_blocks
expr_stmt|;
name|free_block
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|free_blocks
condition|)
name|free_blocks
operator|->
name|prev
operator|=
name|free_block
expr_stmt|;
name|free_blocks
operator|=
name|free_block
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_remove_free_block
specifier|static
name|SLJIT_INLINE
name|void
name|sljit_remove_free_block
parameter_list|(
name|struct
name|free_block
modifier|*
name|free_block
parameter_list|)
block|{
if|if
condition|(
name|free_block
operator|->
name|next
condition|)
name|free_block
operator|->
name|next
operator|->
name|prev
operator|=
name|free_block
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|free_block
operator|->
name|prev
condition|)
name|free_block
operator|->
name|prev
operator|->
name|next
operator|=
name|free_block
operator|->
name|next
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|free_blocks
operator|==
name|free_block
argument_list|)
expr_stmt|;
name|free_blocks
operator|=
name|free_block
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sljit_malloc_exec
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_malloc_exec
parameter_list|(
name|sljit_uw
name|size
parameter_list|)
block|{
name|struct
name|block_header
modifier|*
name|header
decl_stmt|;
name|struct
name|block_header
modifier|*
name|next_header
decl_stmt|;
name|struct
name|free_block
modifier|*
name|free_block
decl_stmt|;
name|sljit_uw
name|chunk_size
decl_stmt|;
name|allocator_grab_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|free_block
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|free_block
argument_list|)
expr_stmt|;
name|size
operator|=
name|ALIGN_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|free_block
operator|=
name|free_blocks
expr_stmt|;
while|while
condition|(
name|free_block
condition|)
block|{
if|if
condition|(
name|free_block
operator|->
name|size
operator|>=
name|size
condition|)
block|{
name|chunk_size
operator|=
name|free_block
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|>
name|size
operator|+
literal|64
condition|)
block|{
comment|/* We just cut a block from the end of the free block. */
name|chunk_size
operator|-=
name|size
expr_stmt|;
name|free_block
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|header
operator|=
name|AS_BLOCK_HEADER
argument_list|(
name|free_block
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|header
operator|->
name|prev_size
operator|=
name|chunk_size
expr_stmt|;
name|AS_BLOCK_HEADER
argument_list|(
name|header
argument_list|,
name|size
argument_list|)
operator|->
name|prev_size
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|sljit_remove_free_block
argument_list|(
name|free_block
argument_list|)
expr_stmt|;
name|header
operator|=
operator|(
expr|struct
name|block_header
operator|*
operator|)
name|free_block
expr_stmt|;
name|size
operator|=
name|chunk_size
expr_stmt|;
block|}
name|allocated_size
operator|+=
name|size
expr_stmt|;
name|header
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|allocator_release_lock
argument_list|()
expr_stmt|;
return|return
name|MEM_START
argument_list|(
name|header
argument_list|)
return|;
block|}
name|free_block
operator|=
name|free_block
operator|->
name|next
expr_stmt|;
block|}
name|chunk_size
operator|=
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
operator|+
name|CHUNK_SIZE
operator|-
literal|1
operator|)
operator|&
name|CHUNK_MASK
expr_stmt|;
name|header
operator|=
operator|(
expr|struct
name|block_header
operator|*
operator|)
name|alloc_chunk
argument_list|(
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header
condition|)
block|{
name|allocator_release_lock
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|chunk_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|chunk_size
expr_stmt|;
name|header
operator|->
name|prev_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|>
name|size
operator|+
literal|64
condition|)
block|{
comment|/* Cut the allocated space into a free and a used block. */
name|allocated_size
operator|+=
name|size
expr_stmt|;
name|header
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|chunk_size
operator|-=
name|size
expr_stmt|;
name|free_block
operator|=
name|AS_FREE_BLOCK
argument_list|(
name|header
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free_block
operator|->
name|header
operator|.
name|prev_size
operator|=
name|size
expr_stmt|;
name|sljit_insert_free_block
argument_list|(
name|free_block
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|next_header
operator|=
name|AS_BLOCK_HEADER
argument_list|(
name|free_block
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* All space belongs to this allocation. */
name|allocated_size
operator|+=
name|chunk_size
expr_stmt|;
name|header
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|next_header
operator|=
name|AS_BLOCK_HEADER
argument_list|(
name|header
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
name|next_header
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|next_header
operator|->
name|prev_size
operator|=
name|chunk_size
expr_stmt|;
name|allocator_release_lock
argument_list|()
expr_stmt|;
return|return
name|MEM_START
argument_list|(
name|header
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_free_exec
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_exec
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|block_header
modifier|*
name|header
decl_stmt|;
name|struct
name|free_block
modifier|*
name|free_block
decl_stmt|;
name|allocator_grab_lock
argument_list|()
expr_stmt|;
name|header
operator|=
name|AS_BLOCK_HEADER
argument_list|(
name|ptr
argument_list|,
operator|-
operator|(
name|sljit_sw
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
argument_list|)
expr_stmt|;
name|allocated_size
operator|-=
name|header
operator|->
name|size
expr_stmt|;
comment|/* Connecting free blocks together if possible. */
comment|/* If header->prev_size == 0, free_block will equal to header. 	   In this case, free_block->header.size will be> 0. */
name|free_block
operator|=
name|AS_FREE_BLOCK
argument_list|(
name|header
argument_list|,
operator|-
operator|(
name|sljit_sw
operator|)
name|header
operator|->
name|prev_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
name|free_block
operator|->
name|header
operator|.
name|size
argument_list|)
condition|)
block|{
name|free_block
operator|->
name|size
operator|+=
name|header
operator|->
name|size
expr_stmt|;
name|header
operator|=
name|AS_BLOCK_HEADER
argument_list|(
name|free_block
argument_list|,
name|free_block
operator|->
name|size
argument_list|)
expr_stmt|;
name|header
operator|->
name|prev_size
operator|=
name|free_block
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|free_block
operator|=
operator|(
expr|struct
name|free_block
operator|*
operator|)
name|header
expr_stmt|;
name|sljit_insert_free_block
argument_list|(
name|free_block
argument_list|,
name|header
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|header
operator|=
name|AS_BLOCK_HEADER
argument_list|(
name|free_block
argument_list|,
name|free_block
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
name|header
operator|->
name|size
argument_list|)
condition|)
block|{
name|free_block
operator|->
name|size
operator|+=
operator|(
operator|(
expr|struct
name|free_block
operator|*
operator|)
name|header
operator|)
operator|->
name|size
expr_stmt|;
name|sljit_remove_free_block
argument_list|(
operator|(
expr|struct
name|free_block
operator|*
operator|)
name|header
argument_list|)
expr_stmt|;
name|header
operator|=
name|AS_BLOCK_HEADER
argument_list|(
name|free_block
argument_list|,
name|free_block
operator|->
name|size
argument_list|)
expr_stmt|;
name|header
operator|->
name|prev_size
operator|=
name|free_block
operator|->
name|size
expr_stmt|;
block|}
comment|/* The whole chunk is free. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
name|free_block
operator|->
name|header
operator|.
name|prev_size
operator|&&
name|header
operator|->
name|size
operator|==
literal|1
argument_list|)
condition|)
block|{
comment|/* If this block is freed, we still have (allocated_size / 2) free space. */
if|if
condition|(
name|total_size
operator|-
name|free_block
operator|->
name|size
operator|>
operator|(
name|allocated_size
operator|*
literal|3
operator|/
literal|2
operator|)
condition|)
block|{
name|total_size
operator|-=
name|free_block
operator|->
name|size
expr_stmt|;
name|sljit_remove_free_block
argument_list|(
name|free_block
argument_list|)
expr_stmt|;
name|free_chunk
argument_list|(
name|free_block
argument_list|,
name|free_block
operator|->
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|allocator_release_lock
argument_list|()
expr_stmt|;
block|}
end_function
end_unit
