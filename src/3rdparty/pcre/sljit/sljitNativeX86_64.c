begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/* x86 64-bit arch dependent functions. */
end_comment
begin_function
DECL|function|emit_load_imm64
specifier|static
name|sljit_si
name|emit_load_imm64
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_sw
name|imm
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
operator|(
operator|(
name|reg_map
index|[
name|reg
index|]
operator|<=
literal|7
operator|)
condition|?
literal|0
else|:
name|REX_B
operator|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_i32
operator|+
operator|(
name|reg_map
index|[
name|reg
index|]
operator|&
literal|0x7
operator|)
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|inst
operator|=
name|imm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|generate_far_jump_code
specifier|static
name|sljit_ub
modifier|*
name|generate_far_jump_code
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|<
name|SLJIT_JUMP
condition|)
block|{
comment|/* Invert type. */
operator|*
name|code_ptr
operator|++
operator|=
name|get_jump_code
argument_list|(
name|type
operator|^
literal|0x1
argument_list|)
operator|-
literal|0x10
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
literal|10
operator|+
literal|3
expr_stmt|;
block|}
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|TMP_REG3
index|]
operator|==
literal|9
argument_list|,
name|tmp3_is_9_first
argument_list|)
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|REX_W
operator||
name|REX_B
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|MOV_r_i32
operator|+
literal|1
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
condition|)
name|jump
operator|->
name|flags
operator||=
name|PATCH_MD
expr_stmt|;
else|else
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|code_ptr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|REX_B
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|GROUP_FF
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
operator|)
condition|?
operator|(
name|MOD_REG
operator||
name|CALL_rm
operator||
literal|1
operator|)
else|:
operator|(
name|MOD_REG
operator||
name|JMP_rm
operator||
literal|1
operator|)
expr_stmt|;
return|return
name|code_ptr
return|;
block|}
end_function
begin_function
DECL|function|generate_fixed_jump
specifier|static
name|sljit_ub
modifier|*
name|generate_fixed_jump
parameter_list|(
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_sw
name|addr
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_sw
name|delta
init|=
name|addr
operator|-
operator|(
operator|(
name|sljit_sw
operator|)
name|code_ptr
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|delta
operator|<=
name|HALFWORD_MAX
operator|&&
name|delta
operator|>=
name|HALFWORD_MIN
condition|)
block|{
operator|*
name|code_ptr
operator|++
operator|=
operator|(
name|type
operator|==
literal|2
operator|)
condition|?
name|CALL_i32
else|:
name|JMP_i32
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|code_ptr
operator|=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|TMP_REG3
index|]
operator|==
literal|9
argument_list|,
name|tmp3_is_9_second
argument_list|)
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|REX_W
operator||
name|REX_B
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|MOV_r_i32
operator|+
literal|1
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|code_ptr
operator|=
name|addr
expr_stmt|;
name|code_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|REX_B
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|GROUP_FF
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
operator|(
name|type
operator|==
literal|2
operator|)
condition|?
operator|(
name|MOD_REG
operator||
name|CALL_rm
operator||
literal|1
operator|)
else|:
operator|(
name|MOD_REG
operator||
name|JMP_rm
operator||
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|code_ptr
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|,
name|pushed_size
decl_stmt|;
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
name|saveds
expr_stmt|;
comment|/* Including the return address saved by the call instruction. */
name|pushed_size
operator|=
operator|(
name|saveds
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN64
if|if
condition|(
name|saveds
operator|>=
literal|2
condition|)
name|size
operator|+=
name|saveds
operator|-
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|saveds
operator|>=
literal|4
condition|)
name|size
operator|+=
name|saveds
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|scratches
operator|>=
literal|5
condition|)
block|{
name|size
operator|+=
operator|(
literal|5
operator|-
literal|4
operator|)
operator|*
literal|2
expr_stmt|;
name|pushed_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|size
operator|+=
name|args
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|5
condition|)
block|{
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_EREG2
index|]
operator|>=
literal|8
argument_list|,
name|saved_ereg2_is_hireg
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_EREG2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saveds
operator|>=
literal|4
condition|)
block|{
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_EREG1
index|]
operator|>=
literal|8
argument_list|,
name|saved_ereg1_is_hireg
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_EREG1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saveds
operator|>=
literal|3
condition|)
block|{
ifndef|#
directive|ifndef
name|_WIN64
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG3
index|]
operator|>=
literal|8
argument_list|,
name|saved_reg3_is_hireg
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
else|#
directive|else
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG3
index|]
operator|<
literal|8
argument_list|,
name|saved_reg3_is_loreg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_REG3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saveds
operator|>=
literal|2
condition|)
block|{
ifndef|#
directive|ifndef
name|_WIN64
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG2
index|]
operator|>=
literal|8
argument_list|,
name|saved_reg2_is_hireg
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
else|#
directive|else
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG2
index|]
operator|<
literal|8
argument_list|,
name|saved_reg2_is_loreg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_REG2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saveds
operator|>=
literal|1
condition|)
block|{
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
operator|<
literal|8
argument_list|,
name|saved_reg1_is_loreg
argument_list|)
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_REG1
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|scratches
operator|>=
literal|5
condition|)
block|{
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_TEMPORARY_EREG2
index|]
operator|>=
literal|8
argument_list|,
name|temporary_ereg2_is_hireg
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_TEMPORARY_EREG2
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|_WIN64
if|if
condition|(
name|args
operator|>
literal|0
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x7
comment|/* rdi */
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|1
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
name|REX_R
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_lmap
index|[
name|SLJIT_SAVED_REG2
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x6
comment|/* rsi */
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|2
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
name|REX_R
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_lmap
index|[
name|SLJIT_SAVED_REG3
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x2
comment|/* rdx */
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|args
operator|>
literal|0
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x1
comment|/* rcx */
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|1
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG2
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x2
comment|/* rdx */
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|2
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
name|REX_B
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG3
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x0
comment|/* r8 */
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|local_size
operator|=
operator|(
operator|(
name|local_size
operator|+
name|FIXED_LOCALS_OFFSET
operator|+
name|pushed_size
operator|+
literal|16
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|-
name|pushed_size
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|local_size
operator|>
literal|1024
condition|)
block|{
comment|/* Allocate stack for the callback, which grows the stack. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
operator|+
operator|(
literal|3
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
operator|+
operator|(
literal|3
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_BINARY_83
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|SUB
operator||
literal|4
expr_stmt|;
comment|/* Pushed size must be divisible by 8. */
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|pushed_size
operator|&
literal|0x7
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushed_size
operator|&
literal|0x8
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|local_size
operator|-=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|inst
operator|++
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|local_size
operator|-=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
comment|/* Second instruction */
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<
literal|8
argument_list|,
name|temporary_reg1_is_loreg
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_rm_i32
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|reg_lmap
index|[
name|SLJIT_SCRATCH_REG1
index|]
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
name|local_size
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|sljit_grow_stack
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|local_size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_size
operator|<=
literal|127
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_BINARY_83
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|SUB
operator||
literal|4
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|local_size
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|7
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|7
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_BINARY_81
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|SUB
operator||
literal|4
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
name|local_size
expr_stmt|;
name|inst
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_WIN64
comment|/* Save xmm6 with MOVAPS instruction. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
literal|0x20247429
expr_stmt|;
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|pushed_size
decl_stmt|;
name|CHECK_ERROR_VOID
argument_list|()
expr_stmt|;
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
comment|/* Including the return address saved by the call instruction. */
name|pushed_size
operator|=
operator|(
name|saveds
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|scratches
operator|>=
literal|5
condition|)
name|pushed_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|local_size
operator|=
operator|(
operator|(
name|local_size
operator|+
name|FIXED_LOCALS_OFFSET
operator|+
name|pushed_size
operator|+
literal|16
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|-
name|pushed_size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|;
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
comment|/* Restore xmm6 with MOVAPS instruction. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
literal|0x20247428
expr_stmt|;
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|compiler
operator|->
name|local_size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|<=
literal|127
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_BINARY_83
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|ADD
operator||
literal|4
expr_stmt|;
operator|*
name|inst
operator|=
name|compiler
operator|->
name|local_size
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|7
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|7
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_BINARY_81
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
name|ADD
operator||
literal|4
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
name|compiler
operator|->
name|local_size
expr_stmt|;
block|}
name|size
operator|=
literal|1
operator|+
name|compiler
operator|->
name|saveds
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN64
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|2
condition|)
name|size
operator|+=
name|compiler
operator|->
name|saveds
operator|-
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|4
condition|)
name|size
operator|+=
name|compiler
operator|->
name|saveds
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|5
condition|)
name|size
operator|+=
operator|(
literal|5
operator|-
literal|4
operator|)
operator|*
literal|2
expr_stmt|;
endif|#
directive|endif
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|5
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|POP_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_TEMPORARY_EREG2
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|1
condition|)
name|POP_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|2
condition|)
block|{
ifndef|#
directive|ifndef
name|_WIN64
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
endif|#
directive|endif
name|POP_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_REG2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|3
condition|)
block|{
ifndef|#
directive|ifndef
name|_WIN64
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
endif|#
directive|endif
name|POP_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_REG3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|4
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|POP_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_EREG1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|5
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|POP_REG
argument_list|(
name|reg_lmap
index|[
name|SLJIT_SAVED_EREG2
index|]
argument_list|)
expr_stmt|;
block|}
name|RET
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|emit_do_imm32
specifier|static
name|sljit_si
name|emit_do_imm32
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|rex
parameter_list|,
name|sljit_ub
name|opcode
parameter_list|,
name|sljit_sw
name|imm
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|length
init|=
literal|1
operator|+
operator|(
name|rex
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
decl_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|rex
condition|)
operator|*
name|inst
operator|++
operator|=
name|rex
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|opcode
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
name|imm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_x86_instruction
specifier|static
name|sljit_ub
modifier|*
name|emit_x86_instruction
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|,
comment|/* The register or immediate operand. */
name|sljit_si
name|a
parameter_list|,
name|sljit_sw
name|imma
parameter_list|,
comment|/* The general operand (not immediate). */
name|sljit_si
name|b
parameter_list|,
name|sljit_sw
name|immb
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_ub
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_ub
name|rex
init|=
literal|0
decl_stmt|;
name|sljit_si
name|flags
init|=
name|size
operator|&
operator|~
literal|0xf
decl_stmt|;
name|sljit_si
name|inst_size
decl_stmt|;
comment|/* The immediate operand must be 32 bit. */
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|a
operator|&
name|SLJIT_IMM
operator|)
operator|||
name|compiler
operator|->
name|mode32
operator|||
name|IS_HALFWORD
argument_list|(
name|imma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Both cannot be switched on. */
name|SLJIT_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|EX86_BIN_INS
operator||
name|EX86_SHIFT_INS
operator|)
operator|)
operator|!=
operator|(
name|EX86_BIN_INS
operator||
name|EX86_SHIFT_INS
operator|)
argument_list|)
expr_stmt|;
comment|/* Size flags not allowed for typed instructions. */
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|EX86_BIN_INS
operator||
name|EX86_SHIFT_INS
operator|)
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|EX86_BYTE_ARG
operator||
name|EX86_HALF_ARG
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Both size flags cannot be switched on. */
name|SLJIT_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|EX86_BYTE_ARG
operator||
name|EX86_HALF_ARG
operator|)
operator|)
operator|!=
operator|(
name|EX86_BYTE_ARG
operator||
name|EX86_HALF_ARG
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
comment|/* SSE2 and immediate is not possible. */
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|a
operator|&
name|SLJIT_IMM
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_F3
operator|)
operator|)
operator|!=
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_F3
operator|)
operator|&&
operator|(
name|flags
operator|&
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_66
operator|)
operator|)
operator|!=
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_66
operator|)
operator|&&
operator|(
name|flags
operator|&
operator|(
name|EX86_PREF_F3
operator||
name|EX86_PREF_66
operator|)
operator|)
operator|!=
operator|(
name|EX86_PREF_F3
operator||
name|EX86_PREF_66
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|&=
literal|0xf
expr_stmt|;
name|inst_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|!
operator|(
name|b
operator|&
name|OFFS_REG_MASK
operator|)
operator|&&
name|NOT_HALFWORD
argument_list|(
name|immb
argument_list|)
condition|)
block|{
if|if
condition|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|immb
argument_list|)
condition|)
return|return
name|NULL
return|;
name|immb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|&
name|REG_MASK
condition|)
name|b
operator||=
name|TO_OFFS_REG
argument_list|(
name|TMP_REG3
argument_list|)
expr_stmt|;
else|else
name|b
operator||=
name|TMP_REG3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compiler
operator|->
name|mode32
operator|&&
operator|!
operator|(
name|flags
operator|&
name|EX86_NO_REXW
operator|)
condition|)
name|rex
operator||=
name|REX_W
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_REX
condition|)
name|rex
operator||=
name|REX
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
if|if
condition|(
name|flags
operator|&
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_F3
operator|)
condition|)
name|inst_size
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_66
condition|)
name|inst_size
operator|++
expr_stmt|;
comment|/* Calculate size of b. */
name|inst_size
operator|+=
literal|1
expr_stmt|;
comment|/* mod r/m byte. */
if|if
condition|(
name|b
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|&
name|REG_MASK
operator|)
operator|==
name|SLJIT_UNUSED
condition|)
name|inst_size
operator|+=
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
comment|/* SIB byte required to avoid RIP based addressing. */
else|else
block|{
if|if
condition|(
name|reg_map
index|[
name|b
operator|&
name|REG_MASK
index|]
operator|>=
literal|8
condition|)
name|rex
operator||=
name|REX_B
expr_stmt|;
if|if
condition|(
name|immb
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|b
operator|&
name|OFFS_REG_MASK
operator|)
condition|)
block|{
comment|/* Immediate operand. */
if|if
condition|(
name|immb
operator|<=
literal|127
operator|&&
name|immb
operator|>=
operator|-
literal|128
condition|)
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
expr_stmt|;
else|else
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|b
operator|&
name|REG_MASK
operator|)
operator|==
name|SLJIT_LOCALS_REG
operator|&&
operator|!
operator|(
name|b
operator|&
name|OFFS_REG_MASK
operator|)
condition|)
name|b
operator||=
name|TO_OFFS_REG
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
name|OFFS_REG_MASK
operator|)
operator|!=
name|SLJIT_UNUSED
condition|)
block|{
name|inst_size
operator|+=
literal|1
expr_stmt|;
comment|/* SIB byte. */
if|if
condition|(
name|reg_map
index|[
name|OFFS_REG
argument_list|(
name|b
argument_list|)
index|]
operator|>=
literal|8
condition|)
name|rex
operator||=
name|REX_X
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
operator|&&
name|reg_map
index|[
name|b
index|]
operator|>=
literal|8
condition|)
name|rex
operator||=
name|REX_B
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|reg_map
index|[
name|b
index|]
operator|>=
literal|8
condition|)
name|rex
operator||=
name|REX_B
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|a
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|EX86_BIN_INS
condition|)
block|{
if|if
condition|(
name|imma
operator|<=
literal|127
operator|&&
name|imma
operator|>=
operator|-
literal|128
condition|)
block|{
name|inst_size
operator|+=
literal|1
expr_stmt|;
name|flags
operator||=
name|EX86_BYTE_ARG
expr_stmt|;
block|}
else|else
name|inst_size
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_SHIFT_INS
condition|)
block|{
name|imma
operator|&=
name|compiler
operator|->
name|mode32
condition|?
literal|0x1f
else|:
literal|0x3f
expr_stmt|;
if|if
condition|(
name|imma
operator|!=
literal|1
condition|)
block|{
name|inst_size
operator|++
expr_stmt|;
name|flags
operator||=
name|EX86_BYTE_ARG
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_BYTE_ARG
condition|)
name|inst_size
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_HALF_ARG
condition|)
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
else|else
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
operator|||
name|a
operator|==
name|SLJIT_PREF_SHIFT_REG
argument_list|)
expr_stmt|;
comment|/* reg_map[SLJIT_PREF_SHIFT_REG] is less than 8. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
operator|&&
name|reg_map
index|[
name|a
index|]
operator|>=
literal|8
condition|)
name|rex
operator||=
name|REX_R
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|reg_map
index|[
name|a
index|]
operator|>=
literal|8
condition|)
name|rex
operator||=
name|REX_R
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|rex
condition|)
name|inst_size
operator|++
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|inst_size
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
comment|/* Encoding the byte. */
name|INC_SIZE
argument_list|(
name|inst_size
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_F2
condition|)
operator|*
name|inst
operator|++
operator|=
literal|0xf2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_F3
condition|)
operator|*
name|inst
operator|++
operator|=
literal|0xf3
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_66
condition|)
operator|*
name|inst
operator|++
operator|=
literal|0x66
expr_stmt|;
if|if
condition|(
name|rex
condition|)
operator|*
name|inst
operator|++
operator|=
name|rex
expr_stmt|;
name|buf_ptr
operator|=
name|inst
operator|+
name|size
expr_stmt|;
comment|/* Encode mod/rm byte. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|EX86_BIN_INS
operator|)
operator|&&
operator|(
name|a
operator|&
name|SLJIT_IMM
operator|)
condition|)
operator|*
name|inst
operator|=
operator|(
name|flags
operator|&
name|EX86_BYTE_ARG
operator|)
condition|?
name|GROUP_BINARY_83
else|:
name|GROUP_BINARY_81
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|&
name|SLJIT_IMM
operator|)
operator|||
operator|(
name|a
operator|==
literal|0
operator|)
condition|)
operator|*
name|buf_ptr
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
condition|)
operator|*
name|buf_ptr
operator|=
name|reg_lmap
index|[
name|a
index|]
operator|<<
literal|3
expr_stmt|;
else|else
operator|*
name|buf_ptr
operator|=
name|a
operator|<<
literal|3
expr_stmt|;
else|#
directive|else
else|else
operator|*
name|buf_ptr
operator|=
name|reg_lmap
index|[
name|a
index|]
operator|<<
literal|3
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|a
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|imma
operator|==
literal|1
condition|)
operator|*
name|inst
operator|=
name|GROUP_SHIFT_1
expr_stmt|;
else|else
operator|*
name|inst
operator|=
name|GROUP_SHIFT_N
expr_stmt|;
block|}
else|else
operator|*
name|inst
operator|=
name|GROUP_SHIFT_CL
expr_stmt|;
operator|*
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|b
operator|&
name|SLJIT_MEM
operator|)
condition|)
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
operator|*
name|buf_ptr
operator|++
operator||=
name|MOD_REG
operator|+
operator|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
operator|)
condition|?
name|reg_lmap
index|[
name|b
index|]
else|:
name|b
operator|)
expr_stmt|;
else|#
directive|else
operator|*
name|buf_ptr
operator|++
operator||=
name|MOD_REG
operator|+
name|reg_lmap
index|[
name|b
index|]
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
name|REG_MASK
operator|)
operator|!=
name|SLJIT_UNUSED
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|&
name|OFFS_REG_MASK
operator|)
operator|==
name|SLJIT_UNUSED
operator|||
operator|(
name|b
operator|&
name|OFFS_REG_MASK
operator|)
operator|==
name|TO_OFFS_REG
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
condition|)
block|{
if|if
condition|(
name|immb
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|immb
operator|<=
literal|127
operator|&&
name|immb
operator|>=
operator|-
literal|128
condition|)
operator|*
name|buf_ptr
operator||=
literal|0x40
expr_stmt|;
else|else
operator|*
name|buf_ptr
operator||=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|b
operator|&
name|OFFS_REG_MASK
operator|)
operator|==
name|SLJIT_UNUSED
condition|)
operator|*
name|buf_ptr
operator|++
operator||=
name|reg_lmap
index|[
name|b
operator|&
name|REG_MASK
index|]
expr_stmt|;
else|else
block|{
operator|*
name|buf_ptr
operator|++
operator||=
literal|0x04
expr_stmt|;
operator|*
name|buf_ptr
operator|++
operator|=
name|reg_lmap
index|[
name|b
operator|&
name|REG_MASK
index|]
operator||
operator|(
name|reg_lmap
index|[
name|OFFS_REG
argument_list|(
name|b
argument_list|)
index|]
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|immb
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|immb
operator|<=
literal|127
operator|&&
name|immb
operator|>=
operator|-
literal|128
condition|)
operator|*
name|buf_ptr
operator|++
operator|=
name|immb
expr_stmt|;
comment|/* 8 bit displacement. */
else|else
block|{
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|buf_ptr
operator|=
name|immb
expr_stmt|;
comment|/* 32 bit displacement. */
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
operator|*
name|buf_ptr
operator|++
operator||=
literal|0x04
expr_stmt|;
operator|*
name|buf_ptr
operator|++
operator|=
name|reg_lmap
index|[
name|b
operator|&
name|REG_MASK
index|]
operator||
operator|(
name|reg_lmap
index|[
name|OFFS_REG
argument_list|(
name|b
argument_list|)
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|immb
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|buf_ptr
operator|++
operator||=
literal|0x04
expr_stmt|;
operator|*
name|buf_ptr
operator|++
operator|=
literal|0x25
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|buf_ptr
operator|=
name|immb
expr_stmt|;
comment|/* 32 bit displacement. */
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|EX86_BYTE_ARG
condition|)
operator|*
name|buf_ptr
operator|=
name|imma
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_HALF_ARG
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
name|buf_ptr
operator|=
name|imma
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
condition|)
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|buf_ptr
operator|=
name|imma
expr_stmt|;
block|}
return|return
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
condition|?
name|inst
else|:
operator|(
name|inst
operator|+
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Call / return instructions                                           */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|call_with_args
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|call_with_args
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN64
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|==
literal|6
operator|&&
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<
literal|8
operator|&&
name|reg_map
index|[
name|SLJIT_SCRATCH_REG3
index|]
operator|<
literal|8
argument_list|,
name|args_registers
argument_list|)
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
operator|(
operator|(
name|type
operator|<
name|SLJIT_CALL3
operator|)
condition|?
literal|3
else|:
literal|6
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
operator|(
name|type
operator|<
name|SLJIT_CALL3
operator|)
condition|?
literal|3
else|:
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL3
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
literal|0x2
comment|/* rdx */
operator|<<
literal|3
operator|)
operator||
name|reg_lmap
index|[
name|SLJIT_SCRATCH_REG3
index|]
expr_stmt|;
block|}
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
literal|0x7
comment|/* rdi */
operator|<<
literal|3
operator|)
operator||
name|reg_lmap
index|[
name|SLJIT_SCRATCH_REG1
index|]
expr_stmt|;
else|#
directive|else
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|==
literal|2
operator|&&
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<
literal|8
operator|&&
name|reg_map
index|[
name|SLJIT_SCRATCH_REG3
index|]
operator|<
literal|8
argument_list|,
name|args_registers
argument_list|)
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
operator|(
operator|(
name|type
operator|<
name|SLJIT_CALL3
operator|)
condition|?
literal|3
else|:
literal|6
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
operator|(
name|type
operator|<
name|SLJIT_CALL3
operator|)
condition|?
literal|3
else|:
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL3
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|REX_W
operator||
name|REX_R
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
literal|0x0
comment|/* r8 */
operator|<<
literal|3
operator|)
operator||
name|reg_lmap
index|[
name|SLJIT_SCRATCH_REG3
index|]
expr_stmt|;
block|}
operator|*
name|inst
operator|++
operator|=
name|REX_W
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
literal|0x1
comment|/* rcx */
operator|<<
literal|3
operator|)
operator||
name|reg_lmap
index|[
name|SLJIT_SCRATCH_REG1
index|]
expr_stmt|;
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
name|dst
operator|=
name|TMP_REG1
expr_stmt|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_map
index|[
name|dst
index|]
operator|<
literal|8
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|POP_REG
argument_list|(
name|reg_lmap
index|[
name|dst
index|]
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|POP_REG
argument_list|(
name|reg_lmap
index|[
name|dst
index|]
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* REX_W is not necessary (src is not immediate). */
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|POP_rm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|NOT_HALFWORD
argument_list|(
name|srcw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
block|}
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_map
index|[
name|src
index|]
operator|<
literal|8
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|src
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|REX_B
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_lmap
index|[
name|src
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
comment|/* REX_W is not necessary (src is not immediate). */
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_FF
expr_stmt|;
operator|*
name|inst
operator||=
name|PUSH_rm
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|IS_HALFWORD
argument_list|(
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SLJIT_IMM. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|PUSH_i32
expr_stmt|;
operator|*
operator|(
name|sljit_si
operator|*
operator|)
name|inst
operator|=
name|srcw
expr_stmt|;
name|inst
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_si
argument_list|)
expr_stmt|;
block|}
name|RET
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Extend input                                                         */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|emit_mov_int
specifier|static
name|sljit_si
name|emit_mov_int
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|sign
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_si
name|dst_r
decl_stmt|;
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
operator|&&
operator|!
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* Empty instruction. */
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|sign
operator|||
operator|(
operator|(
name|sljit_uw
operator|)
name|srcw
operator|<=
literal|0x7fffffff
operator|)
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
operator|(
name|sljit_si
operator|)
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_i32
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
return|return
name|emit_load_imm64
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|srcw
argument_list|)
return|;
block|}
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
operator|(
name|sljit_si
operator|)
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_i32
expr_stmt|;
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|dst_r
operator|=
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
name|dst
else|:
name|TMP_REG1
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
name|dst_r
operator|=
name|src
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sign
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOVSXD_r_rm
expr_stmt|;
block|}
else|else
block|{
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov
argument_list|(
name|compiler
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
name|compiler
operator|->
name|mode32
operator|=
literal|1
expr_stmt|;
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
name|dst_r
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|=
name|MOV_rm_r
expr_stmt|;
name|compiler
operator|->
name|mode32
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
end_unit
