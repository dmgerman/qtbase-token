begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2012 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains the external function pcre_study(), along with local supporting functions. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_define
DECL|macro|SET_BIT
define|#
directive|define
name|SET_BIT
parameter_list|(
name|c
parameter_list|)
value|start_bits[c/8] |= (1<< (c&7))
end_define
begin_comment
comment|/* Returns from set_start_bits() */
end_comment
begin_enum
DECL|enumerator|SSB_FAIL
DECL|enumerator|SSB_DONE
DECL|enumerator|SSB_CONTINUE
DECL|enumerator|SSB_UNKNOWN
enum|enum
block|{
name|SSB_FAIL
block|,
name|SSB_DONE
block|,
name|SSB_CONTINUE
block|,
name|SSB_UNKNOWN
block|}
enum|;
end_enum
begin_comment
comment|/************************************************* *   Find the minimum subject length for a group  * *************************************************/
end_comment
begin_comment
comment|/* Scan a parenthesized group and compute the minimum length of subject that is needed to match it. This is a lower bound; it does not mean there is a string of that length that matches. In UTF8 mode, the result is in characters rather than bytes.  Arguments:   code            pointer to start of group (the bracket)   startcode       pointer to start of the whole pattern   options         the compiling options   int             RECURSE depth  Returns:   the minimum length            -1 if \C in UTF-8 mode or (*ACCEPT) was encountered            -2 internal error (missing capturing bracket)            -3 internal error (opcode not listed) */
end_comment
begin_function
specifier|static
name|int
DECL|function|find_minlength
name|find_minlength
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|startcode
parameter_list|,
name|int
name|options
parameter_list|,
name|int
name|recurse_depth
parameter_list|)
block|{
name|int
name|length
init|=
operator|-
literal|1
decl_stmt|;
comment|/* PCRE_UTF16 has the same value as PCRE_UTF8. */
name|BOOL
name|utf
init|=
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
decl_stmt|;
name|BOOL
name|had_recurse
init|=
name|FALSE
decl_stmt|;
specifier|register
name|int
name|branchlength
init|=
literal|0
decl_stmt|;
specifier|register
name|pcre_uchar
modifier|*
name|cc
init|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|code
operator|+
literal|1
operator|+
name|LINK_SIZE
decl_stmt|;
if|if
condition|(
operator|*
name|code
operator|==
name|OP_CBRA
operator|||
operator|*
name|code
operator|==
name|OP_SCBRA
operator|||
operator|*
name|code
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|code
operator|==
name|OP_SCBRAPOS
condition|)
name|cc
operator|+=
name|IMM2_SIZE
expr_stmt|;
comment|/* Scan along the opcodes for this branch. If we get to the end of the branch, check the length against that of the other branches. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|d
decl_stmt|,
name|min
decl_stmt|;
name|pcre_uchar
modifier|*
name|cs
decl_stmt|,
modifier|*
name|ce
decl_stmt|;
specifier|register
name|pcre_uchar
name|op
init|=
operator|*
name|cc
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_COND
case|:
case|case
name|OP_SCOND
case|:
comment|/* If there is only one branch in a condition, the implied branch has zero     length, so we don't add anything. This covers the DEFINE "condition"     automatically. */
name|cs
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cs
operator|!=
name|OP_ALT
condition|)
block|{
name|cc
operator|=
name|cs
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
block|}
comment|/* Otherwise we can fall through and treat it the same as any other     subpattern. */
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
name|d
operator|=
name|find_minlength
argument_list|(
name|cc
argument_list|,
name|startcode
argument_list|,
name|options
argument_list|,
name|recurse_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
return|return
name|d
return|;
name|branchlength
operator|+=
name|d
expr_stmt|;
do|do
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* ACCEPT makes things far too complicated; we have to give up. */
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
return|return
operator|-
literal|1
return|;
comment|/* Reached end of a branch; if it's a ket it is the end of a nested     call. If it's ALT it is an alternation in a nested call. If it is END it's     the end of the outer call. All can be handled by the same code. If an     ACCEPT was previously encountered, use the length that was in force at that     time, and pass back the shortest ACCEPT length. */
case|case
name|OP_ALT
case|:
case|case
name|OP_KET
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRPOS
case|:
case|case
name|OP_END
case|:
if|if
condition|(
name|length
operator|<
literal|0
operator|||
operator|(
operator|!
name|had_recurse
operator|&&
name|branchlength
operator|<
name|length
operator|)
condition|)
name|length
operator|=
name|branchlength
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|OP_ALT
condition|)
return|return
name|length
return|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|branchlength
operator|=
literal|0
expr_stmt|;
name|had_recurse
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* Skip over assertive subpatterns */
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
do|do
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
comment|/* Fall through */
comment|/* Skip over things that don't match chars */
case|case
name|OP_REVERSE
case|:
case|case
name|OP_CREF
case|:
case|case
name|OP_NCREF
case|:
case|case
name|OP_RREF
case|:
case|case
name|OP_NRREF
case|:
case|case
name|OP_DEF
case|:
case|case
name|OP_CALLOUT
case|:
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|cc
index|]
expr_stmt|;
break|break;
comment|/* Skip over a subpattern that has a {0} or {0,x} quantifier */
case|case
name|OP_BRAZERO
case|:
case|case
name|OP_BRAMINZERO
case|:
case|case
name|OP_BRAPOSZERO
case|:
case|case
name|OP_SKIPZERO
case|:
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|cc
index|]
expr_stmt|;
do|do
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* Handle literal characters and + repetitions */
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
name|branchlength
operator|++
expr_stmt|;
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
name|branchlength
operator|++
expr_stmt|;
name|cc
operator|+=
operator|(
name|cc
index|[
literal|1
index|]
operator|==
name|OP_PROP
operator|||
name|cc
index|[
literal|1
index|]
operator|==
name|OP_NOTPROP
operator|)
condition|?
literal|4
else|:
literal|2
expr_stmt|;
break|break;
comment|/* Handle exact repetitions. The count is already in characters, but we     need to skip over a multibyte character in UTF8 mode.  */
case|case
name|OP_EXACT
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTEXACTI
case|:
name|branchlength
operator|+=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|2
operator|+
name|IMM2_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OP_TYPEEXACT
case|:
name|branchlength
operator|+=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|2
operator|+
name|IMM2_SIZE
operator|+
operator|(
operator|(
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_PROP
operator|||
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_NOTPROP
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
break|break;
comment|/* Handle single-char non-literal matchers */
case|case
name|OP_PROP
case|:
case|case
name|OP_NOTPROP
case|:
name|cc
operator|+=
literal|2
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_HSPACE
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
name|branchlength
operator|++
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
comment|/* "Any newline" might match two characters, but it also might match just     one. */
case|case
name|OP_ANYNL
case|:
name|branchlength
operator|+=
literal|1
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
comment|/* The single-byte matcher means we can't proceed in UTF-8 mode. (In     non-UTF-8 mode \C will actually be turned into OP_ALLANY, so won't ever     appear, but leave the code, just in case.) */
case|case
name|OP_ANYBYTE
case|:
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
name|branchlength
operator|++
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
comment|/* For repeated character types, we have to test for \p and \P, which have     an extra two bytes of parameters. */
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
if|if
condition|(
name|cc
index|[
literal|1
index|]
operator|==
name|OP_PROP
operator|||
name|cc
index|[
literal|1
index|]
operator|==
name|OP_NOTPROP
condition|)
name|cc
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|op
index|]
expr_stmt|;
break|break;
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_PROP
operator|||
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_NOTPROP
condition|)
name|cc
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|op
index|]
expr_stmt|;
break|break;
comment|/* Check a class for variable quantification */
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
case|case
name|OP_XCLASS
case|:
comment|/* The original code caused an unsigned overflow in 64 bit systems,     so now we use a conditional statement. */
if|if
condition|(
name|op
operator|==
name|OP_XCLASS
condition|)
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CLASS
index|]
expr_stmt|;
else|#
directive|else
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CLASS
index|]
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
name|branchlength
operator|++
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
name|branchlength
operator|+=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|branchlength
operator|++
expr_stmt|;
break|break;
block|}
break|break;
comment|/* Backreferences and subroutine calls are treated in the same way: we find     the minimum length for the subpattern. A recursion, however, causes an     a flag to be set that causes the length of this branch to be ignored. The     logic is that a recursion can only make sense if there is another     alternation that stops the recursing. That will provide the minimum length     (when no recursion happens). A backreference within the group that it is     referencing behaves in the same way.      If PCRE_JAVASCRIPT_COMPAT is set, a backreference to an unset bracket     matches an empty string (by default it causes a matching failure), so in     that case we must set the minimum length to zero. */
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|==
literal|0
condition|)
block|{
name|ce
operator|=
name|cs
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|PRIV
argument_list|(
name|find_bracket
argument_list|)
argument_list|(
name|startcode
argument_list|,
name|utf
argument_list|,
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
do|do
name|ce
operator|+=
name|GET
argument_list|(
name|ce
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ce
operator|==
name|OP_ALT
condition|)
do|;
if|if
condition|(
name|cc
operator|>
name|cs
operator|&&
name|cc
operator|<
name|ce
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
name|had_recurse
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|find_minlength
argument_list|(
name|cs
argument_list|,
name|startcode
argument_list|,
name|options
argument_list|,
name|recurse_depth
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|d
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
comment|/* Handle repeated back references */
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
name|min
operator|=
literal|1
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
name|min
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|min
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|branchlength
operator|+=
name|min
operator|*
name|d
expr_stmt|;
break|break;
comment|/* We can easily detect direct recursion, but not mutual recursion. This is     caught by a recursion depth count. */
case|case
name|OP_RECURSE
case|:
name|cs
operator|=
name|ce
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|startcode
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|do
name|ce
operator|+=
name|GET
argument_list|(
name|ce
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ce
operator|==
name|OP_ALT
condition|)
do|;
if|if
condition|(
operator|(
name|cc
operator|>
name|cs
operator|&&
name|cc
operator|<
name|ce
operator|)
operator|||
name|recurse_depth
operator|>
literal|10
condition|)
name|had_recurse
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|branchlength
operator|+=
name|find_minlength
argument_list|(
name|cs
argument_list|,
name|startcode
argument_list|,
name|options
argument_list|,
name|recurse_depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* Anything else does not or need not match a character. We can get the     item's length from the table, but for those that can match zero occurrences     of a character, we must take special action for UTF-8 characters. As it     happens, the "NOT" versions of these opcodes are used at present only for     ASCII characters, so they could be omitted from this list. However, in     future that may change, so we include them here so as not to leave a     gotcha for a future maintainer. */
case|case
name|OP_UPTO
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_STAR
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|op
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Skip these, but we need to add in the name length. */
case|case
name|OP_MARK
case|:
case|case
name|OP_PRUNE_ARG
case|:
case|case
name|OP_SKIP_ARG
case|:
case|case
name|OP_THEN_ARG
case|:
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|op
index|]
operator|+
name|cc
index|[
literal|1
index|]
expr_stmt|;
break|break;
comment|/* The remaining opcodes are just skipped over. */
case|case
name|OP_CLOSE
case|:
case|case
name|OP_COMMIT
case|:
case|case
name|OP_FAIL
case|:
case|case
name|OP_PRUNE
case|:
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_SKIP
case|:
case|case
name|OP_THEN
case|:
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|op
index|]
expr_stmt|;
break|break;
comment|/* This should not occur: we list all opcodes explicitly so that when     new ones get added they are properly considered. */
default|default:
return|return
operator|-
literal|3
return|;
block|}
block|}
comment|/* Control never gets here */
block|}
end_function
begin_comment
comment|/************************************************* *      Set a bit and maybe its alternate case    * *************************************************/
end_comment
begin_comment
comment|/* Given a character, set its first byte's bit in the table, and also the corresponding bit for the other version of a letter if we are caseless. In UTF-8 mode, for characters greater than 127, we can only do the caseless thing when Unicode property support is available.  Arguments:   start_bits    points to the bit map   p             points to the character   caseless      the caseless flag   cd            the block with char table pointers   utf           TRUE for UTF-8 / UTF-16 / UTF-32 mode  Returns:        pointer after the character */
end_comment
begin_function
specifier|static
specifier|const
name|pcre_uchar
modifier|*
DECL|function|set_table_bit
name|set_table_bit
parameter_list|(
name|pcre_uint8
modifier|*
name|start_bits
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|p
parameter_list|,
name|BOOL
name|caseless
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
name|BOOL
name|utf
parameter_list|)
block|{
name|pcre_uint32
name|c
init|=
operator|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|SET_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|c
operator|>
literal|127
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|caseless
condition|)
block|{
name|pcre_uchar
name|buff
index|[
literal|6
index|]
decl_stmt|;
name|c
operator|=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
expr_stmt|;
call|(
name|void
call|)
name|PRIV
argument_list|(
argument|ord2utf
argument_list|)
argument_list|(
name|c
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Not SUPPORT_UCP */
return|return
name|p
return|;
block|}
else|#
directive|else
comment|/* Not SUPPORT_UTF */
call|(
name|void
call|)
argument_list|(
name|utf
argument_list|)
expr_stmt|;
comment|/* Stops warning for unused parameter */
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Not UTF-8 mode, or character is less than 127. */
if|if
condition|(
name|caseless
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_letter
operator|)
operator|!=
literal|0
condition|)
name|SET_BIT
argument_list|(
name|cd
operator|->
name|fcc
index|[
name|c
index|]
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|c
operator|>
literal|0xff
condition|)
block|{
name|c
operator|=
literal|0xff
expr_stmt|;
name|caseless
operator|=
name|FALSE
expr_stmt|;
block|}
name|SET_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|c
operator|>
literal|127
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|caseless
condition|)
block|{
name|c
operator|=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0xff
condition|)
name|c
operator|=
literal|0xff
expr_stmt|;
name|SET_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UCP */
return|return
name|p
return|;
block|}
else|#
directive|else
comment|/* Not SUPPORT_UTF */
call|(
name|void
call|)
argument_list|(
name|utf
argument_list|)
expr_stmt|;
comment|/* Stops warning for unused parameter */
endif|#
directive|endif
comment|/* SUPPORT_UTF */
if|if
condition|(
name|caseless
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_letter
operator|)
operator|!=
literal|0
condition|)
name|SET_BIT
argument_list|(
name|cd
operator|->
name|fcc
index|[
name|c
index|]
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/************************************************* *     Set bits for a positive character type     * *************************************************/
end_comment
begin_comment
comment|/* This function sets starting bits for a character type. In UTF-8 mode, we can only do a direct setting for bytes less than 128, as otherwise there can be confusion with bytes in the middle of UTF-8 characters. In a "traditional" environment, the tables will only recognize ASCII characters anyway, but in at least one Windows environment, some higher bytes bits were set in the tables. So we deal with that case by considering the UTF-8 encoding.  Arguments:   start_bits     the starting bitmap   cbit type      the type of character wanted   table_limit    32 for non-UTF-8; 16 for UTF-8   cd             the block with char table pointers  Returns:         nothing */
end_comment
begin_function
specifier|static
name|void
DECL|function|set_type_bits
name|set_type_bits
parameter_list|(
name|pcre_uint8
modifier|*
name|start_bits
parameter_list|,
name|int
name|cbit_type
parameter_list|,
name|unsigned
name|int
name|table_limit
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
specifier|register
name|pcre_uint32
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|table_limit
condition|;
name|c
operator|++
control|)
name|start_bits
index|[
name|c
index|]
operator||=
name|cd
operator|->
name|cbits
index|[
name|c
operator|+
name|cbit_type
index|]
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|table_limit
operator|==
literal|32
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|128
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cd
operator|->
name|cbits
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|pcre_uchar
name|buff
index|[
literal|6
index|]
decl_stmt|;
call|(
name|void
call|)
name|PRIV
argument_list|(
argument|ord2utf
argument_list|)
argument_list|(
name|c
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/************************************************* *     Set bits for a negative character type     * *************************************************/
end_comment
begin_comment
comment|/* This function sets starting bits for a negative character type such as \D. In UTF-8 mode, we can only do a direct setting for bytes less than 128, as otherwise there can be confusion with bytes in the middle of UTF-8 characters. Unlike in the positive case, where we can set appropriate starting bits for specific high-valued UTF-8 characters, in this case we have to set the bits for all high-valued characters. The lowest is 0xc2, but we overkill by starting at 0xc0 (192) for simplicity.  Arguments:   start_bits     the starting bitmap   cbit type      the type of character wanted   table_limit    32 for non-UTF-8; 16 for UTF-8   cd             the block with char table pointers  Returns:         nothing */
end_comment
begin_function
specifier|static
name|void
DECL|function|set_nottype_bits
name|set_nottype_bits
parameter_list|(
name|pcre_uint8
modifier|*
name|start_bits
parameter_list|,
name|int
name|cbit_type
parameter_list|,
name|unsigned
name|int
name|table_limit
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
specifier|register
name|pcre_uint32
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|table_limit
condition|;
name|c
operator|++
control|)
name|start_bits
index|[
name|c
index|]
operator||=
operator|~
name|cd
operator|->
name|cbits
index|[
name|c
operator|+
name|cbit_type
index|]
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|table_limit
operator|!=
literal|32
condition|)
for|for
control|(
name|c
operator|=
literal|24
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|start_bits
index|[
name|c
index|]
operator|=
literal|0xff
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/************************************************* *          Create bitmap of starting bytes       * *************************************************/
end_comment
begin_comment
comment|/* This function scans a compiled unanchored expression recursively and attempts to build a bitmap of the set of possible starting bytes. As time goes by, we may be able to get more clever at doing this. The SSB_CONTINUE return is useful for parenthesized groups in patterns such as (a*)b where the group provides some optional starting bytes but scanning must continue at the outer level to find at least one mandatory byte. At the outermost level, this function fails unless the result is SSB_DONE.  Arguments:   code         points to an expression   start_bits   points to a 32-byte table, initialized to 0   utf          TRUE if in UTF-8 / UTF-16 / UTF-32 mode   cd           the block with char table pointers  Returns:       SSB_FAIL     => Failed to find any starting bytes                SSB_DONE     => Found mandatory starting bytes                SSB_CONTINUE => Found optional starting bytes                SSB_UNKNOWN  => Hit an unrecognized opcode */
end_comment
begin_function
specifier|static
name|int
DECL|function|set_start_bits
name|set_start_bits
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|pcre_uint8
modifier|*
name|start_bits
parameter_list|,
name|BOOL
name|utf
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
specifier|register
name|pcre_uint32
name|c
decl_stmt|;
name|int
name|yield
init|=
name|SSB_DONE
decl_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
name|int
name|table_limit
init|=
name|utf
condition|?
literal|16
else|:
literal|32
decl_stmt|;
else|#
directive|else
name|int
name|table_limit
init|=
literal|32
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* ========================================================================= */
comment|/* The following comment and code was inserted in January 1999. In May 2006, when it was observed to cause compiler warnings about unused values, I took it out again. If anybody is still using OS/2, they will have to put it back manually. */
comment|/* This next statement and the later reference to dummy are here in order to trick the optimizer of the IBM C compiler for OS/2 into generating correct code. Apparently IBM isn't going to fix the problem, and we would rather not disable optimization (in this module it actually makes a big difference, and the pcre module can use all the optimization it can get). */
block|volatile int dummy;
comment|/* ========================================================================= */
endif|#
directive|endif
do|do
block|{
name|BOOL
name|try_next
init|=
name|TRUE
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|tcode
init|=
name|code
operator|+
literal|1
operator|+
name|LINK_SIZE
decl_stmt|;
if|if
condition|(
operator|*
name|code
operator|==
name|OP_CBRA
operator|||
operator|*
name|code
operator|==
name|OP_SCBRA
operator|||
operator|*
name|code
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|code
operator|==
name|OP_SCBRAPOS
condition|)
name|tcode
operator|+=
name|IMM2_SIZE
expr_stmt|;
while|while
condition|(
name|try_next
condition|)
comment|/* Loop for items in this branch */
block|{
name|int
name|rc
decl_stmt|;
switch|switch
condition|(
operator|*
name|tcode
condition|)
block|{
comment|/* If we reach something we don't understand, it means a new opcode has       been created that hasn't been added to this code. Hopefully this problem       will be discovered during testing. */
default|default:
return|return
name|SSB_UNKNOWN
return|;
comment|/* Fail for a valid opcode that implies no starting bits. */
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ANYBYTE
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_CLOSE
case|:
case|case
name|OP_COMMIT
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_CREF
case|:
case|case
name|OP_DEF
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
case|case
name|OP_END
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_FAIL
case|:
case|case
name|OP_MARK
case|:
case|case
name|OP_NCREF
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_NRREF
case|:
case|case
name|OP_PROP
case|:
case|case
name|OP_PRUNE
case|:
case|case
name|OP_PRUNE_ARG
case|:
case|case
name|OP_RECURSE
case|:
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
case|case
name|OP_REVERSE
case|:
case|case
name|OP_RREF
case|:
case|case
name|OP_SCOND
case|:
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_SKIP
case|:
case|case
name|OP_SKIP_ARG
case|:
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_THEN
case|:
case|case
name|OP_THEN_ARG
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
endif|#
directive|endif
return|return
name|SSB_FAIL
return|;
comment|/* We can ignore word boundary tests. */
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
name|tcode
operator|++
expr_stmt|;
break|break;
comment|/* If we hit a bracket or a positive lookahead assertion, recurse to set       bits from within the subpattern. If it can't find anything, we have to       give up. If it finds some mandatory character(s), we are done for this       branch. Otherwise, carry on scanning after the subpattern. */
case|case
name|OP_BRA
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_ASSERT
case|:
name|rc
operator|=
name|set_start_bits
argument_list|(
name|tcode
argument_list|,
name|start_bits
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SSB_FAIL
operator|||
name|rc
operator|==
name|SSB_UNKNOWN
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|rc
operator|==
name|SSB_DONE
condition|)
name|try_next
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
do|do
name|tcode
operator|+=
name|GET
argument_list|(
name|tcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|tcode
operator|==
name|OP_ALT
condition|)
do|;
name|tcode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
break|break;
comment|/* If we hit ALT or KET, it means we haven't found anything mandatory in       this branch, though we might have found something optional. For ALT, we       continue with the next alternative, but we have to arrange that the final       result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,       return SSB_CONTINUE: if this is the top level, that indicates failure,       but after a nested subpattern, it causes scanning to continue. */
case|case
name|OP_ALT
case|:
name|yield
operator|=
name|SSB_CONTINUE
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_KET
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRPOS
case|:
return|return
name|SSB_CONTINUE
return|;
comment|/* Skip over callout */
case|case
name|OP_CALLOUT
case|:
name|tcode
operator|+=
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* Skip over lookbehind and negative lookahead assertions */
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
do|do
name|tcode
operator|+=
name|GET
argument_list|(
name|tcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|tcode
operator|==
name|OP_ALT
condition|)
do|;
name|tcode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* BRAZERO does the bracket, but carries on. */
case|case
name|OP_BRAZERO
case|:
case|case
name|OP_BRAMINZERO
case|:
case|case
name|OP_BRAPOSZERO
case|:
name|rc
operator|=
name|set_start_bits
argument_list|(
operator|++
name|tcode
argument_list|,
name|start_bits
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SSB_FAIL
operator|||
name|rc
operator|==
name|SSB_UNKNOWN
condition|)
return|return
name|rc
return|;
comment|/* =========================================================================       See the comment at the head of this function concerning the next line,       which was an old fudge for the benefit of OS/2.       dummy = 1;   ========================================================================= */
do|do
name|tcode
operator|+=
name|GET
argument_list|(
name|tcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|tcode
operator|==
name|OP_ALT
condition|)
do|;
name|tcode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* SKIPZERO skips the bracket. */
case|case
name|OP_SKIPZERO
case|:
name|tcode
operator|++
expr_stmt|;
do|do
name|tcode
operator|+=
name|GET
argument_list|(
name|tcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|tcode
operator|==
name|OP_ALT
condition|)
do|;
name|tcode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* Single-char * or ? sets the bit and tries the next item */
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_POSQUERY
case|:
name|tcode
operator|=
name|set_table_bit
argument_list|(
name|start_bits
argument_list|,
name|tcode
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|cd
argument_list|,
name|utf
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_POSQUERYI
case|:
name|tcode
operator|=
name|set_table_bit
argument_list|(
name|start_bits
argument_list|,
name|tcode
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|cd
argument_list|,
name|utf
argument_list|)
expr_stmt|;
break|break;
comment|/* Single-char upto sets the bit and tries the next */
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_POSUPTO
case|:
name|tcode
operator|=
name|set_table_bit
argument_list|(
name|start_bits
argument_list|,
name|tcode
operator|+
literal|1
operator|+
name|IMM2_SIZE
argument_list|,
name|FALSE
argument_list|,
name|cd
argument_list|,
name|utf
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_POSUPTOI
case|:
name|tcode
operator|=
name|set_table_bit
argument_list|(
name|start_bits
argument_list|,
name|tcode
operator|+
literal|1
operator|+
name|IMM2_SIZE
argument_list|,
name|TRUE
argument_list|,
name|cd
argument_list|,
name|utf
argument_list|)
expr_stmt|;
break|break;
comment|/* At least one single char sets the bit and stops */
case|case
name|OP_EXACT
case|:
name|tcode
operator|+=
name|IMM2_SIZE
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_CHAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_POSPLUS
case|:
operator|(
name|void
operator|)
name|set_table_bit
argument_list|(
name|start_bits
argument_list|,
name|tcode
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|cd
argument_list|,
name|utf
argument_list|)
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_EXACTI
case|:
name|tcode
operator|+=
name|IMM2_SIZE
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_CHARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_POSPLUSI
case|:
operator|(
name|void
operator|)
name|set_table_bit
argument_list|(
name|start_bits
argument_list|,
name|tcode
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|cd
argument_list|,
name|utf
argument_list|)
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* Special spacing and line-terminating items. These recognize specific       lists of characters. The difference between VSPACE and ANYNL is that the       latter can match the two-character CRLF sequence, but that is not       relevant for finding the first character, so their code here is       identical. */
case|case
name|OP_HSPACE
case|:
name|SET_BIT
argument_list|(
name|CHAR_HT
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_SPACE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|SET_BIT
argument_list|(
literal|0xC2
argument_list|)
expr_stmt|;
comment|/* For U+00A0 */
name|SET_BIT
argument_list|(
literal|0xE1
argument_list|)
expr_stmt|;
comment|/* For U+1680, U+180E */
name|SET_BIT
argument_list|(
literal|0xE2
argument_list|)
expr_stmt|;
comment|/* For U+2000 - U+200A, U+202F, U+205F */
name|SET_BIT
argument_list|(
literal|0xE3
argument_list|)
expr_stmt|;
comment|/* For U+3000 */
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|SET_BIT
argument_list|(
literal|0xA0
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* For characters> 255 */
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
block|{
ifndef|#
directive|ifndef
name|EBCDIC
name|SET_BIT
argument_list|(
literal|0xA0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not EBCDIC */
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|SET_BIT
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* For characters> 255 */
endif|#
directive|endif
comment|/* COMPILE_PCRE[16|32] */
block|}
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_ANYNL
case|:
case|case
name|OP_VSPACE
case|:
name|SET_BIT
argument_list|(
name|CHAR_LF
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_VT
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_FF
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_CR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|SET_BIT
argument_list|(
literal|0xC2
argument_list|)
expr_stmt|;
comment|/* For U+0085 */
name|SET_BIT
argument_list|(
literal|0xE2
argument_list|)
expr_stmt|;
comment|/* For U+2028, U+2029 */
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|SET_BIT
argument_list|(
name|CHAR_NEL
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* For characters> 255 */
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
block|{
name|SET_BIT
argument_list|(
name|CHAR_NEL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|SET_BIT
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* For characters> 255 */
endif|#
directive|endif
block|}
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* Single character types set the bits and stop. Note that if PCRE_UCP       is set, we do not see these op codes because \d etc are converted to       properties. Therefore, these apply in the case when only characters less       than 256 are recognized to match the types. */
case|case
name|OP_NOT_DIGIT
case|:
name|set_nottype_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_digit
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_DIGIT
case|:
name|set_type_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_digit
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* The cbit_space table has vertical tab as whitespace; we have to       ensure it is set as not whitespace. Luckily, the code value is the same       (0x0b) in ASCII and EBCDIC, so we can just adjust the appropriate bit. */
case|case
name|OP_NOT_WHITESPACE
case|:
name|set_nottype_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_space
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|start_bits
index|[
literal|1
index|]
operator||=
literal|0x08
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* The cbit_space table has vertical tab as whitespace; we have to not       set it from the table. Luckily, the code value is the same (0x0b) in       ASCII and EBCDIC, so we can just adjust the appropriate bit. */
case|case
name|OP_WHITESPACE
case|:
name|c
operator|=
name|start_bits
index|[
literal|1
index|]
expr_stmt|;
comment|/* Save in case it was already set */
name|set_type_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_space
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|start_bits
index|[
literal|1
index|]
operator|=
operator|(
name|start_bits
index|[
literal|1
index|]
operator|&
operator|~
literal|0x08
operator|)
operator||
name|c
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
name|set_nottype_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_word
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OP_WORDCHAR
case|:
name|set_type_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_word
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* One or more character type fudges the pointer and restarts, knowing       it will hit a single character type and stop there. */
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
name|tcode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_TYPEEXACT
case|:
name|tcode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
comment|/* Zero or more repeats of character types set the bits and then       try again. */
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
name|tcode
operator|+=
name|IMM2_SIZE
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
switch|switch
condition|(
name|tcode
index|[
literal|1
index|]
condition|)
block|{
default|default:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
return|return
name|SSB_FAIL
return|;
case|case
name|OP_HSPACE
case|:
name|SET_BIT
argument_list|(
name|CHAR_HT
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_SPACE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|SET_BIT
argument_list|(
literal|0xC2
argument_list|)
expr_stmt|;
comment|/* For U+00A0 */
name|SET_BIT
argument_list|(
literal|0xE1
argument_list|)
expr_stmt|;
comment|/* For U+1680, U+180E */
name|SET_BIT
argument_list|(
literal|0xE2
argument_list|)
expr_stmt|;
comment|/* For U+2000 - U+200A, U+202F, U+205F */
name|SET_BIT
argument_list|(
literal|0xE3
argument_list|)
expr_stmt|;
comment|/* For U+3000 */
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|SET_BIT
argument_list|(
literal|0xA0
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* For characters> 255 */
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
ifndef|#
directive|ifndef
name|EBCDIC
name|SET_BIT
argument_list|(
literal|0xA0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not EBCDIC */
break|break;
case|case
name|OP_ANYNL
case|:
case|case
name|OP_VSPACE
case|:
name|SET_BIT
argument_list|(
name|CHAR_LF
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_VT
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_FF
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|CHAR_CR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|SET_BIT
argument_list|(
literal|0xC2
argument_list|)
expr_stmt|;
comment|/* For U+0085 */
name|SET_BIT
argument_list|(
literal|0xE2
argument_list|)
expr_stmt|;
comment|/* For U+2028, U+2029 */
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|SET_BIT
argument_list|(
name|CHAR_NEL
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* For characters> 255 */
endif|#
directive|endif
comment|/* COMPILE_PCRE16 */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|SET_BIT
argument_list|(
name|CHAR_NEL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_DIGIT
case|:
name|set_nottype_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_digit
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DIGIT
case|:
name|set_type_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_digit
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
break|break;
comment|/* The cbit_space table has vertical tab as whitespace; we have to         ensure it gets set as not whitespace. Luckily, the code value is the         same (0x0b) in ASCII and EBCDIC, so we can just adjust the appropriate         bit. */
case|case
name|OP_NOT_WHITESPACE
case|:
name|set_nottype_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_space
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|start_bits
index|[
literal|1
index|]
operator||=
literal|0x08
expr_stmt|;
break|break;
comment|/* The cbit_space table has vertical tab as whitespace; we have to         avoid setting it. Luckily, the code value is the same (0x0b) in ASCII         and EBCDIC, so we can just adjust the appropriate bit. */
case|case
name|OP_WHITESPACE
case|:
name|c
operator|=
name|start_bits
index|[
literal|1
index|]
expr_stmt|;
comment|/* Save in case it was already set */
name|set_type_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_space
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|start_bits
index|[
literal|1
index|]
operator|=
operator|(
name|start_bits
index|[
literal|1
index|]
operator|&
operator|~
literal|0x08
operator|)
operator||
name|c
expr_stmt|;
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
name|set_nottype_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_word
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WORDCHAR
case|:
name|set_type_bits
argument_list|(
name|start_bits
argument_list|,
name|cbit_word
argument_list|,
name|table_limit
argument_list|,
name|cd
argument_list|)
expr_stmt|;
break|break;
block|}
name|tcode
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* Character class where all the information is in a bit map: set the       bits and either carry on or not, according to the repeat count. If it was       a negative class, and we are operating with UTF-8 characters, any byte       with a value>= 0xc4 is a potentially valid starter because it starts a       character with a value> 255. */
case|case
name|OP_NCLASS
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|utf
condition|)
block|{
name|start_bits
index|[
literal|24
index|]
operator||=
literal|0xf0
expr_stmt|;
comment|/* Bits for 0xc4 - 0xc8 */
name|memset
argument_list|(
name|start_bits
operator|+
literal|25
argument_list|,
literal|0xff
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Bits for 0xc9 - 0xff */
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|SET_BIT
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* For characters> 255 */
endif|#
directive|endif
comment|/* Fall through */
case|case
name|OP_CLASS
case|:
block|{
name|pcre_uint8
modifier|*
name|map
decl_stmt|;
name|tcode
operator|++
expr_stmt|;
name|map
operator|=
operator|(
name|pcre_uint8
operator|*
operator|)
name|tcode
expr_stmt|;
comment|/* In UTF-8 mode, the bits in a bit map correspond to character         values, not to byte values. However, the bit map we are constructing is         for byte values. So we have to do a conversion for characters whose         value is> 127. In fact, there are only two possible starting bytes for         characters in the range 128 - 255. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|utf
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|16
condition|;
name|c
operator|++
control|)
name|start_bits
index|[
name|c
index|]
operator||=
name|map
index|[
name|c
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|128
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|map
index|[
name|c
operator|/
literal|8
index|]
operator|&&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|d
init|=
operator|(
name|c
operator|>>
literal|6
operator|)
operator||
literal|0xc0
decl_stmt|;
comment|/* Set bit for this starter */
name|start_bits
index|[
name|d
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|d
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
comment|/* and then skip on to the */
name|c
operator|=
operator|(
name|c
operator|&
literal|0xc0
operator|)
operator|+
literal|0x40
operator|-
literal|1
expr_stmt|;
comment|/* next relevant character. */
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
comment|/* In non-UTF-8 mode, the two bit maps are completely compatible. */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|start_bits
index|[
name|c
index|]
operator||=
name|map
index|[
name|c
index|]
expr_stmt|;
block|}
comment|/* Advance past the bit map, and act on what follows. For a zero         minimum repeat, continue; otherwise stop processing. */
name|tcode
operator|+=
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|tcode
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
name|tcode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
if|if
condition|(
name|GET2
argument_list|(
name|tcode
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|tcode
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
else|else
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|try_next
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
break|break;
comment|/* End of bitmap class handling */
block|}
comment|/* End of switch */
block|}
comment|/* End of try_next loop */
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Advance to next branch */
block|}
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
return|return
name|yield
return|;
block|}
end_function
begin_comment
comment|/************************************************* *          Study a compiled expression           * *************************************************/
end_comment
begin_comment
comment|/* This function is handed a compiled expression that it must study to produce information that will speed up the matching. It returns a pcre[16]_extra block which then gets handed back to pcre_exec().  Arguments:   re        points to the compiled expression   options   contains option bits   errorptr  points to where to place error messages;             set NULL unless error  Returns:    pointer to a pcre[16]_extra block, with study_data filled in and               the appropriate flags set;             NULL on error or if no optimization possible */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|pcre_extra
modifier|*
name|PCRE_CALL_CONVENTION
DECL|function|pcre_study
name|pcre_study
argument_list|(
specifier|const
name|pcre
operator|*
name|external_re
argument_list|,
name|int
name|options
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|pcre16_extra
modifier|*
name|PCRE_CALL_CONVENTION
name|pcre16_study
argument_list|(
specifier|const
name|pcre16
operator|*
name|external_re
argument_list|,
name|int
name|options
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|pcre32_extra
modifier|*
name|PCRE_CALL_CONVENTION
name|pcre32_study
argument_list|(
specifier|const
name|pcre32
operator|*
name|external_re
argument_list|,
name|int
name|options
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|)
endif|#
directive|endif
block|{
name|int
name|min
decl_stmt|;
name|BOOL
name|bits_set
init|=
name|FALSE
decl_stmt|;
name|pcre_uint8
name|start_bits
index|[
literal|32
index|]
decl_stmt|;
name|PUBL
argument_list|(
name|extra
argument_list|)
operator|*
name|extra
operator|=
name|NULL
expr_stmt|;
name|pcre_study_data
modifier|*
name|study
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|tables
decl_stmt|;
name|pcre_uchar
modifier|*
name|code
decl_stmt|;
name|compile_data
name|compile_block
decl_stmt|;
specifier|const
name|REAL_PCRE
modifier|*
name|re
init|=
operator|(
specifier|const
name|REAL_PCRE
operator|*
operator|)
name|external_re
decl_stmt|;
operator|*
name|errorptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|NULL
operator|||
name|re
operator|->
name|magic_number
operator|!=
name|MAGIC_NUMBER
condition|)
block|{
operator|*
name|errorptr
operator|=
literal|"argument is not a compiled regular expression"
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_MODE
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
operator|*
name|errorptr
operator|=
literal|"argument not compiled in 8 bit mode"
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|*
name|errorptr
operator|=
literal|"argument not compiled in 16 bit mode"
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
operator|*
name|errorptr
operator|=
literal|"argument not compiled in 32 bit mode"
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
operator|~
name|PUBLIC_STUDY_OPTIONS
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|errorptr
operator|=
literal|"unknown or incorrect option bit(s) set"
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|code
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
operator|+
operator|(
name|re
operator|->
name|name_count
operator|*
name|re
operator|->
name|name_entry_size
operator|)
expr_stmt|;
comment|/* For an anchored pattern, or an unanchored pattern that has a first char, or a multiline pattern that matches only at "line starts", there is no point in seeking a list of starting bytes. */
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|re
operator|->
name|flags
operator|&
operator|(
name|PCRE_FIRSTSET
operator||
name|PCRE_STARTLINE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* Set the character tables in the block that is passed around */
name|tables
operator|=
name|re
operator|->
name|tables
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|tables
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|pcre_fullinfo
argument_list|(
name|external_re
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_DEFAULT_TABLES
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|tables
operator|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|tables
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|pcre16_fullinfo
argument_list|(
name|external_re
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_DEFAULT_TABLES
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|tables
operator|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|tables
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|pcre32_fullinfo
argument_list|(
name|external_re
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_DEFAULT_TABLES
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|tables
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|compile_block
operator|.
name|lcc
operator|=
name|tables
operator|+
name|lcc_offset
expr_stmt|;
name|compile_block
operator|.
name|fcc
operator|=
name|tables
operator|+
name|fcc_offset
expr_stmt|;
name|compile_block
operator|.
name|cbits
operator|=
name|tables
operator|+
name|cbits_offset
expr_stmt|;
name|compile_block
operator|.
name|ctypes
operator|=
name|tables
operator|+
name|ctypes_offset
expr_stmt|;
comment|/* See if we can find a fixed set of initial characters for the pattern. */
name|memset
argument_list|(
name|start_bits
argument_list|,
literal|0
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|pcre_uint8
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|set_start_bits
argument_list|(
name|code
argument_list|,
name|start_bits
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
argument_list|,
operator|&
name|compile_block
argument_list|)
expr_stmt|;
name|bits_set
operator|=
name|rc
operator|==
name|SSB_DONE
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SSB_UNKNOWN
condition|)
block|{
operator|*
name|errorptr
operator|=
literal|"internal error: opcode not recognized"
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Find the minimum length of subject string. */
switch|switch
condition|(
name|min
operator|=
name|find_minlength
argument_list|(
name|code
argument_list|,
name|code
argument_list|,
name|re
operator|->
name|options
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
operator|-
literal|2
case|:
operator|*
name|errorptr
operator|=
literal|"internal error: missing capturing bracket"
expr_stmt|;
return|return
name|NULL
return|;
case|case
operator|-
literal|3
case|:
operator|*
name|errorptr
operator|=
literal|"internal error: opcode not recognized"
expr_stmt|;
return|return
name|NULL
return|;
default|default:
break|break;
block|}
comment|/* If a set of starting bytes has been identified, or if the minimum length is greater than zero, or if JIT optimization has been requested, or if PCRE_STUDY_EXTRA_NEEDED is set, get a pcre[16]_extra block and a pcre_study_data block. The study data is put in the latter, which is pointed to by the former, which may also get additional data set later by the calling program. At the moment, the size of pcre_study_data is fixed. We nevertheless save it in a field for returning via the pcre_fullinfo() function so that if it becomes variable in the future, we don't have to change that code. */
if|if
condition|(
name|bits_set
operator|||
name|min
operator|>
literal|0
operator|||
operator|(
name|options
operator|&
operator|(
ifdef|#
directive|ifdef
name|SUPPORT_JIT
name|PCRE_STUDY_JIT_COMPILE
operator||
name|PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
operator||
name|PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
operator||
endif|#
directive|endif
name|PCRE_STUDY_EXTRA_NEEDED
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|extra
operator|=
operator|(
name|PUBL
argument_list|(
name|extra
argument_list|)
operator|*
operator|)
operator|(
name|PUBL
argument_list|(
name|malloc
argument_list|)
operator|)
operator|(
sizeof|sizeof
argument_list|(
name|PUBL
argument_list|(
name|extra
argument_list|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|pcre_study_data
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extra
operator|==
name|NULL
condition|)
block|{
operator|*
name|errorptr
operator|=
literal|"failed to get memory"
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|study
operator|=
operator|(
name|pcre_study_data
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|extra
operator|+
sizeof|sizeof
argument_list|(
name|PUBL
argument_list|(
name|extra
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|extra
operator|->
name|flags
operator|=
name|PCRE_EXTRA_STUDY_DATA
expr_stmt|;
name|extra
operator|->
name|study_data
operator|=
name|study
expr_stmt|;
name|study
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|pcre_study_data
argument_list|)
expr_stmt|;
name|study
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Set the start bits always, to avoid unset memory errors if the   study data is written to a file, but set the flag only if any of the bits   are set, to save time looking when none are. */
if|if
condition|(
name|bits_set
condition|)
block|{
name|study
operator|->
name|flags
operator||=
name|PCRE_STUDY_MAPPED
expr_stmt|;
name|memcpy
argument_list|(
name|study
operator|->
name|start_bits
argument_list|,
name|start_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|start_bits
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|study
operator|->
name|start_bits
argument_list|,
literal|0
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|pcre_uint8
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
if|if
condition|(
name|bits_set
condition|)
block|{
name|pcre_uint8
modifier|*
name|ptr
init|=
name|start_bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Start bits:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%3d: %02x%s"
argument_list|,
name|i
operator|*
literal|8
argument_list|,
operator|*
name|ptr
operator|++
argument_list|,
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Always set the minlength value in the block, because the JIT compiler   makes use of it. However, don't set the bit unless the length is greater than   zero - the interpretive pcre_exec() and pcre_dfa_exec() needn't waste time   checking the zero case. */
if|if
condition|(
name|min
operator|>
literal|0
condition|)
block|{
name|study
operator|->
name|flags
operator||=
name|PCRE_STUDY_MINLEN
expr_stmt|;
name|study
operator|->
name|minlength
operator|=
name|min
expr_stmt|;
block|}
else|else
name|study
operator|->
name|minlength
operator|=
literal|0
expr_stmt|;
comment|/* If JIT support was compiled and requested, attempt the JIT compilation.   If no starting bytes were found, and the minimum length is zero, and JIT   compilation fails, abandon the extra block and return NULL, unless   PCRE_STUDY_EXTRA_NEEDED is set. */
ifdef|#
directive|ifdef
name|SUPPORT_JIT
name|extra
operator|->
name|executable_jit
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_STUDY_JIT_COMPILE
operator|)
operator|!=
literal|0
condition|)
name|PRIV
function_decl|(
name|jit_compile
function_decl|)
parameter_list|(
name|re
parameter_list|,
name|extra
parameter_list|,
name|JIT_COMPILE
parameter_list|)
function_decl|;
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
operator|)
operator|!=
literal|0
condition|)
name|PRIV
function_decl|(
name|jit_compile
function_decl|)
parameter_list|(
name|re
parameter_list|,
name|extra
parameter_list|,
name|JIT_PARTIAL_SOFT_COMPILE
parameter_list|)
function_decl|;
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
operator|)
operator|!=
literal|0
condition|)
name|PRIV
function_decl|(
name|jit_compile
function_decl|)
parameter_list|(
name|re
parameter_list|,
name|extra
parameter_list|,
name|JIT_PARTIAL_HARD_COMPILE
parameter_list|)
function_decl|;
if|if
condition|(
name|study
operator|->
name|flags
operator|==
literal|0
operator|&&
operator|(
name|extra
operator|->
name|flags
operator|&
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|options
operator|&
name|PCRE_STUDY_EXTRA_NEEDED
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|pcre_free_study
argument_list|(
name|extra
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|pcre16_free_study
argument_list|(
name|extra
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|pcre32_free_study
argument_list|(
name|extra
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|extra
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|extra
return|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *          Free the study data                   * *************************************************/
end_comment
begin_comment
comment|/* This function frees the memory that was obtained by pcre_study().  Argument:   a pointer to the pcre[16]_extra block Returns:    nothing */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|void
DECL|function|pcre_free_study
name|pcre_free_study
argument_list|(
name|pcre_extra
operator|*
name|extra
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|void
name|pcre16_free_study
argument_list|(
name|pcre16_extra
operator|*
name|extra
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|void
name|pcre32_free_study
argument_list|(
name|pcre32_extra
operator|*
name|extra
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|extra
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|SUPPORT_JIT
if|if
condition|(
operator|(
name|extra
operator|->
name|flags
operator|&
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|)
operator|!=
literal|0
operator|&&
name|extra
operator|->
name|executable_jit
operator|!=
name|NULL
condition|)
name|PRIV
function_decl|(
name|jit_free
function_decl|)
parameter_list|(
name|extra
operator|->
name|executable_jit
parameter_list|)
function_decl|;
endif|#
directive|endif
name|PUBL
function_decl|(
name|free
function_decl|)
parameter_list|(
name|extra
parameter_list|)
function_decl|;
block|}
end_decl_stmt
begin_comment
comment|/* End of pcre_study.c */
end_comment
end_unit
