begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2012 University of Cambridge    The machine code generator part (this module) was written by Zoltan Herczeg                       Copyright (c) 2010-2012  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_if
if|#
directive|if
name|defined
name|SUPPORT_JIT
end_if
begin_comment
comment|/* All-in-one: Since we use the JIT compiler only from here, we just include it. This way we don't need to touch the build system files. */
end_comment
begin_define
DECL|macro|SLJIT_MALLOC
define|#
directive|define
name|SLJIT_MALLOC
parameter_list|(
name|size
parameter_list|)
value|(PUBL(malloc))(size)
end_define
begin_define
DECL|macro|SLJIT_FREE
define|#
directive|define
name|SLJIT_FREE
parameter_list|(
name|ptr
parameter_list|)
value|(PUBL(free))(ptr)
end_define
begin_define
DECL|macro|SLJIT_CONFIG_AUTO
define|#
directive|define
name|SLJIT_CONFIG_AUTO
value|1
end_define
begin_define
DECL|macro|SLJIT_CONFIG_STATIC
define|#
directive|define
name|SLJIT_CONFIG_STATIC
value|1
end_define
begin_define
DECL|macro|SLJIT_VERBOSE
define|#
directive|define
name|SLJIT_VERBOSE
value|0
end_define
begin_define
DECL|macro|SLJIT_DEBUG
define|#
directive|define
name|SLJIT_DEBUG
value|0
end_define
begin_include
include|#
directive|include
file|"sljit/sljitLir.c"
end_include
begin_if
if|#
directive|if
name|defined
name|SLJIT_CONFIG_UNSUPPORTED
operator|&&
name|SLJIT_CONFIG_UNSUPPORTED
end_if
begin_error
error|#
directive|error
error|Unsupported architecture
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Allocate memory for the regex stack on the real machine stack. Fast, but limited size. */
end_comment
begin_define
DECL|macro|MACHINE_STACK_SIZE
define|#
directive|define
name|MACHINE_STACK_SIZE
value|32768
end_define
begin_comment
comment|/* Growth rate for stack allocated by the OS. Should be the multiply of page size. */
end_comment
begin_define
DECL|macro|STACK_GROWTH_RATE
define|#
directive|define
name|STACK_GROWTH_RATE
value|8192
end_define
begin_comment
comment|/* Enable to check that the allocation could destroy temporaries. */
end_comment
begin_if
if|#
directive|if
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
end_if
begin_define
DECL|macro|DESTROY_REGISTERS
define|#
directive|define
name|DESTROY_REGISTERS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Short summary about the backtracking mechanism empolyed by the jit code generator:  The code generator follows the recursive nature of the PERL compatible regular expressions. The basic blocks of regular expressions are condition checkers whose execute different commands depending on the result of the condition check. The relationship between the operators can be horizontal (concatenation) and vertical (sub-expression) (See struct backtrack_common for more details).    'ab' - 'a' and 'b' regexps are concatenated   'a+' - 'a' is the sub-expression of the '+' operator  The condition checkers are boolean (true/false) checkers. Machine code is generated for the checker itself and for the actions depending on the result of the checker. The 'true' case is called as the matching path (expected path), and the other is called as the 'backtrack' path. Branch instructions are expesive for all CPUs, so we avoid taken branches on the matching path.   Greedy star operator (*) :    Matching path: match happens.    Backtrack path: match failed.  Non-greedy star operator (*?) :    Matching path: no need to perform a match.    Backtrack path: match is required.  The following example shows how the code generated for a capturing bracket with two alternatives. Let A, B, C, D are arbirary regular expressions, and we have the following regular expression:     A(B|C)D  The generated code will be the following:   A matching path  '(' matching path (pushing arguments to the stack)  B matching path  ')' matching path (pushing arguments to the stack)  D matching path  return with successful match   D backtrack path  ')' backtrack path (If we arrived from "C" jump to the backtrack of "C")  B backtrack path  C expected path  jump to D matching path  C backtrack path  A backtrack path   Notice, that the order of backtrack code paths are the opposite of the fast  code paths. In this way the topmost value on the stack is always belong  to the current backtrack code path. The backtrack path must check  whether there is a next alternative. If so, it needs to jump back to  the matching path eventually. Otherwise it needs to clear out its own stack  frame and continue the execution on the backtrack code paths. */
end_comment
begin_comment
comment|/* Saved stack frames:  Atomic blocks and asserts require reloading the values of private data when the backtrack mechanism performed. Because of OP_RECURSE, the data are not necessarly known in compile time, thus we need a dynamic restore mechanism.  The stack frames are stored in a chain list, and have the following format: ([ capturing bracket offset ][ start value ][ end value ])+ ... [ 0 ] [ previous head ]  Thus we can restore the private data to a particular point in the stack. */
end_comment
begin_typedef
DECL|struct|jit_arguments
typedef|typedef
struct|struct
name|jit_arguments
block|{
comment|/* Pointers first. */
DECL|member|stack
name|struct
name|sljit_stack
modifier|*
name|stack
decl_stmt|;
DECL|member|str
specifier|const
name|pcre_uchar
modifier|*
name|str
decl_stmt|;
DECL|member|begin
specifier|const
name|pcre_uchar
modifier|*
name|begin
decl_stmt|;
DECL|member|end
specifier|const
name|pcre_uchar
modifier|*
name|end
decl_stmt|;
DECL|member|offsets
name|int
modifier|*
name|offsets
decl_stmt|;
DECL|member|uchar_ptr
name|pcre_uchar
modifier|*
name|uchar_ptr
decl_stmt|;
DECL|member|mark_ptr
name|pcre_uchar
modifier|*
name|mark_ptr
decl_stmt|;
comment|/* Everything else after. */
DECL|member|offsetcount
name|int
name|offsetcount
decl_stmt|;
DECL|member|calllimit
name|int
name|calllimit
decl_stmt|;
DECL|member|notbol
name|pcre_uint8
name|notbol
decl_stmt|;
DECL|member|noteol
name|pcre_uint8
name|noteol
decl_stmt|;
DECL|member|notempty
name|pcre_uint8
name|notempty
decl_stmt|;
DECL|member|notempty_atstart
name|pcre_uint8
name|notempty_atstart
decl_stmt|;
block|}
DECL|typedef|jit_arguments
name|jit_arguments
typedef|;
end_typedef
begin_typedef
DECL|struct|executable_functions
typedef|typedef
struct|struct
name|executable_functions
block|{
DECL|member|executable_funcs
name|void
modifier|*
name|executable_funcs
index|[
name|JIT_NUMBER_OF_COMPILE_MODES
index|]
decl_stmt|;
name|PUBL
argument_list|(
argument|jit_callback
argument_list|)
name|callback
expr_stmt|;
DECL|member|userdata
name|void
modifier|*
name|userdata
decl_stmt|;
DECL|member|top_bracket
name|pcre_uint32
name|top_bracket
decl_stmt|;
DECL|member|executable_sizes
name|sljit_uw
name|executable_sizes
index|[
name|JIT_NUMBER_OF_COMPILE_MODES
index|]
decl_stmt|;
block|}
DECL|typedef|executable_functions
name|executable_functions
typedef|;
end_typedef
begin_typedef
DECL|struct|jump_list
typedef|typedef
struct|struct
name|jump_list
block|{
DECL|member|jump
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
DECL|member|next
name|struct
name|jump_list
modifier|*
name|next
decl_stmt|;
block|}
DECL|typedef|jump_list
name|jump_list
typedef|;
end_typedef
begin_enum
DECL|enum|stub_types
DECL|enumerator|stack_alloc
enum|enum
name|stub_types
block|{
name|stack_alloc
block|}
enum|;
end_enum
begin_typedef
DECL|struct|stub_list
typedef|typedef
struct|struct
name|stub_list
block|{
DECL|member|type
name|enum
name|stub_types
name|type
decl_stmt|;
DECL|member|data
name|int
name|data
decl_stmt|;
DECL|member|start
name|struct
name|sljit_jump
modifier|*
name|start
decl_stmt|;
DECL|member|quit
name|struct
name|sljit_label
modifier|*
name|quit
decl_stmt|;
DECL|member|next
name|struct
name|stub_list
modifier|*
name|next
decl_stmt|;
block|}
DECL|typedef|stub_list
name|stub_list
typedef|;
end_typedef
begin_typedef
DECL|typedef|jit_function
typedef|typedef
name|int
function_decl|(
name|SLJIT_CALL
modifier|*
name|jit_function
function_decl|)
parameter_list|(
name|jit_arguments
modifier|*
name|args
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/* The following structure is the key data type for the recursive code generator. It is allocated by compile_matchingpath, and contains the aguments for compile_backtrackingpath. Must be the first member of its descendants. */
end_comment
begin_typedef
DECL|struct|backtrack_common
typedef|typedef
struct|struct
name|backtrack_common
block|{
comment|/* Concatenation stack. */
DECL|member|prev
name|struct
name|backtrack_common
modifier|*
name|prev
decl_stmt|;
DECL|member|nextbacktracks
name|jump_list
modifier|*
name|nextbacktracks
decl_stmt|;
comment|/* Internal stack (for component operators). */
DECL|member|top
name|struct
name|backtrack_common
modifier|*
name|top
decl_stmt|;
DECL|member|topbacktracks
name|jump_list
modifier|*
name|topbacktracks
decl_stmt|;
comment|/* Opcode pointer. */
DECL|member|cc
name|pcre_uchar
modifier|*
name|cc
decl_stmt|;
block|}
DECL|typedef|backtrack_common
name|backtrack_common
typedef|;
end_typedef
begin_typedef
DECL|struct|assert_backtrack
typedef|typedef
struct|struct
name|assert_backtrack
block|{
DECL|member|common
name|backtrack_common
name|common
decl_stmt|;
DECL|member|condfailed
name|jump_list
modifier|*
name|condfailed
decl_stmt|;
comment|/* Less than 0 (-1) if a frame is not needed. */
DECL|member|framesize
name|int
name|framesize
decl_stmt|;
comment|/* Points to our private memory word on the stack. */
DECL|member|private_data_ptr
name|int
name|private_data_ptr
decl_stmt|;
comment|/* For iterators. */
DECL|member|matchingpath
name|struct
name|sljit_label
modifier|*
name|matchingpath
decl_stmt|;
block|}
DECL|typedef|assert_backtrack
name|assert_backtrack
typedef|;
end_typedef
begin_typedef
DECL|struct|bracket_backtrack
typedef|typedef
struct|struct
name|bracket_backtrack
block|{
DECL|member|common
name|backtrack_common
name|common
decl_stmt|;
comment|/* Where to coninue if an alternative is successfully matched. */
DECL|member|alternative_matchingpath
name|struct
name|sljit_label
modifier|*
name|alternative_matchingpath
decl_stmt|;
comment|/* For rmin and rmax iterators. */
DECL|member|recursive_matchingpath
name|struct
name|sljit_label
modifier|*
name|recursive_matchingpath
decl_stmt|;
comment|/* For greedy ? operator. */
DECL|member|zero_matchingpath
name|struct
name|sljit_label
modifier|*
name|zero_matchingpath
decl_stmt|;
comment|/* Contains the branches of a failed condition. */
union|union
block|{
comment|/* Both for OP_COND, OP_SCOND. */
DECL|member|condfailed
name|jump_list
modifier|*
name|condfailed
decl_stmt|;
DECL|member|assert
name|assert_backtrack
modifier|*
name|assert
decl_stmt|;
comment|/* For OP_ONCE. -1 if not needed. */
DECL|member|framesize
name|int
name|framesize
decl_stmt|;
block|}
DECL|member|u
name|u
union|;
comment|/* Points to our private memory word on the stack. */
DECL|member|private_data_ptr
name|int
name|private_data_ptr
decl_stmt|;
block|}
DECL|typedef|bracket_backtrack
name|bracket_backtrack
typedef|;
end_typedef
begin_typedef
DECL|struct|bracketpos_backtrack
typedef|typedef
struct|struct
name|bracketpos_backtrack
block|{
DECL|member|common
name|backtrack_common
name|common
decl_stmt|;
comment|/* Points to our private memory word on the stack. */
DECL|member|private_data_ptr
name|int
name|private_data_ptr
decl_stmt|;
comment|/* Reverting stack is needed. */
DECL|member|framesize
name|int
name|framesize
decl_stmt|;
comment|/* Allocated stack size. */
DECL|member|stacksize
name|int
name|stacksize
decl_stmt|;
block|}
DECL|typedef|bracketpos_backtrack
name|bracketpos_backtrack
typedef|;
end_typedef
begin_typedef
DECL|struct|braminzero_backtrack
typedef|typedef
struct|struct
name|braminzero_backtrack
block|{
DECL|member|common
name|backtrack_common
name|common
decl_stmt|;
DECL|member|matchingpath
name|struct
name|sljit_label
modifier|*
name|matchingpath
decl_stmt|;
block|}
DECL|typedef|braminzero_backtrack
name|braminzero_backtrack
typedef|;
end_typedef
begin_typedef
DECL|struct|iterator_backtrack
typedef|typedef
struct|struct
name|iterator_backtrack
block|{
DECL|member|common
name|backtrack_common
name|common
decl_stmt|;
comment|/* Next iteration. */
DECL|member|matchingpath
name|struct
name|sljit_label
modifier|*
name|matchingpath
decl_stmt|;
block|}
DECL|typedef|iterator_backtrack
name|iterator_backtrack
typedef|;
end_typedef
begin_typedef
DECL|struct|recurse_entry
typedef|typedef
struct|struct
name|recurse_entry
block|{
DECL|member|next
name|struct
name|recurse_entry
modifier|*
name|next
decl_stmt|;
comment|/* Contains the function entry. */
DECL|member|entry
name|struct
name|sljit_label
modifier|*
name|entry
decl_stmt|;
comment|/* Collects the calls until the function is not created. */
DECL|member|calls
name|jump_list
modifier|*
name|calls
decl_stmt|;
comment|/* Points to the starting opcode. */
DECL|member|start
name|int
name|start
decl_stmt|;
block|}
DECL|typedef|recurse_entry
name|recurse_entry
typedef|;
end_typedef
begin_typedef
DECL|struct|recurse_backtrack
typedef|typedef
struct|struct
name|recurse_backtrack
block|{
DECL|member|common
name|backtrack_common
name|common
decl_stmt|;
block|}
DECL|typedef|recurse_backtrack
name|recurse_backtrack
typedef|;
end_typedef
begin_define
DECL|macro|MAX_RANGE_SIZE
define|#
directive|define
name|MAX_RANGE_SIZE
value|6
end_define
begin_typedef
DECL|struct|compiler_common
typedef|typedef
struct|struct
name|compiler_common
block|{
DECL|member|compiler
name|struct
name|sljit_compiler
modifier|*
name|compiler
decl_stmt|;
DECL|member|start
name|pcre_uchar
modifier|*
name|start
decl_stmt|;
comment|/* Maps private data offset to each opcode. */
DECL|member|private_data_ptrs
name|int
modifier|*
name|private_data_ptrs
decl_stmt|;
comment|/* Tells whether the capturing bracket is optimized. */
DECL|member|optimized_cbracket
name|pcre_uint8
modifier|*
name|optimized_cbracket
decl_stmt|;
comment|/* Starting offset of private data for capturing brackets. */
DECL|member|cbraptr
name|int
name|cbraptr
decl_stmt|;
comment|/* OVector starting point. Must be divisible by 2. */
DECL|member|ovector_start
name|int
name|ovector_start
decl_stmt|;
comment|/* Last known position of the requested byte. */
DECL|member|req_char_ptr
name|int
name|req_char_ptr
decl_stmt|;
comment|/* Head of the last recursion. */
DECL|member|recursive_head
name|int
name|recursive_head
decl_stmt|;
comment|/* First inspected character for partial matching. */
DECL|member|start_used_ptr
name|int
name|start_used_ptr
decl_stmt|;
comment|/* Starting pointer for partial soft matches. */
DECL|member|hit_start
name|int
name|hit_start
decl_stmt|;
comment|/* End pointer of the first line. */
DECL|member|first_line_end
name|int
name|first_line_end
decl_stmt|;
comment|/* Points to the marked string. */
DECL|member|mark_ptr
name|int
name|mark_ptr
decl_stmt|;
comment|/* Flipped and lower case tables. */
DECL|member|fcc
specifier|const
name|pcre_uint8
modifier|*
name|fcc
decl_stmt|;
DECL|member|lcc
name|sljit_sw
name|lcc
decl_stmt|;
comment|/* Mode can be PCRE_STUDY_JIT_COMPILE and others. */
DECL|member|mode
name|int
name|mode
decl_stmt|;
comment|/* Newline control. */
DECL|member|nltype
name|int
name|nltype
decl_stmt|;
DECL|member|newline
name|int
name|newline
decl_stmt|;
DECL|member|bsr_nltype
name|int
name|bsr_nltype
decl_stmt|;
comment|/* Dollar endonly. */
DECL|member|endonly
name|int
name|endonly
decl_stmt|;
DECL|member|has_set_som
name|BOOL
name|has_set_som
decl_stmt|;
comment|/* Tables. */
DECL|member|ctypes
name|sljit_sw
name|ctypes
decl_stmt|;
DECL|member|digits
name|int
name|digits
index|[
literal|2
operator|+
name|MAX_RANGE_SIZE
index|]
decl_stmt|;
comment|/* Named capturing brackets. */
DECL|member|name_table
name|sljit_uw
name|name_table
decl_stmt|;
DECL|member|name_count
name|sljit_sw
name|name_count
decl_stmt|;
DECL|member|name_entry_size
name|sljit_sw
name|name_entry_size
decl_stmt|;
comment|/* Labels and jump lists. */
DECL|member|partialmatchlabel
name|struct
name|sljit_label
modifier|*
name|partialmatchlabel
decl_stmt|;
DECL|member|quitlabel
name|struct
name|sljit_label
modifier|*
name|quitlabel
decl_stmt|;
DECL|member|acceptlabel
name|struct
name|sljit_label
modifier|*
name|acceptlabel
decl_stmt|;
DECL|member|stubs
name|stub_list
modifier|*
name|stubs
decl_stmt|;
DECL|member|entries
name|recurse_entry
modifier|*
name|entries
decl_stmt|;
DECL|member|currententry
name|recurse_entry
modifier|*
name|currententry
decl_stmt|;
DECL|member|partialmatch
name|jump_list
modifier|*
name|partialmatch
decl_stmt|;
DECL|member|quit
name|jump_list
modifier|*
name|quit
decl_stmt|;
DECL|member|accept
name|jump_list
modifier|*
name|accept
decl_stmt|;
DECL|member|calllimit
name|jump_list
modifier|*
name|calllimit
decl_stmt|;
DECL|member|stackalloc
name|jump_list
modifier|*
name|stackalloc
decl_stmt|;
DECL|member|revertframes
name|jump_list
modifier|*
name|revertframes
decl_stmt|;
DECL|member|wordboundary
name|jump_list
modifier|*
name|wordboundary
decl_stmt|;
DECL|member|anynewline
name|jump_list
modifier|*
name|anynewline
decl_stmt|;
DECL|member|hspace
name|jump_list
modifier|*
name|hspace
decl_stmt|;
DECL|member|vspace
name|jump_list
modifier|*
name|vspace
decl_stmt|;
DECL|member|casefulcmp
name|jump_list
modifier|*
name|casefulcmp
decl_stmt|;
DECL|member|caselesscmp
name|jump_list
modifier|*
name|caselesscmp
decl_stmt|;
DECL|member|jscript_compat
name|BOOL
name|jscript_compat
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
DECL|member|utf
name|BOOL
name|utf
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
DECL|member|use_ucp
name|BOOL
name|use_ucp
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|COMPILE_PCRE32
DECL|member|utfreadchar
name|jump_list
modifier|*
name|utfreadchar
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
DECL|member|utfreadtype8
name|jump_list
modifier|*
name|utfreadtype8
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
DECL|member|getucd
name|jump_list
modifier|*
name|getucd
decl_stmt|;
endif|#
directive|endif
block|}
DECL|typedef|compiler_common
name|compiler_common
typedef|;
end_typedef
begin_comment
comment|/* For byte_sequence_compare. */
end_comment
begin_typedef
DECL|struct|compare_context
typedef|typedef
struct|struct
name|compare_context
block|{
DECL|member|length
name|int
name|length
decl_stmt|;
DECL|member|sourcereg
name|int
name|sourcereg
decl_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
DECL|member|ucharptr
name|int
name|ucharptr
decl_stmt|;
union|union
block|{
DECL|member|asint
name|sljit_si
name|asint
decl_stmt|;
DECL|member|asushort
name|sljit_uh
name|asushort
decl_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
DECL|member|asbyte
name|sljit_ub
name|asbyte
decl_stmt|;
DECL|member|asuchars
name|sljit_ub
name|asuchars
index|[
literal|4
index|]
decl_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
DECL|member|asuchars
name|sljit_uh
name|asuchars
index|[
literal|2
index|]
decl_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
DECL|member|asuchars
name|sljit_ui
name|asuchars
index|[
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
block|}
DECL|member|c
name|c
union|;
union|union
block|{
DECL|member|asint
name|sljit_si
name|asint
decl_stmt|;
DECL|member|asushort
name|sljit_uh
name|asushort
decl_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
DECL|member|asbyte
name|sljit_ub
name|asbyte
decl_stmt|;
DECL|member|asuchars
name|sljit_ub
name|asuchars
index|[
literal|4
index|]
decl_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
DECL|member|asuchars
name|sljit_uh
name|asuchars
index|[
literal|2
index|]
decl_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
DECL|member|asuchars
name|sljit_ui
name|asuchars
index|[
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
block|}
DECL|member|oc
name|oc
union|;
endif|#
directive|endif
block|}
DECL|typedef|compare_context
name|compare_context
typedef|;
end_typedef
begin_enum
enum|enum
block|{
DECL|enumerator|frame_end
name|frame_end
init|=
literal|0
block|,
DECL|enumerator|frame_setstrbegin
name|frame_setstrbegin
init|=
operator|-
literal|1
block|,
DECL|enumerator|frame_setmark
name|frame_setmark
init|=
operator|-
literal|2
block|}
enum|;
end_enum
begin_comment
comment|/* Undefine sljit macros. */
end_comment
begin_undef
DECL|macro|CMP
undef|#
directive|undef
name|CMP
end_undef
begin_comment
comment|/* Used for accessing the elements of the stack. */
end_comment
begin_define
DECL|macro|STACK
define|#
directive|define
name|STACK
parameter_list|(
name|i
parameter_list|)
value|((-(i) - 1) * (int)sizeof(sljit_sw))
end_define
begin_define
DECL|macro|TMP1
define|#
directive|define
name|TMP1
value|SLJIT_SCRATCH_REG1
end_define
begin_define
DECL|macro|TMP2
define|#
directive|define
name|TMP2
value|SLJIT_SCRATCH_REG3
end_define
begin_define
DECL|macro|TMP3
define|#
directive|define
name|TMP3
value|SLJIT_TEMPORARY_EREG2
end_define
begin_define
DECL|macro|STR_PTR
define|#
directive|define
name|STR_PTR
value|SLJIT_SAVED_REG1
end_define
begin_define
DECL|macro|STR_END
define|#
directive|define
name|STR_END
value|SLJIT_SAVED_REG2
end_define
begin_define
DECL|macro|STACK_TOP
define|#
directive|define
name|STACK_TOP
value|SLJIT_SCRATCH_REG2
end_define
begin_define
DECL|macro|STACK_LIMIT
define|#
directive|define
name|STACK_LIMIT
value|SLJIT_SAVED_REG3
end_define
begin_define
DECL|macro|ARGUMENTS
define|#
directive|define
name|ARGUMENTS
value|SLJIT_SAVED_EREG1
end_define
begin_define
DECL|macro|CALL_COUNT
define|#
directive|define
name|CALL_COUNT
value|SLJIT_SAVED_EREG2
end_define
begin_define
DECL|macro|RETURN_ADDR
define|#
directive|define
name|RETURN_ADDR
value|SLJIT_TEMPORARY_EREG1
end_define
begin_comment
comment|/* Local space layout. */
end_comment
begin_comment
comment|/* These two locals can be used by the current opcode. */
end_comment
begin_define
DECL|macro|LOCALS0
define|#
directive|define
name|LOCALS0
value|(0 * sizeof(sljit_sw))
end_define
begin_define
DECL|macro|LOCALS1
define|#
directive|define
name|LOCALS1
value|(1 * sizeof(sljit_sw))
end_define
begin_comment
comment|/* Two local variables for possessive quantifiers (char1 cannot use them). */
end_comment
begin_define
DECL|macro|POSSESSIVE0
define|#
directive|define
name|POSSESSIVE0
value|(2 * sizeof(sljit_sw))
end_define
begin_define
DECL|macro|POSSESSIVE1
define|#
directive|define
name|POSSESSIVE1
value|(3 * sizeof(sljit_sw))
end_define
begin_comment
comment|/* Max limit of recursions. */
end_comment
begin_define
DECL|macro|CALL_LIMIT
define|#
directive|define
name|CALL_LIMIT
value|(4 * sizeof(sljit_sw))
end_define
begin_comment
comment|/* The output vector is stored on the stack, and contains pointers to characters. The vector data is divided into two groups: the first group contains the start / end character pointers, and the second is the start pointers when the end of the capturing group has not yet reached. */
end_comment
begin_define
DECL|macro|OVECTOR_START
define|#
directive|define
name|OVECTOR_START
value|(common->ovector_start)
end_define
begin_define
DECL|macro|OVECTOR
define|#
directive|define
name|OVECTOR
parameter_list|(
name|i
parameter_list|)
value|(OVECTOR_START + (i) * sizeof(sljit_sw))
end_define
begin_define
DECL|macro|OVECTOR_PRIV
define|#
directive|define
name|OVECTOR_PRIV
parameter_list|(
name|i
parameter_list|)
value|(common->cbraptr + (i) * sizeof(sljit_sw))
end_define
begin_define
DECL|macro|PRIVATE_DATA
define|#
directive|define
name|PRIVATE_DATA
parameter_list|(
name|cc
parameter_list|)
value|(common->private_data_ptrs[(cc) - common->start])
end_define
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_define
DECL|macro|MOV_UCHAR
define|#
directive|define
name|MOV_UCHAR
value|SLJIT_MOV_UB
end_define
begin_define
DECL|macro|MOVU_UCHAR
define|#
directive|define
name|MOVU_UCHAR
value|SLJIT_MOVU_UB
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_define
DECL|macro|MOV_UCHAR
define|#
directive|define
name|MOV_UCHAR
value|SLJIT_MOV_UH
end_define
begin_define
DECL|macro|MOVU_UCHAR
define|#
directive|define
name|MOVU_UCHAR
value|SLJIT_MOVU_UH
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_define
DECL|macro|MOV_UCHAR
define|#
directive|define
name|MOV_UCHAR
value|SLJIT_MOV_UI
end_define
begin_define
DECL|macro|MOVU_UCHAR
define|#
directive|define
name|MOVU_UCHAR
value|SLJIT_MOVU_UI
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Unsupported compiling mode
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Shortcuts. */
end_comment
begin_define
DECL|macro|DEFINE_COMPILER
define|#
directive|define
name|DEFINE_COMPILER
define|\
value|struct sljit_compiler *compiler = common->compiler
end_define
begin_define
DECL|macro|OP1
define|#
directive|define
name|OP1
parameter_list|(
name|op
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))
end_define
begin_define
DECL|macro|OP2
define|#
directive|define
name|OP2
parameter_list|(
name|op
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src1
parameter_list|,
name|src1w
parameter_list|,
name|src2
parameter_list|,
name|src2w
parameter_list|)
define|\
value|sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))
end_define
begin_define
DECL|macro|LABEL
define|#
directive|define
name|LABEL
parameter_list|()
define|\
value|sljit_emit_label(compiler)
end_define
begin_define
DECL|macro|JUMP
define|#
directive|define
name|JUMP
parameter_list|(
name|type
parameter_list|)
define|\
value|sljit_emit_jump(compiler, (type))
end_define
begin_define
DECL|macro|JUMPTO
define|#
directive|define
name|JUMPTO
parameter_list|(
name|type
parameter_list|,
name|label
parameter_list|)
define|\
value|sljit_set_label(sljit_emit_jump(compiler, (type)), (label))
end_define
begin_define
DECL|macro|JUMPHERE
define|#
directive|define
name|JUMPHERE
parameter_list|(
name|jump
parameter_list|)
define|\
value|sljit_set_label((jump), sljit_emit_label(compiler))
end_define
begin_define
DECL|macro|CMP
define|#
directive|define
name|CMP
parameter_list|(
name|type
parameter_list|,
name|src1
parameter_list|,
name|src1w
parameter_list|,
name|src2
parameter_list|,
name|src2w
parameter_list|)
define|\
value|sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))
end_define
begin_define
DECL|macro|CMPTO
define|#
directive|define
name|CMPTO
parameter_list|(
name|type
parameter_list|,
name|src1
parameter_list|,
name|src1w
parameter_list|,
name|src2
parameter_list|,
name|src2w
parameter_list|,
name|label
parameter_list|)
define|\
value|sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))
end_define
begin_define
DECL|macro|OP_FLAGS
define|#
directive|define
name|OP_FLAGS
parameter_list|(
name|op
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src
parameter_list|,
name|srcw
parameter_list|,
name|type
parameter_list|)
define|\
value|sljit_emit_op_flags(compiler, (op), (dst), (dstw), (src), (srcw), (type))
end_define
begin_define
DECL|macro|GET_LOCAL_BASE
define|#
directive|define
name|GET_LOCAL_BASE
parameter_list|(
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|offset
parameter_list|)
define|\
value|sljit_get_local_base(compiler, (dst), (dstw), (offset))
end_define
begin_function
DECL|function|bracketend
specifier|static
name|pcre_uchar
modifier|*
name|bracketend
parameter_list|(
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
operator|*
name|cc
operator|>=
name|OP_ASSERT
operator|&&
operator|*
name|cc
operator|<=
name|OP_ASSERTBACK_NOT
operator|)
operator|||
operator|(
operator|*
name|cc
operator|>=
name|OP_ONCE
operator|&&
operator|*
name|cc
operator|<=
name|OP_SCOND
operator|)
argument_list|)
expr_stmt|;
do|do
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|>=
name|OP_KET
operator|&&
operator|*
name|cc
operator|<=
name|OP_KETRPOS
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_comment
comment|/* Functions whose might need modification for all new supported opcodes:  next_opcode  get_private_data_length  set_private_data_ptrs  get_framesize  init_frame  get_private_data_length_for_copy  copy_private_data  compile_matchingpath  compile_backtrackingpath */
end_comment
begin_function
DECL|function|next_opcode
specifier|static
name|pcre_uchar
modifier|*
name|next_opcode
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|common
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYNL
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
case|case
name|OP_DEF
case|:
case|case
name|OP_BRAZERO
case|:
case|case
name|OP_BRAMINZERO
case|:
case|case
name|OP_BRAPOSZERO
case|:
case|case
name|OP_COMMIT
case|:
case|case
name|OP_FAIL
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
case|case
name|OP_SKIPZERO
case|:
return|return
name|cc
operator|+
literal|1
return|;
case|case
name|OP_ANYBYTE
case|:
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
return|return
name|cc
operator|+
literal|1
return|;
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cc
return|;
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
name|cc
operator|+=
literal|2
operator|+
name|IMM2_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cc
return|;
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
return|return
name|cc
operator|+
literal|1
operator|+
literal|2
return|;
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
case|case
name|OP_CREF
case|:
case|case
name|OP_NCREF
case|:
case|case
name|OP_RREF
case|:
case|case
name|OP_NRREF
case|:
case|case
name|OP_CLOSE
case|:
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
return|return
name|cc
operator|+
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
return|;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
return|return
name|cc
operator|+
literal|1
operator|+
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
return|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
return|return
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
return|;
endif|#
directive|endif
case|case
name|OP_RECURSE
case|:
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_REVERSE
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
case|case
name|OP_ALT
case|:
case|case
name|OP_KET
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRPOS
case|:
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
case|case
name|OP_CBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCBRAPOS
case|:
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
return|;
case|case
name|OP_MARK
case|:
return|return
name|cc
operator|+
literal|1
operator|+
literal|2
operator|+
name|cc
index|[
literal|1
index|]
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_define
DECL|macro|CASE_ITERATOR_PRIVATE_DATA_1
define|#
directive|define
name|CASE_ITERATOR_PRIVATE_DATA_1
define|\
value|case OP_MINSTAR: \     case OP_MINPLUS: \     case OP_QUERY: \     case OP_MINQUERY: \     case OP_MINSTARI: \     case OP_MINPLUSI: \     case OP_QUERYI: \     case OP_MINQUERYI: \     case OP_NOTMINSTAR: \     case OP_NOTMINPLUS: \     case OP_NOTQUERY: \     case OP_NOTMINQUERY: \     case OP_NOTMINSTARI: \     case OP_NOTMINPLUSI: \     case OP_NOTQUERYI: \     case OP_NOTMINQUERYI:
end_define
begin_define
DECL|macro|CASE_ITERATOR_PRIVATE_DATA_2A
define|#
directive|define
name|CASE_ITERATOR_PRIVATE_DATA_2A
define|\
value|case OP_STAR: \     case OP_PLUS: \     case OP_STARI: \     case OP_PLUSI: \     case OP_NOTSTAR: \     case OP_NOTPLUS: \     case OP_NOTSTARI: \     case OP_NOTPLUSI:
end_define
begin_define
DECL|macro|CASE_ITERATOR_PRIVATE_DATA_2B
define|#
directive|define
name|CASE_ITERATOR_PRIVATE_DATA_2B
define|\
value|case OP_UPTO: \     case OP_MINUPTO: \     case OP_UPTOI: \     case OP_MINUPTOI: \     case OP_NOTUPTO: \     case OP_NOTMINUPTO: \     case OP_NOTUPTOI: \     case OP_NOTMINUPTOI:
end_define
begin_define
DECL|macro|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
define|#
directive|define
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
define|\
value|case OP_TYPEMINSTAR: \     case OP_TYPEMINPLUS: \     case OP_TYPEQUERY: \     case OP_TYPEMINQUERY:
end_define
begin_define
DECL|macro|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
define|#
directive|define
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
define|\
value|case OP_TYPESTAR: \     case OP_TYPEPLUS:
end_define
begin_define
DECL|macro|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
define|#
directive|define
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
define|\
value|case OP_TYPEUPTO: \     case OP_TYPEMINUPTO:
end_define
begin_function
DECL|function|get_class_iterator_size
specifier|static
name|int
name|get_class_iterator_size
parameter_list|(
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRPLUS
case|:
return|return
literal|2
return|;
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
return|return
literal|1
return|;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
if|if
condition|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|==
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|2
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|get_private_data_length
specifier|static
name|int
name|get_private_data_length
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|)
block|{
name|int
name|private_data_length
init|=
literal|0
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
name|pcre_uchar
modifier|*
name|name
decl_stmt|;
name|pcre_uchar
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|int
name|space
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|;
name|pcre_uint32
name|bracketlen
decl_stmt|;
comment|/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
name|space
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|bracketlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SET_SOM
case|:
name|common
operator|->
name|has_set_som
operator|=
name|TRUE
expr_stmt|;
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
name|common
operator|->
name|optimized_cbracket
index|[
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
name|private_data_length
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|private_data_length
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|common
operator|->
name|optimized_cbracket
index|[
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
case|case
name|OP_SCOND
case|:
name|bracketlen
operator|=
name|cc
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
expr_stmt|;
if|if
condition|(
name|bracketlen
operator|==
name|OP_CREF
condition|)
block|{
name|bracketlen
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|common
operator|->
name|optimized_cbracket
index|[
name|bracketlen
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracketlen
operator|==
name|OP_NCREF
condition|)
block|{
name|bracketlen
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|common
operator|->
name|name_table
expr_stmt|;
name|alternative
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|common
operator|->
name|name_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET2
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|==
name|bracketlen
condition|)
break|break;
name|name
operator|+=
name|common
operator|->
name|name_entry_size
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
name|i
operator|!=
name|common
operator|->
name|name_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|common
operator|->
name|name_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|alternative
operator|+
name|IMM2_SIZE
argument_list|,
name|name
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
name|common
operator|->
name|optimized_cbracket
index|[
name|GET2
argument_list|(
name|alternative
argument_list|,
literal|0
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|alternative
operator|+=
name|common
operator|->
name|name_entry_size
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_COND
condition|)
block|{
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
name|private_data_length
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
else|else
name|private_data_length
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_BRA
case|:
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_1
name|space
init|=
literal|1
decl_stmt|;
name|size
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2A
name|space
init|=
literal|2
decl_stmt|;
name|size
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2B
name|space
init|=
literal|2
decl_stmt|;
name|size
operator|=
operator|-
operator|(
literal|2
operator|+
name|IMM2_SIZE
operator|)
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
name|space
init|=
literal|1
decl_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
if|if
condition|(
name|cc
index|[
literal|1
index|]
operator|!=
name|OP_ANYNL
operator|&&
name|cc
index|[
literal|1
index|]
operator|!=
name|OP_EXTUNI
condition|)
name|space
operator|=
literal|2
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
if|if
condition|(
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|!=
name|OP_ANYNL
operator|&&
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|!=
name|OP_EXTUNI
condition|)
name|space
operator|=
literal|2
expr_stmt|;
name|size
operator|=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
name|size
operator|+=
literal|1
operator|+
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
name|space
operator|=
name|get_class_iterator_size
argument_list|(
name|cc
operator|+
name|size
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
name|size
operator|=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|space
operator|=
name|get_class_iterator_size
argument_list|(
name|cc
operator|+
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|OP_RECURSE
case|:
comment|/* Set its value only once. */
if|if
condition|(
name|common
operator|->
name|recursive_head
operator|==
literal|0
condition|)
block|{
name|common
operator|->
name|recursive_head
operator|=
name|common
operator|->
name|ovector_start
expr_stmt|;
name|common
operator|->
name|ovector_start
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
if|if
condition|(
name|common
operator|->
name|mark_ptr
operator|==
literal|0
condition|)
block|{
name|common
operator|->
name|mark_ptr
operator|=
name|common
operator|->
name|ovector_start
expr_stmt|;
name|common
operator|->
name|ovector_start
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
literal|2
operator|+
name|cc
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
if|if
condition|(
name|space
operator|>
literal|0
operator|&&
name|cc
operator|>=
name|end
condition|)
name|private_data_length
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|*
name|space
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|cc
operator|+=
operator|-
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|cc
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|bracketlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|>=
name|end
condition|)
block|{
name|end
operator|=
name|bracketend
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
index|[
operator|-
literal|1
operator|-
name|LINK_SIZE
index|]
operator|==
name|OP_KET
condition|)
name|end
operator|=
name|NULL
expr_stmt|;
block|}
name|cc
operator|+=
name|bracketlen
expr_stmt|;
block|}
block|}
return|return
name|private_data_length
return|;
block|}
end_function
begin_function
DECL|function|set_private_data_ptrs
specifier|static
name|void
name|set_private_data_ptrs
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|private_data_ptr
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|cc
init|=
name|common
operator|->
name|start
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
name|pcre_uchar
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|int
name|space
decl_stmt|,
name|size
decl_stmt|,
name|bracketlen
decl_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
name|space
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|bracketlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
name|common
operator|->
name|private_data_ptrs
index|[
name|cc
operator|-
name|common
operator|->
name|start
index|]
operator|=
name|private_data_ptr
expr_stmt|;
name|private_data_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|common
operator|->
name|private_data_ptrs
index|[
name|cc
operator|-
name|common
operator|->
name|start
index|]
operator|=
name|private_data_ptr
expr_stmt|;
name|private_data_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
block|{
name|common
operator|->
name|private_data_ptrs
index|[
name|cc
operator|-
name|common
operator|->
name|start
index|]
operator|=
name|private_data_ptr
expr_stmt|;
name|private_data_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_BRA
case|:
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
name|bracketlen
operator|=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_1
name|space
init|=
literal|1
decl_stmt|;
name|size
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2A
name|space
init|=
literal|2
decl_stmt|;
name|size
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2B
name|space
init|=
literal|2
decl_stmt|;
name|size
operator|=
operator|-
operator|(
literal|2
operator|+
name|IMM2_SIZE
operator|)
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
name|space
init|=
literal|1
decl_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
if|if
condition|(
name|cc
index|[
literal|1
index|]
operator|!=
name|OP_ANYNL
operator|&&
name|cc
index|[
literal|1
index|]
operator|!=
name|OP_EXTUNI
condition|)
name|space
operator|=
literal|2
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
if|if
condition|(
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|!=
name|OP_ANYNL
operator|&&
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|!=
name|OP_EXTUNI
condition|)
name|space
operator|=
literal|2
expr_stmt|;
name|size
operator|=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
name|size
operator|+=
literal|1
operator|+
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
name|space
operator|=
name|get_class_iterator_size
argument_list|(
name|cc
operator|+
name|size
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
name|size
operator|=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|space
operator|=
name|get_class_iterator_size
argument_list|(
name|cc
operator|+
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|space
operator|>
literal|0
operator|&&
name|cc
operator|>=
name|end
condition|)
block|{
name|common
operator|->
name|private_data_ptrs
index|[
name|cc
operator|-
name|common
operator|->
name|start
index|]
operator|=
name|private_data_ptr
expr_stmt|;
name|private_data_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|*
name|space
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|cc
operator|+=
operator|-
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|cc
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|bracketlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|>=
name|end
condition|)
block|{
name|end
operator|=
name|bracketend
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
index|[
operator|-
literal|1
operator|-
name|LINK_SIZE
index|]
operator|==
name|OP_KET
condition|)
name|end
operator|=
name|NULL
expr_stmt|;
block|}
name|cc
operator|+=
name|bracketlen
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Returns with -1 if no need for frame. */
end_comment
begin_function
DECL|function|get_framesize
specifier|static
name|int
name|get_framesize
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|BOOL
name|recursive
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|ccend
init|=
name|bracketend
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|BOOL
name|possessive
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|setsom_found
init|=
name|recursive
decl_stmt|;
name|BOOL
name|setmark_found
init|=
name|recursive
decl_stmt|;
if|if
condition|(
operator|!
name|recursive
operator|&&
operator|(
operator|*
name|cc
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|cc
operator|==
name|OP_SCBRAPOS
operator|)
condition|)
block|{
name|length
operator|=
literal|3
expr_stmt|;
name|possessive
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SET_SOM
case|:
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|has_set_som
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setsom_found
condition|)
block|{
name|length
operator|+=
literal|2
expr_stmt|;
name|setsom_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setmark_found
condition|)
block|{
name|length
operator|+=
literal|2
expr_stmt|;
name|setmark_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
literal|2
operator|+
name|cc
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|OP_RECURSE
case|:
if|if
condition|(
name|common
operator|->
name|has_set_som
operator|&&
operator|!
name|setsom_found
condition|)
block|{
name|length
operator|+=
literal|2
expr_stmt|;
name|setsom_found
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
operator|&&
operator|!
name|setmark_found
condition|)
block|{
name|length
operator|+=
literal|2
expr_stmt|;
name|setmark_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCBRAPOS
case|:
name|length
operator|+=
literal|3
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Possessive quantifiers can use a special case. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|possessive
argument_list|)
operator|&&
name|length
operator|==
literal|3
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
return|return
name|length
operator|+
literal|1
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|init_frame
specifier|static
name|void
name|init_frame
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|int
name|stackpos
parameter_list|,
name|int
name|stacktop
parameter_list|,
name|BOOL
name|recursive
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|ccend
init|=
name|bracketend
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|BOOL
name|setsom_found
init|=
name|recursive
decl_stmt|;
name|BOOL
name|setmark_found
init|=
name|recursive
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/*>= 1 + shortest item size (2) */
name|SLJIT_UNUSED_ARG
argument_list|(
name|stacktop
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|stackpos
operator|>=
name|stacktop
operator|+
literal|2
argument_list|)
expr_stmt|;
name|stackpos
operator|=
name|STACK
argument_list|(
name|stackpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|||
operator|(
operator|*
name|cc
operator|!=
name|OP_CBRAPOS
operator|&&
operator|*
name|cc
operator|!=
name|OP_SCBRAPOS
operator|)
condition|)
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SET_SOM
case|:
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|has_set_som
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setsom_found
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setstrbegin
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|setsom_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setmark_found
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setmark
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|setmark_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
literal|2
operator|+
name|cc
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|OP_RECURSE
case|:
if|if
condition|(
name|common
operator|->
name|has_set_som
operator|&&
operator|!
name|setsom_found
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setstrbegin
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|setsom_found
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
operator|&&
operator|!
name|setmark_found
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setmark
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|setmark_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCBRAPOS
case|:
name|offset
operator|=
operator|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
operator|)
operator|<<
literal|1
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_end
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|stackpos
operator|==
name|STACK
argument_list|(
name|stacktop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_private_data_length_for_copy
specifier|static
name|SLJIT_INLINE
name|int
name|get_private_data_length_for_copy
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|)
block|{
name|int
name|private_data_length
init|=
literal|2
decl_stmt|;
name|int
name|size
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
comment|/* Calculate the sum of the private machine words. */
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
name|private_data_length
operator|++
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
if|if
condition|(
name|common
operator|->
name|optimized_cbracket
index|[
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
index|]
operator|==
literal|0
condition|)
name|private_data_length
operator|++
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|private_data_length
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
name|private_data_length
operator|++
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_1
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
name|private_data_length
operator|++
expr_stmt|;
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2A
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
name|private_data_length
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2B
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
name|private_data_length
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
literal|2
operator|+
name|IMM2_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
name|private_data_length
operator|++
expr_stmt|;
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
name|private_data_length
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
name|private_data_length
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
name|size
operator|=
operator|(
operator|*
name|cc
operator|==
name|OP_XCLASS
operator|)
condition|?
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
else|:
literal|1
operator|+
literal|32
operator|/
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
literal|1
operator|+
literal|32
operator|/
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
name|private_data_length
operator|+=
name|get_class_iterator_size
argument_list|(
name|cc
operator|+
name|size
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|size
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|==
name|ccend
argument_list|)
expr_stmt|;
return|return
name|private_data_length
return|;
block|}
end_function
begin_function
DECL|function|copy_private_data
specifier|static
name|void
name|copy_private_data
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|,
name|BOOL
name|save
parameter_list|,
name|int
name|stackptr
parameter_list|,
name|int
name|stacktop
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|srcw
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|,
name|size
decl_stmt|;
name|BOOL
name|tmp1next
init|=
name|TRUE
decl_stmt|;
name|BOOL
name|tmp1empty
init|=
name|TRUE
decl_stmt|;
name|BOOL
name|tmp2empty
init|=
name|TRUE
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
enum|enum
block|{
name|start
block|,
name|loop
block|,
name|end
block|}
name|status
enum|;
name|status
operator|=
name|save
condition|?
name|start
else|:
name|loop
expr_stmt|;
name|stackptr
operator|=
name|STACK
argument_list|(
name|stackptr
operator|-
literal|2
argument_list|)
expr_stmt|;
name|stacktop
operator|=
name|STACK
argument_list|(
name|stacktop
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|save
condition|)
block|{
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackptr
operator|<
name|stacktop
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|tmp1empty
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|stackptr
operator|<
name|stacktop
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|tmp2empty
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* The tmp1next must be TRUE in either way. */
block|}
while|while
condition|(
name|status
operator|!=
name|end
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|start
case|:
name|SLJIT_ASSERT
argument_list|(
name|save
operator|&&
name|common
operator|->
name|recursive_head
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|common
operator|->
name|recursive_head
expr_stmt|;
name|status
operator|=
name|loop
expr_stmt|;
break|break;
case|case
name|loop
case|:
if|if
condition|(
name|cc
operator|>=
name|ccend
condition|)
block|{
name|status
operator|=
name|end
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|srcw
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
if|if
condition|(
name|common
operator|->
name|optimized_cbracket
index|[
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
index|]
operator|==
literal|0
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|OVECTOR_PRIV
argument_list|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|count
operator|=
literal|2
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|srcw
index|[
literal|1
index|]
operator|=
name|OVECTOR_PRIV
argument_list|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|srcw
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|srcw
index|[
literal|1
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|srcw
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_1
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2A
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|srcw
index|[
literal|1
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
name|CASE_ITERATOR_PRIVATE_DATA_2B
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|srcw
index|[
literal|1
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|2
operator|+
name|IMM2_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|srcw
index|[
literal|1
index|]
operator|=
name|srcw
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|srcw
index|[
literal|1
index|]
operator|=
name|srcw
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
name|size
operator|=
operator|(
operator|*
name|cc
operator|==
name|OP_XCLASS
operator|)
condition|?
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
else|:
literal|1
operator|+
literal|32
operator|/
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
literal|1
operator|+
literal|32
operator|/
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
condition|)
switch|switch
condition|(
name|get_class_iterator_size
argument_list|(
name|cc
operator|+
name|size
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|count
operator|=
literal|2
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|srcw
index|[
literal|1
index|]
operator|=
name|srcw
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|cc
operator|+=
name|size
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|end
case|:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|save
condition|)
block|{
if|if
condition|(
name|tmp1next
condition|)
block|{
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|tmp1empty
operator|=
name|FALSE
expr_stmt|;
name|tmp1next
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|tmp2empty
operator|=
name|FALSE
expr_stmt|;
name|tmp1next
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tmp1next
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|tmp1empty
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp1empty
operator|=
name|stackptr
operator|>=
name|stacktop
expr_stmt|;
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|tmp1next
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|tmp2empty
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp2empty
operator|=
name|stackptr
operator|>=
name|stacktop
expr_stmt|;
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|tmp1next
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|save
condition|)
block|{
if|if
condition|(
name|tmp1next
condition|)
block|{
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|==
name|ccend
operator|&&
name|stackptr
operator|==
name|stacktop
operator|&&
operator|(
name|save
operator|||
operator|(
name|tmp1empty
operator|&&
name|tmp2empty
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|CASE_ITERATOR_PRIVATE_DATA_1
undef|#
directive|undef
name|CASE_ITERATOR_PRIVATE_DATA_1
end_undef
begin_undef
DECL|macro|CASE_ITERATOR_PRIVATE_DATA_2A
undef|#
directive|undef
name|CASE_ITERATOR_PRIVATE_DATA_2A
end_undef
begin_undef
DECL|macro|CASE_ITERATOR_PRIVATE_DATA_2B
undef|#
directive|undef
name|CASE_ITERATOR_PRIVATE_DATA_2B
end_undef
begin_undef
DECL|macro|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
undef|#
directive|undef
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_1
end_undef
begin_undef
DECL|macro|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
undef|#
directive|undef
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
end_undef
begin_undef
DECL|macro|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
undef|#
directive|undef
name|CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
end_undef
begin_function
DECL|function|is_powerof2
specifier|static
name|SLJIT_INLINE
name|BOOL
name|is_powerof2
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|)
block|{
return|return
operator|(
name|value
operator|&
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|set_jumps
specifier|static
name|SLJIT_INLINE
name|void
name|set_jumps
parameter_list|(
name|jump_list
modifier|*
name|list
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* sljit_set_label is clever enough to do nothing   if either the jump or the label is NULL. */
name|sljit_set_label
argument_list|(
name|list
operator|->
name|jump
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_jump
specifier|static
name|SLJIT_INLINE
name|void
name|add_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|)
block|{
name|jump_list
modifier|*
name|list_item
init|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|list_item
condition|)
block|{
name|list_item
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
name|list_item
operator|->
name|jump
operator|=
name|jump
expr_stmt|;
operator|*
name|list
operator|=
name|list_item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_stub
specifier|static
name|void
name|add_stub
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|enum
name|stub_types
name|type
parameter_list|,
name|int
name|data
parameter_list|,
name|struct
name|sljit_jump
modifier|*
name|start
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|stub_list
modifier|*
name|list_item
init|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|stub_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|list_item
condition|)
block|{
name|list_item
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|list_item
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|list_item
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|list_item
operator|->
name|quit
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|list_item
operator|->
name|next
operator|=
name|common
operator|->
name|stubs
expr_stmt|;
name|common
operator|->
name|stubs
operator|=
name|list_item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|flush_stubs
specifier|static
name|void
name|flush_stubs
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|stub_list
modifier|*
name|list_item
init|=
name|common
operator|->
name|stubs
decl_stmt|;
while|while
condition|(
name|list_item
condition|)
block|{
name|JUMPHERE
argument_list|(
name|list_item
operator|->
name|start
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|list_item
operator|->
name|type
condition|)
block|{
case|case
name|stack_alloc
case|:
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|stackalloc
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|list_item
operator|->
name|quit
argument_list|)
expr_stmt|;
name|list_item
operator|=
name|list_item
operator|->
name|next
expr_stmt|;
block|}
name|common
operator|->
name|stubs
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decrease_call_count
specifier|static
name|SLJIT_INLINE
name|void
name|decrease_call_count
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|CALL_COUNT
argument_list|,
literal|0
argument_list|,
name|CALL_COUNT
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|calllimit
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|allocate_stack
specifier|static
name|SLJIT_INLINE
name|void
name|allocate_stack
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* May destroy all locals and registers except TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DESTROY_REGISTERS
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|12345
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_stub
argument_list|(
name|common
argument_list|,
name|stack_alloc
argument_list|,
literal|0
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_LIMIT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_stack
specifier|static
name|SLJIT_INLINE
name|void
name|free_stack
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reset_ovector
specifier|static
name|SLJIT_INLINE
name|void
name|reset_ovector
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* At this point we can freely use all temporary registers. */
comment|/* TMP1 returns with begin - 1. */
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|8
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|i
argument_list|)
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_LOCAL_BASE
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|OVECTOR_START
operator|-
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOVU
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copy_ovector
specifier|static
name|SLJIT_INLINE
name|void
name|copy_ovector
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|topbracket
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|earlyexit
decl_stmt|;
comment|/* At this point we can freely use all registers. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SAVED_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|offsetcount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|mark_ptr
argument_list|)
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|offsets
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|GET_LOCAL_BASE
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|,
name|OVECTOR_START
argument_list|)
expr_stmt|;
comment|/* Unlikely, but possible */
name|earlyexit
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the integer value to the output buffer */
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|OP2
argument_list|(
name|SLJIT_ASHR
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCHAR_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOVU_SI
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG3
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|earlyexit
argument_list|)
expr_stmt|;
comment|/* Calculate the return value, which is the maximum ovector value. */
if|if
condition|(
name|topbracket
operator|>
literal|1
condition|)
block|{
name|GET_LOCAL_BASE
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|OVECTOR_START
operator|+
name|topbracket
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|topbracket
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* OVECTOR(0) is never equal to SLJIT_SAVED_REG3. */
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOVU
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|,
operator|-
operator|(
literal|2
operator|*
operator|(
name|sljit_sw
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG3
argument_list|,
literal|0
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|return_with_partial_match
specifier|static
name|SLJIT_INLINE
name|void
name|return_with_partial_match
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|quit
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|STR_END
operator|==
name|SLJIT_SAVED_REG2
argument_list|,
name|str_end_must_be_saved_reg2
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|start_used_ptr
operator|!=
literal|0
operator|&&
operator|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|?
name|common
operator|->
name|hit_start
operator|!=
literal|0
else|:
name|common
operator|->
name|hit_start
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|offsetcount
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
argument_list|,
name|quit
argument_list|)
expr_stmt|;
comment|/* Store match begin and end. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_HARD_COMPILE
condition|?
name|common
operator|->
name|start_used_ptr
else|:
name|common
operator|->
name|hit_start
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|OP2
argument_list|(
name|SLJIT_ASHR
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCHAR_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|OP2
argument_list|(
name|SLJIT_ASHR
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCHAR_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|quit
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_start_used_ptr
specifier|static
name|SLJIT_INLINE
name|void
name|check_start_used_ptr
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* May destroy TMP1. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
block|{
comment|/* The value of -1 must be kept for start_used_ptr! */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Jumps if start_used_ptr< STR_PTR, or start_used_ptr == -1. Although overwriting   is not necessary if start_used_ptr == STR_PTR, it does not hurt as well. */
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_HARD_COMPILE
condition|)
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|char_has_othercase
specifier|static
name|SLJIT_INLINE
name|BOOL
name|char_has_othercase
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
comment|/* Detects if the character has an othercase. */
name|unsigned
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
return|return
name|c
operator|!=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
return|return
name|common
operator|->
name|fcc
index|[
name|c
index|]
operator|!=
name|c
return|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
expr_stmt|;
return|return
name|MAX_255
argument_list|(
name|c
argument_list|)
condition|?
name|common
operator|->
name|fcc
index|[
name|c
index|]
operator|!=
name|c
else|:
name|FALSE
return|;
block|}
end_function
begin_function
DECL|function|char_othercase
specifier|static
name|SLJIT_INLINE
name|unsigned
name|int
name|char_othercase
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|unsigned
name|int
name|c
parameter_list|)
block|{
comment|/* Returns with the othercase. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|c
operator|>
literal|127
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
return|return
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
return|;
else|#
directive|else
return|return
name|c
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|TABLE_GET
argument_list|(
name|c
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|char_get_othercase_bit
specifier|static
name|unsigned
name|int
name|char_get_othercase_bit
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
comment|/* Detects if the character and its othercase has only 1 bit difference. */
name|unsigned
name|int
name|c
decl_stmt|,
name|oc
decl_stmt|,
name|bit
decl_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
name|int
name|n
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|127
condition|)
name|oc
operator|=
name|common
operator|->
name|fcc
index|[
name|c
index|]
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|oc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|oc
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|c
operator|=
operator|*
name|cc
expr_stmt|;
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|c
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
operator|*
name|cc
expr_stmt|;
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|c
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|c
operator|!=
name|oc
argument_list|)
expr_stmt|;
name|bit
operator|=
name|c
operator|^
name|oc
expr_stmt|;
comment|/* Optimized for English alphabet. */
if|if
condition|(
name|c
operator|<=
literal|127
operator|&&
name|bit
operator|==
literal|0x20
condition|)
return|return
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
literal|0x20
return|;
comment|/* Since c != oc, they must have at least 1 bit difference. */
if|if
condition|(
operator|!
name|is_powerof2
argument_list|(
name|bit
argument_list|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|c
operator|>
literal|127
condition|)
block|{
name|n
operator|=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bit
operator|&
literal|0x3f
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|--
expr_stmt|;
name|bit
operator|>>=
literal|6
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|<<
literal|8
operator|)
operator||
name|bit
return|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF */
return|return
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
name|bit
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|c
operator|>
literal|65535
condition|)
block|{
if|if
condition|(
name|bit
operator|>=
operator|(
literal|1
operator|<<
literal|10
operator|)
condition|)
name|bit
operator|>>=
literal|10
expr_stmt|;
else|else
return|return
operator|(
name|bit
operator|<
literal|256
operator|)
condition|?
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator||
name|bit
operator|)
else|:
operator|(
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
operator|(
name|bit
operator|>>
literal|8
operator|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF */
return|return
operator|(
name|bit
operator|<
literal|256
operator|)
condition|?
operator|(
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
name|bit
operator|)
else|:
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
name|bit
operator|>>
literal|8
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
block|}
end_function
begin_function
DECL|function|check_partial
specifier|static
name|void
name|check_partial
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|BOOL
name|force
parameter_list|)
block|{
comment|/* Checks whether a partial matching is occured. Does not modify registers. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|force
operator|||
name|common
operator|->
name|mode
operator|!=
name|JIT_COMPILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
return|return;
if|if
condition|(
operator|!
name|force
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|common
operator|->
name|partialmatchlabel
operator|!=
name|NULL
condition|)
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|partialmatchlabel
argument_list|)
expr_stmt|;
else|else
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|partialmatch
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_str_end
specifier|static
name|struct
name|sljit_jump
modifier|*
name|check_str_end
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Does not affect registers. Usually used in a tight spot. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|nohit
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|return_value
decl_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
return|return
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
return|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
block|{
name|nohit
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|nohit
argument_list|)
expr_stmt|;
name|return_value
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|return_value
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|partialmatchlabel
operator|!=
name|NULL
condition|)
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|partialmatchlabel
argument_list|)
expr_stmt|;
else|else
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|partialmatch
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
return|return
name|return_value
return|;
block|}
end_function
begin_function
DECL|function|detect_partial_match
specifier|static
name|void
name|detect_partial_match
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Partial matching mode. */
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|common
operator|->
name|partialmatchlabel
operator|!=
name|NULL
condition|)
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|partialmatchlabel
argument_list|)
expr_stmt|;
else|else
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|partialmatch
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_char
specifier|static
name|void
name|read_char
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Reads the character into TMP1, updates STR_PTR. Does not check STR_END. TMP2 Destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|utfreadchar
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF&& !COMPILE_PCRE32 */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|peek_char
specifier|static
name|void
name|peek_char
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Reads the character into TMP1, keeps STR_PTR. Does not check STR_END. TMP2 Destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|utfreadchar
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF&& !COMPILE_PCRE32 */
block|}
end_function
begin_function
DECL|function|read_char8_type
specifier|static
name|void
name|read_char8_type
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */
name|DEFINE_COMPILER
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
comment|/* This can be an extra read in some situations, but hopefully   it is needed in most cases. */
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|utfreadtype8
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Skip low surrogate if necessary. */
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
return|return;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
comment|/* The ctypes array contains only 256 values. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|skip_char_back
specifier|static
name|void
name|skip_char_back
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Goes one character back. Affects STR_PTR and TMP1. Does not check begin. */
name|DEFINE_COMPILER
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x80
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip low surrogate if necessary. */
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xdc00
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
endif|#
directive|endif
comment|/* SUPPORT_UTF&& !COMPILE_PCRE32 */
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_newlinechar
specifier|static
name|void
name|check_newlinechar
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|nltype
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|,
name|BOOL
name|jumpiftrue
parameter_list|)
block|{
comment|/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
if|if
condition|(
name|nltype
operator|==
name|NLTYPE_ANY
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|anynewline
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|jumpiftrue
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|jumpiftrue
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|<
literal|256
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|jumpiftrue
condition|?
name|SLJIT_C_EQUAL
else|:
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UTF
end_ifdef
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_function
DECL|function|do_utfreadchar
specifier|static
name|void
name|do_utfreadchar
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Fast decoding a UTF-8 character. TMP1 contains the first byte of the character (>= 0xc0). Return char value in TMP1, length - 1 in TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Searching for the first zero. */
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
comment|/* Two byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
comment|/* Three byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Four byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|do_utfreadtype8
specifier|static
name|void
name|do_utfreadtype8
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Fast decoding a UTF-8 character type. TMP2 contains the first byte of the character (>= 0xc0). Return value in TMP1. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|compare
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
comment|/* Two byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compare
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|compare
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* We only have types for characters less than 256. */
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_function
DECL|function|do_utfreadchar
specifier|static
name|void
name|do_utfreadchar
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Fast decoding a UTF-16 character. TMP1 contains the first 16 bit char of the character (>= 0xd800). Return char value in TMP1, length - 1 in TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xdc00
argument_list|)
expr_stmt|;
comment|/* Do nothing, only return. */
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Combine two 16 bit characters. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3ff
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3ff
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16] */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UTF */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UCP
end_ifdef
begin_comment
comment|/* UCD_BLOCK_SIZE must be 128 (see the assert below). */
end_comment
begin_define
DECL|macro|UCD_BLOCK_MASK
define|#
directive|define
name|UCD_BLOCK_MASK
value|127
end_define
begin_define
DECL|macro|UCD_BLOCK_SHIFT
define|#
directive|define
name|UCD_BLOCK_SHIFT
value|7
end_define
begin_function
DECL|function|do_getucd
specifier|static
name|void
name|do_getucd
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Search the UCD record for the character comes in TMP1. Returns chartype in TMP1 and UCD offset in TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|UCD_BLOCK_SIZE
operator|==
literal|128
operator|&&
sizeof|sizeof
argument_list|(
name|ucd_record
argument_list|)
operator|==
literal|8
argument_list|)
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCD_BLOCK_SHIFT
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucd_stage1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCD_BLOCK_MASK
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCD_BLOCK_SHIFT
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucd_stage2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|TMP2
argument_list|,
name|TMP1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|chartype
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|TMP1
argument_list|,
name|TMP2
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
DECL|function|mainloop_entry
specifier|static
name|SLJIT_INLINE
expr|struct
name|sljit_label
operator|*
name|mainloop_entry
argument_list|(
argument|compiler_common *common
argument_list|,
argument|BOOL hascrorlf
argument_list|,
argument|BOOL firstline
argument_list|)
block|{
name|DEFINE_COMPILER
block|; struct
name|sljit_label
operator|*
name|mainloop
block|; struct
name|sljit_label
operator|*
name|newlinelabel
operator|=
name|NULL
block|; struct
name|sljit_jump
operator|*
name|start
block|; struct
name|sljit_jump
operator|*
name|end
operator|=
name|NULL
block|; struct
name|sljit_jump
operator|*
name|nl
operator|=
name|NULL
block|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
block|struct
name|sljit_jump
operator|*
name|singlechar
block|;
endif|#
directive|endif
name|jump_list
operator|*
name|newline
operator|=
name|NULL
block|;
name|BOOL
name|newlinecheck
operator|=
name|FALSE
block|;
name|BOOL
name|readuchar
operator|=
name|FALSE
block|;
if|if
condition|(
operator|!
operator|(
name|hascrorlf
operator|||
name|firstline
operator|)
operator|&&
operator|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
operator|||
name|common
operator|->
name|newline
operator|>
literal|255
operator|)
condition|)
name|newlinecheck
operator|=
name|TRUE
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|firstline
condition|)
block|{
comment|/* Search for the end of the first line. */
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|first_line_end
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
comment|/* Continual stores does not cause data dependency. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
operator|&
name|newline
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|newline
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|start
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|newlinecheck
condition|)
block|{
name|newlinelabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCHAR_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* Increasing the STR_PTR here requires one less jump in the most common case. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UTF
end_ifdef
begin_if
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|readuchar
operator|=
name|TRUE
expr_stmt|;
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|if
condition|(
name|newlinecheck
condition|)
name|readuchar
operator|=
name|TRUE
expr_stmt|;
end_if
begin_if
if|if
condition|(
name|readuchar
condition|)
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if
begin_if
if|if
condition|(
name|newlinecheck
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|newlinelabel
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
end_if
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_if
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|singlechar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|singlechar
argument_list|)
expr_stmt|;
block|}
end_if
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_if
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|singlechar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|singlechar
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16] */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UTF&& !COMPILE_PCRE32 */
end_comment
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|start
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|newlinecheck
condition|)
block|{
name|JUMPHERE
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|nl
argument_list|)
expr_stmt|;
block|}
end_if
begin_return
return|return
name|mainloop
return|;
end_return
begin_define
DECL|macro|MAX_N_CHARS
unit|}
define|#
directive|define
name|MAX_N_CHARS
value|3
end_define
begin_function
DECL|macro|MAX_N_CHARS
unit|static
DECL|function|fast_forward_first_n_chars
name|SLJIT_INLINE
name|BOOL
name|fast_forward_first_n_chars
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|BOOL
name|firstline
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|start
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|quit
decl_stmt|;
name|pcre_uint32
name|chars
index|[
name|MAX_N_CHARS
operator|*
literal|2
index|]
decl_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|common
operator|->
name|start
operator|+
literal|1
operator|+
name|IMM2_SIZE
decl_stmt|;
name|int
name|location
init|=
literal|0
decl_stmt|;
name|pcre_int32
name|len
decl_stmt|,
name|c
decl_stmt|,
name|bit
decl_stmt|,
name|caseless
decl_stmt|;
name|int
name|must_stop
decl_stmt|;
comment|/* We do not support alternatives now. */
if|if
condition|(
operator|*
operator|(
name|common
operator|->
name|start
operator|+
name|GET
argument_list|(
name|common
operator|->
name|start
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|OP_ALT
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|caseless
operator|=
literal|0
expr_stmt|;
name|must_stop
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_CHAR
case|:
name|must_stop
operator|=
literal|0
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CHARI
case|:
name|caseless
operator|=
literal|1
expr_stmt|;
name|must_stop
operator|=
literal|0
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
comment|/* Zero width assertions. */
name|cc
operator|++
expr_stmt|;
continue|continue;
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_POSPLUS
case|:
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_EXACT
case|:
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_POSPLUSI
case|:
name|caseless
operator|=
literal|1
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_EXACTI
case|:
name|caseless
operator|=
literal|1
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|must_stop
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|must_stop
operator|==
literal|2
condition|)
break|break;
name|len
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
literal|0
index|]
argument_list|)
condition|)
name|len
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|caseless
operator|&&
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
block|{
name|caseless
operator|=
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|caseless
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|caseless
operator|=
operator|(
operator|(
name|caseless
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|len
operator|-
operator|(
name|caseless
operator|>>
literal|8
operator|)
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|caseless
operator|&
literal|0x100
operator|)
operator|!=
literal|0
condition|)
name|caseless
operator|=
operator|(
operator|(
name|caseless
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|len
operator|-
operator|(
name|caseless
operator|>>
literal|9
operator|)
operator|)
expr_stmt|;
else|else
name|caseless
operator|=
operator|(
operator|(
name|caseless
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|len
operator|-
operator|(
name|caseless
operator|>>
literal|9
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|caseless
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|location
operator|<
name|MAX_N_CHARS
operator|*
literal|2
condition|)
block|{
name|c
operator|=
operator|*
name|cc
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|(
name|caseless
operator|&
literal|0xff
operator|)
condition|)
block|{
name|bit
operator|=
name|caseless
operator|>>
literal|8
expr_stmt|;
name|c
operator||=
name|bit
expr_stmt|;
block|}
name|chars
index|[
name|location
index|]
operator|=
name|c
expr_stmt|;
name|chars
index|[
name|location
operator|+
literal|1
index|]
operator|=
name|bit
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|location
operator|+=
literal|2
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|location
operator|>=
name|MAX_N_CHARS
operator|*
literal|2
operator|||
name|must_stop
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* At least two characters are required. */
if|if
condition|(
name|location
operator|<
literal|2
operator|*
literal|2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|firstline
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|first_line_end
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|location
operator|>>
literal|1
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|location
operator|>>
literal|1
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|start
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|quit
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|chars
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|chars
index|[
literal|0
index|]
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|>
literal|2
operator|*
literal|2
condition|)
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|chars
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|chars
index|[
literal|2
index|]
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|>
literal|2
operator|*
literal|2
condition|)
block|{
if|if
condition|(
name|chars
index|[
literal|5
index|]
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|chars
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|chars
index|[
literal|4
index|]
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|quit
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|location
operator|>>
literal|1
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_undef
DECL|macro|MAX_N_CHARS
undef|#
directive|undef
name|MAX_N_CHARS
end_undef
begin_function
DECL|function|fast_forward_first_char
specifier|static
name|SLJIT_INLINE
name|void
name|fast_forward_first_char
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
name|first_char
parameter_list|,
name|BOOL
name|caseless
parameter_list|,
name|BOOL
name|firstline
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|start
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|quit
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|found
decl_stmt|;
name|pcre_uchar
name|oc
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|firstline
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|first_line_end
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|quit
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oc
operator|=
name|first_char
expr_stmt|;
if|if
condition|(
name|caseless
condition|)
block|{
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|first_char
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|first_char
operator|>
literal|127
operator|&&
name|common
operator|->
name|utf
condition|)
name|oc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|first_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|first_char
operator|==
name|oc
condition|)
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
else|else
block|{
name|bit
operator|=
name|first_char
operator|^
name|oc
expr_stmt|;
if|if
condition|(
name|is_powerof2
argument_list|(
name|bit
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|first_char
operator||
name|bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|found
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
block|}
block|}
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|quit
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fast_forward_newline
specifier|static
name|SLJIT_INLINE
name|void
name|fast_forward_newline
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|BOOL
name|firstline
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|lastchar
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|firstchar
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|quit
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|foundcr
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|notfoundnl
decl_stmt|;
name|jump_list
modifier|*
name|newline
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|firstline
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|first_line_end
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|lastchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|firstchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_GREATER_EQUAL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCHAR_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|quit
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|quit
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|firstchar
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|lastchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
return|return;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|firstchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|lastchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
name|foundcr
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
operator|&
name|newline
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|newline
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
block|{
name|quit
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|foundcr
argument_list|)
expr_stmt|;
name|notfoundnl
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCHAR_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|notfoundnl
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|quit
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|lastchar
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|firstchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fast_forward_start_bits
specifier|static
name|SLJIT_INLINE
name|void
name|fast_forward_start_bits
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|sljit_uw
name|start_bits
parameter_list|,
name|BOOL
name|firstline
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|start
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|quit
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|found
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|firstline
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|first_line_end
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|quit
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|start_bits
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|found
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|#
directive|if
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|quit
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_expr_stmt
DECL|function|search_requested_char
specifier|static
name|SLJIT_INLINE
expr|struct
name|sljit_jump
operator|*
name|search_requested_char
argument_list|(
argument|compiler_common *common
argument_list|,
argument|pcre_uchar req_char
argument_list|,
argument|BOOL caseless
argument_list|,
argument|BOOL has_firstchar
argument_list|)
block|{
name|DEFINE_COMPILER
block|; struct
name|sljit_label
operator|*
name|loop
block|; struct
name|sljit_jump
operator|*
name|toolong
block|; struct
name|sljit_jump
operator|*
name|alreadyfound
block|; struct
name|sljit_jump
operator|*
name|found
block|; struct
name|sljit_jump
operator|*
name|foundoc
operator|=
name|NULL
block|; struct
name|sljit_jump
operator|*
name|notfound
block|;
name|pcre_uint32
name|oc
block|,
name|bit
block|;
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|req_char_ptr
operator|!=
literal|0
argument_list|)
block|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|req_char_ptr
argument_list|)
block|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|REQ_BYTE_MAX
argument_list|)
block|;
name|toolong
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
block|;
name|alreadyfound
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
block|;
if|if
condition|(
name|has_firstchar
condition|)
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|notfound
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|oc
operator|=
name|req_char
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|caseless
condition|)
block|{
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|req_char
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|req_char
operator|>
literal|127
operator|&&
name|common
operator|->
name|utf
condition|)
name|oc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|req_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_if
begin_if
if|if
condition|(
name|req_char
operator|==
name|oc
condition|)
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
else|else
block|{
name|bit
operator|=
name|req_char
operator|^
name|oc
expr_stmt|;
if|if
condition|(
name|is_powerof2
argument_list|(
name|bit
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|req_char
operator||
name|bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
name|foundoc
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_if
begin_expr_stmt
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|loop
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|found
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|foundoc
condition|)
name|JUMPHERE
argument_list|(
name|foundoc
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|req_char_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|alreadyfound
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|toolong
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|notfound
return|;
end_return
begin_function
unit|}  static
DECL|function|do_revertframes
name|void
name|do_revertframes
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|mainloop
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GET_LOCAL_BASE
argument_list|(
name|TMP3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Drop frames until we reach STACK_TOP. */
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_SIG_LESS_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_end
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_end
argument_list|)
expr_stmt|;
comment|/* End of dropping frames. */
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setstrbegin
argument_list|)
expr_stmt|;
comment|/* Set string begin. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setmark
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
comment|/* Unknown command. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_wordboundary
specifier|static
name|void
name|check_wordboundary
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|skipread
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
operator|||
name|defined
name|SUPPORT_UTF
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|ctype_word
operator|==
literal|0x10
argument_list|,
name|ctype_word_must_be_16
argument_list|)
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
comment|/* Get type of the previous char, and put it to LOCALS1. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skipread
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|check_start_used_ptr
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
comment|/* Testing char type. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|use_ucp
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_UNDERSCORE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Nd
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_No
operator|-
name|ucp_Nd
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
comment|/* Here LOCALS1 has already been zeroed. */
name|jump
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|4
comment|/* ctype_word */
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|}
name|JUMPHERE
argument_list|(
name|skipread
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skipread
operator|=
name|check_str_end
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|peek_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
comment|/* Testing char type. This is a code duplication. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|use_ucp
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_UNDERSCORE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Nd
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_No
operator|-
name|ucp_Nd
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
comment|/* TMP2 may be destroyed by peek_char. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|4
comment|/* ctype_word */
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|}
name|JUMPHERE
argument_list|(
name|skipread
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_XOR
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   range format:    ranges[0] = length of the range (max MAX_RANGE_SIZE, -1 means invalid range).   ranges[1] = first bit (0 or 1)   ranges[2-length] = position of the bit change (when the current bit is not equal to the previous) */
end_comment
begin_function
DECL|function|check_ranges
specifier|static
name|BOOL
name|check_ranges
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
modifier|*
name|ranges
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|,
name|BOOL
name|readch
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
if|if
condition|(
name|ranges
index|[
literal|0
index|]
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|ranges
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|readch
condition|)
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|==
literal|0
condition|?
name|SLJIT_C_LESS
else|:
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|2
case|:
if|if
condition|(
name|readch
condition|)
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|!=
literal|0
condition|?
name|SLJIT_C_LESS
else|:
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|3
index|]
operator|-
name|ranges
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|4
case|:
if|if
condition|(
name|ranges
index|[
literal|2
index|]
operator|+
literal|1
operator|==
name|ranges
index|[
literal|3
index|]
operator|&&
name|ranges
index|[
literal|4
index|]
operator|+
literal|1
operator|==
name|ranges
index|[
literal|5
index|]
condition|)
block|{
if|if
condition|(
name|readch
condition|)
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
name|ranges
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|ranges
index|[
literal|3
index|]
operator|-
name|ranges
index|[
literal|2
index|]
operator|)
operator|==
operator|(
name|ranges
index|[
literal|5
index|]
operator|-
name|ranges
index|[
literal|4
index|]
operator|)
operator|&&
name|is_powerof2
argument_list|(
name|ranges
index|[
literal|4
index|]
operator|-
name|ranges
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|readch
condition|)
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|4
index|]
operator|-
name|ranges
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|!=
literal|0
condition|?
name|SLJIT_C_LESS
else|:
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ranges
index|[
literal|5
index|]
operator|-
name|ranges
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function
begin_function
DECL|function|get_ctype_ranges
specifier|static
name|void
name|get_ctype_ranges
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
modifier|*
name|ranges
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|,
name|length
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|ctypes
init|=
operator|(
specifier|const
name|pcre_uint8
operator|*
operator|)
name|common
operator|->
name|ctypes
decl_stmt|;
name|bit
operator|=
name|ctypes
index|[
literal|0
index|]
operator|&
name|flag
expr_stmt|;
name|ranges
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|ranges
index|[
literal|1
index|]
operator|=
name|bit
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ctypes
index|[
name|i
index|]
operator|&
name|flag
operator|)
operator|!=
name|bit
condition|)
block|{
if|if
condition|(
name|length
operator|>=
name|MAX_RANGE_SIZE
condition|)
return|return;
name|ranges
index|[
literal|2
operator|+
name|length
index|]
operator|=
name|i
expr_stmt|;
name|length
operator|++
expr_stmt|;
name|bit
operator|^=
name|flag
expr_stmt|;
block|}
if|if
condition|(
name|bit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|>=
name|MAX_RANGE_SIZE
condition|)
return|return;
name|ranges
index|[
literal|2
operator|+
name|length
index|]
operator|=
literal|256
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
name|ranges
index|[
literal|0
index|]
operator|=
name|length
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_class_ranges
specifier|static
name|BOOL
name|check_class_ranges
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
specifier|const
name|pcre_uint8
modifier|*
name|bits
parameter_list|,
name|BOOL
name|nclass
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|)
block|{
name|int
name|ranges
index|[
literal|2
operator|+
name|MAX_RANGE_SIZE
index|]
decl_stmt|;
name|pcre_uint8
name|bit
decl_stmt|,
name|cbit
decl_stmt|,
name|all
decl_stmt|;
name|int
name|i
decl_stmt|,
name|byte
decl_stmt|,
name|length
init|=
literal|0
decl_stmt|;
name|bit
operator|=
name|bits
index|[
literal|0
index|]
operator|&
literal|0x1
expr_stmt|;
name|ranges
index|[
literal|1
index|]
operator|=
name|bit
expr_stmt|;
comment|/* Can be 0 or 255. */
name|all
operator|=
operator|-
name|bit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
control|)
block|{
name|byte
operator|=
name|i
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|0x7
operator|)
operator|==
literal|0
operator|&&
name|bits
index|[
name|byte
index|]
operator|==
name|all
condition|)
name|i
operator|+=
literal|8
expr_stmt|;
else|else
block|{
name|cbit
operator|=
operator|(
name|bits
index|[
name|byte
index|]
operator|>>
operator|(
name|i
operator|&
literal|0x7
operator|)
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|cbit
operator|!=
name|bit
condition|)
block|{
if|if
condition|(
name|length
operator|>=
name|MAX_RANGE_SIZE
condition|)
return|return
name|FALSE
return|;
name|ranges
index|[
literal|2
operator|+
name|length
index|]
operator|=
name|i
expr_stmt|;
name|length
operator|++
expr_stmt|;
name|bit
operator|=
name|cbit
expr_stmt|;
name|all
operator|=
operator|-
name|cbit
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|bit
operator|==
literal|0
operator|)
operator|&&
name|nclass
operator|)
operator|||
operator|(
operator|(
name|bit
operator|==
literal|1
operator|)
operator|&&
operator|!
name|nclass
operator|)
condition|)
block|{
if|if
condition|(
name|length
operator|>=
name|MAX_RANGE_SIZE
condition|)
return|return
name|FALSE
return|;
name|ranges
index|[
literal|2
operator|+
name|length
index|]
operator|=
literal|256
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
name|ranges
index|[
literal|0
index|]
operator|=
name|length
expr_stmt|;
return|return
name|check_ranges
argument_list|(
name|common
argument_list|,
name|ranges
argument_list|,
name|backtracks
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|check_anynewline
specifier|static
name|void
name|check_anynewline
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Check whether TMP1 contains a newline character. TMP2 destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0d
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x85
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
endif|#
directive|endif
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x2029
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF || COMPILE_PCRE16 || COMPILE_PCRE32 */
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_hspace
specifier|static
name|void
name|check_hspace
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Check whether TMP1 contains a newline character. TMP2 destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
endif|#
directive|endif
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1680
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x180e
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x200A
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x202f
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x205f
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3000
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF || COMPILE_PCRE16 || COMPILE_PCRE32 */
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_vspace
specifier|static
name|void
name|check_vspace
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Check whether TMP1 contains a newline character. TMP2 destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0d
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x85
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
endif|#
directive|endif
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x2029
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF || COMPILE_PCRE16 || COMPILE_PCRE32 */
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|CHAR1
define|#
directive|define
name|CHAR1
value|STR_END
end_define
begin_define
DECL|macro|CHAR2
define|#
directive|define
name|CHAR2
value|STACK_TOP
end_define
begin_function
DECL|function|do_casefulcmp
specifier|static
name|void
name|do_casefulcmp
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|LCC_TABLE
define|#
directive|define
name|LCC_TABLE
value|STACK_LIMIT
end_define
begin_function
DECL|function|do_caselesscmp
specifier|static
name|void
name|do_caselesscmp
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|LCC_TABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|LCC_TABLE
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|lcc
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|LCC_TABLE
argument_list|,
name|CHAR1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|LCC_TABLE
argument_list|,
name|CHAR2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|LCC_TABLE
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|LCC_TABLE
undef|#
directive|undef
name|LCC_TABLE
end_undef
begin_undef
DECL|macro|CHAR1
undef|#
directive|undef
name|CHAR1
end_undef
begin_undef
DECL|macro|CHAR2
undef|#
directive|undef
name|CHAR2
end_undef
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|SUPPORT_UCP
end_if
begin_function
DECL|function|do_utf_caselesscmp
specifier|static
specifier|const
name|pcre_uchar
modifier|*
name|SLJIT_CALL
name|do_utf_caselesscmp
parameter_list|(
name|pcre_uchar
modifier|*
name|src1
parameter_list|,
name|jit_arguments
modifier|*
name|args
parameter_list|,
name|pcre_uchar
modifier|*
name|end1
parameter_list|)
block|{
comment|/* This function would be ineffective to do in JIT level. */
name|pcre_uint32
name|c1
decl_stmt|,
name|c2
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|src2
init|=
name|args
operator|->
name|uchar_ptr
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|end2
init|=
name|args
operator|->
name|end
decl_stmt|;
specifier|const
name|ucd_record
modifier|*
name|ur
decl_stmt|;
specifier|const
name|pcre_uint32
modifier|*
name|pp
decl_stmt|;
while|while
condition|(
name|src1
operator|<
name|end1
condition|)
block|{
if|if
condition|(
name|src2
operator|>=
name|end2
condition|)
return|return
operator|(
name|pcre_uchar
operator|*
operator|)
literal|1
return|;
name|GETCHARINC
argument_list|(
name|c1
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|GETCHARINC
argument_list|(
name|c2
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|ur
operator|=
name|GET_UCD
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
operator|&&
name|c1
operator|!=
name|c2
operator|+
name|ur
operator|->
name|other_case
condition|)
block|{
name|pp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|ur
operator|->
name|caseset
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c1
operator|<
operator|*
name|pp
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|c1
operator|==
operator|*
name|pp
operator|++
condition|)
break|break;
block|}
block|}
block|}
return|return
name|src2
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UTF&& SUPPORT_UCP */
end_comment
begin_function
DECL|function|byte_sequence_compare
specifier|static
name|pcre_uchar
modifier|*
name|byte_sequence_compare
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|BOOL
name|caseless
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|compare_context
modifier|*
name|context
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|unsigned
name|int
name|othercasebit
init|=
literal|0
decl_stmt|;
name|pcre_uchar
modifier|*
name|othercasechar
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|int
name|utflength
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|caseless
operator|&&
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
block|{
name|othercasebit
operator|=
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|othercasebit
argument_list|)
expr_stmt|;
comment|/* Extracting bit difference info. */
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|othercasechar
operator|=
name|cc
operator|+
operator|(
name|othercasebit
operator|>>
literal|8
operator|)
expr_stmt|;
name|othercasebit
operator|&=
literal|0xff
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
comment|/* Note that this code only handles characters in the BMP. If there   ever are characters outside the BMP whose othercase differs in only one   bit from itself (there currently are none), this code will need to be   revised for COMPILE_PCRE32. */
name|othercasechar
operator|=
name|cc
operator|+
operator|(
name|othercasebit
operator|>>
literal|9
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|othercasebit
operator|&
literal|0x100
operator|)
operator|!=
literal|0
condition|)
name|othercasebit
operator|=
operator|(
name|othercasebit
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
else|else
name|othercasebit
operator|&=
literal|0xff
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
block|}
if|if
condition|(
name|context
operator|->
name|sourcereg
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|4
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|2
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|4
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
name|context
operator|->
name|sourcereg
operator|=
name|TMP2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|utflength
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
condition|)
name|utflength
operator|+=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
do|do
block|{
endif|#
directive|endif
name|context
operator|->
name|length
operator|-=
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
comment|/* Unaligned read is supported. */
if|if
condition|(
name|othercasebit
operator|!=
literal|0
operator|&&
name|othercasechar
operator|==
name|cc
condition|)
block|{
name|context
operator|->
name|c
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
operator|*
name|cc
operator||
name|othercasebit
expr_stmt|;
name|context
operator|->
name|oc
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
name|othercasebit
expr_stmt|;
block|}
else|else
block|{
name|context
operator|->
name|c
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
operator|*
name|cc
expr_stmt|;
name|context
operator|->
name|oc
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|context
operator|->
name|ucharptr
operator|++
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|context
operator|->
name|ucharptr
operator|>=
literal|4
operator|||
name|context
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
name|context
operator|->
name|ucharptr
operator|==
literal|2
operator|&&
name|context
operator|->
name|length
operator|==
literal|1
operator|)
condition|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|context
operator|->
name|ucharptr
operator|>=
literal|2
operator|||
name|context
operator|->
name|length
operator|==
literal|0
condition|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
if|if
condition|(
literal|1
comment|/* context->ucharptr>= 1 || context->length == 0 */
condition|)
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
operator|||
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|4
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|2
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|1
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|2
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16|32] */
name|context
operator|->
name|sourcereg
operator|=
name|context
operator|->
name|sourcereg
operator|==
name|TMP1
condition|?
name|TMP2
else|:
name|TMP1
expr_stmt|;
switch|switch
condition|(
name|context
operator|->
name|ucharptr
condition|)
block|{
case|case
literal|4
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
case|:
if|if
condition|(
name|context
operator|->
name|oc
operator|.
name|asint
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|oc
operator|.
name|asint
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|c
operator|.
name|asint
operator||
name|context
operator|->
name|oc
operator|.
name|asint
argument_list|)
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
operator|||
name|defined
name|COMPILE_PCRE16
case|case
literal|2
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
case|:
if|if
condition|(
name|context
operator|->
name|oc
operator|.
name|asushort
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|oc
operator|.
name|asushort
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|c
operator|.
name|asushort
operator||
name|context
operator|->
name|oc
operator|.
name|asushort
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
case|case
literal|1
case|:
if|if
condition|(
name|context
operator|->
name|oc
operator|.
name|asbyte
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|oc
operator|.
name|asbyte
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|c
operator|.
name|asbyte
operator||
name|context
operator|->
name|oc
operator|.
name|asbyte
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|context
operator|->
name|ucharptr
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* Unaligned read is unsupported. */
if|if
condition|(
name|context
operator|->
name|length
operator|>
literal|0
condition|)
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
name|context
operator|->
name|sourcereg
operator|=
name|context
operator|->
name|sourcereg
operator|==
name|TMP1
condition|?
name|TMP2
else|:
name|TMP1
expr_stmt|;
if|if
condition|(
name|othercasebit
operator|!=
literal|0
operator|&&
name|othercasechar
operator|==
name|cc
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|othercasebit
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|*
name|cc
operator||
name|othercasebit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|*
name|cc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|utflength
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|utflength
operator|>
literal|0
condition|)
do|;
endif|#
directive|endif
return|return
name|cc
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
end_if
begin_define
DECL|macro|SET_TYPE_OFFSET
define|#
directive|define
name|SET_TYPE_OFFSET
parameter_list|(
name|value
parameter_list|)
define|\
value|if ((value) != typeoffset) \     { \     if ((value)> typeoffset) \       OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \     else \       OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \     } \   typeoffset = (value);
end_define
begin_define
DECL|macro|SET_CHAR_OFFSET
define|#
directive|define
name|SET_CHAR_OFFSET
parameter_list|(
name|value
parameter_list|)
define|\
value|if ((value) != charoffset) \     { \     if ((value)> charoffset) \       OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (value) - charoffset); \     else \       OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, charoffset - (value)); \     } \   charoffset = (value);
end_define
begin_function
DECL|function|compile_xclass_matchingpath
specifier|static
name|void
name|compile_xclass_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|jump_list
modifier|*
name|found
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
modifier|*
name|list
init|=
operator|(
operator|*
name|cc
operator|&
name|XCL_NOT
operator|)
operator|==
literal|0
condition|?
operator|&
name|found
else|:
name|backtracks
decl_stmt|;
name|pcre_int32
name|c
decl_stmt|,
name|charoffset
decl_stmt|;
specifier|const
name|pcre_uint32
modifier|*
name|other_cases
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
name|int
name|compares
decl_stmt|,
name|invertcmp
decl_stmt|,
name|numberofcmps
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|BOOL
name|needstype
init|=
name|FALSE
decl_stmt|,
name|needsscript
init|=
name|FALSE
decl_stmt|,
name|needschar
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|charsaved
init|=
name|FALSE
decl_stmt|;
name|int
name|typereg
init|=
name|TMP1
decl_stmt|,
name|scriptreg
init|=
name|TMP1
decl_stmt|;
name|pcre_int32
name|typeoffset
decl_stmt|;
endif|#
directive|endif
comment|/* Although SUPPORT_UTF must be defined, we are    not necessary in utf mode even in 8 bit mode. */
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cc
operator|++
operator|&
name|XCL_MAP
operator|)
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|check_class_ranges
argument_list|(
name|common
argument_list|,
operator|(
specifier|const
name|pcre_uint8
operator|*
operator|)
name|cc
argument_list|,
name|TRUE
argument_list|,
name|list
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|cc
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|list
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|charsaved
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|cc
operator|+=
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
block|}
comment|/* Scanning the necessary info. */
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|compares
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cc
operator|!=
name|XCL_END
condition|)
block|{
name|compares
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
condition|)
block|{
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|needschar
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_RANGE
condition|)
block|{
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|needschar
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|==
name|XCL_PROP
operator|||
operator|*
name|cc
operator|==
name|XCL_NOTPROP
argument_list|)
expr_stmt|;
name|cc
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|PT_ANY
case|:
break|break;
case|case
name|PT_LAMP
case|:
case|case
name|PT_GC
case|:
case|case
name|PT_PC
case|:
case|case
name|PT_ALNUM
case|:
name|needstype
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|needsscript
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_SPACE
case|:
case|case
name|PT_PXSPACE
case|:
case|case
name|PT_WORD
case|:
name|needstype
operator|=
name|TRUE
expr_stmt|;
name|needschar
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_CLIST
case|:
name|needschar
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|cc
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
comment|/* Simple register allocation. TMP1 is preferred if possible. */
if|if
condition|(
name|needstype
operator|||
name|needsscript
condition|)
block|{
if|if
condition|(
name|needschar
operator|&&
operator|!
name|charsaved
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needschar
condition|)
block|{
if|if
condition|(
name|needstype
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typereg
operator|=
name|RETURN_ADDR
expr_stmt|;
block|}
if|if
condition|(
name|needsscript
condition|)
name|scriptreg
operator|=
name|TMP3
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needstype
operator|&&
name|needsscript
condition|)
name|scriptreg
operator|=
name|TMP3
expr_stmt|;
comment|/* In all other cases only one of them was specified, and that can goes to TMP1. */
if|if
condition|(
name|needsscript
condition|)
block|{
if|if
condition|(
name|scriptreg
operator|==
name|TMP1
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|script
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|scriptreg
argument_list|,
name|TMP2
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|script
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Generating code. */
name|cc
operator|=
name|ccbegin
expr_stmt|;
name|charoffset
operator|=
literal|0
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|typeoffset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|cc
operator|!=
name|XCL_END
condition|)
block|{
name|compares
operator|--
expr_stmt|;
name|invertcmp
operator|=
operator|(
name|compares
operator|==
literal|0
operator|&&
name|list
operator|!=
name|backtracks
operator|)
expr_stmt|;
name|jump
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
condition|)
block|{
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
operator|++
expr_stmt|;
if|if
condition|(
name|numberofcmps
operator|<
literal|3
operator|&&
operator|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
operator|||
operator|*
name|cc
operator|==
name|XCL_RANGE
operator|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|numberofcmps
operator|==
literal|0
condition|?
name|SLJIT_MOV
else|:
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|numberofcmps
operator|==
literal|0
condition|?
name|SLJIT_UNUSED
else|:
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|numberofcmps
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numberofcmps
operator|>
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
operator|^
name|invertcmp
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_RANGE
condition|)
block|{
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
operator|++
expr_stmt|;
name|SET_CHAR_OFFSET
argument_list|(
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
operator|++
expr_stmt|;
if|if
condition|(
name|numberofcmps
operator|<
literal|3
operator|&&
operator|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
operator|||
operator|*
name|cc
operator|==
name|XCL_RANGE
operator|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|numberofcmps
operator|==
literal|0
condition|?
name|SLJIT_MOV
else|:
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|numberofcmps
operator|==
literal|0
condition|?
name|SLJIT_UNUSED
else|:
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|numberofcmps
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numberofcmps
operator|>
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
operator|^
name|invertcmp
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
else|else
block|{
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_NOTPROP
condition|)
name|invertcmp
operator|^=
literal|0x1
expr_stmt|;
name|cc
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|PT_ANY
case|:
if|if
condition|(
name|list
operator|!=
name|backtracks
condition|)
block|{
if|if
condition|(
operator|(
name|cc
index|[
operator|-
literal|1
index|]
operator|==
name|XCL_NOTPROP
operator|&&
name|compares
operator|>
literal|0
operator|)
operator|||
operator|(
name|cc
index|[
operator|-
literal|1
index|]
operator|==
name|XCL_PROP
operator|&&
name|compares
operator|==
literal|0
operator|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|cc
index|[
operator|-
literal|1
index|]
operator|==
name|XCL_NOTPROP
condition|)
continue|continue;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_LAMP
case|:
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Ll
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lt
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_GC
case|:
name|c
operator|=
name|PRIV
argument_list|(
name|ucp_typerange
argument_list|)
index|[
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
operator|*
literal|2
index|]
expr_stmt|;
name|SET_TYPE_OFFSET
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
operator|^
name|invertcmp
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PRIV
argument_list|(
name|ucp_typerange
argument_list|)
index|[
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
operator|*
literal|2
operator|+
literal|1
index|]
operator|-
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_PC
case|:
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
operator|^
name|invertcmp
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
operator|^
name|invertcmp
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SPACE
case|:
case|case
name|PT_PXSPACE
case|:
if|if
condition|(
operator|*
name|cc
operator|==
name|PT_SPACE
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|11
operator|-
name|charoffset
argument_list|)
expr_stmt|;
block|}
name|SET_CHAR_OFFSET
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|13
operator|-
literal|9
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|PT_SPACE
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|SET_TYPE_OFFSET
argument_list|(
name|ucp_Zl
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Zs
operator|-
name|ucp_Zl
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_WORD
case|:
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_UNDERSCORE
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
comment|/* ... fall through */
case|case
name|PT_ALNUM
case|:
name|SET_TYPE_OFFSET
argument_list|(
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
operator|(
operator|*
name|cc
operator|==
name|PT_ALNUM
operator|)
condition|?
name|SLJIT_MOV
else|:
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|cc
operator|==
name|PT_ALNUM
operator|)
condition|?
name|SLJIT_UNUSED
else|:
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|SET_TYPE_OFFSET
argument_list|(
name|ucp_Nd
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_No
operator|-
name|ucp_Nd
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_CLIST
case|:
name|other_cases
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|cc
index|[
literal|1
index|]
expr_stmt|;
comment|/* At least three characters are required.          Otherwise this case would be handled by the normal code path. */
name|SLJIT_ASSERT
argument_list|(
name|other_cases
index|[
literal|0
index|]
operator|!=
name|NOTACHAR
operator|&&
name|other_cases
index|[
literal|1
index|]
operator|!=
name|NOTACHAR
operator|&&
name|other_cases
index|[
literal|2
index|]
operator|!=
name|NOTACHAR
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|other_cases
index|[
literal|0
index|]
operator|<
name|other_cases
index|[
literal|1
index|]
operator|&&
name|other_cases
index|[
literal|1
index|]
operator|<
name|other_cases
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Optimizing character pairs, if their difference is power of 2. */
if|if
condition|(
name|is_powerof2
argument_list|(
name|other_cases
index|[
literal|1
index|]
operator|^
name|other_cases
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|charoffset
operator|==
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|other_cases
index|[
literal|1
index|]
operator|^
name|other_cases
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|charoffset
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|other_cases
index|[
literal|1
index|]
operator|^
name|other_cases
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|other_cases
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|other_cases
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_powerof2
argument_list|(
name|other_cases
index|[
literal|2
index|]
operator|^
name|other_cases
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|charoffset
operator|==
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|other_cases
index|[
literal|2
index|]
operator|^
name|other_cases
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|charoffset
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|other_cases
index|[
literal|1
index|]
operator|^
name|other_cases
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|other_cases
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|other_cases
index|[
literal|0
index|]
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
operator|(
operator|(
name|other_cases
index|[
literal|3
index|]
operator|==
name|NOTACHAR
operator|)
condition|?
name|SLJIT_SET_E
else|:
literal|0
operator|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|other_cases
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|*
name|other_cases
operator|++
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|other_cases
operator|!=
name|NOTACHAR
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|*
name|other_cases
operator|++
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
operator|(
operator|(
operator|*
name|other_cases
operator|==
name|NOTACHAR
operator|)
condition|?
name|SLJIT_SET_E
else|:
literal|0
operator|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
block|}
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|cc
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|compares
operator|>
literal|0
condition|?
name|list
else|:
name|backtracks
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|found
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|SET_TYPE_OFFSET
undef|#
directive|undef
name|SET_TYPE_OFFSET
end_undef
begin_undef
DECL|macro|SET_CHAR_OFFSET
undef|#
directive|undef
name|SET_CHAR_OFFSET
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|compile_char1_matchingpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_char1_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
name|type
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|oc
decl_stmt|,
name|bit
decl_stmt|;
name|compare_context
name|context
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
index|[
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|pcre_uchar
name|propdata
index|[
literal|5
index|]
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_SOD
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_SOM
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|wordboundary
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_NOT_WORD_BOUNDARY
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
comment|/* Digits are usually 0-9, so it is worth to optimize them. */
if|if
condition|(
name|common
operator|->
name|digits
index|[
literal|0
index|]
operator|==
operator|-
literal|2
condition|)
name|get_ctype_ranges
argument_list|(
name|common
argument_list|,
name|ctype_digit
argument_list|,
name|common
operator|->
name|digits
argument_list|)
expr_stmt|;
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
comment|/* Flip the starting bit in the negative case. */
if|if
condition|(
name|type
operator|==
name|OP_NOT_DIGIT
condition|)
name|common
operator|->
name|digits
index|[
literal|1
index|]
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|check_ranges
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|digits
argument_list|,
name|backtracks
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|read_char8_type
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ctype_digit
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_DIGIT
condition|?
name|SLJIT_C_ZERO
else|:
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|OP_NOT_DIGIT
condition|)
name|common
operator|->
name|digits
index|[
literal|1
index|]
operator|^=
literal|1
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char8_type
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ctype_space
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_WHITESPACE
condition|?
name|SLJIT_C_ZERO
else|:
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char8_type
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ctype_word
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_WORDCHAR
condition|?
name|SLJIT_C_ZERO
else|:
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_ANY
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|!=
name|JIT_PARTIAL_HARD_COMPILE
condition|)
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|jump
index|[
literal|1
index|]
operator|=
name|check_str_end
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
name|backtracks
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_ALLANY
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
operator|||
name|defined
name|COMPILE_PCRE16
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
return|return
name|cc
return|;
block|}
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_ANYBYTE
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
name|propdata
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|propdata
index|[
literal|1
index|]
operator|=
name|type
operator|==
name|OP_NOTPROP
condition|?
name|XCL_NOTPROP
else|:
name|XCL_PROP
expr_stmt|;
name|propdata
index|[
literal|2
index|]
operator|=
name|cc
index|[
literal|0
index|]
expr_stmt|;
name|propdata
index|[
literal|3
index|]
operator|=
name|cc
index|[
literal|1
index|]
expr_stmt|;
name|propdata
index|[
literal|4
index|]
operator|=
name|XCL_END
expr_stmt|;
name|compile_xclass_matchingpath
argument_list|(
name|common
argument_list|,
name|propdata
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|2
return|;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|OP_ANYNL
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
comment|/* We don't need to handle soft partial matching case. */
if|if
condition|(
name|common
operator|->
name|mode
operator|!=
name|JIT_PARTIAL_HARD_COMPILE
condition|)
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|jump
index|[
literal|1
index|]
operator|=
name|check_str_end
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
index|[
literal|2
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|3
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|bsr_nltype
argument_list|,
name|backtracks
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|hspace
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_NOT_HSPACE
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|vspace
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_NOT_VSPACE
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_EXTUNI
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|gbprop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optimize register allocation: use a real register. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|TMP1
argument_list|,
name|TMP2
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|gbprop
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|TMP1
argument_list|,
name|TMP2
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UI
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_PARTIAL_HARD_COMPILE
condition|)
block|{
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Since we successfully read a char above, partial matching must occure. */
name|check_partial
argument_list|(
name|common
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|cc
return|;
endif|#
directive|endif
case|case
name|OP_EODN
case|:
comment|/* Requires rather complex checks. */
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_NOT_EQUAL
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
index|[
literal|2
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_LESS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Equal. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|3
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|anynewline
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_EOD
case|:
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CIRC
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notbol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CIRCM
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notbol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
name|backtracks
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_DOLL
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|noteol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
operator|->
name|endonly
condition|)
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|OP_EODN
argument_list|,
name|cc
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
else|else
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|cc
return|;
case|case
name|OP_DOLLM
case|:
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|noteol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* STR_PTR = STR_END - IN_UCHARS(1) */
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peek_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
name|backtracks
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
name|length
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
condition|)
name|length
operator|+=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
operator|&&
operator|(
name|type
operator|==
name|OP_CHAR
operator|||
operator|!
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
operator|||
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|length
operator|=
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|context
operator|.
name|sourcereg
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
name|context
operator|.
name|ucharptr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|byte_sequence_compare
argument_list|(
name|common
argument_list|,
name|type
operator|==
name|OP_CHARI
argument_list|,
name|cc
argument_list|,
operator|&
name|context
argument_list|,
name|backtracks
argument_list|)
return|;
block|}
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_CHAR
operator|||
operator|!
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|length
return|;
block|}
name|oc
operator|=
name|char_othercase
argument_list|(
name|common
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bit
operator|=
name|c
operator|^
name|oc
expr_stmt|;
if|if
condition|(
name|is_powerof2
argument_list|(
name|bit
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator||
name|bit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|length
return|;
block|}
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|length
return|;
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|length
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|c
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|128
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_NOT
operator|||
operator|!
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Since UTF8 code page is fixed, we know that c is in [a-z] or [A-Z] range. */
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator||
literal|0x20
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Skip the variable-length character. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
else|else
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|{
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|cc
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
block|{
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|OP_NOT
operator|||
operator|!
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|oc
operator|=
name|char_othercase
argument_list|(
name|common
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bit
operator|=
name|c
operator|^
name|oc
expr_stmt|;
if|if
condition|(
name|is_powerof2
argument_list|(
name|bit
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator||
name|bit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|oc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cc
operator|+
name|length
return|;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
name|detect_partial_match
argument_list|(
name|common
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_class_ranges
argument_list|(
name|common
argument_list|,
operator|(
specifier|const
name|pcre_uint8
operator|*
operator|)
name|cc
argument_list|,
name|type
operator|==
name|OP_NCLASS
argument_list|,
name|backtracks
argument_list|)
condition|)
return|return
name|cc
operator|+
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
return|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
name|jump
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
comment|/* This check only affects 8 bit mode. In other modes, we   always need to compare the value with 255. */
if|if
condition|(
name|common
operator|->
name|utf
condition|)
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|{
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_CLASS
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF || !COMPILE_PCRE8 */
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_sw
operator|)
name|cc
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|jump
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UTF || !COMPILE_PCRE8 */
return|return
name|cc
operator|+
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
return|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
case|case
name|OP_XCLASS
case|:
name|compile_xclass_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
operator|+
name|LINK_SIZE
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
return|;
endif|#
directive|endif
case|case
name|OP_REVERSE
case|:
name|length
operator|=
name|GET
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
name|cc
operator|+
name|LINK_SIZE
return|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|check_start_used_ptr
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|LINK_SIZE
return|;
block|}
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_charn_matchingpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_charn_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|)
block|{
comment|/* This function consumes at least one input character. */
comment|/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|cc
decl_stmt|;
name|compare_context
name|context
decl_stmt|;
name|int
name|size
decl_stmt|;
name|context
operator|.
name|length
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cc
operator|>=
name|ccend
condition|)
break|break;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_CHAR
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
condition|)
name|size
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_CHARI
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
if|if
condition|(
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|&&
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
condition|)
name|size
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|&&
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|size
expr_stmt|;
name|context
operator|.
name|length
operator|+=
name|IN_UCHARS
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|size
operator|>
literal|0
operator|&&
name|context
operator|.
name|length
operator|<=
literal|128
condition|)
do|;
name|cc
operator|=
name|ccbegin
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|/* We have a fixed-length byte sequence. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|.
name|length
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|sourcereg
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
name|context
operator|.
name|ucharptr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
do|do
name|cc
operator|=
name|byte_sequence_compare
argument_list|(
name|common
argument_list|,
operator|*
name|cc
operator|==
name|OP_CHARI
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
operator|&
name|context
argument_list|,
name|backtracks
argument_list|)
expr_stmt|;
do|while
condition|(
name|context
operator|.
name|length
operator|>
literal|0
condition|)
do|;
return|return
name|cc
return|;
block|}
comment|/* A non-fixed length character will be checked if length == 0. */
return|return
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|backtracks
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|compile_ref_checks
specifier|static
name|struct
name|sljit_jump
modifier|*
name|compile_ref_checks
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
init|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
decl_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
operator|->
name|jscript_compat
condition|)
block|{
if|if
condition|(
name|backtracks
operator|==
name|NULL
condition|)
block|{
comment|/* OVECTOR(1) contains the "string begin - 1" constant. */
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
return|return
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
return|;
block|}
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Forward definitions. */
end_comment
begin_function_decl
specifier|static
name|void
name|compile_matchingpath
parameter_list|(
name|compiler_common
modifier|*
parameter_list|,
name|pcre_uchar
modifier|*
parameter_list|,
name|pcre_uchar
modifier|*
parameter_list|,
name|backtrack_common
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|compile_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
parameter_list|,
name|struct
name|backtrack_common
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|PUSH_BACKTRACK
define|#
directive|define
name|PUSH_BACKTRACK
parameter_list|(
name|size
parameter_list|,
name|ccstart
parameter_list|,
name|error
parameter_list|)
define|\
value|do \     { \     backtrack = sljit_alloc_memory(compiler, (size)); \     if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \       return error; \     memset(backtrack, 0, size); \     backtrack->prev = parent->top; \     backtrack->cc = (ccstart); \     parent->top = backtrack; \     } \   while (0)
end_define
begin_define
DECL|macro|PUSH_BACKTRACK_NOVALUE
define|#
directive|define
name|PUSH_BACKTRACK_NOVALUE
parameter_list|(
name|size
parameter_list|,
name|ccstart
parameter_list|)
define|\
value|do \     { \     backtrack = sljit_alloc_memory(compiler, (size)); \     if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \       return; \     memset(backtrack, 0, size); \     backtrack->prev = parent->top; \     backtrack->cc = (ccstart); \     parent->top = backtrack; \     } \   while (0)
end_define
begin_define
DECL|macro|BACKTRACK_AS
define|#
directive|define
name|BACKTRACK_AS
parameter_list|(
name|type
parameter_list|)
value|((type *)backtrack)
end_define
begin_function
DECL|function|compile_ref_matchingpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_ref_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|backtracks
parameter_list|,
name|BOOL
name|withchecks
parameter_list|,
name|BOOL
name|emptyfail
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
init|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|partial
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|nopartial
decl_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OVECTOR(1) contains the "string begin - 1" constant. */
if|if
condition|(
name|withchecks
operator|&&
operator|!
name|common
operator|->
name|jscript_compat
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
operator|*
name|cc
operator|==
name|OP_REFI
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|TMP1
operator|==
name|SLJIT_SCRATCH_REG1
operator|&&
name|STACK_TOP
operator|==
name|SLJIT_SCRATCH_REG2
operator|&&
name|TMP2
operator|==
name|SLJIT_SCRATCH_REG3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|withchecks
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Needed to save important temporary registers. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|uchar_ptr
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL3
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|do_utf_caselesscmp
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|nopartial
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|nopartial
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF&& SUPPORT_UCP */
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|withchecks
condition|)
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|partial
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|partial
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|*
name|cc
operator|==
name|OP_REF
condition|?
operator|&
name|common
operator|->
name|casefulcmp
else|:
operator|&
name|common
operator|->
name|caselesscmp
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mode
operator|!=
name|JIT_COMPILE
condition|)
block|{
name|nopartial
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|partial
argument_list|)
expr_stmt|;
comment|/* TMP2 -= STR_END - STR_PTR */
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|partial
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|*
name|cc
operator|==
name|OP_REF
condition|?
operator|&
name|common
operator|->
name|casefulcmp
else|:
operator|&
name|common
operator|->
name|caselesscmp
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|partial
argument_list|)
expr_stmt|;
name|check_partial
argument_list|(
name|common
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|nopartial
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|emptyfail
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|backtracks
argument_list|,
name|jump
argument_list|)
expr_stmt|;
else|else
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
return|return
name|cc
operator|+
literal|1
operator|+
name|IMM2_SIZE
return|;
block|}
end_function
begin_function
DECL|function|compile_ref_iterator_matchingpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_ref_iterator_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|backtrack_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|backtrack_common
modifier|*
name|backtrack
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|zerolength
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|cc
decl_stmt|;
name|int
name|min
init|=
literal|0
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
name|BOOL
name|minimize
decl_stmt|;
name|PUSH_BACKTRACK
argument_list|(
sizeof|sizeof
argument_list|(
name|iterator_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
expr_stmt|;
name|minimize
operator|=
operator|(
name|type
operator|&
literal|0x1
operator|)
operator|!=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
name|min
operator|=
literal|1
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|1
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
name|min
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|minimize
condition|)
block|{
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Temporary release of STR_PTR. */
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Restore if not zero length. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|>
literal|1
operator|||
name|max
operator|>
literal|1
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_ref_matchingpath
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|1
operator|||
name|max
operator|>
literal|1
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|1
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|min
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|1
condition|)
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max
operator|==
literal|0
condition|)
block|{
comment|/* Includes min> 1 case as well. */
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|zerolength
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
block|}
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OP_CRMINSTAR
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
block|}
else|else
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|0
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|compile_ref_matchingpath
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|1
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|min
argument_list|,
name|BACKTRACK_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max
operator|>
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|zerolength
argument_list|)
expr_stmt|;
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_recurse_matchingpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_recurse_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|backtrack_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|backtrack_common
modifier|*
name|backtrack
decl_stmt|;
name|recurse_entry
modifier|*
name|entry
init|=
name|common
operator|->
name|entries
decl_stmt|;
name|recurse_entry
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|start
init|=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|PUSH_BACKTRACK
argument_list|(
sizeof|sizeof
argument_list|(
name|recurse_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|start
operator|==
name|start
condition|)
break|break;
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|recurse_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|calls
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
else|else
name|common
operator|->
name|entries
operator|=
name|entry
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|has_set_som
operator|&&
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|common
operator|->
name|has_set_som
operator|||
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|has_set_som
condition|?
call|(
name|int
call|)
argument_list|(
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
else|:
name|common
operator|->
name|mark_ptr
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|entry
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|entry
operator|->
name|calls
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|JUMPTO
argument_list|(
name|SLJIT_FAST_CALL
argument_list|,
name|entry
operator|->
name|entry
argument_list|)
expr_stmt|;
comment|/* Leave if the match is failed. */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
block|}
end_function
begin_function
DECL|function|compile_assert_matchingpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_assert_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|assert_backtrack
modifier|*
name|backtrack
parameter_list|,
name|BOOL
name|conditional
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|framesize
decl_stmt|;
name|int
name|private_data_ptr
decl_stmt|;
name|backtrack_common
name|altbacktrack
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|jump_list
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
modifier|*
name|target
init|=
operator|(
name|conditional
operator|)
condition|?
operator|&
name|backtrack
operator|->
name|condfailed
else|:
operator|&
name|backtrack
operator|->
name|common
operator|.
name|topbacktracks
decl_stmt|;
name|jump_list
modifier|*
modifier|*
name|found
decl_stmt|;
comment|/* Saving previous accept variables. */
name|struct
name|sljit_label
modifier|*
name|save_quitlabel
init|=
name|common
operator|->
name|quitlabel
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|save_acceptlabel
init|=
name|common
operator|->
name|acceptlabel
decl_stmt|;
name|jump_list
modifier|*
name|save_quit
init|=
name|common
operator|->
name|quit
decl_stmt|;
name|jump_list
modifier|*
name|save_accept
init|=
name|common
operator|->
name|accept
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|brajump
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
operator|||
operator|*
name|cc
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|conditional
argument_list|)
expr_stmt|;
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
name|private_data_ptr
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|private_data_ptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|framesize
operator|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|backtrack
operator|->
name|framesize
operator|=
name|framesize
expr_stmt|;
name|backtrack
operator|->
name|private_data_ptr
operator|=
name|private_data_ptr
expr_stmt|;
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|opcode
operator|>=
name|OP_ASSERT
operator|&&
name|opcode
operator|<=
name|OP_ASSERTBACK_NOT
argument_list|)
expr_stmt|;
name|found
operator|=
operator|(
name|opcode
operator|==
name|OP_ASSERT
operator|||
name|opcode
operator|==
name|OP_ASSERTBACK
operator|)
condition|?
operator|&
name|tmp
else|:
name|target
expr_stmt|;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
comment|/* This is a braminzero backtrack path. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brajump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|framesize
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|framesize
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|altbacktrack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|backtrack_common
argument_list|)
argument_list|)
expr_stmt|;
name|common
operator|->
name|quitlabel
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|common
operator|->
name|acceptlabel
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|NULL
expr_stmt|;
name|altbacktrack
operator|.
name|top
operator|=
name|NULL
expr_stmt|;
name|altbacktrack
operator|.
name|topbacktracks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|ccbegin
operator|==
name|OP_ALT
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|altbacktrack
operator|.
name|cc
operator|=
name|ccbegin
expr_stmt|;
name|compile_matchingpath
argument_list|(
name|common
argument_list|,
name|ccbegin
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|cc
argument_list|,
operator|&
name|altbacktrack
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|common
operator|->
name|quitlabel
operator|=
name|save_quitlabel
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|save_acceptlabel
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|save_quit
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|save_accept
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|common
operator|->
name|acceptlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|accept
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|common
operator|->
name|accept
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
comment|/* Reset stack. */
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|opcode
operator|!=
name|OP_ASSERT_NOT
operator|&&
name|opcode
operator|!=
name|OP_ASSERTBACK_NOT
operator|)
operator|||
name|conditional
condition|)
block|{
comment|/* We don't need to keep the STR_PTR, only the previous private_data_ptr. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_ASSERT_NOT
operator|||
name|opcode
operator|==
name|OP_ASSERTBACK_NOT
condition|)
block|{
comment|/* We know that STR_PTR was stored on the top of the stack. */
if|if
condition|(
name|conditional
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|framesize
operator|>=
literal|0
condition|)
block|{
comment|/* For OP_BRA and OP_BRAMINZERO. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|found
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|compile_backtrackingpath
argument_list|(
name|common
argument_list|,
name|altbacktrack
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|common
operator|->
name|quitlabel
operator|=
name|save_quitlabel
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|save_acceptlabel
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|save_quit
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|save_accept
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|set_jumps
argument_list|(
name|altbacktrack
operator|.
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|!=
name|OP_ALT
condition|)
break|break;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* None of them matched. */
if|if
condition|(
name|common
operator|->
name|quit
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|common
operator|->
name|quit
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_ASSERT
operator|||
name|opcode
operator|==
name|OP_ASSERTBACK
condition|)
block|{
comment|/* Assert is failed. */
if|if
condition|(
name|conditional
operator|||
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* The topmost item should be 0. */
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The topmost item should be 0. */
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|!=
name|OP_BRAZERO
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|target
argument_list|,
name|jump
argument_list|)
expr_stmt|;
comment|/* Assert is successful. */
name|set_jumps
argument_list|(
name|tmp
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* We know that STR_PTR was stored on the top of the stack. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep the STR_PTR on the top of the stack. */
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bra
operator|==
name|OP_BRA
condition|)
block|{
comment|/* We don't need to keep the STR_PTR, only the previous private_data_ptr. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't need to keep the STR_PTR, only the previous private_data_ptr. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bra
operator|==
name|OP_BRAZERO
condition|?
name|STR_PTR
else|:
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|backtrack
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|sljit_set_label
argument_list|(
name|jump
argument_list|,
name|backtrack
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|backtrack
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brajump
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|backtrack
operator|->
name|common
operator|.
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* AssertNot is successful. */
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The topmost item should be 0. */
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|backtrack
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|backtrack
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brajump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|found
operator|==
operator|&
name|backtrack
operator|->
name|common
operator|.
name|topbacktracks
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|backtrack
operator|->
name|common
operator|.
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|backtrack
operator|->
name|common
operator|.
name|topbacktracks
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|common
operator|->
name|quitlabel
operator|=
name|save_quitlabel
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|save_acceptlabel
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|save_quit
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|save_accept
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
block|}
end_function
begin_function
DECL|function|do_searchovector
specifier|static
name|sljit_sw
name|SLJIT_CALL
name|do_searchovector
parameter_list|(
name|sljit_uw
name|refno
parameter_list|,
name|sljit_sw
modifier|*
name|locals
parameter_list|,
name|pcre_uchar
modifier|*
name|name_table
parameter_list|)
block|{
name|int
name|condition
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotA
init|=
name|name_table
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotB
decl_stmt|;
name|sljit_sw
name|name_count
init|=
name|locals
index|[
name|LOCALS0
operator|/
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
index|]
decl_stmt|;
name|sljit_sw
name|name_entry_size
init|=
name|locals
index|[
name|LOCALS1
operator|/
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
index|]
decl_stmt|;
name|sljit_sw
name|no_capture
decl_stmt|;
name|int
name|i
decl_stmt|;
name|locals
operator|+=
name|refno
operator|&
literal|0xff
expr_stmt|;
name|refno
operator|>>=
literal|8
expr_stmt|;
name|no_capture
operator|=
name|locals
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET2
argument_list|(
name|slotA
argument_list|,
literal|0
argument_list|)
operator|==
name|refno
condition|)
break|break;
name|slotA
operator|+=
name|name_entry_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|name_count
condition|)
block|{
comment|/* Found a name for the number - there can be only one; duplicate names   for different numbers are allowed, but not vice versa. First scan down   for duplicates. */
name|slotB
operator|=
name|slotA
expr_stmt|;
while|while
condition|(
name|slotB
operator|>
name|name_table
condition|)
block|{
name|slotB
operator|-=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|locals
index|[
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
index|]
operator|!=
name|no_capture
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
comment|/* Scan up for duplicates */
if|if
condition|(
operator|!
name|condition
condition|)
block|{
name|slotB
operator|=
name|slotA
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
name|slotB
operator|+=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|locals
index|[
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
index|]
operator|!=
name|no_capture
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
block|}
block|}
return|return
name|condition
return|;
block|}
end_function
begin_function
DECL|function|do_searchgroups
specifier|static
name|sljit_sw
name|SLJIT_CALL
name|do_searchgroups
parameter_list|(
name|sljit_uw
name|recno
parameter_list|,
name|sljit_uw
modifier|*
name|locals
parameter_list|,
name|pcre_uchar
modifier|*
name|name_table
parameter_list|)
block|{
name|int
name|condition
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotA
init|=
name|name_table
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotB
decl_stmt|;
name|sljit_uw
name|name_count
init|=
name|locals
index|[
name|LOCALS0
operator|/
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
index|]
decl_stmt|;
name|sljit_uw
name|name_entry_size
init|=
name|locals
index|[
name|LOCALS1
operator|/
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
index|]
decl_stmt|;
name|sljit_uw
name|group_num
init|=
name|locals
index|[
name|POSSESSIVE0
operator|/
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
index|]
decl_stmt|;
name|sljit_uw
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET2
argument_list|(
name|slotA
argument_list|,
literal|0
argument_list|)
operator|==
name|recno
condition|)
break|break;
name|slotA
operator|+=
name|name_entry_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|name_count
condition|)
block|{
comment|/* Found a name for the number - there can be only one; duplicate   names for different numbers are allowed, but not vice versa. First   scan down for duplicates. */
name|slotB
operator|=
name|slotA
expr_stmt|;
while|while
condition|(
name|slotB
operator|>
name|name_table
condition|)
block|{
name|slotB
operator|-=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|==
name|group_num
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
comment|/* Scan up for duplicates */
if|if
condition|(
operator|!
name|condition
condition|)
block|{
name|slotB
operator|=
name|slotA
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
name|slotB
operator|+=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|==
name|group_num
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
block|}
block|}
return|return
name|condition
return|;
block|}
end_function
begin_comment
comment|/*   Handling bracketed expressions is probably the most complex part.    Stack layout naming characters:     S - Push the current STR_PTR     0 - Push a 0 (NULL)     A - Push the current STR_PTR. Needed for restoring the STR_PTR         before the next alternative. Not pushed if there are no alternatives.     M - Any values pushed by the current alternative. Can be empty, or anything.     C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.     L - Push the previous local (pointed by localptr) to the stack    () - opional values stored on the stack   ()* - optonal, can be stored multiple times    The following list shows the regular expression templates, their PCRE byte codes   and stack layout supported by pcre-sljit.    (?:)                     OP_BRA     | OP_KET                A M   ()                       OP_CBRA    | OP_KET                C M   (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*                            OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*   (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*                            OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*   ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*                            OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*   ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*                            OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*   (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )   (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )   ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )   ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )   (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*            OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*   (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*            OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*   ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*            OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*   ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*            OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*     Stack layout naming characters:     A - Push the alternative index (starting from 0) on the stack.         Not pushed if there is no alternatives.     M - Any values pushed by the current alternative. Can be empty, or anything.    The next list shows the possible content of a bracket:   (|)     OP_*BRA    | OP_ALT ...         M A   (?()|)  OP_*COND   | OP_ALT             M A   (?>|)   OP_ONCE    | OP_ALT ...         [stack trace] M A   (?>|)   OP_ONCE_NC | OP_ALT ...         [stack trace] M A                                           Or nothing, if trace is unnecessary */
end_comment
begin_function
DECL|function|compile_bracket_matchingpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_bracket_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|backtrack_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|backtrack_common
modifier|*
name|backtrack
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|int
name|private_data_ptr
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|stacksize
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
name|pcre_uchar
modifier|*
name|matchingpath
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|pcre_uchar
name|ket
decl_stmt|;
name|assert_backtrack
modifier|*
name|assert
decl_stmt|;
name|BOOL
name|has_alternatives
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|skip
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|rmaxlabel
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|braminzerojump
init|=
name|NULL
decl_stmt|;
name|PUSH_BACKTRACK
argument_list|(
sizeof|sizeof
argument_list|(
name|bracket_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
operator|||
operator|*
name|cc
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
block|}
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|matchingpath
operator|=
name|ccbegin
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|==
name|OP_COND
operator|||
name|opcode
operator|==
name|OP_SCOND
operator|)
operator|&&
name|cc
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_DEF
condition|)
block|{
comment|/* Drop this bracket_backtrack. */
name|parent
operator|->
name|top
operator|=
name|backtrack
operator|->
name|prev
expr_stmt|;
return|return
name|bracketend
argument_list|(
name|cc
argument_list|)
return|;
block|}
name|ket
operator|=
operator|*
operator|(
name|bracketend
argument_list|(
name|cc
argument_list|)
operator|-
literal|1
operator|-
name|LINK_SIZE
operator|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|ket
operator|==
name|OP_KET
operator|||
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|ket
operator|==
name|OP_KETRMIN
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|bra
operator|==
name|OP_BRAZERO
operator|&&
name|ket
operator|==
name|OP_KETRMIN
operator|)
operator|||
operator|(
name|bra
operator|==
name|OP_BRAMINZERO
operator|&&
name|ket
operator|==
name|OP_KETRMAX
operator|)
operator|)
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|has_alternatives
operator|=
operator|*
name|cc
operator|==
name|OP_ALT
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
block|{
name|has_alternatives
operator|=
operator|(
operator|*
name|matchingpath
operator|==
name|OP_RREF
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|matchingpath
operator|==
name|OP_NRREF
condition|)
block|{
name|stacksize
operator|=
name|GET2
argument_list|(
name|matchingpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|currententry
operator|==
name|NULL
operator|||
name|stacksize
operator|==
name|RREF_ANY
condition|)
name|has_alternatives
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|common
operator|->
name|currententry
operator|->
name|start
operator|==
literal|0
condition|)
name|has_alternatives
operator|=
name|stacksize
operator|!=
literal|0
expr_stmt|;
else|else
name|has_alternatives
operator|=
name|stacksize
operator|!=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|common
operator|->
name|start
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|start
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|&&
operator|(
operator|*
name|cc
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|cc
operator|==
name|OP_KETRMIN
operator|)
condition|)
name|opcode
operator|=
name|OP_SCOND
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_ONCE_NC
argument_list|)
condition|)
name|opcode
operator|=
name|OP_ONCE
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRA
operator|||
name|opcode
operator|==
name|OP_SCBRA
condition|)
block|{
comment|/* Capturing brackets has a pre-allocated space. */
name|offset
operator|=
name|GET2
argument_list|(
name|ccbegin
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|optimized_cbracket
index|[
name|offset
index|]
operator|==
literal|0
condition|)
block|{
name|private_data_ptr
operator|=
name|OVECTOR_PRIV
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|<<=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|<<=
literal|1
expr_stmt|;
name|private_data_ptr
operator|=
name|OVECTOR
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|private_data_ptr
operator|=
name|private_data_ptr
expr_stmt|;
name|matchingpath
operator|+=
name|IMM2_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|||
name|opcode
operator|==
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
comment|/* Other brackets simply allocate the next entry. */
name|private_data_ptr
operator|=
name|PRIVATE_DATA
argument_list|(
name|ccbegin
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|private_data_ptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|private_data_ptr
operator|=
name|private_data_ptr
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Instructions before the first alternative. */
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ket
operator|==
name|OP_KETRMAX
operator|)
operator|||
operator|(
name|ket
operator|==
name|OP_KETRMIN
operator|&&
name|bra
operator|!=
name|OP_BRAMINZERO
operator|)
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|stacksize
operator|>
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ket
operator|==
name|OP_KETRMAX
operator|)
operator|||
operator|(
name|ket
operator|==
name|OP_KETRMIN
operator|&&
name|bra
operator|!=
name|OP_BRAMINZERO
operator|)
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
comment|/* This is a backtrack path! (Since the try-path of OP_BRAMINZERO matches to the empty string) */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KETRMIN
condition|)
block|{
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|braminzerojump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|||
name|opcode
operator|>=
name|OP_SBRA
condition|)
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Nothing stored during the first run. */
name|skip
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Checking zero-length iteration. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
operator|||
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* When we come from outside, private_data_ptr contains the previous STR_PTR. */
name|braminzerojump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Except when the whole stack frame must be saved. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|braminzerojump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|skip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|recursive_matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
name|rmaxlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|has_alternatives
operator|&&
name|opcode
operator|!=
name|OP_ONCE
operator|&&
name|opcode
operator|<
name|OP_SBRA
condition|)
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|alternative_matchingpath
operator|=
name|rmaxlabel
expr_stmt|;
block|}
comment|/* Handling capturing brackets and alternatives. */
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
if|if
condition|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* Neither capturing brackets nor recursions are not found in the block. */
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|has_alternatives
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
operator|||
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|has_alternatives
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_CBRA
operator|||
name|opcode
operator|==
name|OP_SCBRA
condition|)
block|{
comment|/* Saving the previous values. */
if|if
condition|(
name|common
operator|->
name|optimized_cbracket
index|[
name|offset
operator|>>
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|2
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|private_data_ptr
operator|==
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
comment|/* Saving the previous value. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_alternatives
condition|)
block|{
comment|/* Pushing the starting string pointer. */
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Generating code for the first alternative. */
if|if
condition|(
name|opcode
operator|==
name|OP_COND
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
if|if
condition|(
operator|*
name|matchingpath
operator|==
name|OP_CREF
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
operator|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|)
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|GET2
argument_list|(
name|matchingpath
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|matchingpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|matchingpath
operator|==
name|OP_NCREF
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|stacksize
operator|=
name|GET2
argument_list|(
name|matchingpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|stacksize
operator|<<
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_count
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_entry_size
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|stacksize
operator|<<
literal|8
operator|)
operator||
operator|(
name|common
operator|->
name|ovector_start
operator|/
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|GET_LOCAL_BASE
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_table
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL3
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|do_searchovector
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
operator|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|)
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|matchingpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|matchingpath
operator|==
name|OP_RREF
operator|||
operator|*
name|matchingpath
operator|==
name|OP_NRREF
condition|)
block|{
comment|/* Never has other case. */
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|=
name|NULL
expr_stmt|;
name|stacksize
operator|=
name|GET2
argument_list|(
name|matchingpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|currententry
operator|==
name|NULL
condition|)
name|stacksize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|stacksize
operator|==
name|RREF_ANY
condition|)
name|stacksize
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|common
operator|->
name|currententry
operator|->
name|start
operator|==
literal|0
condition|)
name|stacksize
operator|=
name|stacksize
operator|==
literal|0
expr_stmt|;
else|else
name|stacksize
operator|=
name|stacksize
operator|==
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|common
operator|->
name|start
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|start
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|matchingpath
operator|==
name|OP_RREF
operator|||
name|stacksize
operator|||
name|common
operator|->
name|currententry
operator|==
name|NULL
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|has_alternatives
argument_list|)
expr_stmt|;
if|if
condition|(
name|stacksize
operator|!=
literal|0
condition|)
name|matchingpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
block|{
name|matchingpath
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|matchingpath
operator|=
name|cc
expr_stmt|;
block|}
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|stacksize
operator|=
name|GET2
argument_list|(
name|matchingpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_count
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_entry_size
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|GET2
argument_list|(
name|common
operator|->
name|start
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|start
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|GET_LOCAL_BASE
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SCRATCH_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_table
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL3
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|do_searchgroups
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
operator|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|)
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|matchingpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
operator|&&
operator|*
name|matchingpath
operator|>=
name|OP_ASSERT
operator|&&
operator|*
name|matchingpath
operator|<=
name|OP_ASSERTBACK_NOT
argument_list|)
expr_stmt|;
comment|/* Similar code as PUSH_BACKTRACK macro. */
name|assert
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|assert_backtrack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|assert
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|assert_backtrack
argument_list|)
argument_list|)
expr_stmt|;
name|assert
operator|->
name|common
operator|.
name|cc
operator|=
name|matchingpath
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|assert
operator|=
name|assert
expr_stmt|;
name|matchingpath
operator|=
name|compile_assert_matchingpath
argument_list|(
name|common
argument_list|,
name|matchingpath
argument_list|,
name|assert
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|compile_matchingpath
argument_list|(
name|common
argument_list|,
name|matchingpath
argument_list|,
name|cc
argument_list|,
name|backtrack
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
if|if
condition|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
comment|/* Move the STR_PTR to the private_data_ptr. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|stacksize
operator|=
operator|(
name|ket
operator|==
name|OP_KETRMIN
operator|||
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|has_alternatives
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
name|stacksize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
operator|||
name|bra
operator|!=
name|OP_BRA
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|has_alternatives
operator|&&
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|stacksize
operator|>
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|has_alternatives
condition|)
block|{
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KETRMAX
condition|)
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|alternative_matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
block|}
comment|/* Must be after the matchingpath label. */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|||
name|opcode
operator|>=
name|OP_SBRA
condition|)
block|{
if|if
condition|(
name|has_alternatives
condition|)
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|alternative_matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
comment|/* Checking zero-length iteration. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
block|{
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|rmaxlabel
argument_list|)
expr_stmt|;
comment|/* Drop STR_PTR for greedy plus quantifier. */
if|if
condition|(
name|bra
operator|!=
name|OP_BRAZERO
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* TMP2 must contain the starting STR_PTR. */
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|rmaxlabel
argument_list|)
expr_stmt|;
block|}
else|else
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|rmaxlabel
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|recursive_matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|zero_matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
comment|/* This is a backtrack path! (From the viewpoint of OP_BRAMINZERO) */
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
operator|(
operator|(
name|braminzero_backtrack
operator|*
operator|)
name|parent
operator|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|braminzerojump
operator|!=
name|NULL
condition|)
block|{
name|JUMPHERE
argument_list|(
name|braminzerojump
argument_list|)
expr_stmt|;
comment|/* We need to release the end pointer to perform the     backtrack for the zero-length iteration. When     framesize is< 0, OP_ONCE will do the release itself. */
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|&&
name|BACKTRACK_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
operator|&&
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Continue to the normal backtrack. */
block|}
if|if
condition|(
operator|(
name|ket
operator|!=
name|OP_KET
operator|&&
name|bra
operator|!=
name|OP_BRAMINZERO
operator|)
operator|||
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
comment|/* Skip the other alternatives. */
while|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_bracketpos_matchingpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_bracketpos_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|backtrack_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|backtrack_common
modifier|*
name|backtrack
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|int
name|private_data_ptr
decl_stmt|;
name|int
name|cbraprivptr
init|=
literal|0
decl_stmt|;
name|int
name|framesize
decl_stmt|;
name|int
name|stacksize
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|BOOL
name|zero
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|NULL
decl_stmt|;
name|int
name|stack
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
init|=
name|NULL
decl_stmt|;
name|struct
name|jump_list
modifier|*
name|emptymatch
init|=
name|NULL
decl_stmt|;
name|PUSH_BACKTRACK
argument_list|(
sizeof|sizeof
argument_list|(
name|bracketpos_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAPOSZERO
condition|)
block|{
name|zero
operator|=
name|TRUE
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|private_data_ptr
operator|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|private_data_ptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|private_data_ptr
operator|=
name|private_data_ptr
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
name|ccbegin
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|offset
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
comment|/* This case cannot be optimized in the same was as   normal capturing brackets. */
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|optimized_cbracket
index|[
name|offset
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cbraprivptr
operator|=
name|OVECTOR_PRIV
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|<<=
literal|1
expr_stmt|;
name|ccbegin
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|framesize
operator|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|framesize
operator|=
name|framesize
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|stacksize
operator|=
operator|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|stacksize
operator|++
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|stacksize
operator|=
name|stacksize
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stacksize
operator|=
name|framesize
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_BRAPOS
operator|||
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
name|stacksize
operator|++
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|stacksize
operator|=
name|stacksize
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_BRAPOS
operator|||
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stack
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stack
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|stacksize
operator|-
literal|1
argument_list|,
name|stacksize
operator|-
name|framesize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cc
operator|!=
name|OP_KETRPOS
condition|)
block|{
name|backtrack
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
name|backtrack
operator|->
name|topbacktracks
operator|=
name|NULL
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|compile_matchingpath
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|cc
argument_list|,
name|backtrack
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|emptymatch
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
name|stacksize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|stacksize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|emptymatch
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|flush_stubs
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|compile_backtrackingpath
argument_list|(
name|common
argument_list|,
name|backtrack
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|set_jumps
argument_list|(
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
comment|/* Last alternative. */
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_KETRPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_KETRPOS
condition|)
break|break;
name|ccbegin
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
name|backtrack
operator|->
name|topbacktracks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* TMP2 is set to [private_data_ptr] above. */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|stacksize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* None of them matched. */
name|set_jumps
argument_list|(
name|emptymatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
block|}
end_function
begin_function
DECL|function|get_iterator_parameters
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|get_iterator_parameters
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|opcode
parameter_list|,
name|pcre_uchar
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|arg1
parameter_list|,
name|int
modifier|*
name|arg2
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
name|end
parameter_list|)
block|{
name|int
name|class_len
decl_stmt|;
operator|*
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_STAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_POSUPTO
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_CHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_STARI
operator|&&
operator|*
name|opcode
operator|<=
name|OP_POSUPTOI
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_CHARI
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_NOTSTAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_NOTPOSUPTO
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_NOT
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_NOTSTAR
operator|-
name|OP_STAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_NOTSTARI
operator|&&
operator|*
name|opcode
operator|<=
name|OP_NOTPOSUPTOI
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_NOTI
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_NOTSTARI
operator|-
name|OP_STAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_TYPESTAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_TYPEPOSUPTO
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_TYPESTAR
operator|-
name|OP_STAR
expr_stmt|;
operator|*
name|type
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|opcode
operator|>=
name|OP_CLASS
operator|||
operator|*
name|opcode
operator|<=
name|OP_XCLASS
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
operator|*
name|opcode
expr_stmt|;
name|cc
operator|++
expr_stmt|;
name|class_len
operator|=
operator|(
operator|*
name|type
operator|<
name|OP_XCLASS
operator|)
condition|?
call|(
name|int
call|)
argument_list|(
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
argument_list|)
else|:
name|GET
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|opcode
operator|=
name|cc
index|[
name|class_len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_CRSTAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_CRMINQUERY
condition|)
block|{
operator|*
name|opcode
operator|-=
name|OP_CRSTAR
operator|-
name|OP_STAR
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
name|cc
operator|+
name|class_len
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|opcode
operator|==
name|OP_CRRANGE
operator|||
operator|*
name|opcode
operator|==
name|OP_CRMINRANGE
argument_list|)
expr_stmt|;
operator|*
name|arg1
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
operator|(
name|class_len
operator|+
name|IMM2_SIZE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|arg2
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
name|class_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg2
operator|==
literal|0
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|arg1
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|opcode
operator|=
operator|(
operator|*
name|opcode
operator|==
name|OP_CRRANGE
operator|)
condition|?
name|OP_UPTO
else|:
name|OP_MINUPTO
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg1
operator|==
operator|*
name|arg2
condition|)
operator|*
name|opcode
operator|=
name|OP_EXACT
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
name|cc
operator|+
name|class_len
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
block|}
return|return
name|cc
return|;
block|}
if|if
condition|(
operator|*
name|opcode
operator|==
name|OP_UPTO
operator|||
operator|*
name|opcode
operator|==
name|OP_MINUPTO
operator|||
operator|*
name|opcode
operator|==
name|OP_EXACT
operator|||
operator|*
name|opcode
operator|==
name|OP_POSUPTO
condition|)
block|{
operator|*
name|arg1
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|IMM2_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|type
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|++
expr_stmt|;
return|return
name|cc
return|;
block|}
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
operator|*
name|end
operator|=
name|cc
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
condition|)
operator|*
name|end
operator|+=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_iterator_matchingpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_iterator_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|backtrack_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|backtrack_common
modifier|*
name|backtrack
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|int
name|arg1
init|=
operator|-
literal|1
decl_stmt|,
name|arg2
init|=
operator|-
literal|1
decl_stmt|;
name|pcre_uchar
modifier|*
name|end
decl_stmt|;
name|jump_list
modifier|*
name|nomatch
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|int
name|private_data_ptr
init|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|int
name|base
init|=
operator|(
name|private_data_ptr
operator|==
literal|0
operator|)
condition|?
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
else|:
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
decl_stmt|;
name|int
name|offset0
init|=
operator|(
name|private_data_ptr
operator|==
literal|0
operator|)
condition|?
name|STACK
argument_list|(
literal|0
argument_list|)
else|:
name|private_data_ptr
decl_stmt|;
name|int
name|offset1
init|=
operator|(
name|private_data_ptr
operator|==
literal|0
operator|)
condition|?
name|STACK
argument_list|(
literal|1
argument_list|)
else|:
name|private_data_ptr
operator|+
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
decl_stmt|;
name|int
name|tmp_base
decl_stmt|,
name|tmp_offset
decl_stmt|;
name|PUSH_BACKTRACK
argument_list|(
sizeof|sizeof
argument_list|(
name|iterator_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cc
operator|=
name|get_iterator_parameters
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
operator|&
name|opcode
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYBYTE
case|:
case|case
name|OP_ANYNL
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
name|tmp_base
operator|=
name|TMP3
expr_stmt|;
name|tmp_offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
comment|/* Fall through. */
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_XCLASS
case|:
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
name|tmp_base
operator|=
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
expr_stmt|;
name|tmp_offset
operator|=
name|POSSESSIVE0
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OP_STAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_CRRANGE
case|:
if|if
condition|(
name|type
operator|==
name|OP_ANYNL
operator|||
name|type
operator|==
name|OP_EXTUNI
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|private_data_ptr
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_STAR
operator|||
name|opcode
operator|==
name|OP_UPTO
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_UPTO
operator|||
name|opcode
operator|==
name|OP_CRRANGE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_UPTO
operator|||
name|opcode
operator|==
name|OP_CRRANGE
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRRANGE
operator|&&
name|arg2
operator|>
literal|0
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg2
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_UPTO
operator|||
operator|(
name|opcode
operator|==
name|OP_CRRANGE
operator|&&
name|arg1
operator|>
literal|0
operator|)
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We cannot use TMP3 because of this allocate_stack. */
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_PLUS
condition|)
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
name|OP_PLUS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|nomatch
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
name|OP_PLUS
condition|)
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_CRRANGE
operator|&&
name|arg1
operator|==
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
operator|+
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|nomatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRRANGE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg2
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
block|}
name|BACKTRACK_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINPLUS
case|:
if|if
condition|(
name|opcode
operator|==
name|OP_MINPLUS
condition|)
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_CRMINRANGE
case|:
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_QUERY
condition|)
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
name|BACKTRACK_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_EXACT
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSUPTO
case|:
if|if
condition|(
name|opcode
operator|==
name|OP_POSPLUS
condition|)
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_POSUPTO
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|nomatch
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_POSUPTO
condition|)
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|nomatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POSQUERY
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|nomatch
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|nomatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|tmp_base
argument_list|,
name|tmp_offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|end
return|;
block|}
end_function
begin_function
DECL|function|compile_fail_accept_matchingpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_fail_accept_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|backtrack_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|backtrack_common
modifier|*
name|backtrack
decl_stmt|;
name|PUSH_BACKTRACK
argument_list|(
sizeof|sizeof
argument_list|(
name|bracket_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_FAIL
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ASSERT_ACCEPT
operator|||
name|common
operator|->
name|currententry
operator|!=
name|NULL
condition|)
block|{
comment|/* No need to check notempty conditions. */
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty_atstart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|backtrack
operator|->
name|topbacktracks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|compile_close_matchingpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_close_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
init|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|BOOL
name|optimized_cbracket
init|=
name|common
operator|->
name|optimized_cbracket
index|[
name|offset
index|]
operator|!=
literal|0
decl_stmt|;
comment|/* Data will be discarded anyway... */
if|if
condition|(
name|common
operator|->
name|currententry
operator|!=
name|NULL
condition|)
return|return
name|cc
operator|+
literal|1
operator|+
name|IMM2_SIZE
return|;
if|if
condition|(
operator|!
name|optimized_cbracket
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR_PRIV
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|<<=
literal|1
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimized_cbracket
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|IMM2_SIZE
return|;
block|}
end_function
begin_function
DECL|function|compile_matchingpath
specifier|static
name|void
name|compile_matchingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|,
name|backtrack_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|backtrack_common
modifier|*
name|backtrack
decl_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYBYTE
case|:
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
case|case
name|OP_ANYNL
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_REVERSE
case|:
name|cc
operator|=
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextbacktracks
else|:
operator|&
name|parent
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SET_SOM
case|:
name|PUSH_BACKTRACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|backtrack_common
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
if|if
condition|(
name|common
operator|->
name|mode
operator|==
name|JIT_COMPILE
condition|)
name|cc
operator|=
name|compile_charn_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|ccend
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextbacktracks
else|:
operator|&
name|parent
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextbacktracks
else|:
operator|&
name|parent
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
name|cc
operator|=
name|compile_iterator_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|if
condition|(
name|cc
index|[
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
index|]
operator|>=
name|OP_CRSTAR
operator|&&
name|cc
index|[
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
index|]
operator|<=
name|OP_CRMINRANGE
condition|)
name|cc
operator|=
name|compile_iterator_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextbacktracks
else|:
operator|&
name|parent
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
case|case
name|OP_XCLASS
case|:
if|if
condition|(
operator|*
operator|(
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
name|OP_CRSTAR
operator|&&
operator|*
operator|(
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
name|OP_CRMINRANGE
condition|)
name|cc
operator|=
name|compile_iterator_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextbacktracks
else|:
operator|&
name|parent
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
if|if
condition|(
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|>=
name|OP_CRSTAR
operator|&&
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|<=
name|OP_CRMINRANGE
condition|)
name|cc
operator|=
name|compile_ref_iterator_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|compile_ref_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextbacktracks
else|:
operator|&
name|parent
operator|->
name|topbacktracks
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RECURSE
case|:
name|cc
operator|=
name|compile_recurse_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
name|PUSH_BACKTRACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|assert_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|compile_assert_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|BACKTRACK_AS
argument_list|(
name|assert_backtrack
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAMINZERO
case|:
name|PUSH_BACKTRACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|braminzero_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|bracketend
argument_list|(
name|cc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cc
operator|-
literal|1
operator|-
name|LINK_SIZE
operator|)
operator|!=
name|OP_KETRMIN
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|BACKTRACK_AS
argument_list|(
name|braminzero_backtrack
argument_list|)
operator|->
name|matchingpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_CBRA
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCOND
case|:
name|cc
operator|=
name|compile_bracket_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAZERO
case|:
if|if
condition|(
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
name|cc
operator|=
name|compile_bracket_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
block|{
name|PUSH_BACKTRACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|assert_backtrack
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|compile_assert_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|BACKTRACK_AS
argument_list|(
name|assert_backtrack
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_BRAPOSZERO
case|:
name|cc
operator|=
name|compile_bracketpos_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|PUSH_BACKTRACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|backtrack_common
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
call|(
name|sljit_sw
call|)
argument_list|(
name|cc
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|mark_ptr
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
literal|2
operator|+
name|cc
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|OP_COMMIT
case|:
name|PUSH_BACKTRACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|backtrack_common
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_FAIL
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
name|cc
operator|=
name|compile_fail_accept_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CLOSE
case|:
name|cc
operator|=
name|compile_close_matchingpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SKIPZERO
case|:
name|cc
operator|=
name|bracketend
argument_list|(
name|cc
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return;
block|}
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|==
name|ccend
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|PUSH_BACKTRACK
undef|#
directive|undef
name|PUSH_BACKTRACK
end_undef
begin_undef
DECL|macro|PUSH_BACKTRACK_NOVALUE
undef|#
directive|undef
name|PUSH_BACKTRACK_NOVALUE
end_undef
begin_undef
DECL|macro|BACKTRACK_AS
undef|#
directive|undef
name|BACKTRACK_AS
end_undef
begin_define
DECL|macro|COMPILE_BACKTRACKINGPATH
define|#
directive|define
name|COMPILE_BACKTRACKINGPATH
parameter_list|(
name|current
parameter_list|)
define|\
value|do \     { \     compile_backtrackingpath(common, (current)); \     if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \       return; \     } \   while (0)
end_define
begin_define
DECL|macro|CURRENT_AS
define|#
directive|define
name|CURRENT_AS
parameter_list|(
name|type
parameter_list|)
value|((type *)current)
end_define
begin_function
DECL|function|compile_iterator_backtrackingpath
specifier|static
name|void
name|compile_iterator_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|int
name|arg1
init|=
operator|-
literal|1
decl_stmt|,
name|arg2
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
name|jumplist
init|=
name|NULL
decl_stmt|;
name|int
name|private_data_ptr
init|=
name|PRIVATE_DATA
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|int
name|base
init|=
operator|(
name|private_data_ptr
operator|==
literal|0
operator|)
condition|?
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
else|:
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
decl_stmt|;
name|int
name|offset0
init|=
operator|(
name|private_data_ptr
operator|==
literal|0
operator|)
condition|?
name|STACK
argument_list|(
literal|0
argument_list|)
else|:
name|private_data_ptr
decl_stmt|;
name|int
name|offset1
init|=
operator|(
name|private_data_ptr
operator|==
literal|0
operator|)
condition|?
name|STACK
argument_list|(
literal|1
argument_list|)
else|:
name|private_data_ptr
operator|+
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
decl_stmt|;
name|cc
operator|=
name|get_iterator_parameters
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
operator|&
name|opcode
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OP_STAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_CRRANGE
case|:
if|if
condition|(
name|type
operator|==
name|OP_ANYNL
operator|||
name|type
operator|==
name|OP_EXTUNI
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|private_data_ptr
operator|==
literal|0
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_UPTO
condition|)
name|arg2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
name|OP_PLUS
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRRANGE
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_PLUS
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINPLUS
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|jumplist
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|jumplist
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_MINPLUS
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_CRMINRANGE
case|:
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
condition|)
block|{
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|jumplist
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset1
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg2
operator|+
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
operator|&&
name|arg1
operator|==
literal|0
condition|)
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
operator|+
literal|2
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|jumplist
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_QUERY
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MINQUERY
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|base
argument_list|,
name|offset0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compile_char1_matchingpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|jumplist
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|jumplist
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSPLUS
case|:
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSUPTO
case|:
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|compile_ref_iterator_backtrackingpath
specifier|static
name|void
name|compile_ref_iterator_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|type
operator|=
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
return|return;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_recurse_backtrackingpath
specifier|static
name|void
name|compile_recurse_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|has_set_som
operator|&&
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|common
operator|->
name|has_set_som
operator|||
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|has_set_som
condition|?
call|(
name|int
call|)
argument_list|(
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
else|:
name|common
operator|->
name|mark_ptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|compile_assert_backtrackingpath
specifier|static
name|void
name|compile_assert_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|brajump
init|=
name|NULL
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|!=
name|OP_BRAMINZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
condition|)
block|{
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|current
operator|->
name|topbacktracks
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|assert_backtrack
argument_list|)
operator|->
name|framesize
operator|<
literal|0
condition|)
block|{
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ASSERT_NOT
operator|||
operator|*
name|cc
operator|==
name|OP_ASSERTBACK_NOT
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brajump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ASSERT
operator|||
operator|*
name|cc
operator|==
name|OP_ASSERTBACK
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_backtrack
argument_list|)
operator|->
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_backtrack
argument_list|)
operator|->
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_backtrack
argument_list|)
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
comment|/* We know there is enough place on the stack. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_backtrack
argument_list|)
operator|->
name|matchingpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brajump
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|compile_bracket_backtrackingpath
specifier|static
name|void
name|compile_bracket_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|private_data_ptr
init|=
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|private_data_ptr
decl_stmt|;
name|int
name|stacksize
decl_stmt|;
name|int
name|count
decl_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccprev
decl_stmt|;
name|jump_list
modifier|*
name|jumplist
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
name|jumplistitem
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|pcre_uchar
name|ket
decl_stmt|;
name|assert_backtrack
modifier|*
name|assert
decl_stmt|;
name|BOOL
name|has_alternatives
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|brazero
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|once
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|cond
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|rminlabel
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
operator|||
operator|*
name|cc
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|ket
operator|=
operator|*
operator|(
name|bracketend
argument_list|(
name|ccbegin
argument_list|)
operator|-
literal|1
operator|-
name|LINK_SIZE
operator|)
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|has_alternatives
operator|=
operator|*
name|cc
operator|==
name|OP_ALT
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
name|has_alternatives
operator|=
operator|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|>=
name|OP_ASSERT
operator|&&
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|<=
name|OP_ASSERTBACK_NOT
operator|)
operator|||
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRA
operator|||
name|opcode
operator|==
name|OP_SCBRA
condition|)
name|offset
operator|=
operator|(
name|GET2
argument_list|(
name|ccbegin
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|&&
operator|(
operator|*
name|cc
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|cc
operator|==
name|OP_KETRMIN
operator|)
condition|)
name|opcode
operator|=
name|OP_SCOND
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_ONCE_NC
argument_list|)
condition|)
name|opcode
operator|=
name|OP_ONCE
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brazero
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
if|if
condition|(
name|bra
operator|!=
name|OP_BRAMINZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|>=
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
comment|/* Checking zero-length iteration. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
operator|||
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|recursive_matchingpath
argument_list|)
expr_stmt|;
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|recursive_matchingpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|recursive_matchingpath
argument_list|)
expr_stmt|;
block|}
name|rminlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brazero
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_ONCE
argument_list|)
condition|)
block|{
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|once
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
block|{
if|if
condition|(
name|has_alternatives
condition|)
block|{
comment|/* Always exactly one alternative. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jumplistitem
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
name|jumplistitem
argument_list|)
condition|)
return|return;
name|jumplist
operator|=
name|jumplistitem
expr_stmt|;
name|jumplistitem
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|jumplistitem
operator|->
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
block|{
comment|/* Build a jump list. Get the last successfully matched branch index. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|/* Append as the last item. */
if|if
condition|(
name|jumplist
operator|!=
name|NULL
condition|)
block|{
name|jumplistitem
operator|->
name|next
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
expr_stmt|;
name|jumplistitem
operator|=
name|jumplistitem
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|jumplistitem
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
expr_stmt|;
name|jumplist
operator|=
name|jumplistitem
expr_stmt|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
name|jumplistitem
argument_list|)
condition|)
return|return;
name|jumplistitem
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|jumplistitem
operator|->
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|cc
operator|=
name|ccbegin
operator|+
name|GET
argument_list|(
name|ccbegin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|COMPILE_BACKTRACKINGPATH
argument_list|(
name|current
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|topbacktracks
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
block|{
comment|/* Conditional block always has at most one alternative. */
if|if
condition|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|>=
name|OP_ASSERT
operator|&&
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|<=
name|OP_ASSERTBACK_NOT
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|assert
operator|=
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|assert
expr_stmt|;
if|if
condition|(
name|assert
operator|->
name|framesize
operator|>=
literal|0
operator|&&
operator|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERT
operator|||
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERTBACK
operator|)
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|assert
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cond
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|assert
operator|->
name|condfailed
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|!=
name|NULL
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|cond
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|condfailed
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|SLJIT_ASSERT
argument_list|(
operator|!
name|has_alternatives
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alternatives
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|current
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|topbacktracks
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|nextbacktracks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
block|{
name|ccprev
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_COND
operator|&&
name|opcode
operator|!=
name|OP_SCOND
condition|)
block|{
if|if
condition|(
name|private_data_ptr
operator|!=
literal|0
operator|&&
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|compile_matchingpath
argument_list|(
name|common
argument_list|,
name|ccprev
argument_list|,
name|cc
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return;
block|}
comment|/* Instructions after the current alternative is succesfully matched. */
comment|/* There is a similar code in compile_bracket_matchingpath. */
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
comment|/* Move the STR_PTR to the private_data_ptr. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
operator|||
name|bra
operator|!=
name|OP_BRA
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|stacksize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
operator|||
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We know we have place at least for one item on the top of the stack. */
name|SLJIT_ASSERT
argument_list|(
name|stacksize
operator|==
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
operator|||
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
if|if
condition|(
name|ket
operator|!=
name|OP_KET
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|alternative_matchingpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|jumplist
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jumplist
operator|->
name|jump
argument_list|)
expr_stmt|;
name|jumplist
operator|=
name|jumplist
operator|->
name|next
expr_stmt|;
block|}
name|COMPILE_BACKTRACKINGPATH
argument_list|(
name|current
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|topbacktracks
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|current
operator|->
name|nextbacktracks
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jumplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|NULL
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|opcode
operator|==
name|OP_COND
operator|||
name|opcode
operator|==
name|OP_SCOND
argument_list|)
expr_stmt|;
name|assert
operator|=
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|assert
expr_stmt|;
if|if
condition|(
operator|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERT_NOT
operator|||
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERTBACK_NOT
operator|)
operator|&&
name|assert
operator|->
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|assert
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
comment|/* Free the STR_PTR. */
if|if
condition|(
name|private_data_ptr
operator|==
literal|0
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* Using both tmp register is better for instruction scheduling. */
if|if
condition|(
name|common
operator|->
name|optimized_cbracket
index|[
name|offset
operator|>>
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
name|cc
operator|=
name|ccbegin
operator|+
name|GET
argument_list|(
name|ccbegin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
block|{
comment|/* Reset head and drop saved frame. */
name|stacksize
operator|=
operator|(
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|ket
operator|==
name|OP_KETRMIN
operator|||
operator|*
name|cc
operator|==
name|OP_ALT
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
name|stacksize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
operator|||
operator|(
operator|*
name|cc
operator|==
name|OP_ALT
operator|&&
name|ket
operator|!=
name|OP_KETRMIN
operator|)
condition|)
block|{
comment|/* The STR_PTR must be released. */
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|once
argument_list|)
expr_stmt|;
comment|/* Restore previous private_data_ptr */
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See the comment below. */
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|private_data_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|!=
name|OP_BRAZERO
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|recursive_matchingpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|zero_matchingpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brazero
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OP_ONCE removes everything in case of a backtrack, so we don't   need to explicitly release the STR_PTR. The extra release would   affect badly the free_stack(2) above. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|rminlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
name|bra
operator|==
name|OP_BRAMINZERO
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_backtrack
argument_list|)
operator|->
name|zero_matchingpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brazero
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|compile_bracketpos_backtrackingpath
specifier|static
name|void
name|compile_bracketpos_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|framesize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|current
operator|->
name|cc
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|current
operator|->
name|cc
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|offset
operator|=
operator|(
name|GET2
argument_list|(
name|current
operator|->
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
operator|)
operator|<<
literal|1
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|stacksize
argument_list|)
expr_stmt|;
return|return;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|private_data_ptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|topbacktracks
condition|)
block|{
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Drop the stack frame. */
name|free_stack
argument_list|(
name|common
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|stacksize
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|private_data_ptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_backtrack
argument_list|)
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_braminzero_backtrackingpath
specifier|static
name|void
name|compile_braminzero_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|assert_backtrack
name|backtrack
decl_stmt|;
name|current
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|topbacktracks
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|nextbacktracks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
block|{
comment|/* Manual call of compile_bracket_matchingpath and compile_bracket_backtrackingpath. */
name|compile_bracket_matchingpath
argument_list|(
name|common
argument_list|,
name|current
operator|->
name|cc
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|compile_bracket_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|backtrack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|backtrack
argument_list|)
argument_list|)
expr_stmt|;
name|backtrack
operator|.
name|common
operator|.
name|cc
operator|=
name|current
operator|->
name|cc
expr_stmt|;
name|backtrack
operator|.
name|matchingpath
operator|=
name|CURRENT_AS
argument_list|(
name|braminzero_backtrack
argument_list|)
operator|->
name|matchingpath
expr_stmt|;
comment|/* Manual call of compile_assert_matchingpath. */
name|compile_assert_matchingpath
argument_list|(
name|common
argument_list|,
name|current
operator|->
name|cc
argument_list|,
operator|&
name|backtrack
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
name|current
operator|->
name|nextbacktracks
operator|&&
operator|!
name|current
operator|->
name|topbacktracks
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_backtrackingpath
specifier|static
name|void
name|compile_backtrackingpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|backtrack_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|nextbacktracks
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|nextbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|current
operator|->
name|cc
condition|)
block|{
case|case
name|OP_SET_SOM
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
endif|#
directive|endif
name|compile_iterator_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
name|compile_ref_iterator_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RECURSE
case|:
name|compile_recurse_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
name|compile_assert_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_CBRA
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCOND
case|:
name|compile_bracket_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAZERO
case|:
if|if
condition|(
name|current
operator|->
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
name|compile_bracket_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
else|else
name|compile_assert_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_BRAPOSZERO
case|:
name|compile_bracketpos_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAMINZERO
case|:
name|compile_braminzero_backtrackingpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COMMIT
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|quitlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|quit
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|quitlabel
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FAIL
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
name|set_jumps
argument_list|(
name|current
operator|->
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|current
operator|=
name|current
operator|->
name|prev
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|compile_recurse
specifier|static
name|SLJIT_INLINE
name|void
name|compile_recurse
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|common
operator|->
name|start
operator|+
name|common
operator|->
name|currententry
operator|->
name|start
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
operator|(
operator|*
name|cc
operator|==
name|OP_BRA
condition|?
literal|0
else|:
name|IMM2_SIZE
operator|)
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccend
init|=
name|bracketend
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|int
name|private_data_size
init|=
name|get_private_data_length_for_copy
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|ccend
argument_list|)
decl_stmt|;
name|int
name|framesize
init|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
name|int
name|alternativesize
decl_stmt|;
name|BOOL
name|needsframe
decl_stmt|;
name|backtrack_common
name|altbacktrack
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|save_quitlabel
init|=
name|common
operator|->
name|quitlabel
decl_stmt|;
name|jump_list
modifier|*
name|save_quit
init|=
name|common
operator|->
name|quit
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|==
name|OP_BRA
operator|||
operator|*
name|cc
operator|==
name|OP_CBRA
operator|||
operator|*
name|cc
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|cc
operator|==
name|OP_SCBRA
operator|||
operator|*
name|cc
operator|==
name|OP_SCBRAPOS
argument_list|)
expr_stmt|;
name|needsframe
operator|=
name|framesize
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|needsframe
condition|)
name|framesize
operator|=
literal|0
expr_stmt|;
name|alternativesize
operator|=
operator|*
operator|(
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|OP_ALT
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|currententry
operator|->
name|entry
operator|==
name|NULL
operator|&&
name|common
operator|->
name|recursive_head
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|common
operator|->
name|currententry
operator|->
name|entry
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|set_jumps
argument_list|(
name|common
operator|->
name|currententry
operator|->
name|calls
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|entry
argument_list|)
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|private_data_size
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|private_data_size
operator|+
name|framesize
operator|+
name|alternativesize
operator|-
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_private_data
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|ccend
argument_list|,
name|TRUE
argument_list|,
name|private_data_size
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|,
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|recursive_head
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsframe
condition|)
name|init_frame
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|framesize
operator|+
name|alternativesize
operator|-
literal|1
argument_list|,
name|alternativesize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternativesize
operator|>
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|altbacktrack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|backtrack_common
argument_list|)
argument_list|)
expr_stmt|;
name|common
operator|->
name|quitlabel
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|NULL
expr_stmt|;
name|altbacktrack
operator|.
name|cc
operator|=
name|ccbegin
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|altbacktrack
operator|.
name|top
operator|=
name|NULL
expr_stmt|;
name|altbacktrack
operator|.
name|topbacktracks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|altbacktrack
operator|.
name|cc
operator|!=
name|ccbegin
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compile_matchingpath
argument_list|(
name|common
argument_list|,
name|altbacktrack
operator|.
name|cc
argument_list|,
name|cc
argument_list|,
operator|&
name|altbacktrack
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|common
operator|->
name|quitlabel
operator|=
name|save_quitlabel
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|save_quit
expr_stmt|;
return|return;
block|}
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|compile_backtrackingpath
argument_list|(
name|common
argument_list|,
name|altbacktrack
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|common
operator|->
name|quitlabel
operator|=
name|save_quitlabel
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|save_quit
expr_stmt|;
return|return;
block|}
name|set_jumps
argument_list|(
name|altbacktrack
operator|.
name|topbacktracks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|!=
name|OP_ALT
condition|)
break|break;
name|altbacktrack
operator|.
name|cc
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* None of them matched. */
if|if
condition|(
name|common
operator|->
name|quit
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|common
operator|->
name|quit
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|common
operator|->
name|accept
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|recursive_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsframe
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
name|alternativesize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
name|alternativesize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|copy_private_data
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|ccend
argument_list|,
name|FALSE
argument_list|,
name|private_data_size
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|,
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
name|private_data_size
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|recursive_head
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|common
operator|->
name|quitlabel
operator|=
name|save_quitlabel
expr_stmt|;
name|common
operator|->
name|quit
operator|=
name|save_quit
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|COMPILE_BACKTRACKINGPATH
undef|#
directive|undef
name|COMPILE_BACKTRACKINGPATH
end_undef
begin_undef
DECL|macro|CURRENT_AS
undef|#
directive|undef
name|CURRENT_AS
end_undef
begin_decl_stmt
name|void
DECL|function|jit_compile
name|PRIV
argument_list|(
name|jit_compile
argument_list|)
argument_list|(
specifier|const
name|REAL_PCRE
operator|*
name|re
argument_list|,
name|PUBL
argument_list|(
name|extra
argument_list|)
operator|*
name|extra
argument_list|,
name|int
name|mode
argument_list|)
block|{
name|struct
name|sljit_compiler
modifier|*
name|compiler
decl_stmt|;
name|backtrack_common
name|rootbacktrack
decl_stmt|;
name|compiler_common
name|common_data
decl_stmt|;
name|compiler_common
modifier|*
name|common
init|=
operator|&
name|common_data
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|tables
init|=
name|re
operator|->
name|tables
decl_stmt|;
name|pcre_study_data
modifier|*
name|study
decl_stmt|;
name|int
name|private_data_size
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccend
decl_stmt|;
name|executable_functions
modifier|*
name|functions
decl_stmt|;
name|void
modifier|*
name|executable_func
decl_stmt|;
name|sljit_uw
name|executable_size
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|mainloop
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|empty_match_found
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|empty_match_backtrack
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|reqbyte_notfound
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|empty_match
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|extra
operator|->
name|flags
operator|&
name|PCRE_EXTRA_STUDY_DATA
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|study
operator|=
name|extra
operator|->
name|study_data
expr_stmt|;
if|if
condition|(
operator|!
name|tables
condition|)
name|tables
operator|=
name|PRIV
argument_list|(
name|default_tables
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rootbacktrack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|backtrack_common
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|common
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|compiler_common
argument_list|)
argument_list|)
expr_stmt|;
name|rootbacktrack
operator|.
name|cc
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
operator|+
name|re
operator|->
name|name_count
operator|*
name|re
operator|->
name|name_entry_size
expr_stmt|;
name|common
operator|->
name|start
operator|=
name|rootbacktrack
operator|.
name|cc
expr_stmt|;
name|common
operator|->
name|fcc
operator|=
name|tables
operator|+
name|fcc_offset
expr_stmt|;
name|common
operator|->
name|lcc
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|tables
operator|+
name|lcc_offset
argument_list|)
expr_stmt|;
name|common
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_FIXED
expr_stmt|;
switch|switch
condition|(
name|re
operator|->
name|options
operator|&
name|PCRE_NEWLINE_BITS
condition|)
block|{
case|case
literal|0
case|:
comment|/* Compile-time default */
switch|switch
condition|(
name|NEWLINE
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
break|break;
default|default:
name|common
operator|->
name|newline
operator|=
name|NEWLINE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCRE_NEWLINE_CR
case|:
name|common
operator|->
name|newline
operator|=
name|CHAR_CR
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_LF
case|:
name|common
operator|->
name|newline
operator|=
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_CR
operator|+
name|PCRE_NEWLINE_LF
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANY
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANYCRLF
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_BSR_ANYCRLF
operator|)
operator|!=
literal|0
condition|)
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_BSR_UNICODE
operator|)
operator|!=
literal|0
condition|)
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|BSR_ANYCRLF
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
else|#
directive|else
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
endif|#
directive|endif
block|}
name|common
operator|->
name|endonly
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_DOLLAR_ENDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|common
operator|->
name|ctypes
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|tables
operator|+
name|ctypes_offset
argument_list|)
expr_stmt|;
name|common
operator|->
name|digits
index|[
literal|0
index|]
operator|=
operator|-
literal|2
expr_stmt|;
name|common
operator|->
name|name_table
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
argument_list|)
expr_stmt|;
name|common
operator|->
name|name_count
operator|=
name|re
operator|->
name|name_count
expr_stmt|;
name|common
operator|->
name|name_entry_size
operator|=
name|re
operator|->
name|name_entry_size
expr_stmt|;
name|common
operator|->
name|jscript_compat
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
comment|/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */
name|common
operator|->
name|utf
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|common
operator|->
name|use_ucp
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|ccend
operator|=
name|bracketend
argument_list|(
name|rootbacktrack
operator|.
name|cc
argument_list|)
expr_stmt|;
comment|/* Calculate the local space size on the stack. */
name|common
operator|->
name|ovector_start
operator|=
name|CALL_LIMIT
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|common
operator|->
name|optimized_cbracket
operator|=
operator|(
name|pcre_uint8
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
operator|->
name|optimized_cbracket
condition|)
return|return;
name|memset
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|,
literal|1
argument_list|,
name|re
operator|->
name|top_bracket
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|rootbacktrack
operator|.
name|cc
operator|==
name|OP_BRA
operator|&&
name|ccend
index|[
operator|-
operator|(
literal|1
operator|+
name|LINK_SIZE
operator|)
index|]
operator|==
name|OP_KET
argument_list|)
expr_stmt|;
name|private_data_size
operator|=
name|get_private_data_length
argument_list|(
name|common
argument_list|,
name|rootbacktrack
operator|.
name|cc
argument_list|,
name|ccend
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_size
operator|<
literal|0
condition|)
block|{
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Checking flags and updating ovector_start. */
if|if
condition|(
name|mode
operator|==
name|JIT_COMPILE
operator|&&
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
condition|)
block|{
name|common
operator|->
name|req_char_ptr
operator|=
name|common
operator|->
name|ovector_start
expr_stmt|;
name|common
operator|->
name|ovector_start
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|JIT_COMPILE
condition|)
block|{
name|common
operator|->
name|start_used_ptr
operator|=
name|common
operator|->
name|ovector_start
expr_stmt|;
name|common
operator|->
name|ovector_start
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
block|{
name|common
operator|->
name|hit_start
operator|=
name|common
operator|->
name|ovector_start
expr_stmt|;
name|common
operator|->
name|ovector_start
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
condition|)
block|{
name|common
operator|->
name|first_line_end
operator|=
name|common
operator|->
name|ovector_start
expr_stmt|;
name|common
operator|->
name|ovector_start
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
comment|/* Aligning ovector to even number of sljit words. */
if|if
condition|(
operator|(
name|common
operator|->
name|ovector_start
operator|&
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|common
operator|->
name|ovector_start
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|common
operator|->
name|req_char_ptr
operator|!=
literal|0
operator|&&
name|common
operator|->
name|start_used_ptr
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|common
operator|->
name|cbraptr
operator|=
name|OVECTOR_START
operator|+
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|private_data_size
operator|+=
name|common
operator|->
name|cbraptr
operator|+
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_data_size
operator|>
name|SLJIT_MAX_LOCAL_SIZE
condition|)
block|{
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
return|return;
block|}
name|common
operator|->
name|private_data_ptrs
operator|=
operator|(
name|int
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
operator|(
name|ccend
operator|-
name|rootbacktrack
operator|.
name|cc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
operator|->
name|private_data_ptrs
condition|)
block|{
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|common
operator|->
name|private_data_ptrs
argument_list|,
literal|0
argument_list|,
operator|(
name|ccend
operator|-
name|rootbacktrack
operator|.
name|cc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|set_private_data_ptrs
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|cbraptr
operator|+
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|,
name|ccend
argument_list|)
expr_stmt|;
name|compiler
operator|=
name|sljit_create_compiler
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
block|{
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|private_data_ptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|common
operator|->
name|compiler
operator|=
name|compiler
expr_stmt|;
comment|/* Main pcre_jit_exec entry. */
name|sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|private_data_size
argument_list|)
expr_stmt|;
comment|/* Register init. */
name|reset_ovector
argument_list|(
name|common
argument_list|,
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|req_char_ptr
operator|!=
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|req_char_ptr
argument_list|,
name|SLJIT_SCRATCH_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|calllimit
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_LIMIT
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CALL_LIMIT
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Main part of the matching */
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|==
literal|0
condition|)
block|{
name|mainloop
operator|=
name|mainloop_entry
argument_list|(
name|common
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_HASCRORLF
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Forward search if possible. */
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|JIT_COMPILE
operator|&&
name|fast_forward_first_n_chars
argument_list|(
name|common
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* Do nothing */
block|}
elseif|else
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
condition|)
name|fast_forward_first_char
argument_list|(
name|common
argument_list|,
operator|(
name|pcre_uchar
operator|)
name|re
operator|->
name|first_char
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FCH_CASELESS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|!=
literal|0
condition|)
name|fast_forward_newline
argument_list|(
name|common
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|==
literal|0
operator|&&
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MAPPED
operator|)
operator|!=
literal|0
condition|)
name|fast_forward_start_bits
argument_list|(
name|common
argument_list|,
operator|(
name|sljit_uw
operator|)
name|study
operator|->
name|start_bits
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|common
operator|->
name|req_char_ptr
operator|!=
literal|0
condition|)
name|reqbyte_notfound
operator|=
name|search_requested_char
argument_list|(
name|common
argument_list|,
operator|(
name|pcre_uchar
operator|)
name|re
operator|->
name|req_char
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_RCH_CASELESS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Store the current STR_PTR in OVECTOR(0). */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the limit of allowed recursions. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CALL_COUNT
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CALL_LIMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|mark_ptr
operator|!=
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|mark_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the beginning of the string. */
if|if
condition|(
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|JIT_PARTIAL_HARD_COMPILE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compile_matchingpath
argument_list|(
name|common
argument_list|,
name|rootbacktrack
operator|.
name|cc
argument_list|,
name|ccend
argument_list|,
operator|&
name|rootbacktrack
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|private_data_ptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|empty_match
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|empty_match_found
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|accept
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|common
operator|->
name|accept
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
comment|/* This means we have a match. Update the ovector. */
name|copy_ovector
argument_list|(
name|common
argument_list|,
name|re
operator|->
name|top_bracket
operator|+
literal|1
argument_list|)
expr_stmt|;
name|common
operator|->
name|quitlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|quit
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|common
operator|->
name|quit
argument_list|,
name|common
operator|->
name|quitlabel
argument_list|)
expr_stmt|;
name|sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|JIT_COMPILE
condition|)
block|{
name|common
operator|->
name|partialmatchlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|set_jumps
argument_list|(
name|common
operator|->
name|partialmatch
argument_list|,
name|common
operator|->
name|partialmatchlabel
argument_list|)
expr_stmt|;
name|return_with_partial_match
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|quitlabel
argument_list|)
expr_stmt|;
block|}
name|empty_match_backtrack
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_backtrackingpath
argument_list|(
name|common
argument_list|,
name|rootbacktrack
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|private_data_ptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLJIT_ASSERT
argument_list|(
name|rootbacktrack
operator|.
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
block|{
comment|/* Update hit_start only in the first time. */
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|start_used_ptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
comment|/* Check we have remaining characters. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|JIT_COMPILE
operator|&&
name|study
operator|!=
name|NULL
operator|&&
name|study
operator|->
name|minlength
operator|>
literal|1
operator|&&
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|study
operator|->
name|minlength
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|first_line_end
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|JIT_COMPILE
operator|&&
name|study
operator|!=
name|NULL
operator|&&
name|study
operator|->
name|minlength
operator|>
literal|1
operator|&&
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|study
operator|->
name|minlength
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_GREATER
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|)
expr_stmt|;
name|OP_FLAGS
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_GREATER_EQUAL
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_ZERO
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|first_line_end
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No more remaining characters. */
if|if
condition|(
name|reqbyte_notfound
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|reqbyte_notfound
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|JIT_PARTIAL_SOFT_COMPILE
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|common
operator|->
name|hit_start
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|common
operator|->
name|partialmatchlabel
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_NOMATCH
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|quitlabel
argument_list|)
expr_stmt|;
name|flush_stubs
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|empty_match
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|empty_match_backtrack
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty_atstart
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|empty_match_found
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|empty_match_found
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|empty_match_backtrack
argument_list|)
expr_stmt|;
name|common
operator|->
name|currententry
operator|=
name|common
operator|->
name|entries
expr_stmt|;
while|while
condition|(
name|common
operator|->
name|currententry
operator|!=
name|NULL
condition|)
block|{
comment|/* Might add new entries. */
name|compile_recurse
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|private_data_ptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|flush_stubs
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|common
operator|->
name|currententry
operator|=
name|common
operator|->
name|currententry
operator|->
name|next
expr_stmt|;
block|}
comment|/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */
comment|/* This is a (really) rare case. */
name|set_jumps
argument_list|(
name|common
operator|->
name|stackalloc
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
comment|/* RETURN_ADDR is not a saved register. */
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|top
argument_list|)
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|limit
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|STACK_GROWTH_RATE
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL2
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|sljit_stack_resize
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_LIMIT
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
comment|/* Allocation failed. */
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* We break the return address cache here, but this is a really rare case. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_JIT_STACKLIMIT
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|quitlabel
argument_list|)
expr_stmt|;
comment|/* Call limit reached. */
name|set_jumps
argument_list|(
name|common
operator|->
name|calllimit
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_MATCHLIMIT
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|quitlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|revertframes
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|revertframes
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_revertframes
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|wordboundary
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|wordboundary
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_wordboundary
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|anynewline
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|anynewline
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_anynewline
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|hspace
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|hspace
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_hspace
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|vspace
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|vspace
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_vspace
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|casefulcmp
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|casefulcmp
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_casefulcmp
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|caselesscmp
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|caselesscmp
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_caselesscmp
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UTF
ifndef|#
directive|ifndef
name|COMPILE_PCRE32
if|if
condition|(
name|common
operator|->
name|utfreadchar
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|utfreadchar
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_utfreadchar
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !COMPILE_PCRE32 */
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utfreadtype8
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|utfreadtype8
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_utfreadtype8
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
endif|#
directive|endif
comment|/* SUPPORT_UTF */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|getucd
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|getucd
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_getucd
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|optimized_cbracket
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|private_data_ptrs
argument_list|)
expr_stmt|;
name|executable_func
operator|=
name|sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|executable_size
operator|=
name|sljit_get_generated_code_size
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable_func
operator|==
name|NULL
condition|)
return|return;
comment|/* Reuse the function descriptor if possible. */
if|if
condition|(
operator|(
name|extra
operator|->
name|flags
operator|&
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|)
operator|!=
literal|0
operator|&&
name|extra
operator|->
name|executable_jit
operator|!=
name|NULL
condition|)
name|functions
operator|=
operator|(
name|executable_functions
operator|*
operator|)
name|extra
operator|->
name|executable_jit
expr_stmt|;
else|else
block|{
comment|/* Note: If your memory-checker has flagged the allocation below as a    * memory leak, it is probably because you either forgot to call    * pcre_free_study() (or pcre16_free_study()) on the pcre_extra (or    * pcre16_extra) object, or you called said function after having    * cleared the PCRE_EXTRA_EXECUTABLE_JIT bit from the "flags" field    * of the object. (The function will only free the JIT data if the    * bit remains set, as the bit indicates that the pointer to the data    * is valid.)    */
name|functions
operator|=
name|SLJIT_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|executable_functions
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|functions
operator|==
name|NULL
condition|)
block|{
comment|/* This case is highly unlikely since we just recently     freed a lot of memory. Although not impossible. */
name|sljit_free_code
argument_list|(
name|executable_func
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|functions
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|executable_functions
argument_list|)
argument_list|)
expr_stmt|;
name|functions
operator|->
name|top_bracket
operator|=
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
name|extra
operator|->
name|executable_jit
operator|=
name|functions
expr_stmt|;
name|extra
operator|->
name|flags
operator||=
name|PCRE_EXTRA_EXECUTABLE_JIT
expr_stmt|;
block|}
name|functions
operator|->
name|executable_funcs
index|[
name|mode
index|]
operator|=
name|executable_func
expr_stmt|;
name|functions
operator|->
name|executable_sizes
index|[
name|mode
index|]
operator|=
name|executable_size
expr_stmt|;
block|}
end_decl_stmt
begin_function
DECL|function|jit_machine_stack_exec
specifier|static
name|int
name|jit_machine_stack_exec
parameter_list|(
name|jit_arguments
modifier|*
name|arguments
parameter_list|,
name|void
modifier|*
name|executable_func
parameter_list|)
block|{
union|union
block|{
name|void
modifier|*
name|executable_func
decl_stmt|;
name|jit_function
name|call_executable_func
decl_stmt|;
block|}
name|convert_executable_func
union|;
name|pcre_uint8
name|local_space
index|[
name|MACHINE_STACK_SIZE
index|]
decl_stmt|;
name|struct
name|sljit_stack
name|local_stack
decl_stmt|;
name|local_stack
operator|.
name|top
operator|=
operator|(
name|sljit_sw
operator|)
operator|&
name|local_space
expr_stmt|;
name|local_stack
operator|.
name|base
operator|=
name|local_stack
operator|.
name|top
expr_stmt|;
name|local_stack
operator|.
name|limit
operator|=
name|local_stack
operator|.
name|base
operator|+
name|MACHINE_STACK_SIZE
expr_stmt|;
name|local_stack
operator|.
name|max_limit
operator|=
name|local_stack
operator|.
name|limit
expr_stmt|;
name|arguments
operator|->
name|stack
operator|=
operator|&
name|local_stack
expr_stmt|;
name|convert_executable_func
operator|.
name|executable_func
operator|=
name|executable_func
expr_stmt|;
return|return
name|convert_executable_func
operator|.
name|call_executable_func
argument_list|(
name|arguments
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
name|int
DECL|variable|subject
name|PRIV
argument_list|(
name|jit_exec
argument_list|)
argument_list|(
specifier|const
name|PUBL
argument_list|(
name|extra
argument_list|)
operator|*
name|extra_data
argument_list|,
specifier|const
name|pcre_uchar
operator|*
name|subject
argument_list|,
DECL|variable|length
DECL|variable|start_offset
DECL|variable|options
DECL|variable|offsets
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|)
block|{
name|executable_functions
modifier|*
name|functions
init|=
operator|(
name|executable_functions
operator|*
operator|)
name|extra_data
operator|->
name|executable_jit
decl_stmt|;
union|union
block|{
name|void
modifier|*
name|executable_func
decl_stmt|;
name|jit_function
name|call_executable_func
decl_stmt|;
block|}
name|convert_executable_func
union|;
name|jit_arguments
name|arguments
decl_stmt|;
name|int
name|maxoffsetcount
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|mode
init|=
name|JIT_COMPILE
decl_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
name|JIT_PARTIAL_HARD_COMPILE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_PARTIAL_SOFT
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
name|JIT_PARTIAL_SOFT_COMPILE
expr_stmt|;
if|if
condition|(
name|functions
operator|->
name|executable_funcs
index|[
name|mode
index|]
operator|==
name|NULL
condition|)
return|return
name|PCRE_ERROR_JIT_BADOPTION
return|;
comment|/* Sanity checks should be handled by pcre_exec. */
name|arguments
operator|.
name|str
operator|=
name|subject
operator|+
name|start_offset
expr_stmt|;
name|arguments
operator|.
name|begin
operator|=
name|subject
expr_stmt|;
name|arguments
operator|.
name|end
operator|=
name|subject
operator|+
name|length
expr_stmt|;
name|arguments
operator|.
name|mark_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* JIT decreases this value less frequently than the interpreter. */
name|arguments
operator|.
name|calllimit
operator|=
operator|(
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_MATCH_LIMIT
operator|)
operator|==
literal|0
operator|)
condition|?
name|MATCH_LIMIT
else|:
name|extra_data
operator|->
name|match_limit
expr_stmt|;
name|arguments
operator|.
name|notbol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTBOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|noteol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|notempty
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|notempty_atstart
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY_ATSTART
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|offsets
operator|=
name|offsets
expr_stmt|;
comment|/* pcre_exec() rounds offsetcount to a multiple of 3, and then uses only 2/3 of the output vector for storing captured strings, with the remainder used as workspace. We don't need the workspace here. For compatibility, we limit the number of captured strings in the same way as pcre_exec(), so that the user gets the same result with and without JIT. */
if|if
condition|(
name|offsetcount
operator|!=
literal|2
condition|)
name|offsetcount
operator|=
operator|(
operator|(
name|offsetcount
operator|-
operator|(
name|offsetcount
operator|%
literal|3
operator|)
operator|)
operator|*
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
name|maxoffsetcount
operator|=
name|functions
operator|->
name|top_bracket
expr_stmt|;
if|if
condition|(
name|offsetcount
operator|>
name|maxoffsetcount
condition|)
name|offsetcount
operator|=
name|maxoffsetcount
expr_stmt|;
name|arguments
operator|.
name|offsetcount
operator|=
name|offsetcount
expr_stmt|;
if|if
condition|(
name|functions
operator|->
name|callback
condition|)
name|arguments
operator|.
name|stack
operator|=
operator|(
expr|struct
name|sljit_stack
operator|*
operator|)
name|functions
operator|->
name|callback
argument_list|(
name|functions
operator|->
name|userdata
argument_list|)
expr_stmt|;
else|else
name|arguments
operator|.
name|stack
operator|=
operator|(
expr|struct
name|sljit_stack
operator|*
operator|)
name|functions
operator|->
name|userdata
expr_stmt|;
if|if
condition|(
name|arguments
operator|.
name|stack
operator|==
name|NULL
condition|)
name|retval
operator|=
name|jit_machine_stack_exec
argument_list|(
operator|&
name|arguments
argument_list|,
name|functions
operator|->
name|executable_funcs
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|convert_executable_func
operator|.
name|executable_func
operator|=
name|functions
operator|->
name|executable_funcs
index|[
name|mode
index|]
expr_stmt|;
name|retval
operator|=
name|convert_executable_func
operator|.
name|call_executable_func
argument_list|(
operator|&
name|arguments
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|*
literal|2
operator|>
name|offsetcount
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_MARK
operator|)
operator|!=
literal|0
condition|)
operator|*
operator|(
name|extra_data
operator|->
name|mark
operator|)
operator|=
name|arguments
operator|.
name|mark_ptr
expr_stmt|;
return|return
name|retval
return|;
block|}
end_decl_stmt
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_jit_exec
name|pcre_jit_exec
argument_list|(
specifier|const
name|pcre
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|,
name|pcre_jit_stack
operator|*
name|stack
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_jit_exec
argument_list|(
specifier|const
name|pcre16
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre16_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|,
name|pcre16_jit_stack
operator|*
name|stack
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre32_jit_exec
argument_list|(
specifier|const
name|pcre32
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre32_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR32
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|,
name|pcre32_jit_stack
operator|*
name|stack
argument_list|)
endif|#
directive|endif
block|{
name|pcre_uchar
modifier|*
name|subject_ptr
init|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|subject
decl_stmt|;
name|executable_functions
modifier|*
name|functions
init|=
operator|(
name|executable_functions
operator|*
operator|)
name|extra_data
operator|->
name|executable_jit
decl_stmt|;
union|union
block|{
name|void
modifier|*
name|executable_func
decl_stmt|;
name|jit_function
name|call_executable_func
decl_stmt|;
block|}
name|convert_executable_func
union|;
name|jit_arguments
name|arguments
decl_stmt|;
name|int
name|maxoffsetcount
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|mode
init|=
name|JIT_COMPILE
decl_stmt|;
name|SLJIT_UNUSED_ARG
argument_list|(
name|argument_re
argument_list|)
expr_stmt|;
comment|/* Plausibility checks */
if|if
condition|(
operator|(
name|options
operator|&
operator|~
name|PUBLIC_JIT_EXEC_OPTIONS
operator|)
operator|!=
literal|0
condition|)
return|return
name|PCRE_ERROR_JIT_BADOPTION
return|;
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
name|JIT_PARTIAL_HARD_COMPILE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_PARTIAL_SOFT
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
name|JIT_PARTIAL_SOFT_COMPILE
expr_stmt|;
if|if
condition|(
name|functions
operator|->
name|executable_funcs
index|[
name|mode
index|]
operator|==
name|NULL
condition|)
return|return
name|PCRE_ERROR_JIT_BADOPTION
return|;
comment|/* Sanity checks should be handled by pcre_exec. */
name|arguments
operator|.
name|stack
operator|=
operator|(
expr|struct
name|sljit_stack
operator|*
operator|)
name|stack
expr_stmt|;
name|arguments
operator|.
name|str
operator|=
name|subject_ptr
operator|+
name|start_offset
expr_stmt|;
name|arguments
operator|.
name|begin
operator|=
name|subject_ptr
expr_stmt|;
name|arguments
operator|.
name|end
operator|=
name|subject_ptr
operator|+
name|length
expr_stmt|;
name|arguments
operator|.
name|mark_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* JIT decreases this value less frequently than the interpreter. */
name|arguments
operator|.
name|calllimit
operator|=
operator|(
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_MATCH_LIMIT
operator|)
operator|==
literal|0
operator|)
condition|?
name|MATCH_LIMIT
else|:
name|extra_data
operator|->
name|match_limit
expr_stmt|;
name|arguments
operator|.
name|notbol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTBOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|noteol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|notempty
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|notempty_atstart
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY_ATSTART
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|offsets
operator|=
name|offsets
expr_stmt|;
comment|/* pcre_exec() rounds offsetcount to a multiple of 3, and then uses only 2/3 of the output vector for storing captured strings, with the remainder used as workspace. We don't need the workspace here. For compatibility, we limit the number of captured strings in the same way as pcre_exec(), so that the user gets the same result with and without JIT. */
if|if
condition|(
name|offsetcount
operator|!=
literal|2
condition|)
name|offsetcount
operator|=
operator|(
operator|(
name|offsetcount
operator|-
operator|(
name|offsetcount
operator|%
literal|3
operator|)
operator|)
operator|*
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
name|maxoffsetcount
operator|=
name|functions
operator|->
name|top_bracket
expr_stmt|;
if|if
condition|(
name|offsetcount
operator|>
name|maxoffsetcount
condition|)
name|offsetcount
operator|=
name|maxoffsetcount
expr_stmt|;
name|arguments
operator|.
name|offsetcount
operator|=
name|offsetcount
expr_stmt|;
name|convert_executable_func
operator|.
name|executable_func
operator|=
name|functions
operator|->
name|executable_funcs
index|[
name|mode
index|]
expr_stmt|;
name|retval
operator|=
name|convert_executable_func
operator|.
name|call_executable_func
argument_list|(
operator|&
name|arguments
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|*
literal|2
operator|>
name|offsetcount
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_MARK
operator|)
operator|!=
literal|0
condition|)
operator|*
operator|(
name|extra_data
operator|->
name|mark
operator|)
operator|=
name|arguments
operator|.
name|mark_ptr
expr_stmt|;
return|return
name|retval
return|;
block|}
end_decl_stmt
begin_function
name|void
DECL|function|jit_free
name|PRIV
function|(
name|jit_free
function|)
parameter_list|(
name|void
modifier|*
name|executable_funcs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|executable_functions
modifier|*
name|functions
init|=
operator|(
name|executable_functions
operator|*
operator|)
name|executable_funcs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JIT_NUMBER_OF_COMPILE_MODES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|functions
operator|->
name|executable_funcs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|sljit_free_code
argument_list|(
name|functions
operator|->
name|executable_funcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|SLJIT_FREE
argument_list|(
name|functions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|int
DECL|function|jit_get_size
name|PRIV
function|(
name|jit_get_size
function|)
parameter_list|(
name|void
modifier|*
name|executable_funcs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sljit_uw
name|size
init|=
literal|0
decl_stmt|;
name|sljit_uw
modifier|*
name|executable_sizes
init|=
operator|(
operator|(
name|executable_functions
operator|*
operator|)
name|executable_funcs
operator|)
operator|->
name|executable_sizes
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JIT_NUMBER_OF_COMPILE_MODES
condition|;
name|i
operator|++
control|)
name|size
operator|+=
name|executable_sizes
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|size
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|jit_get_target
name|PRIV
function|(
name|jit_get_target
function|)
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|sljit_get_platform_name
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DECL
name|pcre_jit_stack
modifier|*
DECL|function|pcre_jit_stack_alloc
name|pcre_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DECL
name|pcre16_jit_stack
modifier|*
name|pcre16_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DECL
name|pcre32_jit_stack
modifier|*
name|pcre32_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|startsize
operator|<
literal|1
operator|||
name|maxsize
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|startsize
operator|>
name|maxsize
condition|)
name|startsize
operator|=
name|maxsize
expr_stmt|;
name|startsize
operator|=
operator|(
name|startsize
operator|+
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
expr_stmt|;
name|maxsize
operator|=
operator|(
name|maxsize
operator|+
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|PUBL
argument_list|(
name|jit_stack
argument_list|)
operator|*
operator|)
name|sljit_allocate_stack
argument_list|(
name|startsize
argument_list|,
name|maxsize
argument_list|)
return|;
block|}
end_decl_stmt
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_jit_stack_free
name|pcre_jit_stack_free
argument_list|(
name|pcre_jit_stack
operator|*
name|stack
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DECL
name|void
name|pcre16_jit_stack_free
argument_list|(
name|pcre16_jit_stack
operator|*
name|stack
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DECL
name|void
name|pcre32_jit_stack_free
argument_list|(
name|pcre32_jit_stack
operator|*
name|stack
argument_list|)
endif|#
directive|endif
block|{
name|sljit_free_stack
argument_list|(
operator|(
expr|struct
name|sljit_stack
operator|*
operator|)
name|stack
argument_list|)
expr_stmt|;
block|}
end_decl_stmt
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_assign_jit_stack
name|pcre_assign_jit_stack
argument_list|(
name|pcre_extra
operator|*
name|extra
argument_list|,
name|pcre_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DECL
name|void
name|pcre16_assign_jit_stack
argument_list|(
name|pcre16_extra
operator|*
name|extra
argument_list|,
name|pcre16_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DECL
name|void
name|pcre32_assign_jit_stack
argument_list|(
name|pcre32_extra
operator|*
name|extra
argument_list|,
name|pcre32_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
endif|#
directive|endif
block|{
name|executable_functions
modifier|*
name|functions
decl_stmt|;
if|if
condition|(
name|extra
operator|!=
name|NULL
operator|&&
operator|(
name|extra
operator|->
name|flags
operator|&
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|)
operator|!=
literal|0
operator|&&
name|extra
operator|->
name|executable_jit
operator|!=
name|NULL
condition|)
block|{
name|functions
operator|=
operator|(
name|executable_functions
operator|*
operator|)
name|extra
operator|->
name|executable_jit
expr_stmt|;
name|functions
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|functions
operator|->
name|userdata
operator|=
name|userdata
expr_stmt|;
block|}
block|}
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SUPPORT_JIT */
end_comment
begin_comment
comment|/* These are dummy functions to avoid linking errors when JIT support is not being compiled. */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DECL
name|pcre_jit_stack
modifier|*
DECL|function|pcre_jit_stack_alloc
name|pcre_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DECL
name|pcre16_jit_stack
modifier|*
name|pcre16_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DECL
name|pcre32_jit_stack
modifier|*
name|pcre32_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|startsize
expr_stmt|;
operator|(
name|void
operator|)
name|maxsize
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_decl_stmt
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_jit_stack_free
name|pcre_jit_stack_free
argument_list|(
name|pcre_jit_stack
operator|*
name|stack
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DECL
name|void
name|pcre16_jit_stack_free
argument_list|(
name|pcre16_jit_stack
operator|*
name|stack
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DECL
name|void
name|pcre32_jit_stack_free
argument_list|(
name|pcre32_jit_stack
operator|*
name|stack
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|stack
expr_stmt|;
block|}
end_decl_stmt
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_assign_jit_stack
name|pcre_assign_jit_stack
argument_list|(
name|pcre_extra
operator|*
name|extra
argument_list|,
name|pcre_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DECL
name|void
name|pcre16_assign_jit_stack
argument_list|(
name|pcre16_extra
operator|*
name|extra
argument_list|,
name|pcre16_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DECL
name|void
name|pcre32_assign_jit_stack
argument_list|(
name|pcre32_extra
operator|*
name|extra
argument_list|,
name|pcre32_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|extra
expr_stmt|;
operator|(
name|void
operator|)
name|callback
expr_stmt|;
operator|(
name|void
operator|)
name|userdata
expr_stmt|;
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* End of pcre_jit_compile.c */
end_comment
end_unit
