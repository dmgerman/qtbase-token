begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2012 University of Cambridge    The machine code generator part (this module) was written by Zoltan Herczeg                       Copyright (c) 2010-2012  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_JIT
end_ifdef
begin_comment
comment|/* All-in-one: Since we use the JIT compiler only from here, we just include it. This way we don't need to touch the build system files. */
end_comment
begin_define
DECL|macro|SLJIT_MALLOC
define|#
directive|define
name|SLJIT_MALLOC
parameter_list|(
name|size
parameter_list|)
value|(PUBL(malloc))(size)
end_define
begin_define
DECL|macro|SLJIT_FREE
define|#
directive|define
name|SLJIT_FREE
parameter_list|(
name|ptr
parameter_list|)
value|(PUBL(free))(ptr)
end_define
begin_define
DECL|macro|SLJIT_CONFIG_AUTO
define|#
directive|define
name|SLJIT_CONFIG_AUTO
value|1
end_define
begin_define
DECL|macro|SLJIT_CONFIG_STATIC
define|#
directive|define
name|SLJIT_CONFIG_STATIC
value|1
end_define
begin_define
DECL|macro|SLJIT_VERBOSE
define|#
directive|define
name|SLJIT_VERBOSE
value|0
end_define
begin_define
DECL|macro|SLJIT_DEBUG
define|#
directive|define
name|SLJIT_DEBUG
value|0
end_define
begin_include
include|#
directive|include
file|"sljit/sljitLir.c"
end_include
begin_if
if|#
directive|if
name|defined
name|SLJIT_CONFIG_UNSUPPORTED
operator|&&
name|SLJIT_CONFIG_UNSUPPORTED
end_if
begin_error
error|#
directive|error
error|Unsupported architecture
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Allocate memory on the stack. Fast, but limited size. */
end_comment
begin_define
DECL|macro|LOCAL_SPACE_SIZE
define|#
directive|define
name|LOCAL_SPACE_SIZE
value|32768
end_define
begin_define
DECL|macro|STACK_GROWTH_RATE
define|#
directive|define
name|STACK_GROWTH_RATE
value|8192
end_define
begin_comment
comment|/* Enable to check that the allocation could destroy temporaries. */
end_comment
begin_if
if|#
directive|if
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
end_if
begin_define
DECL|macro|DESTROY_REGISTERS
define|#
directive|define
name|DESTROY_REGISTERS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Short summary about the backtracking mechanism empolyed by the jit code generator:  The code generator follows the recursive nature of the PERL compatible regular expressions. The basic blocks of regular expressions are condition checkers whose execute different commands depending on the result of the condition check. The relationship between the operators can be horizontal (concatenation) and vertical (sub-expression) (See struct fallback_common for more details).    'ab' - 'a' and 'b' regexps are concatenated   'a+' - 'a' is the sub-expression of the '+' operator  The condition checkers are boolean (true/false) checkers. Machine code is generated for the checker itself and for the actions depending on the result of the checker. The 'true' case is called as the hot path (expected path), and the other is called as the 'fallback' path. Branch instructions are expesive for all CPUs, so we avoid taken branches on the hot path.   Greedy star operator (*) :    Hot path: match happens.    Fallback path: match failed.  Non-greedy star operator (*?) :    Hot path: no need to perform a match.    Fallback path: match is required.  The following example shows how the code generated for a capturing bracket with two alternatives. Let A, B, C, D are arbirary regular expressions, and we have the following regular expression:     A(B|C)D  The generated code will be the following:   A hot path  '(' hot path (pushing arguments to the stack)  B hot path  ')' hot path (pushing arguments to the stack)  D hot path  return with successful match   D fallback path  ')' fallback path (If we arrived from "C" jump to the fallback of "C")  B fallback path  C expected path  jump to D hot path  C fallback path  A fallback path   Notice, that the order of fallback code paths are the opposite of the fast  code paths. In this way the topmost value on the stack is always belong  to the current fallback code path. The fallback code path must check  whether there is a next alternative. If so, it needs to jump back to  the hot path eventually. Otherwise it needs to clear out its own stack  frame and continue the execution on the fallback code paths. */
end_comment
begin_comment
comment|/* Saved stack frames:  Atomic blocks and asserts require reloading the values of local variables when the fallback mechanism performed. Because of OP_RECURSE, the locals are not necessarly known in compile time, thus we need a dynamic restore mechanism.  The stack frames are stored in a chain list, and have the following format: ([ capturing bracket offset ][ start value ][ end value ])+ ... [ 0 ] [ previous head ]  Thus we can restore the locals to a particular point in the stack. */
end_comment
begin_typedef
DECL|struct|jit_arguments
typedef|typedef
struct|struct
name|jit_arguments
block|{
comment|/* Pointers first. */
DECL|member|stack
name|struct
name|sljit_stack
modifier|*
name|stack
decl_stmt|;
DECL|member|str
specifier|const
name|pcre_uchar
modifier|*
name|str
decl_stmt|;
DECL|member|begin
specifier|const
name|pcre_uchar
modifier|*
name|begin
decl_stmt|;
DECL|member|end
specifier|const
name|pcre_uchar
modifier|*
name|end
decl_stmt|;
DECL|member|offsets
name|int
modifier|*
name|offsets
decl_stmt|;
DECL|member|ptr
name|pcre_uchar
modifier|*
name|ptr
decl_stmt|;
comment|/* Everything else after. */
DECL|member|offsetcount
name|int
name|offsetcount
decl_stmt|;
DECL|member|calllimit
name|int
name|calllimit
decl_stmt|;
DECL|member|notbol
name|pcre_uint8
name|notbol
decl_stmt|;
DECL|member|noteol
name|pcre_uint8
name|noteol
decl_stmt|;
DECL|member|notempty
name|pcre_uint8
name|notempty
decl_stmt|;
DECL|member|notempty_atstart
name|pcre_uint8
name|notempty_atstart
decl_stmt|;
block|}
DECL|typedef|jit_arguments
name|jit_arguments
typedef|;
end_typedef
begin_typedef
DECL|struct|executable_function
typedef|typedef
struct|struct
name|executable_function
block|{
DECL|member|executable_func
name|void
modifier|*
name|executable_func
decl_stmt|;
name|PUBL
argument_list|(
argument|jit_callback
argument_list|)
name|callback
expr_stmt|;
DECL|member|userdata
name|void
modifier|*
name|userdata
decl_stmt|;
DECL|member|executable_size
name|sljit_uw
name|executable_size
decl_stmt|;
block|}
DECL|typedef|executable_function
name|executable_function
typedef|;
end_typedef
begin_typedef
DECL|struct|jump_list
typedef|typedef
struct|struct
name|jump_list
block|{
DECL|member|jump
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
DECL|member|next
name|struct
name|jump_list
modifier|*
name|next
decl_stmt|;
block|}
DECL|typedef|jump_list
name|jump_list
typedef|;
end_typedef
begin_enum
DECL|enum|stub_types
DECL|enumerator|stack_alloc
enum|enum
name|stub_types
block|{
name|stack_alloc
block|}
enum|;
end_enum
begin_typedef
DECL|struct|stub_list
typedef|typedef
struct|struct
name|stub_list
block|{
DECL|member|type
name|enum
name|stub_types
name|type
decl_stmt|;
DECL|member|data
name|int
name|data
decl_stmt|;
DECL|member|start
name|struct
name|sljit_jump
modifier|*
name|start
decl_stmt|;
DECL|member|leave
name|struct
name|sljit_label
modifier|*
name|leave
decl_stmt|;
DECL|member|next
name|struct
name|stub_list
modifier|*
name|next
decl_stmt|;
block|}
DECL|typedef|stub_list
name|stub_list
typedef|;
end_typedef
begin_typedef
DECL|typedef|jit_function
typedef|typedef
name|int
function_decl|(
name|SLJIT_CALL
modifier|*
name|jit_function
function_decl|)
parameter_list|(
name|jit_arguments
modifier|*
name|args
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/* The following structure is the key data type for the recursive code generator. It is allocated by compile_hotpath, and contains the aguments for compile_fallbackpath. Must be the first member of its descendants. */
end_comment
begin_typedef
DECL|struct|fallback_common
typedef|typedef
struct|struct
name|fallback_common
block|{
comment|/* Concatenation stack. */
DECL|member|prev
name|struct
name|fallback_common
modifier|*
name|prev
decl_stmt|;
DECL|member|nextfallbacks
name|jump_list
modifier|*
name|nextfallbacks
decl_stmt|;
comment|/* Internal stack (for component operators). */
DECL|member|top
name|struct
name|fallback_common
modifier|*
name|top
decl_stmt|;
DECL|member|topfallbacks
name|jump_list
modifier|*
name|topfallbacks
decl_stmt|;
comment|/* Opcode pointer. */
DECL|member|cc
name|pcre_uchar
modifier|*
name|cc
decl_stmt|;
block|}
DECL|typedef|fallback_common
name|fallback_common
typedef|;
end_typedef
begin_typedef
DECL|struct|assert_fallback
typedef|typedef
struct|struct
name|assert_fallback
block|{
DECL|member|common
name|fallback_common
name|common
decl_stmt|;
DECL|member|condfailed
name|jump_list
modifier|*
name|condfailed
decl_stmt|;
comment|/* Less than 0 (-1) if a frame is not needed. */
DECL|member|framesize
name|int
name|framesize
decl_stmt|;
comment|/* Points to our private memory word on the stack. */
DECL|member|localptr
name|int
name|localptr
decl_stmt|;
comment|/* For iterators. */
DECL|member|hotpath
name|struct
name|sljit_label
modifier|*
name|hotpath
decl_stmt|;
block|}
DECL|typedef|assert_fallback
name|assert_fallback
typedef|;
end_typedef
begin_typedef
DECL|struct|bracket_fallback
typedef|typedef
struct|struct
name|bracket_fallback
block|{
DECL|member|common
name|fallback_common
name|common
decl_stmt|;
comment|/* Where to coninue if an alternative is successfully matched. */
DECL|member|althotpath
name|struct
name|sljit_label
modifier|*
name|althotpath
decl_stmt|;
comment|/* For rmin and rmax iterators. */
DECL|member|recursivehotpath
name|struct
name|sljit_label
modifier|*
name|recursivehotpath
decl_stmt|;
comment|/* For greedy ? operator. */
DECL|member|zerohotpath
name|struct
name|sljit_label
modifier|*
name|zerohotpath
decl_stmt|;
comment|/* Contains the branches of a failed condition. */
union|union
block|{
comment|/* Both for OP_COND, OP_SCOND. */
DECL|member|condfailed
name|jump_list
modifier|*
name|condfailed
decl_stmt|;
DECL|member|assert
name|assert_fallback
modifier|*
name|assert
decl_stmt|;
comment|/* For OP_ONCE. -1 if not needed. */
DECL|member|framesize
name|int
name|framesize
decl_stmt|;
block|}
DECL|member|u
name|u
union|;
comment|/* Points to our private memory word on the stack. */
DECL|member|localptr
name|int
name|localptr
decl_stmt|;
block|}
DECL|typedef|bracket_fallback
name|bracket_fallback
typedef|;
end_typedef
begin_typedef
DECL|struct|bracketpos_fallback
typedef|typedef
struct|struct
name|bracketpos_fallback
block|{
DECL|member|common
name|fallback_common
name|common
decl_stmt|;
comment|/* Points to our private memory word on the stack. */
DECL|member|localptr
name|int
name|localptr
decl_stmt|;
comment|/* Reverting stack is needed. */
DECL|member|framesize
name|int
name|framesize
decl_stmt|;
comment|/* Allocated stack size. */
DECL|member|stacksize
name|int
name|stacksize
decl_stmt|;
block|}
DECL|typedef|bracketpos_fallback
name|bracketpos_fallback
typedef|;
end_typedef
begin_typedef
DECL|struct|braminzero_fallback
typedef|typedef
struct|struct
name|braminzero_fallback
block|{
DECL|member|common
name|fallback_common
name|common
decl_stmt|;
DECL|member|hotpath
name|struct
name|sljit_label
modifier|*
name|hotpath
decl_stmt|;
block|}
DECL|typedef|braminzero_fallback
name|braminzero_fallback
typedef|;
end_typedef
begin_typedef
DECL|struct|iterator_fallback
typedef|typedef
struct|struct
name|iterator_fallback
block|{
DECL|member|common
name|fallback_common
name|common
decl_stmt|;
comment|/* Next iteration. */
DECL|member|hotpath
name|struct
name|sljit_label
modifier|*
name|hotpath
decl_stmt|;
block|}
DECL|typedef|iterator_fallback
name|iterator_fallback
typedef|;
end_typedef
begin_typedef
DECL|struct|recurse_entry
typedef|typedef
struct|struct
name|recurse_entry
block|{
DECL|member|next
name|struct
name|recurse_entry
modifier|*
name|next
decl_stmt|;
comment|/* Contains the function entry. */
DECL|member|entry
name|struct
name|sljit_label
modifier|*
name|entry
decl_stmt|;
comment|/* Collects the calls until the function is not created. */
DECL|member|calls
name|jump_list
modifier|*
name|calls
decl_stmt|;
comment|/* Points to the starting opcode. */
DECL|member|start
name|int
name|start
decl_stmt|;
block|}
DECL|typedef|recurse_entry
name|recurse_entry
typedef|;
end_typedef
begin_typedef
DECL|struct|recurse_fallback
typedef|typedef
struct|struct
name|recurse_fallback
block|{
DECL|member|common
name|fallback_common
name|common
decl_stmt|;
block|}
DECL|typedef|recurse_fallback
name|recurse_fallback
typedef|;
end_typedef
begin_typedef
DECL|struct|compiler_common
typedef|typedef
struct|struct
name|compiler_common
block|{
DECL|member|compiler
name|struct
name|sljit_compiler
modifier|*
name|compiler
decl_stmt|;
DECL|member|start
name|pcre_uchar
modifier|*
name|start
decl_stmt|;
DECL|member|localsize
name|int
name|localsize
decl_stmt|;
DECL|member|localptrs
name|int
modifier|*
name|localptrs
decl_stmt|;
DECL|member|fcc
specifier|const
name|pcre_uint8
modifier|*
name|fcc
decl_stmt|;
DECL|member|lcc
name|sljit_w
name|lcc
decl_stmt|;
DECL|member|cbraptr
name|int
name|cbraptr
decl_stmt|;
DECL|member|nltype
name|int
name|nltype
decl_stmt|;
DECL|member|newline
name|int
name|newline
decl_stmt|;
DECL|member|bsr_nltype
name|int
name|bsr_nltype
decl_stmt|;
DECL|member|endonly
name|int
name|endonly
decl_stmt|;
DECL|member|ctypes
name|sljit_w
name|ctypes
decl_stmt|;
DECL|member|name_table
name|sljit_uw
name|name_table
decl_stmt|;
DECL|member|name_count
name|sljit_w
name|name_count
decl_stmt|;
DECL|member|name_entry_size
name|sljit_w
name|name_entry_size
decl_stmt|;
DECL|member|acceptlabel
name|struct
name|sljit_label
modifier|*
name|acceptlabel
decl_stmt|;
DECL|member|stubs
name|stub_list
modifier|*
name|stubs
decl_stmt|;
DECL|member|entries
name|recurse_entry
modifier|*
name|entries
decl_stmt|;
DECL|member|currententry
name|recurse_entry
modifier|*
name|currententry
decl_stmt|;
DECL|member|accept
name|jump_list
modifier|*
name|accept
decl_stmt|;
DECL|member|calllimit
name|jump_list
modifier|*
name|calllimit
decl_stmt|;
DECL|member|stackalloc
name|jump_list
modifier|*
name|stackalloc
decl_stmt|;
DECL|member|revertframes
name|jump_list
modifier|*
name|revertframes
decl_stmt|;
DECL|member|wordboundary
name|jump_list
modifier|*
name|wordboundary
decl_stmt|;
DECL|member|anynewline
name|jump_list
modifier|*
name|anynewline
decl_stmt|;
DECL|member|hspace
name|jump_list
modifier|*
name|hspace
decl_stmt|;
DECL|member|vspace
name|jump_list
modifier|*
name|vspace
decl_stmt|;
DECL|member|casefulcmp
name|jump_list
modifier|*
name|casefulcmp
decl_stmt|;
DECL|member|caselesscmp
name|jump_list
modifier|*
name|caselesscmp
decl_stmt|;
DECL|member|jscript_compat
name|BOOL
name|jscript_compat
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
DECL|member|utf
name|BOOL
name|utf
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
DECL|member|use_ucp
name|BOOL
name|use_ucp
decl_stmt|;
endif|#
directive|endif
DECL|member|utfreadchar
name|jump_list
modifier|*
name|utfreadchar
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
DECL|member|utfreadtype8
name|jump_list
modifier|*
name|utfreadtype8
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
DECL|member|getucd
name|jump_list
modifier|*
name|getucd
decl_stmt|;
endif|#
directive|endif
block|}
DECL|typedef|compiler_common
name|compiler_common
typedef|;
end_typedef
begin_comment
comment|/* For byte_sequence_compare. */
end_comment
begin_typedef
DECL|struct|compare_context
typedef|typedef
struct|struct
name|compare_context
block|{
DECL|member|length
name|int
name|length
decl_stmt|;
DECL|member|sourcereg
name|int
name|sourcereg
decl_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
DECL|member|ucharptr
name|int
name|ucharptr
decl_stmt|;
union|union
block|{
DECL|member|asint
name|sljit_i
name|asint
decl_stmt|;
DECL|member|asushort
name|sljit_uh
name|asushort
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
DECL|member|asbyte
name|sljit_ub
name|asbyte
decl_stmt|;
DECL|member|asuchars
name|sljit_ub
name|asuchars
index|[
literal|4
index|]
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
DECL|member|asuchars
name|sljit_uh
name|asuchars
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
DECL|member|c
name|c
union|;
union|union
block|{
DECL|member|asint
name|sljit_i
name|asint
decl_stmt|;
DECL|member|asushort
name|sljit_uh
name|asushort
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
DECL|member|asbyte
name|sljit_ub
name|asbyte
decl_stmt|;
DECL|member|asuchars
name|sljit_ub
name|asuchars
index|[
literal|4
index|]
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
DECL|member|asuchars
name|sljit_uh
name|asuchars
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
DECL|member|oc
name|oc
union|;
endif|#
directive|endif
block|}
DECL|typedef|compare_context
name|compare_context
typedef|;
end_typedef
begin_enum
enum|enum
block|{
DECL|enumerator|frame_end
name|frame_end
init|=
literal|0
block|,
DECL|enumerator|frame_setstrbegin
name|frame_setstrbegin
init|=
operator|-
literal|1
block|}
enum|;
end_enum
begin_comment
comment|/* Undefine sljit macros. */
end_comment
begin_undef
DECL|macro|CMP
undef|#
directive|undef
name|CMP
end_undef
begin_comment
comment|/* Used for accessing the elements of the stack. */
end_comment
begin_define
DECL|macro|STACK
define|#
directive|define
name|STACK
parameter_list|(
name|i
parameter_list|)
value|((-(i) - 1) * (int)sizeof(sljit_w))
end_define
begin_define
DECL|macro|TMP1
define|#
directive|define
name|TMP1
value|SLJIT_TEMPORARY_REG1
end_define
begin_define
DECL|macro|TMP2
define|#
directive|define
name|TMP2
value|SLJIT_TEMPORARY_REG3
end_define
begin_define
DECL|macro|TMP3
define|#
directive|define
name|TMP3
value|SLJIT_TEMPORARY_EREG2
end_define
begin_define
DECL|macro|STR_PTR
define|#
directive|define
name|STR_PTR
value|SLJIT_SAVED_REG1
end_define
begin_define
DECL|macro|STR_END
define|#
directive|define
name|STR_END
value|SLJIT_SAVED_REG2
end_define
begin_define
DECL|macro|STACK_TOP
define|#
directive|define
name|STACK_TOP
value|SLJIT_TEMPORARY_REG2
end_define
begin_define
DECL|macro|STACK_LIMIT
define|#
directive|define
name|STACK_LIMIT
value|SLJIT_SAVED_REG3
end_define
begin_define
DECL|macro|ARGUMENTS
define|#
directive|define
name|ARGUMENTS
value|SLJIT_SAVED_EREG1
end_define
begin_define
DECL|macro|CALL_COUNT
define|#
directive|define
name|CALL_COUNT
value|SLJIT_SAVED_EREG2
end_define
begin_define
DECL|macro|RETURN_ADDR
define|#
directive|define
name|RETURN_ADDR
value|SLJIT_TEMPORARY_EREG1
end_define
begin_comment
comment|/* Locals layout. */
end_comment
begin_comment
comment|/* These two locals can be used by the current opcode. */
end_comment
begin_define
DECL|macro|LOCALS0
define|#
directive|define
name|LOCALS0
value|(0 * sizeof(sljit_w))
end_define
begin_define
DECL|macro|LOCALS1
define|#
directive|define
name|LOCALS1
value|(1 * sizeof(sljit_w))
end_define
begin_comment
comment|/* Two local variables for possessive quantifiers (char1 cannot use them). */
end_comment
begin_define
DECL|macro|POSSESSIVE0
define|#
directive|define
name|POSSESSIVE0
value|(2 * sizeof(sljit_w))
end_define
begin_define
DECL|macro|POSSESSIVE1
define|#
directive|define
name|POSSESSIVE1
value|(3 * sizeof(sljit_w))
end_define
begin_comment
comment|/* Head of the last recursion. */
end_comment
begin_define
DECL|macro|RECURSIVE_HEAD
define|#
directive|define
name|RECURSIVE_HEAD
value|(4 * sizeof(sljit_w))
end_define
begin_comment
comment|/* Max limit of recursions. */
end_comment
begin_define
DECL|macro|CALL_LIMIT
define|#
directive|define
name|CALL_LIMIT
value|(5 * sizeof(sljit_w))
end_define
begin_comment
comment|/* Last known position of the requested byte. */
end_comment
begin_define
DECL|macro|REQ_CHAR_PTR
define|#
directive|define
name|REQ_CHAR_PTR
value|(6 * sizeof(sljit_w))
end_define
begin_comment
comment|/* End pointer of the first line. */
end_comment
begin_define
DECL|macro|FIRSTLINE_END
define|#
directive|define
name|FIRSTLINE_END
value|(7 * sizeof(sljit_w))
end_define
begin_comment
comment|/* The output vector is stored on the stack, and contains pointers to characters. The vector data is divided into two groups: the first group contains the start / end character pointers, and the second is the start pointers when the end of the capturing group has not yet reached. */
end_comment
begin_define
DECL|macro|OVECTOR_START
define|#
directive|define
name|OVECTOR_START
value|(8 * sizeof(sljit_w))
end_define
begin_define
DECL|macro|OVECTOR
define|#
directive|define
name|OVECTOR
parameter_list|(
name|i
parameter_list|)
value|(OVECTOR_START + (i) * sizeof(sljit_w))
end_define
begin_define
DECL|macro|OVECTOR_PRIV
define|#
directive|define
name|OVECTOR_PRIV
parameter_list|(
name|i
parameter_list|)
value|(common->cbraptr + (i) * sizeof(sljit_w))
end_define
begin_define
DECL|macro|PRIV_DATA
define|#
directive|define
name|PRIV_DATA
parameter_list|(
name|cc
parameter_list|)
value|(common->localptrs[(cc) - common->start])
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_define
DECL|macro|MOV_UCHAR
define|#
directive|define
name|MOV_UCHAR
value|SLJIT_MOV_UB
end_define
begin_define
DECL|macro|MOVU_UCHAR
define|#
directive|define
name|MOVU_UCHAR
value|SLJIT_MOVU_UB
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
end_ifdef
begin_define
DECL|macro|MOV_UCHAR
define|#
directive|define
name|MOV_UCHAR
value|SLJIT_MOV_UH
end_define
begin_define
DECL|macro|MOVU_UCHAR
define|#
directive|define
name|MOVU_UCHAR
value|SLJIT_MOVU_UH
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Unsupported compiling mode
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Shortcuts. */
end_comment
begin_define
DECL|macro|DEFINE_COMPILER
define|#
directive|define
name|DEFINE_COMPILER
define|\
value|struct sljit_compiler *compiler = common->compiler
end_define
begin_define
DECL|macro|OP1
define|#
directive|define
name|OP1
parameter_list|(
name|op
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))
end_define
begin_define
DECL|macro|OP2
define|#
directive|define
name|OP2
parameter_list|(
name|op
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|src1
parameter_list|,
name|src1w
parameter_list|,
name|src2
parameter_list|,
name|src2w
parameter_list|)
define|\
value|sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))
end_define
begin_define
DECL|macro|LABEL
define|#
directive|define
name|LABEL
parameter_list|()
define|\
value|sljit_emit_label(compiler)
end_define
begin_define
DECL|macro|JUMP
define|#
directive|define
name|JUMP
parameter_list|(
name|type
parameter_list|)
define|\
value|sljit_emit_jump(compiler, (type))
end_define
begin_define
DECL|macro|JUMPTO
define|#
directive|define
name|JUMPTO
parameter_list|(
name|type
parameter_list|,
name|label
parameter_list|)
define|\
value|sljit_set_label(sljit_emit_jump(compiler, (type)), (label))
end_define
begin_define
DECL|macro|JUMPHERE
define|#
directive|define
name|JUMPHERE
parameter_list|(
name|jump
parameter_list|)
define|\
value|sljit_set_label((jump), sljit_emit_label(compiler))
end_define
begin_define
DECL|macro|CMP
define|#
directive|define
name|CMP
parameter_list|(
name|type
parameter_list|,
name|src1
parameter_list|,
name|src1w
parameter_list|,
name|src2
parameter_list|,
name|src2w
parameter_list|)
define|\
value|sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))
end_define
begin_define
DECL|macro|CMPTO
define|#
directive|define
name|CMPTO
parameter_list|(
name|type
parameter_list|,
name|src1
parameter_list|,
name|src1w
parameter_list|,
name|src2
parameter_list|,
name|src2w
parameter_list|,
name|label
parameter_list|)
define|\
value|sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))
end_define
begin_define
DECL|macro|COND_VALUE
define|#
directive|define
name|COND_VALUE
parameter_list|(
name|op
parameter_list|,
name|dst
parameter_list|,
name|dstw
parameter_list|,
name|type
parameter_list|)
define|\
value|sljit_emit_cond_value(compiler, (op), (dst), (dstw), (type))
end_define
begin_function
DECL|function|bracketend
specifier|static
name|pcre_uchar
modifier|*
name|bracketend
parameter_list|(
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
operator|*
name|cc
operator|>=
name|OP_ASSERT
operator|&&
operator|*
name|cc
operator|<=
name|OP_ASSERTBACK_NOT
operator|)
operator|||
operator|(
operator|*
name|cc
operator|>=
name|OP_ONCE
operator|&&
operator|*
name|cc
operator|<=
name|OP_SCOND
operator|)
argument_list|)
expr_stmt|;
do|do
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|>=
name|OP_KET
operator|&&
operator|*
name|cc
operator|<=
name|OP_KETRPOS
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_comment
comment|/* Functions whose might need modification for all new supported opcodes:  next_opcode  get_localspace  set_localptrs  get_framesize  init_frame  get_localsize  copy_locals  compile_hotpath  compile_fallbackpath */
end_comment
begin_function
DECL|function|next_opcode
specifier|static
name|pcre_uchar
modifier|*
name|next_opcode
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
name|SLJIT_UNUSED_ARG
argument_list|(
name|common
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYNL
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
case|case
name|OP_DEF
case|:
case|case
name|OP_BRAZERO
case|:
case|case
name|OP_BRAMINZERO
case|:
case|case
name|OP_BRAPOSZERO
case|:
case|case
name|OP_FAIL
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
case|case
name|OP_SKIPZERO
case|:
return|return
name|cc
operator|+
literal|1
return|;
case|case
name|OP_ANYBYTE
case|:
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
return|return
name|cc
operator|+
literal|1
return|;
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cc
return|;
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
name|cc
operator|+=
literal|2
operator|+
name|IMM2_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cc
return|;
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
return|return
name|cc
operator|+
literal|1
operator|+
literal|2
return|;
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
case|case
name|OP_CREF
case|:
case|case
name|OP_NCREF
case|:
case|case
name|OP_RREF
case|:
case|case
name|OP_NRREF
case|:
case|case
name|OP_CLOSE
case|:
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
return|return
name|cc
operator|+
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
return|;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
return|return
name|cc
operator|+
literal|1
operator|+
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
return|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
return|return
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
return|;
endif|#
directive|endif
case|case
name|OP_RECURSE
case|:
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_REVERSE
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
case|case
name|OP_ALT
case|:
case|case
name|OP_KET
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRPOS
case|:
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
case|case
name|OP_CBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCBRAPOS
case|:
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_function
DECL|function|get_localspace
specifier|static
name|int
name|get_localspace
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|)
block|{
name|int
name|localspace
init|=
literal|0
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
comment|/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
name|localspace
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|localspace
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
name|localspace
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
block|}
return|return
name|localspace
return|;
block|}
end_function
begin_function
DECL|function|set_localptrs
specifier|static
name|void
name|set_localptrs
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|localptr
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|cc
init|=
name|common
operator|->
name|start
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
name|common
operator|->
name|localptrs
index|[
name|cc
operator|-
name|common
operator|->
name|start
index|]
operator|=
name|localptr
expr_stmt|;
name|localptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|common
operator|->
name|localptrs
index|[
name|cc
operator|-
name|common
operator|->
name|start
index|]
operator|=
name|localptr
expr_stmt|;
name|localptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
block|{
name|common
operator|->
name|localptrs
index|[
name|cc
operator|-
name|common
operator|->
name|start
index|]
operator|=
name|localptr
expr_stmt|;
name|localptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Returns with -1 if no need for frame. */
end_comment
begin_function
DECL|function|get_framesize
specifier|static
name|int
name|get_framesize
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|BOOL
name|recursive
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|ccend
init|=
name|bracketend
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|BOOL
name|possessive
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|setsom_found
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|recursive
operator|&&
operator|(
operator|*
name|cc
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|cc
operator|==
name|OP_SCBRAPOS
operator|)
condition|)
block|{
name|length
operator|=
literal|3
expr_stmt|;
name|possessive
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_RECURSE
case|:
if|if
condition|(
operator|!
name|setsom_found
condition|)
block|{
name|length
operator|+=
literal|2
expr_stmt|;
name|setsom_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
operator|(
operator|*
name|cc
operator|==
name|OP_SET_SOM
operator|)
condition|?
literal|1
else|:
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCBRAPOS
case|:
name|length
operator|+=
literal|3
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Possessive quantifiers can use a special case. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|possessive
argument_list|)
operator|&&
name|length
operator|==
literal|3
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
return|return
name|length
operator|+
literal|1
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|init_frame
specifier|static
name|void
name|init_frame
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|int
name|stackpos
parameter_list|,
name|int
name|stacktop
parameter_list|,
name|BOOL
name|recursive
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|ccend
init|=
name|bracketend
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|BOOL
name|setsom_found
init|=
name|FALSE
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/*>= 1 + shortest item size (2) */
name|SLJIT_UNUSED_ARG
argument_list|(
name|stacktop
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|stackpos
operator|>=
name|stacktop
operator|+
literal|2
argument_list|)
expr_stmt|;
name|stackpos
operator|=
name|STACK
argument_list|(
name|stackpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|||
operator|(
operator|*
name|cc
operator|!=
name|OP_CBRAPOS
operator|&&
operator|*
name|cc
operator|!=
name|OP_SCBRAPOS
operator|)
condition|)
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_RECURSE
case|:
if|if
condition|(
operator|!
name|setsom_found
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setstrbegin
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|setsom_found
operator|=
name|TRUE
expr_stmt|;
block|}
name|cc
operator|+=
operator|(
operator|*
name|cc
operator|==
name|OP_SET_SOM
operator|)
condition|?
literal|1
else|:
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCBRAPOS
case|:
name|offset
operator|=
operator|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
operator|)
operator|<<
literal|1
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackpos
operator|+=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackpos
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_end
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|stackpos
operator|==
name|STACK
argument_list|(
name|stacktop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_localsize
specifier|static
name|SLJIT_INLINE
name|int
name|get_localsize
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|)
block|{
name|int
name|localsize
init|=
literal|2
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
comment|/* Calculate the sum of the local variables. */
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
name|localsize
operator|++
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
name|localsize
operator|++
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|localsize
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
name|localsize
operator|++
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|==
name|ccend
argument_list|)
expr_stmt|;
return|return
name|localsize
return|;
block|}
end_function
begin_function
DECL|function|copy_locals
specifier|static
name|void
name|copy_locals
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|,
name|BOOL
name|save
parameter_list|,
name|int
name|stackptr
parameter_list|,
name|int
name|stacktop
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|srcw
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|BOOL
name|tmp1next
init|=
name|TRUE
decl_stmt|;
name|BOOL
name|tmp1empty
init|=
name|TRUE
decl_stmt|;
name|BOOL
name|tmp2empty
init|=
name|TRUE
decl_stmt|;
name|pcre_uchar
modifier|*
name|alternative
decl_stmt|;
enum|enum
block|{
name|start
block|,
name|loop
block|,
name|end
block|}
name|status
enum|;
name|status
operator|=
name|save
condition|?
name|start
else|:
name|loop
expr_stmt|;
name|stackptr
operator|=
name|STACK
argument_list|(
name|stackptr
operator|-
literal|2
argument_list|)
expr_stmt|;
name|stacktop
operator|=
name|STACK
argument_list|(
name|stacktop
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|save
condition|)
block|{
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackptr
operator|<
name|stacktop
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|tmp1empty
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|stackptr
operator|<
name|stacktop
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|tmp2empty
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* The tmp1next must be TRUE in either way. */
block|}
while|while
condition|(
name|status
operator|!=
name|end
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|start
case|:
name|SLJIT_ASSERT
argument_list|(
name|save
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|RECURSIVE_HEAD
expr_stmt|;
name|status
operator|=
name|loop
expr_stmt|;
break|break;
case|case
name|loop
case|:
if|if
condition|(
name|cc
operator|>=
name|ccend
condition|)
block|{
name|status
operator|=
name|end
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCOND
case|:
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIV_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|srcw
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|OVECTOR_PRIV
argument_list|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|count
operator|=
literal|2
expr_stmt|;
name|srcw
index|[
literal|1
index|]
operator|=
name|OVECTOR_PRIV
argument_list|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIV_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|srcw
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
comment|/* Might be a hidden SCOND. */
name|alternative
operator|=
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|alternative
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|alternative
operator|==
name|OP_KETRMIN
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|srcw
index|[
literal|0
index|]
operator|=
name|PRIV_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|srcw
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
default|default:
name|cc
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|end
case|:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|save
condition|)
block|{
if|if
condition|(
name|tmp1next
condition|)
block|{
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|tmp1empty
operator|=
name|FALSE
expr_stmt|;
name|tmp1next
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|tmp2empty
operator|=
name|FALSE
expr_stmt|;
name|tmp1next
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tmp1next
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|tmp1empty
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp1empty
operator|=
name|stackptr
operator|>=
name|stacktop
expr_stmt|;
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
name|tmp1next
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|tmp2empty
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|srcw
index|[
name|count
index|]
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp2empty
operator|=
name|stackptr
operator|>=
name|stacktop
expr_stmt|;
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
name|tmp1next
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|save
condition|)
block|{
if|if
condition|(
name|tmp1next
condition|)
block|{
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tmp2empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp1empty
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|stackptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stackptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|==
name|ccend
operator|&&
name|stackptr
operator|==
name|stacktop
operator|&&
operator|(
name|save
operator|||
operator|(
name|tmp1empty
operator|&&
name|tmp2empty
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ispowerof2
specifier|static
name|SLJIT_INLINE
name|BOOL
name|ispowerof2
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|)
block|{
return|return
operator|(
name|value
operator|&
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|set_jumps
specifier|static
name|SLJIT_INLINE
name|void
name|set_jumps
parameter_list|(
name|jump_list
modifier|*
name|list
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* sljit_set_label is clever enough to do nothing   if either the jump or the label is NULL */
name|sljit_set_label
argument_list|(
name|list
operator|->
name|jump
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_jump
specifier|static
name|SLJIT_INLINE
name|void
name|add_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|)
block|{
name|jump_list
modifier|*
name|list_item
init|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|list_item
condition|)
block|{
name|list_item
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
name|list_item
operator|->
name|jump
operator|=
name|jump
expr_stmt|;
operator|*
name|list
operator|=
name|list_item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_stub
specifier|static
name|void
name|add_stub
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|enum
name|stub_types
name|type
parameter_list|,
name|int
name|data
parameter_list|,
name|struct
name|sljit_jump
modifier|*
name|start
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|stub_list
modifier|*
name|list_item
init|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|stub_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|list_item
condition|)
block|{
name|list_item
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|list_item
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|list_item
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|list_item
operator|->
name|leave
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|list_item
operator|->
name|next
operator|=
name|common
operator|->
name|stubs
expr_stmt|;
name|common
operator|->
name|stubs
operator|=
name|list_item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|flush_stubs
specifier|static
name|void
name|flush_stubs
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|stub_list
modifier|*
name|list_item
init|=
name|common
operator|->
name|stubs
decl_stmt|;
while|while
condition|(
name|list_item
condition|)
block|{
name|JUMPHERE
argument_list|(
name|list_item
operator|->
name|start
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|list_item
operator|->
name|type
condition|)
block|{
case|case
name|stack_alloc
case|:
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|stackalloc
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|list_item
operator|->
name|leave
argument_list|)
expr_stmt|;
name|list_item
operator|=
name|list_item
operator|->
name|next
expr_stmt|;
block|}
name|common
operator|->
name|stubs
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decrease_call_count
specifier|static
name|SLJIT_INLINE
name|void
name|decrease_call_count
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|CALL_COUNT
argument_list|,
literal|0
argument_list|,
name|CALL_COUNT
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|calllimit
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|allocate_stack
specifier|static
name|SLJIT_INLINE
name|void
name|allocate_stack
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* May destroy all locals and registers except TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DESTROY_REGISTERS
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|12345
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_stub
argument_list|(
name|common
argument_list|,
name|stack_alloc
argument_list|,
literal|0
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_LIMIT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_stack
specifier|static
name|SLJIT_INLINE
name|void
name|free_stack
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reset_ovector
specifier|static
name|SLJIT_INLINE
name|void
name|reset_ovector
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* At this point we can freely use all temporary registers. */
comment|/* TMP1 returns with begin - 1. */
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|8
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|i
argument_list|)
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|OVECTOR_START
operator|-
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOVU
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_TEMPORARY_REG2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copy_ovector
specifier|static
name|SLJIT_INLINE
name|void
name|copy_ovector
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|topbracket
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|earlyexit
decl_stmt|;
comment|/* At this point we can freely use all registers. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_SAVED_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_TEMPORARY_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|offsetcount
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_TEMPORARY_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|offsets
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_TEMPORARY_REG1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|OVECTOR_START
argument_list|)
expr_stmt|;
comment|/* Unlikely, but possible */
name|earlyexit
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the integer value to the output buffer */
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|OP2
argument_list|(
name|SLJIT_ASHR
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOVU_SI
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_TEMPORARY_REG3
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|earlyexit
argument_list|)
expr_stmt|;
comment|/* Calculate the return value, which is the maximum ovector value. */
if|if
condition|(
name|topbracket
operator|>
literal|1
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|OVECTOR_START
operator|+
name|topbracket
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|topbracket
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* OVECTOR(0) is never equal to SLJIT_SAVED_REG3. */
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOVU
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_TEMPORARY_REG1
argument_list|)
argument_list|,
operator|-
operator|(
literal|2
operator|*
operator|(
name|sljit_w
operator|)
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG3
argument_list|,
literal|0
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|char_has_othercase
specifier|static
name|SLJIT_INLINE
name|BOOL
name|char_has_othercase
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
comment|/* Detects if the character has an othercase. */
name|unsigned
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
return|return
name|c
operator|!=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
return|return
name|common
operator|->
name|fcc
index|[
name|c
index|]
operator|!=
name|c
return|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
expr_stmt|;
return|return
name|MAX_255
argument_list|(
name|c
argument_list|)
condition|?
name|common
operator|->
name|fcc
index|[
name|c
index|]
operator|!=
name|c
else|:
name|FALSE
return|;
block|}
end_function
begin_function
DECL|function|char_othercase
specifier|static
name|SLJIT_INLINE
name|unsigned
name|int
name|char_othercase
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|unsigned
name|int
name|c
parameter_list|)
block|{
comment|/* Returns with the othercase. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|c
operator|>
literal|127
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
return|return
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
return|;
else|#
directive|else
return|return
name|c
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|TABLE_GET
argument_list|(
name|c
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|char_get_othercase_bit
specifier|static
name|unsigned
name|int
name|char_get_othercase_bit
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
comment|/* Detects if the character and its othercase has only 1 bit difference. */
name|unsigned
name|int
name|c
decl_stmt|,
name|oc
decl_stmt|,
name|bit
decl_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
name|int
name|n
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|127
condition|)
name|oc
operator|=
name|common
operator|->
name|fcc
index|[
name|c
index|]
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|oc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|oc
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|c
operator|=
operator|*
name|cc
expr_stmt|;
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|c
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
operator|*
name|cc
expr_stmt|;
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|c
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|c
operator|!=
name|oc
argument_list|)
expr_stmt|;
name|bit
operator|=
name|c
operator|^
name|oc
expr_stmt|;
comment|/* Optimized for English alphabet. */
if|if
condition|(
name|c
operator|<=
literal|127
operator|&&
name|bit
operator|==
literal|0x20
condition|)
return|return
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
literal|0x20
return|;
comment|/* Since c != oc, they must have at least 1 bit difference. */
if|if
condition|(
operator|!
name|ispowerof2
argument_list|(
name|bit
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|c
operator|>
literal|127
condition|)
block|{
name|n
operator|=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bit
operator|&
literal|0x3f
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|--
expr_stmt|;
name|bit
operator|>>=
literal|6
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|<<
literal|8
operator|)
operator||
name|bit
return|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF */
return|return
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
name|bit
return|;
else|#
directive|else
comment|/* COMPILE_PCRE8 */
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|c
operator|>
literal|65535
condition|)
block|{
if|if
condition|(
name|bit
operator|>=
operator|(
literal|1
operator|<<
literal|10
operator|)
condition|)
name|bit
operator|>>=
literal|10
expr_stmt|;
else|else
return|return
operator|(
name|bit
operator|<
literal|256
operator|)
condition|?
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator||
name|bit
operator|)
else|:
operator|(
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
operator|(
name|bit
operator|>>
literal|8
operator|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF */
return|return
operator|(
name|bit
operator|<
literal|256
operator|)
condition|?
operator|(
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
name|bit
operator|)
else|:
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
name|bit
operator|>>
literal|8
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* COMPILE_PCRE16 */
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|}
end_function
begin_function
DECL|function|check_input_end
specifier|static
name|SLJIT_INLINE
name|void
name|check_input_end
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_char
specifier|static
name|void
name|read_char
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Reads the character into TMP1, updates STR_PTR. Does not check STR_END. TMP2 Destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|utfreadchar
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|peek_char
specifier|static
name|void
name|peek_char
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Reads the character into TMP1, keeps STR_PTR. Does not check STR_END. TMP2 Destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|utfreadchar
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|read_char8_type
specifier|static
name|void
name|read_char8_type
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */
name|DEFINE_COMPILER
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
comment|/* This can be an extra read in some situations, but hopefully   it is needed in most cases. */
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|utfreadtype8
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Skip low surrogate if necessary. */
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
return|return;
block|}
endif|#
directive|endif
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
comment|/* The ctypes array contains only 256 values. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|skip_char_back
specifier|static
name|void
name|skip_char_back
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Goes one character back. Affects STR_PTR and TMP1. Does not check begin. */
name|DEFINE_COMPILER
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x80
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip low surrogate if necessary. */
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xdc00
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_newlinechar
specifier|static
name|void
name|check_newlinechar
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|int
name|nltype
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|,
name|BOOL
name|jumpiftrue
parameter_list|)
block|{
comment|/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
if|if
condition|(
name|nltype
operator|==
name|NLTYPE_ANY
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|anynewline
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|jumpiftrue
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|jumpiftrue
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|<
literal|256
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|jumpiftrue
condition|?
name|SLJIT_C_EQUAL
else|:
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UTF
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_function
DECL|function|do_utfreadchar
specifier|static
name|void
name|do_utfreadchar
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Fast decoding a UTF-8 character. TMP1 contains the first byte of the character (>= 0xc0). Return char value in TMP1, length - 1 in TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
comment|/* Searching for the first zero. */
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
comment|/* Two byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
comment|/* Three byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Four byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|do_utfreadtype8
specifier|static
name|void
name|do_utfreadtype8
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Fast decoding a UTF-8 character type. TMP2 contains the first byte of the character (>= 0xc0). Return value in TMP1. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|compare
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
comment|/* Two byte sequence. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compare
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|compare
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* We only have types for characters less than 256. */
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* COMPILE_PCRE8 */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
end_ifdef
begin_function
DECL|function|do_utfreadchar
specifier|static
name|void
name|do_utfreadchar
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Fast decoding a UTF-16 character. TMP1 contains the first 16 bit char of the character (>= 0xd800). Return char value in TMP1, length - 1 in TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xdc00
argument_list|)
expr_stmt|;
comment|/* Do nothing, only return. */
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Combine two 16 bit characters. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3ff
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3ff
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE16 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE8 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UTF */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UCP
end_ifdef
begin_comment
comment|/* UCD_BLOCK_SIZE must be 128 (see the assert below). */
end_comment
begin_define
DECL|macro|UCD_BLOCK_MASK
define|#
directive|define
name|UCD_BLOCK_MASK
value|127
end_define
begin_define
DECL|macro|UCD_BLOCK_SHIFT
define|#
directive|define
name|UCD_BLOCK_SHIFT
value|7
end_define
begin_function
DECL|function|do_getucd
specifier|static
name|void
name|do_getucd
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Search the UCD record for the character comes in TMP1. Returns chartype in TMP1 and UCD offset in TMP2. */
name|DEFINE_COMPILER
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|UCD_BLOCK_SIZE
operator|==
literal|128
operator|&&
sizeof|sizeof
argument_list|(
name|ucd_record
argument_list|)
operator|==
literal|8
argument_list|)
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCD_BLOCK_SHIFT
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|ucd_stage1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCD_BLOCK_MASK
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|UCD_BLOCK_SHIFT
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|ucd_stage2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|TMP2
argument_list|,
name|TMP1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|chartype
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|TMP1
argument_list|,
name|TMP2
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
DECL|function|mainloop_entry
specifier|static
name|SLJIT_INLINE
expr|struct
name|sljit_label
operator|*
name|mainloop_entry
argument_list|(
argument|compiler_common *common
argument_list|,
argument|BOOL hascrorlf
argument_list|,
argument|BOOL firstline
argument_list|)
block|{
name|DEFINE_COMPILER
block|; struct
name|sljit_label
operator|*
name|mainloop
block|; struct
name|sljit_label
operator|*
name|newlinelabel
operator|=
name|NULL
block|; struct
name|sljit_jump
operator|*
name|start
block|; struct
name|sljit_jump
operator|*
name|end
operator|=
name|NULL
block|; struct
name|sljit_jump
operator|*
name|nl
operator|=
name|NULL
block|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
block|struct
name|sljit_jump
operator|*
name|singlechar
block|;
endif|#
directive|endif
name|jump_list
operator|*
name|newline
operator|=
name|NULL
block|;
name|BOOL
name|newlinecheck
operator|=
name|FALSE
block|;
name|BOOL
name|readuchar
operator|=
name|FALSE
block|;
if|if
condition|(
operator|!
operator|(
name|hascrorlf
operator|||
name|firstline
operator|)
operator|&&
operator|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
operator|||
name|common
operator|->
name|newline
operator|>
literal|255
operator|)
condition|)
name|newlinecheck
operator|=
name|TRUE
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|firstline
condition|)
block|{
comment|/* Search for the end of the first line. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
comment|/* Continual stores does not cause data dependency. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
operator|&
name|newline
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|newline
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|start
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|newlinecheck
condition|)
block|{
name|newlinelabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* Increasing the STR_PTR here requires one less jump in the most common case. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UTF
end_ifdef
begin_if
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|readuchar
operator|=
name|TRUE
expr_stmt|;
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|if
condition|(
name|newlinecheck
condition|)
name|readuchar
operator|=
name|TRUE
expr_stmt|;
end_if
begin_if
if|if
condition|(
name|readuchar
condition|)
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if
begin_if
if|if
condition|(
name|newlinecheck
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|newlinelabel
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
end_if
begin_if
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|singlechar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|singlechar
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE16
end_if
begin_if
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|singlechar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|singlechar
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|start
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|newlinecheck
condition|)
block|{
name|JUMPHERE
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|nl
argument_list|)
expr_stmt|;
block|}
end_if
begin_return
return|return
name|mainloop
return|;
end_return
begin_function
unit|}  static
DECL|function|fast_forward_first_char
name|SLJIT_INLINE
name|void
name|fast_forward_first_char
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
name|first_char
parameter_list|,
name|BOOL
name|caseless
parameter_list|,
name|BOOL
name|firstline
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|start
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|leave
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|found
decl_stmt|;
name|pcre_uchar
name|oc
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|firstline
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|leave
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oc
operator|=
name|first_char
expr_stmt|;
if|if
condition|(
name|caseless
condition|)
block|{
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|first_char
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|first_char
operator|>
literal|127
operator|&&
name|common
operator|->
name|utf
condition|)
name|oc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|first_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|first_char
operator|==
name|oc
condition|)
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
else|else
block|{
name|bit
operator|=
name|first_char
operator|^
name|oc
expr_stmt|;
if|if
condition|(
name|ispowerof2
argument_list|(
name|bit
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|first_char
operator||
name|bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|found
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
block|}
block|}
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|leave
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fast_forward_newline
specifier|static
name|SLJIT_INLINE
name|void
name|fast_forward_newline
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|BOOL
name|firstline
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|lastchar
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|firstchar
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|leave
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|foundcr
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|notfoundnl
decl_stmt|;
name|jump_list
modifier|*
name|newline
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|firstline
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|lastchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|firstchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_GREATER_EQUAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|leave
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|leave
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|firstchar
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|lastchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
return|return;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|firstchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|lastchar
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
name|foundcr
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
operator|&
name|newline
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|newline
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
block|{
name|leave
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|foundcr
argument_list|)
expr_stmt|;
name|notfoundnl
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|notfoundnl
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|leave
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|lastchar
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|firstchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fast_forward_start_bits
specifier|static
name|SLJIT_INLINE
name|void
name|fast_forward_start_bits
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|sljit_uw
name|start_bits
parameter_list|,
name|BOOL
name|firstline
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_label
modifier|*
name|start
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|leave
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|found
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|firstline
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|leave
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|start_bits
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|found
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|leave
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
block|}
end_function
begin_expr_stmt
DECL|function|search_requested_char
specifier|static
name|SLJIT_INLINE
expr|struct
name|sljit_jump
operator|*
name|search_requested_char
argument_list|(
argument|compiler_common *common
argument_list|,
argument|pcre_uchar req_char
argument_list|,
argument|BOOL caseless
argument_list|,
argument|BOOL has_firstchar
argument_list|)
block|{
name|DEFINE_COMPILER
block|; struct
name|sljit_label
operator|*
name|loop
block|; struct
name|sljit_jump
operator|*
name|toolong
block|; struct
name|sljit_jump
operator|*
name|alreadyfound
block|; struct
name|sljit_jump
operator|*
name|found
block|; struct
name|sljit_jump
operator|*
name|foundoc
operator|=
name|NULL
block|; struct
name|sljit_jump
operator|*
name|notfound
block|;
name|pcre_uchar
name|oc
block|,
name|bit
block|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|REQ_CHAR_PTR
argument_list|)
block|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|REQ_BYTE_MAX
argument_list|)
block|;
name|toolong
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
block|;
name|alreadyfound
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
block|;
if|if
condition|(
name|has_firstchar
condition|)
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|notfound
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|oc
operator|=
name|req_char
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|caseless
condition|)
block|{
name|oc
operator|=
name|TABLE_GET
argument_list|(
name|req_char
argument_list|,
name|common
operator|->
name|fcc
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|req_char
operator|>
literal|127
operator|&&
name|common
operator|->
name|utf
condition|)
name|oc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|req_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_if
begin_if
if|if
condition|(
name|req_char
operator|==
name|oc
condition|)
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
else|else
block|{
name|bit
operator|=
name|req_char
operator|^
name|oc
expr_stmt|;
if|if
condition|(
name|ispowerof2
argument_list|(
name|bit
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|req_char
operator||
name|bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|found
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
name|foundoc
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|oc
argument_list|)
expr_stmt|;
block|}
block|}
end_if
begin_expr_stmt
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|loop
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|found
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|foundoc
condition|)
name|JUMPHERE
argument_list|(
name|foundoc
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|REQ_CHAR_PTR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|alreadyfound
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|JUMPHERE
argument_list|(
name|toolong
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|notfound
return|;
end_return
begin_function
unit|}  static
DECL|function|do_revertframes
name|void
name|do_revertframes
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|mainloop
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Drop frames until we reach STACK_TOP. */
name|mainloop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_SIG_LESS_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_end
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_end
argument_list|)
expr_stmt|;
comment|/* End of dropping frames. */
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|frame_setstrbegin
argument_list|)
expr_stmt|;
comment|/* Set string begin. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Unknown command. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_wordboundary
specifier|static
name|void
name|check_wordboundary
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|beginend
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
operator|||
name|defined
name|SUPPORT_UTF
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
endif|#
directive|endif
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|ctype_word
operator|==
literal|0x10
argument_list|,
name|ctype_word_must_be_16
argument_list|)
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
comment|/* Get type of the previous char, and put it to LOCALS1. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beginend
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
comment|/* Testing char type. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|use_ucp
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_UNDERSCORE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Nd
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_No
operator|-
name|ucp_Nd
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
comment|/* Here LOCALS1 has already been zeroed. */
name|jump
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|4
comment|/* ctype_word */
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|}
name|JUMPHERE
argument_list|(
name|beginend
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beginend
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|peek_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
comment|/* Testing char type. This is a code duplication. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|use_ucp
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_UNDERSCORE
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Nd
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_No
operator|-
name|ucp_Nd
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
comment|/* TMP2 may be destroyed by peek_char. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|common
operator|->
name|ctypes
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|4
comment|/* ctype_word */
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|}
name|JUMPHERE
argument_list|(
name|beginend
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_XOR
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_anynewline
specifier|static
name|void
name|check_anynewline
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Check whether TMP1 contains a newline character. TMP2 destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0d
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x85
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
endif|#
directive|endif
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x2029
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF || COMPILE_PCRE16 */
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_hspace
specifier|static
name|void
name|check_hspace
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Check whether TMP1 contains a newline character. TMP2 destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x09
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
endif|#
directive|endif
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1680
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x180e
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x200A
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x202f
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x205f
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x3000
operator|-
literal|0x2000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF || COMPILE_PCRE16 */
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_vspace
specifier|static
name|void
name|check_vspace
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
comment|/* Check whether TMP1 contains a newline character. TMP2 destroyed. */
name|DEFINE_COMPILER
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x0d
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x85
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
endif|#
directive|endif
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x2029
operator|-
literal|0x0a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF || COMPILE_PCRE16 */
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|CHAR1
define|#
directive|define
name|CHAR1
value|STR_END
end_define
begin_define
DECL|macro|CHAR2
define|#
directive|define
name|CHAR2
value|STACK_TOP
end_define
begin_function
DECL|function|do_casefulcmp
specifier|static
name|void
name|do_casefulcmp
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|LCC_TABLE
define|#
directive|define
name|LCC_TABLE
value|STACK_LIMIT
end_define
begin_function
DECL|function|do_caselesscmp
specifier|static
name|void
name|do_caselesscmp
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|LCC_TABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|LCC_TABLE
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|lcc
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOVU_UCHAR
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|LCC_TABLE
argument_list|,
name|CHAR1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|LCC_TABLE
argument_list|,
name|CHAR2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|LCC_TABLE
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CHAR2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|LCC_TABLE
undef|#
directive|undef
name|LCC_TABLE
end_undef
begin_undef
DECL|macro|CHAR1
undef|#
directive|undef
name|CHAR1
end_undef
begin_undef
DECL|macro|CHAR2
undef|#
directive|undef
name|CHAR2
end_undef
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|SUPPORT_UCP
end_if
begin_function
DECL|function|do_utf_caselesscmp
specifier|static
specifier|const
name|pcre_uchar
modifier|*
name|SLJIT_CALL
name|do_utf_caselesscmp
parameter_list|(
name|pcre_uchar
modifier|*
name|src1
parameter_list|,
name|jit_arguments
modifier|*
name|args
parameter_list|,
name|pcre_uchar
modifier|*
name|end1
parameter_list|)
block|{
comment|/* This function would be ineffective to do in JIT level. */
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|src2
init|=
name|args
operator|->
name|ptr
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|end2
init|=
name|args
operator|->
name|end
decl_stmt|;
while|while
condition|(
name|src1
operator|<
name|end1
condition|)
block|{
if|if
condition|(
name|src2
operator|>=
name|end2
condition|)
return|return
literal|0
return|;
name|GETCHARINC
argument_list|(
name|c1
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|GETCHARINC
argument_list|(
name|c2
argument_list|,
name|src2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
operator|&&
name|c1
operator|!=
name|UCD_OTHERCASE
argument_list|(
name|c2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
name|src2
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UTF&& SUPPORT_UCP */
end_comment
begin_function
DECL|function|byte_sequence_compare
specifier|static
name|pcre_uchar
modifier|*
name|byte_sequence_compare
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|BOOL
name|caseless
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|compare_context
modifier|*
name|context
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|unsigned
name|int
name|othercasebit
init|=
literal|0
decl_stmt|;
name|pcre_uchar
modifier|*
name|othercasechar
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|int
name|utflength
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|caseless
operator|&&
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
block|{
name|othercasebit
operator|=
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|othercasebit
argument_list|)
expr_stmt|;
comment|/* Extracting bit difference info. */
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|othercasechar
operator|=
name|cc
operator|+
operator|(
name|othercasebit
operator|>>
literal|8
operator|)
expr_stmt|;
name|othercasebit
operator|&=
literal|0xff
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|othercasechar
operator|=
name|cc
operator|+
operator|(
name|othercasebit
operator|>>
literal|9
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|othercasebit
operator|&
literal|0x100
operator|)
operator|!=
literal|0
condition|)
name|othercasebit
operator|=
operator|(
name|othercasebit
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
else|else
name|othercasebit
operator|&=
literal|0xff
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|context
operator|->
name|sourcereg
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|4
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|2
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|4
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
name|context
operator|->
name|sourcereg
operator|=
name|TMP2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|utflength
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
condition|)
name|utflength
operator|+=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
do|do
block|{
endif|#
directive|endif
name|context
operator|->
name|length
operator|-=
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
comment|/* Unaligned read is supported. */
if|if
condition|(
name|othercasebit
operator|!=
literal|0
operator|&&
name|othercasechar
operator|==
name|cc
condition|)
block|{
name|context
operator|->
name|c
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
operator|*
name|cc
operator||
name|othercasebit
expr_stmt|;
name|context
operator|->
name|oc
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
name|othercasebit
expr_stmt|;
block|}
else|else
block|{
name|context
operator|->
name|c
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
operator|*
name|cc
expr_stmt|;
name|context
operator|->
name|oc
operator|.
name|asuchars
index|[
name|context
operator|->
name|ucharptr
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|context
operator|->
name|ucharptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|context
operator|->
name|ucharptr
operator|>=
literal|4
operator|||
name|context
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
name|context
operator|->
name|ucharptr
operator|==
literal|2
operator|&&
name|context
operator|->
name|length
operator|==
literal|1
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|context
operator|->
name|ucharptr
operator|>=
literal|2
operator|||
name|context
operator|->
name|length
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|4
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|2
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|1
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|context
operator|->
name|length
operator|>=
literal|2
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|context
operator|->
name|sourcereg
operator|=
name|context
operator|->
name|sourcereg
operator|==
name|TMP1
condition|?
name|TMP2
else|:
name|TMP1
expr_stmt|;
switch|switch
condition|(
name|context
operator|->
name|ucharptr
condition|)
block|{
case|case
literal|4
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
case|:
if|if
condition|(
name|context
operator|->
name|oc
operator|.
name|asint
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|oc
operator|.
name|asint
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|c
operator|.
name|asint
operator||
name|context
operator|->
name|oc
operator|.
name|asint
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
case|:
if|if
condition|(
name|context
operator|->
name|oc
operator|.
name|asushort
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|oc
operator|.
name|asushort
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|c
operator|.
name|asushort
operator||
name|context
operator|->
name|oc
operator|.
name|asushort
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
case|case
literal|1
case|:
if|if
condition|(
name|context
operator|->
name|oc
operator|.
name|asbyte
operator|!=
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|oc
operator|.
name|asbyte
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|->
name|c
operator|.
name|asbyte
operator||
name|context
operator|->
name|oc
operator|.
name|asbyte
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|context
operator|->
name|ucharptr
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* Unaligned read is unsupported. */
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|context
operator|->
name|length
operator|>
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|context
operator|->
name|length
operator|>
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
operator|-
name|context
operator|->
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|context
operator|->
name|sourcereg
operator|=
name|context
operator|->
name|sourcereg
operator|==
name|TMP1
condition|?
name|TMP2
else|:
name|TMP1
expr_stmt|;
if|if
condition|(
name|othercasebit
operator|!=
literal|0
operator|&&
name|othercasechar
operator|==
name|cc
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|othercasebit
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|*
name|cc
operator||
name|othercasebit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|context
operator|->
name|sourcereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|*
name|cc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|utflength
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|utflength
operator|>
literal|0
condition|)
do|;
endif|#
directive|endif
return|return
name|cc
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
end_if
begin_define
DECL|macro|SET_TYPE_OFFSET
define|#
directive|define
name|SET_TYPE_OFFSET
parameter_list|(
name|value
parameter_list|)
define|\
value|if ((value) != typeoffset) \     { \     if ((value)> typeoffset) \       OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \     else \       OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \     } \   typeoffset = (value);
end_define
begin_define
DECL|macro|SET_CHAR_OFFSET
define|#
directive|define
name|SET_CHAR_OFFSET
parameter_list|(
name|value
parameter_list|)
define|\
value|if ((value) != charoffset) \     { \     if ((value)> charoffset) \       OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (value) - charoffset); \     else \       OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, charoffset - (value)); \     } \   charoffset = (value);
end_define
begin_function
DECL|function|compile_xclass_hotpath
specifier|static
name|void
name|compile_xclass_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|jump_list
modifier|*
name|found
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
modifier|*
name|list
init|=
operator|(
operator|*
name|cc
operator|&
name|XCL_NOT
operator|)
operator|==
literal|0
condition|?
operator|&
name|found
else|:
name|fallbacks
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|compares
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|BOOL
name|needstype
init|=
name|FALSE
decl_stmt|,
name|needsscript
init|=
name|FALSE
decl_stmt|,
name|needschar
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|charsaved
init|=
name|FALSE
decl_stmt|;
name|int
name|typereg
init|=
name|TMP1
decl_stmt|,
name|scriptreg
init|=
name|TMP1
decl_stmt|;
name|unsigned
name|int
name|typeoffset
decl_stmt|;
endif|#
directive|endif
name|int
name|invertcmp
decl_stmt|,
name|numberofcmps
decl_stmt|;
name|unsigned
name|int
name|charoffset
decl_stmt|;
comment|/* Although SUPPORT_UTF must be defined, we are not necessary in utf mode. */
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cc
operator|++
operator|&
name|XCL_MAP
operator|)
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|cc
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|list
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|charsaved
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|cc
operator|+=
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
block|}
comment|/* Scanning the necessary info. */
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|compares
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cc
operator|!=
name|XCL_END
condition|)
block|{
name|compares
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
condition|)
block|{
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|needschar
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_RANGE
condition|)
block|{
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|needschar
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|==
name|XCL_PROP
operator|||
operator|*
name|cc
operator|==
name|XCL_NOTPROP
argument_list|)
expr_stmt|;
name|cc
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|PT_ANY
case|:
break|break;
case|case
name|PT_LAMP
case|:
case|case
name|PT_GC
case|:
case|case
name|PT_PC
case|:
case|case
name|PT_ALNUM
case|:
name|needstype
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|needsscript
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_SPACE
case|:
case|case
name|PT_PXSPACE
case|:
case|case
name|PT_WORD
case|:
name|needstype
operator|=
name|TRUE
expr_stmt|;
name|needschar
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|cc
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
comment|/* Simple register allocation. TMP1 is preferred if possible. */
if|if
condition|(
name|needstype
operator|||
name|needsscript
condition|)
block|{
if|if
condition|(
name|needschar
operator|&&
operator|!
name|charsaved
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needschar
condition|)
block|{
if|if
condition|(
name|needstype
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|RETURN_ADDR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typereg
operator|=
name|RETURN_ADDR
expr_stmt|;
block|}
if|if
condition|(
name|needsscript
condition|)
name|scriptreg
operator|=
name|TMP3
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needstype
operator|&&
name|needsscript
condition|)
name|scriptreg
operator|=
name|TMP3
expr_stmt|;
comment|/* In all other cases only one of them was specified, and that can goes to TMP1. */
if|if
condition|(
name|needsscript
condition|)
block|{
if|if
condition|(
name|scriptreg
operator|==
name|TMP1
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|script
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM2
argument_list|(
name|scriptreg
argument_list|,
name|TMP2
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
operator|+
name|SLJIT_OFFSETOF
argument_list|(
name|ucd_record
argument_list|,
name|script
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Generating code. */
name|cc
operator|=
name|ccbegin
expr_stmt|;
name|charoffset
operator|=
literal|0
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|typeoffset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|cc
operator|!=
name|XCL_END
condition|)
block|{
name|compares
operator|--
expr_stmt|;
name|invertcmp
operator|=
operator|(
name|compares
operator|==
literal|0
operator|&&
name|list
operator|!=
name|fallbacks
operator|)
expr_stmt|;
name|jump
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
condition|)
block|{
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
operator|++
expr_stmt|;
if|if
condition|(
name|numberofcmps
operator|<
literal|3
operator|&&
operator|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
operator|||
operator|*
name|cc
operator|==
name|XCL_RANGE
operator|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|numberofcmps
operator|==
literal|0
condition|?
name|SLJIT_MOV
else|:
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|numberofcmps
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numberofcmps
operator|>
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
operator|^
name|invertcmp
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_RANGE
condition|)
block|{
name|cc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
operator|++
expr_stmt|;
name|SET_CHAR_OFFSET
argument_list|(
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
operator|++
expr_stmt|;
if|if
condition|(
name|numberofcmps
operator|<
literal|3
operator|&&
operator|(
operator|*
name|cc
operator|==
name|XCL_SINGLE
operator|||
operator|*
name|cc
operator|==
name|XCL_RANGE
operator|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|numberofcmps
operator|==
literal|0
condition|?
name|SLJIT_MOV
else|:
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|numberofcmps
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numberofcmps
operator|>
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
operator|^
name|invertcmp
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|numberofcmps
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
else|else
block|{
if|if
condition|(
operator|*
name|cc
operator|==
name|XCL_NOTPROP
condition|)
name|invertcmp
operator|^=
literal|0x1
expr_stmt|;
name|cc
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|PT_ANY
case|:
if|if
condition|(
name|list
operator|!=
name|fallbacks
condition|)
block|{
if|if
condition|(
operator|(
name|cc
index|[
operator|-
literal|1
index|]
operator|==
name|XCL_NOTPROP
operator|&&
name|compares
operator|>
literal|0
operator|)
operator|||
operator|(
name|cc
index|[
operator|-
literal|1
index|]
operator|==
name|XCL_PROP
operator|&&
name|compares
operator|==
literal|0
operator|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|cc
index|[
operator|-
literal|1
index|]
operator|==
name|XCL_NOTPROP
condition|)
continue|continue;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_LAMP
case|:
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Ll
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lt
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_GC
case|:
name|c
operator|=
name|PRIV
argument_list|(
name|ucp_typerange
argument_list|)
index|[
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
operator|*
literal|2
index|]
expr_stmt|;
name|SET_TYPE_OFFSET
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
operator|^
name|invertcmp
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PRIV
argument_list|(
name|ucp_typerange
argument_list|)
index|[
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
operator|*
literal|2
operator|+
literal|1
index|]
operator|-
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_PC
case|:
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
operator|^
name|invertcmp
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
operator|-
name|typeoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
operator|^
name|invertcmp
argument_list|,
name|scriptreg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|int
operator|)
name|cc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SPACE
case|:
case|case
name|PT_PXSPACE
case|:
if|if
condition|(
operator|*
name|cc
operator|==
name|PT_SPACE
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|11
operator|-
name|charoffset
argument_list|)
expr_stmt|;
block|}
name|SET_CHAR_OFFSET
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|13
operator|-
literal|9
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|PT_SPACE
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|SET_TYPE_OFFSET
argument_list|(
name|ucp_Zl
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Zs
operator|-
name|ucp_Zl
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_WORD
case|:
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_UNDERSCORE
operator|-
name|charoffset
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
comment|/* ... fall through */
case|case
name|PT_ALNUM
case|:
name|SET_TYPE_OFFSET
argument_list|(
name|ucp_Ll
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Lu
operator|-
name|ucp_Ll
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
operator|(
operator|*
name|cc
operator|==
name|PT_ALNUM
operator|)
condition|?
name|SLJIT_MOV
else|:
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|SET_TYPE_OFFSET
argument_list|(
name|ucp_Nd
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|typereg
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_No
operator|-
name|ucp_Nd
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_LESS_EQUAL
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
operator|^
name|invertcmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|cc
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|compares
operator|>
literal|0
condition|?
name|list
else|:
name|fallbacks
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|found
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|SET_TYPE_OFFSET
undef|#
directive|undef
name|SET_TYPE_OFFSET
end_undef
begin_undef
DECL|macro|SET_CHAR_OFFSET
undef|#
directive|undef
name|SET_CHAR_OFFSET
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|compile_char1_hotpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_char1_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
name|type
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|oc
decl_stmt|,
name|bit
decl_stmt|;
name|compare_context
name|context
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
index|[
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|pcre_uchar
name|propdata
index|[
literal|5
index|]
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_SOD
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_SOM
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|wordboundary
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_NOT_WORD_BOUNDARY
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char8_type
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ctype_digit
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_DIGIT
condition|?
name|SLJIT_C_ZERO
else|:
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char8_type
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ctype_space
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_WHITESPACE
condition|?
name|SLJIT_C_ZERO
else|:
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char8_type
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ctype_word
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_WORDCHAR
condition|?
name|SLJIT_C_ZERO
else|:
name|SLJIT_C_NOT_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_ANY
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
name|fallbacks
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_ALLANY
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* COMPILE_PCRE8 */
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xfc00
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xd800
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE16 */
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
block|}
endif|#
directive|endif
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_ANYBYTE
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
name|propdata
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|propdata
index|[
literal|1
index|]
operator|=
name|type
operator|==
name|OP_NOTPROP
condition|?
name|XCL_NOTPROP
else|:
name|XCL_PROP
expr_stmt|;
name|propdata
index|[
literal|2
index|]
operator|=
name|cc
index|[
literal|0
index|]
expr_stmt|;
name|propdata
index|[
literal|3
index|]
operator|=
name|cc
index|[
literal|1
index|]
expr_stmt|;
name|propdata
index|[
literal|4
index|]
operator|=
name|XCL_END
expr_stmt|;
name|compile_xclass_hotpath
argument_list|(
name|common
argument_list|,
name|propdata
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|2
return|;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|OP_ANYNL
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
index|[
literal|2
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|3
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|bsr_nltype
argument_list|,
name|fallbacks
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|hspace
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_NOT_HSPACE
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|vspace
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|type
operator|==
name|OP_NOT_VSPACE
condition|?
name|SLJIT_C_NOT_ZERO
else|:
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_EXTUNI
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Mc
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Mn
operator|-
name|ucp_Mc
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|getucd
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Mc
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|ucp_Mn
operator|-
name|ucp_Mc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
endif|#
directive|endif
case|case
name|OP_EODN
case|:
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_CR
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
index|[
literal|2
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_LESS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Equal. */
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|3
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|CHAR_NL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|anynewline
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_EOD
case|:
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CIRC
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notbol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CIRCM
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notbol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
name|fallbacks
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_DOLL
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|noteol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
operator|->
name|endonly
condition|)
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|OP_EODN
argument_list|,
name|cc
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
else|else
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_DOLLM
case|:
name|jump
index|[
literal|1
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|noteol
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|common
operator|->
name|newline
operator|>
literal|255
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|common
operator|->
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|newline
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peek_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|check_newlinechar
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nltype
argument_list|,
name|fallbacks
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
name|length
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
condition|)
name|length
operator|+=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|OP_CHAR
operator|||
operator|!
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
operator|||
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|length
operator|=
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|context
operator|.
name|sourcereg
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
name|context
operator|.
name|ucharptr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|byte_sequence_compare
argument_list|(
name|common
argument_list|,
name|type
operator|==
name|OP_CHARI
argument_list|,
name|cc
argument_list|,
operator|&
name|context
argument_list|,
name|fallbacks
argument_list|)
return|;
block|}
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|c
operator|=
operator|*
name|cc
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|char_othercase
argument_list|(
name|common
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|length
return|;
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|length
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|c
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|128
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STR_PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_NOT
operator|||
operator|!
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Since UTF8 code page is fixed, we know that c is in [a-z] or [A-Z] range. */
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator||
literal|0x20
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Skip the variable-length character. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|MOV_UCHAR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
operator|-
literal|0xc0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
else|else
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|{
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|cc
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
block|{
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|OP_NOT
operator|||
operator|!
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|oc
operator|=
name|char_othercase
argument_list|(
name|common
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bit
operator|=
name|c
operator|^
name|oc
expr_stmt|;
if|if
condition|(
name|ispowerof2
argument_list|(
name|bit
argument_list|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_OR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
operator||
name|bit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|oc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cc
operator|+
literal|1
return|;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
name|check_input_end
argument_list|(
name|common
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
name|read_char
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
name|jump
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
comment|/* This check only affects 8 bit mode. In other modes, we   always need to compare the value with 255. */
if|if
condition|(
name|common
operator|->
name|utf
condition|)
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
block|{
name|jump
index|[
literal|0
index|]
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_CLASS
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|jump
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SUPPORT_UTF || !COMPILE_PCRE8 */
name|OP2
argument_list|(
name|SLJIT_AND
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_LSHR
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|sljit_w
operator|)
name|cc
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SHL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_AND
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|jump
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UTF || !COMPILE_PCRE8 */
return|return
name|cc
operator|+
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
return|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
case|case
name|OP_XCLASS
case|:
name|compile_xclass_hotpath
argument_list|(
name|common
argument_list|,
name|cc
operator|+
name|LINK_SIZE
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
return|;
endif|#
directive|endif
case|case
name|OP_REVERSE
case|:
name|length
operator|=
name|GET
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|LINK_SIZE
return|;
block|}
endif|#
directive|endif
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
name|LINK_SIZE
return|;
block|}
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_charn_hotpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_charn_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|)
block|{
comment|/* This function consumes at least one input character. */
comment|/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|cc
decl_stmt|;
name|compare_context
name|context
decl_stmt|;
name|int
name|size
decl_stmt|;
name|context
operator|.
name|length
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cc
operator|>=
name|ccend
condition|)
break|break;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_CHAR
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
condition|)
name|size
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_CHARI
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
condition|)
block|{
if|if
condition|(
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|&&
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
condition|)
name|size
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|char_has_othercase
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|&&
name|char_get_othercase_bit
argument_list|(
name|common
argument_list|,
name|cc
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|size
expr_stmt|;
name|context
operator|.
name|length
operator|+=
name|IN_UCHARS
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|size
operator|>
literal|0
operator|&&
name|context
operator|.
name|length
operator|<=
literal|128
condition|)
do|;
name|cc
operator|=
name|ccbegin
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|/* We have a fixed-length byte sequence. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|context
operator|.
name|length
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|sourcereg
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
name|SLJIT_UNALIGNED
operator|&&
name|SLJIT_UNALIGNED
name|context
operator|.
name|ucharptr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
do|do
name|cc
operator|=
name|byte_sequence_compare
argument_list|(
name|common
argument_list|,
operator|*
name|cc
operator|==
name|OP_CHARI
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
operator|&
name|context
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
do|while
condition|(
name|context
operator|.
name|length
operator|>
literal|0
condition|)
do|;
return|return
name|cc
return|;
block|}
comment|/* A non-fixed length character will be checked if length == 0. */
return|return
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|fallbacks
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|compile_ref_checks
specifier|static
name|struct
name|sljit_jump
modifier|*
name|compile_ref_checks
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
init|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
decl_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
operator|->
name|jscript_compat
condition|)
block|{
if|if
condition|(
name|fallbacks
operator|==
name|NULL
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_EQUAL
argument_list|)
expr_stmt|;
return|return
name|JUMP
argument_list|(
name|SLJIT_C_NOT_ZERO
argument_list|)
return|;
block|}
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Forward definitions. */
end_comment
begin_function_decl
specifier|static
name|void
name|compile_hotpath
parameter_list|(
name|compiler_common
modifier|*
parameter_list|,
name|pcre_uchar
modifier|*
parameter_list|,
name|pcre_uchar
modifier|*
parameter_list|,
name|fallback_common
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|compile_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
parameter_list|,
name|struct
name|fallback_common
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|PUSH_FALLBACK
define|#
directive|define
name|PUSH_FALLBACK
parameter_list|(
name|size
parameter_list|,
name|ccstart
parameter_list|,
name|error
parameter_list|)
define|\
value|do \     { \     fallback = sljit_alloc_memory(compiler, (size)); \     if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \       return error; \     memset(fallback, 0, size); \     fallback->prev = parent->top; \     fallback->cc = (ccstart); \     parent->top = fallback; \     } \   while (0)
end_define
begin_define
DECL|macro|PUSH_FALLBACK_NOVALUE
define|#
directive|define
name|PUSH_FALLBACK_NOVALUE
parameter_list|(
name|size
parameter_list|,
name|ccstart
parameter_list|)
define|\
value|do \     { \     fallback = sljit_alloc_memory(compiler, (size)); \     if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \       return; \     memset(fallback, 0, size); \     fallback->prev = parent->top; \     fallback->cc = (ccstart); \     parent->top = fallback; \     } \   while (0)
end_define
begin_define
DECL|macro|FALLBACK_AS
define|#
directive|define
name|FALLBACK_AS
parameter_list|(
name|type
parameter_list|)
value|((type*)fallback)
end_define
begin_function
DECL|function|compile_ref_hotpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_ref_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|jump_list
modifier|*
modifier|*
name|fallbacks
parameter_list|,
name|BOOL
name|withchecks
parameter_list|,
name|BOOL
name|emptyfail
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
init|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|withchecks
operator|&&
operator|!
name|common
operator|->
name|jscript_compat
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
operator|*
name|cc
operator|==
name|OP_REFI
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|TMP1
operator|==
name|SLJIT_TEMPORARY_REG1
operator|&&
name|STACK_TOP
operator|==
name|SLJIT_TEMPORARY_REG2
operator|&&
name|TMP2
operator|==
name|SLJIT_TEMPORARY_REG3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|withchecks
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Needed to save important temporary registers. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_TEMPORARY_REG2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|ptr
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL3
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|do_utf_caselesscmp
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF&& SUPPORT_UCP */
block|{
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|withchecks
condition|)
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_C_ZERO
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|*
name|cc
operator|==
name|OP_REF
condition|?
operator|&
name|common
operator|->
name|casefulcmp
else|:
operator|&
name|common
operator|->
name|caselesscmp
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|emptyfail
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|fallbacks
argument_list|,
name|jump
argument_list|)
expr_stmt|;
else|else
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
return|return
name|cc
operator|+
literal|1
operator|+
name|IMM2_SIZE
return|;
block|}
end_function
begin_function
DECL|function|compile_ref_iterator_hotpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_ref_iterator_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|fallback_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|fallback_common
modifier|*
name|fallback
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|zerolength
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|cc
decl_stmt|;
name|int
name|min
init|=
literal|0
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
name|BOOL
name|minimize
decl_stmt|;
name|PUSH_FALLBACK
argument_list|(
sizeof|sizeof
argument_list|(
name|iterator_fallback
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
expr_stmt|;
name|minimize
operator|=
operator|(
name|type
operator|&
literal|0x1
operator|)
operator|!=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
name|min
operator|=
literal|1
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|1
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
name|min
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|minimize
condition|)
block|{
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Temporary release of STR_PTR. */
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Restore if not zero length. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|>
literal|1
operator|||
name|max
operator|>
literal|1
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_ref_hotpath
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|1
operator|||
name|max
operator|>
literal|1
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|1
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|min
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|1
condition|)
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max
operator|==
literal|0
condition|)
block|{
comment|/* Includes min> 1 case as well. */
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|zerolength
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
block|}
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OP_CRMINSTAR
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
block|}
else|else
name|zerolength
operator|=
name|compile_ref_checks
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|0
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|compile_ref_hotpath
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|1
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|min
argument_list|,
name|FALLBACK_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max
operator|>
literal|0
condition|)
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|zerolength
argument_list|)
expr_stmt|;
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_recurse_hotpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_recurse_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|fallback_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|fallback_common
modifier|*
name|fallback
decl_stmt|;
name|recurse_entry
modifier|*
name|entry
init|=
name|common
operator|->
name|entries
decl_stmt|;
name|recurse_entry
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|start
init|=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|PUSH_FALLBACK
argument_list|(
sizeof|sizeof
argument_list|(
name|recurse_fallback
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|start
operator|==
name|start
condition|)
break|break;
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|recurse_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|calls
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
else|else
name|common
operator|->
name|entries
operator|=
name|entry
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|entry
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|entry
operator|->
name|calls
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|JUMPTO
argument_list|(
name|SLJIT_FAST_CALL
argument_list|,
name|entry
operator|->
name|entry
argument_list|)
expr_stmt|;
comment|/* Leave if the match is failed. */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
block|}
end_function
begin_function
DECL|function|compile_assert_hotpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_assert_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|assert_fallback
modifier|*
name|fallback
parameter_list|,
name|BOOL
name|conditional
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|framesize
decl_stmt|;
name|int
name|localptr
decl_stmt|;
name|fallback_common
name|altfallback
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|jump_list
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
modifier|*
name|target
init|=
operator|(
name|conditional
operator|)
condition|?
operator|&
name|fallback
operator|->
name|condfailed
else|:
operator|&
name|fallback
operator|->
name|common
operator|.
name|topfallbacks
decl_stmt|;
name|jump_list
modifier|*
modifier|*
name|found
decl_stmt|;
comment|/* Saving previous accept variables. */
name|struct
name|sljit_label
modifier|*
name|save_acceptlabel
init|=
name|common
operator|->
name|acceptlabel
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|brajump
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
name|save_accept
init|=
name|common
operator|->
name|accept
decl_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
operator|||
operator|*
name|cc
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|conditional
argument_list|)
expr_stmt|;
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
name|localptr
operator|=
name|PRIV_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|localptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|framesize
operator|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|fallback
operator|->
name|framesize
operator|=
name|framesize
expr_stmt|;
name|fallback
operator|->
name|localptr
operator|=
name|localptr
expr_stmt|;
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|opcode
operator|>=
name|OP_ASSERT
operator|&&
name|opcode
operator|<=
name|OP_ASSERTBACK_NOT
argument_list|)
expr_stmt|;
name|found
operator|=
operator|(
name|opcode
operator|==
name|OP_ASSERT
operator|||
name|opcode
operator|==
name|OP_ASSERTBACK
operator|)
condition|?
operator|&
name|tmp
else|:
name|target
expr_stmt|;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
comment|/* This is a braminzero fallback path. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brajump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|framesize
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|framesize
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|altfallback
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fallback_common
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|common
operator|->
name|acceptlabel
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|NULL
expr_stmt|;
name|altfallback
operator|.
name|top
operator|=
name|NULL
expr_stmt|;
name|altfallback
operator|.
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|ccbegin
operator|==
name|OP_ALT
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|altfallback
operator|.
name|cc
operator|=
name|ccbegin
expr_stmt|;
name|compile_hotpath
argument_list|(
name|common
argument_list|,
name|ccbegin
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|cc
argument_list|,
operator|&
name|altfallback
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|common
operator|->
name|acceptlabel
operator|=
name|save_acceptlabel
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|save_accept
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|common
operator|->
name|acceptlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|accept
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|common
operator|->
name|accept
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
comment|/* Reset stack. */
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|opcode
operator|!=
name|OP_ASSERT_NOT
operator|&&
name|opcode
operator|!=
name|OP_ASSERTBACK_NOT
operator|)
operator|||
name|conditional
condition|)
block|{
comment|/* We don't need to keep the STR_PTR, only the previous localptr. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_ASSERT_NOT
operator|||
name|opcode
operator|==
name|OP_ASSERTBACK_NOT
condition|)
block|{
comment|/* We know that STR_PTR was stored on the top of the stack. */
if|if
condition|(
name|conditional
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|framesize
operator|>=
literal|0
condition|)
block|{
comment|/* For OP_BRA and OP_BRAMINZERO. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|found
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|compile_fallbackpath
argument_list|(
name|common
argument_list|,
name|altfallback
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|common
operator|->
name|acceptlabel
operator|=
name|save_acceptlabel
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|save_accept
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|set_jumps
argument_list|(
name|altfallback
operator|.
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|!=
name|OP_ALT
condition|)
break|break;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* None of them matched. */
if|if
condition|(
name|opcode
operator|==
name|OP_ASSERT
operator|||
name|opcode
operator|==
name|OP_ASSERTBACK
condition|)
block|{
comment|/* Assert is failed. */
if|if
condition|(
name|conditional
operator|||
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* The topmost item should be 0. */
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The topmost item should be 0. */
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|!=
name|OP_BRAZERO
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
name|target
argument_list|,
name|jump
argument_list|)
expr_stmt|;
comment|/* Assert is successful. */
name|set_jumps
argument_list|(
name|tmp
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* We know that STR_PTR was stored on the top of the stack. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep the STR_PTR on the top of the stack. */
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bra
operator|==
name|OP_BRA
condition|)
block|{
comment|/* We don't need to keep the STR_PTR, only the previous localptr. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't need to keep the STR_PTR, only the previous localptr. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bra
operator|==
name|OP_BRAZERO
condition|?
name|STR_PTR
else|:
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|fallback
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|sljit_set_label
argument_list|(
name|jump
argument_list|,
name|fallback
operator|->
name|hotpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|fallback
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brajump
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|fallback
operator|->
name|common
operator|.
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* AssertNot is successful. */
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The topmost item should be 0. */
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|free_stack
argument_list|(
name|common
argument_list|,
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|fallback
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|fallback
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brajump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|found
operator|==
operator|&
name|fallback
operator|->
name|common
operator|.
name|topfallbacks
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|fallback
operator|->
name|common
operator|.
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|fallback
operator|->
name|common
operator|.
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|common
operator|->
name|acceptlabel
operator|=
name|save_acceptlabel
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|save_accept
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
block|}
end_function
begin_function
DECL|function|do_searchovector
specifier|static
name|sljit_w
name|SLJIT_CALL
name|do_searchovector
parameter_list|(
name|sljit_w
name|refno
parameter_list|,
name|sljit_w
modifier|*
name|locals
parameter_list|,
name|pcre_uchar
modifier|*
name|name_table
parameter_list|)
block|{
name|int
name|condition
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotA
init|=
name|name_table
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotB
decl_stmt|;
name|sljit_w
name|name_count
init|=
name|locals
index|[
name|LOCALS0
operator|/
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
index|]
decl_stmt|;
name|sljit_w
name|name_entry_size
init|=
name|locals
index|[
name|LOCALS1
operator|/
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
index|]
decl_stmt|;
name|sljit_w
name|no_capture
decl_stmt|;
name|int
name|i
decl_stmt|;
name|locals
operator|+=
name|OVECTOR_START
operator|/
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|no_capture
operator|=
name|locals
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET2
argument_list|(
name|slotA
argument_list|,
literal|0
argument_list|)
operator|==
name|refno
condition|)
break|break;
name|slotA
operator|+=
name|name_entry_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|name_count
condition|)
block|{
comment|/* Found a name for the number - there can be only one; duplicate names   for different numbers are allowed, but not vice versa. First scan down   for duplicates. */
name|slotB
operator|=
name|slotA
expr_stmt|;
while|while
condition|(
name|slotB
operator|>
name|name_table
condition|)
block|{
name|slotB
operator|-=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|locals
index|[
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
index|]
operator|!=
name|no_capture
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
comment|/* Scan up for duplicates */
if|if
condition|(
operator|!
name|condition
condition|)
block|{
name|slotB
operator|=
name|slotA
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
name|slotB
operator|+=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|locals
index|[
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
index|]
operator|!=
name|no_capture
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
block|}
block|}
return|return
name|condition
return|;
block|}
end_function
begin_function
DECL|function|do_searchgroups
specifier|static
name|sljit_w
name|SLJIT_CALL
name|do_searchgroups
parameter_list|(
name|sljit_w
name|recno
parameter_list|,
name|sljit_w
modifier|*
name|locals
parameter_list|,
name|pcre_uchar
modifier|*
name|name_table
parameter_list|)
block|{
name|int
name|condition
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotA
init|=
name|name_table
decl_stmt|;
name|pcre_uchar
modifier|*
name|slotB
decl_stmt|;
name|sljit_w
name|name_count
init|=
name|locals
index|[
name|LOCALS0
operator|/
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
index|]
decl_stmt|;
name|sljit_w
name|name_entry_size
init|=
name|locals
index|[
name|LOCALS1
operator|/
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
index|]
decl_stmt|;
name|sljit_w
name|group_num
init|=
name|locals
index|[
name|POSSESSIVE0
operator|/
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET2
argument_list|(
name|slotA
argument_list|,
literal|0
argument_list|)
operator|==
name|recno
condition|)
break|break;
name|slotA
operator|+=
name|name_entry_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|name_count
condition|)
block|{
comment|/* Found a name for the number - there can be only one; duplicate   names for different numbers are allowed, but not vice versa. First   scan down for duplicates. */
name|slotB
operator|=
name|slotA
expr_stmt|;
while|while
condition|(
name|slotB
operator|>
name|name_table
condition|)
block|{
name|slotB
operator|-=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|==
name|group_num
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
comment|/* Scan up for duplicates */
if|if
condition|(
operator|!
name|condition
condition|)
block|{
name|slotB
operator|=
name|slotA
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
control|)
block|{
name|slotB
operator|+=
name|name_entry_size
expr_stmt|;
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
name|slotA
operator|+
name|IMM2_SIZE
argument_list|,
name|slotB
operator|+
name|IMM2_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|condition
operator|=
name|GET2
argument_list|(
name|slotB
argument_list|,
literal|0
argument_list|)
operator|==
name|group_num
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
block|}
else|else
break|break;
block|}
block|}
block|}
return|return
name|condition
return|;
block|}
end_function
begin_comment
comment|/*   Handling bracketed expressions is probably the most complex part.    Stack layout naming characters:     S - Push the current STR_PTR     0 - Push a 0 (NULL)     A - Push the current STR_PTR. Needed for restoring the STR_PTR         before the next alternative. Not pushed if there are no alternatives.     M - Any values pushed by the current alternative. Can be empty, or anything.     C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.     L - Push the previous local (pointed by localptr) to the stack    () - opional values stored on the stack   ()* - optonal, can be stored multiple times    The following list shows the regular expression templates, their PCRE byte codes   and stack layout supported by pcre-sljit.    (?:)                     OP_BRA     | OP_KET                A M   ()                       OP_CBRA    | OP_KET                C M   (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*                            OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*   (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*                            OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*   ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*                            OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*   ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*                            OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*   (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )   (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )   ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )   ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )   (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*            OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*   (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*            OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*   ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*            OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*   ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*            OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*     Stack layout naming characters:     A - Push the alternative index (starting from 0) on the stack.         Not pushed if there is no alternatives.     M - Any values pushed by the current alternative. Can be empty, or anything.    The next list shows the possible content of a bracket:   (|)     OP_*BRA    | OP_ALT ...         M A   (?()|)  OP_*COND   | OP_ALT             M A   (?>|)   OP_ONCE    | OP_ALT ...         [stack trace] M A   (?>|)   OP_ONCE_NC | OP_ALT ...         [stack trace] M A                                           Or nothing, if trace is unnecessary */
end_comment
begin_function
DECL|function|compile_bracket_hotpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_bracket_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|fallback_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|fallback_common
modifier|*
name|fallback
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|int
name|localptr
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|stacksize
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
name|pcre_uchar
modifier|*
name|hotpath
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|pcre_uchar
name|ket
decl_stmt|;
name|assert_fallback
modifier|*
name|assert
decl_stmt|;
name|BOOL
name|has_alternatives
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|skip
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|rmaxlabel
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|braminzerojump
init|=
name|NULL
decl_stmt|;
name|PUSH_FALLBACK
argument_list|(
sizeof|sizeof
argument_list|(
name|bracket_fallback
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
operator|||
operator|*
name|cc
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
block|}
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|hotpath
operator|=
name|ccbegin
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|==
name|OP_COND
operator|||
name|opcode
operator|==
name|OP_SCOND
operator|)
operator|&&
name|cc
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_DEF
condition|)
block|{
comment|/* Drop this bracket_fallback. */
name|parent
operator|->
name|top
operator|=
name|fallback
operator|->
name|prev
expr_stmt|;
return|return
name|bracketend
argument_list|(
name|cc
argument_list|)
return|;
block|}
name|ket
operator|=
operator|*
operator|(
name|bracketend
argument_list|(
name|cc
argument_list|)
operator|-
literal|1
operator|-
name|LINK_SIZE
operator|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|ket
operator|==
name|OP_KET
operator|||
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|ket
operator|==
name|OP_KETRMIN
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|bra
operator|==
name|OP_BRAZERO
operator|&&
name|ket
operator|==
name|OP_KETRMIN
operator|)
operator|||
operator|(
name|bra
operator|==
name|OP_BRAMINZERO
operator|&&
name|ket
operator|==
name|OP_KETRMAX
operator|)
operator|)
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|has_alternatives
operator|=
operator|*
name|cc
operator|==
name|OP_ALT
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
block|{
name|has_alternatives
operator|=
operator|(
operator|*
name|hotpath
operator|==
name|OP_RREF
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|hotpath
operator|==
name|OP_NRREF
condition|)
block|{
name|stacksize
operator|=
name|GET2
argument_list|(
name|hotpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|currententry
operator|==
name|NULL
operator|||
name|stacksize
operator|==
name|RREF_ANY
condition|)
name|has_alternatives
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|common
operator|->
name|currententry
operator|->
name|start
operator|==
literal|0
condition|)
name|has_alternatives
operator|=
name|stacksize
operator|!=
literal|0
expr_stmt|;
else|else
name|has_alternatives
operator|=
name|stacksize
operator|!=
name|GET2
argument_list|(
name|common
operator|->
name|start
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|start
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|&&
operator|(
operator|*
name|cc
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|cc
operator|==
name|OP_KETRMIN
operator|)
condition|)
name|opcode
operator|=
name|OP_SCOND
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_ONCE_NC
argument_list|)
condition|)
name|opcode
operator|=
name|OP_ONCE
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRA
operator|||
name|opcode
operator|==
name|OP_SCBRA
condition|)
block|{
comment|/* Capturing brackets has a pre-allocated space. */
name|offset
operator|=
name|GET2
argument_list|(
name|ccbegin
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|localptr
operator|=
name|OVECTOR_PRIV
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|<<=
literal|1
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|localptr
operator|=
name|localptr
expr_stmt|;
name|hotpath
operator|+=
name|IMM2_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|||
name|opcode
operator|==
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
comment|/* Other brackets simply allocate the next entry. */
name|localptr
operator|=
name|PRIV_DATA
argument_list|(
name|ccbegin
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|localptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|localptr
operator|=
name|localptr
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Instructions before the first alternative. */
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ket
operator|==
name|OP_KETRMAX
operator|)
operator|||
operator|(
name|ket
operator|==
name|OP_KETRMIN
operator|&&
name|bra
operator|!=
name|OP_BRAMINZERO
operator|)
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|stacksize
operator|>
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ket
operator|==
name|OP_KETRMAX
operator|)
operator|||
operator|(
name|ket
operator|==
name|OP_KETRMIN
operator|&&
name|bra
operator|!=
name|OP_BRAMINZERO
operator|)
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
comment|/* This is a fallback path! (Since the hot-path of OP_BRAMINZERO matches to the empty string) */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KETRMIN
condition|)
block|{
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|braminzerojump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|||
name|opcode
operator|>=
name|OP_SBRA
condition|)
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Nothing stored during the first run. */
name|skip
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* Checking zero-length iteration. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
operator|||
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* When we come from outside, localptr contains the previous STR_PTR. */
name|braminzerojump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Except when the whole stack frame must be saved. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|braminzerojump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|skip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|recursivehotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
name|rmaxlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|has_alternatives
operator|&&
name|opcode
operator|!=
name|OP_ONCE
operator|&&
name|opcode
operator|<
name|OP_SBRA
condition|)
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|althotpath
operator|=
name|rmaxlabel
expr_stmt|;
block|}
comment|/* Handling capturing brackets and alternatives. */
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
if|if
condition|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
comment|/* Neither capturing brackets nor recursions are not found in the block. */
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|has_alternatives
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
operator|||
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|has_alternatives
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_CBRA
operator|||
name|opcode
operator|==
name|OP_SCBRA
condition|)
block|{
comment|/* Saving the previous values. */
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|2
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
comment|/* Saving the previous value. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_alternatives
condition|)
block|{
comment|/* Pushing the starting string pointer. */
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Generating code for the first alternative. */
if|if
condition|(
name|opcode
operator|==
name|OP_COND
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
if|if
condition|(
operator|*
name|hotpath
operator|==
name|OP_CREF
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
operator|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|)
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|GET2
argument_list|(
name|hotpath
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|hotpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|hotpath
operator|==
name|OP_NCREF
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|stacksize
operator|=
name|GET2
argument_list|(
name|hotpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|stacksize
operator|<<
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_count
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_entry_size
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_table
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL3
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|do_searchovector
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
operator|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|)
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|hotpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|hotpath
operator|==
name|OP_RREF
operator|||
operator|*
name|hotpath
operator|==
name|OP_NRREF
condition|)
block|{
comment|/* Never has other case. */
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|=
name|NULL
expr_stmt|;
name|stacksize
operator|=
name|GET2
argument_list|(
name|hotpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|currententry
operator|==
name|NULL
condition|)
name|stacksize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|stacksize
operator|==
name|RREF_ANY
condition|)
name|stacksize
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|common
operator|->
name|currententry
operator|->
name|start
operator|==
literal|0
condition|)
name|stacksize
operator|=
name|stacksize
operator|==
literal|0
expr_stmt|;
else|else
name|stacksize
operator|=
name|stacksize
operator|==
name|GET2
argument_list|(
name|common
operator|->
name|start
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|start
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hotpath
operator|==
name|OP_RREF
operator|||
name|stacksize
operator|||
name|common
operator|->
name|currententry
operator|==
name|NULL
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|has_alternatives
argument_list|)
expr_stmt|;
if|if
condition|(
name|stacksize
operator|!=
literal|0
condition|)
name|hotpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
block|{
name|hotpath
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|hotpath
operator|=
name|cc
expr_stmt|;
block|}
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|stacksize
operator|=
name|GET2
argument_list|(
name|hotpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_count
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_entry_size
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|GET2
argument_list|(
name|common
operator|->
name|start
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|start
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG2
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_TEMPORARY_REG3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|common
operator|->
name|name_table
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL3
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|do_searchgroups
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
operator|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|)
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hotpath
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
operator|&&
operator|*
name|hotpath
operator|>=
name|OP_ASSERT
operator|&&
operator|*
name|hotpath
operator|<=
name|OP_ASSERTBACK_NOT
argument_list|)
expr_stmt|;
comment|/* Similar code as PUSH_FALLBACK macro. */
name|assert
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|assert_fallback
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|assert
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|assert_fallback
argument_list|)
argument_list|)
expr_stmt|;
name|assert
operator|->
name|common
operator|.
name|cc
operator|=
name|hotpath
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|assert
operator|=
name|assert
expr_stmt|;
name|hotpath
operator|=
name|compile_assert_hotpath
argument_list|(
name|common
argument_list|,
name|hotpath
argument_list|,
name|assert
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|compile_hotpath
argument_list|(
name|common
argument_list|,
name|hotpath
argument_list|,
name|cc
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
if|if
condition|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
comment|/* Move the STR_PTR to the localptr. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|stacksize
operator|=
operator|(
name|ket
operator|==
name|OP_KETRMIN
operator|||
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|has_alternatives
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
name|stacksize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
operator|||
name|bra
operator|!=
name|OP_BRA
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|has_alternatives
operator|&&
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|stacksize
operator|>
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|has_alternatives
condition|)
block|{
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KETRMAX
condition|)
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|althotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
block|}
comment|/* Must be after the hotpath label. */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|||
name|opcode
operator|>=
name|OP_SBRA
condition|)
block|{
if|if
condition|(
name|has_alternatives
condition|)
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|althotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
comment|/* Checking zero-length iteration. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|rmaxlabel
argument_list|)
expr_stmt|;
else|else
comment|/* TMP2 must contain the starting STR_PTR. */
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|rmaxlabel
argument_list|)
expr_stmt|;
block|}
else|else
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|rmaxlabel
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|recursivehotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|zerohotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
block|{
comment|/* This is a fallback path! (From the viewpoint of OP_BRAMINZERO) */
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
operator|(
operator|(
name|braminzero_fallback
operator|*
operator|)
name|parent
operator|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|braminzerojump
operator|!=
name|NULL
condition|)
block|{
name|JUMPHERE
argument_list|(
name|braminzerojump
argument_list|)
expr_stmt|;
comment|/* We need to release the end pointer to perform the     fallback for the zero-length iteration. When     framesize is< 0, OP_ONCE will do the release itself. */
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
operator|&&
name|FALLBACK_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
operator|&&
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Continue to the normal fallback. */
block|}
if|if
condition|(
operator|(
name|ket
operator|!=
name|OP_KET
operator|&&
name|bra
operator|!=
name|OP_BRAMINZERO
operator|)
operator|||
name|bra
operator|==
name|OP_BRAZERO
condition|)
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
comment|/* Skip the other alternatives. */
while|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_bracketpos_hotpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_bracketpos_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|fallback_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|fallback_common
modifier|*
name|fallback
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|int
name|localptr
decl_stmt|;
name|int
name|cbraprivptr
init|=
literal|0
decl_stmt|;
name|int
name|framesize
decl_stmt|;
name|int
name|stacksize
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|BOOL
name|zero
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|NULL
decl_stmt|;
name|int
name|stack
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|loop
init|=
name|NULL
decl_stmt|;
name|struct
name|jump_list
modifier|*
name|emptymatch
init|=
name|NULL
decl_stmt|;
name|PUSH_FALLBACK
argument_list|(
sizeof|sizeof
argument_list|(
name|bracketpos_fallback
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAPOSZERO
condition|)
block|{
name|zero
operator|=
name|TRUE
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|localptr
operator|=
name|PRIV_DATA
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|localptr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|localptr
operator|=
name|localptr
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
name|ccbegin
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|offset
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|cbraprivptr
operator|=
name|OVECTOR_PRIV
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|<<=
literal|1
expr_stmt|;
name|ccbegin
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|framesize
operator|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|framesize
operator|=
name|framesize
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|stacksize
operator|=
operator|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|stacksize
operator|++
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|stacksize
operator|=
name|stacksize
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stacksize
operator|=
name|framesize
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_BRAPOS
operator|||
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
name|stacksize
operator|++
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|stacksize
operator|=
name|stacksize
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|-
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_BRAPOS
operator|||
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stack
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stack
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_frame
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|stacksize
operator|-
literal|1
argument_list|,
name|stacksize
operator|-
name|framesize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|LABEL
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cc
operator|!=
name|OP_KETRPOS
condition|)
block|{
name|fallback
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
name|fallback
operator|->
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|compile_hotpath
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|cc
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|emptymatch
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_IMM
argument_list|,
name|stacksize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|stacksize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_SBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|emptymatch
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|flush_stubs
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|compile_fallbackpath
argument_list|(
name|common
argument_list|,
name|fallback
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|set_jumps
argument_list|(
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_CBRAPOS
operator|||
name|opcode
operator|==
name|OP_SCBRAPOS
condition|)
block|{
comment|/* Last alternative. */
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_KETRPOS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|cbraprivptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_KETRPOS
condition|)
break|break;
name|ccbegin
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
name|fallback
operator|->
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|framesize
operator|<
literal|0
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
operator|-
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* TMP2 is set to [localptr] above. */
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
operator|(
name|stacksize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* None of them matched. */
name|set_jumps
argument_list|(
name|emptymatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
return|;
block|}
end_function
begin_function
DECL|function|get_iterator_parameters
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|get_iterator_parameters
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|opcode
parameter_list|,
name|pcre_uchar
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|arg1
parameter_list|,
name|int
modifier|*
name|arg2
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
name|end
parameter_list|)
block|{
name|int
name|class_len
decl_stmt|;
operator|*
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_STAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_POSUPTO
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_CHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_STARI
operator|&&
operator|*
name|opcode
operator|<=
name|OP_POSUPTOI
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_CHARI
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_NOTSTAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_NOTPOSUPTO
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_NOT
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_NOTSTAR
operator|-
name|OP_STAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_NOTSTARI
operator|&&
operator|*
name|opcode
operator|<=
name|OP_NOTPOSUPTOI
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|type
operator|=
name|OP_NOTI
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_NOTSTARI
operator|-
name|OP_STAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_TYPESTAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_TYPEPOSUPTO
condition|)
block|{
name|cc
operator|++
expr_stmt|;
operator|*
name|opcode
operator|-=
name|OP_TYPESTAR
operator|-
name|OP_STAR
expr_stmt|;
operator|*
name|type
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|opcode
operator|>=
name|OP_CLASS
operator|||
operator|*
name|opcode
operator|<=
name|OP_XCLASS
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
operator|*
name|opcode
expr_stmt|;
name|cc
operator|++
expr_stmt|;
name|class_len
operator|=
operator|(
operator|*
name|type
operator|<
name|OP_XCLASS
operator|)
condition|?
call|(
name|int
call|)
argument_list|(
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
argument_list|)
else|:
name|GET
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|opcode
operator|=
name|cc
index|[
name|class_len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|opcode
operator|>=
name|OP_CRSTAR
operator|&&
operator|*
name|opcode
operator|<=
name|OP_CRMINQUERY
condition|)
block|{
operator|*
name|opcode
operator|-=
name|OP_CRSTAR
operator|-
name|OP_STAR
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
name|cc
operator|+
name|class_len
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|opcode
operator|==
name|OP_CRRANGE
operator|||
operator|*
name|opcode
operator|==
name|OP_CRMINRANGE
argument_list|)
expr_stmt|;
operator|*
name|arg1
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
operator|(
name|class_len
operator|+
name|IMM2_SIZE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|arg2
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
name|class_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg2
operator|==
literal|0
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|*
name|arg1
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|opcode
operator|=
operator|(
operator|*
name|opcode
operator|==
name|OP_CRRANGE
operator|)
condition|?
name|OP_UPTO
else|:
name|OP_MINUPTO
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg1
operator|==
operator|*
name|arg2
condition|)
operator|*
name|opcode
operator|=
name|OP_EXACT
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
name|cc
operator|+
name|class_len
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
block|}
return|return
name|cc
return|;
block|}
if|if
condition|(
operator|*
name|opcode
operator|==
name|OP_UPTO
operator|||
operator|*
name|opcode
operator|==
name|OP_MINUPTO
operator|||
operator|*
name|opcode
operator|==
name|OP_EXACT
operator|||
operator|*
name|opcode
operator|==
name|OP_POSUPTO
condition|)
block|{
operator|*
name|arg1
operator|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|IMM2_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|type
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
name|next_opcode
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|++
expr_stmt|;
return|return
name|cc
return|;
block|}
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
operator|*
name|end
operator|=
name|cc
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
condition|)
operator|*
name|end
operator|+=
name|GET_EXTRALEN
argument_list|(
operator|*
name|cc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|cc
return|;
block|}
end_function
begin_function
DECL|function|compile_iterator_hotpath
specifier|static
name|pcre_uchar
modifier|*
name|compile_iterator_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|fallback_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|fallback_common
modifier|*
name|fallback
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|int
name|arg1
init|=
operator|-
literal|1
decl_stmt|,
name|arg2
init|=
operator|-
literal|1
decl_stmt|;
name|pcre_uchar
modifier|*
name|end
decl_stmt|;
name|jump_list
modifier|*
name|nomatch
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|PUSH_FALLBACK
argument_list|(
sizeof|sizeof
argument_list|(
name|iterator_fallback
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cc
operator|=
name|get_iterator_parameters
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
operator|&
name|opcode
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OP_STAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_CRRANGE
case|:
if|if
condition|(
name|type
operator|==
name|OP_ANYNL
operator|||
name|type
operator|==
name|OP_EXTUNI
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_STAR
operator|||
name|opcode
operator|==
name|OP_UPTO
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|OP_UPTO
operator|||
name|opcode
operator|==
name|OP_CRRANGE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_UPTO
operator|||
name|opcode
operator|==
name|OP_CRRANGE
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRRANGE
operator|&&
name|arg2
operator|>
literal|0
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg2
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_UPTO
operator|||
operator|(
name|opcode
operator|==
name|OP_CRRANGE
operator|&&
name|arg1
operator|>
literal|0
operator|)
condition|)
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_GREATER_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|nomatch
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|<=
name|OP_PLUS
operator|||
operator|(
name|opcode
operator|==
name|OP_CRRANGE
operator|&&
name|arg1
operator|==
literal|0
operator|)
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
operator|+
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|nomatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_PLUS
operator|||
name|opcode
operator|==
name|OP_CRRANGE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|opcode
operator|==
name|OP_PLUS
condition|?
literal|2
else|:
name|arg2
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FALLBACK_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINPLUS
case|:
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_MINPLUS
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_CRMINRANGE
case|:
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_QUERY
condition|)
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
name|FALLBACK_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_EXACT
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
operator|+
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSUPTO
case|:
if|if
condition|(
name|opcode
operator|!=
name|OP_POSSTAR
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|nomatch
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_POSUPTO
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_POSPLUS
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
operator|+
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|nomatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_POSPLUS
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POSQUERY
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|nomatch
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|nomatch
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|POSSESSIVE1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
return|return
name|end
return|;
block|}
end_function
begin_function
DECL|function|compile_fail_accept_hotpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_fail_accept_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|fallback_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|fallback_common
modifier|*
name|fallback
decl_stmt|;
name|PUSH_FALLBACK
argument_list|(
sizeof|sizeof
argument_list|(
name|bracket_fallback
argument_list|)
argument_list|,
name|cc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_FAIL
condition|)
block|{
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ASSERT_ACCEPT
operator|||
name|common
operator|->
name|currententry
operator|!=
name|NULL
condition|)
block|{
comment|/* No need to check notempty conditions. */
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty_atstart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|acceptlabel
operator|==
name|NULL
condition|)
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|fallback
operator|->
name|topfallbacks
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|compile_close_hotpath
specifier|static
name|SLJIT_INLINE
name|pcre_uchar
modifier|*
name|compile_close_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
init|=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Data will be discarded anyway... */
if|if
condition|(
name|common
operator|->
name|currententry
operator|!=
name|NULL
condition|)
return|return
name|cc
operator|+
literal|1
operator|+
name|IMM2_SIZE
return|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR_PRIV
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|<<=
literal|1
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cc
operator|+
literal|1
operator|+
name|IMM2_SIZE
return|;
block|}
end_function
begin_function
DECL|function|compile_hotpath
specifier|static
name|void
name|compile_hotpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|pcre_uchar
modifier|*
name|cc
parameter_list|,
name|pcre_uchar
modifier|*
name|ccend
parameter_list|,
name|fallback_common
modifier|*
name|parent
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|fallback_common
modifier|*
name|fallback
decl_stmt|;
while|while
condition|(
name|cc
operator|<
name|ccend
condition|)
block|{
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYBYTE
case|:
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
case|case
name|OP_ANYNL
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_REVERSE
case|:
name|cc
operator|=
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextfallbacks
else|:
operator|&
name|parent
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SET_SOM
case|:
name|PUSH_FALLBACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|fallback_common
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
name|cc
operator|=
name|compile_charn_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|ccend
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextfallbacks
else|:
operator|&
name|parent
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
name|cc
operator|=
name|compile_iterator_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|if
condition|(
name|cc
index|[
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
index|]
operator|>=
name|OP_CRSTAR
operator|&&
name|cc
index|[
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
index|]
operator|<=
name|OP_CRMINRANGE
condition|)
name|cc
operator|=
name|compile_iterator_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextfallbacks
else|:
operator|&
name|parent
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
case|case
name|OP_XCLASS
case|:
if|if
condition|(
operator|*
operator|(
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
name|OP_CRSTAR
operator|&&
operator|*
operator|(
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
name|OP_CRMINRANGE
condition|)
name|cc
operator|=
name|compile_iterator_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
operator|*
name|cc
argument_list|,
name|cc
operator|+
literal|1
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextfallbacks
else|:
operator|&
name|parent
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
if|if
condition|(
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|>=
name|OP_CRSTAR
operator|&&
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|<=
name|OP_CRMINRANGE
condition|)
name|cc
operator|=
name|compile_ref_iterator_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|compile_ref_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
operator|->
name|top
operator|!=
name|NULL
condition|?
operator|&
name|parent
operator|->
name|top
operator|->
name|nextfallbacks
else|:
operator|&
name|parent
operator|->
name|topfallbacks
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RECURSE
case|:
name|cc
operator|=
name|compile_recurse_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
name|PUSH_FALLBACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|assert_fallback
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|compile_assert_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|FALLBACK_AS
argument_list|(
name|assert_fallback
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAMINZERO
case|:
name|PUSH_FALLBACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|braminzero_fallback
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|bracketend
argument_list|(
name|cc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cc
operator|-
literal|1
operator|-
name|LINK_SIZE
operator|)
operator|!=
name|OP_KETRMIN
condition|)
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|FALLBACK_AS
argument_list|(
name|braminzero_fallback
argument_list|)
operator|->
name|hotpath
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
name|decrease_call_count
argument_list|(
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_CBRA
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCOND
case|:
name|cc
operator|=
name|compile_bracket_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAZERO
case|:
if|if
condition|(
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
name|cc
operator|=
name|compile_bracket_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
else|else
block|{
name|PUSH_FALLBACK_NOVALUE
argument_list|(
sizeof|sizeof
argument_list|(
name|assert_fallback
argument_list|)
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|=
name|compile_assert_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|FALLBACK_AS
argument_list|(
name|assert_fallback
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_BRAPOSZERO
case|:
name|cc
operator|=
name|compile_bracketpos_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FAIL
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
name|cc
operator|=
name|compile_fail_accept_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CLOSE
case|:
name|cc
operator|=
name|compile_close_hotpath
argument_list|(
name|common
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SKIPZERO
case|:
name|cc
operator|=
name|bracketend
argument_list|(
name|cc
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cc
operator|==
name|NULL
condition|)
return|return;
block|}
name|SLJIT_ASSERT
argument_list|(
name|cc
operator|==
name|ccend
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|PUSH_FALLBACK
undef|#
directive|undef
name|PUSH_FALLBACK
end_undef
begin_undef
DECL|macro|PUSH_FALLBACK_NOVALUE
undef|#
directive|undef
name|PUSH_FALLBACK_NOVALUE
end_undef
begin_undef
DECL|macro|FALLBACK_AS
undef|#
directive|undef
name|FALLBACK_AS
end_undef
begin_define
DECL|macro|COMPILE_FALLBACKPATH
define|#
directive|define
name|COMPILE_FALLBACKPATH
parameter_list|(
name|current
parameter_list|)
define|\
value|do \     { \     compile_fallbackpath(common, (current)); \     if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \       return; \     } \   while (0)
end_define
begin_define
DECL|macro|CURRENT_AS
define|#
directive|define
name|CURRENT_AS
parameter_list|(
name|type
parameter_list|)
value|((type*)current)
end_define
begin_function
DECL|function|compile_iterator_fallbackpath
specifier|static
name|void
name|compile_iterator_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
name|opcode
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|int
name|arg1
init|=
operator|-
literal|1
decl_stmt|,
name|arg2
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|cc
operator|=
name|get_iterator_parameters
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
operator|&
name|opcode
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OP_STAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_CRRANGE
case|:
if|if
condition|(
name|type
operator|==
name|OP_ANYNL
operator|||
name|type
operator|==
name|OP_EXTUNI
condition|)
block|{
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|OP_STAR
operator|||
name|opcode
operator|==
name|OP_UPTO
condition|)
name|arg2
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_PLUS
condition|)
name|arg2
operator|=
literal|1
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|skip_char_back
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_PLUS
operator|||
name|opcode
operator|==
name|OP_CRRANGE
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINPLUS
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_MINPLUS
condition|)
block|{
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|->
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
block|}
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|current
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_CRMINRANGE
case|:
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
condition|)
block|{
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|->
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
name|label
operator|=
name|LABEL
argument_list|()
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|current
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg2
operator|+
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CRMINRANGE
operator|&&
name|arg1
operator|==
literal|0
condition|)
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|arg1
operator|+
literal|2
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_QUERY
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MINQUERY
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compile_char1_hotpath
argument_list|(
name|common
argument_list|,
name|type
argument_list|,
name|cc
argument_list|,
operator|&
name|current
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSPLUS
case|:
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSUPTO
case|:
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|compile_ref_iterator_fallbackpath
specifier|static
name|void
name|compile_ref_iterator_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
name|type
decl_stmt|;
name|type
operator|=
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
return|return;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|iterator_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_recurse_fallbackpath
specifier|static
name|void
name|compile_recurse_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_assert_fallbackpath
specifier|static
name|void
name|compile_assert_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|brajump
init|=
name|NULL
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|!=
name|OP_BRAMINZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
condition|)
block|{
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|current
operator|->
name|topfallbacks
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|assert_fallback
argument_list|)
operator|->
name|framesize
operator|<
literal|0
condition|)
block|{
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ASSERT_NOT
operator|||
operator|*
name|cc
operator|==
name|OP_ASSERTBACK_NOT
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brajump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ASSERT
operator|||
operator|*
name|cc
operator|==
name|OP_ASSERTBACK
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_fallback
argument_list|)
operator|->
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_fallback
argument_list|)
operator|->
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_fallback
argument_list|)
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
comment|/* We know there is enough place on the stack. */
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|assert_fallback
argument_list|)
operator|->
name|hotpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brajump
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|compile_bracket_fallbackpath
specifier|static
name|void
name|compile_bracket_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|localptr
init|=
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|localptr
decl_stmt|;
name|int
name|stacksize
decl_stmt|;
name|int
name|count
decl_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|current
operator|->
name|cc
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccprev
decl_stmt|;
name|jump_list
modifier|*
name|jumplist
init|=
name|NULL
decl_stmt|;
name|jump_list
modifier|*
name|jumplistitem
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
name|bra
init|=
name|OP_BRA
decl_stmt|;
name|pcre_uchar
name|ket
decl_stmt|;
name|assert_fallback
modifier|*
name|assert
decl_stmt|;
name|BOOL
name|has_alternatives
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|brazero
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|once
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|cond
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|rminlabel
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_BRAZERO
operator|||
operator|*
name|cc
operator|==
name|OP_BRAMINZERO
condition|)
block|{
name|bra
operator|=
operator|*
name|cc
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
name|opcode
operator|=
operator|*
name|cc
expr_stmt|;
name|ccbegin
operator|=
name|cc
expr_stmt|;
name|ket
operator|=
operator|*
operator|(
name|bracketend
argument_list|(
name|ccbegin
argument_list|)
operator|-
literal|1
operator|-
name|LINK_SIZE
operator|)
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|has_alternatives
operator|=
operator|*
name|cc
operator|==
name|OP_ALT
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
name|has_alternatives
operator|=
operator|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|>=
name|OP_ASSERT
operator|&&
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|<=
name|OP_ASSERTBACK_NOT
operator|)
operator|||
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_CBRA
operator|||
name|opcode
operator|==
name|OP_SCBRA
condition|)
name|offset
operator|=
operator|(
name|GET2
argument_list|(
name|ccbegin
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|&&
operator|(
operator|*
name|cc
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|cc
operator|==
name|OP_KETRMIN
operator|)
condition|)
name|opcode
operator|=
name|OP_SCOND
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_ONCE_NC
argument_list|)
condition|)
name|opcode
operator|=
name|OP_ONCE
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
if|if
condition|(
name|bra
operator|!=
name|OP_BRAZERO
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brazero
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
if|if
condition|(
name|bra
operator|!=
name|OP_BRAMINZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|>=
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
comment|/* Checking zero-length iteration. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
operator|||
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|recursivehotpath
argument_list|)
expr_stmt|;
else|else
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
operator|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|recursivehotpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|recursivehotpath
argument_list|)
expr_stmt|;
block|}
name|rminlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brazero
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_ONCE
argument_list|)
condition|)
block|{
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|once
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
block|{
if|if
condition|(
name|has_alternatives
condition|)
block|{
comment|/* Always exactly one alternative. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jumplistitem
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
name|jumplistitem
argument_list|)
condition|)
return|return;
name|jumplist
operator|=
name|jumplistitem
expr_stmt|;
name|jumplistitem
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|jumplistitem
operator|->
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
block|{
comment|/* Build a jump list. Get the last successfully matched branch index. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|/* Append as the last item. */
if|if
condition|(
name|jumplist
operator|!=
name|NULL
condition|)
block|{
name|jumplistitem
operator|->
name|next
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
expr_stmt|;
name|jumplistitem
operator|=
name|jumplistitem
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|jumplistitem
operator|=
name|sljit_alloc_memory
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|jump_list
argument_list|)
argument_list|)
expr_stmt|;
name|jumplist
operator|=
name|jumplistitem
expr_stmt|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|!
name|jumplistitem
argument_list|)
condition|)
return|return;
name|jumplistitem
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|jumplistitem
operator|->
name|jump
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|cc
operator|=
name|ccbegin
operator|+
name|GET
argument_list|(
name|ccbegin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|COMPILE_FALLBACKPATH
argument_list|(
name|current
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|topfallbacks
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_COND
argument_list|)
operator|||
name|SLJIT_UNLIKELY
argument_list|(
name|opcode
operator|==
name|OP_SCOND
argument_list|)
condition|)
block|{
comment|/* Conditional block always has at most one alternative. */
if|if
condition|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|>=
name|OP_ASSERT
operator|&&
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|<=
name|OP_ASSERTBACK_NOT
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|assert
operator|=
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|assert
expr_stmt|;
if|if
condition|(
name|assert
operator|->
name|framesize
operator|>=
literal|0
operator|&&
operator|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERT
operator|||
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERTBACK
operator|)
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|assert
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cond
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|assert
operator|->
name|condfailed
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|condfailed
operator|!=
name|NULL
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|has_alternatives
argument_list|)
expr_stmt|;
name|cond
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|condfailed
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|SLJIT_ASSERT
argument_list|(
operator|!
name|has_alternatives
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_alternatives
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|current
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|nextfallbacks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
block|{
name|ccprev
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_COND
operator|&&
name|opcode
operator|!=
name|OP_SCOND
condition|)
block|{
if|if
condition|(
name|localptr
operator|!=
literal|0
operator|&&
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|compile_hotpath
argument_list|(
name|common
argument_list|,
name|ccprev
argument_list|,
name|cc
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return;
block|}
comment|/* Instructions after the current alternative is succesfully matched. */
comment|/* There is a similar code in compile_bracket_hotpath. */
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|<
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
comment|/* Move the STR_PTR to the localptr. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
comment|/* TMP2 which is set here used by OP_KETRMAX below. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
operator|||
name|bra
operator|!=
name|OP_BRA
condition|)
name|stacksize
operator|++
expr_stmt|;
if|if
condition|(
name|stacksize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
operator|||
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|stacksize
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We know we have place at least for one item on the top of the stack. */
name|SLJIT_ASSERT
argument_list|(
name|stacksize
operator|==
literal|1
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|stacksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ket
operator|!=
name|OP_KET
operator|||
name|bra
operator|!=
name|OP_BRA
condition|)
block|{
if|if
condition|(
name|ket
operator|!=
name|OP_KET
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stacksize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|stacksize
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|althotpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|jumplist
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jumplist
operator|->
name|jump
argument_list|)
expr_stmt|;
name|jumplist
operator|=
name|jumplist
operator|->
name|next
expr_stmt|;
block|}
name|COMPILE_FALLBACKPATH
argument_list|(
name|current
operator|->
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|topfallbacks
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|current
operator|->
name|nextfallbacks
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jumplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|NULL
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|opcode
operator|==
name|OP_COND
operator|||
name|opcode
operator|==
name|OP_SCOND
argument_list|)
expr_stmt|;
name|assert
operator|=
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|assert
expr_stmt|;
if|if
condition|(
operator|(
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERT_NOT
operator|||
name|ccbegin
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|==
name|OP_ASSERTBACK_NOT
operator|)
operator|&&
name|assert
operator|->
name|framesize
operator|>=
literal|0
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|assert
operator|->
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|assert
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
comment|/* Free the STR_PTR. */
if|if
condition|(
name|localptr
operator|==
literal|0
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* Using both tmp register is better for instruction scheduling. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_SBRA
operator|||
name|opcode
operator|==
name|OP_SCOND
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
block|{
name|cc
operator|=
name|ccbegin
operator|+
name|GET
argument_list|(
name|ccbegin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
block|{
comment|/* Reset head and drop saved frame. */
name|stacksize
operator|=
operator|(
name|ket
operator|==
name|OP_KETRMAX
operator|||
name|ket
operator|==
name|OP_KETRMIN
operator|||
operator|*
name|cc
operator|==
name|OP_ALT
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|+
name|stacksize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
operator|||
operator|(
operator|*
name|cc
operator|==
name|OP_ALT
operator|&&
name|ket
operator|!=
name|OP_KETRMIN
operator|)
condition|)
block|{
comment|/* The STR_PTR must be released. */
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|JUMPHERE
argument_list|(
name|once
argument_list|)
expr_stmt|;
comment|/* Restore previous localptr */
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|>=
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|u
operator|.
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See the comment below. */
name|free_stack
argument_list|(
name|common
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|localptr
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ket
operator|==
name|OP_KETRMAX
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|recursivehotpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|zerohotpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brazero
argument_list|)
expr_stmt|;
block|}
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ket
operator|==
name|OP_KETRMIN
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OP_ONCE removes everything in case of a fallback, so we don't   need to explicitly release the STR_PTR. The extra release would   affect badly the free_stack(2) above. */
if|if
condition|(
name|opcode
operator|!=
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|rminlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OP_ONCE
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
name|bra
operator|==
name|OP_BRAMINZERO
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAMINZERO
condition|)
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bra
operator|==
name|OP_BRAZERO
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracket_fallback
argument_list|)
operator|->
name|zerohotpath
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|brazero
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|compile_bracketpos_fallbackpath
specifier|static
name|void
name|compile_bracketpos_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
if|if
condition|(
name|CURRENT_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|framesize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|current
operator|->
name|cc
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|current
operator|->
name|cc
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|offset
operator|=
operator|(
name|GET2
argument_list|(
name|current
operator|->
name|cc
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
operator|)
operator|<<
literal|1
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|stacksize
argument_list|)
expr_stmt|;
return|return;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|localptr
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|topfallbacks
condition|)
block|{
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Drop the stack frame. */
name|free_stack
argument_list|(
name|common
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|stacksize
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|localptr
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|CURRENT_AS
argument_list|(
name|bracketpos_fallback
argument_list|)
operator|->
name|framesize
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_braminzero_fallbackpath
specifier|static
name|void
name|compile_braminzero_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|assert_fallback
name|fallback
decl_stmt|;
name|current
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
name|current
operator|->
name|nextfallbacks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
block|{
comment|/* Manual call of compile_bracket_hotpath and compile_bracket_fallbackpath. */
name|compile_bracket_hotpath
argument_list|(
name|common
argument_list|,
name|current
operator|->
name|cc
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|compile_bracket_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|fallback
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fallback
argument_list|)
argument_list|)
expr_stmt|;
name|fallback
operator|.
name|common
operator|.
name|cc
operator|=
name|current
operator|->
name|cc
expr_stmt|;
name|fallback
operator|.
name|hotpath
operator|=
name|CURRENT_AS
argument_list|(
name|braminzero_fallback
argument_list|)
operator|->
name|hotpath
expr_stmt|;
comment|/* Manual call of compile_assert_hotpath. */
name|compile_assert_hotpath
argument_list|(
name|common
argument_list|,
name|current
operator|->
name|cc
argument_list|,
operator|&
name|fallback
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
name|current
operator|->
name|nextfallbacks
operator|&&
operator|!
name|current
operator|->
name|topfallbacks
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_fallbackpath
specifier|static
name|void
name|compile_fallbackpath
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|,
name|struct
name|fallback_common
modifier|*
name|current
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|nextfallbacks
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|current
operator|->
name|nextfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|current
operator|->
name|cc
condition|)
block|{
case|case
name|OP_SET_SOM
case|:
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
endif|#
directive|endif
name|compile_iterator_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
name|compile_ref_iterator_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RECURSE
case|:
name|compile_recurse_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
name|compile_assert_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_CBRA
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCOND
case|:
name|compile_bracket_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAZERO
case|:
if|if
condition|(
name|current
operator|->
name|cc
index|[
literal|1
index|]
operator|>
name|OP_ASSERTBACK_NOT
condition|)
name|compile_bracket_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
else|else
name|compile_assert_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_BRAPOSZERO
case|:
name|compile_bracketpos_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BRAMINZERO
case|:
name|compile_braminzero_fallbackpath
argument_list|(
name|common
argument_list|,
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FAIL
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
name|set_jumps
argument_list|(
name|current
operator|->
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
name|current
operator|=
name|current
operator|->
name|prev
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|compile_recurse
specifier|static
name|SLJIT_INLINE
name|void
name|compile_recurse
parameter_list|(
name|compiler_common
modifier|*
name|common
parameter_list|)
block|{
name|DEFINE_COMPILER
expr_stmt|;
name|pcre_uchar
modifier|*
name|cc
init|=
name|common
operator|->
name|start
operator|+
name|common
operator|->
name|currententry
operator|->
name|start
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccbegin
init|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
operator|(
operator|*
name|cc
operator|==
name|OP_BRA
condition|?
literal|0
else|:
name|IMM2_SIZE
operator|)
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccend
init|=
name|bracketend
argument_list|(
name|cc
argument_list|)
decl_stmt|;
name|int
name|localsize
init|=
name|get_localsize
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|ccend
argument_list|)
decl_stmt|;
name|int
name|framesize
init|=
name|get_framesize
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
name|int
name|alternativesize
decl_stmt|;
name|BOOL
name|needsframe
decl_stmt|;
name|fallback_common
name|altfallback
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|cc
operator|==
name|OP_BRA
operator|||
operator|*
name|cc
operator|==
name|OP_CBRA
operator|||
operator|*
name|cc
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|cc
operator|==
name|OP_SCBRA
operator|||
operator|*
name|cc
operator|==
name|OP_SCBRAPOS
argument_list|)
expr_stmt|;
name|needsframe
operator|=
name|framesize
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|needsframe
condition|)
name|framesize
operator|=
literal|0
expr_stmt|;
name|alternativesize
operator|=
operator|*
operator|(
name|cc
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|OP_ALT
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|common
operator|->
name|currententry
operator|->
name|entry
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|common
operator|->
name|currententry
operator|->
name|entry
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|set_jumps
argument_list|(
name|common
operator|->
name|currententry
operator|->
name|calls
argument_list|,
name|common
operator|->
name|currententry
operator|->
name|entry
argument_list|)
expr_stmt|;
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|allocate_stack
argument_list|(
name|common
argument_list|,
name|localsize
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
name|localsize
operator|+
name|framesize
operator|+
name|alternativesize
operator|-
literal|1
argument_list|)
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_locals
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|ccend
argument_list|,
name|TRUE
argument_list|,
name|localsize
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|,
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|RECURSIVE_HEAD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsframe
condition|)
name|init_frame
argument_list|(
name|common
argument_list|,
name|cc
argument_list|,
name|framesize
operator|+
name|alternativesize
operator|-
literal|1
argument_list|,
name|alternativesize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternativesize
operator|>
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|altfallback
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fallback_common
argument_list|)
argument_list|)
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|NULL
expr_stmt|;
name|altfallback
operator|.
name|cc
operator|=
name|ccbegin
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|altfallback
operator|.
name|top
operator|=
name|NULL
expr_stmt|;
name|altfallback
operator|.
name|topfallbacks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|altfallback
operator|.
name|cc
operator|!=
name|ccbegin
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
name|STACK
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compile_hotpath
argument_list|(
name|common
argument_list|,
name|altfallback
operator|.
name|cc
argument_list|,
name|cc
argument_list|,
operator|&
name|altfallback
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|accept
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
argument_list|)
expr_stmt|;
name|compile_fallbackpath
argument_list|(
name|common
argument_list|,
name|altfallback
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
return|return;
name|set_jumps
argument_list|(
name|altfallback
operator|.
name|topfallbacks
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cc
operator|!=
name|OP_ALT
condition|)
break|break;
name|altfallback
operator|.
name|cc
operator|=
name|cc
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* None of them matched. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump
operator|=
name|JUMP
argument_list|(
name|SLJIT_JUMP
argument_list|)
expr_stmt|;
name|set_jumps
argument_list|(
name|common
operator|->
name|accept
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|RECURSIVE_HEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsframe
condition|)
block|{
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
name|alternativesize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump
argument_list|(
name|compiler
argument_list|,
operator|&
name|common
operator|->
name|revertframes
argument_list|,
name|JUMP
argument_list|(
name|SLJIT_FAST_CALL
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|framesize
operator|+
name|alternativesize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|copy_locals
argument_list|(
name|common
argument_list|,
name|ccbegin
argument_list|,
name|ccend
argument_list|,
name|FALSE
argument_list|,
name|localsize
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|,
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|free_stack
argument_list|(
name|common
argument_list|,
name|localsize
operator|+
name|framesize
operator|+
name|alternativesize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|TMP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|RECURSIVE_HEAD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|STACK_TOP
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|COMPILE_FALLBACKPATH
undef|#
directive|undef
name|COMPILE_FALLBACKPATH
end_undef
begin_undef
DECL|macro|CURRENT_AS
undef|#
directive|undef
name|CURRENT_AS
end_undef
begin_decl_stmt
name|void
DECL|function|jit_compile
name|PRIV
argument_list|(
name|jit_compile
argument_list|)
argument_list|(
specifier|const
name|REAL_PCRE
operator|*
name|re
argument_list|,
name|PUBL
argument_list|(
name|extra
argument_list|)
operator|*
name|extra
argument_list|)
block|{
name|struct
name|sljit_compiler
modifier|*
name|compiler
decl_stmt|;
name|fallback_common
name|rootfallback
decl_stmt|;
name|compiler_common
name|common_data
decl_stmt|;
name|compiler_common
modifier|*
name|common
init|=
operator|&
name|common_data
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|tables
init|=
name|re
operator|->
name|tables
decl_stmt|;
name|pcre_study_data
modifier|*
name|study
decl_stmt|;
name|pcre_uchar
modifier|*
name|ccend
decl_stmt|;
name|executable_function
modifier|*
name|function
decl_stmt|;
name|void
modifier|*
name|executable_func
decl_stmt|;
name|sljit_uw
name|executable_size
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|leave
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|mainloop
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|empty_match_found
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|empty_match_fallback
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|alloc_error
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|reqbyte_notfound
init|=
name|NULL
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|empty_match
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|extra
operator|->
name|flags
operator|&
name|PCRE_EXTRA_STUDY_DATA
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|study
operator|=
name|extra
operator|->
name|study_data
expr_stmt|;
if|if
condition|(
operator|!
name|tables
condition|)
name|tables
operator|=
name|PRIV
argument_list|(
name|default_tables
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rootfallback
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fallback_common
argument_list|)
argument_list|)
expr_stmt|;
name|rootfallback
operator|.
name|cc
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
operator|+
name|re
operator|->
name|name_count
operator|*
name|re
operator|->
name|name_entry_size
expr_stmt|;
name|common
operator|->
name|compiler
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|start
operator|=
name|rootfallback
operator|.
name|cc
expr_stmt|;
name|common
operator|->
name|cbraptr
operator|=
name|OVECTOR_START
operator|+
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
name|common
operator|->
name|fcc
operator|=
name|tables
operator|+
name|fcc_offset
expr_stmt|;
name|common
operator|->
name|lcc
operator|=
call|(
name|sljit_w
call|)
argument_list|(
name|tables
operator|+
name|lcc_offset
argument_list|)
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_FIXED
expr_stmt|;
switch|switch
condition|(
name|re
operator|->
name|options
operator|&
name|PCRE_NEWLINE_BITS
condition|)
block|{
case|case
literal|0
case|:
comment|/* Compile-time default */
switch|switch
condition|(
name|NEWLINE
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
break|break;
default|default:
name|common
operator|->
name|newline
operator|=
name|NEWLINE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCRE_NEWLINE_CR
case|:
name|common
operator|->
name|newline
operator|=
name|CHAR_CR
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_LF
case|:
name|common
operator|->
name|newline
operator|=
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_CR
operator|+
name|PCRE_NEWLINE_LF
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANY
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANYCRLF
case|:
name|common
operator|->
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
name|common
operator|->
name|nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_BSR_ANYCRLF
operator|)
operator|!=
literal|0
condition|)
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_BSR_UNICODE
operator|)
operator|!=
literal|0
condition|)
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|BSR_ANYCRLF
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
else|#
directive|else
name|common
operator|->
name|bsr_nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
endif|#
directive|endif
block|}
name|common
operator|->
name|endonly
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_DOLLAR_ENDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|common
operator|->
name|ctypes
operator|=
call|(
name|sljit_w
call|)
argument_list|(
name|tables
operator|+
name|ctypes_offset
argument_list|)
expr_stmt|;
name|common
operator|->
name|name_table
operator|=
call|(
name|sljit_w
call|)
argument_list|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
argument_list|)
expr_stmt|;
name|common
operator|->
name|name_count
operator|=
name|re
operator|->
name|name_count
expr_stmt|;
name|common
operator|->
name|name_entry_size
operator|=
name|re
operator|->
name|name_entry_size
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|stubs
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|currententry
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|accept
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|calllimit
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|stackalloc
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|revertframes
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|wordboundary
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|anynewline
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|hspace
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|vspace
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|casefulcmp
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|caselesscmp
operator|=
name|NULL
expr_stmt|;
name|common
operator|->
name|jscript_compat
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
comment|/* PCRE_UTF16 has the same value as PCRE_UTF8. */
name|common
operator|->
name|utf
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|common
operator|->
name|use_ucp
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
name|common
operator|->
name|utfreadchar
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|common
operator|->
name|utfreadtype8
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SUPPORT_UTF */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|common
operator|->
name|getucd
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|ccend
operator|=
name|bracketend
argument_list|(
name|rootfallback
operator|.
name|cc
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|*
name|rootfallback
operator|.
name|cc
operator|==
name|OP_BRA
operator|&&
name|ccend
index|[
operator|-
operator|(
literal|1
operator|+
name|LINK_SIZE
operator|)
index|]
operator|==
name|OP_KET
argument_list|)
expr_stmt|;
name|common
operator|->
name|localsize
operator|=
name|get_localspace
argument_list|(
name|common
argument_list|,
name|rootfallback
operator|.
name|cc
argument_list|,
name|ccend
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|localsize
operator|<
literal|0
condition|)
return|return;
name|common
operator|->
name|localsize
operator|+=
name|common
operator|->
name|cbraptr
operator|+
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|localsize
operator|>
name|SLJIT_MAX_LOCAL_SIZE
condition|)
return|return;
name|common
operator|->
name|localptrs
operator|=
operator|(
name|int
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
operator|(
name|ccend
operator|-
name|rootfallback
operator|.
name|cc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|common
operator|->
name|localptrs
condition|)
return|return;
name|memset
argument_list|(
name|common
operator|->
name|localptrs
argument_list|,
literal|0
argument_list|,
operator|(
name|ccend
operator|-
name|rootfallback
operator|.
name|cc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|set_localptrs
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|cbraptr
operator|+
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_w
argument_list|)
argument_list|,
name|ccend
argument_list|)
expr_stmt|;
name|compiler
operator|=
name|sljit_create_compiler
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|compiler
condition|)
block|{
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|localptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|common
operator|->
name|compiler
operator|=
name|compiler
expr_stmt|;
comment|/* Main pcre_jit_exec entry. */
name|sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
comment|/* Register init. */
name|reset_ovector
argument_list|(
name|common
argument_list|,
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
condition|)
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|REQ_CHAR_PTR
argument_list|,
name|SLJIT_TEMPORARY_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|calllimit
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_LIMIT
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP2
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CALL_LIMIT
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Main part of the matching */
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|==
literal|0
condition|)
block|{
name|mainloop
operator|=
name|mainloop_entry
argument_list|(
name|common
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_HASCRORLF
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Forward search if possible. */
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
condition|)
name|fast_forward_first_char
argument_list|(
name|common
argument_list|,
name|re
operator|->
name|first_char
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FCH_CASELESS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|!=
literal|0
condition|)
name|fast_forward_newline
argument_list|(
name|common
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|==
literal|0
operator|&&
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MAPPED
operator|)
operator|!=
literal|0
condition|)
name|fast_forward_start_bits
argument_list|(
name|common
argument_list|,
operator|(
name|sljit_uw
operator|)
name|study
operator|->
name|start_bits
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
condition|)
name|reqbyte_notfound
operator|=
name|search_requested_char
argument_list|(
name|common
argument_list|,
name|re
operator|->
name|req_char
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_RCH_CASELESS
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Store the current STR_PTR in OVECTOR(0). */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the limit of allowed recursions. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|CALL_COUNT
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|CALL_LIMIT
argument_list|)
expr_stmt|;
name|compile_hotpath
argument_list|(
name|common
argument_list|,
name|rootfallback
operator|.
name|cc
argument_list|,
name|ccend
argument_list|,
operator|&
name|rootfallback
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|localptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|empty_match
operator|=
name|CMP
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|empty_match_found
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|common
operator|->
name|acceptlabel
operator|=
name|LABEL
argument_list|()
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|accept
operator|!=
name|NULL
condition|)
name|set_jumps
argument_list|(
name|common
operator|->
name|accept
argument_list|,
name|common
operator|->
name|acceptlabel
argument_list|)
expr_stmt|;
comment|/* This means we have a match. Update the ovector. */
name|copy_ovector
argument_list|(
name|common
argument_list|,
name|re
operator|->
name|top_bracket
operator|+
literal|1
argument_list|)
expr_stmt|;
name|leave
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|empty_match_fallback
operator|=
name|LABEL
argument_list|()
expr_stmt|;
name|compile_fallbackpath
argument_list|(
name|common
argument_list|,
name|rootfallback
operator|.
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|localptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLJIT_ASSERT
argument_list|(
name|rootfallback
operator|.
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check we have remaining characters. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|study
operator|!=
name|NULL
operator|&&
name|study
operator|->
name|minlength
operator|>
literal|1
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|study
operator|->
name|minlength
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_LESS_EQUAL
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|study
operator|!=
name|NULL
operator|&&
name|study
operator|->
name|minlength
operator|>
literal|1
condition|)
block|{
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|IN_UCHARS
argument_list|(
name|study
operator|->
name|minlength
argument_list|)
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|STR_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_GREATER
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_SUB
operator||
name|SLJIT_SET_U
argument_list|,
name|SLJIT_UNUSED
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|)
expr_stmt|;
name|COND_VALUE
argument_list|(
name|SLJIT_OR
operator||
name|SLJIT_SET_E
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_C_GREATER_EQUAL
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_C_ZERO
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
else|else
name|CMPTO
argument_list|(
name|SLJIT_C_LESS
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|FIRSTLINE_END
argument_list|,
name|mainloop
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reqbyte_notfound
operator|!=
name|NULL
condition|)
name|JUMPHERE
argument_list|(
name|reqbyte_notfound
argument_list|)
expr_stmt|;
comment|/* Copy OVECTOR(1) to OVECTOR(0) */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|OVECTOR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_NOMATCH
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|leave
argument_list|)
expr_stmt|;
name|flush_stubs
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|JUMPHERE
argument_list|(
name|empty_match
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|empty_match_fallback
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|notempty_atstart
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|empty_match_found
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|CMPTO
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|STR_PTR
argument_list|,
literal|0
argument_list|,
name|empty_match_found
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|empty_match_fallback
argument_list|)
expr_stmt|;
name|common
operator|->
name|currententry
operator|=
name|common
operator|->
name|entries
expr_stmt|;
while|while
condition|(
name|common
operator|->
name|currententry
operator|!=
name|NULL
condition|)
block|{
comment|/* Might add new entries. */
name|compile_recurse
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|sljit_get_compiler_error
argument_list|(
name|compiler
argument_list|)
argument_list|)
condition|)
block|{
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|localptrs
argument_list|)
expr_stmt|;
return|return;
block|}
name|flush_stubs
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|common
operator|->
name|currententry
operator|=
name|common
operator|->
name|currententry
operator|->
name|next
expr_stmt|;
block|}
comment|/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */
comment|/* This is a (really) rare case. */
name|set_jumps
argument_list|(
name|common
operator|->
name|stackalloc
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
comment|/* RETURN_ADDR is not a saved register. */
name|sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|common
operator|->
name|localsize
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|top
argument_list|)
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP2
argument_list|(
name|SLJIT_ADD
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|limit
argument_list|)
argument_list|,
name|SLJIT_IMM
argument_list|,
name|STACK_GROWTH_RATE
argument_list|)
expr_stmt|;
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL2
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|sljit_stack_resize
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_error
operator|=
name|CMP
argument_list|(
name|SLJIT_C_NOT_EQUAL
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|ARGUMENTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP1
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
name|jit_arguments
argument_list|,
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_TOP
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|STACK_LIMIT
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|TMP1
argument_list|)
argument_list|,
name|SLJIT_OFFSETOF
argument_list|(
expr|struct
name|sljit_stack
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|TMP2
argument_list|,
literal|0
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS1
argument_list|)
expr_stmt|;
name|sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MEM1
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|LOCALS0
argument_list|)
expr_stmt|;
comment|/* Allocation failed. */
name|JUMPHERE
argument_list|(
name|alloc_error
argument_list|)
expr_stmt|;
comment|/* We break the return address cache here, but this is a really rare case. */
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_JIT_STACKLIMIT
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|leave
argument_list|)
expr_stmt|;
comment|/* Call limit reached. */
name|set_jumps
argument_list|(
name|common
operator|->
name|calllimit
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|OP1
argument_list|(
name|SLJIT_MOV
argument_list|,
name|SLJIT_RETURN_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|PCRE_ERROR_MATCHLIMIT
argument_list|)
expr_stmt|;
name|JUMPTO
argument_list|(
name|SLJIT_JUMP
argument_list|,
name|leave
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|revertframes
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|revertframes
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_revertframes
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|wordboundary
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|wordboundary
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_wordboundary
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|anynewline
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|anynewline
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_anynewline
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|hspace
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|hspace
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_hspace
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|vspace
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|vspace
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|check_vspace
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|casefulcmp
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|casefulcmp
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_casefulcmp
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common
operator|->
name|caselesscmp
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|caselesscmp
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_caselesscmp
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|common
operator|->
name|utfreadchar
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|utfreadchar
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_utfreadchar
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|common
operator|->
name|utfreadtype8
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|utfreadtype8
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_utfreadtype8
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|common
operator|->
name|getucd
operator|!=
name|NULL
condition|)
block|{
name|set_jumps
argument_list|(
name|common
operator|->
name|getucd
argument_list|,
name|LABEL
argument_list|()
argument_list|)
expr_stmt|;
name|do_getucd
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLJIT_FREE
argument_list|(
name|common
operator|->
name|localptrs
argument_list|)
expr_stmt|;
name|executable_func
operator|=
name|sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|executable_size
operator|=
name|sljit_get_generated_code_size
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|sljit_free_compiler
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable_func
operator|==
name|NULL
condition|)
return|return;
name|function
operator|=
name|SLJIT_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|executable_function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|==
name|NULL
condition|)
block|{
comment|/* This case is highly unlikely since we just recently   freed a lot of memory. Although not impossible. */
name|sljit_free_code
argument_list|(
name|executable_func
argument_list|)
expr_stmt|;
return|return;
block|}
name|function
operator|->
name|executable_func
operator|=
name|executable_func
expr_stmt|;
name|function
operator|->
name|executable_size
operator|=
name|executable_size
expr_stmt|;
name|function
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|function
operator|->
name|userdata
operator|=
name|NULL
expr_stmt|;
name|extra
operator|->
name|executable_jit
operator|=
name|function
expr_stmt|;
name|extra
operator|->
name|flags
operator||=
name|PCRE_EXTRA_EXECUTABLE_JIT
expr_stmt|;
block|}
end_decl_stmt
begin_function
DECL|function|jit_machine_stack_exec
specifier|static
name|int
name|jit_machine_stack_exec
parameter_list|(
name|jit_arguments
modifier|*
name|arguments
parameter_list|,
name|executable_function
modifier|*
name|function
parameter_list|)
block|{
union|union
block|{
name|void
modifier|*
name|executable_func
decl_stmt|;
name|jit_function
name|call_executable_func
decl_stmt|;
block|}
name|convert_executable_func
union|;
name|pcre_uint8
name|local_area
index|[
name|LOCAL_SPACE_SIZE
index|]
decl_stmt|;
name|struct
name|sljit_stack
name|local_stack
decl_stmt|;
name|local_stack
operator|.
name|top
operator|=
operator|(
name|sljit_w
operator|)
operator|&
name|local_area
expr_stmt|;
name|local_stack
operator|.
name|base
operator|=
name|local_stack
operator|.
name|top
expr_stmt|;
name|local_stack
operator|.
name|limit
operator|=
name|local_stack
operator|.
name|base
operator|+
name|LOCAL_SPACE_SIZE
expr_stmt|;
name|local_stack
operator|.
name|max_limit
operator|=
name|local_stack
operator|.
name|limit
expr_stmt|;
name|arguments
operator|->
name|stack
operator|=
operator|&
name|local_stack
expr_stmt|;
name|convert_executable_func
operator|.
name|executable_func
operator|=
name|function
operator|->
name|executable_func
expr_stmt|;
return|return
name|convert_executable_func
operator|.
name|call_executable_func
argument_list|(
name|arguments
argument_list|)
return|;
block|}
end_function
begin_function
name|int
DECL|function|jit_exec
name|PRIV
function|(
name|jit_exec
function|)
parameter_list|(
specifier|const
name|REAL_PCRE
modifier|*
name|re
parameter_list|,
name|void
modifier|*
name|executable_func
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|subject
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|start_offset
parameter_list|,
name|int
name|options
parameter_list|,
name|int
name|match_limit
parameter_list|,
name|int
modifier|*
name|offsets
parameter_list|,
name|int
name|offsetcount
parameter_list|)
block|{
name|executable_function
modifier|*
name|function
init|=
operator|(
name|executable_function
operator|*
operator|)
name|executable_func
decl_stmt|;
union|union
block|{
name|void
modifier|*
name|executable_func
decl_stmt|;
name|jit_function
name|call_executable_func
decl_stmt|;
block|}
name|convert_executable_func
union|;
name|jit_arguments
name|arguments
decl_stmt|;
name|int
name|maxoffsetcount
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* Sanity checks should be handled by pcre_exec. */
name|arguments
operator|.
name|stack
operator|=
name|NULL
expr_stmt|;
name|arguments
operator|.
name|str
operator|=
name|subject
operator|+
name|start_offset
expr_stmt|;
name|arguments
operator|.
name|begin
operator|=
name|subject
expr_stmt|;
name|arguments
operator|.
name|end
operator|=
name|subject
operator|+
name|length
expr_stmt|;
name|arguments
operator|.
name|calllimit
operator|=
name|match_limit
expr_stmt|;
comment|/* JIT decreases this value less times. */
name|arguments
operator|.
name|notbol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTBOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|noteol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|notempty
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|notempty_atstart
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY_ATSTART
operator|)
operator|!=
literal|0
expr_stmt|;
name|arguments
operator|.
name|offsets
operator|=
name|offsets
expr_stmt|;
comment|/* pcre_exec() rounds offsetcount to a multiple of 3, and then uses only 2/3 of the output vector for storing captured strings, with the remainder used as workspace. We don't need the workspace here. For compatibility, we limit the number of captured strings in the same way as pcre_exec(), so that the user gets the same result with and without JIT. */
if|if
condition|(
name|offsetcount
operator|!=
literal|2
condition|)
name|offsetcount
operator|=
operator|(
operator|(
name|offsetcount
operator|-
operator|(
name|offsetcount
operator|%
literal|3
operator|)
operator|)
operator|*
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
name|maxoffsetcount
operator|=
operator|(
name|re
operator|->
name|top_bracket
operator|+
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|offsetcount
operator|>
name|maxoffsetcount
condition|)
name|offsetcount
operator|=
name|maxoffsetcount
expr_stmt|;
name|arguments
operator|.
name|offsetcount
operator|=
name|offsetcount
expr_stmt|;
if|if
condition|(
name|function
operator|->
name|callback
condition|)
name|arguments
operator|.
name|stack
operator|=
operator|(
expr|struct
name|sljit_stack
operator|*
operator|)
name|function
operator|->
name|callback
argument_list|(
name|function
operator|->
name|userdata
argument_list|)
expr_stmt|;
else|else
name|arguments
operator|.
name|stack
operator|=
operator|(
expr|struct
name|sljit_stack
operator|*
operator|)
name|function
operator|->
name|userdata
expr_stmt|;
if|if
condition|(
name|arguments
operator|.
name|stack
operator|==
name|NULL
condition|)
name|retval
operator|=
name|jit_machine_stack_exec
argument_list|(
operator|&
name|arguments
argument_list|,
name|function
argument_list|)
expr_stmt|;
else|else
block|{
name|convert_executable_func
operator|.
name|executable_func
operator|=
name|function
operator|->
name|executable_func
expr_stmt|;
name|retval
operator|=
name|convert_executable_func
operator|.
name|call_executable_func
argument_list|(
operator|&
name|arguments
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|*
literal|2
operator|>
name|offsetcount
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
name|void
DECL|function|jit_free
name|PRIV
function|(
name|jit_free
function|)
parameter_list|(
name|void
modifier|*
name|executable_func
parameter_list|)
block|{
name|executable_function
modifier|*
name|function
init|=
operator|(
name|executable_function
operator|*
operator|)
name|executable_func
decl_stmt|;
name|sljit_free_code
argument_list|(
name|function
operator|->
name|executable_func
argument_list|)
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|int
DECL|function|jit_get_size
name|PRIV
function|(
name|jit_get_size
function|)
parameter_list|(
name|void
modifier|*
name|executable_func
parameter_list|)
block|{
return|return
operator|(
operator|(
name|executable_function
operator|*
operator|)
name|executable_func
operator|)
operator|->
name|executable_size
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|jit_get_target
name|PRIV
function|(
name|jit_get_target
function|)
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|sljit_get_platform_name
argument_list|()
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DECL
name|pcre_jit_stack
modifier|*
DECL|function|pcre_jit_stack_alloc
name|pcre_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
else|#
directive|else
name|PCRE_EXP_DECL
name|pcre16_jit_stack
modifier|*
name|pcre16_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|startsize
operator|<
literal|1
operator|||
name|maxsize
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|startsize
operator|>
name|maxsize
condition|)
name|startsize
operator|=
name|maxsize
expr_stmt|;
name|startsize
operator|=
operator|(
name|startsize
operator|+
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
expr_stmt|;
name|maxsize
operator|=
operator|(
name|maxsize
operator|+
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|STACK_GROWTH_RATE
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|PUBL
argument_list|(
name|jit_stack
argument_list|)
operator|*
operator|)
name|sljit_allocate_stack
argument_list|(
name|startsize
argument_list|,
name|maxsize
argument_list|)
return|;
block|}
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_jit_stack_free
name|pcre_jit_stack_free
argument_list|(
name|pcre_jit_stack
operator|*
name|stack
argument_list|)
else|#
directive|else
name|PCRE_EXP_DECL
name|void
name|pcre16_jit_stack_free
argument_list|(
name|pcre16_jit_stack
operator|*
name|stack
argument_list|)
endif|#
directive|endif
block|{
name|sljit_free_stack
argument_list|(
operator|(
expr|struct
name|sljit_stack
operator|*
operator|)
name|stack
argument_list|)
expr_stmt|;
block|}
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_assign_jit_stack
name|pcre_assign_jit_stack
argument_list|(
name|pcre_extra
operator|*
name|extra
argument_list|,
name|pcre_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
else|#
directive|else
name|PCRE_EXP_DECL
name|void
name|pcre16_assign_jit_stack
argument_list|(
name|pcre16_extra
operator|*
name|extra
argument_list|,
name|pcre16_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
endif|#
directive|endif
block|{
name|executable_function
modifier|*
name|function
decl_stmt|;
if|if
condition|(
name|extra
operator|!=
name|NULL
operator|&&
operator|(
name|extra
operator|->
name|flags
operator|&
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|)
operator|!=
literal|0
operator|&&
name|extra
operator|->
name|executable_jit
operator|!=
name|NULL
condition|)
block|{
name|function
operator|=
operator|(
name|executable_function
operator|*
operator|)
name|extra
operator|->
name|executable_jit
expr_stmt|;
name|function
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|function
operator|->
name|userdata
operator|=
name|userdata
expr_stmt|;
block|}
block|}
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SUPPORT_JIT */
end_comment
begin_comment
comment|/* These are dummy functions to avoid linking errors when JIT support is not being compiled. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DECL
name|pcre_jit_stack
modifier|*
DECL|function|pcre_jit_stack_alloc
name|pcre_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
else|#
directive|else
name|PCRE_EXP_DECL
name|pcre16_jit_stack
modifier|*
name|pcre16_jit_stack_alloc
argument_list|(
name|int
name|startsize
argument_list|,
name|int
name|maxsize
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|startsize
expr_stmt|;
operator|(
name|void
operator|)
name|maxsize
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_jit_stack_free
name|pcre_jit_stack_free
argument_list|(
name|pcre_jit_stack
operator|*
name|stack
argument_list|)
else|#
directive|else
name|PCRE_EXP_DECL
name|void
name|pcre16_jit_stack_free
argument_list|(
name|pcre16_jit_stack
operator|*
name|stack
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|stack
expr_stmt|;
block|}
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DECL
name|void
DECL|function|pcre_assign_jit_stack
name|pcre_assign_jit_stack
argument_list|(
name|pcre_extra
operator|*
name|extra
argument_list|,
name|pcre_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
else|#
directive|else
name|PCRE_EXP_DECL
name|void
name|pcre16_assign_jit_stack
argument_list|(
name|pcre16_extra
operator|*
name|extra
argument_list|,
name|pcre16_jit_callback
name|callback
argument_list|,
name|void
operator|*
name|userdata
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|extra
expr_stmt|;
operator|(
name|void
operator|)
name|callback
expr_stmt|;
operator|(
name|void
operator|)
name|userdata
expr_stmt|;
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* End of pcre_jit_compile.c */
end_comment
end_unit
