begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2014 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains pcre_exec(), the externally visible function that does pattern matching using an NFA algorithm, trying to mimic Perl as closely as possible. There are also some static supporting functions. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|NLBLOCK
define|#
directive|define
name|NLBLOCK
value|md
end_define
begin_comment
DECL|macro|NLBLOCK
comment|/* Block containing newline information */
end_comment
begin_define
DECL|macro|PSSTART
define|#
directive|define
name|PSSTART
value|start_subject
end_define
begin_comment
DECL|macro|PSSTART
comment|/* Field containing processed string start */
end_comment
begin_define
DECL|macro|PSEND
define|#
directive|define
name|PSEND
value|end_subject
end_define
begin_comment
DECL|macro|PSEND
comment|/* Field containing processed string end */
end_comment
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_comment
comment|/* Undefine some potentially clashing cpp symbols */
end_comment
begin_undef
DECL|macro|min
undef|#
directive|undef
name|min
end_undef
begin_undef
DECL|macro|max
undef|#
directive|undef
name|max
end_undef
begin_comment
comment|/* The md->capture_last field uses the lower 16 bits for the last captured substring (which can never be greater than 65535) and a bit in the top half to mean "capture vector overflowed". This odd way of doing things was implemented when it was realized that preserving and restoring the overflow bit whenever the last capture number was saved/restored made for a neater interface, and doing it this way saved on (a) another variable, which would have increased the stack frame size (a big NO-NO in PCRE) and (b) another separate set of save/restore instructions. The following defines are used in implementing this. */
end_comment
begin_define
DECL|macro|CAPLMASK
define|#
directive|define
name|CAPLMASK
value|0x0000ffff
end_define
begin_comment
DECL|macro|CAPLMASK
comment|/* The bits used for last_capture */
end_comment
begin_define
DECL|macro|OVFLMASK
define|#
directive|define
name|OVFLMASK
value|0xffff0000
end_define
begin_comment
DECL|macro|OVFLMASK
comment|/* The bits used for the overflow flag */
end_comment
begin_define
DECL|macro|OVFLBIT
define|#
directive|define
name|OVFLBIT
value|0x00010000
end_define
begin_comment
DECL|macro|OVFLBIT
comment|/* The bit that is set for overflow */
end_comment
begin_comment
comment|/* Values for setting in md->match_function_type to indicate two special types of call to match(). We do it this way to save on using another stack variable, as stack usage is to be discouraged. */
end_comment
begin_define
DECL|macro|MATCH_CONDASSERT
define|#
directive|define
name|MATCH_CONDASSERT
value|1
end_define
begin_comment
DECL|macro|MATCH_CONDASSERT
comment|/* Called to check a condition assertion */
end_comment
begin_define
DECL|macro|MATCH_CBEGROUP
define|#
directive|define
name|MATCH_CBEGROUP
value|2
end_define
begin_comment
DECL|macro|MATCH_CBEGROUP
comment|/* Could-be-empty unlimited repeat group */
end_comment
begin_comment
comment|/* Non-error returns from the match() function. Error returns are externally defined PCRE_ERROR_xxx codes, which are all negative. */
end_comment
begin_define
DECL|macro|MATCH_MATCH
define|#
directive|define
name|MATCH_MATCH
value|1
end_define
begin_define
DECL|macro|MATCH_NOMATCH
define|#
directive|define
name|MATCH_NOMATCH
value|0
end_define
begin_comment
comment|/* Special internal returns from the match() function. Make them sufficiently negative to avoid the external error codes. */
end_comment
begin_define
DECL|macro|MATCH_ACCEPT
define|#
directive|define
name|MATCH_ACCEPT
value|(-999)
end_define
begin_define
DECL|macro|MATCH_KETRPOS
define|#
directive|define
name|MATCH_KETRPOS
value|(-998)
end_define
begin_define
DECL|macro|MATCH_ONCE
define|#
directive|define
name|MATCH_ONCE
value|(-997)
end_define
begin_comment
comment|/* The next 5 must be kept together and in sequence so that a test that checks for any one of them can use a range. */
end_comment
begin_define
DECL|macro|MATCH_COMMIT
define|#
directive|define
name|MATCH_COMMIT
value|(-996)
end_define
begin_define
DECL|macro|MATCH_PRUNE
define|#
directive|define
name|MATCH_PRUNE
value|(-995)
end_define
begin_define
DECL|macro|MATCH_SKIP
define|#
directive|define
name|MATCH_SKIP
value|(-994)
end_define
begin_define
DECL|macro|MATCH_SKIP_ARG
define|#
directive|define
name|MATCH_SKIP_ARG
value|(-993)
end_define
begin_define
DECL|macro|MATCH_THEN
define|#
directive|define
name|MATCH_THEN
value|(-992)
end_define
begin_define
DECL|macro|MATCH_BACKTRACK_MAX
define|#
directive|define
name|MATCH_BACKTRACK_MAX
value|MATCH_THEN
end_define
begin_define
DECL|macro|MATCH_BACKTRACK_MIN
define|#
directive|define
name|MATCH_BACKTRACK_MIN
value|MATCH_COMMIT
end_define
begin_comment
comment|/* Maximum number of ints of offset to save on the stack for recursive calls. If the offset vector is bigger, malloc is used. This should be a multiple of 3, because the offset vector is always a multiple of 3 long. */
end_comment
begin_define
DECL|macro|REC_STACK_SAVE_MAX
define|#
directive|define
name|REC_STACK_SAVE_MAX
value|30
end_define
begin_comment
comment|/* Min and max values for the common repeats; for the maxima, 0 => infinity */
end_comment
begin_decl_stmt
DECL|variable|rep_min
specifier|static
specifier|const
name|char
name|rep_min
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rep_max
specifier|static
specifier|const
name|char
name|rep_max
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_DEBUG
end_ifdef
begin_comment
comment|/************************************************* *        Debugging function to print chars       * *************************************************/
end_comment
begin_comment
comment|/* Print a sequence of chars in printable format, stopping at the end of the subject if the requested.  Arguments:   p           points to characters   length      number to print   is_subject  TRUE if printing from within md->start_subject   md          pointer to matching data block, if is_subject is TRUE  Returns:     nothing */
end_comment
begin_function
specifier|static
name|void
DECL|function|pchars
name|pchars
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|,
name|BOOL
name|is_subject
parameter_list|,
name|match_data
modifier|*
name|md
parameter_list|)
block|{
name|pcre_uint32
name|c
decl_stmt|;
name|BOOL
name|utf
init|=
name|md
operator|->
name|utf
decl_stmt|;
if|if
condition|(
name|is_subject
operator|&&
name|length
operator|>
name|md
operator|->
name|end_subject
operator|-
name|p
condition|)
name|length
operator|=
name|md
operator|->
name|end_subject
operator|-
name|p
expr_stmt|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|=
name|UCHAR21INCTEST
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\x{%02x}"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/************************************************* *          Match a back-reference                * *************************************************/
end_comment
begin_comment
comment|/* Normally, if a back reference hasn't been set, the length that is passed is negative, so the match always fails. However, in JavaScript compatibility mode, the length passed is zero. Note that in caseless UTF-8 mode, the number of subject bytes matched may be different to the number of reference bytes.  Arguments:   offset      index into the offset vector   eptr        pointer into the subject   length      length of reference to be matched (number of bytes)   md          points to match data block   caseless    TRUE if caseless  Returns:>= 0 the number of subject bytes matched               -1 no match               -2 partial match; always given if at end subject */
end_comment
begin_function
specifier|static
name|int
DECL|function|match_ref
name|match_ref
parameter_list|(
name|int
name|offset
parameter_list|,
specifier|register
name|PCRE_PUCHAR
name|eptr
parameter_list|,
name|int
name|length
parameter_list|,
name|match_data
modifier|*
name|md
parameter_list|,
name|BOOL
name|caseless
parameter_list|)
block|{
name|PCRE_PUCHAR
name|eptr_start
init|=
name|eptr
decl_stmt|;
specifier|register
name|PCRE_PUCHAR
name|p
init|=
name|md
operator|->
name|start_subject
operator|+
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
decl_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|SUPPORT_UCP
name|BOOL
name|utf
init|=
name|md
operator|->
name|utf
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCRE_DEBUG
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
name|printf
argument_list|(
literal|"matching subject<null>"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"matching subject "
argument_list|)
expr_stmt|;
name|pchars
argument_list|(
name|eptr
argument_list|,
name|length
argument_list|,
name|TRUE
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" against backref "
argument_list|)
expr_stmt|;
name|pchars
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|FALSE
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Always fail if reference not set (and not JavaScript compatible - in that case the length is passed as zero). */
if|if
condition|(
name|length
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Separate the caseless case for speed. In UTF-8 mode we can only do this properly if Unicode properties are supported. Otherwise, we can check only ASCII characters. */
if|if
condition|(
name|caseless
condition|)
block|{
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
name|defined
name|SUPPORT_UCP
if|if
condition|(
name|utf
condition|)
block|{
comment|/* Match characters up to the end of the reference. NOTE: the number of     data units matched may differ, because in UTF-8 there are some characters     whose upper and lower case versions code have different numbers of bytes.     For example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65     (3 bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a     sequence of two of the latter. It is important, therefore, to check the     length along the reference, not along the subject (earlier code did this     wrong). */
name|PCRE_PUCHAR
name|endptr
init|=
name|p
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|endptr
condition|)
block|{
name|pcre_uint32
name|c
decl_stmt|,
name|d
decl_stmt|;
specifier|const
name|ucd_record
modifier|*
name|ur
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
return|return
operator|-
literal|2
return|;
comment|/* Partial match */
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|GETCHARINC
argument_list|(
name|d
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ur
operator|=
name|GET_UCD
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|d
operator|&&
name|c
operator|!=
name|d
operator|+
name|ur
operator|->
name|other_case
condition|)
block|{
specifier|const
name|pcre_uint32
modifier|*
name|pp
init|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|ur
operator|->
name|caseset
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|pp
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|==
operator|*
name|pp
operator|++
condition|)
break|break;
block|}
block|}
block|}
block|}
else|else
endif|#
directive|endif
comment|/* The same code works when not in UTF-8 mode and in UTF-8 mode when there   is no UCP support. */
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
name|pcre_uint32
name|cc
decl_stmt|,
name|cp
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
return|return
operator|-
literal|2
return|;
comment|/* Partial match */
name|cc
operator|=
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|UCHAR21TEST
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TABLE_GET
argument_list|(
name|cp
argument_list|,
name|md
operator|->
name|lcc
argument_list|,
name|cp
argument_list|)
operator|!=
name|TABLE_GET
argument_list|(
name|cc
argument_list|,
name|md
operator|->
name|lcc
argument_list|,
name|cc
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|++
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* In the caseful case, we can just compare the bytes, whether or not we are in UTF-8 mode. */
else|else
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
return|return
operator|-
literal|2
return|;
comment|/* Partial match */
if|if
condition|(
name|UCHAR21INCTEST
argument_list|(
name|p
argument_list|)
operator|!=
name|UCHAR21INCTEST
argument_list|(
name|eptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|eptr
operator|-
name|eptr_start
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************** ****************************************************************************                    RECURSION IN THE match() FUNCTION  The match() function is highly recursive, though not every recursive call increases the recursive depth. Nevertheless, some regular expressions can cause it to recurse to a great depth. I was writing for Unix, so I just let it call itself recursively. This uses the stack for saving everything that has to be saved for a recursive call. On Unix, the stack can be large, and this works fine.  It turns out that on some non-Unix-like systems there are problems with programs that use a lot of stack. (This despite the fact that every last chip has oodles of memory these days, and techniques for extending the stack have been known for decades.) So....  There is a fudge, triggered by defining NO_RECURSE, which avoids recursive calls by keeping local variables that need to be preserved in blocks of memory obtained from malloc() instead instead of on the stack. Macros are used to achieve this so that the actual code doesn't look very different to what it always used to.  The original heap-recursive code used longjmp(). However, it seems that this can be very slow on some operating systems. Following a suggestion from Stan Switzer, the use of longjmp() has been abolished, at the cost of having to provide a unique number for each call to RMATCH. There is no way of generating a sequence of numbers at compile time in C. I have given them names, to make them stand out more clearly.  Crude tests on x86 Linux show a small speedup of around 5-8%. However, on FreeBSD, avoiding longjmp() more than halves the time taken to run the standard tests. Furthermore, not using longjmp() means that local dynamic variables don't have indeterminate values; this has meant that the frame size can be reduced because the result can be "passed back" by straight setting of the variable instead of being passed in the frame. **************************************************************************** ***************************************************************************/
end_comment
begin_comment
comment|/* Numbers for RMATCH calls. When this list is changed, the code at HEAP_RETURN below must be updated in sync.  */
end_comment
begin_enum
DECL|enumerator|RM1
DECL|enumerator|RM2
DECL|enumerator|RM3
DECL|enumerator|RM4
DECL|enumerator|RM5
DECL|enumerator|RM6
DECL|enumerator|RM7
DECL|enumerator|RM8
DECL|enumerator|RM9
DECL|enumerator|RM10
enum|enum
block|{
name|RM1
init|=
literal|1
block|,
name|RM2
block|,
name|RM3
block|,
name|RM4
block|,
name|RM5
block|,
name|RM6
block|,
name|RM7
block|,
name|RM8
block|,
name|RM9
block|,
name|RM10
block|,
DECL|enumerator|RM11
DECL|enumerator|RM12
DECL|enumerator|RM13
DECL|enumerator|RM14
DECL|enumerator|RM15
DECL|enumerator|RM16
DECL|enumerator|RM17
DECL|enumerator|RM18
DECL|enumerator|RM19
DECL|enumerator|RM20
name|RM11
block|,
name|RM12
block|,
name|RM13
block|,
name|RM14
block|,
name|RM15
block|,
name|RM16
block|,
name|RM17
block|,
name|RM18
block|,
name|RM19
block|,
name|RM20
block|,
DECL|enumerator|RM21
DECL|enumerator|RM22
DECL|enumerator|RM23
DECL|enumerator|RM24
DECL|enumerator|RM25
DECL|enumerator|RM26
DECL|enumerator|RM27
DECL|enumerator|RM28
DECL|enumerator|RM29
DECL|enumerator|RM30
name|RM21
block|,
name|RM22
block|,
name|RM23
block|,
name|RM24
block|,
name|RM25
block|,
name|RM26
block|,
name|RM27
block|,
name|RM28
block|,
name|RM29
block|,
name|RM30
block|,
DECL|enumerator|RM31
DECL|enumerator|RM32
DECL|enumerator|RM33
DECL|enumerator|RM34
DECL|enumerator|RM35
DECL|enumerator|RM36
DECL|enumerator|RM37
DECL|enumerator|RM38
DECL|enumerator|RM39
DECL|enumerator|RM40
name|RM31
block|,
name|RM32
block|,
name|RM33
block|,
name|RM34
block|,
name|RM35
block|,
name|RM36
block|,
name|RM37
block|,
name|RM38
block|,
name|RM39
block|,
name|RM40
block|,
DECL|enumerator|RM41
DECL|enumerator|RM42
DECL|enumerator|RM43
DECL|enumerator|RM44
DECL|enumerator|RM45
DECL|enumerator|RM46
DECL|enumerator|RM47
DECL|enumerator|RM48
DECL|enumerator|RM49
DECL|enumerator|RM50
name|RM41
block|,
name|RM42
block|,
name|RM43
block|,
name|RM44
block|,
name|RM45
block|,
name|RM46
block|,
name|RM47
block|,
name|RM48
block|,
name|RM49
block|,
name|RM50
block|,
DECL|enumerator|RM51
DECL|enumerator|RM52
DECL|enumerator|RM53
DECL|enumerator|RM54
DECL|enumerator|RM55
DECL|enumerator|RM56
DECL|enumerator|RM57
DECL|enumerator|RM58
DECL|enumerator|RM59
DECL|enumerator|RM60
name|RM51
block|,
name|RM52
block|,
name|RM53
block|,
name|RM54
block|,
name|RM55
block|,
name|RM56
block|,
name|RM57
block|,
name|RM58
block|,
name|RM59
block|,
name|RM60
block|,
DECL|enumerator|RM61
DECL|enumerator|RM62
DECL|enumerator|RM63
DECL|enumerator|RM64
DECL|enumerator|RM65
DECL|enumerator|RM66
DECL|enumerator|RM67
name|RM61
block|,
name|RM62
block|,
name|RM63
block|,
name|RM64
block|,
name|RM65
block|,
name|RM66
block|,
name|RM67
block|}
enum|;
end_enum
begin_comment
comment|/* These versions of the macros use the stack, as normal. There are debugging versions and production versions. Note that the "rw" argument of RMATCH isn't actually used in this definition. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_RECURSE
end_ifndef
begin_define
DECL|macro|REGISTER
define|#
directive|define
name|REGISTER
value|register
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_DEBUG
end_ifdef
begin_define
DECL|macro|RMATCH
define|#
directive|define
name|RMATCH
parameter_list|(
name|ra
parameter_list|,
name|rb
parameter_list|,
name|rc
parameter_list|,
name|rd
parameter_list|,
name|re
parameter_list|,
name|rw
parameter_list|)
define|\
value|{ \   printf("match() called in line %d\n", __LINE__); \   rrc = match(ra,rb,mstart,rc,rd,re,rdepth+1); \   printf("to line %d\n", __LINE__); \   }
end_define
begin_define
DECL|macro|RRETURN
define|#
directive|define
name|RRETURN
parameter_list|(
name|ra
parameter_list|)
define|\
value|{ \   printf("match() returned %d from line %d\n", ra, __LINE__); \   return ra; \   }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|RMATCH
define|#
directive|define
name|RMATCH
parameter_list|(
name|ra
parameter_list|,
name|rb
parameter_list|,
name|rc
parameter_list|,
name|rd
parameter_list|,
name|re
parameter_list|,
name|rw
parameter_list|)
define|\
value|rrc = match(ra,rb,mstart,rc,rd,re,rdepth+1)
end_define
begin_define
DECL|macro|RRETURN
define|#
directive|define
name|RRETURN
parameter_list|(
name|ra
parameter_list|)
value|return ra
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* These versions of the macros manage a private stack on the heap. Note that the "rd" argument of RMATCH isn't actually used in this definition. It's the md argument of match(), which never changes. */
end_comment
begin_define
DECL|macro|REGISTER
define|#
directive|define
name|REGISTER
end_define
begin_define
DECL|macro|RMATCH
define|#
directive|define
name|RMATCH
parameter_list|(
name|ra
parameter_list|,
name|rb
parameter_list|,
name|rc
parameter_list|,
name|rd
parameter_list|,
name|re
parameter_list|,
name|rw
parameter_list|)
define|\
value|{\   heapframe *newframe = frame->Xnextframe;\   if (newframe == NULL)\     {\     newframe = (heapframe *)(PUBL(stack_malloc))(sizeof(heapframe));\     if (newframe == NULL) RRETURN(PCRE_ERROR_NOMEMORY);\     newframe->Xnextframe = NULL;\     frame->Xnextframe = newframe;\     }\   frame->Xwhere = rw;\   newframe->Xeptr = ra;\   newframe->Xecode = rb;\   newframe->Xmstart = mstart;\   newframe->Xoffset_top = rc;\   newframe->Xeptrb = re;\   newframe->Xrdepth = frame->Xrdepth + 1;\   newframe->Xprevframe = frame;\   frame = newframe;\   DPRINTF(("restarting from line %d\n", __LINE__));\   goto HEAP_RECURSE;\   L_##rw:\   DPRINTF(("jumped back to line %d\n", __LINE__));\   }
end_define
begin_define
DECL|macro|RRETURN
define|#
directive|define
name|RRETURN
parameter_list|(
name|ra
parameter_list|)
define|\
value|{\   heapframe *oldframe = frame;\   frame = oldframe->Xprevframe;\   if (frame != NULL)\     {\     rrc = ra;\     goto HEAP_RETURN;\     }\   return ra;\   }
end_define
begin_comment
comment|/* Structure for remembering the local variables in a private frame */
end_comment
begin_typedef
DECL|struct|heapframe
typedef|typedef
struct|struct
name|heapframe
block|{
DECL|member|Xprevframe
name|struct
name|heapframe
modifier|*
name|Xprevframe
decl_stmt|;
DECL|member|Xnextframe
name|struct
name|heapframe
modifier|*
name|Xnextframe
decl_stmt|;
comment|/* Function arguments that may change */
DECL|member|Xeptr
name|PCRE_PUCHAR
name|Xeptr
decl_stmt|;
DECL|member|Xecode
specifier|const
name|pcre_uchar
modifier|*
name|Xecode
decl_stmt|;
DECL|member|Xmstart
name|PCRE_PUCHAR
name|Xmstart
decl_stmt|;
DECL|member|Xoffset_top
name|int
name|Xoffset_top
decl_stmt|;
DECL|member|Xeptrb
name|eptrblock
modifier|*
name|Xeptrb
decl_stmt|;
DECL|member|Xrdepth
name|unsigned
name|int
name|Xrdepth
decl_stmt|;
comment|/* Function local variables */
DECL|member|Xcallpat
name|PCRE_PUCHAR
name|Xcallpat
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
DECL|member|Xcharptr
name|PCRE_PUCHAR
name|Xcharptr
decl_stmt|;
endif|#
directive|endif
DECL|member|Xdata
name|PCRE_PUCHAR
name|Xdata
decl_stmt|;
DECL|member|Xnext
name|PCRE_PUCHAR
name|Xnext
decl_stmt|;
DECL|member|Xpp
name|PCRE_PUCHAR
name|Xpp
decl_stmt|;
DECL|member|Xprev
name|PCRE_PUCHAR
name|Xprev
decl_stmt|;
DECL|member|Xsaved_eptr
name|PCRE_PUCHAR
name|Xsaved_eptr
decl_stmt|;
DECL|member|Xnew_recursive
name|recursion_info
name|Xnew_recursive
decl_stmt|;
DECL|member|Xcur_is_word
name|BOOL
name|Xcur_is_word
decl_stmt|;
DECL|member|Xcondition
name|BOOL
name|Xcondition
decl_stmt|;
DECL|member|Xprev_is_word
name|BOOL
name|Xprev_is_word
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
DECL|member|Xprop_type
name|int
name|Xprop_type
decl_stmt|;
DECL|member|Xprop_value
name|unsigned
name|int
name|Xprop_value
decl_stmt|;
DECL|member|Xprop_fail_result
name|int
name|Xprop_fail_result
decl_stmt|;
DECL|member|Xoclength
name|int
name|Xoclength
decl_stmt|;
DECL|member|Xocchars
name|pcre_uchar
name|Xocchars
index|[
literal|6
index|]
decl_stmt|;
endif|#
directive|endif
DECL|member|Xcodelink
name|int
name|Xcodelink
decl_stmt|;
DECL|member|Xctype
name|int
name|Xctype
decl_stmt|;
DECL|member|Xfc
name|unsigned
name|int
name|Xfc
decl_stmt|;
DECL|member|Xfi
name|int
name|Xfi
decl_stmt|;
DECL|member|Xlength
name|int
name|Xlength
decl_stmt|;
DECL|member|Xmax
name|int
name|Xmax
decl_stmt|;
DECL|member|Xmin
name|int
name|Xmin
decl_stmt|;
DECL|member|Xnumber
name|unsigned
name|int
name|Xnumber
decl_stmt|;
DECL|member|Xoffset
name|int
name|Xoffset
decl_stmt|;
DECL|member|Xop
name|unsigned
name|int
name|Xop
decl_stmt|;
DECL|member|Xsave_capture_last
name|pcre_int32
name|Xsave_capture_last
decl_stmt|;
DECL|member|Xsave_offset1
DECL|member|Xsave_offset2
DECL|member|Xsave_offset3
name|int
name|Xsave_offset1
decl_stmt|,
name|Xsave_offset2
decl_stmt|,
name|Xsave_offset3
decl_stmt|;
DECL|member|Xstacksave
name|int
name|Xstacksave
index|[
name|REC_STACK_SAVE_MAX
index|]
decl_stmt|;
DECL|member|Xnewptrb
name|eptrblock
name|Xnewptrb
decl_stmt|;
comment|/* Where to jump back to */
DECL|member|Xwhere
name|int
name|Xwhere
decl_stmt|;
block|}
DECL|typedef|heapframe
name|heapframe
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************** ***************************************************************************/
end_comment
begin_comment
comment|/************************************************* *         Match from current position            * *************************************************/
end_comment
begin_comment
comment|/* This function is called recursively in many circumstances. Whenever it returns a negative (error) response, the outer incarnation must also return the same response. */
end_comment
begin_comment
comment|/* These macros pack up tests that are used for partial matching, and which appear several times in the code. We set the "hit end" flag if the pointer is at the end of the subject and also past the start of the subject (i.e. something has been matched). For hard partial matching, we then return immediately. The second one is used when we already know we are past the end of the subject. */
end_comment
begin_define
DECL|macro|CHECK_PARTIAL
define|#
directive|define
name|CHECK_PARTIAL
parameter_list|()
define|\
value|if (md->partial != 0&& eptr>= md->end_subject&& \       eptr> md->start_used_ptr) \     { \     md->hitend = TRUE; \     if (md->partial> 1) RRETURN(PCRE_ERROR_PARTIAL); \     }
end_define
begin_define
DECL|macro|SCHECK_PARTIAL
define|#
directive|define
name|SCHECK_PARTIAL
parameter_list|()
define|\
value|if (md->partial != 0&& eptr> md->start_used_ptr) \     { \     md->hitend = TRUE; \     if (md->partial> 1) RRETURN(PCRE_ERROR_PARTIAL); \     }
end_define
begin_comment
comment|/* Performance note: It might be tempting to extract commonly used fields from the md structure (e.g. utf, end_subject) into individual variables to improve performance. Tests using gcc on a SPARC disproved this; in the first case, it made performance worse.  Arguments:    eptr        pointer to current character in subject    ecode       pointer to current position in compiled code    mstart      pointer to the current match start position (can be modified                  by encountering \K)    offset_top  current top pointer    md          pointer to "static" info for the match    eptrb       pointer to chain of blocks containing eptr at start of                  brackets - for testing for empty matches    rdepth      the recursion depth  Returns:       MATCH_MATCH if matched            )  these values are>= 0                MATCH_NOMATCH if failed to match  )                a negative MATCH_xxx value for PRUNE, SKIP, etc                a negative PCRE_ERROR_xxx value if aborted by an error condition                  (e.g. stopped by repeated call or recursion limit) */
end_comment
begin_function
specifier|static
name|int
DECL|function|match
name|match
parameter_list|(
name|REGISTER
name|PCRE_PUCHAR
name|eptr
parameter_list|,
name|REGISTER
specifier|const
name|pcre_uchar
modifier|*
name|ecode
parameter_list|,
name|PCRE_PUCHAR
name|mstart
parameter_list|,
name|int
name|offset_top
parameter_list|,
name|match_data
modifier|*
name|md
parameter_list|,
name|eptrblock
modifier|*
name|eptrb
parameter_list|,
name|unsigned
name|int
name|rdepth
parameter_list|)
block|{
comment|/* These variables do not need to be preserved over recursion in this function, so they can be ordinary variables in all cases. Mark some of them with "register" because they are used a lot in loops. */
specifier|register
name|int
name|rrc
decl_stmt|;
comment|/* Returns from recursive calls */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Used for loops not involving calls to RMATCH() */
specifier|register
name|pcre_uint32
name|c
decl_stmt|;
comment|/* Character values not kept over RMATCH() calls */
specifier|register
name|BOOL
name|utf
decl_stmt|;
comment|/* Local copy of UTF flag for speed */
name|BOOL
name|minimize
decl_stmt|,
name|possessive
decl_stmt|;
comment|/* Quantifier options */
name|BOOL
name|caseless
decl_stmt|;
name|int
name|condcode
decl_stmt|;
comment|/* When recursion is not being used, all "local" variables that have to be preserved over calls to RMATCH() are part of a "frame". We set up the top-level frame on the stack here; subsequent instantiations are obtained from the heap whenever RMATCH() does a "recursion". See the macro definitions above. Putting the top-level on the stack rather than malloc-ing them all gives a performance boost in many cases where there is not much "recursion". */
ifdef|#
directive|ifdef
name|NO_RECURSE
name|heapframe
modifier|*
name|frame
init|=
operator|(
name|heapframe
operator|*
operator|)
name|md
operator|->
name|match_frames_base
decl_stmt|;
comment|/* Copy in the original argument variables */
name|frame
operator|->
name|Xeptr
operator|=
name|eptr
expr_stmt|;
name|frame
operator|->
name|Xecode
operator|=
name|ecode
expr_stmt|;
name|frame
operator|->
name|Xmstart
operator|=
name|mstart
expr_stmt|;
name|frame
operator|->
name|Xoffset_top
operator|=
name|offset_top
expr_stmt|;
name|frame
operator|->
name|Xeptrb
operator|=
name|eptrb
expr_stmt|;
name|frame
operator|->
name|Xrdepth
operator|=
name|rdepth
expr_stmt|;
comment|/* This is where control jumps back to to effect "recursion" */
name|HEAP_RECURSE
label|:
comment|/* Macros make the argument variables come from the current frame */
DECL|macro|eptr
define|#
directive|define
name|eptr
value|frame->Xeptr
DECL|macro|ecode
define|#
directive|define
name|ecode
value|frame->Xecode
DECL|macro|mstart
define|#
directive|define
name|mstart
value|frame->Xmstart
DECL|macro|offset_top
define|#
directive|define
name|offset_top
value|frame->Xoffset_top
DECL|macro|eptrb
define|#
directive|define
name|eptrb
value|frame->Xeptrb
DECL|macro|rdepth
define|#
directive|define
name|rdepth
value|frame->Xrdepth
comment|/* Ditto for the local variables */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
DECL|macro|charptr
define|#
directive|define
name|charptr
value|frame->Xcharptr
endif|#
directive|endif
DECL|macro|callpat
define|#
directive|define
name|callpat
value|frame->Xcallpat
DECL|macro|codelink
define|#
directive|define
name|codelink
value|frame->Xcodelink
DECL|macro|data
define|#
directive|define
name|data
value|frame->Xdata
DECL|macro|next
define|#
directive|define
name|next
value|frame->Xnext
DECL|macro|pp
define|#
directive|define
name|pp
value|frame->Xpp
DECL|macro|prev
define|#
directive|define
name|prev
value|frame->Xprev
DECL|macro|saved_eptr
define|#
directive|define
name|saved_eptr
value|frame->Xsaved_eptr
DECL|macro|new_recursive
define|#
directive|define
name|new_recursive
value|frame->Xnew_recursive
DECL|macro|cur_is_word
define|#
directive|define
name|cur_is_word
value|frame->Xcur_is_word
DECL|macro|condition
define|#
directive|define
name|condition
value|frame->Xcondition
DECL|macro|prev_is_word
define|#
directive|define
name|prev_is_word
value|frame->Xprev_is_word
ifdef|#
directive|ifdef
name|SUPPORT_UCP
DECL|macro|prop_type
define|#
directive|define
name|prop_type
value|frame->Xprop_type
DECL|macro|prop_value
define|#
directive|define
name|prop_value
value|frame->Xprop_value
DECL|macro|prop_fail_result
define|#
directive|define
name|prop_fail_result
value|frame->Xprop_fail_result
DECL|macro|oclength
define|#
directive|define
name|oclength
value|frame->Xoclength
DECL|macro|occhars
define|#
directive|define
name|occhars
value|frame->Xocchars
endif|#
directive|endif
DECL|macro|ctype
define|#
directive|define
name|ctype
value|frame->Xctype
DECL|macro|fc
define|#
directive|define
name|fc
value|frame->Xfc
DECL|macro|fi
define|#
directive|define
name|fi
value|frame->Xfi
DECL|macro|length
define|#
directive|define
name|length
value|frame->Xlength
DECL|macro|max
define|#
directive|define
name|max
value|frame->Xmax
DECL|macro|min
define|#
directive|define
name|min
value|frame->Xmin
DECL|macro|number
define|#
directive|define
name|number
value|frame->Xnumber
DECL|macro|offset
define|#
directive|define
name|offset
value|frame->Xoffset
DECL|macro|op
define|#
directive|define
name|op
value|frame->Xop
DECL|macro|save_capture_last
define|#
directive|define
name|save_capture_last
value|frame->Xsave_capture_last
DECL|macro|save_offset1
define|#
directive|define
name|save_offset1
value|frame->Xsave_offset1
DECL|macro|save_offset2
define|#
directive|define
name|save_offset2
value|frame->Xsave_offset2
DECL|macro|save_offset3
define|#
directive|define
name|save_offset3
value|frame->Xsave_offset3
DECL|macro|stacksave
define|#
directive|define
name|stacksave
value|frame->Xstacksave
DECL|macro|newptrb
define|#
directive|define
name|newptrb
value|frame->Xnewptrb
comment|/* When recursion is being used, local variables are allocated on the stack and get preserved during recursion in the normal way. In this environment, fi and i, and fc and c, can be the same variables. */
else|#
directive|else
comment|/* NO_RECURSE not defined */
define|#
directive|define
name|fi
value|i
define|#
directive|define
name|fc
value|c
comment|/* Many of the following variables are used only in small blocks of the code. My normal style of coding would have declared them within each of those blocks. However, in order to accommodate the version of this code that uses an external "stack" implemented on the heap, it is easier to declare them all here, so the declarations can be cut out in a block. The only declarations within blocks below are for variables that do not have to be preserved over a recursive call to RMATCH(). */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
specifier|const
name|pcre_uchar
modifier|*
name|charptr
decl_stmt|;
endif|#
directive|endif
specifier|const
name|pcre_uchar
modifier|*
name|callpat
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|data
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|next
decl_stmt|;
name|PCRE_PUCHAR
name|pp
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|prev
decl_stmt|;
name|PCRE_PUCHAR
name|saved_eptr
decl_stmt|;
name|recursion_info
name|new_recursive
decl_stmt|;
name|BOOL
name|cur_is_word
decl_stmt|;
name|BOOL
name|condition
decl_stmt|;
name|BOOL
name|prev_is_word
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|int
name|prop_type
decl_stmt|;
name|unsigned
name|int
name|prop_value
decl_stmt|;
name|int
name|prop_fail_result
decl_stmt|;
name|int
name|oclength
decl_stmt|;
name|pcre_uchar
name|occhars
index|[
literal|6
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|codelink
decl_stmt|;
name|int
name|ctype
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|min
decl_stmt|;
name|unsigned
name|int
name|number
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|op
decl_stmt|;
name|pcre_int32
name|save_capture_last
decl_stmt|;
name|int
name|save_offset1
decl_stmt|,
name|save_offset2
decl_stmt|,
name|save_offset3
decl_stmt|;
name|int
name|stacksave
index|[
name|REC_STACK_SAVE_MAX
index|]
decl_stmt|;
name|eptrblock
name|newptrb
decl_stmt|;
comment|/* There is a special fudge for calling match() in a way that causes it to measure the size of its basic stack frame when the stack is being used for recursion. The second argument (ecode) being NULL triggers this behaviour. It cannot normally ever be NULL. The return is the negated value of the frame size. */
if|if
condition|(
name|ecode
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rdepth
operator|==
literal|0
condition|)
return|return
name|match
argument_list|(
operator|(
name|PCRE_PUCHAR
operator|)
operator|&
name|rdepth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
return|;
else|else
block|{
name|int
name|len
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rdepth
operator|-
operator|(
name|char
operator|*
operator|)
name|eptr
decl_stmt|;
return|return
operator|(
name|len
operator|>
literal|0
operator|)
condition|?
operator|-
name|len
else|:
name|len
return|;
block|}
block|}
endif|#
directive|endif
comment|/* NO_RECURSE */
comment|/* To save space on the stack and in the heap frame, I have doubled up on some of the local variables that are used only in localised parts of the code, but still need to be preserved over recursive calls of match(). These macros define the alternative names that are used. */
DECL|macro|allow_zero
define|#
directive|define
name|allow_zero
value|cur_is_word
DECL|macro|cbegroup
define|#
directive|define
name|cbegroup
value|condition
DECL|macro|code_offset
define|#
directive|define
name|code_offset
value|codelink
DECL|macro|condassert
define|#
directive|define
name|condassert
value|condition
DECL|macro|matched_once
define|#
directive|define
name|matched_once
value|prev_is_word
DECL|macro|foc
define|#
directive|define
name|foc
value|number
DECL|macro|save_mark
define|#
directive|define
name|save_mark
value|data
comment|/* These statements are here to stop the compiler complaining about unitialized variables. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|prop_value
operator|=
literal|0
expr_stmt|;
name|prop_fail_result
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* This label is used for tail recursion, which is used in a few cases even when NO_RECURSE is not defined, in order to reduce the amount of stack that is used. Thanks to Ian Taylor for noticing this possibility and sending the original patch. */
name|TAIL_RECURSE
label|:
comment|/* OK, now we can get on with the real code of the function. Recursive calls are specified by the macro RMATCH and RRETURN is used to return. When NO_RECURSE is *not* defined, these just turn into a recursive call to match() and a "return", respectively (possibly with some debugging if PCRE_DEBUG is defined). However, RMATCH isn't like a function call because it's quite a complicated macro. It has to be used in one particular way. This shouldn't, however, impact performance when true recursion is being used. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|utf
operator|=
name|md
operator|->
name|utf
expr_stmt|;
comment|/* Local copy of the flag */
else|#
directive|else
name|utf
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* First check that we haven't called match() too many times, or that we haven't exceeded the recursive call limit. */
if|if
condition|(
name|md
operator|->
name|match_call_count
operator|++
operator|>=
name|md
operator|->
name|match_limit
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_MATCHLIMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdepth
operator|>=
name|md
operator|->
name|match_limit_recursion
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_RECURSIONLIMIT
argument_list|)
expr_stmt|;
comment|/* At the start of a group with an unlimited repeat that may match an empty string, the variable md->match_function_type is set to MATCH_CBEGROUP. It is done this way to save having to use another function argument, which would take up space on the stack. See also MATCH_CONDASSERT below.  When MATCH_CBEGROUP is set, add the current subject pointer to the chain of such remembered pointers, to be checked when we hit the closing ket, in order to break infinite loops that match no characters. When match() is called in other circumstances, don't add to the chain. The MATCH_CBEGROUP feature must NOT be used with tail recursion, because the memory block that is used is on the stack, so a new one may be required for each match(). */
if|if
condition|(
name|md
operator|->
name|match_function_type
operator|==
name|MATCH_CBEGROUP
condition|)
block|{
name|newptrb
operator|.
name|epb_saved_eptr
operator|=
name|eptr
expr_stmt|;
name|newptrb
operator|.
name|epb_prev
operator|=
name|eptrb
expr_stmt|;
name|eptrb
operator|=
operator|&
name|newptrb
expr_stmt|;
name|md
operator|->
name|match_function_type
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now start processing the opcodes. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|minimize
operator|=
name|possessive
operator|=
name|FALSE
expr_stmt|;
name|op
operator|=
operator|*
name|ecode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_MARK
case|:
name|md
operator|->
name|nomatch_mark
operator|=
name|ecode
operator|+
literal|2
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* In case previously set by assertion */
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
operator|+
name|ecode
index|[
literal|1
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM55
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rrc
operator|==
name|MATCH_MATCH
operator|||
name|rrc
operator|==
name|MATCH_ACCEPT
operator|)
operator|&&
name|md
operator|->
name|mark
operator|==
name|NULL
condition|)
name|md
operator|->
name|mark
operator|=
name|ecode
operator|+
literal|2
expr_stmt|;
comment|/* A return of MATCH_SKIP_ARG means that matching failed at SKIP with an     argument, and we must check whether that argument matches this MARK's     argument. It is passed back in md->start_match_ptr (an overloading of that     variable). If it does match, we reset that variable to the current subject     position and return MATCH_SKIP. Otherwise, pass back the return code     unaltered. */
elseif|else
if|if
condition|(
name|rrc
operator|==
name|MATCH_SKIP_ARG
operator|&&
name|STRCMP_UC_UC_TEST
argument_list|(
name|ecode
operator|+
literal|2
argument_list|,
name|md
operator|->
name|start_match_ptr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|->
name|start_match_ptr
operator|=
name|eptr
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_SKIP
argument_list|)
expr_stmt|;
block|}
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
case|case
name|OP_FAIL
case|:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
case|case
name|OP_COMMIT
case|:
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM52
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_COMMIT
argument_list|)
expr_stmt|;
case|case
name|OP_PRUNE
case|:
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM51
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_PRUNE
argument_list|)
expr_stmt|;
case|case
name|OP_PRUNE_ARG
case|:
name|md
operator|->
name|nomatch_mark
operator|=
name|ecode
operator|+
literal|2
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* In case previously set by assertion */
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
operator|+
name|ecode
index|[
literal|1
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM56
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rrc
operator|==
name|MATCH_MATCH
operator|||
name|rrc
operator|==
name|MATCH_ACCEPT
operator|)
operator|&&
name|md
operator|->
name|mark
operator|==
name|NULL
condition|)
name|md
operator|->
name|mark
operator|=
name|ecode
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_PRUNE
argument_list|)
expr_stmt|;
case|case
name|OP_SKIP
case|:
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM53
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|start_match_ptr
operator|=
name|eptr
expr_stmt|;
comment|/* Pass back current position */
name|RRETURN
argument_list|(
name|MATCH_SKIP
argument_list|)
expr_stmt|;
comment|/* Note that, for Perl compatibility, SKIP with an argument does NOT set     nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was     not a matching mark, we have to re-run the match, ignoring the SKIP_ARG     that failed and any that precede it (either they also failed, or were not     triggered). To do this, we maintain a count of executed SKIP_ARGs. If a     SKIP_ARG gets to top level, the match is re-run with md->ignore_skip_arg     set to the count of the one that failed. */
case|case
name|OP_SKIP_ARG
case|:
name|md
operator|->
name|skip_arg_count
operator|++
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|skip_arg_count
operator|<=
name|md
operator|->
name|ignore_skip_arg
condition|)
block|{
name|ecode
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
operator|+
name|ecode
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
operator|+
name|ecode
index|[
literal|1
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM57
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
comment|/* Pass back the current skip name by overloading md->start_match_ptr and     returning the special MATCH_SKIP_ARG return code. This will either be     caught by a matching MARK, or get to the top, where it causes a rematch     with md->ignore_skip_arg set to the value of md->skip_arg_count. */
name|md
operator|->
name|start_match_ptr
operator|=
name|ecode
operator|+
literal|2
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_SKIP_ARG
argument_list|)
expr_stmt|;
comment|/* For THEN (and THEN_ARG) we pass back the address of the opcode, so that     the branch in which it occurs can be determined. Overload the start of     match pointer to do this. */
case|case
name|OP_THEN
case|:
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM54
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|start_match_ptr
operator|=
name|ecode
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_THEN
argument_list|)
expr_stmt|;
case|case
name|OP_THEN_ARG
case|:
name|md
operator|->
name|nomatch_mark
operator|=
name|ecode
operator|+
literal|2
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* In case previously set by assertion */
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
operator|+
name|ecode
index|[
literal|1
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM58
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rrc
operator|==
name|MATCH_MATCH
operator|||
name|rrc
operator|==
name|MATCH_ACCEPT
operator|)
operator|&&
name|md
operator|->
name|mark
operator|==
name|NULL
condition|)
name|md
operator|->
name|mark
operator|=
name|ecode
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|start_match_ptr
operator|=
name|ecode
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_THEN
argument_list|)
expr_stmt|;
comment|/* Handle an atomic group that does not contain any capturing parentheses.     This can be handled like an assertion. Prior to 8.13, all atomic groups     were handled this way. In 8.13, the code was changed as below for ONCE, so     that backups pass through the group and thereby reset captured values.     However, this uses a lot more stack, so in 8.20, atomic groups that do not     contain any captures generate OP_ONCE_NC, which can be handled in the old,     less stack intensive way.      Check the alternative branches in turn - the matching won't pass the KET     for this kind of subpattern. If any one branch matches, we carry on as at     the end of a normal bracket, leaving the subject pointer, but resetting     the start-of-match value in case it was changed by \K. */
case|case
name|OP_ONCE_NC
case|:
name|prev
operator|=
name|ecode
expr_stmt|;
name|saved_eptr
operator|=
name|eptr
expr_stmt|;
name|save_mark
operator|=
name|md
operator|->
name|mark
expr_stmt|;
do|do
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM64
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|==
name|MATCH_MATCH
condition|)
comment|/* Note: _not_ MATCH_ACCEPT */
block|{
name|mstart
operator|=
name|md
operator|->
name|start_match_ptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rrc
operator|==
name|MATCH_THEN
condition|)
block|{
name|next
operator|=
name|ecode
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|<
name|next
operator|&&
operator|(
operator|*
name|ecode
operator|==
name|OP_ALT
operator|||
operator|*
name|next
operator|==
name|OP_ALT
operator|)
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
block|}
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|save_mark
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
comment|/* If hit the end of the group (which could be repeated), fail */
if|if
condition|(
operator|*
name|ecode
operator|!=
name|OP_ONCE_NC
operator|&&
operator|*
name|ecode
operator|!=
name|OP_ALT
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Continue as from after the group, updating the offsets high water     mark, since extracts may have been taken. */
do|do
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
name|offset_top
operator|=
name|md
operator|->
name|end_offset_top
expr_stmt|;
name|eptr
operator|=
name|md
operator|->
name|end_match_ptr
expr_stmt|;
comment|/* For a non-repeating ket, just continue at this level. This also     happens for a repeating ket if no characters were matched in the group.     This is the forcible breaking of infinite loops as implemented in Perl     5.005. */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_KET
operator|||
name|eptr
operator|==
name|saved_eptr
condition|)
block|{
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
block|}
comment|/* The repeating kets try the rest of the pattern or restart from the     preceding bracket, in the appropriate order. The second "call" of match()     uses tail recursion, to avoid using another stack frame. */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_KETRMIN
condition|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM65
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|ecode
operator|=
name|prev
expr_stmt|;
goto|goto
name|TAIL_RECURSE
goto|;
block|}
else|else
comment|/* OP_KETRMAX */
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|prev
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM66
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
goto|goto
name|TAIL_RECURSE
goto|;
block|}
comment|/* Control never gets here */
comment|/* Handle a capturing bracket, other than those that are possessive with an     unlimited repeat. If there is space in the offset vector, save the current     subject position in the working slot at the top of the vector. We mustn't     change the current values of the data slot, because they may be set from a     previous iteration of this group, and be referred to by a reference inside     the group. A failure to match might occur after the group has succeeded,     if something later on doesn't match. For this reason, we need to restore     the working value and also the values of the final offsets, in case they     were set by a previous iteration of the same bracket.      If there isn't enough space in the offset vector, treat this as if it were     a non-capturing bracket. Don't worry about setting the flag for the error     case here; that is handled in the code for KET. */
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
name|number
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|number
operator|<<
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|printf
argument_list|(
literal|"start bracket %d\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"subject="
argument_list|)
expr_stmt|;
name|pchars
argument_list|(
name|eptr
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|<
name|md
operator|->
name|offset_max
condition|)
block|{
name|save_offset1
operator|=
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
expr_stmt|;
name|save_offset2
operator|=
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
name|save_offset3
operator|=
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
expr_stmt|;
name|save_capture_last
operator|=
name|md
operator|->
name|capture_last
expr_stmt|;
name|save_mark
operator|=
name|md
operator|->
name|mark
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"saving %d %d %d\n"
operator|,
name|save_offset1
operator|,
name|save_offset2
operator|,
name|save_offset3
operator|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|eptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|op
operator|>=
name|OP_SBRA
condition|)
name|md
operator|->
name|match_function_type
operator|=
name|MATCH_CBEGROUP
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|==
name|MATCH_ONCE
condition|)
break|break;
comment|/* Backing up through an atomic group */
comment|/* If we backed up to a THEN, check whether it is within the current         branch by comparing the address of the THEN that is passed back with         the end of the branch. If it is within the current branch, and the         branch is one of two or more alternatives (it either starts or ends         with OP_ALT), we have reached the limit of THEN's action, so convert         the return code to NOMATCH, which will cause normal backtracking to         happen from now on. Otherwise, THEN is passed back to an outer         alternative. This implements Perl's treatment of parenthesized groups,         where a group not containing | does not affect the current alternative,         that is, (X) is NOT the same as (X|(*F)). */
if|if
condition|(
name|rrc
operator|==
name|MATCH_THEN
condition|)
block|{
name|next
operator|=
name|ecode
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|<
name|next
operator|&&
operator|(
operator|*
name|ecode
operator|==
name|OP_ALT
operator|||
operator|*
name|next
operator|==
name|OP_ALT
operator|)
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
block|}
comment|/* Anything other than NOMATCH is passed back. */
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|capture_last
operator|=
name|save_capture_last
expr_stmt|;
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|save_mark
expr_stmt|;
if|if
condition|(
operator|*
name|ecode
operator|!=
name|OP_ALT
condition|)
break|break;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"bracket %d failed\n"
operator|,
name|number
operator|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|=
name|save_offset1
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|save_offset2
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
operator|=
name|save_offset3
expr_stmt|;
comment|/* At this point, rrc will be one of MATCH_ONCE or MATCH_NOMATCH. */
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH ... Insufficient room for saving captured contents. Treat     as a non-capturing bracket. */
comment|/* VVVVVVVVVVVVVVVVVVVVVVVVV */
comment|/* VVVVVVVVVVVVVVVVVVVVVVVVV */
name|DPRINTF
argument_list|(
operator|(
literal|"insufficient capture room: treat as non-capturing\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* VVVVVVVVVVVVVVVVVVVVVVVVV */
comment|/* VVVVVVVVVVVVVVVVVVVVVVVVV */
comment|/* Non-capturing or atomic group, except for possessive with unlimited     repeat and ONCE group with no captures. Loop for all the alternatives.      When we get to the final alternative within the brackets, we used to return     the result of a recursive call to match() whatever happened so it was     possible to reduce stack usage by turning this into a tail recursion,     except in the case of a possibly empty group. However, now that there is     the possiblity of (*THEN) occurring in the final alternative, this     optimization is no longer always possible.      We can optimize if we know there are no (*THEN)s in the pattern; at present     this is the best that can be done.      MATCH_ONCE is returned when the end of an atomic group is successfully     reached, but subsequent matching fails. It passes back up the tree (causing     captured values to be reset) until the original atomic group level is     reached. This is tested by comparing md->once_target with the start of the     group. At this point, the return is converted into MATCH_NOMATCH so that     previous backup points can be taken. */
case|case
name|OP_ONCE
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_SBRA
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"start non-capturing bracket\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|op
operator|>=
name|OP_SBRA
operator|||
name|op
operator|==
name|OP_ONCE
condition|)
name|md
operator|->
name|match_function_type
operator|=
name|MATCH_CBEGROUP
expr_stmt|;
comment|/* If this is not a possibly empty group, and there are no (*THEN)s in       the pattern, and this is the final alternative, optimize as described       above. */
elseif|else
if|if
condition|(
operator|!
name|md
operator|->
name|hasthen
operator|&&
name|ecode
index|[
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
index|]
operator|!=
name|OP_ALT
condition|)
block|{
name|ecode
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
expr_stmt|;
goto|goto
name|TAIL_RECURSE
goto|;
block|}
comment|/* In all other cases, we have to make another call to match(). */
name|save_mark
operator|=
name|md
operator|->
name|mark
expr_stmt|;
name|save_capture_last
operator|=
name|md
operator|->
name|capture_last
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM2
argument_list|)
expr_stmt|;
comment|/* See comment in the code for capturing groups above about handling       THEN. */
if|if
condition|(
name|rrc
operator|==
name|MATCH_THEN
condition|)
block|{
name|next
operator|=
name|ecode
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|<
name|next
operator|&&
operator|(
operator|*
name|ecode
operator|==
name|OP_ALT
operator|||
operator|*
name|next
operator|==
name|OP_ALT
operator|)
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
block|}
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
block|{
if|if
condition|(
name|rrc
operator|==
name|MATCH_ONCE
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|scode
init|=
name|ecode
decl_stmt|;
if|if
condition|(
operator|*
name|scode
operator|!=
name|OP_ONCE
condition|)
comment|/* If not at start, find it */
block|{
while|while
condition|(
operator|*
name|scode
operator|==
name|OP_ALT
condition|)
name|scode
operator|+=
name|GET
argument_list|(
name|scode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scode
operator|-=
name|GET
argument_list|(
name|scode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|->
name|once_target
operator|==
name|scode
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
block|}
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|save_mark
expr_stmt|;
if|if
condition|(
operator|*
name|ecode
operator|!=
name|OP_ALT
condition|)
break|break;
name|md
operator|->
name|capture_last
operator|=
name|save_capture_last
expr_stmt|;
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Handle possessive capturing brackets with an unlimited repeat. We come     here from BRAZERO with allow_zero set TRUE. The offset_vector values are     handled similarly to the normal case above. However, the matching is     different. The end of these brackets will always be OP_KETRPOS, which     returns MATCH_KETRPOS without going further in the pattern. By this means     we can handle the group by iteration rather than recursion, thereby     reducing the amount of stack needed. */
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
name|allow_zero
operator|=
name|FALSE
expr_stmt|;
name|POSSESSIVE_CAPTURE
label|:
name|number
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|number
operator|<<
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|printf
argument_list|(
literal|"start possessive bracket %d\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"subject="
argument_list|)
expr_stmt|;
name|pchars
argument_list|(
name|eptr
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|>=
name|md
operator|->
name|offset_max
condition|)
goto|goto
name|POSSESSIVE_NON_CAPTURE
goto|;
name|matched_once
operator|=
name|FALSE
expr_stmt|;
name|code_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|ecode
operator|-
name|md
operator|->
name|start_code
argument_list|)
expr_stmt|;
name|save_offset1
operator|=
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
expr_stmt|;
name|save_offset2
operator|=
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
name|save_offset3
operator|=
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
expr_stmt|;
name|save_capture_last
operator|=
name|md
operator|->
name|capture_last
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"saving %d %d %d\n"
operator|,
name|save_offset1
operator|,
name|save_offset2
operator|,
name|save_offset3
operator|)
argument_list|)
expr_stmt|;
comment|/* Each time round the loop, save the current subject position for use     when the group matches. For MATCH_MATCH, the group has matched, so we     restart it with a new subject starting position, remembering that we had     at least one match. For MATCH_NOMATCH, carry on with the alternatives, as     usual. If we haven't matched any alternatives in any iteration, check to     see if a previous iteration matched. If so, the group has matched;     continue from afterwards. Otherwise it has failed; restore the previous     capture values before returning NOMATCH. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|eptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|OP_SBRA
condition|)
name|md
operator|->
name|match_function_type
operator|=
name|MATCH_CBEGROUP
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM63
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|==
name|MATCH_KETRPOS
condition|)
block|{
name|offset_top
operator|=
name|md
operator|->
name|end_offset_top
expr_stmt|;
name|ecode
operator|=
name|md
operator|->
name|start_code
operator|+
name|code_offset
expr_stmt|;
name|save_capture_last
operator|=
name|md
operator|->
name|capture_last
expr_stmt|;
name|matched_once
operator|=
name|TRUE
expr_stmt|;
name|mstart
operator|=
name|md
operator|->
name|start_match_ptr
expr_stmt|;
comment|/* In case \K changed it */
if|if
condition|(
name|eptr
operator|==
name|md
operator|->
name|end_match_ptr
condition|)
comment|/* Matched an empty string */
block|{
do|do
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
break|break;
block|}
name|eptr
operator|=
name|md
operator|->
name|end_match_ptr
expr_stmt|;
continue|continue;
block|}
comment|/* See comment in the code for capturing groups above about handling       THEN. */
if|if
condition|(
name|rrc
operator|==
name|MATCH_THEN
condition|)
block|{
name|next
operator|=
name|ecode
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|<
name|next
operator|&&
operator|(
operator|*
name|ecode
operator|==
name|OP_ALT
operator|||
operator|*
name|next
operator|==
name|OP_ALT
operator|)
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
block|}
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|capture_last
operator|=
name|save_capture_last
expr_stmt|;
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ecode
operator|!=
name|OP_ALT
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|matched_once
condition|)
block|{
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|=
name|save_offset1
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|save_offset2
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
operator|=
name|save_offset3
expr_stmt|;
block|}
if|if
condition|(
name|allow_zero
operator|||
name|matched_once
condition|)
block|{
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Non-capturing possessive bracket with unlimited repeat. We come here     from BRAZERO with allow_zero = TRUE. The code is similar to the above,     without the capturing complication. It is written out separately for speed     and cleanliness. */
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
name|allow_zero
operator|=
name|FALSE
expr_stmt|;
name|POSSESSIVE_NON_CAPTURE
label|:
name|matched_once
operator|=
name|FALSE
expr_stmt|;
name|code_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|ecode
operator|-
name|md
operator|->
name|start_code
argument_list|)
expr_stmt|;
name|save_capture_last
operator|=
name|md
operator|->
name|capture_last
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|op
operator|>=
name|OP_SBRA
condition|)
name|md
operator|->
name|match_function_type
operator|=
name|MATCH_CBEGROUP
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|ecode
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM48
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|==
name|MATCH_KETRPOS
condition|)
block|{
name|offset_top
operator|=
name|md
operator|->
name|end_offset_top
expr_stmt|;
name|ecode
operator|=
name|md
operator|->
name|start_code
operator|+
name|code_offset
expr_stmt|;
name|matched_once
operator|=
name|TRUE
expr_stmt|;
name|mstart
operator|=
name|md
operator|->
name|start_match_ptr
expr_stmt|;
comment|/* In case \K reset it */
if|if
condition|(
name|eptr
operator|==
name|md
operator|->
name|end_match_ptr
condition|)
comment|/* Matched an empty string */
block|{
do|do
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
break|break;
block|}
name|eptr
operator|=
name|md
operator|->
name|end_match_ptr
expr_stmt|;
continue|continue;
block|}
comment|/* See comment in the code for capturing groups above about handling       THEN. */
if|if
condition|(
name|rrc
operator|==
name|MATCH_THEN
condition|)
block|{
name|next
operator|=
name|ecode
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|<
name|next
operator|&&
operator|(
operator|*
name|ecode
operator|==
name|OP_ALT
operator|||
operator|*
name|next
operator|==
name|OP_ALT
operator|)
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
block|}
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ecode
operator|!=
name|OP_ALT
condition|)
break|break;
name|md
operator|->
name|capture_last
operator|=
name|save_capture_last
expr_stmt|;
block|}
if|if
condition|(
name|matched_once
operator|||
name|allow_zero
condition|)
block|{
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Control never reaches here. */
comment|/* Conditional group: compilation checked that there are no more than two     branches. If the condition is false, skipping the first branch takes us     past the end of the item if there is only one branch, but that's exactly     what we want. */
case|case
name|OP_COND
case|:
case|case
name|OP_SCOND
case|:
comment|/* The variable codelink will be added to ecode when the condition is     false, to get to the second branch. Setting it to the offset to the ALT     or KET, then incrementing ecode achieves this effect. We now have ecode     pointing to the condition or callout. */
name|codelink
operator|=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Offset to the second branch */
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
comment|/* From this opcode */
comment|/* Because of the way auto-callout works during compile, a callout item is     inserted between OP_COND and an assertion condition. */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_CALLOUT
condition|)
block|{
if|if
condition|(
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|PUBL
argument_list|(
argument|callout_block
argument_list|)
name|cb
expr_stmt|;
name|cb
operator|.
name|version
operator|=
literal|2
expr_stmt|;
comment|/* Version 1 of the callout block */
name|cb
operator|.
name|callout_number
operator|=
name|ecode
index|[
literal|1
index|]
expr_stmt|;
name|cb
operator|.
name|offset_vector
operator|=
name|md
operator|->
name|offset_vector
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR
operator|)
name|md
operator|->
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR16
operator|)
name|md
operator|->
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR32
operator|)
name|md
operator|->
name|start_subject
expr_stmt|;
endif|#
directive|endif
name|cb
operator|.
name|subject_length
operator|=
call|(
name|int
call|)
argument_list|(
name|md
operator|->
name|end_subject
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|start_match
operator|=
call|(
name|int
call|)
argument_list|(
name|mstart
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|current_position
operator|=
call|(
name|int
call|)
argument_list|(
name|eptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|pattern_position
operator|=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cb
operator|.
name|next_item_length
operator|=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|capture_top
operator|=
name|offset_top
operator|/
literal|2
expr_stmt|;
name|cb
operator|.
name|capture_last
operator|=
name|md
operator|->
name|capture_last
operator|&
name|CAPLMASK
expr_stmt|;
comment|/* Internal change requires this for API compatibility. */
if|if
condition|(
name|cb
operator|.
name|capture_last
operator|==
literal|0
condition|)
name|cb
operator|.
name|capture_last
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|.
name|callout_data
operator|=
name|md
operator|->
name|callout_data
expr_stmt|;
name|cb
operator|.
name|mark
operator|=
name|md
operator|->
name|nomatch_mark
expr_stmt|;
if|if
condition|(
operator|(
name|rrc
operator|=
operator|(
operator|*
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|)
operator|(
operator|&
name|cb
operator|)
operator|)
operator|>
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|<
literal|0
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
comment|/* Advance ecode past the callout, so it now points to the condition. We       must adjust codelink so that the value of ecode+codelink is unchanged. */
name|ecode
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CALLOUT
index|]
expr_stmt|;
name|codelink
operator|-=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CALLOUT
index|]
expr_stmt|;
block|}
comment|/* Test the various possible conditions */
name|condition
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|condcode
operator|=
operator|*
name|ecode
condition|)
block|{
case|case
name|OP_RREF
case|:
comment|/* Numbered group recursion test */
if|if
condition|(
name|md
operator|->
name|recursive
operator|!=
name|NULL
condition|)
comment|/* Not recursing => FALSE */
block|{
name|unsigned
name|int
name|recno
init|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Recursion group number*/
name|condition
operator|=
operator|(
name|recno
operator|==
name|RREF_ANY
operator|||
name|recno
operator|==
name|md
operator|->
name|recursive
operator|->
name|group_num
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_DNRREF
case|:
comment|/* Duplicate named group recursion test */
if|if
condition|(
name|md
operator|->
name|recursive
operator|!=
name|NULL
condition|)
block|{
name|int
name|count
init|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
decl_stmt|;
name|pcre_uchar
modifier|*
name|slot
init|=
name|md
operator|->
name|name_table
operator|+
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
operator|*
name|md
operator|->
name|name_entry_size
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|recno
init|=
name|GET2
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|condition
operator|=
name|recno
operator|==
name|md
operator|->
name|recursive
operator|->
name|group_num
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
name|slot
operator|+=
name|md
operator|->
name|name_entry_size
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_CREF
case|:
comment|/* Numbered group used test */
name|offset
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
expr_stmt|;
comment|/* Doubled ref number */
name|condition
operator|=
name|offset
operator|<
name|offset_top
operator|&&
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
name|OP_DNCREF
case|:
comment|/* Duplicate named group used test */
block|{
name|int
name|count
init|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
decl_stmt|;
name|pcre_uchar
modifier|*
name|slot
init|=
name|md
operator|->
name|name_table
operator|+
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
operator|*
name|md
operator|->
name|name_entry_size
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|offset
operator|=
name|GET2
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|condition
operator|=
name|offset
operator|<
name|offset_top
operator|&&
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|condition
condition|)
break|break;
name|slot
operator|+=
name|md
operator|->
name|name_entry_size
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_DEF
case|:
comment|/* DEFINE - always false */
case|case
name|OP_FAIL
case|:
comment|/* From optimized (?!) condition */
break|break;
comment|/* The condition is an assertion. Call match() to evaluate it - setting       md->match_function_type to MATCH_CONDASSERT causes it to stop at the end       of an assertion. */
default|default:
name|md
operator|->
name|match_function_type
operator|=
name|MATCH_CONDASSERT
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|,
name|RM3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|==
name|MATCH_MATCH
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|end_offset_top
operator|>
name|offset_top
condition|)
name|offset_top
operator|=
name|md
operator|->
name|end_offset_top
expr_stmt|;
comment|/* Captures may have happened */
name|condition
operator|=
name|TRUE
expr_stmt|;
comment|/* Advance ecode past the assertion to the start of the first branch,         but adjust it so that the general choosing code below works. If the         assertion has a quantifier that allows zero repeats we must skip over         the BRAZERO. This is a lunatic thing to do, but somebody did! */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_BRAZERO
condition|)
name|ecode
operator|++
expr_stmt|;
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|-
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|condcode
index|]
expr_stmt|;
block|}
comment|/* PCRE doesn't allow the effect of (*THEN) to escape beyond an       assertion; it is therefore treated as NOMATCH. Any other return is an       error. */
elseif|else
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
operator|&&
name|rrc
operator|!=
name|MATCH_THEN
condition|)
block|{
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
comment|/* Need braces because of following else */
block|}
break|break;
block|}
comment|/* Choose branch according to the condition */
name|ecode
operator|+=
name|condition
condition|?
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|condcode
index|]
else|:
name|codelink
expr_stmt|;
comment|/* We are now at the branch that is to be obeyed. As there is only one, we     can use tail recursion to avoid using another stack frame, except when     there is unlimited repeat of a possibly empty group. In the latter case, a     recursive call to match() is always required, unless the second alternative     doesn't exist, in which case we can just plough on. Note that, for     compatibility with Perl, the | in a conditional group is NOT treated as     creating two alternatives. If a THEN is encountered in the branch, it     propagates out to the enclosing alternative (unless nested in a deeper set     of alternatives, of course). */
if|if
condition|(
name|condition
operator|||
name|ecode
index|[
operator|-
operator|(
literal|1
operator|+
name|LINK_SIZE
operator|)
index|]
operator|==
name|OP_ALT
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|OP_SCOND
condition|)
block|{
goto|goto
name|TAIL_RECURSE
goto|;
block|}
name|md
operator|->
name|match_function_type
operator|=
name|MATCH_CBEGROUP
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM49
argument_list|)
expr_stmt|;
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
comment|/* Condition false& no alternative; continue after the group. */
else|else
block|{       }
break|break;
comment|/* Before OP_ACCEPT there may be any number of OP_CLOSE opcodes,     to close any currently open capturing brackets. */
case|case
name|OP_CLOSE
case|:
name|number
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Must be less than 65536 */
name|offset
operator|=
name|number
operator|<<
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|printf
argument_list|(
literal|"end bracket %d at *ACCEPT"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|md
operator|->
name|capture_last
operator|=
operator|(
name|md
operator|->
name|capture_last
operator|&
name|OVFLMASK
operator|)
operator||
name|number
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|md
operator|->
name|offset_max
condition|)
name|md
operator|->
name|capture_last
operator||=
name|OVFLBIT
expr_stmt|;
else|else
block|{
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|=
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|eptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
comment|/* If this group is at or above the current highwater mark, ensure that       any groups between the current high water mark and this group are marked       unset and then update the high water mark. */
if|if
condition|(
name|offset
operator|>=
name|offset_top
condition|)
block|{
specifier|register
name|int
modifier|*
name|iptr
init|=
name|md
operator|->
name|offset_vector
operator|+
name|offset_top
decl_stmt|;
specifier|register
name|int
modifier|*
name|iend
init|=
name|md
operator|->
name|offset_vector
operator|+
name|offset
decl_stmt|;
while|while
condition|(
name|iptr
operator|<
name|iend
condition|)
operator|*
name|iptr
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|offset_top
operator|=
name|offset
operator|+
literal|2
expr_stmt|;
block|}
block|}
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
break|break;
comment|/* End of the pattern, either real or forced. */
case|case
name|OP_END
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
comment|/* If we have matched an empty string, fail if not in an assertion and not     in a recursion if either PCRE_NOTEMPTY is set, or if PCRE_NOTEMPTY_ATSTART     is set and we have matched at the start of the subject. In both cases,     backtracking will then try other alternatives, if any. */
if|if
condition|(
name|eptr
operator|==
name|mstart
operator|&&
name|op
operator|!=
name|OP_ASSERT_ACCEPT
operator|&&
name|md
operator|->
name|recursive
operator|==
name|NULL
operator|&&
operator|(
name|md
operator|->
name|notempty
operator|||
operator|(
name|md
operator|->
name|notempty_atstart
operator|&&
name|mstart
operator|==
name|md
operator|->
name|start_subject
operator|+
name|md
operator|->
name|start_offset
operator|)
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Otherwise, we have a match. */
name|md
operator|->
name|end_match_ptr
operator|=
name|eptr
expr_stmt|;
comment|/* Record where we ended */
name|md
operator|->
name|end_offset_top
operator|=
name|offset_top
expr_stmt|;
comment|/* and how many extracts were taken */
name|md
operator|->
name|start_match_ptr
operator|=
name|mstart
expr_stmt|;
comment|/* and the start (\K can modify) */
comment|/* For some reason, the macros don't work properly if an expression is     given as the argument to RRETURN when the heap is in use. */
name|rrc
operator|=
operator|(
name|op
operator|==
name|OP_END
operator|)
condition|?
name|MATCH_MATCH
else|:
name|MATCH_ACCEPT
expr_stmt|;
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
comment|/* Assertion brackets. Check the alternative branches in turn - the     matching won't pass the KET for an assertion. If any one branch matches,     the assertion is true. Lookbehind assertions have an OP_REVERSE item at the     start of each branch to move the current point backwards, so the code at     this level is identical to the lookahead case. When the assertion is part     of a condition, we want to return immediately afterwards. The caller of     this incarnation of the match() function will have set MATCH_CONDASSERT in     md->match_function type, and one of these opcodes will be the first opcode     that is processed. We use a local variable that is preserved over calls to     match() to remember this case. */
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERTBACK
case|:
name|save_mark
operator|=
name|md
operator|->
name|mark
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|match_function_type
operator|==
name|MATCH_CONDASSERT
condition|)
block|{
name|condassert
operator|=
name|TRUE
expr_stmt|;
name|md
operator|->
name|match_function_type
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|condassert
operator|=
name|FALSE
expr_stmt|;
comment|/* Loop for each branch */
do|do
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|,
name|RM4
argument_list|)
expr_stmt|;
comment|/* A match means that the assertion is true; break out of the loop       that matches its alternatives. */
if|if
condition|(
name|rrc
operator|==
name|MATCH_MATCH
operator|||
name|rrc
operator|==
name|MATCH_ACCEPT
condition|)
block|{
name|mstart
operator|=
name|md
operator|->
name|start_match_ptr
expr_stmt|;
comment|/* In case \K reset it */
break|break;
block|}
comment|/* If not matched, restore the previous mark setting. */
name|md
operator|->
name|mark
operator|=
name|save_mark
expr_stmt|;
comment|/* See comment in the code for capturing groups above about handling       THEN. */
if|if
condition|(
name|rrc
operator|==
name|MATCH_THEN
condition|)
block|{
name|next
operator|=
name|ecode
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|<
name|next
operator|&&
operator|(
operator|*
name|ecode
operator|==
name|OP_ALT
operator|||
operator|*
name|next
operator|==
name|OP_ALT
operator|)
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
block|}
comment|/* Anything other than NOMATCH causes the entire assertion to fail,       passing back the return code. This includes COMMIT, SKIP, PRUNE and an       uncaptured THEN, which means they take their normal effect. This       consistent approach does not always have exactly the same effect as in       Perl. */
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
comment|/* Continue for next alternative */
comment|/* If we have tried all the alternative branches, the assertion has     failed. If not, we broke out after a match. */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_KET
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* If checking an assertion for a condition, return MATCH_MATCH. */
if|if
condition|(
name|condassert
condition|)
name|RRETURN
argument_list|(
name|MATCH_MATCH
argument_list|)
expr_stmt|;
comment|/* Continue from after a successful assertion, updating the offsets high     water mark, since extracts may have been taken during the assertion. */
do|do
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|offset_top
operator|=
name|md
operator|->
name|end_offset_top
expr_stmt|;
continue|continue;
comment|/* Negative assertion: all branches must fail to match for the assertion to     succeed. */
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
name|save_mark
operator|=
name|md
operator|->
name|mark
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|match_function_type
operator|==
name|MATCH_CONDASSERT
condition|)
block|{
name|condassert
operator|=
name|TRUE
expr_stmt|;
name|md
operator|->
name|match_function_type
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|condassert
operator|=
name|FALSE
expr_stmt|;
comment|/* Loop for each alternative branch. */
do|do
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|,
name|RM5
argument_list|)
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|save_mark
expr_stmt|;
comment|/* Always restore the mark setting */
switch|switch
condition|(
name|rrc
condition|)
block|{
case|case
name|MATCH_MATCH
case|:
comment|/* A successful match means */
case|case
name|MATCH_ACCEPT
case|:
comment|/* the assertion has failed. */
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
case|case
name|MATCH_NOMATCH
case|:
comment|/* Carry on with next branch */
break|break;
comment|/* See comment in the code for capturing groups above about handling         THEN. */
case|case
name|MATCH_THEN
case|:
name|next
operator|=
name|ecode
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|<
name|next
operator|&&
operator|(
operator|*
name|ecode
operator|==
name|OP_ALT
operator|||
operator|*
name|next
operator|==
name|OP_ALT
operator|)
condition|)
block|{
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
break|break;
block|}
comment|/* Otherwise fall through. */
comment|/* COMMIT, SKIP, PRUNE, and an uncaptured THEN cause the whole         assertion to fail to match, without considering any more alternatives.         Failing to match means the assertion is true. This is a consistent         approach, but does not always have the same effect as in Perl. */
case|case
name|MATCH_COMMIT
case|:
case|case
name|MATCH_SKIP
case|:
case|case
name|MATCH_SKIP_ARG
case|:
case|case
name|MATCH_PRUNE
case|:
do|do
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
goto|goto
name|NEG_ASSERT_TRUE
goto|;
comment|/* Break out of alternation loop */
comment|/* Anything else is an error */
default|default:
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
comment|/* Continue with next branch */
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
comment|/* All branches in the assertion failed to match. */
name|NEG_ASSERT_TRUE
label|:
if|if
condition|(
name|condassert
condition|)
name|RRETURN
argument_list|(
name|MATCH_MATCH
argument_list|)
expr_stmt|;
comment|/* Condition assertion */
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
comment|/* Continue with current branch */
continue|continue;
comment|/* Move the subject pointer back. This occurs only at the start of     each branch of a lookbehind assertion. If we are too close to the start to     move back, this match function fails. When working with UTF-8 we move     back a number of characters, not bytes. */
case|case
name|OP_REVERSE
case|:
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|i
operator|=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|eptr
operator|--
expr_stmt|;
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|start_subject
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* No UTF-8 support, or not in UTF-8 mode: count is byte count */
block|{
name|eptr
operator|-=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|start_subject
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Save the earliest consulted character, then skip to next op code */
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|start_used_ptr
condition|)
name|md
operator|->
name|start_used_ptr
operator|=
name|eptr
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* The callout item calls an external function, if one is provided, passing     details of the match so far. This is mainly for debugging, though the     function is able to force a failure. */
case|case
name|OP_CALLOUT
case|:
if|if
condition|(
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|PUBL
argument_list|(
argument|callout_block
argument_list|)
name|cb
expr_stmt|;
name|cb
operator|.
name|version
operator|=
literal|2
expr_stmt|;
comment|/* Version 1 of the callout block */
name|cb
operator|.
name|callout_number
operator|=
name|ecode
index|[
literal|1
index|]
expr_stmt|;
name|cb
operator|.
name|offset_vector
operator|=
name|md
operator|->
name|offset_vector
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR
operator|)
name|md
operator|->
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR16
operator|)
name|md
operator|->
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR32
operator|)
name|md
operator|->
name|start_subject
expr_stmt|;
endif|#
directive|endif
name|cb
operator|.
name|subject_length
operator|=
call|(
name|int
call|)
argument_list|(
name|md
operator|->
name|end_subject
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|start_match
operator|=
call|(
name|int
call|)
argument_list|(
name|mstart
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|current_position
operator|=
call|(
name|int
call|)
argument_list|(
name|eptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|pattern_position
operator|=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cb
operator|.
name|next_item_length
operator|=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|capture_top
operator|=
name|offset_top
operator|/
literal|2
expr_stmt|;
name|cb
operator|.
name|capture_last
operator|=
name|md
operator|->
name|capture_last
operator|&
name|CAPLMASK
expr_stmt|;
comment|/* Internal change requires this for API compatibility. */
if|if
condition|(
name|cb
operator|.
name|capture_last
operator|==
literal|0
condition|)
name|cb
operator|.
name|capture_last
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|.
name|callout_data
operator|=
name|md
operator|->
name|callout_data
expr_stmt|;
name|cb
operator|.
name|mark
operator|=
name|md
operator|->
name|nomatch_mark
expr_stmt|;
if|if
condition|(
operator|(
name|rrc
operator|=
operator|(
operator|*
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|)
operator|(
operator|&
name|cb
operator|)
operator|)
operator|>
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|<
literal|0
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|+=
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* Recursion either matches the current regex, or some subexpression. The     offset data is the offset to the starting bracket from the start of the     whole pattern. (This is so that it works from duplicated subpatterns.)      The state of the capturing groups is preserved over recursion, and     re-instated afterwards. We don't know how many are started and not yet     finished (offset_top records the completed total) so we just have to save     all the potential data. There may be up to 65535 such values, which is too     large to put on the stack, but using malloc for small numbers seems     expensive. As a compromise, the stack is used when there are no more than     REC_STACK_SAVE_MAX values to store; otherwise malloc is used.      There are also other values that have to be saved. We use a chained     sequence of blocks that actually live on the stack. Thanks to Robin Houston     for the original version of this logic. It has, however, been hacked around     a lot, so he is not to blame for the current way it works. */
case|case
name|OP_RECURSE
case|:
block|{
name|recursion_info
modifier|*
name|ri
decl_stmt|;
name|unsigned
name|int
name|recno
decl_stmt|;
name|callpat
operator|=
name|md
operator|->
name|start_code
operator|+
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|recno
operator|=
operator|(
name|callpat
operator|==
name|md
operator|->
name|start_code
operator|)
condition|?
literal|0
else|:
name|GET2
argument_list|(
name|callpat
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
comment|/* Check for repeating a recursion without advancing the subject pointer.       This should catch convoluted mutual recursions. (Some simple cases are       caught at compile time.) */
for|for
control|(
name|ri
operator|=
name|md
operator|->
name|recursive
init|;
name|ri
operator|!=
name|NULL
condition|;
name|ri
operator|=
name|ri
operator|->
name|prevrec
control|)
if|if
condition|(
name|recno
operator|==
name|ri
operator|->
name|group_num
operator|&&
name|eptr
operator|==
name|ri
operator|->
name|subject_position
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_RECURSELOOP
argument_list|)
expr_stmt|;
comment|/* Add to "recursing stack" */
name|new_recursive
operator|.
name|group_num
operator|=
name|recno
expr_stmt|;
name|new_recursive
operator|.
name|saved_capture_last
operator|=
name|md
operator|->
name|capture_last
expr_stmt|;
name|new_recursive
operator|.
name|subject_position
operator|=
name|eptr
expr_stmt|;
name|new_recursive
operator|.
name|prevrec
operator|=
name|md
operator|->
name|recursive
expr_stmt|;
name|md
operator|->
name|recursive
operator|=
operator|&
name|new_recursive
expr_stmt|;
comment|/* Where to continue from afterwards */
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
comment|/* Now save the offset data */
name|new_recursive
operator|.
name|saved_max
operator|=
name|md
operator|->
name|offset_end
expr_stmt|;
if|if
condition|(
name|new_recursive
operator|.
name|saved_max
operator|<=
name|REC_STACK_SAVE_MAX
condition|)
name|new_recursive
operator|.
name|offset_save
operator|=
name|stacksave
expr_stmt|;
else|else
block|{
name|new_recursive
operator|.
name|offset_save
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|PUBL
argument_list|(
name|malloc
argument_list|)
operator|)
operator|(
name|new_recursive
operator|.
name|saved_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_recursive
operator|.
name|offset_save
operator|==
name|NULL
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_NOMEMORY
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|new_recursive
operator|.
name|offset_save
argument_list|,
name|md
operator|->
name|offset_vector
argument_list|,
name|new_recursive
operator|.
name|saved_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OK, now we can do the recursion. After processing each alternative,       restore the offset data and the last captured value. If there were nested       recursions, md->recursive might be changed, so reset it before looping.       */
name|DPRINTF
argument_list|(
operator|(
literal|"Recursing into group %d\n"
operator|,
name|new_recursive
operator|.
name|group_num
operator|)
argument_list|)
expr_stmt|;
name|cbegroup
operator|=
operator|(
operator|*
name|callpat
operator|>=
name|OP_SBRA
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cbegroup
condition|)
name|md
operator|->
name|match_function_type
operator|=
name|MATCH_CBEGROUP
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|callpat
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|callpat
index|]
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|md
operator|->
name|offset_vector
argument_list|,
name|new_recursive
operator|.
name|offset_save
argument_list|,
name|new_recursive
operator|.
name|saved_max
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|capture_last
operator|=
name|new_recursive
operator|.
name|saved_capture_last
expr_stmt|;
name|md
operator|->
name|recursive
operator|=
name|new_recursive
operator|.
name|prevrec
expr_stmt|;
if|if
condition|(
name|rrc
operator|==
name|MATCH_MATCH
operator|||
name|rrc
operator|==
name|MATCH_ACCEPT
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Recursion matched\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_recursive
operator|.
name|offset_save
operator|!=
name|stacksave
condition|)
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|new_recursive
operator|.
name|offset_save
operator|)
expr_stmt|;
comment|/* Set where we got to in the subject, and reset the start in case           it was changed by \K. This *is* propagated back out of a recursion,           for Perl compatibility. */
name|eptr
operator|=
name|md
operator|->
name|end_match_ptr
expr_stmt|;
name|mstart
operator|=
name|md
operator|->
name|start_match_ptr
expr_stmt|;
goto|goto
name|RECURSION_MATCHED
goto|;
comment|/* Exit loop; end processing */
block|}
comment|/* PCRE does not allow THEN, SKIP, PRUNE or COMMIT to escape beyond a         recursion; they cause a NOMATCH for the entire recursion. These codes         are defined in a range that can be tested for. */
if|if
condition|(
name|rrc
operator|>=
name|MATCH_BACKTRACK_MIN
operator|&&
name|rrc
operator|<=
name|MATCH_BACKTRACK_MAX
condition|)
block|{
if|if
condition|(
name|new_recursive
operator|.
name|offset_save
operator|!=
name|stacksave
condition|)
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|new_recursive
operator|.
name|offset_save
operator|)
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Any return code other than NOMATCH is an error. */
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Recursion gave error %d\n"
operator|,
name|rrc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_recursive
operator|.
name|offset_save
operator|!=
name|stacksave
condition|)
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|new_recursive
operator|.
name|offset_save
operator|)
expr_stmt|;
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
name|md
operator|->
name|recursive
operator|=
operator|&
name|new_recursive
expr_stmt|;
name|callpat
operator|+=
name|GET
argument_list|(
name|callpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|callpat
operator|==
name|OP_ALT
condition|)
do|;
name|DPRINTF
argument_list|(
operator|(
literal|"Recursion didn't match\n"
operator|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|recursive
operator|=
name|new_recursive
operator|.
name|prevrec
expr_stmt|;
if|if
condition|(
name|new_recursive
operator|.
name|offset_save
operator|!=
name|stacksave
condition|)
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|new_recursive
operator|.
name|offset_save
operator|)
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|RECURSION_MATCHED
label|:
break|break;
comment|/* An alternation is the end of a branch; scan along to find the end of the     bracketed group and go to there. */
case|case
name|OP_ALT
case|:
do|do
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ecode
operator|==
name|OP_ALT
condition|)
do|;
break|break;
comment|/* BRAZERO, BRAMINZERO and SKIPZERO occur just before a bracket group,     indicating that it may occur zero times. It may repeat infinitely, or not     at all - i.e. it could be ()* or ()? or even (){0} in the pattern. Brackets     with fixed upper repeat limits are compiled as a number of copies, with the     optional ones preceded by BRAZERO or BRAMINZERO. */
case|case
name|OP_BRAZERO
case|:
name|next
operator|=
name|ecode
operator|+
literal|1
expr_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|next
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM10
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
do|do
name|next
operator|+=
name|GET
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|next
operator|==
name|OP_ALT
condition|)
do|;
name|ecode
operator|=
name|next
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
case|case
name|OP_BRAMINZERO
case|:
name|next
operator|=
name|ecode
operator|+
literal|1
expr_stmt|;
do|do
name|next
operator|+=
name|GET
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|next
operator|==
name|OP_ALT
condition|)
do|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|next
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM11
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_SKIPZERO
case|:
name|next
operator|=
name|ecode
operator|+
literal|1
expr_stmt|;
do|do
name|next
operator|+=
name|GET
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|next
operator|==
name|OP_ALT
condition|)
do|;
name|ecode
operator|=
name|next
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* BRAPOSZERO occurs before a possessive bracket group. Don't do anything     here; just jump to the group, with allow_zero set TRUE. */
case|case
name|OP_BRAPOSZERO
case|:
name|op
operator|=
operator|*
operator|(
operator|++
name|ecode
operator|)
expr_stmt|;
name|allow_zero
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_CBRAPOS
operator|||
name|op
operator|==
name|OP_SCBRAPOS
condition|)
goto|goto
name|POSSESSIVE_CAPTURE
goto|;
goto|goto
name|POSSESSIVE_NON_CAPTURE
goto|;
comment|/* End of a group, repeated or non-repeating. */
case|case
name|OP_KET
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRPOS
case|:
name|prev
operator|=
name|ecode
operator|-
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If this was a group that remembered the subject start, in order to break     infinite repeats of empty string matches, retrieve the subject start from     the chain. Otherwise, set it NULL. */
if|if
condition|(
operator|*
name|prev
operator|>=
name|OP_SBRA
operator|||
operator|*
name|prev
operator|==
name|OP_ONCE
condition|)
block|{
name|saved_eptr
operator|=
name|eptrb
operator|->
name|epb_saved_eptr
expr_stmt|;
comment|/* Value at start of group */
name|eptrb
operator|=
name|eptrb
operator|->
name|epb_prev
expr_stmt|;
comment|/* Backup to previous group */
block|}
else|else
name|saved_eptr
operator|=
name|NULL
expr_stmt|;
comment|/* If we are at the end of an assertion group or a non-capturing atomic     group, stop matching and return MATCH_MATCH, but record the current high     water mark for use by positive assertions. We also need to record the match     start in case it was changed by \K. */
if|if
condition|(
operator|(
operator|*
name|prev
operator|>=
name|OP_ASSERT
operator|&&
operator|*
name|prev
operator|<=
name|OP_ASSERTBACK_NOT
operator|)
operator|||
operator|*
name|prev
operator|==
name|OP_ONCE_NC
condition|)
block|{
name|md
operator|->
name|end_match_ptr
operator|=
name|eptr
expr_stmt|;
comment|/* For ONCE_NC */
name|md
operator|->
name|end_offset_top
operator|=
name|offset_top
expr_stmt|;
name|md
operator|->
name|start_match_ptr
operator|=
name|mstart
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_MATCH
argument_list|)
expr_stmt|;
comment|/* Sets md->mark */
block|}
comment|/* For capturing groups we have to check the group number back at the start     and if necessary complete handling an extraction by setting the offsets and     bumping the high water mark. Whole-pattern recursion is coded as a recurse     into group 0, so it won't be picked up here. Instead, we catch it when the     OP_END is reached. Other recursion is handled here. We just have to record     the current subject position and start match pointer and give a MATCH     return. */
if|if
condition|(
operator|*
name|prev
operator|==
name|OP_CBRA
operator|||
operator|*
name|prev
operator|==
name|OP_SCBRA
operator|||
operator|*
name|prev
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|prev
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|number
operator|=
name|GET2
argument_list|(
name|prev
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|number
operator|<<
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|printf
argument_list|(
literal|"end bracket %d"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Handle a recursively called group. */
if|if
condition|(
name|md
operator|->
name|recursive
operator|!=
name|NULL
operator|&&
name|md
operator|->
name|recursive
operator|->
name|group_num
operator|==
name|number
condition|)
block|{
name|md
operator|->
name|end_match_ptr
operator|=
name|eptr
expr_stmt|;
name|md
operator|->
name|start_match_ptr
operator|=
name|mstart
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_MATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with capturing */
name|md
operator|->
name|capture_last
operator|=
operator|(
name|md
operator|->
name|capture_last
operator|&
name|OVFLMASK
operator|)
operator||
name|number
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|md
operator|->
name|offset_max
condition|)
name|md
operator|->
name|capture_last
operator||=
name|OVFLBIT
expr_stmt|;
else|else
block|{
comment|/* If offset is greater than offset_top, it means that we are         "skipping" a capturing group, and that group's offsets must be marked         unset. In earlier versions of PCRE, all the offsets were unset at the         start of matching, but this doesn't work because atomic groups and         assertions can cause a value to be set that should later be unset.         Example: matching /(?>(a))b|(a)c/ against "ac". This sets group 1 as         part of the atomic group, but this is not on the final matching path,         so must be unset when 2 is set. (If there is no group 2, there is no         problem, because offset_top will then be 2, indicating no capture.) */
if|if
condition|(
name|offset
operator|>
name|offset_top
condition|)
block|{
specifier|register
name|int
modifier|*
name|iptr
init|=
name|md
operator|->
name|offset_vector
operator|+
name|offset_top
decl_stmt|;
specifier|register
name|int
modifier|*
name|iend
init|=
name|md
operator|->
name|offset_vector
operator|+
name|offset
decl_stmt|;
while|while
condition|(
name|iptr
operator|<
name|iend
condition|)
operator|*
name|iptr
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Now make the extraction */
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|=
name|md
operator|->
name|offset_vector
index|[
name|md
operator|->
name|offset_end
operator|-
name|number
index|]
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|eptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_top
operator|<=
name|offset
condition|)
name|offset_top
operator|=
name|offset
operator|+
literal|2
expr_stmt|;
block|}
block|}
comment|/* OP_KETRPOS is a possessive repeating ket. Remember the current position,     and return the MATCH_KETRPOS. This makes it possible to do the repeats one     at a time from the outer level, thus saving stack. This must precede the     empty string test - in this case that test is done at the outer level. */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_KETRPOS
condition|)
block|{
name|md
operator|->
name|start_match_ptr
operator|=
name|mstart
expr_stmt|;
comment|/* In case \K reset it */
name|md
operator|->
name|end_match_ptr
operator|=
name|eptr
expr_stmt|;
name|md
operator|->
name|end_offset_top
operator|=
name|offset_top
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_KETRPOS
argument_list|)
expr_stmt|;
block|}
comment|/* For an ordinary non-repeating ket, just continue at this level. This     also happens for a repeating ket if no characters were matched in the     group. This is the forcible breaking of infinite loops as implemented in     Perl 5.005. For a non-repeating atomic group that includes captures,     establish a backup point by processing the rest of the pattern at a lower     level. If this results in a NOMATCH return, pass MATCH_ONCE back to the     original OP_ONCE level, thereby bypassing intermediate backup points, but     resetting any captures that happened along the way. */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_KET
operator|||
name|eptr
operator|==
name|saved_eptr
condition|)
block|{
if|if
condition|(
operator|*
name|prev
operator|==
name|OP_ONCE
condition|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM12
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|once_target
operator|=
name|prev
expr_stmt|;
comment|/* Level at which to change to MATCH_NOMATCH */
name|RRETURN
argument_list|(
name|MATCH_ONCE
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
comment|/* Carry on at this level */
break|break;
block|}
comment|/* The normal repeating kets try the rest of the pattern or restart from     the preceding bracket, in the appropriate order. In the second case, we can     use tail recursion to avoid using another stack frame, unless we have an     an atomic group or an unlimited repeat of a group that can match an empty     string. */
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_KETRMIN
condition|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM7
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prev
operator|==
name|OP_ONCE
condition|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|prev
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM8
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|once_target
operator|=
name|prev
expr_stmt|;
comment|/* Level at which to change to MATCH_NOMATCH */
name|RRETURN
argument_list|(
name|MATCH_ONCE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|prev
operator|>=
name|OP_SBRA
condition|)
comment|/* Could match an empty string */
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|prev
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM50
argument_list|)
expr_stmt|;
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|=
name|prev
expr_stmt|;
goto|goto
name|TAIL_RECURSE
goto|;
block|}
else|else
comment|/* OP_KETRMAX */
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|prev
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM13
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|==
name|MATCH_ONCE
operator|&&
name|md
operator|->
name|once_target
operator|==
name|prev
condition|)
name|rrc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prev
operator|==
name|OP_ONCE
condition|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM9
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|md
operator|->
name|once_target
operator|=
name|prev
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_ONCE
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
goto|goto
name|TAIL_RECURSE
goto|;
block|}
comment|/* Control never gets here */
comment|/* Not multiline mode: start of subject assertion, unless notbol. */
case|case
name|OP_CIRC
case|:
if|if
condition|(
name|md
operator|->
name|notbol
operator|&&
name|eptr
operator|==
name|md
operator|->
name|start_subject
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Start of subject assertion */
case|case
name|OP_SOD
case|:
if|if
condition|(
name|eptr
operator|!=
name|md
operator|->
name|start_subject
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* Multiline mode: start of subject unless notbol, or after any newline. */
case|case
name|OP_CIRCM
case|:
if|if
condition|(
name|md
operator|->
name|notbol
operator|&&
name|eptr
operator|==
name|md
operator|->
name|start_subject
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|!=
name|md
operator|->
name|start_subject
operator|&&
operator|(
name|eptr
operator|==
name|md
operator|->
name|end_subject
operator|||
operator|!
name|WAS_NEWLINE
argument_list|(
name|eptr
argument_list|)
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* Start of match assertion */
case|case
name|OP_SOM
case|:
if|if
condition|(
name|eptr
operator|!=
name|md
operator|->
name|start_subject
operator|+
name|md
operator|->
name|start_offset
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* Reset the start of match point */
case|case
name|OP_SET_SOM
case|:
name|mstart
operator|=
name|eptr
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* Multiline mode: assert before any newline, or before end of subject     unless noteol is set. */
case|case
name|OP_DOLLM
case|:
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
condition|)
block|{
if|if
condition|(
operator|!
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
name|eptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|md
operator|->
name|noteol
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* Not multiline mode: assert before a terminating newline or before end of     subject unless noteol is set. */
case|case
name|OP_DOLL
case|:
if|if
condition|(
name|md
operator|->
name|noteol
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|md
operator|->
name|endonly
condition|)
goto|goto
name|ASSERT_NL_OR_EOS
goto|;
comment|/* ... else fall through for endonly */
comment|/* End of subject assertion (\z) */
case|case
name|OP_EOD
case|:
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* End of subject or ending \n assertion (\Z) */
case|case
name|OP_EODN
case|:
name|ASSERT_NL_OR_EOS
label|:
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
operator|&&
operator|(
operator|!
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
operator|||
name|eptr
operator|!=
name|md
operator|->
name|end_subject
operator|-
name|md
operator|->
name|nllen
operator|)
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
name|eptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Either at end of string or \n before end. */
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* Word boundary assertions */
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
block|{
comment|/* Find out if the previous and current characters are "word" characters.       It takes a bit more work in UTF-8 mode. Characters> 255 are assumed to       be "non-word" characters. Remember the earliest consulted character for       partial matching. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
comment|/* Get status of previous character */
if|if
condition|(
name|eptr
operator|==
name|md
operator|->
name|start_subject
condition|)
name|prev_is_word
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|PCRE_PUCHAR
name|lastptr
init|=
name|eptr
operator|-
literal|1
decl_stmt|;
name|BACKCHAR
argument_list|(
name|lastptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastptr
operator|<
name|md
operator|->
name|start_used_ptr
condition|)
name|md
operator|->
name|start_used_ptr
operator|=
name|lastptr
expr_stmt|;
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|lastptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|md
operator|->
name|use_ucp
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|prev_is_word
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|int
name|cat
init|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|prev_is_word
operator|=
operator|(
name|cat
operator|==
name|ucp_L
operator|||
name|cat
operator|==
name|ucp_N
operator|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|prev_is_word
operator|=
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
comment|/* Get status of next character */
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|cur_is_word
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|md
operator|->
name|use_ucp
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|cur_is_word
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|int
name|cat
init|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|cur_is_word
operator|=
operator|(
name|cat
operator|==
name|ucp_L
operator|||
name|cat
operator|==
name|ucp_N
operator|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|cur_is_word
operator|=
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not in UTF-8 mode, but we may still have PCRE_UCP set, and for       consistency with the behaviour of \w we do use it in this case. */
block|{
comment|/* Get status of previous character */
if|if
condition|(
name|eptr
operator|==
name|md
operator|->
name|start_subject
condition|)
name|prev_is_word
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|eptr
operator|<=
name|md
operator|->
name|start_used_ptr
condition|)
name|md
operator|->
name|start_used_ptr
operator|=
name|eptr
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|md
operator|->
name|use_ucp
condition|)
block|{
name|c
operator|=
name|eptr
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|prev_is_word
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|int
name|cat
init|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|prev_is_word
operator|=
operator|(
name|cat
operator|==
name|ucp_L
operator|||
name|cat
operator|==
name|ucp_N
operator|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|prev_is_word
operator|=
name|MAX_255
argument_list|(
name|eptr
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|md
operator|->
name|ctypes
index|[
name|eptr
index|[
operator|-
literal|1
index|]
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Get status of next character */
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|cur_is_word
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|md
operator|->
name|use_ucp
condition|)
block|{
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|cur_is_word
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|int
name|cat
init|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|cur_is_word
operator|=
operator|(
name|cat
operator|==
name|ucp_L
operator|||
name|cat
operator|==
name|ucp_N
operator|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|cur_is_word
operator|=
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|&&
operator|(
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Now see if the situation is what we want */
if|if
condition|(
operator|(
operator|*
name|ecode
operator|++
operator|==
name|OP_WORD_BOUNDARY
operator|)
condition|?
name|cur_is_word
operator|==
name|prev_is_word
else|:
name|cur_is_word
operator|!=
name|prev_is_word
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Match any single character type except newline; have to take care with     CRLF newlines and partial matching. */
case|case
name|OP_ANY
case|:
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
name|eptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through */
comment|/* Match any single character whatsoever. */
case|case
name|OP_ALLANY
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
comment|/* DO NOT merge the eptr++ here; it must */
block|{
comment|/* not be updated before SCHECK_PARTIAL. */
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
name|ACROSSCHAR
argument_list|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
argument_list|,
operator|*
name|eptr
argument_list|,
name|eptr
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ecode
operator|++
expr_stmt|;
break|break;
comment|/* Match a single byte, even in UTF-8 mode. This opcode really does match     any byte, even newline, independent of the setting of PCRE_DOTALL. */
case|case
name|OP_ANYBYTE
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
comment|/* DO NOT merge the eptr++ here; it must */
block|{
comment|/* not be updated before SCHECK_PARTIAL. */
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|++
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_NOT_DIGIT
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
name|c
operator|<
literal|256
operator|&&
endif|#
directive|endif
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_DIGIT
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
name|c
operator|>
literal|255
operator|||
endif|#
directive|endif
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_NOT_WHITESPACE
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
name|c
operator|<
literal|256
operator|&&
endif|#
directive|endif
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_WHITESPACE
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
name|c
operator|>
literal|255
operator|||
endif|#
directive|endif
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
name|c
operator|<
literal|256
operator|&&
endif|#
directive|endif
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_WORDCHAR
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
name|c
operator|>
literal|255
operator|||
endif|#
directive|endif
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_ANYNL
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
operator|==
name|CHAR_LF
condition|)
name|eptr
operator|++
expr_stmt|;
break|break;
case|case
name|CHAR_LF
case|:
break|break;
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
ifndef|#
directive|ifndef
name|EBCDIC
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
comment|/* Not EBCDIC */
if|if
condition|(
name|md
operator|->
name|bsr_anycrlf
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_NOT_HSPACE
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Byte and multibyte cases */
default|default:
break|break;
block|}
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_HSPACE
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
break|break;
comment|/* Byte and multibyte cases */
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_NOT_VSPACE
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
name|ecode
operator|++
expr_stmt|;
break|break;
case|case
name|OP_VSPACE
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
break|break;
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
comment|/* Check the next character by Unicode property. We will get here only     if the support is in the binary; otherwise a compile-time error occurs. */
case|case
name|OP_PROP
case|:
case|case
name|OP_NOTPROP
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
block|{
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ecode
index|[
literal|1
index|]
condition|)
block|{
case|case
name|PT_ANY
case|:
if|if
condition|(
name|op
operator|==
name|OP_NOTPROP
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_LAMP
case|:
if|if
condition|(
operator|(
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_NOTPROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_GC
case|:
if|if
condition|(
operator|(
name|ecode
index|[
literal|2
index|]
operator|!=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_PROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_PC
case|:
if|if
condition|(
operator|(
name|ecode
index|[
literal|2
index|]
operator|!=
name|prop
operator|->
name|chartype
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_PROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
if|if
condition|(
operator|(
name|ecode
index|[
literal|2
index|]
operator|!=
name|prop
operator|->
name|script
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_PROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
comment|/* These are specials */
case|case
name|PT_ALNUM
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_NOTPROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,         which means that Perl space and POSIX space are now identical. PCRE         was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
if|if
condition|(
name|op
operator|==
name|OP_NOTPROP
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_NOTPROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PT_WORD
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_NOTPROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_CLIST
case|:
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|ecode
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_PROP
condition|)
block|{
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_PROP
condition|)
break|break;
else|else
block|{
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PT_UCNC
case|:
if|if
condition|(
operator|(
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
operator|)
operator|==
operator|(
name|op
operator|==
name|OP_NOTPROP
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
comment|/* This should never occur */
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
name|ecode
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
comment|/* Match an extended Unicode sequence. We will get here only if the support     is in the binary; otherwise a compile-time error occurs. */
case|case
name|OP_EXTUNI
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
condition|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
comment|/* Match a back reference, possibly repeatedly. Look past the end of the     item to see if there is repeat information following. The code is similar     to that for character classes, but repeated for efficiency. Then obey     similar code to character type repeats - written out again for speed.     However, if the referenced string is the empty string, always treat     it as matched, any number of times (otherwise there could be infinite     loops). If the reference is unset, there are two possibilities:      (a) In the default, Perl-compatible state, set the length negative;     this ensures that every attempt at a match fails. We can't just fail     here, because of the possibility of quantifiers with zero minima.      (b) If the JavaScript compatibility flag is set, set the length to zero     so that the back reference matches an empty string.      Otherwise, set the length to the length of what was matched by the     referenced subpattern.      The OP_REF and OP_REFI opcodes are used for a reference to a numbered group     or to a non-duplicated named group. For a duplicated named group, OP_DNREF     and OP_DNREFI are used. In this case we must scan the list of groups to     which the name refers, and use the first one that is set. */
case|case
name|OP_DNREF
case|:
case|case
name|OP_DNREFI
case|:
name|caseless
operator|=
name|op
operator|==
name|OP_DNREFI
expr_stmt|;
block|{
name|int
name|count
init|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
decl_stmt|;
name|pcre_uchar
modifier|*
name|slot
init|=
name|md
operator|->
name|name_table
operator|+
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
operator|*
name|md
operator|->
name|name_entry_size
decl_stmt|;
name|ecode
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
comment|/* Setting the default length first and initializing 'offset' avoids       compiler warnings in the REF_REPEAT code. */
name|length
operator|=
operator|(
name|md
operator|->
name|jscript_compat
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|offset
operator|=
name|GET2
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|offset_top
operator|&&
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|>=
literal|0
condition|)
block|{
name|length
operator|=
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
operator|-
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
expr_stmt|;
break|break;
block|}
name|slot
operator|+=
name|md
operator|->
name|name_entry_size
expr_stmt|;
block|}
block|}
goto|goto
name|REF_REPEAT
goto|;
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
name|caseless
operator|=
name|op
operator|==
name|OP_REFI
expr_stmt|;
name|offset
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
expr_stmt|;
comment|/* Doubled ref number */
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|offset_top
operator|||
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
operator|<
literal|0
condition|)
name|length
operator|=
operator|(
name|md
operator|->
name|jscript_compat
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
else|else
name|length
operator|=
name|md
operator|->
name|offset_vector
index|[
name|offset
operator|+
literal|1
index|]
operator|-
name|md
operator|->
name|offset_vector
index|[
name|offset
index|]
expr_stmt|;
comment|/* Set up for repetition, or handle the non-repeated case */
name|REF_REPEAT
label|:
switch|switch
condition|(
operator|*
name|ecode
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
name|c
operator|=
operator|*
name|ecode
operator|++
operator|-
name|OP_CRSTAR
expr_stmt|;
name|minimize
operator|=
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|min
operator|=
name|rep_min
index|[
name|c
index|]
expr_stmt|;
comment|/* Pick up values from tables; */
name|max
operator|=
name|rep_max
index|[
name|c
index|]
expr_stmt|;
comment|/* zero for max => infinity */
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
name|minimize
operator|=
operator|(
operator|*
name|ecode
operator|==
name|OP_CRMINRANGE
operator|)
expr_stmt|;
name|min
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
comment|/* No repeat follows */
if|if
condition|(
operator|(
name|length
operator|=
name|match_ref
argument_list|(
name|offset
argument_list|,
name|eptr
argument_list|,
name|length
argument_list|,
name|md
argument_list|,
name|caseless
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|==
operator|-
literal|2
condition|)
name|eptr
operator|=
name|md
operator|->
name|end_subject
expr_stmt|;
comment|/* Partial match */
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|+=
name|length
expr_stmt|;
continue|continue;
comment|/* With the main loop */
block|}
comment|/* Handle repeated back references. If the length of the reference is     zero, just continue with the main loop. If the length is negative, it     means the reference is unset in non-Java-compatible mode. If the minimum is     zero, we can continue at the same level without recursion. For any other     minimum, carrying on will result in NOMATCH. */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|length
operator|<
literal|0
operator|&&
name|min
operator|==
literal|0
condition|)
continue|continue;
comment|/* First, ensure the minimum number of matches are present. We get back     the length of the reference string explicitly rather than passing the     address of eptr, so that eptr can be a register variable. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slength
decl_stmt|;
if|if
condition|(
operator|(
name|slength
operator|=
name|match_ref
argument_list|(
name|offset
argument_list|,
name|eptr
argument_list|,
name|length
argument_list|,
name|md
argument_list|,
name|caseless
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|slength
operator|==
operator|-
literal|2
condition|)
name|eptr
operator|=
name|md
operator|->
name|end_subject
expr_stmt|;
comment|/* Partial match */
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|+=
name|slength
expr_stmt|;
block|}
comment|/* If min = max, continue at the same level without recursion.     They are not both allowed to be zero. */
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
comment|/* If minimizing, keep trying and advancing the pointer */
if|if
condition|(
name|minimize
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|int
name|slength
decl_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM14
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slength
operator|=
name|match_ref
argument_list|(
name|offset
argument_list|,
name|eptr
argument_list|,
name|length
argument_list|,
name|md
argument_list|,
name|caseless
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|slength
operator|==
operator|-
literal|2
condition|)
name|eptr
operator|=
name|md
operator|->
name|end_subject
expr_stmt|;
comment|/* Partial match */
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|+=
name|slength
expr_stmt|;
block|}
comment|/* Control never gets here */
block|}
comment|/* If maximizing, find the longest string and work backwards */
else|else
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slength
decl_stmt|;
if|if
condition|(
operator|(
name|slength
operator|=
name|match_ref
argument_list|(
name|offset
argument_list|,
name|eptr
argument_list|,
name|length
argument_list|,
name|md
argument_list|,
name|caseless
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Can't use CHECK_PARTIAL because we don't want to update eptr in           the soft partial matching case. */
if|if
condition|(
name|slength
operator|==
operator|-
literal|2
operator|&&
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
name|md
operator|->
name|end_subject
operator|>
name|md
operator|->
name|start_used_ptr
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|eptr
operator|+=
name|slength
expr_stmt|;
block|}
while|while
condition|(
name|eptr
operator|>=
name|pp
condition|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM15
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|-=
name|length
expr_stmt|;
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
comment|/* Match a bit-mapped character class, possibly repeatedly. This op code is     used when all the characters in the class have values in the range 0-255,     and either the matching is caseful, or the characters are in the range     0-127 when UTF-8 processing is enabled. The only difference between     OP_CLASS and OP_NCLASS occurs when a data character outside the range is     encountered.      First, look past the end of the item to see if there is repeat information     following. Then obey similar code to character type repeats - written out     again for speed. */
case|case
name|OP_NCLASS
case|:
case|case
name|OP_CLASS
case|:
block|{
comment|/* The data variable is saved across frames, so the byte map needs to       be stored there. */
DECL|macro|BYTE_MAP
define|#
directive|define
name|BYTE_MAP
value|((pcre_uint8 *)data)
name|data
operator|=
name|ecode
operator|+
literal|1
expr_stmt|;
comment|/* Save for matching */
name|ecode
operator|+=
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
expr_stmt|;
comment|/* Advance past the item */
switch|switch
condition|(
operator|*
name|ecode
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
case|case
name|OP_CRPOSSTAR
case|:
case|case
name|OP_CRPOSPLUS
case|:
case|case
name|OP_CRPOSQUERY
case|:
name|c
operator|=
operator|*
name|ecode
operator|++
operator|-
name|OP_CRSTAR
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|OP_CRPOSSTAR
operator|-
name|OP_CRSTAR
condition|)
name|minimize
operator|=
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
else|else
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
name|rep_min
index|[
name|c
index|]
expr_stmt|;
comment|/* Pick up values from tables; */
name|max
operator|=
name|rep_max
index|[
name|c
index|]
expr_stmt|;
comment|/* zero for max => infinity */
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
case|case
name|OP_CRPOSRANGE
case|:
name|minimize
operator|=
operator|(
operator|*
name|ecode
operator|==
name|OP_CRMINRANGE
operator|)
expr_stmt|;
name|possessive
operator|=
operator|(
operator|*
name|ecode
operator|==
name|OP_CRPOSRANGE
operator|)
expr_stmt|;
name|min
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
comment|/* No repeat follows */
name|min
operator|=
name|max
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* First, ensure the minimum number of matches are present. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_CLASS
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|BYTE_MAP
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|eptr
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
if|if
condition|(
name|c
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_CLASS
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|BYTE_MAP
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If max == min we can continue with the main loop without the       need to recurse. */
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
comment|/* If minimizing, keep testing the rest of the expression and advancing       the pointer while it matches the class. */
if|if
condition|(
name|minimize
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM16
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_CLASS
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|BYTE_MAP
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM17
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|eptr
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
if|if
condition|(
name|c
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_CLASS
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|BYTE_MAP
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Control never gets here */
block|}
comment|/* If maximizing, find the longest possible run, then work backwards. */
else|else
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_CLASS
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|BYTE_MAP
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM18
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|--
operator|==
name|pp
condition|)
break|break;
comment|/* Stop if tried at original pos */
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
if|if
condition|(
name|c
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_CLASS
condition|)
break|break;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|BYTE_MAP
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
while|while
condition|(
name|eptr
operator|>=
name|pp
condition|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM19
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
block|}
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
DECL|macro|BYTE_MAP
undef|#
directive|undef
name|BYTE_MAP
block|}
comment|/* Control never gets here */
comment|/* Match an extended character class. In the 8-bit library, this opcode is     encountered only when UTF-8 mode mode is supported. In the 16-bit and     32-bit libraries, codepoints greater than 255 may be encountered even when     UTF is not supported. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
block|{
name|data
operator|=
name|ecode
operator|+
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
comment|/* Save for matching */
name|ecode
operator|+=
name|GET
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Advance past the item */
switch|switch
condition|(
operator|*
name|ecode
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
case|case
name|OP_CRPOSSTAR
case|:
case|case
name|OP_CRPOSPLUS
case|:
case|case
name|OP_CRPOSQUERY
case|:
name|c
operator|=
operator|*
name|ecode
operator|++
operator|-
name|OP_CRSTAR
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|OP_CRPOSSTAR
operator|-
name|OP_CRSTAR
condition|)
name|minimize
operator|=
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
else|else
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
name|rep_min
index|[
name|c
index|]
expr_stmt|;
comment|/* Pick up values from tables; */
name|max
operator|=
name|rep_max
index|[
name|c
index|]
expr_stmt|;
comment|/* zero for max => infinity */
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
case|case
name|OP_CRPOSRANGE
case|:
name|minimize
operator|=
operator|(
operator|*
name|ecode
operator|==
name|OP_CRMINRANGE
operator|)
expr_stmt|;
name|possessive
operator|=
operator|(
operator|*
name|ecode
operator|==
name|OP_CRPOSRANGE
operator|)
expr_stmt|;
name|min
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
comment|/* No repeat follows */
name|min
operator|=
name|max
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* First, ensure the minimum number of matches are present. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PRIV
argument_list|(
name|xclass
argument_list|)
argument_list|(
name|c
argument_list|,
name|data
argument_list|,
name|utf
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* If max == min we can continue with the main loop without the       need to recurse. */
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
comment|/* If minimizing, keep testing the rest of the expression and advancing       the pointer while it matches the class. */
if|if
condition|(
name|minimize
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM20
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PRIV
argument_list|(
name|xclass
argument_list|)
argument_list|(
name|c
argument_list|,
name|data
argument_list|,
name|utf
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
block|}
comment|/* If maximizing, find the longest possible run, then work backwards. */
else|else
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|PRIV
argument_list|(
name|xclass
argument_list|)
argument_list|(
name|c
argument_list|,
name|data
argument_list|,
name|utf
argument_list|)
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM21
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|--
operator|==
name|pp
condition|)
break|break;
comment|/* Stop if tried at original pos */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
block|}
endif|#
directive|endif
comment|/* End of XCLASS */
comment|/* Match a single character, casefully */
case|case
name|OP_CHAR
case|:
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|length
operator|=
literal|1
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
name|GETCHARLEN
argument_list|(
name|fc
argument_list|,
name|ecode
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|md
operator|->
name|end_subject
operator|-
name|eptr
condition|)
block|{
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
comment|/* Not SCHECK_PARTIAL() */
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|ecode
operator|++
operator|!=
name|UCHAR21INC
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
if|if
condition|(
name|md
operator|->
name|end_subject
operator|-
name|eptr
operator|<
literal|1
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
comment|/* This one can use SCHECK_PARTIAL() */
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecode
index|[
literal|1
index|]
operator|!=
operator|*
name|eptr
operator|++
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
comment|/* Match a single character, caselessly. If we are at the end of the     subject, give up immediately. */
case|case
name|OP_CHARI
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|length
operator|=
literal|1
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
name|GETCHARLEN
argument_list|(
name|fc
argument_list|,
name|ecode
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* If the pattern character's value is< 128, we have only one byte, and       we know that its other case must also be one byte long, so we can use the       fast lookup table. We know that there is at least one byte left in the       subject. */
if|if
condition|(
name|fc
operator|<
literal|128
condition|)
block|{
name|pcre_uint32
name|cc
init|=
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|md
operator|->
name|lcc
index|[
name|fc
index|]
operator|!=
name|TABLE_GET
argument_list|(
name|cc
argument_list|,
name|md
operator|->
name|lcc
argument_list|,
name|cc
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
comment|/* Otherwise we must pick up the subject character. Note that we cannot       use the value of "length" to check for sufficient bytes left, because the       other case of the character may have more or fewer bytes.  */
else|else
block|{
name|pcre_uint32
name|dc
decl_stmt|;
name|GETCHARINC
argument_list|(
name|dc
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|ecode
operator|+=
name|length
expr_stmt|;
comment|/* If we have Unicode property support, we can use it to test the other         case of the character, if there is one. */
if|if
condition|(
name|fc
operator|!=
name|dc
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|dc
operator|!=
name|UCD_OTHERCASE
argument_list|(
name|fc
argument_list|)
condition|)
endif|#
directive|endif
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Not UTF mode */
block|{
if|if
condition|(
name|TABLE_GET
argument_list|(
name|ecode
index|[
literal|1
index|]
argument_list|,
name|md
operator|->
name|lcc
argument_list|,
name|ecode
index|[
literal|1
index|]
argument_list|)
operator|!=
name|TABLE_GET
argument_list|(
operator|*
name|eptr
argument_list|,
name|md
operator|->
name|lcc
argument_list|,
operator|*
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
name|ecode
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
comment|/* Match a single character repeatedly. */
case|case
name|OP_EXACT
case|:
case|case
name|OP_EXACTI
case|:
name|min
operator|=
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATCHAR
goto|;
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_POSUPTOI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_UPTO
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_MINUPTOI
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|minimize
operator|=
operator|*
name|ecode
operator|==
name|OP_MINUPTO
operator|||
operator|*
name|ecode
operator|==
name|OP_MINUPTOI
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATCHAR
goto|;
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSSTARI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATCHAR
goto|;
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSPLUSI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|1
expr_stmt|;
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATCHAR
goto|;
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSQUERYI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|1
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATCHAR
goto|;
case|case
name|OP_STAR
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_MINQUERYI
case|:
name|c
operator|=
operator|*
name|ecode
operator|++
operator|-
operator|(
operator|(
name|op
operator|<
name|OP_STARI
operator|)
condition|?
name|OP_STAR
else|:
name|OP_STARI
operator|)
expr_stmt|;
name|minimize
operator|=
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|min
operator|=
name|rep_min
index|[
name|c
index|]
expr_stmt|;
comment|/* Pick up values from tables; */
name|max
operator|=
name|rep_max
index|[
name|c
index|]
expr_stmt|;
comment|/* zero for max => infinity */
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
comment|/* Common code for all repeated single-character matches. We first check     for the minimum number of characters. If the minimum equals the maximum, we     are done. Otherwise, if minimizing, check the rest of the pattern for a     match; if there isn't one, advance up to the maximum, one character at a     time.      If maximizing, advance up to the maximum number of matching characters,     until eptr is past the end of the maximum run. If possessive, we are     then done (no backing up). Otherwise, match at this position; anything     other than no match is immediately returned. For nomatch, back up one     character, unless we are matching \R and the last thing matched was     \r\n, in which case, back up two bytes. When we reach the first optional     character position, we can save stack by doing a tail recurse.      The various UTF/non-UTF and caseful/caseless cases are handled separately,     for speed. */
name|REPEATCHAR
label|:
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|length
operator|=
literal|1
expr_stmt|;
name|charptr
operator|=
name|ecode
expr_stmt|;
name|GETCHARLEN
argument_list|(
name|fc
argument_list|,
name|ecode
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ecode
operator|+=
name|length
expr_stmt|;
comment|/* Handle multibyte character matching specially here. There is       support for caseless matching if UCP support is present. */
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|pcre_uint32
name|othercase
decl_stmt|;
if|if
condition|(
name|op
operator|>=
name|OP_STARI
operator|&&
comment|/* Caseless */
operator|(
name|othercase
operator|=
name|UCD_OTHERCASE
argument_list|(
name|fc
argument_list|)
operator|)
operator|!=
name|fc
condition|)
name|oclength
operator|=
name|PRIV
argument_list|(
name|ord2utf
argument_list|)
argument_list|(
name|othercase
argument_list|,
name|occhars
argument_list|)
expr_stmt|;
else|else
name|oclength
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|md
operator|->
name|end_subject
operator|-
name|length
operator|&&
name|memcmp
argument_list|(
name|eptr
argument_list|,
name|charptr
argument_list|,
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|eptr
operator|+=
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
elseif|else
if|if
condition|(
name|oclength
operator|>
literal|0
operator|&&
name|eptr
operator|<=
name|md
operator|->
name|end_subject
operator|-
name|oclength
operator|&&
name|memcmp
argument_list|(
name|eptr
argument_list|,
name|occhars
argument_list|,
name|IN_UCHARS
argument_list|(
name|oclength
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|eptr
operator|+=
name|oclength
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
else|else
block|{
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
if|if
condition|(
name|minimize
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM22
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|<=
name|md
operator|->
name|end_subject
operator|-
name|length
operator|&&
name|memcmp
argument_list|(
name|eptr
argument_list|,
name|charptr
argument_list|,
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|eptr
operator|+=
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
elseif|else
if|if
condition|(
name|oclength
operator|>
literal|0
operator|&&
name|eptr
operator|<=
name|md
operator|->
name|end_subject
operator|-
name|oclength
operator|&&
name|memcmp
argument_list|(
name|eptr
argument_list|,
name|occhars
argument_list|,
name|IN_UCHARS
argument_list|(
name|oclength
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|eptr
operator|+=
name|oclength
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
else|else
block|{
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Control never gets here */
block|}
else|else
comment|/* Maximize */
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|md
operator|->
name|end_subject
operator|-
name|length
operator|&&
name|memcmp
argument_list|(
name|eptr
argument_list|,
name|charptr
argument_list|,
name|IN_UCHARS
argument_list|(
name|length
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|eptr
operator|+=
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
elseif|else
if|if
condition|(
name|oclength
operator|>
literal|0
operator|&&
name|eptr
operator|<=
name|md
operator|->
name|end_subject
operator|-
name|oclength
operator|&&
name|memcmp
argument_list|(
name|eptr
argument_list|,
name|occhars
argument_list|,
name|IN_UCHARS
argument_list|(
name|oclength
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|eptr
operator|+=
name|oclength
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
else|else
block|{
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM23
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|eptr
operator|--
expr_stmt|;
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* without SUPPORT_UCP */
name|eptr
operator|-=
name|length
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
block|}
comment|/* Control never gets here */
block|}
comment|/* If the length of a UTF-8 character is 1, we fall through here, and       obey the code as for non-UTF-8 characters below, though in this case the       value of fc will always be< 128. */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* When not in UTF-8 mode, load a single-byte character. */
name|fc
operator|=
operator|*
name|ecode
operator|++
expr_stmt|;
comment|/* The value of fc at this point is always one character, though we may     or may not be in UTF mode. The code is duplicated for the caseless and     caseful cases, for speed, since matching characters is likely to be quite     common. First, ensure the minimum number of matches are present. If min =     max, continue at the same level without recursing. Otherwise, if     minimizing, keep trying the rest of the expression and advancing one     matching character if failing, up to the maximum. Alternatively, if     maximizing, find the maximum number of characters and work backwards. */
name|DPRINTF
argument_list|(
operator|(
literal|"matching %c{%d,%d} against subject %.*s\n"
operator|,
name|fc
operator|,
name|min
operator|,
name|max
operator|,
name|max
operator|,
operator|(
name|char
operator|*
operator|)
name|eptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|OP_STARI
condition|)
comment|/* Caseless */
block|{
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
comment|/* fc must be< 128 if UTF is enabled. */
name|foc
operator|=
name|md
operator|->
name|fcc
index|[
name|fc
index|]
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|SUPPORT_UTF
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|utf
operator|&&
name|fc
operator|>
literal|127
condition|)
name|foc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|fc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|utf
operator|&&
name|fc
operator|>
literal|127
condition|)
name|foc
operator|=
name|fc
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|foc
operator|=
name|TABLE_GET
argument_list|(
name|fc
argument_list|,
name|md
operator|->
name|fcc
argument_list|,
name|fc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE8 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
comment|/* Faster than pcre_uchar */
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|!=
name|cc
operator|&&
name|foc
operator|!=
name|cc
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
if|if
condition|(
name|minimize
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
comment|/* Faster than pcre_uchar */
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM24
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|!=
name|cc
operator|&&
name|foc
operator|!=
name|cc
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
comment|/* Control never gets here */
block|}
else|else
comment|/* Maximize */
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
comment|/* Faster than pcre_uchar */
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|cc
operator|=
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|!=
name|cc
operator|&&
name|foc
operator|!=
name|cc
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|==
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM25
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
block|}
block|}
comment|/* Caseful comparisons (includes all multi-byte characters) */
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|!=
name|UCHAR21INCTEST
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
if|if
condition|(
name|minimize
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM26
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|!=
name|UCHAR21INCTEST
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
block|}
else|else
comment|/* Maximize */
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fc
operator|!=
name|UCHAR21TEST
argument_list|(
name|eptr
argument_list|)
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|==
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM27
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
block|}
block|}
comment|/* Control never gets here */
comment|/* Match a negated single one-byte character. The character we are     checking can be multibyte. */
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
specifier|register
name|pcre_uint32
name|ch
decl_stmt|,
name|och
decl_stmt|;
name|ecode
operator|++
expr_stmt|;
name|GETCHARINC
argument_list|(
name|ch
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_NOT
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|c
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|ch
operator|>
literal|127
condition|)
name|och
operator|=
name|UCD_OTHERCASE
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ch
operator|>
literal|127
condition|)
name|och
operator|=
name|ch
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
else|else
name|och
operator|=
name|TABLE_GET
argument_list|(
name|ch
argument_list|,
name|md
operator|->
name|fcc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|c
operator|||
name|och
operator|==
name|c
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
specifier|register
name|pcre_uint32
name|ch
init|=
name|ecode
index|[
literal|1
index|]
decl_stmt|;
name|c
operator|=
operator|*
name|eptr
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|c
operator|||
operator|(
name|op
operator|==
name|OP_NOTI
operator|&&
name|TABLE_GET
argument_list|(
name|ch
argument_list|,
name|md
operator|->
name|fcc
argument_list|,
name|ch
argument_list|)
operator|==
name|c
operator|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
comment|/* Match a negated single one-byte character repeatedly. This is almost a     repeat of the code for a repeated single character, but I haven't found a     nice way of commoning these up that doesn't require a test of the     positive/negative option for each character match. Maybe that wouldn't add     very much to the time taken, but character matching *is* what this is all     about... */
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTEXACTI
case|:
name|min
operator|=
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATNOTCHAR
goto|;
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTMINUPTOI
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|minimize
operator|=
operator|*
name|ecode
operator|==
name|OP_NOTMINUPTO
operator|||
operator|*
name|ecode
operator|==
name|OP_NOTMINUPTOI
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATNOTCHAR
goto|;
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSSTARI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATNOTCHAR
goto|;
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|1
expr_stmt|;
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATNOTCHAR
goto|;
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|1
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATNOTCHAR
goto|;
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATNOTCHAR
goto|;
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTMINQUERYI
case|:
name|c
operator|=
operator|*
name|ecode
operator|++
operator|-
operator|(
operator|(
name|op
operator|>=
name|OP_NOTSTARI
operator|)
condition|?
name|OP_NOTSTARI
else|:
name|OP_NOTSTAR
operator|)
expr_stmt|;
name|minimize
operator|=
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|min
operator|=
name|rep_min
index|[
name|c
index|]
expr_stmt|;
comment|/* Pick up values from tables; */
name|max
operator|=
name|rep_max
index|[
name|c
index|]
expr_stmt|;
comment|/* zero for max => infinity */
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
comment|/* Common code for all repeated single-byte matches. */
name|REPEATNOTCHAR
label|:
name|GETCHARINCTEST
argument_list|(
name|fc
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
comment|/* The code is duplicated for the caseless and caseful cases, for speed,     since matching characters is likely to be quite common. First, ensure the     minimum number of matches are present. If min = max, continue at the same     level without recursing. Otherwise, if minimizing, keep trying the rest of     the expression and advancing one matching character if failing, up to the     maximum. Alternatively, if maximizing, find the maximum number of     characters and work backwards. */
name|DPRINTF
argument_list|(
operator|(
literal|"negative matching %c{%d,%d} against subject %.*s\n"
operator|,
name|fc
operator|,
name|min
operator|,
name|max
operator|,
name|max
operator|,
operator|(
name|char
operator|*
operator|)
name|eptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|OP_NOTSTARI
condition|)
comment|/* Caseless */
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|utf
operator|&&
name|fc
operator|>
literal|127
condition|)
name|foc
operator|=
name|UCD_OTHERCASE
argument_list|(
name|fc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|utf
operator|&&
name|fc
operator|>
literal|127
condition|)
name|foc
operator|=
name|fc
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|foc
operator|=
name|TABLE_GET
argument_list|(
name|fc
argument_list|,
name|md
operator|->
name|fcc
argument_list|,
name|fc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
specifier|register
name|pcre_uint32
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|d
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|d
operator|||
operator|(
name|unsigned
name|int
operator|)
name|foc
operator|==
name|d
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Not UTF mode */
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|==
operator|*
name|eptr
operator|||
name|foc
operator|==
operator|*
name|eptr
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
if|if
condition|(
name|minimize
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
specifier|register
name|pcre_uint32
name|d
decl_stmt|;
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM28
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|d
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|d
operator|||
operator|(
name|unsigned
name|int
operator|)
name|foc
operator|==
name|d
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/*SUPPORT_UTF */
comment|/* Not UTF mode */
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM29
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|==
operator|*
name|eptr
operator|||
name|foc
operator|==
operator|*
name|eptr
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
block|}
comment|/* Control never gets here */
block|}
comment|/* Maximize case */
else|else
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
specifier|register
name|pcre_uint32
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|d
operator|||
operator|(
name|unsigned
name|int
operator|)
name|foc
operator|==
name|d
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM30
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Not UTF mode */
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fc
operator|==
operator|*
name|eptr
operator|||
name|foc
operator|==
operator|*
name|eptr
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|==
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM31
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
block|}
block|}
comment|/* Control never gets here */
block|}
block|}
comment|/* Caseful comparisons */
else|else
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
specifier|register
name|pcre_uint32
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|d
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|d
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|==
operator|*
name|eptr
operator|++
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
if|if
condition|(
name|minimize
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
specifier|register
name|pcre_uint32
name|d
decl_stmt|;
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM32
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|d
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|d
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM33
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|==
operator|*
name|eptr
operator|++
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Control never gets here */
block|}
comment|/* Maximize case */
else|else
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
specifier|register
name|pcre_uint32
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|d
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM34
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fc
operator|==
operator|*
name|eptr
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|==
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM35
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
block|}
block|}
comment|/* Control never gets here */
block|}
block|}
comment|/* Control never gets here */
comment|/* Match a single character type repeatedly; several different opcodes     share code. This is very similar to the code for single characters, but we     repeat it in the interests of efficiency. */
case|case
name|OP_TYPEEXACT
case|:
name|min
operator|=
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|minimize
operator|=
name|TRUE
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATTYPE
goto|;
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|minimize
operator|=
operator|*
name|ecode
operator|==
name|OP_TYPEMINUPTO
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATTYPE
goto|;
case|case
name|OP_TYPEPOSSTAR
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATTYPE
goto|;
case|case
name|OP_TYPEPOSPLUS
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|1
expr_stmt|;
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATTYPE
goto|;
case|case
name|OP_TYPEPOSQUERY
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|1
expr_stmt|;
name|ecode
operator|++
expr_stmt|;
goto|goto
name|REPEATTYPE
goto|;
case|case
name|OP_TYPEPOSUPTO
case|:
name|possessive
operator|=
name|TRUE
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecode
operator|+=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
goto|goto
name|REPEATTYPE
goto|;
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
name|c
operator|=
operator|*
name|ecode
operator|++
operator|-
name|OP_TYPESTAR
expr_stmt|;
name|minimize
operator|=
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|min
operator|=
name|rep_min
index|[
name|c
index|]
expr_stmt|;
comment|/* Pick up values from tables; */
name|max
operator|=
name|rep_max
index|[
name|c
index|]
expr_stmt|;
comment|/* zero for max => infinity */
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|max
operator|=
name|INT_MAX
expr_stmt|;
comment|/* Common code for all repeated single character type matches. Note that     in UTF-8 mode, '.' matches a character of any length, but for the other     character types, the valid characters are all one-byte long. */
name|REPEATTYPE
label|:
name|ctype
operator|=
operator|*
name|ecode
operator|++
expr_stmt|;
comment|/* Code for the character type */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|ctype
operator|==
name|OP_PROP
operator|||
name|ctype
operator|==
name|OP_NOTPROP
condition|)
block|{
name|prop_fail_result
operator|=
name|ctype
operator|==
name|OP_NOTPROP
expr_stmt|;
name|prop_type
operator|=
operator|*
name|ecode
operator|++
expr_stmt|;
name|prop_value
operator|=
operator|*
name|ecode
operator|++
expr_stmt|;
block|}
else|else
name|prop_type
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* First, ensure the minimum number of matches are present. Use inline     code for maximizing the speed, and do the type test once at the start     (i.e. keep it out of the loop). Separate the UTF-8 code completely as that     is tidier. Also separate the UCP code, which can be the same for both UTF-8     and single-bytes. */
if|if
condition|(
name|min
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|prop_type
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PT_ANY
case|:
if|if
condition|(
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PT_LAMP
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|int
name|chartype
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|chartype
operator|=
name|UCD_CHARTYPE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chartype
operator|==
name|ucp_Lu
operator|||
name|chartype
operator|==
name|ucp_Ll
operator|||
name|chartype
operator|==
name|ucp_Lt
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PT_GC
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PT_PC
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_CHARTYPE
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PT_SC
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_SCRIPT
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PT_ALNUM
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|int
name|category
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|category
operator|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|==
name|ucp_L
operator|||
name|category
operator|==
name|ucp_N
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,           which means that Perl space and POSIX space are now identical. PCRE           was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
if|if
condition|(
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
operator|==
name|ucp_Z
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PT_WORD
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|int
name|category
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|category
operator|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|==
name|ucp_L
operator|||
name|category
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PT_CLIST
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|prop_value
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|prop_fail_result
condition|)
break|break;
else|else
block|{
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|prop_fail_result
condition|)
block|{
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
block|}
break|break;
case|case
name|PT_UCNC
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* This should not occur */
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Match extended Unicode sequences. We will get here only if the       support is in the binary; otherwise a compile-time error occurs. */
elseif|else
if|if
condition|(
name|ctype
operator|==
name|OP_EXTUNI
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
condition|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* SUPPORT_UCP */
comment|/* Handle all other cases when the coding is UTF-8 */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|OP_ANY
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
name|eptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
argument_list|,
operator|*
name|eptr
argument_list|,
name|eptr
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ALLANY
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
argument_list|,
operator|*
name|eptr
argument_list|,
name|eptr
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ANYBYTE
case|:
if|if
condition|(
name|eptr
operator|>
name|md
operator|->
name|end_subject
operator|-
name|min
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|+=
name|min
expr_stmt|;
break|break;
case|case
name|OP_ANYNL
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
operator|&&
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
operator|==
name|CHAR_LF
condition|)
name|eptr
operator|++
expr_stmt|;
break|break;
case|case
name|CHAR_LF
case|:
break|break;
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
ifndef|#
directive|ifndef
name|EBCDIC
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
comment|/* Not EBCDIC */
if|if
condition|(
name|md
operator|->
name|bsr_anycrlf
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|OP_NOT_HSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
comment|/* Byte and multibyte cases */
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|OP_HSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
break|break;
comment|/* Byte and multibyte cases */
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_NOT_VSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|OP_VSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
break|break;
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_NOT_DIGIT
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|128
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_DIGIT
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|>=
literal|128
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|cc
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
comment|/* No need to skip more bytes - we know it's a 1-byte character */
block|}
break|break;
case|case
name|OP_NOT_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|128
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|cc
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
argument_list|,
operator|*
name|eptr
argument_list|,
name|eptr
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|>=
literal|128
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|cc
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
comment|/* No need to skip more bytes - we know it's a 1-byte character */
block|}
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|128
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|cc
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
argument_list|,
operator|*
name|eptr
argument_list|,
name|eptr
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|>=
literal|128
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|cc
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
comment|/* No need to skip more bytes - we know it's a 1-byte character */
block|}
break|break;
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
comment|/* End switch(ctype) */
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Code for the non-UTF-8 case for minimum matching of operators other       than OP_PROP and OP_NOTPROP. */
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|OP_ANY
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
name|eptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
operator|*
name|eptr
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_ALLANY
case|:
if|if
condition|(
name|eptr
operator|>
name|md
operator|->
name|end_subject
operator|-
name|min
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|+=
name|min
expr_stmt|;
break|break;
case|case
name|OP_ANYBYTE
case|:
if|if
condition|(
name|eptr
operator|>
name|md
operator|->
name|end_subject
operator|-
name|min
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|+=
name|min
expr_stmt|;
break|break;
case|case
name|OP_ANYNL
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|eptr
operator|++
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
operator|&&
operator|*
name|eptr
operator|==
name|CHAR_LF
condition|)
name|eptr
operator|++
expr_stmt|;
break|break;
case|case
name|CHAR_LF
case|:
break|break;
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
if|if
condition|(
name|md
operator|->
name|bsr_anycrlf
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|OP_NOT_HSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|eptr
operator|++
condition|)
block|{
default|default:
break|break;
name|HSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|HSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_HSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|eptr
operator|++
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|HSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|HSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
break|break;
block|}
block|}
break|break;
case|case
name|OP_NOT_VSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|eptr
operator|++
condition|)
block|{
name|VSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|VSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|OP_VSPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|eptr
operator|++
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|VSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|VSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
break|break;
block|}
block|}
break|break;
case|case
name|OP_NOT_DIGIT
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_DIGIT
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If min = max, continue at the same level without recursing */
if|if
condition|(
name|min
operator|==
name|max
condition|)
continue|continue;
comment|/* If minimizing, we have to test the rest of the pattern before each     subsequent match. Again, separate the UTF-8 case for speed, and also     separate the UCP cases. */
if|if
condition|(
name|minimize
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|prop_type
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PT_ANY
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM36
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
case|case
name|PT_LAMP
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|int
name|chartype
decl_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM37
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|chartype
operator|=
name|UCD_CHARTYPE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chartype
operator|==
name|ucp_Lu
operator|||
name|chartype
operator|==
name|ucp_Ll
operator|||
name|chartype
operator|==
name|ucp_Lt
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
case|case
name|PT_GC
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM38
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
case|case
name|PT_PC
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM39
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_CHARTYPE
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
case|case
name|PT_SC
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM40
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_SCRIPT
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
case|case
name|PT_ALNUM
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|int
name|category
decl_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM59
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|category
operator|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|==
name|ucp_L
operator|||
name|category
operator|==
name|ucp_N
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,           which means that Perl space and POSIX space are now identical. PCRE           was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM61
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
if|if
condition|(
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
operator|==
name|ucp_Z
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Control never gets here */
case|case
name|PT_WORD
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|int
name|category
decl_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM62
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|category
operator|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|==
name|ucp_L
operator|||
name|category
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
case|case
name|PT_CLIST
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM67
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|prop_value
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|prop_fail_result
condition|)
break|break;
else|else
block|{
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|prop_fail_result
condition|)
block|{
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
block|}
comment|/* Control never gets here */
case|case
name|PT_UCNC
case|:
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM60
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
operator|)
operator|==
name|prop_fail_result
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Control never gets here */
comment|/* This should never occur */
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Match extended Unicode sequences. We will get here only if the       support is in the binary; otherwise a compile-time error occurs. */
elseif|else
if|if
condition|(
name|ctype
operator|==
name|OP_EXTUNI
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM41
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
condition|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* SUPPORT_UCP */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM42
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|OP_ANY
operator|&&
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|GETCHARINC
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|OP_ANY
case|:
comment|/* This is the non-NL case */
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
comment|/* Take care with CRLF partial */
name|eptr
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYBYTE
case|:
break|break;
case|case
name|OP_ANYNL
case|:
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
operator|&&
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
operator|==
name|CHAR_LF
condition|)
name|eptr
operator|++
expr_stmt|;
break|break;
case|case
name|CHAR_LF
case|:
break|break;
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
ifndef|#
directive|ifndef
name|EBCDIC
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
comment|/* Not EBCDIC */
if|if
condition|(
name|md
operator|->
name|bsr_anycrlf
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OP_NOT_HSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
break|break;
case|case
name|OP_HSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
break|break;
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_VSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
break|break;
case|case
name|OP_VSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
break|break;
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_DIGIT
case|:
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DIGIT
case|:
if|if
condition|(
name|c
operator|>=
literal|256
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_WHITESPACE
case|:
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WHITESPACE
case|:
if|if
condition|(
name|c
operator|>=
literal|256
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WORDCHAR
case|:
if|if
condition|(
name|c
operator|>=
literal|256
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Not UTF mode */
block|{
for|for
control|(
name|fi
operator|=
name|min
init|;
condition|;
name|fi
operator|++
control|)
block|{
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM43
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|>=
name|max
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|OP_ANY
operator|&&
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|eptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|OP_ANY
case|:
comment|/* This is the non-NL case */
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
comment|/* Take care with CRLF partial */
name|eptr
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYBYTE
case|:
break|break;
case|case
name|OP_ANYNL
case|:
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
operator|&&
operator|*
name|eptr
operator|==
name|CHAR_LF
condition|)
name|eptr
operator|++
expr_stmt|;
break|break;
case|case
name|CHAR_LF
case|:
break|break;
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
if|if
condition|(
name|md
operator|->
name|bsr_anycrlf
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OP_NOT_HSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
break|break;
name|HSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|HSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_HSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|HSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|HSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
break|break;
block|}
break|break;
case|case
name|OP_NOT_VSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
break|break;
name|VSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|VSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_VSPACE
case|:
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
name|VSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|VSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
break|break;
block|}
break|break;
case|case
name|OP_NOT_DIGIT
case|:
if|if
condition|(
name|MAX_255
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DIGIT
case|:
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_WHITESPACE
case|:
if|if
condition|(
name|MAX_255
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WHITESPACE
case|:
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
if|if
condition|(
name|MAX_255
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WORDCHAR
case|:
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
name|RRETURN
argument_list|(
name|MATCH_NOMATCH
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Control never gets here */
block|}
comment|/* If maximizing, it is worth using inline code for speed, doing the type     test once at the start (i.e. keep it out of the loop). Again, keep the     UTF-8 and UCP stuff separate. */
else|else
block|{
name|pp
operator|=
name|eptr
expr_stmt|;
comment|/* Remember where we started */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|prop_type
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PT_ANY
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|PT_LAMP
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|chartype
decl_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|chartype
operator|=
name|UCD_CHARTYPE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chartype
operator|==
name|ucp_Lu
operator|||
name|chartype
operator|==
name|ucp_Ll
operator|||
name|chartype
operator|==
name|ucp_Lt
operator|)
operator|==
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|PT_GC
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|PT_PC
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_CHARTYPE
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|PT_SC
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|UCD_SCRIPT
argument_list|(
name|c
argument_list|)
operator|==
name|prop_value
operator|)
operator|==
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|PT_ALNUM
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|category
decl_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|category
operator|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|==
name|ucp_L
operator|||
name|category
operator|==
name|ucp_N
operator|)
operator|==
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,           which means that Perl space and POSIX space are now identical. PCRE           was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
if|if
condition|(
name|prop_fail_result
condition|)
goto|goto
name|ENDLOOP99
goto|;
comment|/* Break the loop */
break|break;
default|default:
if|if
condition|(
operator|(
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
operator|==
name|ucp_Z
operator|)
operator|==
name|prop_fail_result
condition|)
goto|goto
name|ENDLOOP99
goto|;
comment|/* Break the loop */
break|break;
block|}
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
name|ENDLOOP99
label|:
break|break;
case|case
name|PT_WORD
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|category
decl_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|category
operator|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|==
name|ucp_L
operator|||
name|category
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
operator|)
operator|==
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|PT_CLIST
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|prop_value
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|prop_fail_result
condition|)
break|break;
else|else
goto|goto
name|GOT_MAX
goto|;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|prop_fail_result
condition|)
goto|goto
name|GOT_MAX
goto|;
else|else
break|break;
block|}
block|}
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
name|GOT_MAX
label|:
break|break;
case|case
name|PT_UCNC
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
operator|)
operator|==
name|prop_fail_result
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
comment|/* eptr is now past the end of the maximum run */
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM44
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
if|if
condition|(
name|utf
condition|)
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Match extended Unicode grapheme clusters. We will get here only if the       support is in the binary; otherwise a compile-time error occurs. */
elseif|else
if|if
condition|(
name|ctype
operator|==
name|OP_EXTUNI
condition|)
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
condition|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|CHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
comment|/* eptr is now past the end of the maximum run */
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
comment|/* We use<= pp rather than == pp to detect the start of the run while         backtracking because the use of \C in UTF mode can cause BACKCHAR to         move back past pp. This is just palliative; the use of \C in UTF mode         is fraught with danger. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
name|PCRE_PUCHAR
name|fptr
decl_stmt|;
if|if
condition|(
name|eptr
operator|<=
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
comment|/* At start of char run */
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM45
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
comment|/* Backtracking over an extended grapheme cluster involves inspecting           the previous two characters (if present) to see if a break is           permitted between them. */
name|eptr
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
else|else
block|{
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
comment|/* At start of char run */
name|fptr
operator|=
name|eptr
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|c
operator|=
operator|*
name|fptr
expr_stmt|;
else|else
block|{
name|BACKCHAR
argument_list|(
name|fptr
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|fptr
argument_list|)
expr_stmt|;
block|}
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|=
name|fptr
expr_stmt|;
name|rgb
operator|=
name|lgb
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* SUPPORT_UCP */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|OP_ANY
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
comment|/* Take care with CRLF partial */
name|eptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
argument_list|,
operator|*
name|eptr
argument_list|,
name|eptr
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ALLANY
case|:
if|if
condition|(
name|max
operator|<
name|INT_MAX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|eptr
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|eptr
operator|<
name|md
operator|->
name|end_subject
argument_list|,
operator|*
name|eptr
argument_list|,
name|eptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|eptr
operator|=
name|md
operator|->
name|end_subject
expr_stmt|;
comment|/* Unlimited UTF-8 repeat */
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* The byte case is the same as non-UTF8 */
case|case
name|OP_ANYBYTE
case|:
name|c
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|c
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|md
operator|->
name|end_subject
operator|-
name|eptr
argument_list|)
condition|)
block|{
name|eptr
operator|=
name|md
operator|->
name|end_subject
expr_stmt|;
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
else|else
name|eptr
operator|+=
name|c
expr_stmt|;
break|break;
case|case
name|OP_ANYNL
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CHAR_CR
condition|)
block|{
if|if
condition|(
operator|++
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
break|break;
if|if
condition|(
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
operator|==
name|CHAR_LF
condition|)
name|eptr
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|!=
name|CHAR_LF
operator|&&
operator|(
name|md
operator|->
name|bsr_anycrlf
operator|||
operator|(
name|c
operator|!=
name|CHAR_VT
operator|&&
name|c
operator|!=
name|CHAR_FF
operator|&&
name|c
operator|!=
name|CHAR_NEL
ifndef|#
directive|ifndef
name|EBCDIC
operator|&&
name|c
operator|!=
literal|0x2028
operator|&&
name|c
operator|!=
literal|0x2029
endif|#
directive|endif
comment|/* Not EBCDIC */
operator|)
operator|)
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|BOOL
name|gotspace
decl_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|gotspace
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|gotspace
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gotspace
operator|==
operator|(
name|ctype
operator|==
name|OP_NOT_HSPACE
operator|)
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|BOOL
name|gotspace
decl_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|gotspace
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|gotspace
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gotspace
operator|==
operator|(
name|ctype
operator|==
name|OP_NOT_VSPACE
operator|)
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_DIGIT
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|OP_DIGIT
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|256
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|OP_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|256
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|OP_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|eptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|256
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|+=
name|len
expr_stmt|;
block|}
break|break;
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|<=
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM46
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
name|BACKCHAR
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|OP_ANYNL
operator|&&
name|eptr
operator|>
name|pp
operator|&&
name|UCHAR21
argument_list|(
name|eptr
argument_list|)
operator|==
name|CHAR_NL
operator|&&
name|UCHAR21
argument_list|(
name|eptr
operator|-
literal|1
argument_list|)
operator|==
name|CHAR_CR
condition|)
name|eptr
operator|--
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Not UTF mode */
block|{
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|OP_ANY
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|eptr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|md
operator|->
name|partial
operator|!=
literal|0
operator|&&
comment|/* Take care with CRLF partial */
name|eptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
operator|*
name|eptr
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|md
operator|->
name|hitend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|partial
operator|>
literal|1
condition|)
name|RRETURN
argument_list|(
name|PCRE_ERROR_PARTIAL
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYBYTE
case|:
name|c
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|c
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|md
operator|->
name|end_subject
operator|-
name|eptr
argument_list|)
condition|)
block|{
name|eptr
operator|=
name|md
operator|->
name|end_subject
expr_stmt|;
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
block|}
else|else
name|eptr
operator|+=
name|c
expr_stmt|;
break|break;
case|case
name|OP_ANYNL
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|eptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CHAR_CR
condition|)
block|{
if|if
condition|(
operator|++
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
break|break;
if|if
condition|(
operator|*
name|eptr
operator|==
name|CHAR_LF
condition|)
name|eptr
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|!=
name|CHAR_LF
operator|&&
operator|(
name|md
operator|->
name|bsr_anycrlf
operator|||
operator|(
name|c
operator|!=
name|CHAR_VT
operator|&&
name|c
operator|!=
name|CHAR_FF
operator|&&
name|c
operator|!=
name|CHAR_NEL
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
operator|&&
name|c
operator|!=
literal|0x2028
operator|&&
name|c
operator|!=
literal|0x2029
endif|#
directive|endif
operator|)
operator|)
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_NOT_HSPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
name|eptr
condition|)
block|{
default|default:
name|eptr
operator|++
expr_stmt|;
break|break;
name|HSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|HSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
goto|goto
name|ENDLOOP00
goto|;
block|}
block|}
name|ENDLOOP00
label|:
break|break;
case|case
name|OP_HSPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
name|eptr
condition|)
block|{
default|default:
goto|goto
name|ENDLOOP01
goto|;
name|HSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|HSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
name|eptr
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|ENDLOOP01
label|:
break|break;
case|case
name|OP_NOT_VSPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
name|eptr
condition|)
block|{
default|default:
name|eptr
operator|++
expr_stmt|;
break|break;
name|VSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|VSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
goto|goto
name|ENDLOOP02
goto|;
block|}
block|}
name|ENDLOOP02
label|:
break|break;
case|case
name|OP_VSPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
name|eptr
condition|)
block|{
default|default:
goto|goto
name|ENDLOOP03
goto|;
name|VSPACE_BYTE_CASES
label|:
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
name|VSPACE_MULTIBYTE_CASES
label|:
endif|#
directive|endif
name|eptr
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|ENDLOOP03
label|:
break|break;
case|case
name|OP_NOT_DIGIT
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_DIGIT
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_WHITESPACE
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_NOT_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|&&
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_WORDCHAR
case|:
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eptr
operator|>=
name|md
operator|->
name|end_subject
condition|)
block|{
name|SCHECK_PARTIAL
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|eptr
argument_list|)
operator|||
operator|(
name|md
operator|->
name|ctypes
index|[
operator|*
name|eptr
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
break|break;
name|eptr
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|RRETURN
argument_list|(
name|PCRE_ERROR_INTERNAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|possessive
condition|)
continue|continue;
comment|/* No backtracking */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eptr
operator|==
name|pp
condition|)
goto|goto
name|TAIL_RECURSE
goto|;
name|RMATCH
argument_list|(
name|eptr
argument_list|,
name|ecode
argument_list|,
name|offset_top
argument_list|,
name|md
argument_list|,
name|eptrb
argument_list|,
name|RM47
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc
operator|!=
name|MATCH_NOMATCH
condition|)
name|RRETURN
argument_list|(
name|rrc
argument_list|)
expr_stmt|;
name|eptr
operator|--
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|OP_ANYNL
operator|&&
name|eptr
operator|>
name|pp
operator|&&
operator|*
name|eptr
operator|==
name|CHAR_LF
operator|&&
name|eptr
index|[
operator|-
literal|1
index|]
operator|==
name|CHAR_CR
condition|)
name|eptr
operator|--
expr_stmt|;
block|}
block|}
comment|/* Control never gets here */
block|}
comment|/* There's been some horrible disaster. Arrival here can only mean there is     something seriously wrong in the code above or the OP_xxx definitions. */
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"Unknown opcode %d\n"
operator|,
operator|*
name|ecode
operator|)
argument_list|)
expr_stmt|;
name|RRETURN
argument_list|(
name|PCRE_ERROR_UNKNOWN_OPCODE
argument_list|)
expr_stmt|;
block|}
comment|/* Do not stick any code in here without much thought; it is assumed   that "continue" in the code above comes out to here to repeat the main   loop. */
block|}
comment|/* End of main loop */
comment|/* Control never reaches here */
comment|/* When compiling to use the heap rather than the stack for recursive calls to match(), the RRETURN() macro jumps here. The number that is saved in frame->Xwhere indicates which label we actually want to return to. */
ifdef|#
directive|ifdef
name|NO_RECURSE
DECL|macro|LBL
define|#
directive|define
name|LBL
parameter_list|(
name|val
parameter_list|)
value|case val: goto L_RM##val;
name|HEAP_RETURN
label|:
switch|switch
condition|(
name|frame
operator|->
name|Xwhere
condition|)
block|{
name|LBL
argument_list|(
literal|1
argument_list|)
name|LBL
argument_list|(
literal|2
argument_list|)
name|LBL
argument_list|(
literal|3
argument_list|)
name|LBL
argument_list|(
literal|4
argument_list|)
name|LBL
argument_list|(
literal|5
argument_list|)
name|LBL
argument_list|(
literal|6
argument_list|)
name|LBL
argument_list|(
literal|7
argument_list|)
name|LBL
argument_list|(
literal|8
argument_list|)
name|LBL
argument_list|(
literal|9
argument_list|)
name|LBL
argument_list|(
literal|10
argument_list|)
name|LBL
argument_list|(
literal|11
argument_list|)
name|LBL
argument_list|(
literal|12
argument_list|)
name|LBL
argument_list|(
literal|13
argument_list|)
name|LBL
argument_list|(
literal|14
argument_list|)
name|LBL
argument_list|(
literal|15
argument_list|)
name|LBL
argument_list|(
literal|17
argument_list|)
name|LBL
argument_list|(
literal|19
argument_list|)
name|LBL
argument_list|(
literal|24
argument_list|)
name|LBL
argument_list|(
literal|25
argument_list|)
name|LBL
argument_list|(
literal|26
argument_list|)
name|LBL
argument_list|(
literal|27
argument_list|)
name|LBL
argument_list|(
literal|29
argument_list|)
name|LBL
argument_list|(
literal|31
argument_list|)
name|LBL
argument_list|(
literal|33
argument_list|)
name|LBL
argument_list|(
literal|35
argument_list|)
name|LBL
argument_list|(
literal|43
argument_list|)
name|LBL
argument_list|(
literal|47
argument_list|)
name|LBL
argument_list|(
literal|48
argument_list|)
name|LBL
argument_list|(
literal|49
argument_list|)
name|LBL
argument_list|(
literal|50
argument_list|)
name|LBL
argument_list|(
literal|51
argument_list|)
name|LBL
argument_list|(
literal|52
argument_list|)
name|LBL
argument_list|(
literal|53
argument_list|)
name|LBL
argument_list|(
literal|54
argument_list|)
name|LBL
argument_list|(
literal|55
argument_list|)
name|LBL
argument_list|(
literal|56
argument_list|)
name|LBL
argument_list|(
literal|57
argument_list|)
name|LBL
argument_list|(
literal|58
argument_list|)
name|LBL
argument_list|(
literal|63
argument_list|)
name|LBL
argument_list|(
literal|64
argument_list|)
name|LBL
argument_list|(
literal|65
argument_list|)
name|LBL
argument_list|(
literal|66
argument_list|)
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
name|LBL
argument_list|(
literal|20
argument_list|)
name|LBL
argument_list|(
literal|21
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|LBL
argument_list|(
literal|16
argument_list|)
name|LBL
argument_list|(
literal|18
argument_list|)
name|LBL
argument_list|(
literal|22
argument_list|)
name|LBL
argument_list|(
literal|23
argument_list|)
name|LBL
argument_list|(
literal|28
argument_list|)
name|LBL
argument_list|(
literal|30
argument_list|)
name|LBL
argument_list|(
literal|32
argument_list|)
name|LBL
argument_list|(
literal|34
argument_list|)
name|LBL
argument_list|(
literal|42
argument_list|)
name|LBL
argument_list|(
literal|46
argument_list|)
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|LBL
argument_list|(
literal|36
argument_list|)
name|LBL
argument_list|(
literal|37
argument_list|)
name|LBL
argument_list|(
literal|38
argument_list|)
name|LBL
argument_list|(
literal|39
argument_list|)
name|LBL
argument_list|(
literal|40
argument_list|)
name|LBL
argument_list|(
literal|41
argument_list|)
name|LBL
argument_list|(
literal|44
argument_list|)
name|LBL
argument_list|(
literal|45
argument_list|)
name|LBL
argument_list|(
literal|59
argument_list|)
name|LBL
argument_list|(
literal|60
argument_list|)
name|LBL
argument_list|(
literal|61
argument_list|)
name|LBL
argument_list|(
literal|62
argument_list|)
name|LBL
argument_list|(
literal|67
argument_list|)
endif|#
directive|endif
comment|/* SUPPORT_UCP */
endif|#
directive|endif
comment|/* SUPPORT_UTF */
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"jump error in pcre match: label %d non-existent\n"
operator|,
name|frame
operator|->
name|Xwhere
operator|)
argument_list|)
expr_stmt|;
return|return
name|PCRE_ERROR_INTERNAL
return|;
block|}
DECL|macro|LBL
undef|#
directive|undef
name|LBL
endif|#
directive|endif
comment|/* NO_RECURSE */
block|}
end_function
begin_comment
comment|/*************************************************************************** ****************************************************************************                    RECURSION IN THE match() FUNCTION  Undefine all the macros that were defined above to handle this. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|NO_RECURSE
end_ifdef
begin_undef
DECL|macro|eptr
undef|#
directive|undef
name|eptr
end_undef
begin_undef
DECL|macro|ecode
undef|#
directive|undef
name|ecode
end_undef
begin_undef
DECL|macro|mstart
undef|#
directive|undef
name|mstart
end_undef
begin_undef
DECL|macro|offset_top
undef|#
directive|undef
name|offset_top
end_undef
begin_undef
DECL|macro|eptrb
undef|#
directive|undef
name|eptrb
end_undef
begin_undef
DECL|macro|flags
undef|#
directive|undef
name|flags
end_undef
begin_undef
DECL|macro|callpat
undef|#
directive|undef
name|callpat
end_undef
begin_undef
DECL|macro|charptr
undef|#
directive|undef
name|charptr
end_undef
begin_undef
DECL|macro|data
undef|#
directive|undef
name|data
end_undef
begin_undef
DECL|macro|next
undef|#
directive|undef
name|next
end_undef
begin_undef
DECL|macro|pp
undef|#
directive|undef
name|pp
end_undef
begin_undef
DECL|macro|prev
undef|#
directive|undef
name|prev
end_undef
begin_undef
DECL|macro|saved_eptr
undef|#
directive|undef
name|saved_eptr
end_undef
begin_undef
DECL|macro|new_recursive
undef|#
directive|undef
name|new_recursive
end_undef
begin_undef
DECL|macro|cur_is_word
undef|#
directive|undef
name|cur_is_word
end_undef
begin_undef
DECL|macro|condition
undef|#
directive|undef
name|condition
end_undef
begin_undef
DECL|macro|prev_is_word
undef|#
directive|undef
name|prev_is_word
end_undef
begin_undef
DECL|macro|ctype
undef|#
directive|undef
name|ctype
end_undef
begin_undef
DECL|macro|length
undef|#
directive|undef
name|length
end_undef
begin_undef
DECL|macro|max
undef|#
directive|undef
name|max
end_undef
begin_undef
DECL|macro|min
undef|#
directive|undef
name|min
end_undef
begin_undef
DECL|macro|number
undef|#
directive|undef
name|number
end_undef
begin_undef
DECL|macro|offset
undef|#
directive|undef
name|offset
end_undef
begin_undef
DECL|macro|op
undef|#
directive|undef
name|op
end_undef
begin_undef
DECL|macro|save_capture_last
undef|#
directive|undef
name|save_capture_last
end_undef
begin_undef
DECL|macro|save_offset1
undef|#
directive|undef
name|save_offset1
end_undef
begin_undef
DECL|macro|save_offset2
undef|#
directive|undef
name|save_offset2
end_undef
begin_undef
DECL|macro|save_offset3
undef|#
directive|undef
name|save_offset3
end_undef
begin_undef
DECL|macro|stacksave
undef|#
directive|undef
name|stacksave
end_undef
begin_undef
DECL|macro|newptrb
undef|#
directive|undef
name|newptrb
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* These two are defined as macros in both cases */
end_comment
begin_undef
DECL|macro|fc
undef|#
directive|undef
name|fc
end_undef
begin_undef
DECL|macro|fi
undef|#
directive|undef
name|fi
end_undef
begin_comment
comment|/*************************************************************************** ***************************************************************************/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|NO_RECURSE
end_ifdef
begin_comment
comment|/************************************************* *          Release allocated heap frames         * *************************************************/
end_comment
begin_comment
comment|/* This function releases all the allocated frames. The base frame is on the machine stack, and so must not be freed.  Argument: the address of the base frame Returns:  nothing */
end_comment
begin_function
specifier|static
name|void
DECL|function|release_match_heapframes
name|release_match_heapframes
parameter_list|(
name|heapframe
modifier|*
name|frame_base
parameter_list|)
block|{
name|heapframe
modifier|*
name|nextframe
init|=
name|frame_base
operator|->
name|Xnextframe
decl_stmt|;
while|while
condition|(
name|nextframe
operator|!=
name|NULL
condition|)
block|{
name|heapframe
modifier|*
name|oldframe
init|=
name|nextframe
decl_stmt|;
name|nextframe
operator|=
name|nextframe
operator|->
name|Xnextframe
expr_stmt|;
operator|(
name|PUBL
argument_list|(
name|stack_free
argument_list|)
operator|)
operator|(
name|oldframe
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/************************************************* *         Execute a Regular Expression           * *************************************************/
end_comment
begin_comment
comment|/* This function applies a compiled re to a subject string and picks out portions of the string if it matches. Two elements in the vector are set for each substring: the offsets to the start and end of the substring.  Arguments:   argument_re     points to the compiled expression   extra_data      points to extra data or is NULL   subject         points to the subject string   length          length of subject string (may contain binary zeros)   start_offset    where to start in the subject string   options         option bits   offsets         points to a vector of ints to be filled in with offsets   offsetcount     the number of elements in the vector  Returns:> 0 => success; value is the number of elements filled in                   = 0 => success, but offsets is not big enough                    -1 => failed to match< -1 => some kind of unexpected problem */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_exec
name|pcre_exec
argument_list|(
specifier|const
name|pcre
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_exec
argument_list|(
specifier|const
name|pcre16
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre16_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre32_exec
argument_list|(
specifier|const
name|pcre32
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre32_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR32
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|)
endif|#
directive|endif
block|{
name|int
name|rc
decl_stmt|,
name|ocount
decl_stmt|,
name|arg_offset_max
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|BOOL
name|using_temporary_offsets
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|anchored
decl_stmt|;
name|BOOL
name|startline
decl_stmt|;
name|BOOL
name|firstline
decl_stmt|;
name|BOOL
name|utf
decl_stmt|;
name|BOOL
name|has_first_char
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|has_req_char
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
name|first_char
init|=
literal|0
decl_stmt|;
name|pcre_uchar
name|first_char2
init|=
literal|0
decl_stmt|;
name|pcre_uchar
name|req_char
init|=
literal|0
decl_stmt|;
name|pcre_uchar
name|req_char2
init|=
literal|0
decl_stmt|;
name|match_data
name|match_block
decl_stmt|;
name|match_data
modifier|*
name|md
init|=
operator|&
name|match_block
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|tables
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|start_bits
init|=
name|NULL
decl_stmt|;
name|PCRE_PUCHAR
name|start_match
init|=
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
operator|+
name|start_offset
decl_stmt|;
name|PCRE_PUCHAR
name|end_subject
decl_stmt|;
name|PCRE_PUCHAR
name|start_partial
init|=
name|NULL
decl_stmt|;
name|PCRE_PUCHAR
name|match_partial
init|=
name|NULL
decl_stmt|;
name|PCRE_PUCHAR
name|req_char_ptr
init|=
name|start_match
operator|-
literal|1
decl_stmt|;
specifier|const
name|pcre_study_data
modifier|*
name|study
decl_stmt|;
specifier|const
name|REAL_PCRE
modifier|*
name|re
init|=
operator|(
specifier|const
name|REAL_PCRE
operator|*
operator|)
name|argument_re
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_RECURSE
name|heapframe
name|frame_zero
decl_stmt|;
name|frame_zero
operator|.
name|Xprevframe
operator|=
name|NULL
expr_stmt|;
comment|/* Marks the top level */
name|frame_zero
operator|.
name|Xnextframe
operator|=
name|NULL
expr_stmt|;
comment|/* None are allocated yet */
name|md
operator|->
name|match_frames_base
operator|=
operator|&
name|frame_zero
expr_stmt|;
endif|#
directive|endif
comment|/* Check for the special magic call that measures the size of the stack used per recursive call of match(). Without the funny casting for sizeof, a Windows compiler gave this error: "unary minus operator applied to unsigned type, result still unsigned". Hopefully the cast fixes that. */
if|if
condition|(
name|re
operator|==
name|NULL
operator|&&
name|extra_data
operator|==
name|NULL
operator|&&
name|subject
operator|==
name|NULL
operator|&&
name|length
operator|==
operator|-
literal|999
operator|&&
name|start_offset
operator|==
operator|-
literal|999
condition|)
ifdef|#
directive|ifdef
name|NO_RECURSE
return|return
operator|-
operator|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|heapframe
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
name|match
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
comment|/* Plausibility checks */
if|if
condition|(
operator|(
name|options
operator|&
operator|~
name|PUBLIC_EXEC_OPTIONS
operator|)
operator|!=
literal|0
condition|)
return|return
name|PCRE_ERROR_BADOPTION
return|;
if|if
condition|(
name|re
operator|==
name|NULL
operator|||
name|subject
operator|==
name|NULL
operator|||
operator|(
name|offsets
operator|==
name|NULL
operator|&&
name|offsetcount
operator|>
literal|0
operator|)
condition|)
return|return
name|PCRE_ERROR_NULL
return|;
if|if
condition|(
name|offsetcount
operator|<
literal|0
condition|)
return|return
name|PCRE_ERROR_BADCOUNT
return|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
return|return
name|PCRE_ERROR_BADLENGTH
return|;
if|if
condition|(
name|start_offset
operator|<
literal|0
operator|||
name|start_offset
operator|>
name|length
condition|)
return|return
name|PCRE_ERROR_BADOFFSET
return|;
comment|/* Check that the first field in the block is the magic number. If it is not, return with PCRE_ERROR_BADMAGIC. However, if the magic number is equal to REVERSED_MAGIC_NUMBER we return with PCRE_ERROR_BADENDIANNESS, which means that the pattern is likely compiled with different endianness. */
if|if
condition|(
name|re
operator|->
name|magic_number
operator|!=
name|MAGIC_NUMBER
condition|)
return|return
name|re
operator|->
name|magic_number
operator|==
name|REVERSED_MAGIC_NUMBER
condition|?
name|PCRE_ERROR_BADENDIANNESS
else|:
name|PCRE_ERROR_BADMAGIC
return|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_MODE
operator|)
operator|==
literal|0
condition|)
return|return
name|PCRE_ERROR_BADMODE
return|;
comment|/* These two settings are used in the code for checking a UTF-8 string that follows immediately afterwards. Other values in the md block are used only during "normal" pcre_exec() processing, not when the JIT support is in use, so they are set up later. */
comment|/* PCRE_UTF16 has the same value as PCRE_UTF8. */
name|utf
operator|=
name|md
operator|->
name|utf
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|partial
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|2
else|:
operator|(
operator|(
name|options
operator|&
name|PCRE_PARTIAL_SOFT
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Check a UTF-8 string if required. Pass back the character offset and error code for an invalid string if a results vector is available. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
operator|(
name|options
operator|&
name|PCRE_NO_UTF8_CHECK
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|erroroffset
decl_stmt|;
name|int
name|errorcode
init|=
name|PRIV
argument_list|(
name|valid_utf
argument_list|)
argument_list|(
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
argument_list|,
name|length
argument_list|,
operator|&
name|erroroffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|errorcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offsetcount
operator|>=
literal|2
condition|)
block|{
name|offsets
index|[
literal|0
index|]
operator|=
name|erroroffset
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
name|errorcode
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|COMPILE_PCRE8
return|return
operator|(
name|errorcode
operator|<=
name|PCRE_UTF8_ERR5
operator|&&
name|md
operator|->
name|partial
operator|>
literal|1
operator|)
condition|?
name|PCRE_ERROR_SHORTUTF8
else|:
name|PCRE_ERROR_BADUTF8
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
return|return
operator|(
name|errorcode
operator|<=
name|PCRE_UTF16_ERR1
operator|&&
name|md
operator|->
name|partial
operator|>
literal|1
operator|)
condition|?
name|PCRE_ERROR_SHORTUTF16
else|:
name|PCRE_ERROR_BADUTF16
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
return|return
name|PCRE_ERROR_BADUTF32
return|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
name|COMPILE_PCRE8
operator|||
name|defined
name|COMPILE_PCRE16
comment|/* Check that a start_offset points to the start of a UTF character. */
if|if
condition|(
name|start_offset
operator|>
literal|0
operator|&&
name|start_offset
operator|<
name|length
operator|&&
name|NOT_FIRSTCHAR
argument_list|(
operator|(
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
operator|)
index|[
name|start_offset
index|]
argument_list|)
condition|)
return|return
name|PCRE_ERROR_BADUTF8_OFFSET
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* If the pattern was successfully studied with JIT support, run the JIT executable instead of the rest of this function. Most options must be set at compile time for the JIT code to be usable. Fallback to the normal code path if an unsupported flag is set. */
ifdef|#
directive|ifdef
name|SUPPORT_JIT
if|if
condition|(
name|extra_data
operator|!=
name|NULL
operator|&&
operator|(
name|extra_data
operator|->
name|flags
operator|&
operator|(
name|PCRE_EXTRA_EXECUTABLE_JIT
operator||
name|PCRE_EXTRA_TABLES
operator|)
operator|)
operator|==
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|&&
name|extra_data
operator|->
name|executable_jit
operator|!=
name|NULL
operator|&&
operator|(
name|options
operator|&
operator|~
name|PUBLIC_JIT_EXEC_OPTIONS
operator|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|PRIV
argument_list|(
name|jit_exec
argument_list|)
argument_list|(
name|extra_data
argument_list|,
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|subject
argument_list|,
name|length
argument_list|,
name|start_offset
argument_list|,
name|options
argument_list|,
name|offsets
argument_list|,
name|offsetcount
argument_list|)
expr_stmt|;
comment|/* PCRE_ERROR_NULL means that the selected normal or partial matching   mode is not compiled. In this case we simply fallback to interpreter. */
if|if
condition|(
name|rc
operator|!=
name|PCRE_ERROR_JIT_BADOPTION
condition|)
return|return
name|rc
return|;
block|}
endif|#
directive|endif
comment|/* Carry on with non-JIT matching. This information is for finding all the numbers associated with a given name, for condition testing. */
name|md
operator|->
name|name_table
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
expr_stmt|;
name|md
operator|->
name|name_count
operator|=
name|re
operator|->
name|name_count
expr_stmt|;
name|md
operator|->
name|name_entry_size
operator|=
name|re
operator|->
name|name_entry_size
expr_stmt|;
comment|/* Fish out the optional data from the extra_data structure, first setting the default values. */
name|study
operator|=
name|NULL
expr_stmt|;
name|md
operator|->
name|match_limit
operator|=
name|MATCH_LIMIT
expr_stmt|;
name|md
operator|->
name|match_limit_recursion
operator|=
name|MATCH_LIMIT_RECURSION
expr_stmt|;
name|md
operator|->
name|callout_data
operator|=
name|NULL
expr_stmt|;
comment|/* The table pointer is always in native byte order. */
name|tables
operator|=
name|re
operator|->
name|tables
expr_stmt|;
comment|/* The two limit values override the defaults, whatever their value. */
if|if
condition|(
name|extra_data
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|int
name|flags
init|=
name|extra_data
operator|->
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_STUDY_DATA
operator|)
operator|!=
literal|0
condition|)
name|study
operator|=
operator|(
specifier|const
name|pcre_study_data
operator|*
operator|)
name|extra_data
operator|->
name|study_data
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_MATCH_LIMIT
operator|)
operator|!=
literal|0
condition|)
name|md
operator|->
name|match_limit
operator|=
name|extra_data
operator|->
name|match_limit
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_MATCH_LIMIT_RECURSION
operator|)
operator|!=
literal|0
condition|)
name|md
operator|->
name|match_limit_recursion
operator|=
name|extra_data
operator|->
name|match_limit_recursion
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_CALLOUT_DATA
operator|)
operator|!=
literal|0
condition|)
name|md
operator|->
name|callout_data
operator|=
name|extra_data
operator|->
name|callout_data
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_TABLES
operator|)
operator|!=
literal|0
condition|)
name|tables
operator|=
name|extra_data
operator|->
name|tables
expr_stmt|;
block|}
comment|/* Limits in the regex override only if they are smaller. */
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_MLSET
operator|)
operator|!=
literal|0
operator|&&
name|re
operator|->
name|limit_match
operator|<
name|md
operator|->
name|match_limit
condition|)
name|md
operator|->
name|match_limit
operator|=
name|re
operator|->
name|limit_match
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_RLSET
operator|)
operator|!=
literal|0
operator|&&
name|re
operator|->
name|limit_recursion
operator|<
name|md
operator|->
name|match_limit_recursion
condition|)
name|md
operator|->
name|match_limit_recursion
operator|=
name|re
operator|->
name|limit_recursion
expr_stmt|;
comment|/* If the exec call supplied NULL for tables, use the inbuilt ones. This is a feature that makes it possible to save compiled regex and re-use them in other programs later. */
if|if
condition|(
name|tables
operator|==
name|NULL
condition|)
name|tables
operator|=
name|PRIV
argument_list|(
name|default_tables
argument_list|)
expr_stmt|;
comment|/* Set up other data */
name|anchored
operator|=
operator|(
operator|(
name|re
operator|->
name|options
operator||
name|options
operator|)
operator|&
name|PCRE_ANCHORED
operator|)
operator|!=
literal|0
expr_stmt|;
name|startline
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|!=
literal|0
expr_stmt|;
name|firstline
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* The code starts after the real_pcre block and the capture name table. */
name|md
operator|->
name|start_code
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
operator|+
name|re
operator|->
name|name_count
operator|*
name|re
operator|->
name|name_entry_size
expr_stmt|;
name|md
operator|->
name|start_subject
operator|=
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
expr_stmt|;
name|md
operator|->
name|start_offset
operator|=
name|start_offset
expr_stmt|;
name|md
operator|->
name|end_subject
operator|=
name|md
operator|->
name|start_subject
operator|+
name|length
expr_stmt|;
name|end_subject
operator|=
name|md
operator|->
name|end_subject
expr_stmt|;
name|md
operator|->
name|endonly
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_DOLLAR_ENDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|use_ucp
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|jscript_compat
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|ignore_skip_arg
operator|=
literal|0
expr_stmt|;
comment|/* Some options are unpacked into BOOL variables in the hope that testing them will be faster than individual option bits. */
name|md
operator|->
name|notbol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTBOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|noteol
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEOL
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|notempty
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|notempty_atstart
operator|=
operator|(
name|options
operator|&
name|PCRE_NOTEMPTY_ATSTART
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|hitend
operator|=
name|FALSE
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|md
operator|->
name|nomatch_mark
operator|=
name|NULL
expr_stmt|;
comment|/* In case never set */
name|md
operator|->
name|recursive
operator|=
name|NULL
expr_stmt|;
comment|/* No recursion at top level */
name|md
operator|->
name|hasthen
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_HASTHEN
operator|)
operator|!=
literal|0
expr_stmt|;
name|md
operator|->
name|lcc
operator|=
name|tables
operator|+
name|lcc_offset
expr_stmt|;
name|md
operator|->
name|fcc
operator|=
name|tables
operator|+
name|fcc_offset
expr_stmt|;
name|md
operator|->
name|ctypes
operator|=
name|tables
operator|+
name|ctypes_offset
expr_stmt|;
comment|/* Handle different \R options. */
switch|switch
condition|(
name|options
operator|&
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|md
operator|->
name|bsr_anycrlf
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_BSR_ANYCRLF
operator|)
operator|!=
literal|0
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|BSR_ANYCRLF
name|md
operator|->
name|bsr_anycrlf
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|md
operator|->
name|bsr_anycrlf
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|PCRE_BSR_ANYCRLF
case|:
name|md
operator|->
name|bsr_anycrlf
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PCRE_BSR_UNICODE
case|:
name|md
operator|->
name|bsr_anycrlf
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
return|return
name|PCRE_ERROR_BADNEWLINE
return|;
block|}
comment|/* Handle different types of newline. The three bits give eight cases. If nothing is set at run time, whatever was used at compile time applies. */
switch|switch
condition|(
operator|(
operator|(
operator|(
name|options
operator|&
name|PCRE_NEWLINE_BITS
operator|)
operator|==
literal|0
operator|)
condition|?
name|re
operator|->
name|options
else|:
operator|(
name|pcre_uint32
operator|)
name|options
operator|)
operator|&
name|PCRE_NEWLINE_BITS
condition|)
block|{
case|case
literal|0
case|:
name|newline
operator|=
name|NEWLINE
expr_stmt|;
break|break;
comment|/* Compile-time default */
case|case
name|PCRE_NEWLINE_CR
case|:
name|newline
operator|=
name|CHAR_CR
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_LF
case|:
name|newline
operator|=
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_CR
operator|+
name|PCRE_NEWLINE_LF
case|:
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANY
case|:
name|newline
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANYCRLF
case|:
name|newline
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
return|return
name|PCRE_ERROR_BADNEWLINE
return|;
block|}
if|if
condition|(
name|newline
operator|==
operator|-
literal|2
condition|)
block|{
name|md
operator|->
name|nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newline
operator|<
literal|0
condition|)
block|{
name|md
operator|->
name|nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|nltype
operator|=
name|NLTYPE_FIXED
expr_stmt|;
if|if
condition|(
name|newline
operator|>
literal|255
condition|)
block|{
name|md
operator|->
name|nllen
operator|=
literal|2
expr_stmt|;
name|md
operator|->
name|nl
index|[
literal|0
index|]
operator|=
operator|(
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|md
operator|->
name|nl
index|[
literal|1
index|]
operator|=
name|newline
operator|&
literal|255
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|nllen
operator|=
literal|1
expr_stmt|;
name|md
operator|->
name|nl
index|[
literal|0
index|]
operator|=
name|newline
expr_stmt|;
block|}
block|}
comment|/* Partial matching was originally supported only for a restricted set of regexes; from release 8.00 there are no restrictions, but the bits are still defined (though never set). So there's no harm in leaving this code. */
if|if
condition|(
name|md
operator|->
name|partial
operator|&&
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_NOPARTIAL
operator|)
operator|!=
literal|0
condition|)
return|return
name|PCRE_ERROR_BADPARTIAL
return|;
comment|/* If the expression has got more back references than the offsets supplied can hold, we get a temporary chunk of working store to use during the matching. Otherwise, we can use the vector supplied, rounding down its size to a multiple of 3. */
name|ocount
operator|=
name|offsetcount
operator|-
operator|(
name|offsetcount
operator|%
literal|3
operator|)
expr_stmt|;
name|arg_offset_max
operator|=
operator|(
literal|2
operator|*
name|ocount
operator|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|top_backref
operator|>
literal|0
operator|&&
name|re
operator|->
name|top_backref
operator|>=
name|ocount
operator|/
literal|3
condition|)
block|{
name|ocount
operator|=
name|re
operator|->
name|top_backref
operator|*
literal|3
operator|+
literal|3
expr_stmt|;
name|md
operator|->
name|offset_vector
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|PUBL
argument_list|(
name|malloc
argument_list|)
operator|)
operator|(
name|ocount
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|offset_vector
operator|==
name|NULL
condition|)
return|return
name|PCRE_ERROR_NOMEMORY
return|;
name|using_temporary_offsets
operator|=
name|TRUE
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Got memory to hold back references\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|md
operator|->
name|offset_vector
operator|=
name|offsets
expr_stmt|;
name|md
operator|->
name|offset_end
operator|=
name|ocount
expr_stmt|;
name|md
operator|->
name|offset_max
operator|=
operator|(
literal|2
operator|*
name|ocount
operator|)
operator|/
literal|3
expr_stmt|;
name|md
operator|->
name|capture_last
operator|=
literal|0
expr_stmt|;
comment|/* Reset the working variable associated with each extraction. These should never be used unless previously set, but they get saved and restored, and so we initialize them to avoid reading uninitialized locations. Also, unset the offsets for the matched string. This is really just for tidiness with callouts, in case they inspect these fields. */
if|if
condition|(
name|md
operator|->
name|offset_vector
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
modifier|*
name|iptr
init|=
name|md
operator|->
name|offset_vector
operator|+
name|ocount
decl_stmt|;
specifier|register
name|int
modifier|*
name|iend
init|=
name|iptr
operator|-
name|re
operator|->
name|top_bracket
decl_stmt|;
if|if
condition|(
name|iend
operator|<
name|md
operator|->
name|offset_vector
operator|+
literal|2
condition|)
name|iend
operator|=
name|md
operator|->
name|offset_vector
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|--
name|iptr
operator|>=
name|iend
condition|)
operator|*
name|iptr
operator|=
operator|-
literal|1
expr_stmt|;
name|md
operator|->
name|offset_vector
index|[
literal|0
index|]
operator|=
name|md
operator|->
name|offset_vector
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Set up the first character to match, if available. The first_char value is never set for an anchored regular expression, but the anchoring may be forced at run time, so we have to test for anchoring. The first char may be unset for an unanchored pattern, of course. If there's no first char and the pattern was studied, there may be a bitmap of possible first characters. */
if|if
condition|(
operator|!
name|anchored
condition|)
block|{
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|has_first_char
operator|=
name|TRUE
expr_stmt|;
name|first_char
operator|=
name|first_char2
operator|=
call|(
name|pcre_uchar
call|)
argument_list|(
name|re
operator|->
name|first_char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FCH_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|first_char2
operator|=
name|TABLE_GET
argument_list|(
name|first_char
argument_list|,
name|md
operator|->
name|fcc
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|utf
operator|&&
name|first_char
operator|>
literal|127
condition|)
name|first_char2
operator|=
name|UCD_OTHERCASE
argument_list|(
name|first_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|startline
operator|&&
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MAPPED
operator|)
operator|!=
literal|0
condition|)
name|start_bits
operator|=
name|study
operator|->
name|start_bits
expr_stmt|;
block|}
comment|/* For anchored or unanchored matches, there may be a "last known required character" set. */
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|has_req_char
operator|=
name|TRUE
expr_stmt|;
name|req_char
operator|=
name|req_char2
operator|=
call|(
name|pcre_uchar
call|)
argument_list|(
name|re
operator|->
name|req_char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_RCH_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|req_char2
operator|=
name|TABLE_GET
argument_list|(
name|req_char
argument_list|,
name|md
operator|->
name|fcc
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|utf
operator|&&
name|req_char
operator|>
literal|127
condition|)
name|req_char2
operator|=
name|UCD_OTHERCASE
argument_list|(
name|req_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* ==========================================================================*/
comment|/* Loop for handling unanchored repeated matching attempts; for anchored regexs the loop runs just once. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|PCRE_PUCHAR
name|save_end_subject
init|=
name|end_subject
decl_stmt|;
name|PCRE_PUCHAR
name|new_start_match
decl_stmt|;
comment|/* If firstline is TRUE, the start of the match is constrained to the first   line of a multiline string. That is, the match must be before or at the first   newline. Implement this by temporarily adjusting end_subject so that we stop   scanning at a newline. If the match fails at the newline, later code breaks   this loop. */
if|if
condition|(
name|firstline
condition|)
block|{
name|PCRE_PUCHAR
name|t
init|=
name|start_match
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
while|while
condition|(
name|t
operator|<
name|md
operator|->
name|end_subject
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|t
operator|<
name|end_subject
argument_list|,
operator|*
name|t
argument_list|,
name|t
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
while|while
condition|(
name|t
operator|<
name|md
operator|->
name|end_subject
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
name|end_subject
operator|=
name|t
expr_stmt|;
block|}
comment|/* There are some optimizations that avoid running the match if a known   starting point is not found, or if a known later character is not present.   However, there is an option that disables these, for testing and for ensuring   that all callouts do actually occur. The option can be set in the regex by   (*NO_START_OPT) or passed in match-time options. */
if|if
condition|(
operator|(
operator|(
name|options
operator||
name|re
operator|->
name|options
operator|)
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Advance to a unique first char if there is one. */
if|if
condition|(
name|has_first_char
condition|)
block|{
name|pcre_uchar
name|smc
decl_stmt|;
if|if
condition|(
name|first_char
operator|!=
name|first_char2
condition|)
while|while
condition|(
name|start_match
operator|<
name|end_subject
operator|&&
operator|(
name|smc
operator|=
name|UCHAR21TEST
argument_list|(
name|start_match
argument_list|)
operator|)
operator|!=
name|first_char
operator|&&
name|smc
operator|!=
name|first_char2
condition|)
name|start_match
operator|++
expr_stmt|;
else|else
while|while
condition|(
name|start_match
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|start_match
argument_list|)
operator|!=
name|first_char
condition|)
name|start_match
operator|++
expr_stmt|;
block|}
comment|/* Or to just after a linebreak for a multiline match */
elseif|else
if|if
condition|(
name|startline
condition|)
block|{
if|if
condition|(
name|start_match
operator|>
name|md
operator|->
name|start_subject
operator|+
name|start_offset
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
while|while
condition|(
name|start_match
operator|<
name|end_subject
operator|&&
operator|!
name|WAS_NEWLINE
argument_list|(
name|start_match
argument_list|)
condition|)
block|{
name|start_match
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|start_match
operator|<
name|end_subject
argument_list|,
operator|*
name|start_match
argument_list|,
name|start_match
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
while|while
condition|(
name|start_match
operator|<
name|end_subject
operator|&&
operator|!
name|WAS_NEWLINE
argument_list|(
name|start_match
argument_list|)
condition|)
name|start_match
operator|++
expr_stmt|;
comment|/* If we have just passed a CR and the newline option is ANY or ANYCRLF,         and we are now at a LF, advance the match position by one more character.         */
if|if
condition|(
name|start_match
index|[
operator|-
literal|1
index|]
operator|==
name|CHAR_CR
operator|&&
operator|(
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
operator|)
operator|&&
name|start_match
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|start_match
argument_list|)
operator|==
name|CHAR_NL
condition|)
name|start_match
operator|++
expr_stmt|;
block|}
block|}
comment|/* Or to a non-unique first byte after study */
elseif|else
if|if
condition|(
name|start_bits
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|start_match
operator|<
name|end_subject
condition|)
block|{
specifier|register
name|pcre_uint32
name|c
init|=
name|UCHAR21TEST
argument_list|(
name|start_match
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
if|if
condition|(
name|c
operator|>
literal|255
condition|)
name|c
operator|=
literal|255
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|start_bits
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|start_match
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Starting optimizations */
comment|/* Restore fudged end_subject */
name|end_subject
operator|=
name|save_end_subject
expr_stmt|;
comment|/* The following two optimizations are disabled for partial matching or if   disabling is explicitly requested. */
if|if
condition|(
operator|(
operator|(
name|options
operator||
name|re
operator|->
name|options
operator|)
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|md
operator|->
name|partial
condition|)
block|{
comment|/* If the pattern was studied, a minimum subject length may be set. This is     a lower bound; no actual string of that length may actually match the     pattern. Although the value is, strictly, in characters, we treat it as     bytes to avoid spending too much time in this optimization. */
if|if
condition|(
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MINLEN
operator|)
operator|!=
literal|0
operator|&&
call|(
name|pcre_uint32
call|)
argument_list|(
name|end_subject
operator|-
name|start_match
argument_list|)
operator|<
name|study
operator|->
name|minlength
condition|)
block|{
name|rc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
break|break;
block|}
comment|/* If req_char is set, we know that that character must appear in the     subject for the match to succeed. If the first character is set, req_char     must be later in the subject; otherwise the test starts at the match point.     This optimization can save a huge amount of backtracking in patterns with     nested unlimited repeats that aren't going to match. Writing separate code     for cased/caseless versions makes it go faster, as does using an     autoincrement and backing off on a match.      HOWEVER: when the subject string is very, very long, searching to its end     can take a long time, and give bad performance on quite ordinary patterns.     This showed up when somebody was matching something like /^\d+C/ on a     32-megabyte string... so we don't do this when the string is sufficiently     long. */
if|if
condition|(
name|has_req_char
operator|&&
name|end_subject
operator|-
name|start_match
operator|<
name|REQ_BYTE_MAX
condition|)
block|{
specifier|register
name|PCRE_PUCHAR
name|p
init|=
name|start_match
operator|+
operator|(
name|has_first_char
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
comment|/* We don't need to repeat the search if we haven't yet reached the       place we found it at last time. */
if|if
condition|(
name|p
operator|>
name|req_char_ptr
condition|)
block|{
if|if
condition|(
name|req_char
operator|!=
name|req_char2
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end_subject
condition|)
block|{
specifier|register
name|pcre_uint32
name|pp
init|=
name|UCHAR21INCTEST
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp
operator|==
name|req_char
operator|||
name|pp
operator|==
name|req_char2
condition|)
block|{
name|p
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|<
name|end_subject
condition|)
block|{
if|if
condition|(
name|UCHAR21INCTEST
argument_list|(
name|p
argument_list|)
operator|==
name|req_char
condition|)
block|{
name|p
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we can't find the required character, break the matching loop,         forcing a match failure. */
if|if
condition|(
name|p
operator|>=
name|end_subject
condition|)
block|{
name|rc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
break|break;
block|}
comment|/* If we have found the required character, save the point where we         found it, so that we don't search again next time round the loop if         the start hasn't passed this character yet. */
name|req_char_ptr
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|PCRE_DEBUG
comment|/* Sigh. Some compilers never learn. */
name|printf
argument_list|(
literal|">>>> Match against: "
argument_list|)
expr_stmt|;
name|pchars
argument_list|(
name|start_match
argument_list|,
name|end_subject
operator|-
name|start_match
argument_list|,
name|TRUE
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OK, we can now run the match. If "hitend" is set afterwards, remember the   first starting point for which a partial match was found. */
name|md
operator|->
name|start_match_ptr
operator|=
name|start_match
expr_stmt|;
name|md
operator|->
name|start_used_ptr
operator|=
name|start_match
expr_stmt|;
name|md
operator|->
name|match_call_count
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|match_function_type
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|end_offset_top
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|skip_arg_count
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|match
argument_list|(
name|start_match
argument_list|,
name|md
operator|->
name|start_code
argument_list|,
name|start_match
argument_list|,
literal|2
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|hitend
operator|&&
name|start_partial
operator|==
name|NULL
condition|)
block|{
name|start_partial
operator|=
name|md
operator|->
name|start_used_ptr
expr_stmt|;
name|match_partial
operator|=
name|start_match
expr_stmt|;
block|}
switch|switch
condition|(
name|rc
condition|)
block|{
comment|/* If MATCH_SKIP_ARG reaches this level it means that a MARK that matched     the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP     entirely. The only way we can do that is to re-do the match at the same     point, with a flag to force SKIP with an argument to be ignored. Just     treating this case as NOMATCH does not work because it does not check other     alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC. */
case|case
name|MATCH_SKIP_ARG
case|:
name|new_start_match
operator|=
name|start_match
expr_stmt|;
name|md
operator|->
name|ignore_skip_arg
operator|=
name|md
operator|->
name|skip_arg_count
expr_stmt|;
break|break;
comment|/* SKIP passes back the next starting point explicitly, but if it is no     greater than the match we have just done, treat it as NOMATCH. */
case|case
name|MATCH_SKIP
case|:
if|if
condition|(
name|md
operator|->
name|start_match_ptr
operator|>
name|start_match
condition|)
block|{
name|new_start_match
operator|=
name|md
operator|->
name|start_match_ptr
expr_stmt|;
break|break;
block|}
comment|/* Fall through */
comment|/* NOMATCH and PRUNE advance by one character. THEN at this level acts     exactly like PRUNE. Unset ignore SKIP-with-argument. */
case|case
name|MATCH_NOMATCH
case|:
case|case
name|MATCH_PRUNE
case|:
case|case
name|MATCH_THEN
case|:
name|md
operator|->
name|ignore_skip_arg
operator|=
literal|0
expr_stmt|;
name|new_start_match
operator|=
name|start_match
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
name|ACROSSCHAR
argument_list|(
name|new_start_match
operator|<
name|end_subject
argument_list|,
operator|*
name|new_start_match
argument_list|,
name|new_start_match
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* COMMIT disables the bumpalong, but otherwise behaves as NOMATCH. */
case|case
name|MATCH_COMMIT
case|:
name|rc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
goto|goto
name|ENDLOOP
goto|;
comment|/* Any other return is either a match, or some kind of error. */
default|default:
goto|goto
name|ENDLOOP
goto|;
block|}
comment|/* Control reaches here for the various types of "no match at this point"   result. Reset the code to MATCH_NOMATCH for subsequent checking. */
name|rc
operator|=
name|MATCH_NOMATCH
expr_stmt|;
comment|/* If PCRE_FIRSTLINE is set, the match must happen before or at the first   newline in the subject (though it may continue over the newline). Therefore,   if we have just failed to match, starting at a newline, do not continue. */
if|if
condition|(
name|firstline
operator|&&
name|IS_NEWLINE
argument_list|(
name|start_match
argument_list|)
condition|)
break|break;
comment|/* Advance to new matching position */
name|start_match
operator|=
name|new_start_match
expr_stmt|;
comment|/* Break the loop if the pattern is anchored or if we have passed the end of   the subject. */
if|if
condition|(
name|anchored
operator|||
name|start_match
operator|>
name|end_subject
condition|)
break|break;
comment|/* If we have just passed a CR and we are now at a LF, and the pattern does   not contain any explicit matches for \r or \n, and the newline option is CRLF   or ANY or ANYCRLF, advance the match position by one more character. In   normal matching start_match will aways be greater than the first position at   this stage, but a failed *SKIP can cause a return at the same point, which is   why the first test exists. */
if|if
condition|(
name|start_match
operator|>
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
operator|+
name|start_offset
operator|&&
name|start_match
index|[
operator|-
literal|1
index|]
operator|==
name|CHAR_CR
operator|&&
name|start_match
operator|<
name|end_subject
operator|&&
operator|*
name|start_match
operator|==
name|CHAR_NL
operator|&&
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_HASCRORLF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
operator|||
name|md
operator|->
name|nllen
operator|==
literal|2
operator|)
condition|)
name|start_match
operator|++
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* Reset for start of next match attempt */
block|}
comment|/* End of for(;;) "bumpalong" loop */
comment|/* ==========================================================================*/
comment|/* We reach here when rc is not MATCH_NOMATCH, or if one of the stopping conditions is true:  (1) The pattern is anchored or the match was failed by (*COMMIT);  (2) We are past the end of the subject;  (3) PCRE_FIRSTLINE is set and we have failed to match at a newline, because     this option requests that a match occur at or before the first newline in     the subject.  When we have a match and the offset vector is big enough to deal with any backreferences, captured substring offsets will already be set up. In the case where we had to get some local store to hold offsets for backreference processing, copy those that we can. In this case there need not be overflow if certain parts of the pattern were not used, even though there are more capturing parentheses than vector slots. */
name|ENDLOOP
label|:
if|if
condition|(
name|rc
operator|==
name|MATCH_MATCH
operator|||
name|rc
operator|==
name|MATCH_ACCEPT
condition|)
block|{
if|if
condition|(
name|using_temporary_offsets
condition|)
block|{
if|if
condition|(
name|arg_offset_max
operator|>=
literal|4
condition|)
block|{
name|memcpy
argument_list|(
name|offsets
operator|+
literal|2
argument_list|,
name|md
operator|->
name|offset_vector
operator|+
literal|2
argument_list|,
operator|(
name|arg_offset_max
operator|-
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Copied offsets from temporary memory\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|->
name|end_offset_top
operator|>
name|arg_offset_max
condition|)
name|md
operator|->
name|capture_last
operator||=
name|OVFLBIT
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Freeing temporary memory\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|md
operator|->
name|offset_vector
operator|)
expr_stmt|;
block|}
comment|/* Set the return code to the number of captured strings, or 0 if there were   too many to fit into the vector. */
name|rc
operator|=
operator|(
operator|(
name|md
operator|->
name|capture_last
operator|&
name|OVFLBIT
operator|)
operator|!=
literal|0
operator|&&
name|md
operator|->
name|end_offset_top
operator|>=
name|arg_offset_max
operator|)
condition|?
literal|0
else|:
name|md
operator|->
name|end_offset_top
operator|/
literal|2
expr_stmt|;
comment|/* If there is space in the offset vector, set any unused pairs at the end of   the pattern to -1 for backwards compatibility. It is documented that this   happens. In earlier versions, the whole set of potential capturing offsets   was set to -1 each time round the loop, but this is handled differently now.   "Gaps" are set to -1 dynamically instead (this fixes a bug). Thus, it is only   those at the end that need unsetting here. We can't just unset them all at   the start of the whole thing because they may get set in one branch that is   not the final matching branch. */
if|if
condition|(
name|md
operator|->
name|end_offset_top
operator|/
literal|2
operator|<=
name|re
operator|->
name|top_bracket
operator|&&
name|offsets
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
modifier|*
name|iptr
decl_stmt|,
modifier|*
name|iend
decl_stmt|;
name|int
name|resetcount
init|=
literal|2
operator|+
name|re
operator|->
name|top_bracket
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|resetcount
operator|>
name|offsetcount
condition|)
name|resetcount
operator|=
name|offsetcount
expr_stmt|;
name|iptr
operator|=
name|offsets
operator|+
name|md
operator|->
name|end_offset_top
expr_stmt|;
name|iend
operator|=
name|offsets
operator|+
name|resetcount
expr_stmt|;
while|while
condition|(
name|iptr
operator|<
name|iend
condition|)
operator|*
name|iptr
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* If there is space, set up the whole thing as substring 0. The value of   md->start_match_ptr might be modified if \K was encountered on the success   matching path. */
if|if
condition|(
name|offsetcount
operator|<
literal|2
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|offsets
index|[
literal|0
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|md
operator|->
name|start_match_ptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|md
operator|->
name|end_match_ptr
operator|-
name|md
operator|->
name|start_subject
argument_list|)
expr_stmt|;
block|}
comment|/* Return MARK data if requested */
if|if
condition|(
name|extra_data
operator|!=
name|NULL
operator|&&
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_MARK
operator|)
operator|!=
literal|0
condition|)
operator|*
operator|(
name|extra_data
operator|->
name|mark
operator|)
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|md
operator|->
name|mark
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|">>>> returning %d\n"
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_RECURSE
name|release_match_heapframes
argument_list|(
operator|&
name|frame_zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
comment|/* Control gets here if there has been an error, or if the overall match attempt has failed at all permitted starting positions. */
if|if
condition|(
name|using_temporary_offsets
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Freeing temporary memory\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|md
operator|->
name|offset_vector
operator|)
expr_stmt|;
block|}
comment|/* For anything other than nomatch or partial match, just return the code. */
if|if
condition|(
name|rc
operator|!=
name|MATCH_NOMATCH
operator|&&
name|rc
operator|!=
name|PCRE_ERROR_PARTIAL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|">>>> error: returning %d\n"
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_RECURSE
name|release_match_heapframes
argument_list|(
operator|&
name|frame_zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
comment|/* Handle partial matches - disable any mark data */
if|if
condition|(
name|match_partial
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|">>>> returning PCRE_ERROR_PARTIAL\n"
operator|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|mark
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|offsetcount
operator|>
literal|1
condition|)
block|{
name|offsets
index|[
literal|0
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|start_partial
operator|-
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|end_subject
operator|-
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetcount
operator|>
literal|2
condition|)
name|offsets
index|[
literal|2
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|match_partial
operator|-
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|PCRE_ERROR_PARTIAL
expr_stmt|;
block|}
comment|/* This is the classic nomatch case */
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|">>>> returning PCRE_ERROR_NOMATCH\n"
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|PCRE_ERROR_NOMATCH
expr_stmt|;
block|}
comment|/* Return the MARK data if it has been requested. */
if|if
condition|(
name|extra_data
operator|!=
name|NULL
operator|&&
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_MARK
operator|)
operator|!=
literal|0
condition|)
operator|*
operator|(
name|extra_data
operator|->
name|mark
operator|)
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|md
operator|->
name|nomatch_mark
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_RECURSE
name|release_match_heapframes
argument_list|(
operator|&
name|frame_zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
end_decl_stmt
begin_comment
comment|/* End of pcre_exec.c */
end_comment
end_unit
