begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2012 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains some convenience functions for extracting substrings from the subject string after a regex match has succeeded. The original idea for these functions came from Scott Wimer. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_comment
comment|/************************************************* *           Find number for named string         * *************************************************/
end_comment
begin_comment
comment|/* This function is used by the get_first_set() function below, as well as being generally available. It assumes that names are unique.  Arguments:   code        the compiled regex   stringname  the name whose number is required  Returns:      the number of the named parentheses, or a negative number                 (PCRE_ERROR_NOSUBSTRING) if not found */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_get_stringnumber
name|pcre_get_stringnumber
argument_list|(
specifier|const
name|pcre
operator|*
name|code
argument_list|,
specifier|const
name|char
operator|*
name|stringname
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_get_stringnumber
argument_list|(
specifier|const
name|pcre16
operator|*
name|code
argument_list|,
name|PCRE_SPTR16
name|stringname
argument_list|)
endif|#
directive|endif
block|{
name|int
name|rc
decl_stmt|;
name|int
name|entrysize
decl_stmt|;
name|int
name|top
decl_stmt|,
name|bot
decl_stmt|;
name|pcre_uchar
modifier|*
name|nametable
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMECOUNT
argument_list|,
operator|&
name|top
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|top
operator|<=
literal|0
condition|)
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMEENTRYSIZE
argument_list|,
operator|&
name|entrysize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMETABLE
argument_list|,
operator|&
name|nametable
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre16_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMECOUNT
argument_list|,
operator|&
name|top
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|top
operator|<=
literal|0
condition|)
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre16_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMEENTRYSIZE
argument_list|,
operator|&
name|entrysize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre16_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMETABLE
argument_list|,
operator|&
name|nametable
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
endif|#
directive|endif
name|bot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bot
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|top
operator|+
name|bot
operator|)
operator|/
literal|2
decl_stmt|;
name|pcre_uchar
modifier|*
name|entry
init|=
name|nametable
operator|+
name|entrysize
operator|*
name|mid
decl_stmt|;
name|int
name|c
init|=
name|STRCMP_UC_UC
argument_list|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|stringname
argument_list|,
operator|(
name|pcre_uchar
operator|*
operator|)
operator|(
name|entry
operator|+
name|IMM2_SIZE
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|GET2
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|bot
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|top
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *     Find (multiple) entries for named string   * *************************************************/
end_comment
begin_comment
comment|/* This is used by the get_first_set() function below, as well as being generally available. It is used when duplicated names are permitted.  Arguments:   code        the compiled regex   stringname  the name whose entries required   firstptr    where to put the pointer to the first entry   lastptr     where to put the pointer to the last entry  Returns:      the length of each entry, or a negative number                 (PCRE_ERROR_NOSUBSTRING) if not found */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_get_stringtable_entries
name|pcre_get_stringtable_entries
argument_list|(
specifier|const
name|pcre
operator|*
name|code
argument_list|,
specifier|const
name|char
operator|*
name|stringname
argument_list|,
name|char
operator|*
operator|*
name|firstptr
argument_list|,
name|char
operator|*
operator|*
name|lastptr
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_get_stringtable_entries
argument_list|(
specifier|const
name|pcre16
operator|*
name|code
argument_list|,
name|PCRE_SPTR16
name|stringname
argument_list|,
name|PCRE_UCHAR16
operator|*
operator|*
name|firstptr
argument_list|,
name|PCRE_UCHAR16
operator|*
operator|*
name|lastptr
argument_list|)
endif|#
directive|endif
block|{
name|int
name|rc
decl_stmt|;
name|int
name|entrysize
decl_stmt|;
name|int
name|top
decl_stmt|,
name|bot
decl_stmt|;
name|pcre_uchar
modifier|*
name|nametable
decl_stmt|,
modifier|*
name|lastentry
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMECOUNT
argument_list|,
operator|&
name|top
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|top
operator|<=
literal|0
condition|)
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMEENTRYSIZE
argument_list|,
operator|&
name|entrysize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMETABLE
argument_list|,
operator|&
name|nametable
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre16_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMECOUNT
argument_list|,
operator|&
name|top
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|top
operator|<=
literal|0
condition|)
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre16_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMEENTRYSIZE
argument_list|,
operator|&
name|entrysize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pcre16_fullinfo
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|PCRE_INFO_NAMETABLE
argument_list|,
operator|&
name|nametable
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
endif|#
directive|endif
name|lastentry
operator|=
name|nametable
operator|+
name|entrysize
operator|*
operator|(
name|top
operator|-
literal|1
operator|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bot
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|top
operator|+
name|bot
operator|)
operator|/
literal|2
decl_stmt|;
name|pcre_uchar
modifier|*
name|entry
init|=
name|nametable
operator|+
name|entrysize
operator|*
name|mid
decl_stmt|;
name|int
name|c
init|=
name|STRCMP_UC_UC
argument_list|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|stringname
argument_list|,
operator|(
name|pcre_uchar
operator|*
operator|)
operator|(
name|entry
operator|+
name|IMM2_SIZE
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|pcre_uchar
modifier|*
name|first
init|=
name|entry
decl_stmt|;
name|pcre_uchar
modifier|*
name|last
init|=
name|entry
decl_stmt|;
while|while
condition|(
name|first
operator|>
name|nametable
condition|)
block|{
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|stringname
argument_list|,
operator|(
name|pcre_uchar
operator|*
operator|)
operator|(
name|first
operator|-
name|entrysize
operator|+
name|IMM2_SIZE
operator|)
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|first
operator|-=
name|entrysize
expr_stmt|;
block|}
while|while
condition|(
name|last
operator|<
name|lastentry
condition|)
block|{
if|if
condition|(
name|STRCMP_UC_UC
argument_list|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|stringname
argument_list|,
operator|(
name|pcre_uchar
operator|*
operator|)
operator|(
name|last
operator|+
name|entrysize
operator|+
name|IMM2_SIZE
operator|)
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|last
operator|+=
name|entrysize
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
operator|*
name|firstptr
operator|=
operator|(
name|char
operator|*
operator|)
name|first
expr_stmt|;
operator|*
name|lastptr
operator|=
operator|(
name|char
operator|*
operator|)
name|last
expr_stmt|;
else|#
directive|else
operator|*
name|firstptr
operator|=
operator|(
name|PCRE_UCHAR16
operator|*
operator|)
name|first
expr_stmt|;
operator|*
name|lastptr
operator|=
operator|(
name|PCRE_UCHAR16
operator|*
operator|)
name|last
expr_stmt|;
endif|#
directive|endif
return|return
name|entrysize
return|;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|bot
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|top
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *    Find first set of multiple named strings    * *************************************************/
end_comment
begin_comment
comment|/* This function allows for duplicate names in the table of named substrings. It returns the number of the first one that was set in a pattern match.  Arguments:   code         the compiled regex   stringname   the name of the capturing substring   ovector      the vector of matched substrings  Returns:       the number of the first that is set,                or the number of the last one if none are set,                or a negative number on error */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
specifier|static
name|int
DECL|function|get_first_set
name|get_first_set
argument_list|(
specifier|const
name|pcre
operator|*
name|code
argument_list|,
specifier|const
name|char
operator|*
name|stringname
argument_list|,
name|int
operator|*
name|ovector
argument_list|)
else|#
directive|else
decl|static
name|int
name|get_first_set
argument_list|(
specifier|const
name|pcre16
operator|*
name|code
argument_list|,
name|PCRE_SPTR16
name|stringname
argument_list|,
name|int
operator|*
name|ovector
argument_list|)
endif|#
directive|endif
block|{
specifier|const
name|REAL_PCRE
modifier|*
name|re
init|=
operator|(
specifier|const
name|REAL_PCRE
operator|*
operator|)
name|code
decl_stmt|;
name|int
name|entrysize
decl_stmt|;
name|pcre_uchar
modifier|*
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
else|#
directive|else
name|PCRE_UCHAR16
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_DUPNAMES
operator|)
operator|==
literal|0
operator|&&
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_JCHANGED
operator|)
operator|==
literal|0
condition|)
return|return
name|pcre_get_stringnumber
argument_list|(
name|code
argument_list|,
name|stringname
argument_list|)
return|;
name|entrysize
operator|=
name|pcre_get_stringtable_entries
argument_list|(
name|code
argument_list|,
name|stringname
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_DUPNAMES
operator|)
operator|==
literal|0
operator|&&
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_JCHANGED
operator|)
operator|==
literal|0
condition|)
return|return
name|pcre16_get_stringnumber
argument_list|(
name|code
argument_list|,
name|stringname
argument_list|)
return|;
name|entrysize
operator|=
name|pcre16_get_stringtable_entries
argument_list|(
name|code
argument_list|,
name|stringname
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entrysize
operator|<=
literal|0
condition|)
return|return
name|entrysize
return|;
for|for
control|(
name|entry
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|first
init|;
name|entry
operator|<=
operator|(
name|pcre_uchar
operator|*
operator|)
name|last
condition|;
name|entry
operator|+=
name|entrysize
control|)
block|{
name|int
name|n
init|=
name|GET2
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ovector
index|[
name|n
operator|*
literal|2
index|]
operator|>=
literal|0
condition|)
return|return
name|n
return|;
block|}
return|return
name|GET2
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *      Copy captured string to given buffer      * *************************************************/
end_comment
begin_comment
comment|/* This function copies a single captured substring into a given buffer. Note that we use memcpy() rather than strncpy() in case there are binary zeros in the string.  Arguments:   subject        the subject string that was matched   ovector        pointer to the offsets table   stringcount    the number of substrings that were captured                    (i.e. the yield of the pcre_exec call, unless                    that was zero, in which case it should be 1/3                    of the offset table size)   stringnumber   the number of the required substring   buffer         where to put the substring   size           the size of the buffer  Returns:         if successful:                    the length of the copied string, not including the zero                    that is put on the end; can be zero                  if not successful:                    PCRE_ERROR_NOMEMORY (-6) buffer too small                    PCRE_ERROR_NOSUBSTRING (-7) no such captured substring */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_copy_substring
name|pcre_copy_substring
argument_list|(
specifier|const
name|char
operator|*
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
name|int
name|stringnumber
argument_list|,
name|char
operator|*
name|buffer
argument_list|,
name|int
name|size
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_copy_substring
argument_list|(
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
name|int
name|stringnumber
argument_list|,
name|PCRE_UCHAR16
operator|*
name|buffer
argument_list|,
name|int
name|size
argument_list|)
endif|#
directive|endif
block|{
name|int
name|yield
decl_stmt|;
if|if
condition|(
name|stringnumber
operator|<
literal|0
operator|||
name|stringnumber
operator|>=
name|stringcount
condition|)
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
name|stringnumber
operator|*=
literal|2
expr_stmt|;
name|yield
operator|=
name|ovector
index|[
name|stringnumber
operator|+
literal|1
index|]
operator|-
name|ovector
index|[
name|stringnumber
index|]
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|yield
operator|+
literal|1
condition|)
return|return
name|PCRE_ERROR_NOMEMORY
return|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|subject
operator|+
name|ovector
index|[
name|stringnumber
index|]
argument_list|,
name|IN_UCHARS
argument_list|(
name|yield
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
index|[
name|yield
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|yield
return|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *   Copy named captured string to given buffer   * *************************************************/
end_comment
begin_comment
comment|/* This function copies a single captured substring into a given buffer, identifying it by name. If the regex permits duplicate names, the first substring that is set is chosen.  Arguments:   code           the compiled regex   subject        the subject string that was matched   ovector        pointer to the offsets table   stringcount    the number of substrings that were captured                    (i.e. the yield of the pcre_exec call, unless                    that was zero, in which case it should be 1/3                    of the offset table size)   stringname     the name of the required substring   buffer         where to put the substring   size           the size of the buffer  Returns:         if successful:                    the length of the copied string, not including the zero                    that is put on the end; can be zero                  if not successful:                    PCRE_ERROR_NOMEMORY (-6) buffer too small                    PCRE_ERROR_NOSUBSTRING (-7) no such captured substring */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_copy_named_substring
name|pcre_copy_named_substring
argument_list|(
specifier|const
name|pcre
operator|*
name|code
argument_list|,
specifier|const
name|char
operator|*
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
specifier|const
name|char
operator|*
name|stringname
argument_list|,
name|char
operator|*
name|buffer
argument_list|,
name|int
name|size
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_copy_named_substring
argument_list|(
specifier|const
name|pcre16
operator|*
name|code
argument_list|,
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
name|PCRE_SPTR16
name|stringname
argument_list|,
name|PCRE_UCHAR16
operator|*
name|buffer
argument_list|,
name|int
name|size
argument_list|)
endif|#
directive|endif
block|{
name|int
name|n
init|=
name|get_first_set
argument_list|(
name|code
argument_list|,
name|stringname
argument_list|,
name|ovector
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
name|n
return|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
return|return
name|pcre_copy_substring
argument_list|(
name|subject
argument_list|,
name|ovector
argument_list|,
name|stringcount
argument_list|,
name|n
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
return|;
else|#
directive|else
return|return
name|pcre16_copy_substring
argument_list|(
name|subject
argument_list|,
name|ovector
argument_list|,
name|stringcount
argument_list|,
name|n
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
return|;
endif|#
directive|endif
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *      Copy all captured strings to new store    * *************************************************/
end_comment
begin_comment
comment|/* This function gets one chunk of store and builds a list of pointers and all of the captured substrings in it. A NULL pointer is put on the end of the list.  Arguments:   subject        the subject string that was matched   ovector        pointer to the offsets table   stringcount    the number of substrings that were captured                    (i.e. the yield of the pcre_exec call, unless                    that was zero, in which case it should be 1/3                    of the offset table size)   listptr        set to point to the list of pointers  Returns:         if successful: 0                  if not successful:                    PCRE_ERROR_NOMEMORY (-6) failed to get store */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_get_substring_list
name|pcre_get_substring_list
argument_list|(
specifier|const
name|char
operator|*
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
specifier|const
name|char
operator|*
operator|*
operator|*
name|listptr
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_get_substring_list
argument_list|(
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
name|PCRE_SPTR16
operator|*
operator|*
name|listptr
argument_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
name|pcre_uchar
operator|*
argument_list|)
decl_stmt|;
name|int
name|double_count
init|=
name|stringcount
operator|*
literal|2
decl_stmt|;
name|pcre_uchar
modifier|*
modifier|*
name|stringlist
decl_stmt|;
name|pcre_uchar
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|double_count
condition|;
name|i
operator|+=
literal|2
control|)
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|pcre_uchar
operator|*
argument_list|)
operator|+
name|IN_UCHARS
argument_list|(
name|ovector
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|ovector
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stringlist
operator|=
operator|(
name|pcre_uchar
operator|*
operator|*
operator|)
operator|(
name|PUBL
argument_list|(
name|malloc
argument_list|)
operator|)
operator|(
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|stringlist
operator|==
name|NULL
condition|)
return|return
name|PCRE_ERROR_NOMEMORY
return|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
operator|*
name|listptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|stringlist
expr_stmt|;
else|#
directive|else
operator|*
name|listptr
operator|=
operator|(
name|PCRE_SPTR16
operator|*
operator|)
name|stringlist
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
operator|(
name|stringlist
operator|+
name|stringcount
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|double_count
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|len
init|=
name|ovector
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|ovector
index|[
name|i
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|subject
operator|+
name|ovector
index|[
name|i
index|]
argument_list|,
name|IN_UCHARS
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stringlist
operator|++
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|stringlist
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *   Free store obtained by get_substring_list    * *************************************************/
end_comment
begin_comment
comment|/* This function exists for the benefit of people calling PCRE from non-C programs that can call its functions, but not free() or (PUBL(free))() directly.  Argument:   the result of a previous pcre_get_substring_list() Returns:    nothing */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|void
name|PCRE_CALL_CONVENTION
DECL|function|pcre_free_substring_list
name|pcre_free_substring_list
argument_list|(
specifier|const
name|char
operator|*
operator|*
name|pointer
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|void
name|PCRE_CALL_CONVENTION
name|pcre16_free_substring_list
argument_list|(
name|PCRE_SPTR16
operator|*
name|pointer
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|pointer
operator|)
expr_stmt|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *      Copy captured string to new store         * *************************************************/
end_comment
begin_comment
comment|/* This function copies a single captured substring into a piece of new store  Arguments:   subject        the subject string that was matched   ovector        pointer to the offsets table   stringcount    the number of substrings that were captured                    (i.e. the yield of the pcre_exec call, unless                    that was zero, in which case it should be 1/3                    of the offset table size)   stringnumber   the number of the required substring   stringptr      where to put a pointer to the substring  Returns:         if successful:                    the length of the string, not including the zero that                    is put on the end; can be zero                  if not successful:                    PCRE_ERROR_NOMEMORY (-6) failed to get store                    PCRE_ERROR_NOSUBSTRING (-7) substring not present */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_get_substring
name|pcre_get_substring
argument_list|(
specifier|const
name|char
operator|*
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
name|int
name|stringnumber
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|stringptr
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_get_substring
argument_list|(
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
name|int
name|stringnumber
argument_list|,
name|PCRE_SPTR16
operator|*
name|stringptr
argument_list|)
endif|#
directive|endif
block|{
name|int
name|yield
decl_stmt|;
name|pcre_uchar
modifier|*
name|substring
decl_stmt|;
if|if
condition|(
name|stringnumber
operator|<
literal|0
operator|||
name|stringnumber
operator|>=
name|stringcount
condition|)
return|return
name|PCRE_ERROR_NOSUBSTRING
return|;
name|stringnumber
operator|*=
literal|2
expr_stmt|;
name|yield
operator|=
name|ovector
index|[
name|stringnumber
operator|+
literal|1
index|]
operator|-
name|ovector
index|[
name|stringnumber
index|]
expr_stmt|;
name|substring
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
operator|(
name|PUBL
argument_list|(
name|malloc
argument_list|)
operator|)
operator|(
name|IN_UCHARS
argument_list|(
name|yield
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|substring
operator|==
name|NULL
condition|)
return|return
name|PCRE_ERROR_NOMEMORY
return|;
name|memcpy
argument_list|(
name|substring
argument_list|,
name|subject
operator|+
name|ovector
index|[
name|stringnumber
index|]
argument_list|,
name|IN_UCHARS
argument_list|(
name|yield
argument_list|)
argument_list|)
expr_stmt|;
name|substring
index|[
name|yield
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
operator|*
name|stringptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|substring
expr_stmt|;
else|#
directive|else
operator|*
name|stringptr
operator|=
operator|(
name|PCRE_SPTR16
operator|)
name|substring
expr_stmt|;
endif|#
directive|endif
return|return
name|yield
return|;
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *   Copy named captured string to new store      * *************************************************/
end_comment
begin_comment
comment|/* This function copies a single captured substring, identified by name, into new store. If the regex permits duplicate names, the first substring that is set is chosen.  Arguments:   code           the compiled regex   subject        the subject string that was matched   ovector        pointer to the offsets table   stringcount    the number of substrings that were captured                    (i.e. the yield of the pcre_exec call, unless                    that was zero, in which case it should be 1/3                    of the offset table size)   stringname     the name of the required substring   stringptr      where to put the pointer  Returns:         if successful:                    the length of the copied string, not including the zero                    that is put on the end; can be zero                  if not successful:                    PCRE_ERROR_NOMEMORY (-6) couldn't get memory                    PCRE_ERROR_NOSUBSTRING (-7) no such captured substring */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_get_named_substring
name|pcre_get_named_substring
argument_list|(
specifier|const
name|pcre
operator|*
name|code
argument_list|,
specifier|const
name|char
operator|*
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
specifier|const
name|char
operator|*
name|stringname
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|stringptr
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_get_named_substring
argument_list|(
specifier|const
name|pcre16
operator|*
name|code
argument_list|,
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
operator|*
name|ovector
argument_list|,
name|int
name|stringcount
argument_list|,
name|PCRE_SPTR16
name|stringname
argument_list|,
name|PCRE_SPTR16
operator|*
name|stringptr
argument_list|)
endif|#
directive|endif
block|{
name|int
name|n
init|=
name|get_first_set
argument_list|(
name|code
argument_list|,
name|stringname
argument_list|,
name|ovector
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
name|n
return|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
return|return
name|pcre_get_substring
argument_list|(
name|subject
argument_list|,
name|ovector
argument_list|,
name|stringcount
argument_list|,
name|n
argument_list|,
name|stringptr
argument_list|)
return|;
else|#
directive|else
return|return
name|pcre16_get_substring
argument_list|(
name|subject
argument_list|,
name|ovector
argument_list|,
name|stringcount
argument_list|,
name|n
argument_list|,
name|stringptr
argument_list|)
return|;
endif|#
directive|endif
block|}
end_decl_stmt
begin_comment
comment|/************************************************* *       Free store obtained by get_substring     * *************************************************/
end_comment
begin_comment
comment|/* This function exists for the benefit of people calling PCRE from non-C programs that can call its functions, but not free() or (PUBL(free))() directly.  Argument:   the result of a previous pcre_get_substring() Returns:    nothing */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
name|PCRE_EXP_DEFN
name|void
name|PCRE_CALL_CONVENTION
DECL|function|pcre_free_substring
name|pcre_free_substring
argument_list|(
specifier|const
name|char
operator|*
name|pointer
argument_list|)
else|#
directive|else
name|PCRE_EXP_DEFN
name|void
name|PCRE_CALL_CONVENTION
name|pcre16_free_substring
argument_list|(
name|PCRE_SPTR16
name|pointer
argument_list|)
endif|#
directive|endif
block|{
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|pointer
operator|)
expr_stmt|;
block|}
end_decl_stmt
begin_comment
comment|/* End of pcre_get.c */
end_comment
end_unit
