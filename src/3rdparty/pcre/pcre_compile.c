begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2012 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains the external function pcre_compile(), along with supporting internal functions that are not used by other modules. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|NLBLOCK
define|#
directive|define
name|NLBLOCK
value|cd
end_define
begin_comment
DECL|macro|NLBLOCK
comment|/* Block containing newline information */
end_comment
begin_define
DECL|macro|PSSTART
define|#
directive|define
name|PSSTART
value|start_pattern
end_define
begin_comment
DECL|macro|PSSTART
comment|/* Field containing processed string start */
end_comment
begin_define
DECL|macro|PSEND
define|#
directive|define
name|PSEND
value|end_pattern
end_define
begin_comment
DECL|macro|PSEND
comment|/* Field containing processed string end */
end_comment
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_comment
comment|/* When PCRE_DEBUG is defined, we need the pcre(16|32)_printint() function, which is also used by pcretest. PCRE_DEBUG is not defined when building a production library. We do not need to select pcre16_printint.c specially, because the COMPILE_PCREx macro will already be appropriately set. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_DEBUG
end_ifdef
begin_comment
comment|/* pcre_printint.c should not include any headers */
end_comment
begin_define
DECL|macro|PCRE_INCLUDED
define|#
directive|define
name|PCRE_INCLUDED
end_define
begin_include
include|#
directive|include
file|"pcre_printint.c"
end_include
begin_undef
DECL|macro|PCRE_INCLUDED
undef|#
directive|undef
name|PCRE_INCLUDED
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Macro for setting individual bits in class bitmaps. */
end_comment
begin_define
DECL|macro|SETBIT
define|#
directive|define
name|SETBIT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a[(b)/8] |= (1<< ((b)&7))
end_define
begin_comment
comment|/* Maximum length value to check against when making sure that the integer that holds the compiled pattern length does not overflow. We make it a bit less than INT_MAX to allow for adding in group terminating bytes, so that we don't have to check them every time. */
end_comment
begin_define
DECL|macro|OFLOW_MAX
define|#
directive|define
name|OFLOW_MAX
value|(INT_MAX - 20)
end_define
begin_comment
comment|/* Definitions to allow mutual recursion */
end_comment
begin_function_decl
specifier|static
name|int
name|add_list_to_class
parameter_list|(
name|pcre_uint8
modifier|*
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|compile_data
modifier|*
parameter_list|,
specifier|const
name|pcre_uint32
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|BOOL
name|compile_regex
parameter_list|(
name|int
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|BOOL
parameter_list|,
name|BOOL
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|pcre_uint32
modifier|*
parameter_list|,
name|pcre_int32
modifier|*
parameter_list|,
name|pcre_uint32
modifier|*
parameter_list|,
name|pcre_int32
modifier|*
parameter_list|,
name|branch_chain
modifier|*
parameter_list|,
name|compile_data
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/************************************************* *      Code parameters and static tables         * *************************************************/
end_comment
begin_comment
comment|/* This value specifies the size of stack workspace that is used during the first pre-compile phase that determines how much memory is required. The regex is partly compiled into this space, but the compiled parts are discarded as soon as they can be, so that hopefully there will never be an overrun. The code does, however, check for an overrun. The largest amount I've seen used is 218, so this number is very generous.  The same workspace is used during the second, actual compile phase for remembering forward references to groups so that they can be filled in at the end. Each entry in this list occupies LINK_SIZE bytes, so even when LINK_SIZE is 4 there is plenty of room for most patterns. However, the memory can get filled up by repetitions of forward references, for example patterns like /(?1){0,1999}(b)/, and one user did hit the limit. The code has been changed so that the workspace is expanded using malloc() in this situation. The value below is therefore a minimum, and we put a maximum on it for safety. The minimum is now also defined in terms of LINK_SIZE so that the use of malloc() kicks in at the same number of forward references in all cases. */
end_comment
begin_define
DECL|macro|COMPILE_WORK_SIZE
define|#
directive|define
name|COMPILE_WORK_SIZE
value|(2048*LINK_SIZE)
end_define
begin_define
DECL|macro|COMPILE_WORK_SIZE_MAX
define|#
directive|define
name|COMPILE_WORK_SIZE_MAX
value|(100*COMPILE_WORK_SIZE)
end_define
begin_comment
comment|/* The overrun tests check for a slightly smaller size so that they detect the overrun before it actually does run off the end of the data block. */
end_comment
begin_define
DECL|macro|WORK_SIZE_SAFETY_MARGIN
define|#
directive|define
name|WORK_SIZE_SAFETY_MARGIN
value|(100)
end_define
begin_comment
comment|/* Private flags added to firstchar and reqchar. */
end_comment
begin_define
DECL|macro|REQ_CASELESS
define|#
directive|define
name|REQ_CASELESS
value|(1<< 0)
end_define
begin_comment
DECL|macro|REQ_CASELESS
comment|/* Indicates caselessness */
end_comment
begin_define
DECL|macro|REQ_VARY
define|#
directive|define
name|REQ_VARY
value|(1<< 1)
end_define
begin_comment
DECL|macro|REQ_VARY
comment|/* Reqchar followed non-literal item */
end_comment
begin_comment
comment|/* Negative values for the firstchar and reqchar flags */
end_comment
begin_define
DECL|macro|REQ_UNSET
define|#
directive|define
name|REQ_UNSET
value|(-2)
end_define
begin_define
DECL|macro|REQ_NONE
define|#
directive|define
name|REQ_NONE
value|(-1)
end_define
begin_comment
comment|/* Repeated character flags. */
end_comment
begin_define
DECL|macro|UTF_LENGTH
define|#
directive|define
name|UTF_LENGTH
value|0x10000000l
end_define
begin_comment
DECL|macro|UTF_LENGTH
comment|/* The char contains its length. */
end_comment
begin_comment
comment|/* Table for handling escaped characters in the range '0'-'z'. Positive returns are simple data values; negative values are for special things like \d and so on. Zero means further processing is needed (for things like \x), or the escape is invalid. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|EBCDIC
end_ifndef
begin_comment
comment|/* This is the "normal" table for ASCII systems or for EBCDIC systems running in UTF-8 mode. */
end_comment
begin_decl_stmt
DECL|variable|escapes
specifier|static
specifier|const
name|short
name|int
name|escapes
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|CHAR_COLON
block|,
name|CHAR_SEMICOLON
block|,
name|CHAR_LESS_THAN_SIGN
block|,
name|CHAR_EQUALS_SIGN
block|,
name|CHAR_GREATER_THAN_SIGN
block|,
name|CHAR_QUESTION_MARK
block|,
name|CHAR_COMMERCIAL_AT
block|,
operator|-
name|ESC_A
block|,
operator|-
name|ESC_B
block|,
operator|-
name|ESC_C
block|,
operator|-
name|ESC_D
block|,
operator|-
name|ESC_E
block|,
literal|0
block|,
operator|-
name|ESC_G
block|,
operator|-
name|ESC_H
block|,
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_K
block|,
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_N
block|,
literal|0
block|,
operator|-
name|ESC_P
block|,
operator|-
name|ESC_Q
block|,
operator|-
name|ESC_R
block|,
operator|-
name|ESC_S
block|,
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_V
block|,
operator|-
name|ESC_W
block|,
operator|-
name|ESC_X
block|,
literal|0
block|,
operator|-
name|ESC_Z
block|,
name|CHAR_LEFT_SQUARE_BRACKET
block|,
name|CHAR_BACKSLASH
block|,
name|CHAR_RIGHT_SQUARE_BRACKET
block|,
name|CHAR_CIRCUMFLEX_ACCENT
block|,
name|CHAR_UNDERSCORE
block|,
name|CHAR_GRAVE_ACCENT
block|,
literal|7
block|,
operator|-
name|ESC_b
block|,
literal|0
block|,
operator|-
name|ESC_d
block|,
name|ESC_e
block|,
name|ESC_f
block|,
literal|0
block|,
operator|-
name|ESC_h
block|,
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_k
block|,
literal|0
block|,
literal|0
block|,
name|ESC_n
block|,
literal|0
block|,
operator|-
name|ESC_p
block|,
literal|0
block|,
name|ESC_r
block|,
operator|-
name|ESC_s
block|,
name|ESC_tee
block|,
literal|0
block|,
operator|-
name|ESC_v
block|,
operator|-
name|ESC_w
block|,
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_z
block|}
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* This is the "abnormal" table for EBCDIC systems without UTF-8 support. */
end_comment
begin_decl_stmt
DECL|variable|escapes
specifier|static
specifier|const
name|short
name|int
name|escapes
index|[]
init|=
block|{
comment|/*  48 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|'.'
block|,
literal|'<'
block|,
literal|'('
block|,
literal|'+'
block|,
literal|'|'
block|,
comment|/*  50 */
literal|'&'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  58 */
literal|0
block|,
literal|0
block|,
literal|'!'
block|,
literal|'$'
block|,
literal|'*'
block|,
literal|')'
block|,
literal|';'
block|,
literal|'~'
block|,
comment|/*  60 */
literal|'-'
block|,
literal|'/'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  68 */
literal|0
block|,
literal|0
block|,
literal|'|'
block|,
literal|','
block|,
literal|'%'
block|,
literal|'_'
block|,
literal|'>'
block|,
literal|'?'
block|,
comment|/*  70 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  78 */
literal|0
block|,
literal|'`'
block|,
literal|':'
block|,
literal|'#'
block|,
literal|'@'
block|,
literal|'\''
block|,
literal|'='
block|,
literal|'"'
block|,
comment|/*  80 */
literal|0
block|,
literal|7
block|,
operator|-
name|ESC_b
block|,
literal|0
block|,
operator|-
name|ESC_d
block|,
name|ESC_e
block|,
name|ESC_f
block|,
literal|0
block|,
comment|/*  88 */
operator|-
name|ESC_h
block|,
literal|0
block|,
literal|0
block|,
literal|'{'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  90 */
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_k
block|,
literal|'l'
block|,
literal|0
block|,
name|ESC_n
block|,
literal|0
block|,
operator|-
name|ESC_p
block|,
comment|/*  98 */
literal|0
block|,
name|ESC_r
block|,
literal|0
block|,
literal|'}'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  A0 */
literal|0
block|,
literal|'~'
block|,
operator|-
name|ESC_s
block|,
name|ESC_tee
block|,
literal|0
block|,
operator|-
name|ESC_v
block|,
operator|-
name|ESC_w
block|,
literal|0
block|,
comment|/*  A8 */
literal|0
block|,
operator|-
name|ESC_z
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|'['
block|,
literal|0
block|,
literal|0
block|,
comment|/*  B0 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  B8 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|']'
block|,
literal|'='
block|,
literal|'-'
block|,
comment|/*  C0 */
literal|'{'
block|,
operator|-
name|ESC_A
block|,
operator|-
name|ESC_B
block|,
operator|-
name|ESC_C
block|,
operator|-
name|ESC_D
block|,
operator|-
name|ESC_E
block|,
literal|0
block|,
operator|-
name|ESC_G
block|,
comment|/*  C8 */
operator|-
name|ESC_H
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  D0 */
literal|'}'
block|,
literal|0
block|,
operator|-
name|ESC_K
block|,
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_N
block|,
literal|0
block|,
operator|-
name|ESC_P
block|,
comment|/*  D8 */
operator|-
name|ESC_Q
block|,
operator|-
name|ESC_R
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  E0 */
literal|'\\'
block|,
literal|0
block|,
operator|-
name|ESC_S
block|,
literal|0
block|,
literal|0
block|,
operator|-
name|ESC_V
block|,
operator|-
name|ESC_W
block|,
operator|-
name|ESC_X
block|,
comment|/*  E8 */
literal|0
block|,
operator|-
name|ESC_Z
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  F0 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  F8 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Table of special "verbs" like (*PRUNE). This is a short table, so it is searched linearly. Put all the names into a single string, in order to reduce the number of relocations when a shared library is dynamically linked. The string is built from string macros so that it works in UTF-8 mode on EBCDIC platforms. */
end_comment
begin_typedef
DECL|struct|verbitem
typedef|typedef
struct|struct
name|verbitem
block|{
DECL|member|len
name|int
name|len
decl_stmt|;
comment|/* Length of verb name */
DECL|member|op
name|int
name|op
decl_stmt|;
comment|/* Op when no arg, or -1 if arg mandatory */
DECL|member|op_arg
name|int
name|op_arg
decl_stmt|;
comment|/* Op when arg present, or -1 if not allowed */
block|}
DECL|typedef|verbitem
name|verbitem
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|verbnames
specifier|static
specifier|const
name|char
name|verbnames
index|[]
init|=
literal|"\0"
comment|/* Empty name is a shorthand for MARK */
name|STRING_MARK0
name|STRING_ACCEPT0
name|STRING_COMMIT0
name|STRING_F0
name|STRING_FAIL0
name|STRING_PRUNE0
name|STRING_SKIP0
name|STRING_THEN
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|verbs
specifier|static
specifier|const
name|verbitem
name|verbs
index|[]
init|=
block|{
block|{
literal|0
block|,
operator|-
literal|1
block|,
name|OP_MARK
block|}
block|,
block|{
literal|4
block|,
operator|-
literal|1
block|,
name|OP_MARK
block|}
block|,
block|{
literal|6
block|,
name|OP_ACCEPT
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|6
block|,
name|OP_COMMIT
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|1
block|,
name|OP_FAIL
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|4
block|,
name|OP_FAIL
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|5
block|,
name|OP_PRUNE
block|,
name|OP_PRUNE_ARG
block|}
block|,
block|{
literal|4
block|,
name|OP_SKIP
block|,
name|OP_SKIP_ARG
block|}
block|,
block|{
literal|4
block|,
name|OP_THEN
block|,
name|OP_THEN_ARG
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|verbcount
specifier|static
specifier|const
name|int
name|verbcount
init|=
sizeof|sizeof
argument_list|(
name|verbs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|verbitem
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Tables of names of POSIX character classes and their lengths. The names are now all in a single string, to reduce the number of relocations when a shared library is dynamically loaded. The list of lengths is terminated by a zero length entry. The first three must be alpha, lower, upper, as this is assumed for handling case independence. */
end_comment
begin_decl_stmt
DECL|variable|posix_names
specifier|static
specifier|const
name|char
name|posix_names
index|[]
init|=
name|STRING_alpha0
name|STRING_lower0
name|STRING_upper0
name|STRING_alnum0
name|STRING_ascii0
name|STRING_blank0
name|STRING_cntrl0
name|STRING_digit0
name|STRING_graph0
name|STRING_print0
name|STRING_punct0
name|STRING_space0
name|STRING_word0
name|STRING_xdigit
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|posix_name_lengths
specifier|static
specifier|const
name|pcre_uint8
name|posix_name_lengths
index|[]
init|=
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Table of class bit maps for each POSIX class. Each class is formed from a base map, with an optional addition or removal of another map. Then, for some classes, there is some additional tweaking: for [:blank:] the vertical space characters are removed, and for [:alpha:] and [:alnum:] the underscore character is removed. The triples in the table consist of the base map offset, second map offset or -1 if no second map, and a non-negative value for map addition or a negative value for map subtraction (if there are two maps). The absolute value of the third field has these meanings: 0 => no tweaking, 1 => remove vertical space characters, 2 => remove underscore. */
end_comment
begin_decl_stmt
DECL|variable|posix_class_maps
specifier|static
specifier|const
name|int
name|posix_class_maps
index|[]
init|=
block|{
name|cbit_word
block|,
name|cbit_digit
block|,
operator|-
literal|2
block|,
comment|/* alpha */
name|cbit_lower
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* lower */
name|cbit_upper
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* upper */
name|cbit_word
block|,
operator|-
literal|1
block|,
literal|2
block|,
comment|/* alnum - word without underscore */
name|cbit_print
block|,
name|cbit_cntrl
block|,
literal|0
block|,
comment|/* ascii */
name|cbit_space
block|,
operator|-
literal|1
block|,
literal|1
block|,
comment|/* blank - a GNU extension */
name|cbit_cntrl
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* cntrl */
name|cbit_digit
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* digit */
name|cbit_graph
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* graph */
name|cbit_print
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* print */
name|cbit_punct
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* punct */
name|cbit_space
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* space */
name|cbit_word
block|,
operator|-
literal|1
block|,
literal|0
block|,
comment|/* word - a Perl extension */
name|cbit_xdigit
block|,
operator|-
literal|1
block|,
literal|0
comment|/* xdigit */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Table of substitutes for \d etc when PCRE_UCP is set. The POSIX class substitutes must be in the order of the names, defined above, and there are both positive and negative cases. NULL means no substitute. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UCP
end_ifdef
begin_decl_stmt
DECL|variable|string_PNd
specifier|static
specifier|const
name|pcre_uchar
name|string_PNd
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_N
block|,
name|CHAR_d
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pNd
specifier|static
specifier|const
name|pcre_uchar
name|string_pNd
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_N
block|,
name|CHAR_d
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_PXsp
specifier|static
specifier|const
name|pcre_uchar
name|string_PXsp
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_s
block|,
name|CHAR_p
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pXsp
specifier|static
specifier|const
name|pcre_uchar
name|string_pXsp
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_s
block|,
name|CHAR_p
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_PXwd
specifier|static
specifier|const
name|pcre_uchar
name|string_PXwd
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_w
block|,
name|CHAR_d
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pXwd
specifier|static
specifier|const
name|pcre_uchar
name|string_pXwd
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_w
block|,
name|CHAR_d
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|substitutes
specifier|static
specifier|const
name|pcre_uchar
modifier|*
name|substitutes
index|[]
init|=
block|{
name|string_PNd
block|,
comment|/* \D */
name|string_pNd
block|,
comment|/* \d */
name|string_PXsp
block|,
comment|/* \S */
comment|/* NOTE: Xsp is Perl space */
name|string_pXsp
block|,
comment|/* \s */
name|string_PXwd
block|,
comment|/* \W */
name|string_pXwd
comment|/* \w */
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pL
specifier|static
specifier|const
name|pcre_uchar
name|string_pL
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_L
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pLl
specifier|static
specifier|const
name|pcre_uchar
name|string_pLl
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_L
block|,
name|CHAR_l
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pLu
specifier|static
specifier|const
name|pcre_uchar
name|string_pLu
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_L
block|,
name|CHAR_u
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pXan
specifier|static
specifier|const
name|pcre_uchar
name|string_pXan
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_a
block|,
name|CHAR_n
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_h
specifier|static
specifier|const
name|pcre_uchar
name|string_h
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_h
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_pXps
specifier|static
specifier|const
name|pcre_uchar
name|string_pXps
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_p
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_p
block|,
name|CHAR_s
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_PL
specifier|static
specifier|const
name|pcre_uchar
name|string_PL
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_L
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_PLl
specifier|static
specifier|const
name|pcre_uchar
name|string_PLl
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_L
block|,
name|CHAR_l
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_PLu
specifier|static
specifier|const
name|pcre_uchar
name|string_PLu
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_L
block|,
name|CHAR_u
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_PXan
specifier|static
specifier|const
name|pcre_uchar
name|string_PXan
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_a
block|,
name|CHAR_n
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_H
specifier|static
specifier|const
name|pcre_uchar
name|string_H
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_H
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|string_PXps
specifier|static
specifier|const
name|pcre_uchar
name|string_PXps
index|[]
init|=
block|{
name|CHAR_BACKSLASH
block|,
name|CHAR_P
block|,
name|CHAR_LEFT_CURLY_BRACKET
block|,
name|CHAR_X
block|,
name|CHAR_p
block|,
name|CHAR_s
block|,
name|CHAR_RIGHT_CURLY_BRACKET
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|posix_substitutes
specifier|static
specifier|const
name|pcre_uchar
modifier|*
name|posix_substitutes
index|[]
init|=
block|{
name|string_pL
block|,
comment|/* alpha */
name|string_pLl
block|,
comment|/* lower */
name|string_pLu
block|,
comment|/* upper */
name|string_pXan
block|,
comment|/* alnum */
name|NULL
block|,
comment|/* ascii */
name|string_h
block|,
comment|/* blank */
name|NULL
block|,
comment|/* cntrl */
name|string_pNd
block|,
comment|/* digit */
name|NULL
block|,
comment|/* graph */
name|NULL
block|,
comment|/* print */
name|NULL
block|,
comment|/* punct */
name|string_pXps
block|,
comment|/* space */
comment|/* NOTE: Xps is POSIX space */
name|string_pXwd
block|,
comment|/* word */
name|NULL
block|,
comment|/* xdigit */
comment|/* Negated cases */
name|string_PL
block|,
comment|/* ^alpha */
name|string_PLl
block|,
comment|/* ^lower */
name|string_PLu
block|,
comment|/* ^upper */
name|string_PXan
block|,
comment|/* ^alnum */
name|NULL
block|,
comment|/* ^ascii */
name|string_H
block|,
comment|/* ^blank */
name|NULL
block|,
comment|/* ^cntrl */
name|string_PNd
block|,
comment|/* ^digit */
name|NULL
block|,
comment|/* ^graph */
name|NULL
block|,
comment|/* ^print */
name|NULL
block|,
comment|/* ^punct */
name|string_PXps
block|,
comment|/* ^space */
comment|/* NOTE: Xps is POSIX space */
name|string_PXwd
block|,
comment|/* ^word */
name|NULL
comment|/* ^xdigit */
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|POSIX_SUBSIZE
define|#
directive|define
name|POSIX_SUBSIZE
value|(sizeof(posix_substitutes) / sizeof(pcre_uchar *))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|STRING
define|#
directive|define
name|STRING
parameter_list|(
name|a
parameter_list|)
value|# a
end_define
begin_define
DECL|macro|XSTRING
define|#
directive|define
name|XSTRING
parameter_list|(
name|s
parameter_list|)
value|STRING(s)
end_define
begin_comment
comment|/* The texts of compile-time error messages. These are "char *" because they are passed to the outside world. Do not ever re-use any error number, because they are documented. Always add a new error instead. Messages marked DEAD below are no longer used. This used to be a table of strings, but in order to reduce the number of relocations needed when a shared library is loaded dynamically, it is now one long string. We cannot use a table of offsets, because the lengths of inserts such as XSTRING(MAX_NAME_SIZE) are not known. Instead, we simply count through to the one we want - this isn't a performance issue because these strings are used only when there is a compilation error.  Each substring ends with \0 to insert a null character. This includes the final substring, so that the whole string ends with \0\0, which can be detected when counting through. */
end_comment
begin_decl_stmt
DECL|variable|error_texts
specifier|static
specifier|const
name|char
name|error_texts
index|[]
init|=
literal|"no error\0"
literal|"\\ at end of pattern\0"
literal|"\\c at end of pattern\0"
literal|"unrecognized character follows \\\0"
literal|"numbers out of order in {} quantifier\0"
comment|/* 5 */
literal|"number too big in {} quantifier\0"
literal|"missing terminating ] for character class\0"
literal|"invalid escape sequence in character class\0"
literal|"range out of order in character class\0"
literal|"nothing to repeat\0"
comment|/* 10 */
literal|"operand of unlimited repeat could match the empty string\0"
comment|/** DEAD **/
literal|"internal error: unexpected repeat\0"
literal|"unrecognized character after (? or (?-\0"
literal|"POSIX named classes are supported only within a class\0"
literal|"missing )\0"
comment|/* 15 */
literal|"reference to non-existent subpattern\0"
literal|"erroffset passed as NULL\0"
literal|"unknown option bit(s) set\0"
literal|"missing ) after comment\0"
literal|"parentheses nested too deeply\0"
comment|/** DEAD **/
comment|/* 20 */
literal|"regular expression is too large\0"
literal|"failed to get memory\0"
literal|"unmatched parentheses\0"
literal|"internal error: code overflow\0"
literal|"unrecognized character after (?<\0"
comment|/* 25 */
literal|"lookbehind assertion is not fixed length\0"
literal|"malformed number or name after (?(\0"
literal|"conditional group contains more than two branches\0"
literal|"assertion expected after (?(\0"
literal|"(?R or (?[+-]digits must be followed by )\0"
comment|/* 30 */
literal|"unknown POSIX class name\0"
literal|"POSIX collating elements are not supported\0"
literal|"this version of PCRE is compiled without UTF support\0"
literal|"spare error\0"
comment|/** DEAD **/
literal|"character value in \\x{...} sequence is too large\0"
comment|/* 35 */
literal|"invalid condition (?(0)\0"
literal|"\\C not allowed in lookbehind assertion\0"
literal|"PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\0"
literal|"number after (?C is> 255\0"
literal|"closing ) for (?C expected\0"
comment|/* 40 */
literal|"recursive call could loop indefinitely\0"
literal|"unrecognized character after (?P\0"
literal|"syntax error in subpattern name (missing terminator)\0"
literal|"two named subpatterns have the same name\0"
literal|"invalid UTF-8 string\0"
comment|/* 45 */
literal|"support for \\P, \\p, and \\X has not been compiled\0"
literal|"malformed \\P or \\p sequence\0"
literal|"unknown property name after \\P or \\p\0"
literal|"subpattern name is too long (maximum "
name|XSTRING
argument_list|(
name|MAX_NAME_SIZE
argument_list|)
literal|" characters)\0"
literal|"too many named subpatterns (maximum "
name|XSTRING
argument_list|(
name|MAX_NAME_COUNT
argument_list|)
literal|")\0"
comment|/* 50 */
literal|"repeated subpattern is too long\0"
comment|/** DEAD **/
literal|"octal value is greater than \\377 in 8-bit non-UTF-8 mode\0"
literal|"internal error: overran compiling workspace\0"
literal|"internal error: previously-checked referenced subpattern not found\0"
literal|"DEFINE group contains more than one branch\0"
comment|/* 55 */
literal|"repeating a DEFINE group is not allowed\0"
comment|/** DEAD **/
literal|"inconsistent NEWLINE options\0"
literal|"\\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\0"
literal|"a numbered reference must not be zero\0"
literal|"an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)\0"
comment|/* 60 */
literal|"(*VERB) not recognized\0"
literal|"number is too big\0"
literal|"subpattern name expected\0"
literal|"digit expected after (?+\0"
literal|"] is an invalid data character in JavaScript compatibility mode\0"
comment|/* 65 */
literal|"different names for subpatterns of the same number are not allowed\0"
literal|"(*MARK) must have an argument\0"
literal|"this version of PCRE is not compiled with Unicode property support\0"
literal|"\\c must be followed by an ASCII character\0"
literal|"\\k is not followed by a braced, angle-bracketed, or quoted name\0"
comment|/* 70 */
literal|"internal error: unknown opcode in find_fixedlength()\0"
literal|"\\N is not supported in a class\0"
literal|"too many forward references\0"
literal|"disallowed Unicode code point (>= 0xd800&&<= 0xdfff)\0"
literal|"invalid UTF-16 string\0"
comment|/* 75 */
literal|"name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)\0"
literal|"character value in \\u.... sequence is too large\0"
literal|"invalid UTF-32 string\0"
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Table to identify digits and hex digits. This is used when compiling patterns. Note that the tables in chartables are dependent on the locale, and may mark arbitrary characters as digits - but the PCRE compiling code expects to handle only 0-9, a-z, and A-Z as digits when compiling. That is why we have a private table here. It costs 256 bytes, but it is a lot faster than doing character value tests (at least in some simple cases I timed), and in some applications one wants PCRE to compile efficiently as well as match efficiently.  For convenience, we use the same bit definitions as in chartables:    0x04   decimal digit   0x08   hexadecimal digit  Then we can use ctype_digit and ctype_xdigit in the code. */
end_comment
begin_comment
comment|/* Using a simple comparison for decimal numbers rather than a memory read is much faster, and the resulting code is simpler (the compiler turns it into a subtraction and unsigned comparison). */
end_comment
begin_define
DECL|macro|IS_DIGIT
define|#
directive|define
name|IS_DIGIT
parameter_list|(
name|x
parameter_list|)
value|((x)>= CHAR_0&& (x)<= CHAR_9)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|EBCDIC
end_ifndef
begin_comment
comment|/* This is the "normal" case, for ASCII systems, and EBCDIC systems running in UTF-8 mode. */
end_comment
begin_decl_stmt
DECL|variable|digitab
specifier|static
specifier|const
name|pcre_uint8
name|digitab
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*   0-  7 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*   8- 15 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  16- 23 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  24- 31 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*    - '  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  ( - /  */
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
comment|/*  0 - 7  */
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  8 - ?  */
literal|0x00
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/*  @ - G  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  H - O  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  P - W  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  X - _  */
literal|0x00
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/*  ` - g  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  h - o  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  p - w  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  x -127 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 128-135 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 136-143 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 144-151 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 152-159 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 160-167 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 168-175 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 176-183 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 184-191 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 192-199 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 200-207 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 208-215 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 216-223 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 224-231 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 232-239 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 240-247 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* 248-255 */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* This is the "abnormal" case, for EBCDIC systems not running in UTF-8 mode. */
end_comment
begin_decl_stmt
DECL|variable|digitab
specifier|static
specifier|const
name|pcre_uint8
name|digitab
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*   0-  7  0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*   8- 15    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  16- 23 10 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  24- 31    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  32- 39 20 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  40- 47    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  48- 55 30 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  56- 63    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*    - 71 40 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  72- |     */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*& - 87 50 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  88- 95    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  - -103 60 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 104- ?     */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 112-119 70 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 120- "     */
literal|0x00
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/* 128- g  80 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  h -143    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 144- p  90 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  q -159    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 160- x  A0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  y -175    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  ^ -183 B0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 184-191    */
literal|0x00
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/*  { - G  C0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  H -207    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  } - P  D0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  Q -223    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  \ - X  E0 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  Y -239    */
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0c
block|,
comment|/*  0 - 7  F0 */
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  8 -255    */
end_comment
begin_decl_stmt
DECL|variable|ebcdic_chartab
specifier|static
specifier|const
name|pcre_uint8
name|ebcdic_chartab
index|[]
init|=
block|{
comment|/* chartable partial dup */
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*   0-  7 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*   8- 15 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  16- 23 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  24- 31 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  32- 39 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  40- 47 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  48- 55 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  56- 63 */
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*    - 71 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
comment|/*  72- |  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*& - 87 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  88- 95 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  - -103 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x80
block|,
comment|/* 104- ?  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 112-119 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 120- "  */
literal|0x00
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x12
block|,
comment|/* 128- g  */
literal|0x12
block|,
literal|0x12
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  h -143 */
literal|0x00
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
comment|/* 144- p  */
literal|0x12
block|,
literal|0x12
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  q -159 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
comment|/* 160- x  */
literal|0x12
block|,
literal|0x12
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  y -175 */
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  ^ -183 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 184-191 */
literal|0x80
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x12
block|,
comment|/*  { - G  */
literal|0x12
block|,
literal|0x12
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  H -207 */
literal|0x00
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
comment|/*  } - P  */
literal|0x12
block|,
literal|0x12
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  Q -223 */
literal|0x00
block|,
literal|0x00
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x12
block|,
comment|/*  \ - X  */
literal|0x12
block|,
literal|0x12
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*  Y -239 */
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x1c
block|,
comment|/*  0 - 7  */
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  8 -255 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/************************************************* *            Find an error text                  * *************************************************/
end_comment
begin_comment
comment|/* The error texts are now all in one long string, to save on relocations. As some of the text is of unknown length, we can't use a table of offsets. Instead, just count through the strings. This is not a performance issue because it happens only when there has been a compilation error.  Argument:   the error number Returns:    pointer to the error string */
end_comment
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|find_error_text
name|find_error_text
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|error_texts
decl_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
operator|!=
name|CHAR_NULL
condition|)
block|{}
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|CHAR_NULL
condition|)
return|return
literal|"Error text not found (please report)"
return|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/************************************************* *           Expand the workspace                 * *************************************************/
end_comment
begin_comment
comment|/* This function is called during the second compiling phase, if the number of forward references fills the existing workspace, which is originally a block on the stack. A larger block is obtained from malloc() unless the ultimate limit has been reached or the increase will be rather small.  Argument: pointer to the compile data block Returns:  0 if all went well, else an error number */
end_comment
begin_function
specifier|static
name|int
DECL|function|expand_workspace
name|expand_workspace
parameter_list|(
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|newspace
decl_stmt|;
name|int
name|newsize
init|=
name|cd
operator|->
name|workspace_size
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|newsize
operator|>
name|COMPILE_WORK_SIZE_MAX
condition|)
name|newsize
operator|=
name|COMPILE_WORK_SIZE_MAX
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|workspace_size
operator|>=
name|COMPILE_WORK_SIZE_MAX
operator|||
name|newsize
operator|-
name|cd
operator|->
name|workspace_size
operator|<
name|WORK_SIZE_SAFETY_MARGIN
condition|)
return|return
name|ERR72
return|;
name|newspace
operator|=
operator|(
name|PUBL
argument_list|(
name|malloc
argument_list|)
operator|)
operator|(
name|IN_UCHARS
argument_list|(
name|newsize
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|newspace
operator|==
name|NULL
condition|)
return|return
name|ERR21
return|;
name|memcpy
argument_list|(
name|newspace
argument_list|,
name|cd
operator|->
name|start_workspace
argument_list|,
name|cd
operator|->
name|workspace_size
operator|*
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|hwm
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|newspace
operator|+
operator|(
name|cd
operator|->
name|hwm
operator|-
name|cd
operator|->
name|start_workspace
operator|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|workspace_size
operator|>
name|COMPILE_WORK_SIZE
condition|)
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|cd
operator|->
name|start_workspace
operator|)
expr_stmt|;
name|cd
operator|->
name|start_workspace
operator|=
name|newspace
expr_stmt|;
name|cd
operator|->
name|workspace_size
operator|=
name|newsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/************************************************* *            Check for counted repeat            * *************************************************/
end_comment
begin_comment
comment|/* This function is called when a '{' is encountered in a place where it might start a quantifier. It looks ahead to see if it really is a quantifier or not. It is only a quantifier if it is one of the forms {ddd} {ddd,} or {ddd,ddd} where the ddds are digits.  Arguments:   p         pointer to the first char after '{'  Returns:    TRUE or FALSE */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|is_counted_repeat
name|is_counted_repeat
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|CHAR_COMMA
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|p
operator|==
name|CHAR_RIGHT_CURLY_BRACKET
operator|)
return|;
block|}
end_function
begin_comment
comment|/************************************************* *            Handle escapes                      * *************************************************/
end_comment
begin_comment
comment|/* This function is called when a \ has been encountered. It either returns a positive value for a simple escape such as \n, or 0 for a data character which will be placed in chptr. A backreference to group n is returned as negative n. When UTF-8 is enabled, a positive value greater than 255 may be returned in chptr. On entry,ptr is pointing at the \. On exit, it is on the final character of the escape sequence.  Arguments:   ptrptr         points to the pattern position pointer   chptr          points to the data character   errorcodeptr   points to the errorcode variable   bracount       number of previous extracting brackets   options        the options bits   isclass        TRUE if inside a character class  Returns:         zero => a data character                  positive => a special escape sequence                  negative => a back reference                  on error, errorcodeptr is set */
end_comment
begin_function
specifier|static
name|int
DECL|function|check_escape
name|check_escape
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
modifier|*
name|ptrptr
parameter_list|,
name|pcre_uint32
modifier|*
name|chptr
parameter_list|,
name|int
modifier|*
name|errorcodeptr
parameter_list|,
name|int
name|bracount
parameter_list|,
name|int
name|options
parameter_list|,
name|BOOL
name|isclass
parameter_list|)
block|{
comment|/* PCRE_UTF16 has the same value as PCRE_UTF8. */
name|BOOL
name|utf
init|=
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|ptr
init|=
operator|*
name|ptrptr
operator|+
literal|1
decl_stmt|;
name|pcre_uint32
name|c
decl_stmt|;
name|int
name|escape
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GETCHARINCTEST
argument_list|(
name|c
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Get character value, increment pointer */
name|ptr
operator|--
expr_stmt|;
comment|/* Set pointer back to the last byte */
comment|/* If backslash is at the end of the pattern, it's an error. */
if|if
condition|(
name|c
operator|==
name|CHAR_NULL
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR1
expr_stmt|;
comment|/* Non-alphanumerics are literals. For digits or letters, do an initial lookup in a table. A non-zero result is something that can be returned immediately. Otherwise further processing may be required. */
ifndef|#
directive|ifndef
name|EBCDIC
comment|/* ASCII/UTF-8 coding */
comment|/* Not alphanumeric */
elseif|else
if|if
condition|(
name|c
operator|<
name|CHAR_0
operator|||
name|c
operator|>
name|CHAR_z
condition|)
block|{}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|escapes
index|[
name|c
operator|-
name|CHAR_0
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|c
operator|=
operator|(
name|pcre_uint32
operator|)
name|i
expr_stmt|;
else|else
name|escape
operator|=
operator|-
name|i
expr_stmt|;
block|}
else|#
directive|else
comment|/* EBCDIC coding */
comment|/* Not alphanumeric */
elseif|else
if|if
condition|(
name|c
operator|<
name|CHAR_a
operator|||
operator|(
operator|!
name|MAX_255
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|ebcdic_chartab
index|[
name|c
index|]
operator|&
literal|0x0E
operator|)
operator|==
literal|0
operator|)
condition|)
block|{}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|escapes
index|[
name|c
operator|-
literal|0x48
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|c
operator|=
operator|(
name|pcre_uint32
operator|)
name|i
expr_stmt|;
else|else
name|escape
operator|=
operator|-
name|i
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Escapes that need further processing, or are illegal. */
else|else
block|{
specifier|const
name|pcre_uchar
modifier|*
name|oldptr
decl_stmt|;
name|BOOL
name|braced
decl_stmt|,
name|negated
decl_stmt|,
name|overflow
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* A number of Perl escapes are not handled by PCRE. We give an explicit     error. */
case|case
name|CHAR_l
case|:
case|case
name|CHAR_L
case|:
operator|*
name|errorcodeptr
operator|=
name|ERR37
expr_stmt|;
break|break;
case|case
name|CHAR_u
case|:
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* In JavaScript, \u must be followed by four hexadecimal numbers.       Otherwise it is a lowercase u letter. */
if|if
condition|(
name|MAX_255
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|digitab
index|[
name|ptr
index|[
literal|1
index|]
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
operator|&&
name|MAX_255
argument_list|(
name|ptr
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|digitab
index|[
name|ptr
index|[
literal|2
index|]
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
operator|&&
name|MAX_255
argument_list|(
name|ptr
index|[
literal|3
index|]
argument_list|)
operator|&&
operator|(
name|digitab
index|[
name|ptr
index|[
literal|3
index|]
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
operator|&&
name|MAX_255
argument_list|(
name|ptr
index|[
literal|4
index|]
argument_list|)
operator|&&
operator|(
name|digitab
index|[
name|ptr
index|[
literal|4
index|]
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|pcre_uint32
name|cc
init|=
operator|*
operator|(
operator|++
name|ptr
operator|)
decl_stmt|;
ifndef|#
directive|ifndef
name|EBCDIC
comment|/* ASCII/UTF-8 coding */
if|if
condition|(
name|cc
operator|>=
name|CHAR_a
condition|)
name|cc
operator|-=
literal|32
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
operator|(
name|c
operator|<<
literal|4
operator|)
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|<
name|CHAR_A
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* EBCDIC coding */
if|if
condition|(
name|cc
operator|>=
name|CHAR_a
operator|&&
name|cc
operator|<=
name|CHAR_z
condition|)
name|cc
operator|+=
literal|64
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
operator|(
name|c
operator|<<
literal|4
operator|)
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|>=
name|CHAR_0
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|c
operator|>
operator|(
name|utf
condition|?
literal|0x10ffff
else|:
literal|0xff
operator|)
condition|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|c
operator|>
operator|(
name|utf
condition|?
literal|0x10ffff
else|:
literal|0xffff
operator|)
condition|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
name|c
operator|>
literal|0x10ffff
condition|)
endif|#
directive|endif
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR76
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|utf
operator|&&
name|c
operator|>=
literal|0xd800
operator|&&
name|c
operator|<=
literal|0xdfff
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR73
expr_stmt|;
block|}
block|}
else|else
operator|*
name|errorcodeptr
operator|=
name|ERR37
expr_stmt|;
break|break;
case|case
name|CHAR_U
case|:
comment|/* In JavaScript, \U is an uppercase U letter. */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|==
literal|0
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR37
expr_stmt|;
break|break;
comment|/* In a character class, \g is just a literal "g". Outside a character     class, \g must be followed by one of a number of specific things:      (1) A number, either plain or braced. If positive, it is an absolute     backreference. If negative, it is a relative backreference. This is a Perl     5.10 feature.      (2) Perl 5.10 also supports \g{name} as a reference to a named group. This     is part of Perl's movement towards a unified syntax for back references. As     this is synonymous with \k{name}, we fudge it up by pretending it really     was \k.      (3) For Oniguruma compatibility we also support \g followed by a name or a     number either in angle brackets or in single quotes. However, these are     (possibly recursive) subroutine calls, _not_ backreferences. Just return     the ESC_g code (cf \k). */
case|case
name|CHAR_g
case|:
if|if
condition|(
name|isclass
condition|)
break|break;
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_LESS_THAN_SIGN
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_APOSTROPHE
condition|)
block|{
name|escape
operator|=
name|ESC_g
expr_stmt|;
break|break;
block|}
comment|/* Handle the Perl-compatible cases */
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_LEFT_CURLY_BRACKET
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ptr
operator|+
literal|2
init|;
operator|*
name|p
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|p
operator|!=
name|CHAR_RIGHT_CURLY_BRACKET
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
name|CHAR_MINUS
operator|&&
operator|!
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|p
operator|!=
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
block|{
name|escape
operator|=
name|ESC_k
expr_stmt|;
break|break;
block|}
name|braced
operator|=
name|TRUE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
name|braced
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_MINUS
condition|)
block|{
name|negated
operator|=
name|TRUE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
name|negated
operator|=
name|FALSE
expr_stmt|;
comment|/* The integer range is limited by the machine's int representation. */
name|s
operator|=
literal|0
expr_stmt|;
name|overflow
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|>
name|INT_MAX
operator|/
literal|10
operator|-
literal|1
condition|)
comment|/* Integer overflow */
block|{
name|overflow
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|s
operator|*
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|-
name|CHAR_0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
comment|/* Integer overflow */
block|{
while|while
condition|(
name|IS_DIGIT
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|errorcodeptr
operator|=
name|ERR61
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|braced
operator|&&
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|!=
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR57
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR58
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|negated
condition|)
block|{
if|if
condition|(
name|s
operator|>
name|bracount
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR15
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|bracount
operator|-
operator|(
name|s
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|escape
operator|=
operator|-
name|s
expr_stmt|;
break|break;
comment|/* The handling of escape sequences consisting of a string of digits     starting with one that is not zero is not straightforward. By experiment,     the way Perl works seems to be as follows:      Outside a character class, the digits are read as a decimal number. If the     number is less than 10, or if there are that many previous extracting     left brackets, then it is a back reference. Otherwise, up to three octal     digits are read to form an escaped byte. Thus \123 is likely to be octal     123 (cf \0123, which is octal 012 followed by the literal 3). If the octal     value is greater than 377, the least significant 8 bits are taken. Inside a     character class, \ followed by a digit is always an octal number. */
case|case
name|CHAR_1
case|:
case|case
name|CHAR_2
case|:
case|case
name|CHAR_3
case|:
case|case
name|CHAR_4
case|:
case|case
name|CHAR_5
case|:
case|case
name|CHAR_6
case|:
case|case
name|CHAR_7
case|:
case|case
name|CHAR_8
case|:
case|case
name|CHAR_9
case|:
if|if
condition|(
operator|!
name|isclass
condition|)
block|{
name|oldptr
operator|=
name|ptr
expr_stmt|;
comment|/* The integer range is limited by the machine's int representation. */
name|s
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|-
name|CHAR_0
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|>
name|INT_MAX
operator|/
literal|10
operator|-
literal|1
condition|)
comment|/* Integer overflow */
block|{
name|overflow
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|s
operator|*
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|-
name|CHAR_0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
comment|/* Integer overflow */
block|{
while|while
condition|(
name|IS_DIGIT
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|errorcodeptr
operator|=
name|ERR61
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|<
literal|10
operator|||
name|s
operator|<=
name|bracount
condition|)
block|{
name|escape
operator|=
operator|-
name|s
expr_stmt|;
break|break;
block|}
name|ptr
operator|=
name|oldptr
expr_stmt|;
comment|/* Put the pointer back and fall through */
block|}
comment|/* Handle an octal number following \. If the first digit is 8 or 9, Perl     generates a binary zero byte and treats the digit as a following literal.     Thus we have to pull back the pointer by one. */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|ptr
operator|)
operator|>=
name|CHAR_8
condition|)
block|{
name|ptr
operator|--
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* \0 always starts an octal number, but we may drop through to here with a     larger first octal digit. The original code used just to take the least     significant 8 bits of octal numbers (I think this is what early Perls used     to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,     but no more than 3 octal digits. */
case|case
name|CHAR_0
case|:
name|c
operator|-=
name|CHAR_0
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
literal|2
operator|&&
name|ptr
index|[
literal|1
index|]
operator|>=
name|CHAR_0
operator|&&
name|ptr
index|[
literal|1
index|]
operator|<=
name|CHAR_7
condition|)
name|c
operator|=
name|c
operator|*
literal|8
operator|+
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|-
name|CHAR_0
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
operator|!
name|utf
operator|&&
name|c
operator|>
literal|0xff
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR51
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* \x is complicated. \x{ddd} is a character number which can be greater     than 0xff in utf or non-8bit mode, but only if the ddd are hex digits.     If not, { is treated as a data character. */
case|case
name|CHAR_x
case|:
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* In JavaScript, \x must be followed by two hexadecimal numbers.       Otherwise it is a lowercase x letter. */
if|if
condition|(
name|MAX_255
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|digitab
index|[
name|ptr
index|[
literal|1
index|]
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
operator|&&
name|MAX_255
argument_list|(
name|ptr
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|digitab
index|[
name|ptr
index|[
literal|2
index|]
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|pcre_uint32
name|cc
init|=
operator|*
operator|(
operator|++
name|ptr
operator|)
decl_stmt|;
ifndef|#
directive|ifndef
name|EBCDIC
comment|/* ASCII/UTF-8 coding */
if|if
condition|(
name|cc
operator|>=
name|CHAR_a
condition|)
name|cc
operator|-=
literal|32
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
operator|(
name|c
operator|<<
literal|4
operator|)
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|<
name|CHAR_A
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* EBCDIC coding */
if|if
condition|(
name|cc
operator|>=
name|CHAR_a
operator|&&
name|cc
operator|<=
name|CHAR_z
condition|)
name|cc
operator|+=
literal|64
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
operator|(
name|c
operator|<<
literal|4
operator|)
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|>=
name|CHAR_0
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
block|}
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_LEFT_CURLY_BRACKET
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|pt
init|=
name|ptr
operator|+
literal|2
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|overflow
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|pt
argument_list|)
operator|&&
operator|(
name|digitab
index|[
operator|*
name|pt
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|pcre_uint32
name|cc
init|=
operator|*
name|pt
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|cc
operator|==
name|CHAR_0
condition|)
continue|continue;
comment|/* Leading zeroes */
ifdef|#
directive|ifdef
name|COMPILE_PCRE32
if|if
condition|(
name|c
operator|>=
literal|0x10000000l
condition|)
block|{
name|overflow
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EBCDIC
comment|/* ASCII/UTF-8 coding */
if|if
condition|(
name|cc
operator|>=
name|CHAR_a
condition|)
name|cc
operator|-=
literal|32
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
operator|(
name|c
operator|<<
literal|4
operator|)
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|<
name|CHAR_A
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* EBCDIC coding */
if|if
condition|(
name|cc
operator|>=
name|CHAR_a
operator|&&
name|cc
operator|<=
name|CHAR_z
condition|)
name|cc
operator|+=
literal|64
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
operator|(
name|c
operator|<<
literal|4
operator|)
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|>=
name|CHAR_0
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|c
operator|>
operator|(
name|utf
condition|?
literal|0x10ffff
else|:
literal|0xff
operator|)
condition|)
block|{
name|overflow
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|c
operator|>
operator|(
name|utf
condition|?
literal|0x10ffff
else|:
literal|0xffff
operator|)
condition|)
block|{
name|overflow
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
name|c
operator|>
literal|0x10ffff
condition|)
block|{
name|overflow
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|overflow
condition|)
block|{
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|pt
argument_list|)
operator|&&
operator|(
name|digitab
index|[
operator|*
name|pt
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
condition|)
name|pt
operator|++
expr_stmt|;
operator|*
name|errorcodeptr
operator|=
name|ERR34
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pt
operator|==
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
block|{
if|if
condition|(
name|utf
operator|&&
name|c
operator|>=
literal|0xd800
operator|&&
name|c
operator|<=
literal|0xdfff
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR73
expr_stmt|;
name|ptr
operator|=
name|pt
expr_stmt|;
break|break;
block|}
comment|/* If the sequence of hex digits does not end with '}', then we don't       recognize this construct; fall through to the normal \x handling. */
block|}
comment|/* Read just a single-byte hex-defined char */
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
literal|2
operator|&&
name|MAX_255
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|digitab
index|[
name|ptr
index|[
literal|1
index|]
index|]
operator|&
name|ctype_xdigit
operator|)
operator|!=
literal|0
condition|)
block|{
name|pcre_uint32
name|cc
decl_stmt|;
comment|/* Some compilers don't like */
name|cc
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
comment|/* ++ in initializers */
ifndef|#
directive|ifndef
name|EBCDIC
comment|/* ASCII/UTF-8 coding */
if|if
condition|(
name|cc
operator|>=
name|CHAR_a
condition|)
name|cc
operator|-=
literal|32
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
name|c
operator|*
literal|16
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|<
name|CHAR_A
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* EBCDIC coding */
if|if
condition|(
name|cc
operator|<=
name|CHAR_z
condition|)
name|cc
operator|+=
literal|64
expr_stmt|;
comment|/* Convert to upper case */
name|c
operator|=
name|c
operator|*
literal|16
operator|+
name|cc
operator|-
operator|(
operator|(
name|cc
operator|>=
name|CHAR_0
operator|)
condition|?
name|CHAR_0
else|:
operator|(
name|CHAR_A
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
comment|/* For \c, a following letter is upper-cased; then the 0x40 bit is flipped.     An error is given if the byte following \c is not an ASCII character. This     coding is ASCII-specific, but then the whole concept of \cx is     ASCII-specific. (However, an EBCDIC equivalent has now been added.) */
case|case
name|CHAR_c
case|:
name|c
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CHAR_NULL
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR2
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|EBCDIC
comment|/* ASCII/UTF-8 coding */
if|if
condition|(
name|c
operator|>
literal|127
condition|)
comment|/* Excludes all non-ASCII in either mode */
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR68
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|>=
name|CHAR_a
operator|&&
name|c
operator|<=
name|CHAR_z
condition|)
name|c
operator|-=
literal|32
expr_stmt|;
name|c
operator|^=
literal|0x40
expr_stmt|;
else|#
directive|else
comment|/* EBCDIC coding */
if|if
condition|(
name|c
operator|>=
name|CHAR_a
operator|&&
name|c
operator|<=
name|CHAR_z
condition|)
name|c
operator|+=
literal|64
expr_stmt|;
name|c
operator|^=
literal|0xC0
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* PCRE_EXTRA enables extensions to Perl in the matter of escapes. Any     other alphanumeric following \ is an error if PCRE_EXTRA was set;     otherwise, for Perl compatibility, it is a literal. This code looks a bit     odd, but there used to be some cases other than the default, and there may     be again in future, so I haven't "optimized" it. */
default|default:
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_EXTRA
operator|)
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
operator|*
name|errorcodeptr
operator|=
name|ERR3
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
comment|/* Perl supports \N{name} for character names, as well as plain \N for "not newline". PCRE does not support \N{name}. However, it does support quantification such as \N{2,3}. */
if|if
condition|(
name|escape
operator|==
name|ESC_N
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_LEFT_CURLY_BRACKET
operator|&&
operator|!
name|is_counted_repeat
argument_list|(
name|ptr
operator|+
literal|2
argument_list|)
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR37
expr_stmt|;
comment|/* If PCRE_UCP is set, we change the values for \d etc. */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
operator|&&
name|escape
operator|>=
name|ESC_D
operator|&&
name|escape
operator|<=
name|ESC_w
condition|)
name|escape
operator|+=
operator|(
name|ESC_DU
operator|-
name|ESC_D
operator|)
expr_stmt|;
comment|/* Set the pointer to the final character before returning. */
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
operator|*
name|chptr
operator|=
name|c
expr_stmt|;
return|return
name|escape
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UCP
end_ifdef
begin_comment
comment|/************************************************* *               Handle \P and \p                 * *************************************************/
end_comment
begin_comment
comment|/* This function is called after \P or \p has been encountered, provided that PCRE is compiled with support for Unicode properties. On entry, ptrptr is pointing at the P or p. On exit, it is pointing at the final character of the escape sequence.  Argument:   ptrptr         points to the pattern position pointer   negptr         points to a boolean that is set TRUE for negation else FALSE   ptypeptr       points to an unsigned int that is set to the type value   pdataptr       points to an unsigned int that is set to the detailed property value   errorcodeptr   points to the error code variable  Returns:         TRUE if the type value was found, or FALSE for an invalid type */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|get_ucp
name|get_ucp
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
modifier|*
name|ptrptr
parameter_list|,
name|BOOL
modifier|*
name|negptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|ptypeptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|pdataptr
parameter_list|,
name|int
modifier|*
name|errorcodeptr
parameter_list|)
block|{
name|pcre_uchar
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bot
decl_stmt|,
name|top
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|ptr
init|=
operator|*
name|ptrptr
decl_stmt|;
name|pcre_uchar
name|name
index|[
literal|32
index|]
decl_stmt|;
name|c
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|ERROR_RETURN
goto|;
operator|*
name|negptr
operator|=
name|FALSE
expr_stmt|;
comment|/* \P or \p can be followed by a name in {}, optionally preceded by ^ for negation. */
if|if
condition|(
name|c
operator|==
name|CHAR_LEFT_CURLY_BRACKET
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_CIRCUMFLEX_ACCENT
condition|)
block|{
operator|*
name|negptr
operator|=
name|TRUE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|ERROR_RETURN
goto|;
if|if
condition|(
name|c
operator|==
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
break|break;
name|name
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
goto|goto
name|ERROR_RETURN
goto|;
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise there is just one following character */
else|else
block|{
name|name
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
comment|/* Search for a recognized property name using binary chop */
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|PRIV
argument_list|(
name|utt_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|int
name|r
decl_stmt|;
name|i
operator|=
operator|(
name|bot
operator|+
name|top
operator|)
operator|>>
literal|1
expr_stmt|;
name|r
operator|=
name|STRCMP_UC_C8
argument_list|(
name|name
argument_list|,
name|PRIV
argument_list|(
name|utt_names
argument_list|)
operator|+
name|PRIV
argument_list|(
name|utt
argument_list|)
index|[
name|i
index|]
operator|.
name|name_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
operator|*
name|ptypeptr
operator|=
name|PRIV
argument_list|(
name|utt
argument_list|)
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
operator|*
name|pdataptr
operator|=
name|PRIV
argument_list|(
name|utt
argument_list|)
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|bot
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
name|top
operator|=
name|i
expr_stmt|;
block|}
operator|*
name|errorcodeptr
operator|=
name|ERR47
expr_stmt|;
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
return|return
name|FALSE
return|;
name|ERROR_RETURN
label|:
operator|*
name|errorcodeptr
operator|=
name|ERR46
expr_stmt|;
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/************************************************* *         Read repeat counts                     * *************************************************/
end_comment
begin_comment
comment|/* Read an item of the form {n,m} and return the values. This is called only after is_counted_repeat() has confirmed that a repeat-count quantifier exists, so the syntax is guaranteed to be correct, but we need to check the values.  Arguments:   p              pointer to first char after '{'   minp           pointer to int for min   maxp           pointer to int for max                  returned as -1 if no max   errorcodeptr   points to error code variable  Returns:         pointer to '}' on success;                  current ptr on error, with errorcodeptr set non-zero */
end_comment
begin_function
specifier|static
specifier|const
name|pcre_uchar
modifier|*
DECL|function|read_repeat_counts
name|read_repeat_counts
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|minp
parameter_list|,
name|int
modifier|*
name|maxp
parameter_list|,
name|int
modifier|*
name|errorcodeptr
parameter_list|)
block|{
name|int
name|min
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Read the minimum value and do a paranoid check: a negative value indicates an integer overflow. */
while|while
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|min
operator|=
name|min
operator|*
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|p
operator|++
operator|-
name|CHAR_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|<
literal|0
operator|||
name|min
operator|>
literal|65535
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR5
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Read the maximum value if there is one, and again do a paranoid on its size. Also, max must not be less than min. */
if|if
condition|(
operator|*
name|p
operator|==
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
name|max
operator|=
name|min
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|p
operator|)
operator|!=
name|CHAR_RIGHT_CURLY_BRACKET
condition|)
block|{
name|max
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|max
operator|=
name|max
operator|*
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|p
operator|++
operator|-
name|CHAR_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
operator|||
name|max
operator|>
literal|65535
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR5
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
name|max
operator|<
name|min
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR4
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
block|}
comment|/* Fill in the required variables, and pass back the pointer to the terminating '}'. */
operator|*
name|minp
operator|=
name|min
expr_stmt|;
operator|*
name|maxp
operator|=
name|max
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/************************************************* *  Subroutine for finding forward reference      * *************************************************/
end_comment
begin_comment
comment|/* This recursive function is called only from find_parens() below. The top-level call starts at the beginning of the pattern. All other calls must start at a parenthesis. It scans along a pattern's text looking for capturing subpatterns, and counting them. If it finds a named pattern that matches the name it is given, it returns its number. Alternatively, if the name is NULL, it returns when it reaches a given numbered subpattern. Recursion is used to keep track of subpatterns that reset the capturing group numbers - the (?| feature.  This function was originally called only from the second pass, in which we know that if (?< or (?' or (?P< is encountered, the name will be correctly terminated because that is checked in the first pass. There is now one call to this function in the first pass, to check for a recursive back reference by name (so that we can make the whole group atomic). In this case, we need check only up to the current position in the pattern, and that is still OK because and previous occurrences will have been checked. To make this work, the test for "end of pattern" is a check against cd->end_pattern in the main loop, instead of looking for a binary zero. This means that the special first-pass call can adjust cd->end_pattern temporarily. (Checks for binary zero while processing items within the loop are OK, because afterwards the main loop will terminate.)  Arguments:   ptrptr       address of the current character pointer (updated)   cd           compile background data   name         name to seek, or NULL if seeking a numbered subpattern   lorn         name length, or subpattern number if name is NULL   xmode        TRUE if we are in /x mode   utf          TRUE if we are in UTF-8 / UTF-16 / UTF-32 mode   count        pointer to the current capturing subpattern number (updated)  Returns:       the number of the named subpattern, or -1 if not found */
end_comment
begin_function
specifier|static
name|int
DECL|function|find_parens_sub
name|find_parens_sub
parameter_list|(
name|pcre_uchar
modifier|*
modifier|*
name|ptrptr
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|name
parameter_list|,
name|int
name|lorn
parameter_list|,
name|BOOL
name|xmode
parameter_list|,
name|BOOL
name|utf
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|ptr
init|=
operator|*
name|ptrptr
decl_stmt|;
name|int
name|start_count
init|=
operator|*
name|count
decl_stmt|;
name|int
name|hwm_count
init|=
name|start_count
decl_stmt|;
name|BOOL
name|dup_parens
init|=
name|FALSE
decl_stmt|;
comment|/* If the first character is a parenthesis, check on the type of group we are dealing with. The very first call may not start with a parenthesis. */
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
name|CHAR_LEFT_PARENTHESIS
condition|)
block|{
comment|/* Handle specials such as (*SKIP) or (*UTF8) etc. */
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_ASTERISK
condition|)
name|ptr
operator|+=
literal|2
expr_stmt|;
comment|/* Handle a normal, unnamed capturing parenthesis. */
elseif|else
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_QUESTION_MARK
condition|)
block|{
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
operator|*
name|count
operator|==
name|lorn
condition|)
return|return
operator|*
name|count
return|;
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* All cases now have (? at the start. Remember when we are in a group   where the parenthesis numbers are duplicated. */
elseif|else
if|if
condition|(
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_VERTICAL_LINE
condition|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
name|dup_parens
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Handle comments; all characters are allowed until a ket is reached. */
elseif|else
if|if
condition|(
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_NUMBER_SIGN
condition|)
block|{
for|for
control|(
name|ptr
operator|+=
literal|3
init|;
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_RIGHT_PARENTHESIS
condition|)
break|break;
goto|goto
name|FAIL_EXIT
goto|;
block|}
comment|/* Handle a condition. If it is an assertion, just carry on so that it   is processed as normal. If not, skip to the closing parenthesis of the   condition (there can't be any nested parens). */
elseif|else
if|if
condition|(
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_LEFT_PARENTHESIS
condition|)
block|{
name|ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_QUESTION_MARK
condition|)
block|{
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|ptr
operator|!=
name|CHAR_RIGHT_PARENTHESIS
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|)
name|ptr
operator|++
expr_stmt|;
block|}
block|}
comment|/* Start with (? but not a condition. */
else|else
block|{
name|ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_P
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* Allow optional P */
comment|/* We have to disambiguate (?<! and (?<= from (?<name> for named groups */
if|if
condition|(
operator|(
operator|*
name|ptr
operator|==
name|CHAR_LESS_THAN_SIGN
operator|&&
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_EXCLAMATION_MARK
operator|&&
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_EQUALS_SIGN
operator|)
operator|||
operator|*
name|ptr
operator|==
name|CHAR_APOSTROPHE
condition|)
block|{
name|pcre_uchar
name|term
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|thisname
decl_stmt|;
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
operator|*
name|count
operator|==
name|lorn
condition|)
return|return
operator|*
name|count
return|;
name|term
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|term
operator|==
name|CHAR_LESS_THAN_SIGN
condition|)
name|term
operator|=
name|CHAR_GREATER_THAN_SIGN
expr_stmt|;
name|thisname
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|term
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|lorn
operator|==
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|thisname
argument_list|)
operator|&&
name|STRNCMP_UC_UC
argument_list|(
name|name
argument_list|,
name|thisname
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|lorn
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|*
name|count
return|;
name|term
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Past any initial parenthesis handling, scan for parentheses or vertical bars. Stop if we get to cd->end_pattern. Note that this is important for the first-pass call when this value is temporarily adjusted to stop at the current position. So DO NOT change this to a test for binary zero. */
for|for
control|(
init|;
name|ptr
operator|<
name|cd
operator|->
name|end_pattern
condition|;
name|ptr
operator|++
control|)
block|{
comment|/* Skip over backslashed characters and also entire \Q...\E */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_BACKSLASH
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|FAIL_EXIT
goto|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_Q
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|ptr
operator|!=
name|CHAR_BACKSLASH
condition|)
block|{}
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|FAIL_EXIT
goto|;
if|if
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|==
name|CHAR_E
condition|)
break|break;
block|}
continue|continue;
block|}
comment|/* Skip over character classes; this logic must be similar to the way they   are handled for real. If the first character is '^', skip it. Also, if the   first few characters (either before or after ^) are \Q\E or \E we skip them   too. This makes for compatibility with Perl. Note the use of STR macros to   encode "Q\\E" so that it works in UTF-8 on EBCDIC platforms. */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_LEFT_SQUARE_BRACKET
condition|)
block|{
name|BOOL
name|negate_class
init|=
name|FALSE
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_BACKSLASH
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_E
condition|)
name|ptr
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
argument|ptr +
literal|2
argument_list|,
argument|STR_Q STR_BACKSLASH STR_E
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|ptr
operator|+=
literal|4
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|negate_class
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_CIRCUMFLEX_ACCENT
condition|)
block|{
name|negate_class
operator|=
name|TRUE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* If the next character is ']', it is a data character that must be     skipped, except in JavaScript compatibility mode. */
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_RIGHT_SQUARE_BRACKET
operator|&&
operator|(
name|cd
operator|->
name|external_options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|==
literal|0
condition|)
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|!=
name|CHAR_RIGHT_SQUARE_BRACKET
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_BACKSLASH
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|FAIL_EXIT
goto|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_Q
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|ptr
operator|!=
name|CHAR_BACKSLASH
condition|)
block|{}
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|FAIL_EXIT
goto|;
if|if
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|==
name|CHAR_E
condition|)
break|break;
block|}
continue|continue;
block|}
block|}
continue|continue;
block|}
comment|/* Skip comments in /x mode */
if|if
condition|(
name|xmode
operator|&&
operator|*
name|ptr
operator|==
name|CHAR_NUMBER_SIGN
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|)
block|{
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|cd
operator|->
name|nllen
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
name|FORWARDCHAR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|FAIL_EXIT
goto|;
continue|continue;
block|}
comment|/* Check for the special metacharacters */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_LEFT_PARENTHESIS
condition|)
block|{
name|int
name|rc
init|=
name|find_parens_sub
argument_list|(
operator|&
name|ptr
argument_list|,
name|cd
argument_list|,
name|name
argument_list|,
name|lorn
argument_list|,
name|xmode
argument_list|,
name|utf
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NULL
condition|)
goto|goto
name|FAIL_EXIT
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_RIGHT_PARENTHESIS
condition|)
block|{
if|if
condition|(
name|dup_parens
operator|&&
operator|*
name|count
operator|<
name|hwm_count
condition|)
operator|*
name|count
operator|=
name|hwm_count
expr_stmt|;
goto|goto
name|FAIL_EXIT
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_VERTICAL_LINE
operator|&&
name|dup_parens
condition|)
block|{
if|if
condition|(
operator|*
name|count
operator|>
name|hwm_count
condition|)
name|hwm_count
operator|=
operator|*
name|count
expr_stmt|;
operator|*
name|count
operator|=
name|start_count
expr_stmt|;
block|}
block|}
name|FAIL_EXIT
label|:
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/************************************************* *       Find forward referenced subpattern       * *************************************************/
end_comment
begin_comment
comment|/* This function scans along a pattern's text looking for capturing subpatterns, and counting them. If it finds a named pattern that matches the name it is given, it returns its number. Alternatively, if the name is NULL, it returns when it reaches a given numbered subpattern. This is used for forward references to subpatterns. We used to be able to start this scan from the current compiling point, using the current count value from cd->bracount, and do it all in a single loop, but the addition of the possibility of duplicate subpattern numbers means that we have to scan from the very start, in order to take account of such duplicates, and to use a recursive function to keep track of the different types of group.  Arguments:   cd           compile background data   name         name to seek, or NULL if seeking a numbered subpattern   lorn         name length, or subpattern number if name is NULL   xmode        TRUE if we are in /x mode   utf          TRUE if we are in UTF-8 / UTF-16 / UTF-32 mode  Returns:       the number of the found subpattern, or -1 if not found */
end_comment
begin_function
specifier|static
name|int
DECL|function|find_parens
name|find_parens
parameter_list|(
name|compile_data
modifier|*
name|cd
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|name
parameter_list|,
name|int
name|lorn
parameter_list|,
name|BOOL
name|xmode
parameter_list|,
name|BOOL
name|utf
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|ptr
init|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|cd
operator|->
name|start_pattern
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* If the pattern does not start with an opening parenthesis, the first call to find_parens_sub() will scan right to the end (if necessary). However, if it does start with a parenthesis, find_parens_sub() will return when it hits the matching closing parens. That is why we have to have a loop. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|rc
operator|=
name|find_parens_sub
argument_list|(
operator|&
name|ptr
argument_list|,
name|cd
argument_list|,
name|name
argument_list|,
name|lorn
argument_list|,
name|xmode
argument_list|,
name|utf
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
operator|||
operator|*
name|ptr
operator|++
operator|==
name|CHAR_NULL
condition|)
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function
begin_comment
comment|/************************************************* *      Find first significant op code            * *************************************************/
end_comment
begin_comment
comment|/* This is called by several functions that scan a compiled expression looking for a fixed first character, or an anchoring op code etc. It skips over things that do not influence this. For some calls, it makes sense to skip negative forward and all backward assertions, and also the \b assertion; for others it does not.  Arguments:   code         pointer to the start of the group   skipassert   TRUE if certain assertions are to be skipped  Returns:       pointer to the first significant opcode */
end_comment
begin_function
specifier|static
specifier|const
name|pcre_uchar
modifier|*
DECL|function|first_significant_code
name|first_significant_code
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|BOOL
name|skipassert
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
operator|*
name|code
condition|)
block|{
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
if|if
condition|(
operator|!
name|skipassert
condition|)
return|return
name|code
return|;
do|do
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|code
index|]
expr_stmt|;
break|break;
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
if|if
condition|(
operator|!
name|skipassert
condition|)
return|return
name|code
return|;
comment|/* Fall through */
case|case
name|OP_CALLOUT
case|:
case|case
name|OP_CREF
case|:
case|case
name|OP_NCREF
case|:
case|case
name|OP_RREF
case|:
case|case
name|OP_NRREF
case|:
case|case
name|OP_DEF
case|:
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|code
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|code
return|;
block|}
block|}
comment|/* Control never reaches here */
block|}
end_function
begin_comment
comment|/************************************************* *        Find the fixed length of a branch       * *************************************************/
end_comment
begin_comment
comment|/* Scan a branch and compute the fixed length of subject that will match it, if the length is fixed. This is needed for dealing with backward assertions. In UTF8 mode, the result is in characters rather than bytes. The branch is temporarily terminated with OP_END when this function is called.  This function is called when a backward assertion is encountered, so that if it fails, the error message can point to the correct place in the pattern. However, we cannot do this when the assertion contains subroutine calls, because they can be forward references. We solve this by remembering this case and doing the check at the end; a flag specifies which mode we are running in.  Arguments:   code     points to the start of the pattern (the bracket)   utf      TRUE in UTF-8 / UTF-16 / UTF-32 mode   atend    TRUE if called when the pattern is complete   cd       the "compile data" structure  Returns:   the fixed length,              or -1 if there is no fixed length,              or -2 if \C was encountered (in UTF-8 mode only)              or -3 if an OP_RECURSE item was encountered and atend is FALSE              or -4 if an unknown opcode was encountered (internal error) */
end_comment
begin_function
specifier|static
name|int
DECL|function|find_fixedlength
name|find_fixedlength
parameter_list|(
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|BOOL
name|utf
parameter_list|,
name|BOOL
name|atend
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
name|int
name|length
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|branchlength
init|=
literal|0
decl_stmt|;
specifier|register
name|pcre_uchar
modifier|*
name|cc
init|=
name|code
operator|+
literal|1
operator|+
name|LINK_SIZE
decl_stmt|;
comment|/* Scan along the opcodes for this branch. If we get to the end of the branch, check the length against that of the other branches. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|d
decl_stmt|;
name|pcre_uchar
modifier|*
name|ce
decl_stmt|,
modifier|*
name|cs
decl_stmt|;
specifier|register
name|pcre_uchar
name|op
init|=
operator|*
name|cc
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* We only need to continue for OP_CBRA (normal capturing bracket) and     OP_BRA (normal non-capturing bracket) because the other variants of these     opcodes are all concerned with unlimited repeated groups, which of course     are not of fixed length. */
case|case
name|OP_CBRA
case|:
case|case
name|OP_BRA
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_COND
case|:
name|d
operator|=
name|find_fixedlength
argument_list|(
name|cc
operator|+
operator|(
operator|(
name|op
operator|==
name|OP_CBRA
operator|)
condition|?
name|IMM2_SIZE
else|:
literal|0
operator|)
argument_list|,
name|utf
argument_list|,
name|atend
argument_list|,
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
return|return
name|d
return|;
name|branchlength
operator|+=
name|d
expr_stmt|;
do|do
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* Reached end of a branch; if it's a ket it is the end of a nested call.     If it's ALT it is an alternation in a nested call. An ACCEPT is effectively     an ALT. If it is END it's the end of the outer call. All can be handled by     the same code. Note that we must not include the OP_KETRxxx opcodes here,     because they all imply an unlimited repeat. */
case|case
name|OP_ALT
case|:
case|case
name|OP_KET
case|:
case|case
name|OP_END
case|:
case|case
name|OP_ACCEPT
case|:
case|case
name|OP_ASSERT_ACCEPT
case|:
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|length
operator|=
name|branchlength
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|!=
name|branchlength
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|cc
operator|!=
name|OP_ALT
condition|)
return|return
name|length
return|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|branchlength
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* A true recursion implies not fixed length, but a subroutine call may     be OK. If the subroutine is a forward reference, we can't deal with     it until the end of the pattern, so return -3. */
case|case
name|OP_RECURSE
case|:
if|if
condition|(
operator|!
name|atend
condition|)
return|return
operator|-
literal|3
return|;
name|cs
operator|=
name|ce
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|cd
operator|->
name|start_code
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Start subpattern */
do|do
name|ce
operator|+=
name|GET
argument_list|(
name|ce
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|ce
operator|==
name|OP_ALT
condition|)
do|;
comment|/* End subpattern */
if|if
condition|(
name|cc
operator|>
name|cs
operator|&&
name|cc
operator|<
name|ce
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Recursion */
name|d
operator|=
name|find_fixedlength
argument_list|(
name|cs
operator|+
name|IMM2_SIZE
argument_list|,
name|utf
argument_list|,
name|atend
argument_list|,
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
return|return
name|d
return|;
name|branchlength
operator|+=
name|d
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
comment|/* Skip over assertive subpatterns */
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
do|do
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cc
operator|==
name|OP_ALT
condition|)
do|;
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|cc
index|]
expr_stmt|;
break|break;
comment|/* Skip over things that don't match chars */
case|case
name|OP_MARK
case|:
case|case
name|OP_PRUNE_ARG
case|:
case|case
name|OP_SKIP_ARG
case|:
case|case
name|OP_THEN_ARG
case|:
name|cc
operator|+=
name|cc
index|[
literal|1
index|]
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|cc
index|]
expr_stmt|;
break|break;
case|case
name|OP_CALLOUT
case|:
case|case
name|OP_CIRC
case|:
case|case
name|OP_CIRCM
case|:
case|case
name|OP_CLOSE
case|:
case|case
name|OP_COMMIT
case|:
case|case
name|OP_CREF
case|:
case|case
name|OP_DEF
case|:
case|case
name|OP_DOLL
case|:
case|case
name|OP_DOLLM
case|:
case|case
name|OP_EOD
case|:
case|case
name|OP_EODN
case|:
case|case
name|OP_FAIL
case|:
case|case
name|OP_NCREF
case|:
case|case
name|OP_NRREF
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
case|case
name|OP_PRUNE
case|:
case|case
name|OP_REVERSE
case|:
case|case
name|OP_RREF
case|:
case|case
name|OP_SET_SOM
case|:
case|case
name|OP_SKIP
case|:
case|case
name|OP_SOD
case|:
case|case
name|OP_SOM
case|:
case|case
name|OP_THEN
case|:
case|case
name|OP_WORD_BOUNDARY
case|:
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|cc
index|]
expr_stmt|;
break|break;
comment|/* Handle literal characters */
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
name|branchlength
operator|++
expr_stmt|;
name|cc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Handle exact repetitions. The count is already in characters, but we     need to skip over a multibyte character in UTF8 mode.  */
case|case
name|OP_EXACT
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTEXACTI
case|:
name|branchlength
operator|+=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|2
operator|+
name|IMM2_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cc
operator|+=
name|GET_EXTRALEN
argument_list|(
name|cc
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OP_TYPEEXACT
case|:
name|branchlength
operator|+=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_PROP
operator|||
name|cc
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_NOTPROP
condition|)
name|cc
operator|+=
literal|2
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
break|break;
comment|/* Handle single-char matchers */
case|case
name|OP_PROP
case|:
case|case
name|OP_NOTPROP
case|:
name|cc
operator|+=
literal|2
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_HSPACE
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
name|branchlength
operator|++
expr_stmt|;
name|cc
operator|++
expr_stmt|;
break|break;
comment|/* The single-byte matcher isn't allowed. This only happens in UTF-8 mode;     otherwise \C is coded as OP_ALLANY. */
case|case
name|OP_ANYBYTE
case|:
return|return
operator|-
literal|2
return|;
comment|/* Check a class for variable quantification */
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
case|case
name|OP_XCLASS
case|:
comment|/* The original code caused an unsigned overflow in 64 bit systems,     so now we use a conditional statement. */
if|if
condition|(
name|op
operator|==
name|OP_XCLASS
condition|)
name|cc
operator|+=
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CLASS
index|]
expr_stmt|;
else|#
directive|else
name|cc
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CLASS
index|]
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|cc
condition|)
block|{
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
return|return
operator|-
literal|1
return|;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
if|if
condition|(
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|!=
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|branchlength
operator|+=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
expr_stmt|;
break|break;
default|default:
name|branchlength
operator|++
expr_stmt|;
block|}
break|break;
comment|/* Anything else is variable length */
case|case
name|OP_ANYNL
case|:
case|case
name|OP_BRAMINZERO
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_BRAPOSZERO
case|:
case|case
name|OP_BRAZERO
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRPOS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_REF
case|:
case|case
name|OP_REFI
case|:
case|case
name|OP_SBRA
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_SCOND
case|:
case|case
name|OP_SKIPZERO
case|:
case|case
name|OP_STAR
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_UPTOI
case|:
return|return
operator|-
literal|1
return|;
comment|/* Catch unrecognized opcodes so that when new ones are added they     are not forgotten, as has happened in the past. */
default|default:
return|return
operator|-
literal|4
return|;
block|}
block|}
comment|/* Control never gets here */
block|}
end_function
begin_comment
comment|/************************************************* *    Scan compiled regex for specific bracket    * *************************************************/
end_comment
begin_comment
comment|/* This little function scans through a compiled pattern until it finds a capturing bracket with the given number, or, if the number is negative, an instance of OP_REVERSE for a lookbehind. The function is global in the C sense so that it can be called from pcre_study() when finding the minimum matching length.  Arguments:   code        points to start of expression   utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode   number      the required bracket number or negative to find a lookbehind  Returns:      pointer to the opcode for the bracket, or NULL if not found */
end_comment
begin_function
specifier|const
name|pcre_uchar
modifier|*
DECL|function|find_bracket
name|PRIV
function|(
name|find_bracket
function|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|BOOL
name|utf
parameter_list|,
name|int
name|number
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|pcre_uchar
name|c
init|=
operator|*
name|code
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|OP_END
condition|)
return|return
name|NULL
return|;
comment|/* XCLASS is used for classes that cannot be represented just by a bit   map. This includes negated single high-valued characters. The length in   the table is zero; the actual length is stored in the compiled code. */
if|if
condition|(
name|c
operator|==
name|OP_XCLASS
condition|)
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Handle recursion */
elseif|else
if|if
condition|(
name|c
operator|==
name|OP_REVERSE
condition|)
block|{
if|if
condition|(
name|number
operator|<
literal|0
condition|)
return|return
operator|(
name|pcre_uchar
operator|*
operator|)
name|code
return|;
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|c
index|]
expr_stmt|;
block|}
comment|/* Handle capturing bracket */
elseif|else
if|if
condition|(
name|c
operator|==
name|OP_CBRA
operator|||
name|c
operator|==
name|OP_SCBRA
operator|||
name|c
operator|==
name|OP_CBRAPOS
operator|||
name|c
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|int
name|n
init|=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|number
condition|)
return|return
operator|(
name|pcre_uchar
operator|*
operator|)
name|code
return|;
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|c
index|]
expr_stmt|;
block|}
comment|/* Otherwise, we can get the item's length from the table, except that for   repeated character types, we have to test for \p and \P, which have an extra   two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we   must add in its length. */
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
if|if
condition|(
name|code
index|[
literal|1
index|]
operator|==
name|OP_PROP
operator|||
name|code
index|[
literal|1
index|]
operator|==
name|OP_NOTPROP
condition|)
name|code
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_PROP
operator|||
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_NOTPROP
condition|)
name|code
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
case|case
name|OP_PRUNE_ARG
case|:
case|case
name|OP_SKIP_ARG
case|:
name|code
operator|+=
name|code
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|OP_THEN_ARG
case|:
name|code
operator|+=
name|code
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
comment|/* Add in the fixed length from the table */
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|c
index|]
expr_stmt|;
comment|/* In UTF-8 mode, opcodes that are followed by a character may be followed by   a multi-byte character. The length in the table is a minimum, so we have to   arrange to skip the extra bytes. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_STAR
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSQUERYI
case|:
if|if
condition|(
name|HAS_EXTRALEN
argument_list|(
name|code
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|code
operator|+=
name|GET_EXTRALEN
argument_list|(
name|code
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
call|(
name|void
call|)
argument_list|(
name|utf
argument_list|)
expr_stmt|;
comment|/* Keep compiler happy by referencing function argument */
endif|#
directive|endif
block|}
block|}
block|}
end_function
begin_comment
comment|/************************************************* *   Scan compiled regex for recursion reference  * *************************************************/
end_comment
begin_comment
comment|/* This little function scans through a compiled pattern until it finds an instance of OP_RECURSE.  Arguments:   code        points to start of expression   utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode  Returns:      pointer to the opcode for OP_RECURSE, or NULL if not found */
end_comment
begin_function
specifier|static
specifier|const
name|pcre_uchar
modifier|*
DECL|function|find_recurse
name|find_recurse
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|BOOL
name|utf
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|pcre_uchar
name|c
init|=
operator|*
name|code
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|OP_END
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|c
operator|==
name|OP_RECURSE
condition|)
return|return
name|code
return|;
comment|/* XCLASS is used for classes that cannot be represented just by a bit   map. This includes negated single high-valued characters. The length in   the table is zero; the actual length is stored in the compiled code. */
if|if
condition|(
name|c
operator|==
name|OP_XCLASS
condition|)
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Otherwise, we can get the item's length from the table, except that for   repeated character types, we have to test for \p and \P, which have an extra   two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we   must add in its length. */
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
if|if
condition|(
name|code
index|[
literal|1
index|]
operator|==
name|OP_PROP
operator|||
name|code
index|[
literal|1
index|]
operator|==
name|OP_NOTPROP
condition|)
name|code
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_TYPEPOSUPTO
case|:
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEEXACT
case|:
if|if
condition|(
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_PROP
operator|||
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_NOTPROP
condition|)
name|code
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
case|case
name|OP_PRUNE_ARG
case|:
case|case
name|OP_SKIP_ARG
case|:
name|code
operator|+=
name|code
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|OP_THEN_ARG
case|:
name|code
operator|+=
name|code
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
comment|/* Add in the fixed length from the table */
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|c
index|]
expr_stmt|;
comment|/* In UTF-8 mode, opcodes that are followed by a character may be followed     by a multi-byte character. The length in the table is a minimum, so we have     to arrange to skip the extra bytes. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_EXACTI
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_NOTEXACTI
case|:
case|case
name|OP_UPTO
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTPOSUPTO
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
case|case
name|OP_STAR
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_NOTPOSSTAR
case|:
case|case
name|OP_NOTPOSSTARI
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_NOTPOSQUERY
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
if|if
condition|(
name|HAS_EXTRALEN
argument_list|(
name|code
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|code
operator|+=
name|GET_EXTRALEN
argument_list|(
name|code
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
call|(
name|void
call|)
argument_list|(
name|utf
argument_list|)
expr_stmt|;
comment|/* Keep compiler happy by referencing function argument */
endif|#
directive|endif
block|}
block|}
block|}
end_function
begin_comment
comment|/************************************************* *    Scan compiled branch for non-emptiness      * *************************************************/
end_comment
begin_comment
comment|/* This function scans through a branch of a compiled pattern to see whether it can match the empty string or not. It is called from could_be_empty() below and from compile_branch() when checking for an unlimited repeat of a group that can match nothing. Note that first_significant_code() skips over backward and negative forward assertions when its final argument is TRUE. If we hit an unclosed bracket, we return "empty" - this means we've struck an inner bracket whose current branch will already have been scanned.  Arguments:   code        points to start of search   endcode     points to where to stop   utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode   cd          contains pointers to tables etc.  Returns:      TRUE if what is matched could be empty */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|could_be_empty_branch
name|could_be_empty_branch
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|endcode
parameter_list|,
name|BOOL
name|utf
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
specifier|register
name|pcre_uchar
name|c
decl_stmt|;
for|for
control|(
name|code
operator|=
name|first_significant_code
argument_list|(
name|code
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|code
index|]
argument_list|,
name|TRUE
argument_list|)
init|;
name|code
operator|<
name|endcode
condition|;
name|code
operator|=
name|first_significant_code
argument_list|(
name|code
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|c
index|]
argument_list|,
name|TRUE
argument_list|)
control|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|ccode
decl_stmt|;
name|c
operator|=
operator|*
name|code
expr_stmt|;
comment|/* Skip over forward assertions; the other assertions are skipped by   first_significant_code() with a TRUE final argument. */
if|if
condition|(
name|c
operator|==
name|OP_ASSERT
condition|)
block|{
do|do
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
name|c
operator|=
operator|*
name|code
expr_stmt|;
continue|continue;
block|}
comment|/* For a recursion/subroutine call, if its end has been reached, which   implies a backward reference subroutine call, we can scan it. If it's a   forward reference subroutine call, we can't. To detect forward reference   we have to scan up the list that is kept in the workspace. This function is   called only when doing the real compile, not during the pre-compile that   measures the size of the compiled pattern. */
if|if
condition|(
name|c
operator|==
name|OP_RECURSE
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|scode
decl_stmt|;
name|BOOL
name|empty_branch
decl_stmt|;
comment|/* Test for forward reference */
for|for
control|(
name|scode
operator|=
name|cd
operator|->
name|start_workspace
init|;
name|scode
operator|<
name|cd
operator|->
name|hwm
condition|;
name|scode
operator|+=
name|LINK_SIZE
control|)
if|if
condition|(
operator|(
name|int
operator|)
name|GET
argument_list|(
name|scode
argument_list|,
literal|0
argument_list|)
operator|==
call|(
name|int
call|)
argument_list|(
name|code
operator|+
literal|1
operator|-
name|cd
operator|->
name|start_code
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Not a forward reference, test for completed backward reference */
name|empty_branch
operator|=
name|FALSE
expr_stmt|;
name|scode
operator|=
name|cd
operator|->
name|start_code
operator|+
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET
argument_list|(
name|scode
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Unclosed */
comment|/* Completed backwards reference */
do|do
block|{
if|if
condition|(
name|could_be_empty_branch
argument_list|(
name|scode
argument_list|,
name|endcode
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|)
condition|)
block|{
name|empty_branch
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|scode
operator|+=
name|GET
argument_list|(
name|scode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|scode
operator|==
name|OP_ALT
condition|)
do|;
if|if
condition|(
operator|!
name|empty_branch
condition|)
return|return
name|FALSE
return|;
comment|/* All branches are non-empty */
continue|continue;
block|}
comment|/* Groups with zero repeats can of course be empty; skip them. */
if|if
condition|(
name|c
operator|==
name|OP_BRAZERO
operator|||
name|c
operator|==
name|OP_BRAMINZERO
operator|||
name|c
operator|==
name|OP_SKIPZERO
operator|||
name|c
operator|==
name|OP_BRAPOSZERO
condition|)
block|{
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|c
index|]
expr_stmt|;
do|do
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
name|c
operator|=
operator|*
name|code
expr_stmt|;
continue|continue;
block|}
comment|/* A nested group that is already marked as "could be empty" can just be   skipped. */
if|if
condition|(
name|c
operator|==
name|OP_SBRA
operator|||
name|c
operator|==
name|OP_SBRAPOS
operator|||
name|c
operator|==
name|OP_SCBRA
operator|||
name|c
operator|==
name|OP_SCBRAPOS
condition|)
block|{
do|do
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
name|c
operator|=
operator|*
name|code
expr_stmt|;
continue|continue;
block|}
comment|/* For other groups, scan the branches. */
if|if
condition|(
name|c
operator|==
name|OP_BRA
operator|||
name|c
operator|==
name|OP_BRAPOS
operator|||
name|c
operator|==
name|OP_CBRA
operator|||
name|c
operator|==
name|OP_CBRAPOS
operator|||
name|c
operator|==
name|OP_ONCE
operator|||
name|c
operator|==
name|OP_ONCE_NC
operator|||
name|c
operator|==
name|OP_COND
condition|)
block|{
name|BOOL
name|empty_branch
decl_stmt|;
if|if
condition|(
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Hit unclosed bracket */
comment|/* If a conditional group has only one branch, there is a second, implied,     empty branch, so just skip over the conditional, because it could be empty.     Otherwise, scan the individual branches of the group. */
if|if
condition|(
name|c
operator|==
name|OP_COND
operator|&&
name|code
index|[
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
index|]
operator|!=
name|OP_ALT
condition|)
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|empty_branch
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|empty_branch
operator|&&
name|could_be_empty_branch
argument_list|(
name|code
argument_list|,
name|endcode
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|)
condition|)
name|empty_branch
operator|=
name|TRUE
expr_stmt|;
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
if|if
condition|(
operator|!
name|empty_branch
condition|)
return|return
name|FALSE
return|;
comment|/* All branches are non-empty */
block|}
name|c
operator|=
operator|*
name|code
expr_stmt|;
continue|continue;
block|}
comment|/* Handle the other opcodes */
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Check for quantifiers after a class. XCLASS is used for classes that     cannot be represented just by a bit map. This includes negated single     high-valued characters. The length in PRIV(OP_lengths)[] is zero; the     actual length is stored in the compiled code, so we must update "code"     here. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
case|case
name|OP_XCLASS
case|:
name|ccode
operator|=
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|CHECK_CLASS_REPEAT
goto|;
endif|#
directive|endif
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
name|ccode
operator|=
name|code
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CLASS
index|]
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
name|CHECK_CLASS_REPEAT
label|:
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|ccode
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
comment|/* These could be empty; continue */
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
break|break;
default|default:
comment|/* Non-repeat => class must match */
case|case
name|OP_CRPLUS
case|:
comment|/* These repeats aren't empty */
case|case
name|OP_CRMINPLUS
case|:
return|return
name|FALSE
return|;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
if|if
condition|(
name|GET2
argument_list|(
name|ccode
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Minimum> 0 */
break|break;
block|}
break|break;
comment|/* Opcodes that must match a character */
case|case
name|OP_PROP
case|:
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_EXTUNI
case|:
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
case|case
name|OP_WORDCHAR
case|:
case|case
name|OP_ANY
case|:
case|case
name|OP_ALLANY
case|:
case|case
name|OP_ANYBYTE
case|:
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
case|case
name|OP_NOT
case|:
case|case
name|OP_NOTI
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_EXACT
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTPOSPLUS
case|:
case|case
name|OP_NOTEXACT
case|:
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
case|case
name|OP_TYPEEXACT
case|:
return|return
name|FALSE
return|;
comment|/* These are going to continue, as they may be empty, but we have to     fudge the length for the \p and \P cases. */
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
if|if
condition|(
name|code
index|[
literal|1
index|]
operator|==
name|OP_PROP
operator|||
name|code
index|[
literal|1
index|]
operator|==
name|OP_NOTPROP
condition|)
name|code
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* Same for these */
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_PROP
operator|||
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_NOTPROP
condition|)
name|code
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* End of branch */
case|case
name|OP_KET
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRPOS
case|:
case|case
name|OP_ALT
case|:
return|return
name|TRUE
return|;
comment|/* In UTF-8 mode, STAR, MINSTAR, POSSTAR, QUERY, MINQUERY, POSQUERY, UPTO,     MINUPTO, and POSUPTO may be followed by a multibyte character */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
case|case
name|OP_STAR
case|:
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_QUERY
case|:
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_POSQUERYI
case|:
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|code
index|[
literal|1
index|]
argument_list|)
condition|)
name|code
operator|+=
name|GET_EXTRALEN
argument_list|(
name|code
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_UPTO
case|:
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_POSUPTOI
case|:
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
argument_list|)
condition|)
name|code
operator|+=
name|GET_EXTRALEN
argument_list|(
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MARK, and PRUNE/SKIP/THEN with an argument must skip over the argument     string. */
case|case
name|OP_MARK
case|:
case|case
name|OP_PRUNE_ARG
case|:
case|case
name|OP_SKIP_ARG
case|:
name|code
operator|+=
name|code
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|OP_THEN_ARG
case|:
name|code
operator|+=
name|code
index|[
literal|1
index|]
expr_stmt|;
break|break;
comment|/* None of the remaining opcodes are required to match a character. */
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function
begin_comment
comment|/************************************************* *    Scan compiled regex for non-emptiness       * *************************************************/
end_comment
begin_comment
comment|/* This function is called to check for left recursive calls. We want to check the current branch of the current pattern to see if it could match the empty string. If it could, we must look outwards for branches at other levels, stopping when we pass beyond the bracket which is the subject of the recursion. This function is called only during the real compile, not during the pre-compile.  Arguments:   code        points to start of the recursion   endcode     points to where to stop (current RECURSE item)   bcptr       points to the chain of current (unclosed) branch starts   utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode   cd          pointers to tables etc  Returns:      TRUE if what is matched could be empty */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|could_be_empty
name|could_be_empty
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|endcode
parameter_list|,
name|branch_chain
modifier|*
name|bcptr
parameter_list|,
name|BOOL
name|utf
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
while|while
condition|(
name|bcptr
operator|!=
name|NULL
operator|&&
name|bcptr
operator|->
name|current_branch
operator|>=
name|code
condition|)
block|{
if|if
condition|(
operator|!
name|could_be_empty_branch
argument_list|(
name|bcptr
operator|->
name|current_branch
argument_list|,
name|endcode
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bcptr
operator|=
name|bcptr
operator|->
name|outer
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function
begin_comment
comment|/************************************************* *           Check for POSIX class syntax         * *************************************************/
end_comment
begin_comment
comment|/* This function is called when the sequence "[:" or "[." or "[=" is encountered in a character class. It checks whether this is followed by a sequence of characters terminated by a matching ":]" or ".]" or "=]". If we reach an unescaped ']' without the special preceding character, return FALSE.  Originally, this function only recognized a sequence of letters between the terminators, but it seems that Perl recognizes any sequence of characters, though of course unknown POSIX names are subsequently rejected. Perl gives an "Unknown POSIX class" error for [:f\oo:] for example, where previously PCRE didn't consider this to be a POSIX class. Likewise for [:1234:].  The problem in trying to be exactly like Perl is in the handling of escapes. We have to be sure that [abc[:x\]pqr] is *not* treated as containing a POSIX class, but [abc[:x\]pqr:]] is (so that an error can be generated). The code below handles the special case of \], but does not try to do any other escape processing. This makes it different from Perl for cases such as [:l\ower:] where Perl recognizes it as the POSIX class "lower" but PCRE does not recognize "l\ower". This is a lesser evil that not diagnosing bad classes when Perl does, I think.  A user pointed out that PCRE was rejecting [:a[:digit:]] whereas Perl was not. It seems that the appearance of a nested POSIX class supersedes an apparent external class. For example, [:a[:digit:]b:] matches "a", "b", ":", or a digit.  In Perl, unescaped square brackets may also appear as part of class names. For example, [:a[:abc]b:] gives unknown POSIX class "[:abc]b:]". However, for [:a[:abc]b][b:] it gives unknown POSIX class "[:abc]b][b:]", which does not seem right at all. PCRE does not allow closing square brackets in POSIX class names.  Arguments:   ptr      pointer to the initial [   endptr   where to return the end pointer  Returns:   TRUE or FALSE */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|check_posix_syntax
name|check_posix_syntax
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|ptr
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
modifier|*
name|endptr
parameter_list|)
block|{
name|pcre_uchar
name|terminator
decl_stmt|;
comment|/* Don't combine these lines; the Solaris cc */
name|terminator
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
comment|/* compiler warns about "non-constant" initializer. */
for|for
control|(
operator|++
name|ptr
init|;
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_RIGHT_SQUARE_BRACKET
condition|)
name|ptr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_RIGHT_SQUARE_BRACKET
condition|)
return|return
name|FALSE
return|;
else|else
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|terminator
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_RIGHT_SQUARE_BRACKET
condition|)
block|{
operator|*
name|endptr
operator|=
name|ptr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_LEFT_SQUARE_BRACKET
operator|&&
operator|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_COLON
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_DOT
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_EQUALS_SIGN
operator|)
operator|&&
name|check_posix_syntax
argument_list|(
name|ptr
argument_list|,
name|endptr
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function
begin_comment
comment|/************************************************* *          Check POSIX class name                * *************************************************/
end_comment
begin_comment
comment|/* This function is called to check the name given in a POSIX-style class entry such as [:alnum:].  Arguments:   ptr        points to the first letter   len        the length of the name  Returns:     a value representing the name, or -1 if unknown */
end_comment
begin_function
specifier|static
name|int
DECL|function|check_posix_name
name|check_posix_name
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pn
init|=
name|posix_names
decl_stmt|;
specifier|register
name|int
name|yield
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|posix_name_lengths
index|[
name|yield
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|==
name|posix_name_lengths
index|[
name|yield
index|]
operator|&&
name|STRNCMP_UC_C8
argument_list|(
name|ptr
argument_list|,
name|pn
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|yield
return|;
name|pn
operator|+=
name|posix_name_lengths
index|[
name|yield
index|]
operator|+
literal|1
expr_stmt|;
name|yield
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/************************************************* *    Adjust OP_RECURSE items in repeated group   * *************************************************/
end_comment
begin_comment
comment|/* OP_RECURSE items contain an offset from the start of the regex to the group that is referenced. This means that groups can be replicated for fixed repetition simply by copying (because the recursion is allowed to refer to earlier groups that are outside the current group). However, when a group is optional (i.e. the minimum quantifier is zero), OP_BRAZERO or OP_SKIPZERO is inserted before it, after it has been compiled. This means that any OP_RECURSE items within it that refer to the group itself or any contained groups have to have their offsets adjusted. That one of the jobs of this function. Before it is called, the partially compiled regex must be temporarily terminated with OP_END.  This function has been extended with the possibility of forward references for recursions and subroutine calls. It must also check the list of such references for the group we are dealing with. If it finds that one of the recursions in the current group is on this list, it adjusts the offset in the list, not the value in the reference (which is a group number).  Arguments:   group      points to the start of the group   adjust     the amount by which the group is to be moved   utf        TRUE in UTF-8 / UTF-16 / UTF-32 mode   cd         contains pointers to tables etc.   save_hwm   the hwm forward reference pointer at the start of the group  Returns:     nothing */
end_comment
begin_function
specifier|static
name|void
DECL|function|adjust_recurse
name|adjust_recurse
parameter_list|(
name|pcre_uchar
modifier|*
name|group
parameter_list|,
name|int
name|adjust
parameter_list|,
name|BOOL
name|utf
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
name|pcre_uchar
modifier|*
name|save_hwm
parameter_list|)
block|{
name|pcre_uchar
modifier|*
name|ptr
init|=
name|group
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|find_recurse
argument_list|(
name|ptr
argument_list|,
name|utf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|pcre_uchar
modifier|*
name|hc
decl_stmt|;
comment|/* See if this recursion is on the forward reference list. If so, adjust the   reference. */
for|for
control|(
name|hc
operator|=
name|save_hwm
init|;
name|hc
operator|<
name|cd
operator|->
name|hwm
condition|;
name|hc
operator|+=
name|LINK_SIZE
control|)
block|{
name|offset
operator|=
operator|(
name|int
operator|)
name|GET
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|start_code
operator|+
name|offset
operator|==
name|ptr
operator|+
literal|1
condition|)
block|{
name|PUT
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|,
name|offset
operator|+
name|adjust
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Otherwise, adjust the recursion offset if it's after the start of this   group. */
if|if
condition|(
name|hc
operator|>=
name|cd
operator|->
name|hwm
condition|)
block|{
name|offset
operator|=
operator|(
name|int
operator|)
name|GET
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|start_code
operator|+
name|offset
operator|>=
name|group
condition|)
name|PUT
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
name|offset
operator|+
name|adjust
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/************************************************* *        Insert an automatic callout point       * *************************************************/
end_comment
begin_comment
comment|/* This function is called when the PCRE_AUTO_CALLOUT option is set, to insert callout points before each pattern item.  Arguments:   code           current code pointer   ptr            current pattern pointer   cd             pointers to tables etc  Returns:         new code pointer */
end_comment
begin_function
specifier|static
name|pcre_uchar
modifier|*
DECL|function|auto_callout
name|auto_callout
parameter_list|(
name|pcre_uchar
modifier|*
name|code
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|ptr
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
operator|*
name|code
operator|++
operator|=
name|OP_CALLOUT
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|255
expr_stmt|;
name|PUT
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|cd
operator|->
name|start_pattern
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pattern offset */
name|PUT
argument_list|(
name|code
argument_list|,
name|LINK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Default length */
return|return
name|code
operator|+
literal|2
operator|*
name|LINK_SIZE
return|;
block|}
end_function
begin_comment
comment|/************************************************* *         Complete a callout item                * *************************************************/
end_comment
begin_comment
comment|/* A callout item contains the length of the next item in the pattern, which we can't fill in till after we have reached the relevant point. This is used for both automatic and manual callouts.  Arguments:   previous_callout   points to previous callout item   ptr                current pattern pointer   cd                 pointers to tables etc  Returns:             nothing */
end_comment
begin_function
specifier|static
name|void
DECL|function|complete_callout
name|complete_callout
parameter_list|(
name|pcre_uchar
modifier|*
name|previous_callout
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|ptr
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
name|int
name|length
init|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|cd
operator|->
name|start_pattern
operator|-
name|GET
argument_list|(
name|previous_callout
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|PUT
argument_list|(
name|previous_callout
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UCP
end_ifdef
begin_comment
comment|/************************************************* *           Get othercase range                  * *************************************************/
end_comment
begin_comment
comment|/* This function is passed the start and end of a class range, in UTF-8 mode with UCP support. It searches up the characters, looking for ranges of characters in the "other" case. Each call returns the next one, updating the start address. A character with multiple other cases is returned on its own with a special return value.  Arguments:   cptr        points to starting character value; updated   d           end value   ocptr       where to put start of othercase range   odptr       where to put end of othercase range  Yield:        -1 when no more                0 when a range is returned>0 the CASESET offset for char with multiple other cases                 in this case, ocptr contains the original */
end_comment
begin_function
specifier|static
name|int
DECL|function|get_othercase_range
name|get_othercase_range
parameter_list|(
name|pcre_uint32
modifier|*
name|cptr
parameter_list|,
name|pcre_uint32
name|d
parameter_list|,
name|pcre_uint32
modifier|*
name|ocptr
parameter_list|,
name|pcre_uint32
modifier|*
name|odptr
parameter_list|)
block|{
name|pcre_uint32
name|c
decl_stmt|,
name|othercase
decl_stmt|,
name|next
decl_stmt|;
name|unsigned
name|int
name|co
decl_stmt|;
comment|/* Find the first character that has an other case. If it has multiple other cases, return its case offset value. */
for|for
control|(
name|c
operator|=
operator|*
name|cptr
init|;
name|c
operator|<=
name|d
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|co
operator|=
name|UCD_CASESET
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|ocptr
operator|=
name|c
operator|++
expr_stmt|;
comment|/* Character that has the set */
operator|*
name|cptr
operator|=
name|c
expr_stmt|;
comment|/* Rest of input range */
return|return
operator|(
name|int
operator|)
name|co
return|;
block|}
if|if
condition|(
operator|(
name|othercase
operator|=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
name|c
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|>
name|d
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Reached end of range */
operator|*
name|ocptr
operator|=
name|othercase
expr_stmt|;
name|next
operator|=
name|othercase
operator|+
literal|1
expr_stmt|;
for|for
control|(
operator|++
name|c
init|;
name|c
operator|<=
name|d
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
operator|!=
name|next
condition|)
break|break;
name|next
operator|++
expr_stmt|;
block|}
operator|*
name|odptr
operator|=
name|next
operator|-
literal|1
expr_stmt|;
comment|/* End of othercase range */
operator|*
name|cptr
operator|=
name|c
expr_stmt|;
comment|/* Rest of input range */
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/************************************************* *        Check a character and a property        * *************************************************/
end_comment
begin_comment
comment|/* This function is called by check_auto_possessive() when a property item is adjacent to a fixed character.  Arguments:   c            the character   ptype        the property type   pdata        the data for the type   negated      TRUE if it's a negated property (\P or \p{^)  Returns:       TRUE if auto-possessifying is OK */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|check_char_prop
name|check_char_prop
parameter_list|(
name|pcre_uint32
name|c
parameter_list|,
name|unsigned
name|int
name|ptype
parameter_list|,
name|unsigned
name|int
name|pdata
parameter_list|,
name|BOOL
name|negated
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
specifier|const
name|pcre_uint32
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PT_LAMP
case|:
return|return
operator|(
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
operator|)
operator|==
name|negated
return|;
case|case
name|PT_GC
case|:
return|return
operator|(
name|pdata
operator|==
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|)
operator|==
name|negated
return|;
case|case
name|PT_PC
case|:
return|return
operator|(
name|pdata
operator|==
name|prop
operator|->
name|chartype
operator|)
operator|==
name|negated
return|;
case|case
name|PT_SC
case|:
return|return
operator|(
name|pdata
operator|==
name|prop
operator|->
name|script
operator|)
operator|==
name|negated
return|;
comment|/* These are specials */
case|case
name|PT_ALNUM
case|:
return|return
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|)
operator|==
name|negated
return|;
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
return|return
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
operator|||
name|c
operator|==
name|CHAR_HT
operator|||
name|c
operator|==
name|CHAR_NL
operator|||
name|c
operator|==
name|CHAR_FF
operator|||
name|c
operator|==
name|CHAR_CR
operator|)
operator|==
name|negated
return|;
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
return|return
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
operator|||
name|c
operator|==
name|CHAR_HT
operator|||
name|c
operator|==
name|CHAR_NL
operator|||
name|c
operator|==
name|CHAR_VT
operator|||
name|c
operator|==
name|CHAR_FF
operator|||
name|c
operator|==
name|CHAR_CR
operator|)
operator|==
name|negated
return|;
case|case
name|PT_WORD
case|:
return|return
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
operator|)
operator|==
name|negated
return|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|PT_CLIST
case|:
name|p
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|prop
operator|->
name|caseset
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|p
condition|)
return|return
operator|!
name|negated
return|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
operator|++
condition|)
return|return
name|negated
return|;
block|}
break|break;
comment|/* Control never reaches here */
endif|#
directive|endif
block|}
return|return
name|FALSE
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UCP */
end_comment
begin_comment
comment|/************************************************* *     Check if auto-possessifying is possible    * *************************************************/
end_comment
begin_comment
comment|/* This function is called for unlimited repeats of certain items, to see whether the next thing could possibly match the repeated item. If not, it makes sense to automatically possessify the repeated item.  Arguments:   previous      pointer to the repeated opcode   utf           TRUE in UTF-8 / UTF-16 / UTF-32 mode   ptr           next character in pattern   options       options bits   cd            contains pointers to tables etc.  Returns:        TRUE if possessifying is wanted */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|check_auto_possessive
name|check_auto_possessive
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|previous
parameter_list|,
name|BOOL
name|utf
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|ptr
parameter_list|,
name|int
name|options
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|)
block|{
name|pcre_uint32
name|c
init|=
name|NOTACHAR
decl_stmt|;
name|pcre_uint32
name|next
decl_stmt|;
name|int
name|escape
decl_stmt|;
name|pcre_uchar
name|op_code
init|=
operator|*
name|previous
operator|++
decl_stmt|;
comment|/* Skip whitespace and comments in extended mode */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_EXTENDED
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|ptr
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NUMBER_SIGN
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|)
block|{
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|cd
operator|->
name|nllen
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
name|FORWARDCHAR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
break|break;
block|}
block|}
comment|/* If the next item is one that we can handle, get its value. A non-negative value is a character, a negative value is an escape value. */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_BACKSLASH
condition|)
block|{
name|int
name|temperrorcode
init|=
literal|0
decl_stmt|;
name|escape
operator|=
name|check_escape
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|temperrorcode
argument_list|,
name|cd
operator|->
name|bracount
argument_list|,
name|options
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temperrorcode
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|++
expr_stmt|;
comment|/* Point after the escape sequence */
block|}
elseif|else
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|ptr
index|]
operator|&
name|ctype_meta
operator|)
operator|==
literal|0
condition|)
block|{
name|escape
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|next
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|next
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* Skip whitespace and comments in extended mode */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_EXTENDED
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|ptr
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NUMBER_SIGN
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|)
block|{
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|cd
operator|->
name|nllen
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
name|FORWARDCHAR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
break|break;
block|}
block|}
comment|/* If the next thing is itself optional, we have to give up. */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_ASTERISK
operator|||
operator|*
name|ptr
operator|==
name|CHAR_QUESTION_MARK
operator|||
name|STRNCMP_UC_C8
argument_list|(
argument|ptr
argument_list|,
argument|STR_LEFT_CURLY_BRACKET STR_0 STR_COMMA
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* If the previous item is a character, get its value. */
if|if
condition|(
name|op_code
operator|==
name|OP_CHAR
operator|||
name|op_code
operator|==
name|OP_CHARI
operator|||
name|op_code
operator|==
name|OP_NOT
operator|||
name|op_code
operator|==
name|OP_NOTI
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|GETCHARTEST
argument_list|(
name|c
argument_list|,
name|previous
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
operator|*
name|previous
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Now compare the next item with the previous opcode. First, handle cases when the next item is a character. */
if|if
condition|(
name|escape
operator|==
literal|0
condition|)
block|{
comment|/* For a caseless UTF match, the next character may have more than one other   case, which maps to the special PT_CLIST property. Check this first. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|utf
operator|&&
name|c
operator|!=
name|NOTACHAR
operator|&&
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|ocs
init|=
name|UCD_CASESET
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|ocs
operator|>
literal|0
condition|)
return|return
name|check_char_prop
argument_list|(
name|c
argument_list|,
name|PT_CLIST
argument_list|,
name|ocs
argument_list|,
name|op_code
operator|>=
name|OP_NOT
argument_list|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|OP_CHAR
case|:
return|return
name|c
operator|!=
name|next
return|;
comment|/* For CHARI (caseless character) we must check the other case. If we have     Unicode property support, we can use it to test the other case of     high-valued characters. We know that next can have only one other case,     because multi-other-case characters are dealt with above. */
case|case
name|OP_CHARI
case|:
if|if
condition|(
name|c
operator|==
name|next
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|pcre_uint32
name|othercase
decl_stmt|;
if|if
condition|(
name|next
operator|<
literal|128
condition|)
name|othercase
operator|=
name|cd
operator|->
name|fcc
index|[
name|next
index|]
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|othercase
operator|=
name|UCD_OTHERCASE
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
name|othercase
operator|=
name|NOTACHAR
expr_stmt|;
endif|#
directive|endif
return|return
name|c
operator|!=
name|othercase
return|;
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
return|return
operator|(
name|c
operator|!=
name|TABLE_GET
argument_list|(
name|next
argument_list|,
name|cd
operator|->
name|fcc
argument_list|,
name|next
argument_list|)
operator|)
return|;
comment|/* Not UTF */
case|case
name|OP_NOT
case|:
return|return
name|c
operator|==
name|next
return|;
case|case
name|OP_NOTI
case|:
if|if
condition|(
name|c
operator|==
name|next
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|pcre_uint32
name|othercase
decl_stmt|;
if|if
condition|(
name|next
operator|<
literal|128
condition|)
name|othercase
operator|=
name|cd
operator|->
name|fcc
index|[
name|next
index|]
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|othercase
operator|=
name|UCD_OTHERCASE
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
name|othercase
operator|=
name|NOTACHAR
expr_stmt|;
endif|#
directive|endif
return|return
name|c
operator|==
name|othercase
return|;
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
return|return
operator|(
name|c
operator|==
name|TABLE_GET
argument_list|(
name|next
argument_list|,
name|cd
operator|->
name|fcc
argument_list|,
name|next
argument_list|)
operator|)
return|;
comment|/* Not UTF */
comment|/* Note that OP_DIGIT etc. are generated only when PCRE_UCP is *not* set.     When it is set, \d etc. are converted into OP_(NOT_)PROP codes. */
case|case
name|OP_DIGIT
case|:
return|return
name|next
operator|>
literal|255
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
name|next
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
return|;
case|case
name|OP_NOT_DIGIT
case|:
return|return
name|next
operator|<=
literal|255
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|next
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
return|;
case|case
name|OP_WHITESPACE
case|:
return|return
name|next
operator|>
literal|255
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
name|next
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
return|;
case|case
name|OP_NOT_WHITESPACE
case|:
return|return
name|next
operator|<=
literal|255
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|next
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
return|;
case|case
name|OP_WORDCHAR
case|:
return|return
name|next
operator|>
literal|255
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
name|next
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
return|;
case|case
name|OP_NOT_WORDCHAR
case|:
return|return
name|next
operator|<=
literal|255
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|next
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
return|;
case|case
name|OP_HSPACE
case|:
case|case
name|OP_NOT_HSPACE
case|:
switch|switch
condition|(
name|next
condition|)
block|{
name|HSPACE_CASES
label|:
return|return
name|op_code
operator|==
name|OP_NOT_HSPACE
return|;
default|default:
return|return
name|op_code
operator|!=
name|OP_NOT_HSPACE
return|;
block|}
case|case
name|OP_ANYNL
case|:
case|case
name|OP_VSPACE
case|:
case|case
name|OP_NOT_VSPACE
case|:
switch|switch
condition|(
name|next
condition|)
block|{
name|VSPACE_CASES
label|:
return|return
name|op_code
operator|==
name|OP_NOT_VSPACE
return|;
default|default:
return|return
name|op_code
operator|!=
name|OP_NOT_VSPACE
return|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_PROP
case|:
return|return
name|check_char_prop
argument_list|(
name|next
argument_list|,
name|previous
index|[
literal|0
index|]
argument_list|,
name|previous
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|)
return|;
case|case
name|OP_NOTPROP
case|:
return|return
name|check_char_prop
argument_list|(
name|next
argument_list|,
name|previous
index|[
literal|0
index|]
argument_list|,
name|previous
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|)
return|;
endif|#
directive|endif
default|default:
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Handle the case when the next item is \d, \s, etc. Note that when PCRE_UCP is set, \d turns into ESC_du rather than ESC_d, etc., so ESC_d etc. are generated only when PCRE_UCP is *not* set, that is, when only ASCII characteristics are recognized. Similarly, the opcodes OP_DIGIT etc. are replaced by OP_PROP codes when PCRE_UCP is set. */
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|OP_CHAR
case|:
case|case
name|OP_CHARI
case|:
switch|switch
condition|(
name|escape
condition|)
block|{
case|case
name|ESC_d
case|:
return|return
name|c
operator|>
literal|255
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
return|;
case|case
name|ESC_D
case|:
return|return
name|c
operator|<=
literal|255
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_digit
operator|)
operator|!=
literal|0
return|;
case|case
name|ESC_s
case|:
return|return
name|c
operator|>
literal|255
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|==
literal|0
return|;
case|case
name|ESC_S
case|:
return|return
name|c
operator|<=
literal|255
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
return|;
case|case
name|ESC_w
case|:
return|return
name|c
operator|>
literal|255
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
return|;
case|case
name|ESC_W
case|:
return|return
name|c
operator|<=
literal|255
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
return|;
case|case
name|ESC_h
case|:
case|case
name|ESC_H
case|:
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
return|return
name|escape
operator|!=
name|ESC_h
return|;
default|default:
return|return
name|escape
operator|==
name|ESC_h
return|;
block|}
case|case
name|ESC_v
case|:
case|case
name|ESC_V
case|:
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
return|return
name|escape
operator|!=
name|ESC_v
return|;
default|default:
return|return
name|escape
operator|==
name|ESC_v
return|;
block|}
comment|/* When PCRE_UCP is set, these values get generated for \d etc. Find     their substitutions and process them. The result will always be either     ESC_p or ESC_P. Then fall through to process those values. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|ESC_du
case|:
case|case
name|ESC_DU
case|:
case|case
name|ESC_wu
case|:
case|case
name|ESC_WU
case|:
case|case
name|ESC_su
case|:
case|case
name|ESC_SU
case|:
block|{
name|int
name|temperrorcode
init|=
literal|0
decl_stmt|;
name|ptr
operator|=
name|substitutes
index|[
name|escape
operator|-
name|ESC_DU
index|]
expr_stmt|;
name|escape
operator|=
name|check_escape
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|temperrorcode
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temperrorcode
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|++
expr_stmt|;
comment|/* For compatibility */
block|}
comment|/* Fall through */
case|case
name|ESC_p
case|:
case|case
name|ESC_P
case|:
block|{
name|unsigned
name|int
name|ptype
init|=
literal|0
decl_stmt|,
name|pdata
init|=
literal|0
decl_stmt|;
name|int
name|errorcodeptr
decl_stmt|;
name|BOOL
name|negated
decl_stmt|;
name|ptr
operator|--
expr_stmt|;
comment|/* Make ptr point at the p or P */
if|if
condition|(
operator|!
name|get_ucp
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|negated
argument_list|,
operator|&
name|ptype
argument_list|,
operator|&
name|pdata
argument_list|,
operator|&
name|errorcodeptr
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|++
expr_stmt|;
comment|/* Point past the final curly ket */
comment|/* If the property item is optional, we have to give up. (When generated       from \d etc by PCRE_UCP, this test will have been applied much earlier,       to the original \d etc. At this point, ptr will point to a zero byte. */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_ASTERISK
operator|||
operator|*
name|ptr
operator|==
name|CHAR_QUESTION_MARK
operator|||
name|STRNCMP_UC_C8
argument_list|(
argument|ptr
argument_list|,
argument|STR_LEFT_CURLY_BRACKET STR_0 STR_COMMA
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Do the property check. */
return|return
name|check_char_prop
argument_list|(
name|c
argument_list|,
name|ptype
argument_list|,
name|pdata
argument_list|,
operator|(
name|escape
operator|==
name|ESC_P
operator|)
operator|!=
name|negated
argument_list|)
return|;
block|}
endif|#
directive|endif
default|default:
return|return
name|FALSE
return|;
block|}
comment|/* In principle, support for Unicode properties should be integrated here as   well. It means re-organizing the above code so as to get hold of the property   values before switching on the op-code. However, I wonder how many patterns   combine ASCII \d etc with Unicode properties? (Note that if PCRE_UCP is set,   these op-codes are never generated.) */
case|case
name|OP_DIGIT
case|:
return|return
name|escape
operator|==
name|ESC_D
operator|||
name|escape
operator|==
name|ESC_s
operator|||
name|escape
operator|==
name|ESC_W
operator|||
name|escape
operator|==
name|ESC_h
operator|||
name|escape
operator|==
name|ESC_v
operator|||
name|escape
operator|==
name|ESC_R
return|;
case|case
name|OP_NOT_DIGIT
case|:
return|return
name|escape
operator|==
name|ESC_d
return|;
case|case
name|OP_WHITESPACE
case|:
return|return
name|escape
operator|==
name|ESC_S
operator|||
name|escape
operator|==
name|ESC_d
operator|||
name|escape
operator|==
name|ESC_w
return|;
case|case
name|OP_NOT_WHITESPACE
case|:
return|return
name|escape
operator|==
name|ESC_s
operator|||
name|escape
operator|==
name|ESC_h
operator|||
name|escape
operator|==
name|ESC_v
operator|||
name|escape
operator|==
name|ESC_R
return|;
case|case
name|OP_HSPACE
case|:
return|return
name|escape
operator|==
name|ESC_S
operator|||
name|escape
operator|==
name|ESC_H
operator|||
name|escape
operator|==
name|ESC_d
operator|||
name|escape
operator|==
name|ESC_w
operator|||
name|escape
operator|==
name|ESC_v
operator|||
name|escape
operator|==
name|ESC_R
return|;
case|case
name|OP_NOT_HSPACE
case|:
return|return
name|escape
operator|==
name|ESC_h
return|;
comment|/* Can't have \S in here because VT matches \S (Perl anomaly) */
case|case
name|OP_ANYNL
case|:
case|case
name|OP_VSPACE
case|:
return|return
name|escape
operator|==
name|ESC_V
operator|||
name|escape
operator|==
name|ESC_d
operator|||
name|escape
operator|==
name|ESC_w
return|;
case|case
name|OP_NOT_VSPACE
case|:
return|return
name|escape
operator|==
name|ESC_v
operator|||
name|escape
operator|==
name|ESC_R
return|;
case|case
name|OP_WORDCHAR
case|:
return|return
name|escape
operator|==
name|ESC_W
operator|||
name|escape
operator|==
name|ESC_s
operator|||
name|escape
operator|==
name|ESC_h
operator|||
name|escape
operator|==
name|ESC_v
operator|||
name|escape
operator|==
name|ESC_R
return|;
case|case
name|OP_NOT_WORDCHAR
case|:
return|return
name|escape
operator|==
name|ESC_w
operator|||
name|escape
operator|==
name|ESC_d
return|;
default|default:
return|return
name|FALSE
return|;
block|}
comment|/* Control does not reach here */
block|}
end_function
begin_comment
comment|/************************************************* *        Add a character or range to a class     * *************************************************/
end_comment
begin_comment
comment|/* This function packages up the logic of adding a character or range of characters to a class. The character values in the arguments will be within the valid values for the current mode (8-bit, 16-bit, UTF, etc). This function is mutually recursive with the function immediately below.  Arguments:   classbits     the bit map for characters< 256   uchardptr     points to the pointer for extra data   options       the options word   cd            contains pointers to tables etc.   start         start of range character   end           end of range character  Returns:        the number of< 256 characters added                 the pointer to extra data is updated */
end_comment
begin_function
specifier|static
name|int
DECL|function|add_to_class
name|add_to_class
parameter_list|(
name|pcre_uint8
modifier|*
name|classbits
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
name|uchardptr
parameter_list|,
name|int
name|options
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
name|pcre_uint32
name|start
parameter_list|,
name|pcre_uint32
name|end
parameter_list|)
block|{
name|pcre_uint32
name|c
decl_stmt|;
name|int
name|n8
init|=
literal|0
decl_stmt|;
comment|/* If caseless matching is required, scan the range and process alternate cases. In Unicode, there are 8-bit characters that have alternate cases that are greater than 255 and vice-versa. Sometimes we can just extend the original range. */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|rc
decl_stmt|;
name|pcre_uint32
name|oc
decl_stmt|,
name|od
decl_stmt|;
name|options
operator|&=
operator|~
name|PCRE_CASELESS
expr_stmt|;
comment|/* Remove for recursive calls */
name|c
operator|=
name|start
expr_stmt|;
while|while
condition|(
operator|(
name|rc
operator|=
name|get_othercase_range
argument_list|(
operator|&
name|c
argument_list|,
name|end
argument_list|,
operator|&
name|oc
argument_list|,
operator|&
name|od
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Handle a single character that has more than one other case. */
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|n8
operator|+=
name|add_list_to_class
argument_list|(
name|classbits
argument_list|,
name|uchardptr
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|rc
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* Do nothing if the other case range is within the original range. */
elseif|else
if|if
condition|(
name|oc
operator|>=
name|start
operator|&&
name|od
operator|<=
name|end
condition|)
continue|continue;
comment|/* Extend the original range if there is overlap, noting that if oc< c, we       can't have od> end because a subrange is always shorter than the basic       range. Otherwise, use a recursive call to add the additional range. */
elseif|else
if|if
condition|(
name|oc
operator|<
name|start
operator|&&
name|od
operator|>=
name|start
operator|-
literal|1
condition|)
name|start
operator|=
name|oc
expr_stmt|;
comment|/* Extend downwards */
elseif|else
if|if
condition|(
name|od
operator|>
name|end
operator|&&
name|oc
operator|<=
name|end
operator|+
literal|1
condition|)
name|end
operator|=
name|od
expr_stmt|;
comment|/* Extend upwards */
else|else
name|n8
operator|+=
name|add_to_class
argument_list|(
name|classbits
argument_list|,
name|uchardptr
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|oc
argument_list|,
name|od
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UCP */
comment|/* Not UTF-mode, or no UCP */
for|for
control|(
name|c
operator|=
name|start
init|;
name|c
operator|<=
name|end
operator|&&
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
name|SETBIT
argument_list|(
name|classbits
argument_list|,
name|cd
operator|->
name|fcc
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|n8
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now handle the original range. Adjust the final value according to the bit length - this means that the same lists of (e.g.) horizontal spaces can be used in all cases. */
if|#
directive|if
name|defined
name|COMPILE_PCRE8
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
if|if
condition|(
name|end
operator|>
literal|0xff
condition|)
name|end
operator|=
literal|0xff
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_UTF16
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
if|if
condition|(
name|end
operator|>
literal|0xffff
condition|)
name|end
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
comment|/* COMPILE_PCRE[8|16] */
comment|/* If all characters are less than 256, use the bit map. Otherwise use extra data. */
if|if
condition|(
name|end
operator|<
literal|0x100
condition|)
block|{
for|for
control|(
name|c
operator|=
name|start
init|;
name|c
operator|<=
name|end
condition|;
name|c
operator|++
control|)
block|{
name|n8
operator|++
expr_stmt|;
name|SETBIT
argument_list|(
name|classbits
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pcre_uchar
modifier|*
name|uchardata
init|=
operator|*
name|uchardptr
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
condition|)
comment|/* All UTFs use the same flag bit */
block|{
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
operator|*
name|uchardata
operator|++
operator|=
name|XCL_RANGE
expr_stmt|;
name|uchardata
operator|+=
name|PRIV
argument_list|(
name|ord2utf
argument_list|)
argument_list|(
name|start
argument_list|,
name|uchardata
argument_list|)
expr_stmt|;
name|uchardata
operator|+=
name|PRIV
argument_list|(
name|ord2utf
argument_list|)
argument_list|(
name|end
argument_list|,
name|uchardata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
operator|*
name|uchardata
operator|++
operator|=
name|XCL_SINGLE
expr_stmt|;
name|uchardata
operator|+=
name|PRIV
argument_list|(
name|ord2utf
argument_list|)
argument_list|(
name|start
argument_list|,
name|uchardata
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Without UTF support, character values are constrained by the bit length,   and can only be> 256 for 16-bit and 32-bit libraries. */
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
block|{}
else|#
directive|else
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
operator|*
name|uchardata
operator|++
operator|=
name|XCL_RANGE
expr_stmt|;
operator|*
name|uchardata
operator|++
operator|=
name|start
expr_stmt|;
operator|*
name|uchardata
operator|++
operator|=
name|end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
operator|*
name|uchardata
operator|++
operator|=
name|XCL_SINGLE
expr_stmt|;
operator|*
name|uchardata
operator|++
operator|=
name|start
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|uchardptr
operator|=
name|uchardata
expr_stmt|;
comment|/* Updata extra data pointer */
block|}
return|return
name|n8
return|;
comment|/* Number of 8-bit characters */
block|}
end_function
begin_comment
comment|/************************************************* *        Add a list of characters to a class     * *************************************************/
end_comment
begin_comment
comment|/* This function is used for adding a list of case-equivalent characters to a class, and also for adding a list of horizontal or vertical whitespace. If the list is in order (which it should be), ranges of characters are detected and handled appropriately. This function is mutually recursive with the function above.  Arguments:   classbits     the bit map for characters< 256   uchardptr     points to the pointer for extra data   options       the options word   cd            contains pointers to tables etc.   p             points to row of 32-bit values, terminated by NOTACHAR   except        character to omit; this is used when adding lists of                   case-equivalent characters to avoid including the one we                   already know about  Returns:        the number of< 256 characters added                 the pointer to extra data is updated */
end_comment
begin_function
specifier|static
name|int
DECL|function|add_list_to_class
name|add_list_to_class
parameter_list|(
name|pcre_uint8
modifier|*
name|classbits
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
name|uchardptr
parameter_list|,
name|int
name|options
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
specifier|const
name|pcre_uint32
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|except
parameter_list|)
block|{
name|int
name|n8
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|<
name|NOTACHAR
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|except
condition|)
block|{
while|while
condition|(
name|p
index|[
name|n
operator|+
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
operator|+
name|n
operator|+
literal|1
condition|)
name|n
operator|++
expr_stmt|;
name|n8
operator|+=
name|add_to_class
argument_list|(
name|classbits
argument_list|,
name|uchardptr
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|n
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|n8
return|;
block|}
end_function
begin_comment
comment|/************************************************* *    Add characters not in a list to a class     * *************************************************/
end_comment
begin_comment
comment|/* This function is used for adding the complement of a list of horizontal or vertical whitespace to a class. The list must be in order.  Arguments:   classbits     the bit map for characters< 256   uchardptr     points to the pointer for extra data   options       the options word   cd            contains pointers to tables etc.   p             points to row of 32-bit values, terminated by NOTACHAR  Returns:        the number of< 256 characters added                 the pointer to extra data is updated */
end_comment
begin_function
specifier|static
name|int
DECL|function|add_not_list_to_class
name|add_not_list_to_class
parameter_list|(
name|pcre_uint8
modifier|*
name|classbits
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
name|uchardptr
parameter_list|,
name|int
name|options
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
specifier|const
name|pcre_uint32
modifier|*
name|p
parameter_list|)
block|{
name|BOOL
name|utf
init|=
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|n8
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>
literal|0
condition|)
name|n8
operator|+=
name|add_to_class
argument_list|(
name|classbits
argument_list|,
name|uchardptr
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
literal|0
argument_list|,
name|p
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|<
name|NOTACHAR
condition|)
block|{
while|while
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
operator|+
literal|1
condition|)
name|p
operator|++
expr_stmt|;
name|n8
operator|+=
name|add_to_class
argument_list|(
name|classbits
argument_list|,
name|uchardptr
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|p
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|(
name|p
index|[
literal|1
index|]
operator|==
name|NOTACHAR
operator|)
condition|?
operator|(
name|utf
condition|?
literal|0x10ffffu
else|:
literal|0xffffffffu
operator|)
else|:
name|p
index|[
literal|1
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|n8
return|;
block|}
end_function
begin_comment
comment|/************************************************* *           Compile one branch                   * *************************************************/
end_comment
begin_comment
comment|/* Scan the pattern, compiling it into the a vector. If the options are changed during the branch, the pointer is used to change the external options bits. This function is used during the pre-compile phase when we are trying to find out the amount of memory needed, as well as during the real compile phase. The value of lengthptr distinguishes the two phases.  Arguments:   optionsptr     pointer to the option bits   codeptr        points to the pointer to the current code point   ptrptr         points to the current pattern pointer   errorcodeptr   points to error code variable   firstcharptr    place to put the first required character   firstcharflagsptr place to put the first character flags, or a negative number   reqcharptr     place to put the last required character   reqcharflagsptr place to put the last required character flags, or a negative number   bcptr          points to current branch chain   cond_depth     conditional nesting depth   cd             contains pointers to tables etc.   lengthptr      NULL during the real compile phase                  points to length accumulator during pre-compile phase  Returns:         TRUE on success                  FALSE, with *errorcodeptr set non-zero on error */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|compile_branch
name|compile_branch
parameter_list|(
name|int
modifier|*
name|optionsptr
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
name|codeptr
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
modifier|*
name|ptrptr
parameter_list|,
name|int
modifier|*
name|errorcodeptr
parameter_list|,
name|pcre_uint32
modifier|*
name|firstcharptr
parameter_list|,
name|pcre_int32
modifier|*
name|firstcharflagsptr
parameter_list|,
name|pcre_uint32
modifier|*
name|reqcharptr
parameter_list|,
name|pcre_int32
modifier|*
name|reqcharflagsptr
parameter_list|,
name|branch_chain
modifier|*
name|bcptr
parameter_list|,
name|int
name|cond_depth
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
name|int
modifier|*
name|lengthptr
parameter_list|)
block|{
name|int
name|repeat_type
decl_stmt|,
name|op_type
decl_stmt|;
name|int
name|repeat_min
init|=
literal|0
decl_stmt|,
name|repeat_max
init|=
literal|0
decl_stmt|;
comment|/* To please picky compilers */
name|int
name|bravalue
init|=
literal|0
decl_stmt|;
name|int
name|greedy_default
decl_stmt|,
name|greedy_non_default
decl_stmt|;
name|pcre_uint32
name|firstchar
decl_stmt|,
name|reqchar
decl_stmt|;
name|pcre_int32
name|firstcharflags
decl_stmt|,
name|reqcharflags
decl_stmt|;
name|pcre_uint32
name|zeroreqchar
decl_stmt|,
name|zerofirstchar
decl_stmt|;
name|pcre_int32
name|zeroreqcharflags
decl_stmt|,
name|zerofirstcharflags
decl_stmt|;
name|pcre_int32
name|req_caseopt
decl_stmt|,
name|reqvary
decl_stmt|,
name|tempreqvary
decl_stmt|;
name|int
name|options
init|=
operator|*
name|optionsptr
decl_stmt|;
comment|/* May change dynamically */
name|int
name|after_manual_callout
init|=
literal|0
decl_stmt|;
name|int
name|length_prevgroup
init|=
literal|0
decl_stmt|;
specifier|register
name|pcre_uint32
name|c
decl_stmt|;
name|int
name|escape
decl_stmt|;
specifier|register
name|pcre_uchar
modifier|*
name|code
init|=
operator|*
name|codeptr
decl_stmt|;
name|pcre_uchar
modifier|*
name|last_code
init|=
name|code
decl_stmt|;
name|pcre_uchar
modifier|*
name|orig_code
init|=
name|code
decl_stmt|;
name|pcre_uchar
modifier|*
name|tempcode
decl_stmt|;
name|BOOL
name|inescq
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|groupsetfirstchar
init|=
name|FALSE
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|ptr
init|=
operator|*
name|ptrptr
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|tempptr
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|nestptr
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|previous
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|previous_callout
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|save_hwm
init|=
name|NULL
decl_stmt|;
name|pcre_uint8
name|classbits
index|[
literal|32
index|]
decl_stmt|;
comment|/* We can fish out the UTF-8 setting once and for all into a BOOL, but we must not do this for other options (e.g. PCRE_EXTENDED) because they may change dynamically as we process the pattern. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
comment|/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */
name|BOOL
name|utf
init|=
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE32
name|pcre_uchar
name|utf_chars
index|[
literal|6
index|]
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
name|BOOL
name|utf
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* Helper variables for OP_XCLASS opcode (for characters> 255). We define class_uchardata always so that it can be passed to add_to_class() always, though it will not be used in non-UTF 8-bit cases. This avoids having to supply alternative calls for the different cases. */
name|pcre_uchar
modifier|*
name|class_uchardata
decl_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
name|BOOL
name|xclass
decl_stmt|;
name|pcre_uchar
modifier|*
name|class_uchardata_base
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCRE_DEBUG
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|">> start branch\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the default and non-default settings for greediness */
name|greedy_default
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_UNGREEDY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|greedy_non_default
operator|=
name|greedy_default
operator|^
literal|1
expr_stmt|;
comment|/* Initialize no first byte, no required byte. REQ_UNSET means "no char matching encountered yet". It gets changed to REQ_NONE if we hit something that matches a non-fixed char first char; reqchar just remains unset if we never find one.  When we hit a repeat whose minimum is zero, we may have to adjust these values to take the zero repeat into account. This is implemented by setting them to zerofirstbyte and zeroreqchar when such a repeat is encountered. The individual item types that can be repeated set these backoff variables appropriately. */
name|firstchar
operator|=
name|reqchar
operator|=
name|zerofirstchar
operator|=
name|zeroreqchar
operator|=
literal|0
expr_stmt|;
name|firstcharflags
operator|=
name|reqcharflags
operator|=
name|zerofirstcharflags
operator|=
name|zeroreqcharflags
operator|=
name|REQ_UNSET
expr_stmt|;
comment|/* The variable req_caseopt contains either the REQ_CASELESS value or zero, according to the current setting of the caseless flag. The REQ_CASELESS leaves the lower 28 bit empty. It is added into the firstchar or reqchar variables to record the case status of the value. This is used only for ASCII characters. */
name|req_caseopt
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
operator|)
condition|?
name|REQ_CASELESS
else|:
literal|0
expr_stmt|;
comment|/* Switch on next character until the end of the branch */
for|for
control|(
init|;
condition|;
name|ptr
operator|++
control|)
block|{
name|BOOL
name|negate_class
decl_stmt|;
name|BOOL
name|should_flip_negation
decl_stmt|;
name|BOOL
name|possessive_quantifier
decl_stmt|;
name|BOOL
name|is_quantifier
decl_stmt|;
name|BOOL
name|is_recurse
decl_stmt|;
name|BOOL
name|reset_bracount
decl_stmt|;
name|int
name|class_has_8bitchar
decl_stmt|;
name|int
name|class_one_char
decl_stmt|;
name|int
name|newoptions
decl_stmt|;
name|int
name|recno
decl_stmt|;
name|int
name|refsign
decl_stmt|;
name|int
name|skipbytes
decl_stmt|;
name|pcre_uint32
name|subreqchar
decl_stmt|,
name|subfirstchar
decl_stmt|;
name|pcre_int32
name|subreqcharflags
decl_stmt|,
name|subfirstcharflags
decl_stmt|;
name|int
name|terminator
decl_stmt|;
name|unsigned
name|int
name|mclength
decl_stmt|;
name|unsigned
name|int
name|tempbracount
decl_stmt|;
name|pcre_uint32
name|ec
decl_stmt|;
name|pcre_uchar
name|mcbuffer
index|[
literal|8
index|]
decl_stmt|;
comment|/* Get next character in the pattern */
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
comment|/* If we are at the end of a nested substitution, revert to the outer level   string. Nesting only happens one level deep. */
if|if
condition|(
name|c
operator|==
name|CHAR_NULL
operator|&&
name|nestptr
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|nestptr
expr_stmt|;
name|nestptr
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
block|}
comment|/* If we are in the pre-compile phase, accumulate the length used for the   previous cycle of this loop. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PCRE_DEBUG
if|if
condition|(
name|code
operator|>
name|cd
operator|->
name|hwm
condition|)
name|cd
operator|->
name|hwm
operator|=
name|code
expr_stmt|;
comment|/* High water info */
endif|#
directive|endif
if|if
condition|(
name|code
operator|>
name|cd
operator|->
name|start_workspace
operator|+
name|cd
operator|->
name|workspace_size
operator|-
name|WORK_SIZE_SAFETY_MARGIN
condition|)
comment|/* Check for overrun */
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR52
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* There is at least one situation where code goes backwards: this is the     case of a zero quantifier after a class (e.g. [ab]{0}). At compile time,     the class is simply eliminated. However, it is created first, so we have to     allow memory for it. Therefore, don't ever reduce the length at this point.     */
if|if
condition|(
name|code
operator|<
name|last_code
condition|)
name|code
operator|=
name|last_code
expr_stmt|;
comment|/* Paranoid check for integer overflow */
if|if
condition|(
name|OFLOW_MAX
operator|-
operator|*
name|lengthptr
operator|<
name|code
operator|-
name|last_code
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR20
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
operator|*
name|lengthptr
operator|+=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|last_code
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"length=%d added %d c=%c (0x%x)\n"
operator|,
operator|*
name|lengthptr
operator|,
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|last_code
argument_list|)
operator|,
name|c
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
comment|/* If "previous" is set and it is not at the start of the work space, move     it back to there, in order to avoid filling up the work space. Otherwise,     if "previous" is NULL, reset the current code pointer to the start. */
if|if
condition|(
name|previous
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|previous
operator|>
name|orig_code
condition|)
block|{
name|memmove
argument_list|(
name|orig_code
argument_list|,
name|previous
argument_list|,
name|IN_UCHARS
argument_list|(
name|code
operator|-
name|previous
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|-=
name|previous
operator|-
name|orig_code
expr_stmt|;
name|previous
operator|=
name|orig_code
expr_stmt|;
block|}
block|}
else|else
name|code
operator|=
name|orig_code
expr_stmt|;
comment|/* Remember where this code item starts so we can pick up the length     next time round. */
name|last_code
operator|=
name|code
expr_stmt|;
block|}
comment|/* In the real compile phase, just check the workspace used by the forward   reference list. */
elseif|else
if|if
condition|(
name|cd
operator|->
name|hwm
operator|>
name|cd
operator|->
name|start_workspace
operator|+
name|cd
operator|->
name|workspace_size
operator|-
name|WORK_SIZE_SAFETY_MARGIN
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR52
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* If in \Q...\E, check for the end; if not, we have a literal */
if|if
condition|(
name|inescq
operator|&&
name|c
operator|!=
name|CHAR_NULL
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_E
condition|)
block|{
name|inescq
operator|=
name|FALSE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|previous_callout
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lengthptr
operator|==
name|NULL
condition|)
comment|/* Don't attempt in pre-compile phase */
name|complete_callout
argument_list|(
name|previous_callout
argument_list|,
name|ptr
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|previous_callout
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_AUTO_CALLOUT
operator|)
operator|!=
literal|0
condition|)
block|{
name|previous_callout
operator|=
name|code
expr_stmt|;
name|code
operator|=
name|auto_callout
argument_list|(
name|code
argument_list|,
name|ptr
argument_list|,
name|cd
argument_list|)
expr_stmt|;
block|}
goto|goto
name|NORMAL_CHAR
goto|;
block|}
block|}
comment|/* Fill in length of a previous callout, except when the next thing is   a quantifier. */
name|is_quantifier
operator|=
name|c
operator|==
name|CHAR_ASTERISK
operator|||
name|c
operator|==
name|CHAR_PLUS
operator|||
name|c
operator|==
name|CHAR_QUESTION_MARK
operator|||
operator|(
name|c
operator|==
name|CHAR_LEFT_CURLY_BRACKET
operator|&&
name|is_counted_repeat
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_quantifier
operator|&&
name|previous_callout
operator|!=
name|NULL
operator|&&
name|after_manual_callout
operator|--
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|lengthptr
operator|==
name|NULL
condition|)
comment|/* Don't attempt in pre-compile phase */
name|complete_callout
argument_list|(
name|previous_callout
argument_list|,
name|ptr
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|previous_callout
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* In extended mode, skip white space and comments. */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_EXTENDED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_space
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|CHAR_NUMBER_SIGN
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|)
block|{
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|cd
operator|->
name|nllen
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
name|FORWARDCHAR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|)
continue|continue;
comment|/* Else fall through to handle end of string */
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* No auto callout for quantifiers. */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_AUTO_CALLOUT
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|is_quantifier
condition|)
block|{
name|previous_callout
operator|=
name|code
expr_stmt|;
name|code
operator|=
name|auto_callout
argument_list|(
name|code
argument_list|,
name|ptr
argument_list|,
name|cd
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* ===================================================================*/
case|case
literal|0
case|:
comment|/* The branch terminates at string end */
case|case
name|CHAR_VERTICAL_LINE
case|:
comment|/* or | or ) */
case|case
name|CHAR_RIGHT_PARENTHESIS
case|:
operator|*
name|firstcharptr
operator|=
name|firstchar
expr_stmt|;
operator|*
name|firstcharflagsptr
operator|=
name|firstcharflags
expr_stmt|;
operator|*
name|reqcharptr
operator|=
name|reqchar
expr_stmt|;
operator|*
name|reqcharflagsptr
operator|=
name|reqcharflags
expr_stmt|;
operator|*
name|codeptr
operator|=
name|code
expr_stmt|;
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|OFLOW_MAX
operator|-
operator|*
name|lengthptr
operator|<
name|code
operator|-
name|last_code
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR20
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
operator|*
name|lengthptr
operator|+=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|last_code
argument_list|)
expr_stmt|;
comment|/* To include callout length */
name|DPRINTF
argument_list|(
operator|(
literal|">> end branch\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
comment|/* ===================================================================*/
comment|/* Handle single-character metacharacters. In multiline mode, ^ disables     the setting of any following char as a first character. */
case|case
name|CHAR_CIRCUMFLEX_ACCENT
case|:
name|previous
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_MULTILINE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|OP_CIRCM
expr_stmt|;
block|}
else|else
operator|*
name|code
operator|++
operator|=
name|OP_CIRC
expr_stmt|;
break|break;
case|case
name|CHAR_DOLLAR_SIGN
case|:
name|previous
operator|=
name|NULL
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_MULTILINE
operator|)
operator|!=
literal|0
operator|)
condition|?
name|OP_DOLLM
else|:
name|OP_DOLL
expr_stmt|;
break|break;
comment|/* There can never be a first char if '.' is first, whatever happens about     repeats. The value of reqchar doesn't change either. */
case|case
name|CHAR_DOT
case|:
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
name|zerofirstchar
operator|=
name|firstchar
expr_stmt|;
name|zerofirstcharflags
operator|=
name|firstcharflags
expr_stmt|;
name|zeroreqchar
operator|=
name|reqchar
expr_stmt|;
name|zeroreqcharflags
operator|=
name|reqcharflags
expr_stmt|;
name|previous
operator|=
name|code
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_DOTALL
operator|)
operator|!=
literal|0
operator|)
condition|?
name|OP_ALLANY
else|:
name|OP_ANY
expr_stmt|;
break|break;
comment|/* ===================================================================*/
comment|/* Character classes. If the included characters are all< 256, we build a     32-byte bitmap of the permitted characters, except in the special case     where there is only one such character. For negated classes, we build the     map as usual, then invert it at the end. However, we use a different opcode     so that data characters> 255 can be handled correctly.      If the class contains characters outside the 0-255 range, a different     opcode is compiled. It may optionally have a bit map for characters< 256,     but those above are are explicitly listed afterwards. A flag byte tells     whether the bitmap is present, and whether this is a negated class or not.      In JavaScript compatibility mode, an isolated ']' causes an error. In     default (Perl) mode, it is treated as a data character. */
case|case
name|CHAR_RIGHT_SQUARE_BRACKET
case|:
if|if
condition|(
operator|(
name|cd
operator|->
name|external_options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR64
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
goto|goto
name|NORMAL_CHAR
goto|;
case|case
name|CHAR_LEFT_SQUARE_BRACKET
case|:
name|previous
operator|=
name|code
expr_stmt|;
comment|/* PCRE supports POSIX class stuff inside a class. Perl gives an error if     they are encountered at the top level, so we'll do that too. */
if|if
condition|(
operator|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_COLON
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_DOT
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_EQUALS_SIGN
operator|)
operator|&&
name|check_posix_syntax
argument_list|(
name|ptr
argument_list|,
operator|&
name|tempptr
argument_list|)
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
operator|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_COLON
operator|)
condition|?
name|ERR13
else|:
name|ERR31
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* If the first character is '^', set the negation flag and skip it. Also,     if the first few characters (either before or after ^) are \Q\E or \E we     skip them too. This makes for compatibility with Perl. */
name|negate_class
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CHAR_BACKSLASH
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_E
condition|)
name|ptr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
argument|ptr +
literal|1
argument_list|,
argument|STR_Q STR_BACKSLASH STR_E
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|ptr
operator|+=
literal|3
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|negate_class
operator|&&
name|c
operator|==
name|CHAR_CIRCUMFLEX_ACCENT
condition|)
name|negate_class
operator|=
name|TRUE
expr_stmt|;
else|else
break|break;
block|}
comment|/* Empty classes are allowed in JavaScript compatibility mode. Otherwise,     an initial ']' is taken as a data character -- the code below handles     that. In JS mode, [] must always fail, so generate OP_FAIL, whereas     [^] must match any character, so generate OP_ALLANY. */
if|if
condition|(
name|c
operator|==
name|CHAR_RIGHT_SQUARE_BRACKET
operator|&&
operator|(
name|cd
operator|->
name|external_options
operator|&
name|PCRE_JAVASCRIPT_COMPAT
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|negate_class
condition|?
name|OP_ALLANY
else|:
name|OP_FAIL
expr_stmt|;
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
name|zerofirstchar
operator|=
name|firstchar
expr_stmt|;
name|zerofirstcharflags
operator|=
name|firstcharflags
expr_stmt|;
break|break;
block|}
comment|/* If a class contains a negative special such as \S, we need to flip the     negation flag at the end, so that support for characters> 255 works     correctly (they are all included in the class). */
name|should_flip_negation
operator|=
name|FALSE
expr_stmt|;
comment|/* For optimization purposes, we track some properties of the class:     class_has_8bitchar will be non-zero if the class contains at least one<     256 character; class_one_char will be 1 if the class contains just one     character. */
name|class_has_8bitchar
operator|=
literal|0
expr_stmt|;
name|class_one_char
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the 32-char bit map to all zeros. We build the map in a     temporary bit of memory, in case the class contains fewer than two     8-bit characters because in that case the compiled code doesn't use the bit     map. */
name|memset
argument_list|(
name|classbits
argument_list|,
literal|0
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|pcre_uint8
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
name|xclass
operator|=
name|FALSE
expr_stmt|;
name|class_uchardata
operator|=
name|code
operator|+
name|LINK_SIZE
operator|+
literal|2
expr_stmt|;
comment|/* For XCLASS items */
name|class_uchardata_base
operator|=
name|class_uchardata
expr_stmt|;
comment|/* Save the start */
endif|#
directive|endif
comment|/* Process characters until ] is reached. By writing this as a "do" it     means that an initial ] is taken as a data character. At the start of the     loop, c contains the first byte of the character. */
if|if
condition|(
name|c
operator|!=
name|CHAR_NULL
condition|)
do|do
block|{
specifier|const
name|pcre_uchar
modifier|*
name|oldptr
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Braces are required because the */
name|GETCHARLEN
argument_list|(
name|c
argument_list|,
name|ptr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
comment|/* In the pre-compile phase, accumulate the length of any extra       data and reset the pointer. This is so that very large classes that       contain a zillion> 255 characters no longer overwrite the work space       (which is on the stack). We have to remember that there was XCLASS data,       however. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
operator|&&
name|class_uchardata
operator|>
name|class_uchardata_base
condition|)
block|{
name|xclass
operator|=
name|TRUE
expr_stmt|;
operator|*
name|lengthptr
operator|+=
name|class_uchardata
operator|-
name|class_uchardata_base
expr_stmt|;
name|class_uchardata
operator|=
name|class_uchardata_base
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Inside \Q...\E everything is literal except \E */
if|if
condition|(
name|inescq
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_E
condition|)
comment|/* If we are at \E */
block|{
name|inescq
operator|=
name|FALSE
expr_stmt|;
comment|/* Reset literal state */
name|ptr
operator|++
expr_stmt|;
comment|/* Skip the 'E' */
continue|continue;
comment|/* Carry on with next */
block|}
goto|goto
name|CHECK_RANGE
goto|;
comment|/* Could be range if \E follows */
block|}
comment|/* Handle POSIX class names. Perl allows a negation extension of the       form [:^name:]. A square bracket that doesn't match the syntax is       treated as a literal. We also recognize the POSIX constructions       [.ch.] and [=ch=] ("collating elements") and fault them, as Perl       5.6 and 5.8 do. */
if|if
condition|(
name|c
operator|==
name|CHAR_LEFT_SQUARE_BRACKET
operator|&&
operator|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_COLON
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_DOT
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_EQUALS_SIGN
operator|)
operator|&&
name|check_posix_syntax
argument_list|(
name|ptr
argument_list|,
operator|&
name|tempptr
argument_list|)
condition|)
block|{
name|BOOL
name|local_negate
init|=
name|FALSE
decl_stmt|;
name|int
name|posix_class
decl_stmt|,
name|taboffset
decl_stmt|,
name|tabopt
decl_stmt|;
specifier|register
specifier|const
name|pcre_uint8
modifier|*
name|cbits
init|=
name|cd
operator|->
name|cbits
decl_stmt|;
name|pcre_uint8
name|pbits
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_COLON
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR31
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_CIRCUMFLEX_ACCENT
condition|)
block|{
name|local_negate
operator|=
name|TRUE
expr_stmt|;
name|should_flip_negation
operator|=
name|TRUE
expr_stmt|;
comment|/* Note negative special */
name|ptr
operator|++
expr_stmt|;
block|}
name|posix_class
operator|=
name|check_posix_name
argument_list|(
name|ptr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tempptr
operator|-
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|posix_class
operator|<
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR30
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* If matching is caseless, upper and lower are converted to         alpha. This relies on the fact that the class table starts with         alpha, lower, upper as the first 3 entries. */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
operator|&&
name|posix_class
operator|<=
literal|2
condition|)
name|posix_class
operator|=
literal|0
expr_stmt|;
comment|/* When PCRE_UCP is set, some of the POSIX classes are converted to         different escape sequences that use Unicode properties. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|pc
init|=
name|posix_class
operator|+
operator|(
operator|(
name|local_negate
operator|)
condition|?
name|POSIX_SUBSIZE
operator|/
literal|2
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|posix_substitutes
index|[
name|pc
index|]
operator|!=
name|NULL
condition|)
block|{
name|nestptr
operator|=
name|tempptr
operator|+
literal|1
expr_stmt|;
name|ptr
operator|=
name|posix_substitutes
index|[
name|pc
index|]
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* In the non-UCP case, we build the bit map for the POSIX class in a         chunk of local store because we may be adding and subtracting from it,         and we don't want to subtract bits that may be in the main map already.         At the end we or the result into the bit map that is being built. */
name|posix_class
operator|*=
literal|3
expr_stmt|;
comment|/* Copy in the first table (always present) */
name|memcpy
argument_list|(
name|pbits
argument_list|,
name|cbits
operator|+
name|posix_class_maps
index|[
name|posix_class
index|]
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|pcre_uint8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is a second table, add or remove it as required. */
name|taboffset
operator|=
name|posix_class_maps
index|[
name|posix_class
operator|+
literal|1
index|]
expr_stmt|;
name|tabopt
operator|=
name|posix_class_maps
index|[
name|posix_class
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|taboffset
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|tabopt
operator|>=
literal|0
condition|)
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|pbits
index|[
name|c
index|]
operator||=
name|cbits
index|[
name|c
operator|+
name|taboffset
index|]
expr_stmt|;
else|else
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|pbits
index|[
name|c
index|]
operator|&=
operator|~
name|cbits
index|[
name|c
operator|+
name|taboffset
index|]
expr_stmt|;
block|}
comment|/* Now see if we need to remove any special characters. An option         value of 1 removes vertical space and 2 removes underscore. */
if|if
condition|(
name|tabopt
operator|<
literal|0
condition|)
name|tabopt
operator|=
operator|-
name|tabopt
expr_stmt|;
if|if
condition|(
name|tabopt
operator|==
literal|1
condition|)
name|pbits
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x3c
expr_stmt|;
elseif|else
if|if
condition|(
name|tabopt
operator|==
literal|2
condition|)
name|pbits
index|[
literal|11
index|]
operator|&=
literal|0x7f
expr_stmt|;
comment|/* Add the POSIX table or its complement into the main table that is         being built and we are done. */
if|if
condition|(
name|local_negate
condition|)
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
operator|~
name|pbits
index|[
name|c
index|]
expr_stmt|;
else|else
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
name|pbits
index|[
name|c
index|]
expr_stmt|;
name|ptr
operator|=
name|tempptr
operator|+
literal|1
expr_stmt|;
comment|/* Every class contains at least one< 256 character. */
name|class_has_8bitchar
operator|=
literal|1
expr_stmt|;
comment|/* Every class contains at least two characters. */
name|class_one_char
operator|=
literal|2
expr_stmt|;
continue|continue;
comment|/* End of POSIX syntax handling */
block|}
comment|/* Backslash may introduce a single character, or it may introduce one       of the specials, which just set a flag. The sequence \b is a special       case. Inside a class (and only there) it is treated as backspace. We       assume that other escapes have more than one character in them, so       speculatively set both class_has_8bitchar and class_one_char bigger       than one. Unrecognized escapes fall through and are either treated       as literal characters (by default), or are faulted if       PCRE_EXTRA is set. */
if|if
condition|(
name|c
operator|==
name|CHAR_BACKSLASH
condition|)
block|{
name|escape
operator|=
name|check_escape
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|ec
argument_list|,
name|errorcodeptr
argument_list|,
name|cd
operator|->
name|bracount
argument_list|,
name|options
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errorcodeptr
operator|!=
literal|0
condition|)
goto|goto
name|FAILED
goto|;
if|if
condition|(
name|escape
operator|==
literal|0
condition|)
name|c
operator|=
name|ec
expr_stmt|;
elseif|else
if|if
condition|(
name|escape
operator|==
name|ESC_b
condition|)
name|c
operator|=
name|CHAR_BS
expr_stmt|;
comment|/* \b is backspace in a class */
elseif|else
if|if
condition|(
name|escape
operator|==
name|ESC_N
condition|)
comment|/* \N is not supported in a class */
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR71
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
elseif|else
if|if
condition|(
name|escape
operator|==
name|ESC_Q
condition|)
comment|/* Handle start of quoted string */
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_E
condition|)
block|{
name|ptr
operator|+=
literal|2
expr_stmt|;
comment|/* avoid empty string */
block|}
else|else
name|inescq
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|escape
operator|==
name|ESC_E
condition|)
continue|continue;
comment|/* Ignore orphan \E */
else|else
block|{
specifier|register
specifier|const
name|pcre_uint8
modifier|*
name|cbits
init|=
name|cd
operator|->
name|cbits
decl_stmt|;
comment|/* Every class contains at least two< 256 characters. */
name|class_has_8bitchar
operator|++
expr_stmt|;
comment|/* Every class contains at least two characters. */
name|class_one_char
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
name|escape
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|ESC_du
case|:
comment|/* These are the values given for \d etc */
case|case
name|ESC_DU
case|:
comment|/* when PCRE_UCP is set. We replace the */
case|case
name|ESC_wu
case|:
comment|/* escape sequence with an appropriate \p */
case|case
name|ESC_WU
case|:
comment|/* or \P to test Unicode properties instead */
case|case
name|ESC_su
case|:
comment|/* of the default ASCII testing. */
case|case
name|ESC_SU
case|:
name|nestptr
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|substitutes
index|[
name|escape
operator|-
name|ESC_DU
index|]
operator|-
literal|1
expr_stmt|;
comment|/* Just before substitute */
name|class_has_8bitchar
operator|--
expr_stmt|;
comment|/* Undo! */
continue|continue;
endif|#
directive|endif
case|case
name|ESC_d
case|:
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
name|cbits
index|[
name|c
operator|+
name|cbit_digit
index|]
expr_stmt|;
continue|continue;
case|case
name|ESC_D
case|:
name|should_flip_negation
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
operator|~
name|cbits
index|[
name|c
operator|+
name|cbit_digit
index|]
expr_stmt|;
continue|continue;
case|case
name|ESC_w
case|:
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
name|cbits
index|[
name|c
operator|+
name|cbit_word
index|]
expr_stmt|;
continue|continue;
case|case
name|ESC_W
case|:
name|should_flip_negation
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
operator|~
name|cbits
index|[
name|c
operator|+
name|cbit_word
index|]
expr_stmt|;
continue|continue;
comment|/* Perl 5.004 onwards omits VT from \s, but we must preserve it             if it was previously set by something earlier in the character             class. Luckily, the value of CHAR_VT is 0x0b in both ASCII and             EBCDIC, so we lazily just adjust the appropriate bit. */
case|case
name|ESC_s
case|:
name|classbits
index|[
literal|0
index|]
operator||=
name|cbits
index|[
name|cbit_space
index|]
expr_stmt|;
name|classbits
index|[
literal|1
index|]
operator||=
name|cbits
index|[
name|cbit_space
operator|+
literal|1
index|]
operator|&
operator|~
literal|0x08
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|2
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
name|cbits
index|[
name|c
operator|+
name|cbit_space
index|]
expr_stmt|;
continue|continue;
case|case
name|ESC_S
case|:
name|should_flip_negation
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator||=
operator|~
name|cbits
index|[
name|c
operator|+
name|cbit_space
index|]
expr_stmt|;
name|classbits
index|[
literal|1
index|]
operator||=
literal|0x08
expr_stmt|;
comment|/* Perl 5.004 onwards omits VT from \s */
continue|continue;
comment|/* The rest apply in both UCP and non-UCP cases. */
case|case
name|ESC_h
case|:
operator|(
name|void
operator|)
name|add_list_to_class
argument_list|(
name|classbits
argument_list|,
operator|&
name|class_uchardata
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|PRIV
argument_list|(
name|hspace_list
argument_list|)
argument_list|,
name|NOTACHAR
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ESC_H
case|:
operator|(
name|void
operator|)
name|add_not_list_to_class
argument_list|(
name|classbits
argument_list|,
operator|&
name|class_uchardata
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|PRIV
argument_list|(
name|hspace_list
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ESC_v
case|:
operator|(
name|void
operator|)
name|add_list_to_class
argument_list|(
name|classbits
argument_list|,
operator|&
name|class_uchardata
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|PRIV
argument_list|(
name|vspace_list
argument_list|)
argument_list|,
name|NOTACHAR
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ESC_V
case|:
operator|(
name|void
operator|)
name|add_not_list_to_class
argument_list|(
name|classbits
argument_list|,
operator|&
name|class_uchardata
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|PRIV
argument_list|(
name|vspace_list
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|ESC_p
case|:
case|case
name|ESC_P
case|:
block|{
name|BOOL
name|negated
decl_stmt|;
name|unsigned
name|int
name|ptype
init|=
literal|0
decl_stmt|,
name|pdata
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|get_ucp
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|negated
argument_list|,
operator|&
name|ptype
argument_list|,
operator|&
name|pdata
argument_list|,
name|errorcodeptr
argument_list|)
condition|)
goto|goto
name|FAILED
goto|;
operator|*
name|class_uchardata
operator|++
operator|=
operator|(
operator|(
name|escape
operator|==
name|ESC_p
operator|)
operator|!=
name|negated
operator|)
condition|?
name|XCL_PROP
else|:
name|XCL_NOTPROP
expr_stmt|;
operator|*
name|class_uchardata
operator|++
operator|=
name|ptype
expr_stmt|;
operator|*
name|class_uchardata
operator|++
operator|=
name|pdata
expr_stmt|;
name|class_has_8bitchar
operator|--
expr_stmt|;
comment|/* Undo! */
continue|continue;
block|}
endif|#
directive|endif
comment|/* Unrecognized escapes are faulted if PCRE is running in its             strict mode. By default, for compatibility with Perl, they are             treated as literals. */
default|default:
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_EXTRA
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR7
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|class_has_8bitchar
operator|--
expr_stmt|;
comment|/* Undo the speculative increase. */
name|class_one_char
operator|-=
literal|2
expr_stmt|;
comment|/* Undo the speculative increase. */
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
comment|/* Get the final character and fall through */
break|break;
block|}
block|}
comment|/* Fall through if the escape just defined a single character (c>= 0).         This may be greater than 256. */
name|escape
operator|=
literal|0
expr_stmt|;
block|}
comment|/* End of backslash handling */
comment|/* A character may be followed by '-' to form a range. However, Perl does       not permit ']' to be the end of the range. A '-' character at the end is       treated as a literal. Perl ignores orphaned \E sequences entirely. The       code for handling \Q and \E is messy. */
name|CHECK_RANGE
label|:
while|while
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_E
condition|)
block|{
name|inescq
operator|=
name|FALSE
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
name|oldptr
operator|=
name|ptr
expr_stmt|;
comment|/* Remember if \r or \n were explicitly used */
if|if
condition|(
name|c
operator|==
name|CHAR_CR
operator|||
name|c
operator|==
name|CHAR_NL
condition|)
name|cd
operator|->
name|external_flags
operator||=
name|PCRE_HASCRORLF
expr_stmt|;
comment|/* Check for range */
if|if
condition|(
operator|!
name|inescq
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_MINUS
condition|)
block|{
name|pcre_uint32
name|d
decl_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_E
condition|)
name|ptr
operator|+=
literal|2
expr_stmt|;
comment|/* If we hit \Q (not followed by \E) at this point, go into escaped         mode. */
while|while
condition|(
operator|*
name|ptr
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_Q
condition|)
block|{
name|ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_E
condition|)
block|{
name|ptr
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
name|inescq
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Minus (hyphen) at the end of a class is treated as a literal, so put         back the pointer and jump to handle the character that preceded it. */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NULL
operator|||
operator|(
operator|!
name|inescq
operator|&&
operator|*
name|ptr
operator|==
name|CHAR_RIGHT_SQUARE_BRACKET
operator|)
condition|)
block|{
name|ptr
operator|=
name|oldptr
expr_stmt|;
goto|goto
name|CLASS_SINGLE_CHARACTER
goto|;
block|}
comment|/* Otherwise, we have a potential range; pick up the next character */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
comment|/* Braces are required because the */
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
name|ptr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
block|}
else|else
endif|#
directive|endif
name|d
operator|=
operator|*
name|ptr
expr_stmt|;
comment|/* Not UTF-8 mode */
comment|/* The second part of a range can be a single-character escape, but         not any of the other escapes. Perl 5.6 treats a hyphen as a literal         in such circumstances. */
if|if
condition|(
operator|!
name|inescq
operator|&&
name|d
operator|==
name|CHAR_BACKSLASH
condition|)
block|{
name|int
name|descape
decl_stmt|;
name|descape
operator|=
name|check_escape
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|d
argument_list|,
name|errorcodeptr
argument_list|,
name|cd
operator|->
name|bracount
argument_list|,
name|options
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errorcodeptr
operator|!=
literal|0
condition|)
goto|goto
name|FAILED
goto|;
comment|/* \b is backspace; any other special means the '-' was literal. */
if|if
condition|(
name|descape
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|descape
operator|==
name|ESC_b
condition|)
name|d
operator|=
name|CHAR_BS
expr_stmt|;
else|else
block|{
name|ptr
operator|=
name|oldptr
expr_stmt|;
goto|goto
name|CLASS_SINGLE_CHARACTER
goto|;
comment|/* A few lines below */
block|}
block|}
block|}
comment|/* Check that the two values are in the correct order. Optimize         one-character ranges. */
if|if
condition|(
name|d
operator|<
name|c
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR8
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|d
operator|==
name|c
condition|)
goto|goto
name|CLASS_SINGLE_CHARACTER
goto|;
comment|/* A few lines below */
comment|/* We have found a character range, so single character optimizations         cannot be done anymore. Any value greater than 1 indicates that there         is more than one character. */
name|class_one_char
operator|=
literal|2
expr_stmt|;
comment|/* Remember an explicit \r or \n, and add the range to the class. */
if|if
condition|(
name|d
operator|==
name|CHAR_CR
operator|||
name|d
operator|==
name|CHAR_NL
condition|)
name|cd
operator|->
name|external_flags
operator||=
name|PCRE_HASCRORLF
expr_stmt|;
name|class_has_8bitchar
operator|+=
name|add_to_class
argument_list|(
name|classbits
argument_list|,
operator|&
name|class_uchardata
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Go get the next char in the class */
block|}
comment|/* Handle a single character - we can get here for a normal non-escape       char, or after \ that introduces a single character or for an apparent       range that isn't. Only the value 1 matters for class_one_char, so don't       increase it if it is already 2 or more ... just in case there's a class       with a zillion characters in it. */
name|CLASS_SINGLE_CHARACTER
label|:
if|if
condition|(
name|class_one_char
operator|<
literal|2
condition|)
name|class_one_char
operator|++
expr_stmt|;
comment|/* If class_one_char is 1, we have the first single character in the       class, and there have been no prior ranges, or XCLASS items generated by       escapes. If this is the final character in the class, we can optimize by       turning the item into a 1-character OP_CHAR[I] if it's positive, or       OP_NOT[I] if it's negative. In the positive case, it can cause firstchar       to be set. Otherwise, there can be no first char if this item is first,       whatever repeat count may follow. In the case of reqchar, save the       previous value for reinstating. */
if|if
condition|(
name|class_one_char
operator|==
literal|1
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_RIGHT_SQUARE_BRACKET
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
name|zeroreqchar
operator|=
name|reqchar
expr_stmt|;
name|zeroreqcharflags
operator|=
name|reqcharflags
expr_stmt|;
if|if
condition|(
name|negate_class
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|int
name|d
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
name|zerofirstchar
operator|=
name|firstchar
expr_stmt|;
name|zerofirstcharflags
operator|=
name|firstcharflags
expr_stmt|;
comment|/* For caseless UTF-8 mode when UCP support is available, check           whether this character has more than one other case. If so, generate           a special OP_NOTPROP item instead of OP_NOTI. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|utf
operator|&&
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|d
operator|=
name|UCD_CASESET
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|OP_NOTPROP
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|PT_CLIST
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|d
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* Char has only one other case, or UCP not available */
block|{
operator|*
name|code
operator|++
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
operator|)
condition|?
name|OP_NOTI
else|:
name|OP_NOT
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
name|c
operator|>
name|MAX_VALUE_FOR_SINGLE_CHAR
condition|)
name|code
operator|+=
name|PRIV
argument_list|(
name|ord2utf
argument_list|)
argument_list|(
name|c
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|code
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* We are finished with this character class */
goto|goto
name|END_CLASS
goto|;
block|}
comment|/* For a single, positive character, get the value into mcbuffer, and         then we can handle this with the normal one-character code. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
name|c
operator|>
name|MAX_VALUE_FOR_SINGLE_CHAR
condition|)
name|mclength
operator|=
name|PRIV
argument_list|(
name|ord2utf
argument_list|)
argument_list|(
name|c
argument_list|,
name|mcbuffer
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|mcbuffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|mclength
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|ONE_CHAR
goto|;
block|}
comment|/* End of 1-char optimization */
comment|/* There is more than one character in the class, or an XCLASS item       has been generated. Add this character to the class. */
name|class_has_8bitchar
operator|+=
name|add_to_class
argument_list|(
name|classbits
argument_list|,
operator|&
name|class_uchardata
argument_list|,
name|options
argument_list|,
name|cd
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Loop until ']' reached. This "while" is the end of the "do" far above.     If we are at the end of an internal nested string, revert to the outer     string. */
do|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|)
operator|!=
name|CHAR_NULL
operator|||
operator|(
name|nestptr
operator|!=
name|NULL
operator|&&
operator|(
name|ptr
operator|=
name|nestptr
operator|,
name|nestptr
operator|=
name|NULL
operator|,
name|c
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|)
operator|!=
name|CHAR_NULL
operator|)
operator|)
operator|&&
operator|(
name|c
operator|!=
name|CHAR_RIGHT_SQUARE_BRACKET
operator|||
name|inescq
operator|)
condition|)
do|;
comment|/* Check for missing terminating ']' */
if|if
condition|(
name|c
operator|==
name|CHAR_NULL
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR6
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* We will need an XCLASS if data has been placed in class_uchardata. In     the second phase this is a sufficient test. However, in the pre-compile     phase, class_uchardata gets emptied to prevent workspace overflow, so it     only if the very last character in the class needs XCLASS will it contain     anything at this point. For this reason, xclass gets set TRUE above when     uchar_classdata is emptied, and that's why this code is the way it is here     instead of just doing a test on class_uchardata below. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|class_uchardata
operator|>
name|class_uchardata_base
condition|)
name|xclass
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* If this is the first thing in the branch, there can be no first char     setting, whatever the repeat count. Any reqchar setting must remain     unchanged after any kind of repeat. */
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
name|zerofirstchar
operator|=
name|firstchar
expr_stmt|;
name|zerofirstcharflags
operator|=
name|firstcharflags
expr_stmt|;
name|zeroreqchar
operator|=
name|reqchar
expr_stmt|;
name|zeroreqcharflags
operator|=
name|reqcharflags
expr_stmt|;
comment|/* If there are characters with values> 255, we have to compile an     extended class, with its own opcode, unless there was a negated special     such as \S in the class, and PCRE_UCP is not set, because in that case all     characters> 255 are in the class, so any that were explicitly given as     well can be ignored. If (when there are explicit characters> 255 that must     be listed) there are no characters< 256, we can omit the bitmap in the     actual compiled code. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|xclass
operator|&&
operator|(
operator|!
name|should_flip_negation
operator|||
operator|(
name|options
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
operator|)
condition|)
elif|#
directive|elif
operator|!
name|defined
name|COMPILE_PCRE8
if|if
condition|(
name|xclass
operator|&&
operator|!
name|should_flip_negation
condition|)
endif|#
directive|endif
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
block|{
operator|*
name|class_uchardata
operator|++
operator|=
name|XCL_END
expr_stmt|;
comment|/* Marks the end of extra data */
operator|*
name|code
operator|++
operator|=
name|OP_XCLASS
expr_stmt|;
name|code
operator|+=
name|LINK_SIZE
expr_stmt|;
operator|*
name|code
operator|=
name|negate_class
condition|?
name|XCL_NOT
else|:
literal|0
expr_stmt|;
comment|/* If the map is required, move up the extra data to make room for it;       otherwise just move the code pointer to the end of the extra data. */
if|if
condition|(
name|class_has_8bitchar
operator|>
literal|0
condition|)
block|{
operator|*
name|code
operator|++
operator||=
name|XCL_MAP
expr_stmt|;
name|memmove
argument_list|(
name|code
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
argument_list|,
name|code
argument_list|,
name|IN_UCHARS
argument_list|(
name|class_uchardata
operator|-
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|code
argument_list|,
name|classbits
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|code
operator|=
name|class_uchardata
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|code
operator|=
name|class_uchardata
expr_stmt|;
comment|/* Now fill in the complete length of the item */
name|PUT
argument_list|(
name|previous
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|previous
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* End of class handling */
block|}
endif|#
directive|endif
comment|/* If there are no characters> 255, or they are all to be included or     excluded, set the opcode to OP_CLASS or OP_NCLASS, depending on whether the     whole class was negated and whether there were negative specials such as \S     (non-UCP) in the class. Then copy the 32-byte map into the code vector,     negating it if necessary. */
operator|*
name|code
operator|++
operator|=
operator|(
name|negate_class
operator|==
name|should_flip_negation
operator|)
condition|?
name|OP_CLASS
else|:
name|OP_NCLASS
expr_stmt|;
if|if
condition|(
name|lengthptr
operator|==
name|NULL
condition|)
comment|/* Save time in the pre-compile phase */
block|{
if|if
condition|(
name|negate_class
condition|)
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
name|classbits
index|[
name|c
index|]
operator|=
operator|~
name|classbits
index|[
name|c
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|code
argument_list|,
name|classbits
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
name|code
operator|+=
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
name|END_CLASS
label|:
break|break;
comment|/* ===================================================================*/
comment|/* Various kinds of repeat; '{' is not necessarily a quantifier, but this     has been tested above. */
case|case
name|CHAR_LEFT_CURLY_BRACKET
case|:
if|if
condition|(
operator|!
name|is_quantifier
condition|)
goto|goto
name|NORMAL_CHAR
goto|;
name|ptr
operator|=
name|read_repeat_counts
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|&
name|repeat_min
argument_list|,
operator|&
name|repeat_max
argument_list|,
name|errorcodeptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errorcodeptr
operator|!=
literal|0
condition|)
goto|goto
name|FAILED
goto|;
goto|goto
name|REPEAT
goto|;
case|case
name|CHAR_ASTERISK
case|:
name|repeat_min
operator|=
literal|0
expr_stmt|;
name|repeat_max
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|REPEAT
goto|;
case|case
name|CHAR_PLUS
case|:
name|repeat_min
operator|=
literal|1
expr_stmt|;
name|repeat_max
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|REPEAT
goto|;
case|case
name|CHAR_QUESTION_MARK
case|:
name|repeat_min
operator|=
literal|0
expr_stmt|;
name|repeat_max
operator|=
literal|1
expr_stmt|;
name|REPEAT
label|:
if|if
condition|(
name|previous
operator|==
name|NULL
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR9
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|repeat_min
operator|==
literal|0
condition|)
block|{
name|firstchar
operator|=
name|zerofirstchar
expr_stmt|;
comment|/* Adjust for zero repeat */
name|firstcharflags
operator|=
name|zerofirstcharflags
expr_stmt|;
name|reqchar
operator|=
name|zeroreqchar
expr_stmt|;
comment|/* Ditto */
name|reqcharflags
operator|=
name|zeroreqcharflags
expr_stmt|;
block|}
comment|/* Remember whether this is a variable length repeat */
name|reqvary
operator|=
operator|(
name|repeat_min
operator|==
name|repeat_max
operator|)
condition|?
literal|0
else|:
name|REQ_VARY
expr_stmt|;
name|op_type
operator|=
literal|0
expr_stmt|;
comment|/* Default single-char op codes */
name|possessive_quantifier
operator|=
name|FALSE
expr_stmt|;
comment|/* Default not possessive quantifier */
comment|/* Save start of previous item, in case we have to move it up in order to     insert something before it. */
name|tempcode
operator|=
name|previous
expr_stmt|;
comment|/* If the next character is '+', we have a possessive quantifier. This     implies greediness, whatever the setting of the PCRE_UNGREEDY option.     If the next character is '?' this is a minimizing repeat, by default,     but if PCRE_UNGREEDY is set, it works the other way round. We change the     repeat type to the non-default. */
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_PLUS
condition|)
block|{
name|repeat_type
operator|=
literal|0
expr_stmt|;
comment|/* Force greedy */
name|possessive_quantifier
operator|=
name|TRUE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_QUESTION_MARK
condition|)
block|{
name|repeat_type
operator|=
name|greedy_non_default
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
name|repeat_type
operator|=
name|greedy_default
expr_stmt|;
comment|/* If previous was a recursion call, wrap it in atomic brackets so that     previous becomes the atomic group. All recursions were so wrapped in the     past, but it no longer happens for non-repeated recursions. In fact, the     repeated ones could be re-implemented independently so as not to need this,     but for the moment we rely on the code for repeating groups. */
if|if
condition|(
operator|*
name|previous
operator|==
name|OP_RECURSE
condition|)
block|{
name|memmove
argument_list|(
name|previous
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|previous
argument_list|,
name|IN_UCHARS
argument_list|(
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|previous
operator|=
name|OP_ONCE
expr_stmt|;
name|PUT
argument_list|(
name|previous
argument_list|,
literal|1
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|previous
index|[
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
index|]
operator|=
name|OP_KET
expr_stmt|;
name|PUT
argument_list|(
name|previous
argument_list|,
literal|3
operator|+
literal|2
operator|*
name|LINK_SIZE
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
expr_stmt|;
name|length_prevgroup
operator|=
literal|3
operator|+
literal|3
operator|*
name|LINK_SIZE
expr_stmt|;
comment|/* When actually compiling, we need to check whether this was a forward       reference, and if so, adjust the offset. */
if|if
condition|(
name|lengthptr
operator|==
name|NULL
operator|&&
name|cd
operator|->
name|hwm
operator|>=
name|cd
operator|->
name|start_workspace
operator|+
name|LINK_SIZE
condition|)
block|{
name|int
name|offset
init|=
name|GET
argument_list|(
name|cd
operator|->
name|hwm
argument_list|,
operator|-
name|LINK_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
name|previous
operator|+
literal|1
operator|-
name|cd
operator|->
name|start_code
condition|)
name|PUT
argument_list|(
name|cd
operator|->
name|hwm
argument_list|,
operator|-
name|LINK_SIZE
argument_list|,
name|offset
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now handle repetition for the different types of item. */
comment|/* If previous was a character or negated character match, abolish the item     and generate a repeat item instead. If a char item has a minimum of more     than one, ensure that it is set in reqchar - it might not be if a sequence     such as x{3} is the first thing in a branch because the x will have gone     into firstchar instead.  */
if|if
condition|(
operator|*
name|previous
operator|==
name|OP_CHAR
operator|||
operator|*
name|previous
operator|==
name|OP_CHARI
operator|||
operator|*
name|previous
operator|==
name|OP_NOT
operator|||
operator|*
name|previous
operator|==
name|OP_NOTI
condition|)
block|{
switch|switch
condition|(
operator|*
name|previous
condition|)
block|{
default|default:
comment|/* Make compiler happy. */
case|case
name|OP_CHAR
case|:
name|op_type
operator|=
name|OP_STAR
operator|-
name|OP_STAR
expr_stmt|;
break|break;
case|case
name|OP_CHARI
case|:
name|op_type
operator|=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
break|break;
case|case
name|OP_NOT
case|:
name|op_type
operator|=
name|OP_NOTSTAR
operator|-
name|OP_STAR
expr_stmt|;
break|break;
case|case
name|OP_NOTI
case|:
name|op_type
operator|=
name|OP_NOTSTARI
operator|-
name|OP_STAR
expr_stmt|;
break|break;
block|}
comment|/* Deal with UTF characters that take up more than one character. It's       easier to write this out separately than try to macrify it. Use c to       hold the length of the character in bytes, plus UTF_LENGTH to flag that       it's a length rather than a small character. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
name|NOT_FIRSTCHAR
argument_list|(
name|code
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|pcre_uchar
modifier|*
name|lastchar
init|=
name|code
operator|-
literal|1
decl_stmt|;
name|BACKCHAR
argument_list|(
name|lastchar
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|lastchar
argument_list|)
expr_stmt|;
comment|/* Length of UTF-8 character */
name|memcpy
argument_list|(
name|utf_chars
argument_list|,
name|lastchar
argument_list|,
name|IN_UCHARS
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the char */
name|c
operator||=
name|UTF_LENGTH
expr_stmt|;
comment|/* Flag c as a length */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Handle the case of a single charater - either with no UTF support, or       with UTF disabled, or for a single character UTF character. */
block|{
name|c
operator|=
name|code
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|previous
operator|<=
name|OP_CHARI
operator|&&
name|repeat_min
operator|>
literal|1
condition|)
block|{
name|reqchar
operator|=
name|c
expr_stmt|;
name|reqcharflags
operator|=
name|req_caseopt
operator||
name|cd
operator|->
name|req_varyopt
expr_stmt|;
block|}
block|}
comment|/* If the repetition is unlimited, it pays to see if the next thing on       the line is something that cannot possibly match this character. If so,       automatically possessifying this item gains some performance in the case       where the match fails. */
if|if
condition|(
operator|!
name|possessive_quantifier
operator|&&
name|repeat_max
operator|<
literal|0
operator|&&
name|check_auto_possessive
argument_list|(
name|previous
argument_list|,
name|utf
argument_list|,
name|ptr
operator|+
literal|1
argument_list|,
name|options
argument_list|,
name|cd
argument_list|)
condition|)
block|{
name|repeat_type
operator|=
literal|0
expr_stmt|;
comment|/* Force greedy */
name|possessive_quantifier
operator|=
name|TRUE
expr_stmt|;
block|}
goto|goto
name|OUTPUT_SINGLE_REPEAT
goto|;
comment|/* Code shared with single character types */
block|}
comment|/* If previous was a character type match (\d or similar), abolish it and     create a suitable repeat item. The code is shared with single-character     repeats by setting op_type to add a suitable offset into repeat_type. Note     the the Unicode property types will be present only when SUPPORT_UCP is     defined, but we don't wrap the little bits of code here because it just     makes it horribly messy. */
elseif|else
if|if
condition|(
operator|*
name|previous
operator|<
name|OP_EODN
condition|)
block|{
name|pcre_uchar
modifier|*
name|oldcode
decl_stmt|;
name|int
name|prop_type
decl_stmt|,
name|prop_value
decl_stmt|;
name|op_type
operator|=
name|OP_TYPESTAR
operator|-
name|OP_STAR
expr_stmt|;
comment|/* Use type opcodes */
name|c
operator|=
operator|*
name|previous
expr_stmt|;
if|if
condition|(
operator|!
name|possessive_quantifier
operator|&&
name|repeat_max
operator|<
literal|0
operator|&&
name|check_auto_possessive
argument_list|(
name|previous
argument_list|,
name|utf
argument_list|,
name|ptr
operator|+
literal|1
argument_list|,
name|options
argument_list|,
name|cd
argument_list|)
condition|)
block|{
name|repeat_type
operator|=
literal|0
expr_stmt|;
comment|/* Force greedy */
name|possessive_quantifier
operator|=
name|TRUE
expr_stmt|;
block|}
name|OUTPUT_SINGLE_REPEAT
label|:
if|if
condition|(
operator|*
name|previous
operator|==
name|OP_PROP
operator|||
operator|*
name|previous
operator|==
name|OP_NOTPROP
condition|)
block|{
name|prop_type
operator|=
name|previous
index|[
literal|1
index|]
expr_stmt|;
name|prop_value
operator|=
name|previous
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
name|prop_type
operator|=
name|prop_value
operator|=
operator|-
literal|1
expr_stmt|;
name|oldcode
operator|=
name|code
expr_stmt|;
name|code
operator|=
name|previous
expr_stmt|;
comment|/* Usually overwrite previous item */
comment|/* If the maximum is zero then the minimum must also be zero; Perl allows       this case, so we do too - by simply omitting the item altogether. */
if|if
condition|(
name|repeat_max
operator|==
literal|0
condition|)
goto|goto
name|END_REPEAT
goto|;
comment|/*--------------------------------------------------------------------*/
comment|/* This code is obsolete from release 8.00; the restriction was finally       removed: */
comment|/* All real repeats make it impossible to handle partial matching (maybe       one day we will be able to remove this restriction). */
comment|/* if (repeat_max != 1) cd->external_flags |= PCRE_NOPARTIAL; */
comment|/*--------------------------------------------------------------------*/
comment|/* Combine the op_type with the repeat_type */
name|repeat_type
operator|+=
name|op_type
expr_stmt|;
comment|/* A minimum of zero is handled either as the special case * or ?, or as       an UPTO, with the maximum given. */
if|if
condition|(
name|repeat_min
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|repeat_max
operator|==
operator|-
literal|1
condition|)
operator|*
name|code
operator|++
operator|=
name|OP_STAR
operator|+
name|repeat_type
expr_stmt|;
elseif|else
if|if
condition|(
name|repeat_max
operator|==
literal|1
condition|)
operator|*
name|code
operator|++
operator|=
name|OP_QUERY
operator|+
name|repeat_type
expr_stmt|;
else|else
block|{
operator|*
name|code
operator|++
operator|=
name|OP_UPTO
operator|+
name|repeat_type
expr_stmt|;
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|repeat_max
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A repeat minimum of 1 is optimized into some special cases. If the       maximum is unlimited, we use OP_PLUS. Otherwise, the original item is       left in place and, if the maximum is greater than 1, we use OP_UPTO with       one less than the maximum. */
elseif|else
if|if
condition|(
name|repeat_min
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|repeat_max
operator|==
operator|-
literal|1
condition|)
operator|*
name|code
operator|++
operator|=
name|OP_PLUS
operator|+
name|repeat_type
expr_stmt|;
else|else
block|{
name|code
operator|=
name|oldcode
expr_stmt|;
comment|/* leave previous item in place */
if|if
condition|(
name|repeat_max
operator|==
literal|1
condition|)
goto|goto
name|END_REPEAT
goto|;
operator|*
name|code
operator|++
operator|=
name|OP_UPTO
operator|+
name|repeat_type
expr_stmt|;
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|repeat_max
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The case {n,n} is just an EXACT, while the general case {n,m} is       handled as an EXACT followed by an UPTO. */
else|else
block|{
operator|*
name|code
operator|++
operator|=
name|OP_EXACT
operator|+
name|op_type
expr_stmt|;
comment|/* NB EXACT doesn't have repeat_type */
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|repeat_min
argument_list|)
expr_stmt|;
comment|/* If the maximum is unlimited, insert an OP_STAR. Before doing so,         we have to insert the character for the previous code. For a repeated         Unicode property match, there are two extra bytes that define the         required property. In UTF-8 mode, long characters have their length in         c, with the UTF_LENGTH bit as a flag. */
if|if
condition|(
name|repeat_max
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
operator|(
name|c
operator|&
name|UTF_LENGTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|code
argument_list|,
name|utf_chars
argument_list|,
name|IN_UCHARS
argument_list|(
name|c
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
name|c
operator|&
literal|7
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|*
name|code
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|prop_type
operator|>=
literal|0
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|prop_type
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|prop_value
expr_stmt|;
block|}
block|}
operator|*
name|code
operator|++
operator|=
name|OP_STAR
operator|+
name|repeat_type
expr_stmt|;
block|}
comment|/* Else insert an UPTO if the max is greater than the min, again         preceded by the character, for the previously inserted code. If the         UPTO is just for 1 instance, we can use QUERY instead. */
elseif|else
if|if
condition|(
name|repeat_max
operator|!=
name|repeat_min
condition|)
block|{
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
operator|(
name|c
operator|&
name|UTF_LENGTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|code
argument_list|,
name|utf_chars
argument_list|,
name|IN_UCHARS
argument_list|(
name|c
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
name|c
operator|&
literal|7
expr_stmt|;
block|}
else|else
endif|#
directive|endif
operator|*
name|code
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|prop_type
operator|>=
literal|0
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|prop_type
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|prop_value
expr_stmt|;
block|}
name|repeat_max
operator|-=
name|repeat_min
expr_stmt|;
if|if
condition|(
name|repeat_max
operator|==
literal|1
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|OP_QUERY
operator|+
name|repeat_type
expr_stmt|;
block|}
else|else
block|{
operator|*
name|code
operator|++
operator|=
name|OP_UPTO
operator|+
name|repeat_type
expr_stmt|;
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|repeat_max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The character or character type itself comes last in all cases. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
operator|(
name|c
operator|&
name|UTF_LENGTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|code
argument_list|,
name|utf_chars
argument_list|,
name|IN_UCHARS
argument_list|(
name|c
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
name|c
operator|&
literal|7
expr_stmt|;
block|}
else|else
endif|#
directive|endif
operator|*
name|code
operator|++
operator|=
name|c
expr_stmt|;
comment|/* For a repeated Unicode property match, there are two extra bytes that       define the required property. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|prop_type
operator|>=
literal|0
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|prop_type
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|prop_value
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* If previous was a character class or a back reference, we put the repeat     stuff after it, but just skip the item if the repeat was {0,0}. */
elseif|else
if|if
condition|(
operator|*
name|previous
operator|==
name|OP_CLASS
operator|||
operator|*
name|previous
operator|==
name|OP_NCLASS
operator|||
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|||
operator|!
name|defined
name|COMPILE_PCRE8
operator|*
name|previous
operator|==
name|OP_XCLASS
operator|||
endif|#
directive|endif
operator|*
name|previous
operator|==
name|OP_REF
operator|||
operator|*
name|previous
operator|==
name|OP_REFI
condition|)
block|{
if|if
condition|(
name|repeat_max
operator|==
literal|0
condition|)
block|{
name|code
operator|=
name|previous
expr_stmt|;
goto|goto
name|END_REPEAT
goto|;
block|}
comment|/*--------------------------------------------------------------------*/
comment|/* This code is obsolete from release 8.00; the restriction was finally       removed: */
comment|/* All real repeats make it impossible to handle partial matching (maybe       one day we will be able to remove this restriction). */
comment|/* if (repeat_max != 1) cd->external_flags |= PCRE_NOPARTIAL; */
comment|/*--------------------------------------------------------------------*/
if|if
condition|(
name|repeat_min
operator|==
literal|0
operator|&&
name|repeat_max
operator|==
operator|-
literal|1
condition|)
operator|*
name|code
operator|++
operator|=
name|OP_CRSTAR
operator|+
name|repeat_type
expr_stmt|;
elseif|else
if|if
condition|(
name|repeat_min
operator|==
literal|1
operator|&&
name|repeat_max
operator|==
operator|-
literal|1
condition|)
operator|*
name|code
operator|++
operator|=
name|OP_CRPLUS
operator|+
name|repeat_type
expr_stmt|;
elseif|else
if|if
condition|(
name|repeat_min
operator|==
literal|0
operator|&&
name|repeat_max
operator|==
literal|1
condition|)
operator|*
name|code
operator|++
operator|=
name|OP_CRQUERY
operator|+
name|repeat_type
expr_stmt|;
else|else
block|{
operator|*
name|code
operator|++
operator|=
name|OP_CRRANGE
operator|+
name|repeat_type
expr_stmt|;
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|repeat_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat_max
operator|==
operator|-
literal|1
condition|)
name|repeat_max
operator|=
literal|0
expr_stmt|;
comment|/* 2-byte encoding for max */
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|repeat_max
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If previous was a bracket group, we may have to replicate it in certain     cases. Note that at this point we can encounter only the "basic" bracket     opcodes such as BRA and CBRA, as this is the place where they get converted     into the more special varieties such as BRAPOS and SBRA. A test for>=     OP_ASSERT and<= OP_COND includes ASSERT, ASSERT_NOT, ASSERTBACK,     ASSERTBACK_NOT, ONCE, BRA, CBRA, and COND. Originally, PCRE did not allow     repetition of assertions, but now it does, for Perl compatibility. */
elseif|else
if|if
condition|(
operator|*
name|previous
operator|>=
name|OP_ASSERT
operator|&&
operator|*
name|previous
operator|<=
name|OP_COND
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|previous
argument_list|)
decl_stmt|;
name|pcre_uchar
modifier|*
name|bralink
init|=
name|NULL
decl_stmt|;
name|pcre_uchar
modifier|*
name|brazeroptr
init|=
name|NULL
decl_stmt|;
comment|/* Repeating a DEFINE group is pointless, but Perl allows the syntax, so       we just ignore the repeat. */
if|if
condition|(
operator|*
name|previous
operator|==
name|OP_COND
operator|&&
name|previous
index|[
name|LINK_SIZE
operator|+
literal|1
index|]
operator|==
name|OP_DEF
condition|)
goto|goto
name|END_REPEAT
goto|;
comment|/* There is no sense in actually repeating assertions. The only potential       use of repetition is in cases when the assertion is optional. Therefore,       if the minimum is greater than zero, just ignore the repeat. If the       maximum is not not zero or one, set it to 1. */
if|if
condition|(
operator|*
name|previous
operator|<
name|OP_ONCE
condition|)
comment|/* Assertion */
block|{
if|if
condition|(
name|repeat_min
operator|>
literal|0
condition|)
goto|goto
name|END_REPEAT
goto|;
if|if
condition|(
name|repeat_max
operator|<
literal|0
operator|||
name|repeat_max
operator|>
literal|1
condition|)
name|repeat_max
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The case of a zero minimum is special because of the need to stick       OP_BRAZERO in front of it, and because the group appears once in the       data, whereas in other cases it appears the minimum number of times. For       this reason, it is simplest to treat this case separately, as otherwise       the code gets far too messy. There are several special subcases when the       minimum is zero. */
if|if
condition|(
name|repeat_min
operator|==
literal|0
condition|)
block|{
comment|/* If the maximum is also zero, we used to just omit the group from the         output altogether, like this:          ** if (repeat_max == 0)         **   {         **   code = previous;         **   goto END_REPEAT;         **   }          However, that fails when a group or a subgroup within it is referenced         as a subroutine from elsewhere in the pattern, so now we stick in         OP_SKIPZERO in front of it so that it is skipped on execution. As we         don't have a list of which groups are referenced, we cannot do this         selectively.          If the maximum is 1 or unlimited, we just have to stick in the BRAZERO         and do no more at this point. However, we do need to adjust any         OP_RECURSE calls inside the group that refer to the group itself or any         internal or forward referenced group, because the offset is from the         start of the whole regex. Temporarily terminate the pattern while doing         this. */
if|if
condition|(
name|repeat_max
operator|<=
literal|1
condition|)
comment|/* Covers 0, 1, and unlimited */
block|{
operator|*
name|code
operator|=
name|OP_END
expr_stmt|;
name|adjust_recurse
argument_list|(
name|previous
argument_list|,
literal|1
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|,
name|save_hwm
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|previous
operator|+
literal|1
argument_list|,
name|previous
argument_list|,
name|IN_UCHARS
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|++
expr_stmt|;
if|if
condition|(
name|repeat_max
operator|==
literal|0
condition|)
block|{
operator|*
name|previous
operator|++
operator|=
name|OP_SKIPZERO
expr_stmt|;
goto|goto
name|END_REPEAT
goto|;
block|}
name|brazeroptr
operator|=
name|previous
expr_stmt|;
comment|/* Save for possessive optimizing */
operator|*
name|previous
operator|++
operator|=
name|OP_BRAZERO
operator|+
name|repeat_type
expr_stmt|;
block|}
comment|/* If the maximum is greater than 1 and limited, we have to replicate         in a nested fashion, sticking OP_BRAZERO before each set of brackets.         The first one has to be handled carefully because it's the original         copy, which has to be moved up. The remainder can be handled by code         that is common with the non-zero minimum case below. We have to         adjust the value or repeat_max, since one less copy is required. Once         again, we may have to adjust any OP_RECURSE calls inside the group. */
else|else
block|{
name|int
name|offset
decl_stmt|;
operator|*
name|code
operator|=
name|OP_END
expr_stmt|;
name|adjust_recurse
argument_list|(
name|previous
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|,
name|save_hwm
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|previous
operator|+
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|previous
argument_list|,
name|IN_UCHARS
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|2
operator|+
name|LINK_SIZE
expr_stmt|;
operator|*
name|previous
operator|++
operator|=
name|OP_BRAZERO
operator|+
name|repeat_type
expr_stmt|;
operator|*
name|previous
operator|++
operator|=
name|OP_BRA
expr_stmt|;
comment|/* We chain together the bracket offset fields that have to be           filled in later when the ends of the brackets are reached. */
name|offset
operator|=
operator|(
name|bralink
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
call|(
name|int
call|)
argument_list|(
name|previous
operator|-
name|bralink
argument_list|)
expr_stmt|;
name|bralink
operator|=
name|previous
expr_stmt|;
name|PUTINC
argument_list|(
name|previous
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|repeat_max
operator|--
expr_stmt|;
block|}
comment|/* If the minimum is greater than zero, replicate the group as many       times as necessary, and adjust the maximum to the number of subsequent       copies that we need. If we set a first char from the group, and didn't       set a required char, copy the latter from the former. If there are any       forward reference subroutine calls in the group, there will be entries on       the workspace list; replicate these with an appropriate increment. */
else|else
block|{
if|if
condition|(
name|repeat_min
operator|>
literal|1
condition|)
block|{
comment|/* In the pre-compile phase, we don't actually do the replication. We           just adjust the length as if we had. Do some paranoid checks for           potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit           integer type when available, otherwise double. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
name|int
name|delta
init|=
operator|(
name|repeat_min
operator|-
literal|1
operator|)
operator|*
name|length_prevgroup
decl_stmt|;
if|if
condition|(
call|(
name|INT64_OR_DOUBLE
call|)
argument_list|(
name|repeat_min
operator|-
literal|1
argument_list|)
operator|*
operator|(
name|INT64_OR_DOUBLE
operator|)
name|length_prevgroup
operator|>
operator|(
name|INT64_OR_DOUBLE
operator|)
name|INT_MAX
operator|||
name|OFLOW_MAX
operator|-
operator|*
name|lengthptr
operator|<
name|delta
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR20
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
operator|*
name|lengthptr
operator|+=
name|delta
expr_stmt|;
block|}
comment|/* This is compiling for real. If there is a set first byte for           the group, and we have not yet set a "required byte", set it. Make           sure there is enough workspace for copying forward references before           doing the copy. */
else|else
block|{
if|if
condition|(
name|groupsetfirstchar
operator|&&
name|reqcharflags
operator|<
literal|0
condition|)
block|{
name|reqchar
operator|=
name|firstchar
expr_stmt|;
name|reqcharflags
operator|=
name|firstcharflags
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|repeat_min
condition|;
name|i
operator|++
control|)
block|{
name|pcre_uchar
modifier|*
name|hc
decl_stmt|;
name|pcre_uchar
modifier|*
name|this_hwm
init|=
name|cd
operator|->
name|hwm
decl_stmt|;
name|memcpy
argument_list|(
name|code
argument_list|,
name|previous
argument_list|,
name|IN_UCHARS
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cd
operator|->
name|hwm
operator|>
name|cd
operator|->
name|start_workspace
operator|+
name|cd
operator|->
name|workspace_size
operator|-
name|WORK_SIZE_SAFETY_MARGIN
operator|-
operator|(
name|this_hwm
operator|-
name|save_hwm
operator|)
condition|)
block|{
name|int
name|save_offset
init|=
name|save_hwm
operator|-
name|cd
operator|->
name|start_workspace
decl_stmt|;
name|int
name|this_offset
init|=
name|this_hwm
operator|-
name|cd
operator|->
name|start_workspace
decl_stmt|;
operator|*
name|errorcodeptr
operator|=
name|expand_workspace
argument_list|(
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errorcodeptr
operator|!=
literal|0
condition|)
goto|goto
name|FAILED
goto|;
name|save_hwm
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|cd
operator|->
name|start_workspace
operator|+
name|save_offset
expr_stmt|;
name|this_hwm
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|cd
operator|->
name|start_workspace
operator|+
name|this_offset
expr_stmt|;
block|}
for|for
control|(
name|hc
operator|=
name|save_hwm
init|;
name|hc
operator|<
name|this_hwm
condition|;
name|hc
operator|+=
name|LINK_SIZE
control|)
block|{
name|PUT
argument_list|(
name|cd
operator|->
name|hwm
argument_list|,
literal|0
argument_list|,
name|GET
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|cd
operator|->
name|hwm
operator|+=
name|LINK_SIZE
expr_stmt|;
block|}
name|save_hwm
operator|=
name|this_hwm
expr_stmt|;
name|code
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|repeat_max
operator|>
literal|0
condition|)
name|repeat_max
operator|-=
name|repeat_min
expr_stmt|;
block|}
comment|/* This code is common to both the zero and non-zero minimum cases. If       the maximum is limited, it replicates the group in a nested fashion,       remembering the bracket starts on a stack. In the case of a zero minimum,       the first one was set up above. In all cases the repeat_max now specifies       the number of additional copies needed. Again, we must remember to       replicate entries on the forward reference list. */
if|if
condition|(
name|repeat_max
operator|>=
literal|0
condition|)
block|{
comment|/* In the pre-compile phase, we don't actually do the replication. We         just adjust the length as if we had. For each repetition we must add 1         to the length for BRAZERO and for all but the last repetition we must         add 2 + 2*LINKSIZE to allow for the nesting that occurs. Do some         paranoid checks to avoid integer overflow. The INT64_OR_DOUBLE type is         a 64-bit integer type when available, otherwise double. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
operator|&&
name|repeat_max
operator|>
literal|0
condition|)
block|{
name|int
name|delta
init|=
name|repeat_max
operator|*
operator|(
name|length_prevgroup
operator|+
literal|1
operator|+
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
operator|)
operator|-
literal|2
operator|-
literal|2
operator|*
name|LINK_SIZE
decl_stmt|;
comment|/* Last one doesn't nest */
if|if
condition|(
operator|(
name|INT64_OR_DOUBLE
operator|)
name|repeat_max
operator|*
call|(
name|INT64_OR_DOUBLE
call|)
argument_list|(
name|length_prevgroup
operator|+
literal|1
operator|+
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
argument_list|)
operator|>
operator|(
name|INT64_OR_DOUBLE
operator|)
name|INT_MAX
operator|||
name|OFLOW_MAX
operator|-
operator|*
name|lengthptr
operator|<
name|delta
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR20
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
operator|*
name|lengthptr
operator|+=
name|delta
expr_stmt|;
block|}
comment|/* This is compiling for real */
else|else
for|for
control|(
name|i
operator|=
name|repeat_max
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|pcre_uchar
modifier|*
name|hc
decl_stmt|;
name|pcre_uchar
modifier|*
name|this_hwm
init|=
name|cd
operator|->
name|hwm
decl_stmt|;
operator|*
name|code
operator|++
operator|=
name|OP_BRAZERO
operator|+
name|repeat_type
expr_stmt|;
comment|/* All but the final copy start a new nesting, maintaining the           chain of brackets outstanding. */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
decl_stmt|;
operator|*
name|code
operator|++
operator|=
name|OP_BRA
expr_stmt|;
name|offset
operator|=
operator|(
name|bralink
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|bralink
argument_list|)
expr_stmt|;
name|bralink
operator|=
name|code
expr_stmt|;
name|PUTINC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|code
argument_list|,
name|previous
argument_list|,
name|IN_UCHARS
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure there is enough workspace for forward references before           copying them. */
while|while
condition|(
name|cd
operator|->
name|hwm
operator|>
name|cd
operator|->
name|start_workspace
operator|+
name|cd
operator|->
name|workspace_size
operator|-
name|WORK_SIZE_SAFETY_MARGIN
operator|-
operator|(
name|this_hwm
operator|-
name|save_hwm
operator|)
condition|)
block|{
name|int
name|save_offset
init|=
name|save_hwm
operator|-
name|cd
operator|->
name|start_workspace
decl_stmt|;
name|int
name|this_offset
init|=
name|this_hwm
operator|-
name|cd
operator|->
name|start_workspace
decl_stmt|;
operator|*
name|errorcodeptr
operator|=
name|expand_workspace
argument_list|(
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errorcodeptr
operator|!=
literal|0
condition|)
goto|goto
name|FAILED
goto|;
name|save_hwm
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|cd
operator|->
name|start_workspace
operator|+
name|save_offset
expr_stmt|;
name|this_hwm
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|cd
operator|->
name|start_workspace
operator|+
name|this_offset
expr_stmt|;
block|}
for|for
control|(
name|hc
operator|=
name|save_hwm
init|;
name|hc
operator|<
name|this_hwm
condition|;
name|hc
operator|+=
name|LINK_SIZE
control|)
block|{
name|PUT
argument_list|(
name|cd
operator|->
name|hwm
argument_list|,
literal|0
argument_list|,
name|GET
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|)
operator|+
name|len
operator|+
operator|(
operator|(
name|i
operator|!=
literal|0
operator|)
condition|?
literal|2
operator|+
name|LINK_SIZE
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|hwm
operator|+=
name|LINK_SIZE
expr_stmt|;
block|}
name|save_hwm
operator|=
name|this_hwm
expr_stmt|;
name|code
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Now chain through the pending brackets, and fill in their length         fields (which are holding the chain links pro tem). */
while|while
condition|(
name|bralink
operator|!=
name|NULL
condition|)
block|{
name|int
name|oldlinkoffset
decl_stmt|;
name|int
name|offset
init|=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|bralink
operator|+
literal|1
argument_list|)
decl_stmt|;
name|pcre_uchar
modifier|*
name|bra
init|=
name|code
operator|-
name|offset
decl_stmt|;
name|oldlinkoffset
operator|=
name|GET
argument_list|(
name|bra
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bralink
operator|=
operator|(
name|oldlinkoffset
operator|==
literal|0
operator|)
condition|?
name|NULL
else|:
name|bralink
operator|-
name|oldlinkoffset
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|OP_KET
expr_stmt|;
name|PUTINC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
name|bra
argument_list|,
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the maximum is unlimited, set a repeater in the final copy. For       ONCE brackets, that's all we need to do. However, possessively repeated       ONCE brackets can be converted into non-capturing brackets, as the       behaviour of (?:xx)++ is the same as (?>xx)++ and this saves having to       deal with possessive ONCEs specially.        Otherwise, when we are doing the actual compile phase, check to see       whether this group is one that could match an empty string. If so,       convert the initial operator to the S form (e.g. OP_BRA -> OP_SBRA) so       that runtime checking can be done. [This check is also applied to ONCE       groups at runtime, but in a different way.]        Then, if the quantifier was possessive and the bracket is not a       conditional, we convert the BRA code to the POS form, and the KET code to       KETRPOS. (It turns out to be convenient at runtime to detect this kind of       subpattern at both the start and at the end.) The use of special opcodes       makes it possible to reduce greatly the stack usage in pcre_exec(). If       the group is preceded by OP_BRAZERO, convert this to OP_BRAPOSZERO.        Then, if the minimum number of matches is 1 or 0, cancel the possessive       flag so that the default action below, of wrapping everything inside       atomic brackets, does not happen. When the minimum is greater than 1,       there will be earlier copies of the group, and so we still have to wrap       the whole thing. */
else|else
block|{
name|pcre_uchar
modifier|*
name|ketcode
init|=
name|code
operator|-
literal|1
operator|-
name|LINK_SIZE
decl_stmt|;
name|pcre_uchar
modifier|*
name|bracode
init|=
name|ketcode
operator|-
name|GET
argument_list|(
name|ketcode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Convert possessive ONCE brackets to non-capturing */
if|if
condition|(
operator|(
operator|*
name|bracode
operator|==
name|OP_ONCE
operator|||
operator|*
name|bracode
operator|==
name|OP_ONCE_NC
operator|)
operator|&&
name|possessive_quantifier
condition|)
operator|*
name|bracode
operator|=
name|OP_BRA
expr_stmt|;
comment|/* For non-possessive ONCE brackets, all we need to do is to         set the KET. */
if|if
condition|(
operator|*
name|bracode
operator|==
name|OP_ONCE
operator|||
operator|*
name|bracode
operator|==
name|OP_ONCE_NC
condition|)
operator|*
name|ketcode
operator|=
name|OP_KETRMAX
operator|+
name|repeat_type
expr_stmt|;
comment|/* Handle non-ONCE brackets and possessive ONCEs (which have been         converted to non-capturing above). */
else|else
block|{
comment|/* In the compile phase, check for empty string matching. */
if|if
condition|(
name|lengthptr
operator|==
name|NULL
condition|)
block|{
name|pcre_uchar
modifier|*
name|scode
init|=
name|bracode
decl_stmt|;
do|do
block|{
if|if
condition|(
name|could_be_empty_branch
argument_list|(
name|scode
argument_list|,
name|ketcode
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|)
condition|)
block|{
operator|*
name|bracode
operator|+=
name|OP_SBRA
operator|-
name|OP_BRA
expr_stmt|;
break|break;
block|}
name|scode
operator|+=
name|GET
argument_list|(
name|scode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|scode
operator|==
name|OP_ALT
condition|)
do|;
block|}
comment|/* Handle possessive quantifiers. */
if|if
condition|(
name|possessive_quantifier
condition|)
block|{
comment|/* For COND brackets, we wrap the whole thing in a possessively             repeated non-capturing bracket, because we have not invented POS             versions of the COND opcodes. Because we are moving code along, we             must ensure that any pending recursive references are updated. */
if|if
condition|(
operator|*
name|bracode
operator|==
name|OP_COND
operator|||
operator|*
name|bracode
operator|==
name|OP_SCOND
condition|)
block|{
name|int
name|nlen
init|=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|bracode
argument_list|)
decl_stmt|;
operator|*
name|code
operator|=
name|OP_END
expr_stmt|;
name|adjust_recurse
argument_list|(
name|bracode
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|,
name|save_hwm
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|bracode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|bracode
argument_list|,
name|IN_UCHARS
argument_list|(
name|nlen
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|nlen
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
operator|*
name|bracode
operator|=
name|OP_BRAPOS
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|OP_KETRPOS
expr_stmt|;
name|PUTINC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
name|bracode
argument_list|,
literal|1
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
block|}
comment|/* For non-COND brackets, we modify the BRA code and use KETRPOS. */
else|else
block|{
operator|*
name|bracode
operator|+=
literal|1
expr_stmt|;
comment|/* Switch to xxxPOS opcodes */
operator|*
name|ketcode
operator|=
name|OP_KETRPOS
expr_stmt|;
block|}
comment|/* If the minimum is zero, mark it as possessive, then unset the             possessive flag when the minimum is 0 or 1. */
if|if
condition|(
name|brazeroptr
operator|!=
name|NULL
condition|)
operator|*
name|brazeroptr
operator|=
name|OP_BRAPOSZERO
expr_stmt|;
if|if
condition|(
name|repeat_min
operator|<
literal|2
condition|)
name|possessive_quantifier
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Non-possessive quantifier */
else|else
operator|*
name|ketcode
operator|=
name|OP_KETRMAX
operator|+
name|repeat_type
expr_stmt|;
block|}
block|}
block|}
comment|/* If previous is OP_FAIL, it was generated by an empty class [] in     JavaScript mode. The other ways in which OP_FAIL can be generated, that is     by (*FAIL) or (?!) set previous to NULL, which gives a "nothing to repeat"     error above. We can just ignore the repeat in JS case. */
elseif|else
if|if
condition|(
operator|*
name|previous
operator|==
name|OP_FAIL
condition|)
goto|goto
name|END_REPEAT
goto|;
comment|/* Else there's some kind of shambles */
else|else
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR11
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* If the character following a repeat is '+', or if certain optimization     tests above succeeded, possessive_quantifier is TRUE. For some opcodes,     there are special alternative opcodes for this case. For anything else, we     wrap the entire repeated item inside OP_ONCE brackets. Logically, the '+'     notation is just syntactic sugar, taken from Sun's Java package, but the     special opcodes can optimize it.      Some (but not all) possessively repeated subpatterns have already been     completely handled in the code just above. For them, possessive_quantifier     is always FALSE at this stage.      Note that the repeated item starts at tempcode, not at previous, which     might be the first part of a string whose (former) last char we repeated.      Possessifying an 'exact' quantifier has no effect, so we can ignore it. But     an 'upto' may follow. We skip over an 'exact' item, and then test the     length of what remains before proceeding. */
if|if
condition|(
name|possessive_quantifier
condition|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|tempcode
operator|==
name|OP_TYPEEXACT
condition|)
name|tempcode
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|tempcode
index|]
operator|+
operator|(
operator|(
name|tempcode
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_PROP
operator|||
name|tempcode
index|[
literal|1
operator|+
name|IMM2_SIZE
index|]
operator|==
name|OP_NOTPROP
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tempcode
operator|==
name|OP_EXACT
operator|||
operator|*
name|tempcode
operator|==
name|OP_NOTEXACT
condition|)
block|{
name|tempcode
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|tempcode
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|tempcode
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|tempcode
operator|+=
name|GET_EXTRALEN
argument_list|(
name|tempcode
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|tempcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
switch|switch
condition|(
operator|*
name|tempcode
condition|)
block|{
case|case
name|OP_STAR
case|:
operator|*
name|tempcode
operator|=
name|OP_POSSTAR
expr_stmt|;
break|break;
case|case
name|OP_PLUS
case|:
operator|*
name|tempcode
operator|=
name|OP_POSPLUS
expr_stmt|;
break|break;
case|case
name|OP_QUERY
case|:
operator|*
name|tempcode
operator|=
name|OP_POSQUERY
expr_stmt|;
break|break;
case|case
name|OP_UPTO
case|:
operator|*
name|tempcode
operator|=
name|OP_POSUPTO
expr_stmt|;
break|break;
case|case
name|OP_STARI
case|:
operator|*
name|tempcode
operator|=
name|OP_POSSTARI
expr_stmt|;
break|break;
case|case
name|OP_PLUSI
case|:
operator|*
name|tempcode
operator|=
name|OP_POSPLUSI
expr_stmt|;
break|break;
case|case
name|OP_QUERYI
case|:
operator|*
name|tempcode
operator|=
name|OP_POSQUERYI
expr_stmt|;
break|break;
case|case
name|OP_UPTOI
case|:
operator|*
name|tempcode
operator|=
name|OP_POSUPTOI
expr_stmt|;
break|break;
case|case
name|OP_NOTSTAR
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSSTAR
expr_stmt|;
break|break;
case|case
name|OP_NOTPLUS
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSPLUS
expr_stmt|;
break|break;
case|case
name|OP_NOTQUERY
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSQUERY
expr_stmt|;
break|break;
case|case
name|OP_NOTUPTO
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSUPTO
expr_stmt|;
break|break;
case|case
name|OP_NOTSTARI
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSSTARI
expr_stmt|;
break|break;
case|case
name|OP_NOTPLUSI
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSPLUSI
expr_stmt|;
break|break;
case|case
name|OP_NOTQUERYI
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSQUERYI
expr_stmt|;
break|break;
case|case
name|OP_NOTUPTOI
case|:
operator|*
name|tempcode
operator|=
name|OP_NOTPOSUPTOI
expr_stmt|;
break|break;
case|case
name|OP_TYPESTAR
case|:
operator|*
name|tempcode
operator|=
name|OP_TYPEPOSSTAR
expr_stmt|;
break|break;
case|case
name|OP_TYPEPLUS
case|:
operator|*
name|tempcode
operator|=
name|OP_TYPEPOSPLUS
expr_stmt|;
break|break;
case|case
name|OP_TYPEQUERY
case|:
operator|*
name|tempcode
operator|=
name|OP_TYPEPOSQUERY
expr_stmt|;
break|break;
case|case
name|OP_TYPEUPTO
case|:
operator|*
name|tempcode
operator|=
name|OP_TYPEPOSUPTO
expr_stmt|;
break|break;
comment|/* Because we are moving code along, we must ensure that any         pending recursive references are updated. */
default|default:
operator|*
name|code
operator|=
name|OP_END
expr_stmt|;
name|adjust_recurse
argument_list|(
name|tempcode
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|,
name|save_hwm
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|tempcode
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|tempcode
argument_list|,
name|IN_UCHARS
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|len
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|tempcode
index|[
literal|0
index|]
operator|=
name|OP_ONCE
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|OP_KET
expr_stmt|;
name|PUTINC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
name|tempcode
argument_list|,
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* In all case we no longer have a previous item. We also set the     "follows varying string" flag for subsequently encountered reqchars if     it isn't already set and we have just passed a varying length item. */
name|END_REPEAT
label|:
name|previous
operator|=
name|NULL
expr_stmt|;
name|cd
operator|->
name|req_varyopt
operator||=
name|reqvary
expr_stmt|;
break|break;
comment|/* ===================================================================*/
comment|/* Start of nested parenthesized sub-expression, or comment or lookahead or     lookbehind or option setting or condition or all the other extended     parenthesis forms.  */
case|case
name|CHAR_LEFT_PARENTHESIS
case|:
name|newoptions
operator|=
name|options
expr_stmt|;
name|skipbytes
operator|=
literal|0
expr_stmt|;
name|bravalue
operator|=
name|OP_CBRA
expr_stmt|;
name|save_hwm
operator|=
name|cd
operator|->
name|hwm
expr_stmt|;
name|reset_bracount
operator|=
name|FALSE
expr_stmt|;
comment|/* First deal with various "verbs" that can be introduced by '*'. */
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
name|CHAR_ASTERISK
operator|&&
operator|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|':'
operator|||
operator|(
name|MAX_255
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|cd
operator|->
name|ctypes
index|[
name|ptr
index|[
literal|1
index|]
index|]
operator|&
name|ctype_letter
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|namelen
decl_stmt|;
name|int
name|arglen
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|vn
init|=
name|verbnames
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|name
init|=
name|ptr
operator|+
literal|1
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|arg
init|=
name|NULL
decl_stmt|;
name|previous
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|ptr
index|]
operator|&
name|ctype_letter
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|++
expr_stmt|;
name|namelen
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|name
argument_list|)
expr_stmt|;
comment|/* It appears that Perl allows any characters whatsoever, other than       a closing parenthesis, to appear in arguments, so we no longer insist on       letters, digits, and underscores. */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_COLON
condition|)
block|{
name|arg
operator|=
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|ptr
operator|!=
name|CHAR_RIGHT_PARENTHESIS
condition|)
name|ptr
operator|++
expr_stmt|;
name|arglen
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|arglen
operator|>
name|MAX_MARK
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR75
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_RIGHT_PARENTHESIS
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR60
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Scan the table of verb names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|verbcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|namelen
operator|==
name|verbs
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|STRNCMP_UC_C8
argument_list|(
name|name
argument_list|,
name|vn
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|setverb
decl_stmt|;
comment|/* Check for open captures before ACCEPT and convert it to           ASSERT_ACCEPT if in an assertion. */
if|if
condition|(
name|verbs
index|[
name|i
index|]
operator|.
name|op
operator|==
name|OP_ACCEPT
condition|)
block|{
name|open_capitem
modifier|*
name|oc
decl_stmt|;
if|if
condition|(
name|arglen
operator|!=
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR59
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|cd
operator|->
name|had_accept
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|oc
operator|=
name|cd
operator|->
name|open_caps
init|;
name|oc
operator|!=
name|NULL
condition|;
name|oc
operator|=
name|oc
operator|->
name|next
control|)
block|{
operator|*
name|code
operator|++
operator|=
name|OP_CLOSE
expr_stmt|;
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|oc
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
name|setverb
operator|=
operator|*
name|code
operator|++
operator|=
operator|(
name|cd
operator|->
name|assert_depth
operator|>
literal|0
operator|)
condition|?
name|OP_ASSERT_ACCEPT
else|:
name|OP_ACCEPT
expr_stmt|;
comment|/* Do not set firstchar after *ACCEPT */
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
block|}
comment|/* Handle other cases with/without an argument */
elseif|else
if|if
condition|(
name|arglen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbs
index|[
name|i
index|]
operator|.
name|op
operator|<
literal|0
condition|)
comment|/* Argument is mandatory */
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR66
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|setverb
operator|=
operator|*
name|code
operator|++
operator|=
name|verbs
index|[
name|i
index|]
operator|.
name|op
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbs
index|[
name|i
index|]
operator|.
name|op_arg
operator|<
literal|0
condition|)
comment|/* Argument is forbidden */
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR59
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|setverb
operator|=
operator|*
name|code
operator|++
operator|=
name|verbs
index|[
name|i
index|]
operator|.
name|op_arg
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|arglen
expr_stmt|;
name|memcpy
argument_list|(
name|code
argument_list|,
name|arg
argument_list|,
name|IN_UCHARS
argument_list|(
name|arglen
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
name|arglen
expr_stmt|;
operator|*
name|code
operator|++
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|setverb
condition|)
block|{
case|case
name|OP_THEN
case|:
case|case
name|OP_THEN_ARG
case|:
name|cd
operator|->
name|external_flags
operator||=
name|PCRE_HASTHEN
expr_stmt|;
break|break;
case|case
name|OP_PRUNE
case|:
case|case
name|OP_PRUNE_ARG
case|:
case|case
name|OP_SKIP
case|:
case|case
name|OP_SKIP_ARG
case|:
name|cd
operator|->
name|had_pruneorskip
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
comment|/* Found verb, exit loop */
block|}
name|vn
operator|+=
name|verbs
index|[
name|i
index|]
operator|.
name|len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|verbcount
condition|)
continue|continue;
comment|/* Successfully handled a verb */
operator|*
name|errorcodeptr
operator|=
name|ERR60
expr_stmt|;
comment|/* Verb not recognized */
goto|goto
name|FAILED
goto|;
block|}
comment|/* Deal with the extended parentheses; all are introduced by '?', and the     appearance of any of them means that this is not a capturing group. */
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_QUESTION_MARK
condition|)
block|{
name|int
name|i
decl_stmt|,
name|set
decl_stmt|,
name|unset
decl_stmt|,
name|namelen
decl_stmt|;
name|int
modifier|*
name|optset
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|name
decl_stmt|;
name|pcre_uchar
modifier|*
name|slot
decl_stmt|;
switch|switch
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
condition|)
block|{
case|case
name|CHAR_NUMBER_SIGN
case|:
comment|/* Comment; skip to ket */
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|ptr
operator|!=
name|CHAR_RIGHT_PARENTHESIS
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_NULL
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR18
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
continue|continue;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_VERTICAL_LINE
case|:
comment|/* Reset capture count for each branch */
name|reset_bracount
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through */
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_COLON
case|:
comment|/* Non-capturing bracket */
name|bravalue
operator|=
name|OP_BRA
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
break|break;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_LEFT_PARENTHESIS
case|:
name|bravalue
operator|=
name|OP_COND
expr_stmt|;
comment|/* Conditional group */
comment|/* A condition can be an assertion, a number (referring to a numbered         group), a name (referring to a named group), or 'R', referring to         recursion. R<digits> and R&name are also permitted for recursion tests.          There are several syntaxes for testing a named group: (?(name)) is used         by Python; Perl 5.10 onwards uses (?(<name>) or (?('name')).          There are two unfortunate ambiguities, caused by history. (a) 'R' can         be the recursive thing or the name 'R' (and similarly for 'R' followed         by digits), and (b) a number could be a name that consists of digits.         In both cases, we look for a name first; if not found, we try the other         cases. */
comment|/* For conditions that are assertions, check the syntax, and then exit         the switch. This will take control down to where bracketed groups,         including assertions, are processed. */
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_QUESTION_MARK
operator|&&
operator|(
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_EQUALS_SIGN
operator|||
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_EXCLAMATION_MARK
operator|||
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_LESS_THAN_SIGN
operator|)
condition|)
break|break;
comment|/* Most other conditions use OP_CREF (a couple change to OP_RREF         below), and all need to skip 1+IMM2_SIZE bytes at the start of the group. */
name|code
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|=
name|OP_CREF
expr_stmt|;
name|skipbytes
operator|=
literal|1
operator|+
name|IMM2_SIZE
expr_stmt|;
name|refsign
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Check for a test for recursion in a named group. */
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_R
operator|&&
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_AMPERSAND
condition|)
block|{
name|terminator
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
name|code
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|=
name|OP_RREF
expr_stmt|;
comment|/* Change the type of test */
block|}
comment|/* Check for a test for a named group's having been set, using the Perl         syntax (?(<name>) or (?('name') */
elseif|else
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_LESS_THAN_SIGN
condition|)
block|{
name|terminator
operator|=
name|CHAR_GREATER_THAN_SIGN
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_APOSTROPHE
condition|)
block|{
name|terminator
operator|=
name|CHAR_APOSTROPHE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|terminator
operator|=
name|CHAR_NULL
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_MINUS
operator|||
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_PLUS
condition|)
name|refsign
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
block|}
comment|/* We now expect to read a name; any thing else is an error */
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|cd
operator|->
name|ctypes
index|[
name|ptr
index|[
literal|1
index|]
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|1
expr_stmt|;
comment|/* To get the right offset */
operator|*
name|errorcodeptr
operator|=
name|ERR28
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Read the name, but also get it as a number if it's all digits */
name|recno
operator|=
literal|0
expr_stmt|;
name|name
operator|=
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|ptr
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|recno
operator|>=
literal|0
condition|)
name|recno
operator|=
operator|(
name|IS_DIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
operator|)
condition|?
name|recno
operator|*
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|ptr
operator|-
name|CHAR_0
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|namelen
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|terminator
operator|>
literal|0
operator|&&
operator|*
name|ptr
operator|++
operator|!=
operator|(
name|pcre_uchar
operator|)
name|terminator
operator|)
operator|||
operator|*
name|ptr
operator|++
operator|!=
name|CHAR_RIGHT_PARENTHESIS
condition|)
block|{
name|ptr
operator|--
expr_stmt|;
comment|/* Error offset */
operator|*
name|errorcodeptr
operator|=
name|ERR26
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Do no further checking in the pre-compile phase. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
break|break;
comment|/* In the real compile we do the work of looking for the actual         reference. If the string started with "+" or "-" we require the rest to         be digits, in which case recno will be set. */
if|if
condition|(
name|refsign
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|recno
operator|<=
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR58
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|recno
operator|=
operator|(
name|refsign
operator|==
name|CHAR_MINUS
operator|)
condition|?
name|cd
operator|->
name|bracount
operator|-
name|recno
operator|+
literal|1
else|:
name|recno
operator|+
name|cd
operator|->
name|bracount
expr_stmt|;
if|if
condition|(
name|recno
operator|<=
literal|0
operator|||
name|recno
operator|>
name|cd
operator|->
name|final_bracount
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR15
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|PUT2
argument_list|(
name|code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|recno
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Otherwise (did not start with "+" or "-"), start by looking for the         name. If we find a name, add one to the opcode to change OP_CREF or         OP_RREF into OP_NCREF or OP_NRREF. These behave exactly the same,         except they record that the reference was originally to a name. The         information is used to check duplicate names. */
name|slot
operator|=
name|cd
operator|->
name|name_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cd
operator|->
name|names_found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STRNCMP_UC_UC
argument_list|(
name|name
argument_list|,
name|slot
operator|+
name|IMM2_SIZE
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|slot
operator|+=
name|cd
operator|->
name|name_entry_size
expr_stmt|;
block|}
comment|/* Found a previous named subpattern */
if|if
condition|(
name|i
operator|<
name|cd
operator|->
name|names_found
condition|)
block|{
name|recno
operator|=
name|GET2
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUT2
argument_list|(
name|code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|recno
argument_list|)
expr_stmt|;
name|code
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|++
expr_stmt|;
block|}
comment|/* Search the pattern for a forward reference */
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|find_parens
argument_list|(
name|cd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
operator|(
name|options
operator|&
name|PCRE_EXTENDED
operator|)
operator|!=
literal|0
argument_list|,
name|utf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|PUT2
argument_list|(
name|code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|code
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|++
expr_stmt|;
block|}
comment|/* If terminator == CHAR_NULL it means that the name followed directly         after the opening parenthesis [e.g. (?(abc)...] and in this case there         are some further alternatives to try. For the cases where terminator !=         0 [things like (?(<name>... or (?('name')... or (?(R&name)... ] we have         now checked all the possibilities, so give an error. */
elseif|else
if|if
condition|(
name|terminator
operator|!=
name|CHAR_NULL
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR15
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Check for (?(R) for recursion. Allow digits after R to specify a         specific group number. */
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
name|CHAR_R
condition|)
block|{
name|recno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|namelen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR15
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|recno
operator|=
name|recno
operator|*
literal|10
operator|+
name|name
index|[
name|i
index|]
operator|-
name|CHAR_0
expr_stmt|;
block|}
if|if
condition|(
name|recno
operator|==
literal|0
condition|)
name|recno
operator|=
name|RREF_ANY
expr_stmt|;
name|code
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|=
name|OP_RREF
expr_stmt|;
comment|/* Change test type */
name|PUT2
argument_list|(
name|code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|recno
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly, check for the (?(DEFINE) "condition", which is always         false. */
elseif|else
if|if
condition|(
name|namelen
operator|==
literal|6
operator|&&
name|STRNCMP_UC_C8
argument_list|(
name|name
argument_list|,
name|STRING_DEFINE
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|code
index|[
literal|1
operator|+
name|LINK_SIZE
index|]
operator|=
name|OP_DEF
expr_stmt|;
name|skipbytes
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for the "name" actually being a subpattern number. We are         in the second pass here, so final_bracount is set. */
elseif|else
if|if
condition|(
name|recno
operator|>
literal|0
operator|&&
name|recno
operator|<=
name|cd
operator|->
name|final_bracount
condition|)
block|{
name|PUT2
argument_list|(
name|code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|,
name|recno
argument_list|)
expr_stmt|;
block|}
comment|/* Either an unidentified subpattern, or a reference to (?(0) */
else|else
block|{
operator|*
name|errorcodeptr
operator|=
operator|(
name|recno
operator|==
literal|0
operator|)
condition|?
name|ERR35
else|:
name|ERR15
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
break|break;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_EQUALS_SIGN
case|:
comment|/* Positive lookahead */
name|bravalue
operator|=
name|OP_ASSERT
expr_stmt|;
name|cd
operator|->
name|assert_depth
operator|+=
literal|1
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
break|break;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_EXCLAMATION_MARK
case|:
comment|/* Negative lookahead */
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_RIGHT_PARENTHESIS
condition|)
comment|/* Optimize (?!) */
block|{
operator|*
name|code
operator|++
operator|=
name|OP_FAIL
expr_stmt|;
name|previous
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|bravalue
operator|=
name|OP_ASSERT_NOT
expr_stmt|;
name|cd
operator|->
name|assert_depth
operator|+=
literal|1
expr_stmt|;
break|break;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_LESS_THAN_SIGN
case|:
comment|/* Lookbehind or named define */
switch|switch
condition|(
name|ptr
index|[
literal|1
index|]
condition|)
block|{
case|case
name|CHAR_EQUALS_SIGN
case|:
comment|/* Positive lookbehind */
name|bravalue
operator|=
name|OP_ASSERTBACK
expr_stmt|;
name|cd
operator|->
name|assert_depth
operator|+=
literal|1
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|CHAR_EXCLAMATION_MARK
case|:
comment|/* Negative lookbehind */
name|bravalue
operator|=
name|OP_ASSERTBACK_NOT
expr_stmt|;
name|cd
operator|->
name|assert_depth
operator|+=
literal|1
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* Could be name define, else bad */
if|if
condition|(
name|MAX_255
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
name|ptr
index|[
literal|1
index|]
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|DEFINE_NAME
goto|;
name|ptr
operator|++
expr_stmt|;
comment|/* Correct offset for error */
operator|*
name|errorcodeptr
operator|=
name|ERR24
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
break|break;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_GREATER_THAN_SIGN
case|:
comment|/* One-time brackets */
name|bravalue
operator|=
name|OP_ONCE
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
break|break;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_C
case|:
comment|/* Callout - may be followed by digits; */
name|previous_callout
operator|=
name|code
expr_stmt|;
comment|/* Save for later completion */
name|after_manual_callout
operator|=
literal|1
expr_stmt|;
comment|/* Skip one item before completing */
operator|*
name|code
operator|++
operator|=
name|OP_CALLOUT
expr_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|ptr
operator|++
operator|-
name|CHAR_0
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_RIGHT_PARENTHESIS
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR39
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|n
operator|>
literal|255
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR38
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
operator|*
name|code
operator|++
operator|=
name|n
expr_stmt|;
name|PUT
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|cd
operator|->
name|start_pattern
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pattern offset */
name|PUT
argument_list|(
name|code
argument_list|,
name|LINK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Default length */
name|code
operator|+=
literal|2
operator|*
name|LINK_SIZE
expr_stmt|;
block|}
name|previous
operator|=
name|NULL
expr_stmt|;
continue|continue;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_P
case|:
comment|/* Python-style named subpattern handling */
if|if
condition|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|==
name|CHAR_EQUALS_SIGN
operator|||
operator|*
name|ptr
operator|==
name|CHAR_GREATER_THAN_SIGN
condition|)
comment|/* Reference or recursion */
block|{
name|is_recurse
operator|=
operator|*
name|ptr
operator|==
name|CHAR_GREATER_THAN_SIGN
expr_stmt|;
name|terminator
operator|=
name|CHAR_RIGHT_PARENTHESIS
expr_stmt|;
goto|goto
name|NAMED_REF_OR_RECURSE
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_LESS_THAN_SIGN
condition|)
comment|/* Test for Python-style defn */
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR41
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Fall through to handle (?P< as (?< is handled */
comment|/* ------------------------------------------------------------ */
name|DEFINE_NAME
label|:
comment|/* Come here from (?< handling */
case|case
name|CHAR_APOSTROPHE
case|:
block|{
name|terminator
operator|=
operator|(
operator|*
name|ptr
operator|==
name|CHAR_LESS_THAN_SIGN
operator|)
condition|?
name|CHAR_GREATER_THAN_SIGN
else|:
name|CHAR_APOSTROPHE
expr_stmt|;
name|name
operator|=
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|ptr
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|++
expr_stmt|;
name|namelen
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|name
argument_list|)
expr_stmt|;
comment|/* In the pre-compile phase, just do a syntax check. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|!=
operator|(
name|pcre_uchar
operator|)
name|terminator
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR42
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|cd
operator|->
name|names_found
operator|>=
name|MAX_NAME_COUNT
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR49
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|namelen
operator|+
name|IMM2_SIZE
operator|+
literal|1
operator|>
name|cd
operator|->
name|name_entry_size
condition|)
block|{
name|cd
operator|->
name|name_entry_size
operator|=
name|namelen
operator|+
name|IMM2_SIZE
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|MAX_NAME_SIZE
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR48
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
block|}
block|}
comment|/* In the real compile, create the entry in the table, maintaining           alphabetical order. Duplicate names for different numbers are           permitted only if PCRE_DUPNAMES is set. Duplicate names for the same           number are always OK. (An existing number can be re-used if (?|           appears in the pattern.) In either event, a duplicate name results in           a duplicate entry in the table, even if the number is the same. This           is because the number of names, and hence the table size, is computed           in the pre-compile, and it affects various numbers and pointers which           would all have to be modified, and the compiled code moved down, if           duplicates with the same number were omitted from the table. This           doesn't seem worth the hassle. However, *different* names for the           same number are not permitted. */
else|else
block|{
name|BOOL
name|dupname
init|=
name|FALSE
decl_stmt|;
name|slot
operator|=
name|cd
operator|->
name|name_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cd
operator|->
name|names_found
condition|;
name|i
operator|++
control|)
block|{
name|int
name|crc
init|=
name|memcmp
argument_list|(
name|name
argument_list|,
name|slot
operator|+
name|IMM2_SIZE
argument_list|,
name|IN_UCHARS
argument_list|(
name|namelen
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|crc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slot
index|[
name|IMM2_SIZE
operator|+
name|namelen
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET2
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
operator|!=
name|cd
operator|->
name|bracount
operator|+
literal|1
operator|&&
operator|(
name|options
operator|&
name|PCRE_DUPNAMES
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR43
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
else|else
name|dupname
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|crc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Current name is a substring */
block|}
comment|/* Make space in the table and break the loop for an earlier               name. For a duplicate or later name, carry on. We do this for               duplicates so that in the simple case (when ?(| is not used) they               are in order of their numbers. */
if|if
condition|(
name|crc
operator|<
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|slot
operator|+
name|cd
operator|->
name|name_entry_size
argument_list|,
name|slot
argument_list|,
name|IN_UCHARS
argument_list|(
operator|(
name|cd
operator|->
name|names_found
operator|-
name|i
operator|)
operator|*
name|cd
operator|->
name|name_entry_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Continue the loop for a later or duplicate name */
name|slot
operator|+=
name|cd
operator|->
name|name_entry_size
expr_stmt|;
block|}
comment|/* For non-duplicate names, check for a duplicate number before             adding the new name. */
if|if
condition|(
operator|!
name|dupname
condition|)
block|{
name|pcre_uchar
modifier|*
name|cslot
init|=
name|cd
operator|->
name|name_table
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cd
operator|->
name|names_found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cslot
operator|!=
name|slot
condition|)
block|{
if|if
condition|(
name|GET2
argument_list|(
name|cslot
argument_list|,
literal|0
argument_list|)
operator|==
name|cd
operator|->
name|bracount
operator|+
literal|1
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR65
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
block|}
else|else
name|i
operator|--
expr_stmt|;
name|cslot
operator|+=
name|cd
operator|->
name|name_entry_size
expr_stmt|;
block|}
block|}
name|PUT2
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|cd
operator|->
name|bracount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|slot
operator|+
name|IMM2_SIZE
argument_list|,
name|name
argument_list|,
name|IN_UCHARS
argument_list|(
name|namelen
argument_list|)
argument_list|)
expr_stmt|;
name|slot
index|[
name|IMM2_SIZE
operator|+
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* In both pre-compile and compile, count the number of names we've         encountered. */
name|cd
operator|->
name|names_found
operator|++
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* Move past> or ' */
goto|goto
name|NUMBERED_GROUP
goto|;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_AMPERSAND
case|:
comment|/* Perl recursion/subroutine syntax */
name|terminator
operator|=
name|CHAR_RIGHT_PARENTHESIS
expr_stmt|;
name|is_recurse
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through */
comment|/* We come here from the Python syntax above that handles both         references (?P=name) and recursion (?P>name), as well as falling         through from the Perl recursion syntax (?&name). We also come here from         the Perl \k<name> or \k'name' back reference syntax and the \k{name}         .NET syntax, and the Oniguruma \g<...> and \g'...' subroutine syntax. */
name|NAMED_REF_OR_RECURSE
label|:
name|name
operator|=
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|MAX_255
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|ptr
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|++
expr_stmt|;
name|namelen
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|name
argument_list|)
expr_stmt|;
comment|/* In the pre-compile phase, do a syntax check. We used to just set         a dummy reference number, because it was not used in the first pass.         However, with the change of recursive back references to be atomic,         we have to look for the number so that this state can be identified, as         otherwise the incorrect length is computed. If it's not a backwards         reference, the dummy number will do. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|namelen
operator|==
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR62
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|!=
operator|(
name|pcre_uchar
operator|)
name|terminator
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR42
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|namelen
operator|>
name|MAX_NAME_SIZE
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR48
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* The name table does not exist in the first pass, so we cannot           do a simple search as in the code below. Instead, we have to scan the           pattern to find the number. It is important that we scan it only as           far as we have got because the syntax of named subpatterns has not           been checked for the rest of the pattern, and find_parens() assumes           correct syntax. In any case, it's a waste of resources to scan           further. We stop the scan at the current point by temporarily           adjusting the value of cd->endpattern. */
name|temp
operator|=
name|cd
operator|->
name|end_pattern
expr_stmt|;
name|cd
operator|->
name|end_pattern
operator|=
name|ptr
expr_stmt|;
name|recno
operator|=
name|find_parens
argument_list|(
name|cd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
operator|(
name|options
operator|&
name|PCRE_EXTENDED
operator|)
operator|!=
literal|0
argument_list|,
name|utf
argument_list|)
expr_stmt|;
name|cd
operator|->
name|end_pattern
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|recno
operator|<
literal|0
condition|)
name|recno
operator|=
literal|0
expr_stmt|;
comment|/* Forward ref; set dummy number */
block|}
comment|/* In the real compile, seek the name in the table. We check the name         first, and then check that we have reached the end of the name in the         table. That way, if the name that is longer than any in the table,         the comparison will fail without reading beyond the table entry. */
else|else
block|{
name|slot
operator|=
name|cd
operator|->
name|name_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cd
operator|->
name|names_found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STRNCMP_UC_UC
argument_list|(
name|name
argument_list|,
name|slot
operator|+
name|IMM2_SIZE
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|&&
name|slot
index|[
name|IMM2_SIZE
operator|+
name|namelen
index|]
operator|==
literal|0
condition|)
break|break;
name|slot
operator|+=
name|cd
operator|->
name|name_entry_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|cd
operator|->
name|names_found
condition|)
comment|/* Back reference */
block|{
name|recno
operator|=
name|GET2
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|recno
operator|=
comment|/* Forward back reference */
name|find_parens
argument_list|(
name|cd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
operator|(
name|options
operator|&
name|PCRE_EXTENDED
operator|)
operator|!=
literal|0
argument_list|,
name|utf
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR15
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
block|}
comment|/* In both phases, we can now go to the code than handles numerical         recursion or backreferences. */
if|if
condition|(
name|is_recurse
condition|)
goto|goto
name|HANDLE_RECURSION
goto|;
else|else
goto|goto
name|HANDLE_REFERENCE
goto|;
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_R
case|:
comment|/* Recursion */
name|ptr
operator|++
expr_stmt|;
comment|/* Same as (?0)      */
comment|/* Fall through */
comment|/* ------------------------------------------------------------ */
case|case
name|CHAR_MINUS
case|:
case|case
name|CHAR_PLUS
case|:
comment|/* Recursion or subroutine */
case|case
name|CHAR_0
case|:
case|case
name|CHAR_1
case|:
case|case
name|CHAR_2
case|:
case|case
name|CHAR_3
case|:
case|case
name|CHAR_4
case|:
case|case
name|CHAR_5
case|:
case|case
name|CHAR_6
case|:
case|case
name|CHAR_7
case|:
case|case
name|CHAR_8
case|:
case|case
name|CHAR_9
case|:
block|{
specifier|const
name|pcre_uchar
modifier|*
name|called
decl_stmt|;
name|terminator
operator|=
name|CHAR_RIGHT_PARENTHESIS
expr_stmt|;
comment|/* Come here from the \g<...> and \g'...' code (Oniguruma           compatibility). However, the syntax has been checked to ensure that           the ... are a (signed) number, so that neither ERR63 nor ERR29 will           be called on this path, nor with the jump to OTHER_CHAR_AFTER_QUERY           ever be taken. */
name|HANDLE_NUMERICAL_RECURSION
label|:
if|if
condition|(
operator|(
name|refsign
operator|=
operator|*
name|ptr
operator|)
operator|==
name|CHAR_PLUS
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR63
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|refsign
operator|==
name|CHAR_MINUS
condition|)
block|{
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|OTHER_CHAR_AFTER_QUERY
goto|;
name|ptr
operator|++
expr_stmt|;
block|}
name|recno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|recno
operator|=
name|recno
operator|*
literal|10
operator|+
operator|*
name|ptr
operator|++
operator|-
name|CHAR_0
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
operator|(
name|pcre_uchar
operator|)
name|terminator
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR29
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|refsign
operator|==
name|CHAR_MINUS
condition|)
block|{
if|if
condition|(
name|recno
operator|==
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR58
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|recno
operator|=
name|cd
operator|->
name|bracount
operator|-
name|recno
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|recno
operator|<=
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR15
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|refsign
operator|==
name|CHAR_PLUS
condition|)
block|{
if|if
condition|(
name|recno
operator|==
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR58
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|recno
operator|+=
name|cd
operator|->
name|bracount
expr_stmt|;
block|}
comment|/* Come here from code above that handles a named recursion */
name|HANDLE_RECURSION
label|:
name|previous
operator|=
name|code
expr_stmt|;
name|called
operator|=
name|cd
operator|->
name|start_code
expr_stmt|;
comment|/* When we are actually compiling, find the bracket that is being           referenced. Temporarily end the regex in case it doesn't exist before           this point. If we end up with a forward reference, first check that           the bracket does occur later so we can give the error (and position)           now. Then remember this forward reference in the workspace so it can           be filled in at the end. */
if|if
condition|(
name|lengthptr
operator|==
name|NULL
condition|)
block|{
operator|*
name|code
operator|=
name|OP_END
expr_stmt|;
if|if
condition|(
name|recno
operator|!=
literal|0
condition|)
name|called
operator|=
name|PRIV
argument_list|(
name|find_bracket
argument_list|)
argument_list|(
name|cd
operator|->
name|start_code
argument_list|,
name|utf
argument_list|,
name|recno
argument_list|)
expr_stmt|;
comment|/* Forward reference */
if|if
condition|(
name|called
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|find_parens
argument_list|(
name|cd
argument_list|,
name|NULL
argument_list|,
name|recno
argument_list|,
operator|(
name|options
operator|&
name|PCRE_EXTENDED
operator|)
operator|!=
literal|0
argument_list|,
name|utf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR15
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* Fudge the value of "called" so that when it is inserted as an               offset below, what it actually inserted is the reference number               of the group. Then remember the forward reference. */
name|called
operator|=
name|cd
operator|->
name|start_code
operator|+
name|recno
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|hwm
operator|>=
name|cd
operator|->
name|start_workspace
operator|+
name|cd
operator|->
name|workspace_size
operator|-
name|WORK_SIZE_SAFETY_MARGIN
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|expand_workspace
argument_list|(
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errorcodeptr
operator|!=
literal|0
condition|)
goto|goto
name|FAILED
goto|;
block|}
name|PUTINC
argument_list|(
name|cd
operator|->
name|hwm
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|code
operator|+
literal|1
operator|-
name|cd
operator|->
name|start_code
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If not a forward reference, and the subpattern is still open,             this is a recursive call. We check to see if this is a left             recursion that could loop for ever, and diagnose that case. We             must not, however, do this check if we are in a conditional             subpattern because the condition might be testing for recursion in             a pattern such as /(?(R)a+|(?R)b)/, which is perfectly valid.             Forever loops are also detected at runtime, so those that occur in             conditional subpatterns will be picked up then. */
elseif|else
if|if
condition|(
name|GET
argument_list|(
name|called
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|cond_depth
operator|<=
literal|0
operator|&&
name|could_be_empty
argument_list|(
name|called
argument_list|,
name|code
argument_list|,
name|bcptr
argument_list|,
name|utf
argument_list|,
name|cd
argument_list|)
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR40
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
block|}
comment|/* Insert the recursion/subroutine item. It does not have a set first           character (relevant if it is repeated, because it will then be           wrapped with ONCE brackets). */
operator|*
name|code
operator|=
name|OP_RECURSE
expr_stmt|;
name|PUT
argument_list|(
name|code
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|called
operator|-
name|cd
operator|->
name|start_code
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|groupsetfirstchar
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Can't determine a first byte now */
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
continue|continue;
comment|/* ------------------------------------------------------------ */
default|default:
comment|/* Other characters: check option setting */
name|OTHER_CHAR_AFTER_QUERY
label|:
name|set
operator|=
name|unset
operator|=
literal|0
expr_stmt|;
name|optset
operator|=
operator|&
name|set
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_RIGHT_PARENTHESIS
operator|&&
operator|*
name|ptr
operator|!=
name|CHAR_COLON
condition|)
block|{
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
name|CHAR_MINUS
case|:
name|optset
operator|=
operator|&
name|unset
expr_stmt|;
break|break;
case|case
name|CHAR_J
case|:
comment|/* Record that it changed in the external options */
operator|*
name|optset
operator||=
name|PCRE_DUPNAMES
expr_stmt|;
name|cd
operator|->
name|external_flags
operator||=
name|PCRE_JCHANGED
expr_stmt|;
break|break;
case|case
name|CHAR_i
case|:
operator|*
name|optset
operator||=
name|PCRE_CASELESS
expr_stmt|;
break|break;
case|case
name|CHAR_m
case|:
operator|*
name|optset
operator||=
name|PCRE_MULTILINE
expr_stmt|;
break|break;
case|case
name|CHAR_s
case|:
operator|*
name|optset
operator||=
name|PCRE_DOTALL
expr_stmt|;
break|break;
case|case
name|CHAR_x
case|:
operator|*
name|optset
operator||=
name|PCRE_EXTENDED
expr_stmt|;
break|break;
case|case
name|CHAR_U
case|:
operator|*
name|optset
operator||=
name|PCRE_UNGREEDY
expr_stmt|;
break|break;
case|case
name|CHAR_X
case|:
operator|*
name|optset
operator||=
name|PCRE_EXTRA
expr_stmt|;
break|break;
default|default:
operator|*
name|errorcodeptr
operator|=
name|ERR12
expr_stmt|;
name|ptr
operator|--
expr_stmt|;
comment|/* Correct the offset */
goto|goto
name|FAILED
goto|;
block|}
block|}
comment|/* Set up the changed option bits, but don't change anything yet. */
name|newoptions
operator|=
operator|(
name|options
operator||
name|set
operator|)
operator|&
operator|(
operator|~
name|unset
operator|)
expr_stmt|;
comment|/* If the options ended with ')' this is not the start of a nested         group with option changes, so the options change at this level. If this         item is right at the start of the pattern, the options can be         abstracted and made external in the pre-compile phase, and ignored in         the compile phase. This can be helpful when matching -- for instance in         caseless checking of required bytes.          If the code pointer is not (cd->start_code + 1 + LINK_SIZE), we are         definitely *not* at the start of the pattern because something has been         compiled. In the pre-compile phase, however, the code pointer can have         that value after the start, because it gets reset as code is discarded         during the pre-compile. However, this can happen only at top level - if         we are within parentheses, the starting BRA will still be present. At         any parenthesis level, the length value can be used to test if anything         has been compiled at that level. Thus, a test for both these conditions         is necessary to ensure we correctly detect the start of the pattern in         both phases.          If we are not at the pattern start, reset the greedy defaults and the         case value for firstchar and reqchar. */
if|if
condition|(
operator|*
name|ptr
operator|==
name|CHAR_RIGHT_PARENTHESIS
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|cd
operator|->
name|start_code
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|&&
operator|(
name|lengthptr
operator|==
name|NULL
operator|||
operator|*
name|lengthptr
operator|==
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
operator|)
condition|)
block|{
name|cd
operator|->
name|external_options
operator|=
name|newoptions
expr_stmt|;
block|}
else|else
block|{
name|greedy_default
operator|=
operator|(
operator|(
name|newoptions
operator|&
name|PCRE_UNGREEDY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|greedy_non_default
operator|=
name|greedy_default
operator|^
literal|1
expr_stmt|;
name|req_caseopt
operator|=
operator|(
operator|(
name|newoptions
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
operator|)
condition|?
name|REQ_CASELESS
else|:
literal|0
expr_stmt|;
block|}
comment|/* Change options at this level, and pass them back for use           in subsequent branches. */
operator|*
name|optionsptr
operator|=
name|options
operator|=
name|newoptions
expr_stmt|;
name|previous
operator|=
name|NULL
expr_stmt|;
comment|/* This item can't be repeated */
continue|continue;
comment|/* It is complete */
block|}
comment|/* If the options ended with ':' we are heading into a nested group         with possible change of options. Such groups are non-capturing and are         not assertions of any kind. All we need to do is skip over the ':';         the newoptions value is handled below. */
name|bravalue
operator|=
name|OP_BRA
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* End of switch for character following (? */
block|}
comment|/* End of (? handling */
comment|/* Opening parenthesis not followed by '*' or '?'. If PCRE_NO_AUTO_CAPTURE     is set, all unadorned brackets become non-capturing and behave like (?:...)     brackets. */
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_NO_AUTO_CAPTURE
operator|)
operator|!=
literal|0
condition|)
block|{
name|bravalue
operator|=
name|OP_BRA
expr_stmt|;
block|}
comment|/* Else we have a capturing group. */
else|else
block|{
name|NUMBERED_GROUP
label|:
name|cd
operator|->
name|bracount
operator|+=
literal|1
expr_stmt|;
name|PUT2
argument_list|(
name|code
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|cd
operator|->
name|bracount
argument_list|)
expr_stmt|;
name|skipbytes
operator|=
name|IMM2_SIZE
expr_stmt|;
block|}
comment|/* Process nested bracketed regex. Assertions used not to be repeatable,     but this was changed for Perl compatibility, so all kinds can now be     repeated. We copy code into a non-register variable (tempcode) in order to     be able to pass its address because some compilers complain otherwise. */
name|previous
operator|=
name|code
expr_stmt|;
comment|/* For handling repetition */
operator|*
name|code
operator|=
name|bravalue
expr_stmt|;
name|tempcode
operator|=
name|code
expr_stmt|;
name|tempreqvary
operator|=
name|cd
operator|->
name|req_varyopt
expr_stmt|;
comment|/* Save value before bracket */
name|tempbracount
operator|=
name|cd
operator|->
name|bracount
expr_stmt|;
comment|/* Save value before bracket */
name|length_prevgroup
operator|=
literal|0
expr_stmt|;
comment|/* Initialize for pre-compile phase */
if|if
condition|(
operator|!
name|compile_regex
argument_list|(
name|newoptions
argument_list|,
comment|/* The complete new option state */
operator|&
name|tempcode
argument_list|,
comment|/* Where to put code (updated) */
operator|&
name|ptr
argument_list|,
comment|/* Input pointer (updated) */
name|errorcodeptr
argument_list|,
comment|/* Where to put an error message */
operator|(
name|bravalue
operator|==
name|OP_ASSERTBACK
operator|||
name|bravalue
operator|==
name|OP_ASSERTBACK_NOT
operator|)
argument_list|,
comment|/* TRUE if back assert */
name|reset_bracount
argument_list|,
comment|/* True if (?| group */
name|skipbytes
argument_list|,
comment|/* Skip over bracket number */
name|cond_depth
operator|+
operator|(
operator|(
name|bravalue
operator|==
name|OP_COND
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
comment|/* Depth of condition subpatterns */
operator|&
name|subfirstchar
argument_list|,
comment|/* For possible first char */
operator|&
name|subfirstcharflags
argument_list|,
operator|&
name|subreqchar
argument_list|,
comment|/* For possible last char */
operator|&
name|subreqcharflags
argument_list|,
name|bcptr
argument_list|,
comment|/* Current branch chain */
name|cd
argument_list|,
comment|/* Tables block */
operator|(
name|lengthptr
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
comment|/* Actual compile phase */
operator|&
name|length_prevgroup
comment|/* Pre-compile phase */
argument_list|)
condition|)
goto|goto
name|FAILED
goto|;
comment|/* If this was an atomic group and there are no capturing groups within it,     generate OP_ONCE_NC instead of OP_ONCE. */
if|if
condition|(
name|bravalue
operator|==
name|OP_ONCE
operator|&&
name|cd
operator|->
name|bracount
operator|<=
name|tempbracount
condition|)
operator|*
name|code
operator|=
name|OP_ONCE_NC
expr_stmt|;
if|if
condition|(
name|bravalue
operator|>=
name|OP_ASSERT
operator|&&
name|bravalue
operator|<=
name|OP_ASSERTBACK_NOT
condition|)
name|cd
operator|->
name|assert_depth
operator|-=
literal|1
expr_stmt|;
comment|/* At the end of compiling, code is still pointing to the start of the     group, while tempcode has been updated to point past the end of the group.     The pattern pointer (ptr) is on the bracket.      If this is a conditional bracket, check that there are no more than     two branches in the group, or just one if it's a DEFINE group. We do this     in the real compile phase, not in the pre-pass, where the whole group may     not be available. */
if|if
condition|(
name|bravalue
operator|==
name|OP_COND
operator|&&
name|lengthptr
operator|==
name|NULL
condition|)
block|{
name|pcre_uchar
modifier|*
name|tc
init|=
name|code
decl_stmt|;
name|int
name|condcount
init|=
literal|0
decl_stmt|;
do|do
block|{
name|condcount
operator|++
expr_stmt|;
name|tc
operator|+=
name|GET
argument_list|(
name|tc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|tc
operator|!=
name|OP_KET
condition|)
do|;
comment|/* A DEFINE group is never obeyed inline (the "condition" is always       false). It must have only one branch. */
if|if
condition|(
name|code
index|[
name|LINK_SIZE
operator|+
literal|1
index|]
operator|==
name|OP_DEF
condition|)
block|{
if|if
condition|(
name|condcount
operator|>
literal|1
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR54
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
name|bravalue
operator|=
name|OP_DEF
expr_stmt|;
comment|/* Just a flag to suppress char handling below */
block|}
comment|/* A "normal" conditional group. If there is just one branch, we must not       make use of its firstchar or reqchar, because this is equivalent to an       empty second branch. */
else|else
block|{
if|if
condition|(
name|condcount
operator|>
literal|2
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR27
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
if|if
condition|(
name|condcount
operator|==
literal|1
condition|)
name|subfirstcharflags
operator|=
name|subreqcharflags
operator|=
name|REQ_NONE
expr_stmt|;
block|}
block|}
comment|/* Error if hit end of pattern */
if|if
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_RIGHT_PARENTHESIS
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR14
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
comment|/* In the pre-compile phase, update the length by the length of the group,     less the brackets at either end. Then reduce the compiled code to just a     set of non-capturing brackets so that it doesn't use much memory if it is     duplicated by a quantifier.*/
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|OFLOW_MAX
operator|-
operator|*
name|lengthptr
operator|<
name|length_prevgroup
operator|-
literal|2
operator|-
literal|2
operator|*
name|LINK_SIZE
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR20
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
operator|*
name|lengthptr
operator|+=
name|length_prevgroup
operator|-
literal|2
operator|-
literal|2
operator|*
name|LINK_SIZE
expr_stmt|;
name|code
operator|++
expr_stmt|;
comment|/* This already contains bravalue */
name|PUTINC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|OP_KET
expr_stmt|;
name|PUTINC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
break|break;
comment|/* No need to waste time with special character handling */
block|}
comment|/* Otherwise update the main code pointer to the end of the group. */
name|code
operator|=
name|tempcode
expr_stmt|;
comment|/* For a DEFINE group, required and first character settings are not     relevant. */
if|if
condition|(
name|bravalue
operator|==
name|OP_DEF
condition|)
break|break;
comment|/* Handle updating of the required and first characters for other types of     group. Update for normal brackets of all kinds, and conditions with two     branches (see code above). If the bracket is followed by a quantifier with     zero repeat, we have to back off. Hence the definition of zeroreqchar and     zerofirstchar outside the main loop so that they can be accessed for the     back off. */
name|zeroreqchar
operator|=
name|reqchar
expr_stmt|;
name|zeroreqcharflags
operator|=
name|reqcharflags
expr_stmt|;
name|zerofirstchar
operator|=
name|firstchar
expr_stmt|;
name|zerofirstcharflags
operator|=
name|firstcharflags
expr_stmt|;
name|groupsetfirstchar
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|bravalue
operator|>=
name|OP_ONCE
condition|)
block|{
comment|/* If we have not yet set a firstchar in this branch, take it from the       subpattern, remembering that it was set here so that a repeat of more       than one can replicate it as reqchar if necessary. If the subpattern has       no firstchar, set "none" for the whole branch. In both cases, a zero       repeat forces firstchar to "none". */
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
block|{
if|if
condition|(
name|subfirstcharflags
operator|>=
literal|0
condition|)
block|{
name|firstchar
operator|=
name|subfirstchar
expr_stmt|;
name|firstcharflags
operator|=
name|subfirstcharflags
expr_stmt|;
name|groupsetfirstchar
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
name|zerofirstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
block|}
comment|/* If firstchar was previously set, convert the subpattern's firstchar       into reqchar if there wasn't one, using the vary flag that was in       existence beforehand. */
elseif|else
if|if
condition|(
name|subfirstcharflags
operator|>=
literal|0
operator|&&
name|subreqcharflags
operator|<
literal|0
condition|)
block|{
name|subreqchar
operator|=
name|subfirstchar
expr_stmt|;
name|subreqcharflags
operator|=
name|subfirstcharflags
operator||
name|tempreqvary
expr_stmt|;
block|}
comment|/* If the subpattern set a required byte (or set a first byte that isn't       really the first byte - see above), set it. */
if|if
condition|(
name|subreqcharflags
operator|>=
literal|0
condition|)
block|{
name|reqchar
operator|=
name|subreqchar
expr_stmt|;
name|reqcharflags
operator|=
name|subreqcharflags
expr_stmt|;
block|}
block|}
comment|/* For a forward assertion, we take the reqchar, if set. This can be     helpful if the pattern that follows the assertion doesn't set a different     char. For example, it's useful for /(?=abcde).+/. We can't set firstchar     for an assertion, however because it leads to incorrect effect for patterns     such as /(?=a)a.+/ when the "real" "a" would then become a reqchar instead     of a firstchar. This is overcome by a scan at the end if there's no     firstchar, looking for an asserted first char. */
elseif|else
if|if
condition|(
name|bravalue
operator|==
name|OP_ASSERT
operator|&&
name|subreqcharflags
operator|>=
literal|0
condition|)
block|{
name|reqchar
operator|=
name|subreqchar
expr_stmt|;
name|reqcharflags
operator|=
name|subreqcharflags
expr_stmt|;
block|}
break|break;
comment|/* End of processing '(' */
comment|/* ===================================================================*/
comment|/* Handle metasequences introduced by \. For ones like \d, the ESC_ values     are arranged to be the negation of the corresponding OP_values in the     default case when PCRE_UCP is not set. For the back references, the values     are negative the reference number. Only back references and those types     that consume a character may be repeated. We can test for values between     ESC_b and ESC_Z for the latter; this may have to change if any new ones are     ever created. */
case|case
name|CHAR_BACKSLASH
case|:
name|tempptr
operator|=
name|ptr
expr_stmt|;
name|escape
operator|=
name|check_escape
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|ec
argument_list|,
name|errorcodeptr
argument_list|,
name|cd
operator|->
name|bracount
argument_list|,
name|options
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errorcodeptr
operator|!=
literal|0
condition|)
goto|goto
name|FAILED
goto|;
if|if
condition|(
name|escape
operator|==
literal|0
condition|)
name|c
operator|=
name|ec
expr_stmt|;
else|else
block|{
if|if
condition|(
name|escape
operator|==
name|ESC_Q
condition|)
comment|/* Handle start of quoted string */
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
name|CHAR_BACKSLASH
operator|&&
name|ptr
index|[
literal|2
index|]
operator|==
name|CHAR_E
condition|)
name|ptr
operator|+=
literal|2
expr_stmt|;
comment|/* avoid empty string */
else|else
name|inescq
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|escape
operator|==
name|ESC_E
condition|)
continue|continue;
comment|/* Perl ignores an orphan \E */
comment|/* For metasequences that actually match a character, we disable the       setting of a first character if it hasn't already been set. */
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
operator|&&
name|escape
operator|>
name|ESC_b
operator|&&
name|escape
operator|<
name|ESC_Z
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
comment|/* Set values to reset to if this is followed by a zero repeat. */
name|zerofirstchar
operator|=
name|firstchar
expr_stmt|;
name|zerofirstcharflags
operator|=
name|firstcharflags
expr_stmt|;
name|zeroreqchar
operator|=
name|reqchar
expr_stmt|;
name|zeroreqcharflags
operator|=
name|reqcharflags
expr_stmt|;
comment|/* \g<name> or \g'name' is a subroutine call by name and \g<n> or \g'n'       is a subroutine call by number (Oniguruma syntax). In fact, the value       ESC_g is returned only for these cases. So we don't need to check for<       or ' if the value is ESC_g. For the Perl syntax \g{n} the value is       -n, and for the Perl syntax \g{name} the result is ESC_k (as       that is a synonym for a named back reference). */
if|if
condition|(
name|escape
operator|==
name|ESC_g
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|p
decl_stmt|;
name|save_hwm
operator|=
name|cd
operator|->
name|hwm
expr_stmt|;
comment|/* Normally this is set when '(' is read */
name|terminator
operator|=
operator|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|==
name|CHAR_LESS_THAN_SIGN
operator|)
condition|?
name|CHAR_GREATER_THAN_SIGN
else|:
name|CHAR_APOSTROPHE
expr_stmt|;
comment|/* These two statements stop the compiler for warning about possibly         unset variables caused by the jump to HANDLE_NUMERICAL_RECURSION. In         fact, because we actually check for a number below, the paths that         would actually be in error are never taken. */
name|skipbytes
operator|=
literal|0
expr_stmt|;
name|reset_bracount
operator|=
name|FALSE
expr_stmt|;
comment|/* Test for a name */
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_PLUS
operator|&&
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_MINUS
condition|)
block|{
name|BOOL
name|is_a_number
init|=
name|TRUE
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ptr
operator|+
literal|1
init|;
operator|*
name|p
operator|!=
name|CHAR_NULL
operator|&&
operator|*
name|p
operator|!=
operator|(
name|pcre_uchar
operator|)
name|terminator
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|MAX_255
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|is_a_number
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|p
index|]
operator|&
name|ctype_digit
operator|)
operator|==
literal|0
condition|)
name|is_a_number
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|ctypes
index|[
operator|*
name|p
index|]
operator|&
name|ctype_word
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
operator|(
name|pcre_uchar
operator|)
name|terminator
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR57
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_a_number
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
goto|goto
name|HANDLE_NUMERICAL_RECURSION
goto|;
block|}
name|is_recurse
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|NAMED_REF_OR_RECURSE
goto|;
block|}
comment|/* Test a signed number in angle brackets or quotes. */
name|p
operator|=
name|ptr
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
operator|(
name|pcre_uchar
operator|)
name|terminator
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR57
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
goto|goto
name|HANDLE_NUMERICAL_RECURSION
goto|;
block|}
comment|/* \k<name> or \k'name' is a back reference by name (Perl syntax).       We also support \k{name} (.NET syntax).  */
if|if
condition|(
name|escape
operator|==
name|ESC_k
condition|)
block|{
if|if
condition|(
operator|(
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_LESS_THAN_SIGN
operator|&&
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_APOSTROPHE
operator|&&
name|ptr
index|[
literal|1
index|]
operator|!=
name|CHAR_LEFT_CURLY_BRACKET
operator|)
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR69
expr_stmt|;
break|break;
block|}
name|is_recurse
operator|=
name|FALSE
expr_stmt|;
name|terminator
operator|=
operator|(
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|==
name|CHAR_LESS_THAN_SIGN
operator|)
condition|?
name|CHAR_GREATER_THAN_SIGN
else|:
operator|(
operator|*
name|ptr
operator|==
name|CHAR_APOSTROPHE
operator|)
condition|?
name|CHAR_APOSTROPHE
else|:
name|CHAR_RIGHT_CURLY_BRACKET
expr_stmt|;
goto|goto
name|NAMED_REF_OR_RECURSE
goto|;
block|}
comment|/* Back references are handled specially; must disable firstchar if       not set to cope with cases like (?=(\w+))\1: which would otherwise set       ':' later. */
if|if
condition|(
name|escape
operator|<
literal|0
condition|)
block|{
name|open_capitem
modifier|*
name|oc
decl_stmt|;
name|recno
operator|=
operator|-
name|escape
expr_stmt|;
name|HANDLE_REFERENCE
label|:
comment|/* Come here from named backref handling */
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
name|previous
operator|=
name|code
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
operator|)
condition|?
name|OP_REFI
else|:
name|OP_REF
expr_stmt|;
name|PUT2INC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|recno
argument_list|)
expr_stmt|;
name|cd
operator|->
name|backref_map
operator||=
operator|(
name|recno
operator|<
literal|32
operator|)
condition|?
operator|(
literal|1
operator|<<
name|recno
operator|)
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|recno
operator|>
name|cd
operator|->
name|top_backref
condition|)
name|cd
operator|->
name|top_backref
operator|=
name|recno
expr_stmt|;
comment|/* Check to see if this back reference is recursive, that it, it         is inside the group that it references. A flag is set so that the         group can be made atomic. */
for|for
control|(
name|oc
operator|=
name|cd
operator|->
name|open_caps
init|;
name|oc
operator|!=
name|NULL
condition|;
name|oc
operator|=
name|oc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|oc
operator|->
name|number
operator|==
name|recno
condition|)
block|{
name|oc
operator|->
name|flag
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* So are Unicode property matches, if supported. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
elseif|else
if|if
condition|(
name|escape
operator|==
name|ESC_P
operator|||
name|escape
operator|==
name|ESC_p
condition|)
block|{
name|BOOL
name|negated
decl_stmt|;
name|unsigned
name|int
name|ptype
init|=
literal|0
decl_stmt|,
name|pdata
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|get_ucp
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|negated
argument_list|,
operator|&
name|ptype
argument_list|,
operator|&
name|pdata
argument_list|,
name|errorcodeptr
argument_list|)
condition|)
goto|goto
name|FAILED
goto|;
name|previous
operator|=
name|code
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
operator|(
name|escape
operator|==
name|ESC_p
operator|)
operator|!=
name|negated
operator|)
condition|?
name|OP_PROP
else|:
name|OP_NOTPROP
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|ptype
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|pdata
expr_stmt|;
block|}
else|#
directive|else
comment|/* If Unicode properties are not supported, \X, \P, and \p are not       allowed. */
elseif|else
if|if
condition|(
name|escape
operator|==
name|ESC_X
operator|||
name|escape
operator|==
name|ESC_P
operator|||
name|escape
operator|==
name|ESC_p
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR45
expr_stmt|;
goto|goto
name|FAILED
goto|;
block|}
endif|#
directive|endif
comment|/* For the rest (including \X when Unicode properties are supported), we       can obtain the OP value by negating the escape value in the default       situation when PCRE_UCP is not set. When it *is* set, we substitute       Unicode property tests. Note that \b and \B do a one-character       lookbehind. */
else|else
block|{
if|if
condition|(
operator|(
name|escape
operator|==
name|ESC_b
operator|||
name|escape
operator|==
name|ESC_B
operator|)
operator|&&
name|cd
operator|->
name|max_lookbehind
operator|==
literal|0
condition|)
name|cd
operator|->
name|max_lookbehind
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|escape
operator|>=
name|ESC_DU
operator|&&
name|escape
operator|<=
name|ESC_wu
condition|)
block|{
name|nestptr
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
comment|/* Where to resume */
name|ptr
operator|=
name|substitutes
index|[
name|escape
operator|-
name|ESC_DU
index|]
operator|-
literal|1
expr_stmt|;
comment|/* Just before substitute */
block|}
else|else
endif|#
directive|endif
comment|/* In non-UTF-8 mode, we turn \C into OP_ALLANY instead of OP_ANYBYTE         so that it works in DFA mode and in lookbehinds. */
block|{
name|previous
operator|=
operator|(
name|escape
operator|>
name|ESC_b
operator|&&
name|escape
operator|<
name|ESC_Z
operator|)
condition|?
name|code
else|:
name|NULL
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
operator|!
name|utf
operator|&&
name|escape
operator|==
name|ESC_C
operator|)
condition|?
name|OP_ALLANY
else|:
name|escape
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* We have a data character whose value is in c. In UTF-8 mode it may have     a value> 127. We set its representation in the length/buffer, and then     handle it as a data character. */
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
operator|&&
name|c
operator|>
name|MAX_VALUE_FOR_SINGLE_CHAR
condition|)
name|mclength
operator|=
name|PRIV
argument_list|(
name|ord2utf
argument_list|)
argument_list|(
name|c
argument_list|,
name|mcbuffer
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|mcbuffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|mclength
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|ONE_CHAR
goto|;
comment|/* ===================================================================*/
comment|/* Handle a literal character. It is guaranteed not to be whitespace or #     when the extended flag is set. If we are in UTF-8 mode, it may be a     multi-byte literal character. */
default|default:
name|NORMAL_CHAR
label|:
name|mclength
operator|=
literal|1
expr_stmt|;
name|mcbuffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|HAS_EXTRALEN
argument_list|(
name|c
argument_list|)
condition|)
name|ACROSSCHAR
argument_list|(
name|TRUE
argument_list|,
name|ptr
index|[
literal|1
index|]
argument_list|,
name|mcbuffer
index|[
name|mclength
operator|++
index|]
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* At this point we have the character's bytes in mcbuffer, and the length     in mclength. When not in UTF-8 mode, the length is always 1. */
name|ONE_CHAR
label|:
name|previous
operator|=
name|code
expr_stmt|;
comment|/* For caseless UTF-8 mode when UCP support is available, check whether     this character has more than one other case. If so, generate a special     OP_PROP item instead of OP_CHARI. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
name|utf
operator|&&
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|GETCHAR
argument_list|(
name|c
argument_list|,
name|mcbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|UCD_CASESET
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|OP_PROP
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|PT_CLIST
expr_stmt|;
operator|*
name|code
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
name|firstcharflags
operator|=
name|zerofirstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* Caseful matches, or not one of the multicase characters. */
operator|*
name|code
operator|++
operator|=
operator|(
operator|(
name|options
operator|&
name|PCRE_CASELESS
operator|)
operator|!=
literal|0
operator|)
condition|?
name|OP_CHARI
else|:
name|OP_CHAR
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mclength
condition|;
name|c
operator|++
control|)
operator|*
name|code
operator|++
operator|=
name|mcbuffer
index|[
name|c
index|]
expr_stmt|;
comment|/* Remember if \r or \n were seen */
if|if
condition|(
name|mcbuffer
index|[
literal|0
index|]
operator|==
name|CHAR_CR
operator|||
name|mcbuffer
index|[
literal|0
index|]
operator|==
name|CHAR_NL
condition|)
name|cd
operator|->
name|external_flags
operator||=
name|PCRE_HASCRORLF
expr_stmt|;
comment|/* Set the first and required bytes appropriately. If no previous first     byte, set it from this character, but revert to none on a zero repeat.     Otherwise, leave the firstchar value alone, and don't change it on a zero     repeat. */
if|if
condition|(
name|firstcharflags
operator|==
name|REQ_UNSET
condition|)
block|{
name|zerofirstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
name|zeroreqchar
operator|=
name|reqchar
expr_stmt|;
name|zeroreqcharflags
operator|=
name|reqcharflags
expr_stmt|;
comment|/* If the character is more than one byte long, we can set firstchar       only if it is not to be matched caselessly. */
if|if
condition|(
name|mclength
operator|==
literal|1
operator|||
name|req_caseopt
operator|==
literal|0
condition|)
block|{
name|firstchar
operator|=
name|mcbuffer
index|[
literal|0
index|]
operator||
name|req_caseopt
expr_stmt|;
name|firstchar
operator|=
name|mcbuffer
index|[
literal|0
index|]
expr_stmt|;
name|firstcharflags
operator|=
name|req_caseopt
expr_stmt|;
if|if
condition|(
name|mclength
operator|!=
literal|1
condition|)
block|{
name|reqchar
operator|=
name|code
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|reqcharflags
operator|=
name|cd
operator|->
name|req_varyopt
expr_stmt|;
block|}
block|}
else|else
name|firstcharflags
operator|=
name|reqcharflags
operator|=
name|REQ_NONE
expr_stmt|;
block|}
comment|/* firstchar was previously set; we can set reqchar only if the length is     1 or the matching is caseful. */
else|else
block|{
name|zerofirstchar
operator|=
name|firstchar
expr_stmt|;
name|zerofirstcharflags
operator|=
name|firstcharflags
expr_stmt|;
name|zeroreqchar
operator|=
name|reqchar
expr_stmt|;
name|zeroreqcharflags
operator|=
name|reqcharflags
expr_stmt|;
if|if
condition|(
name|mclength
operator|==
literal|1
operator|||
name|req_caseopt
operator|==
literal|0
condition|)
block|{
name|reqchar
operator|=
name|code
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|reqcharflags
operator|=
name|req_caseopt
operator||
name|cd
operator|->
name|req_varyopt
expr_stmt|;
block|}
block|}
break|break;
comment|/* End of literal character handling */
block|}
block|}
comment|/* end of big loop */
comment|/* Control never reaches here by falling through, only by a goto for all the error states. Pass back the position in the pattern so that it can be displayed to the user for diagnosing the error. */
name|FAILED
label|:
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function
begin_comment
comment|/************************************************* *     Compile sequence of alternatives           * *************************************************/
end_comment
begin_comment
comment|/* On entry, ptr is pointing past the bracket character, but on return it points to the closing bracket, or vertical bar, or end of string. The code variable is pointing at the byte into which the BRA operator has been stored. This function is used during the pre-compile phase when we are trying to find out the amount of memory needed, as well as during the real compile phase. The value of lengthptr distinguishes the two phases.  Arguments:   options        option bits, including any changes for this subpattern   codeptr        -> the address of the current code pointer   ptrptr         -> the address of the current pattern pointer   errorcodeptr   -> pointer to error code variable   lookbehind     TRUE if this is a lookbehind assertion   reset_bracount TRUE to reset the count for each branch   skipbytes      skip this many bytes at start (for brackets and OP_COND)   cond_depth     depth of nesting for conditional subpatterns   firstcharptr    place to put the first required character   firstcharflagsptr place to put the first character flags, or a negative number   reqcharptr     place to put the last required character   reqcharflagsptr place to put the last required character flags, or a negative number   bcptr          pointer to the chain of currently open branches   cd             points to the data block with tables pointers etc.   lengthptr      NULL during the real compile phase                  points to length accumulator during pre-compile phase  Returns:         TRUE on success */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|compile_regex
name|compile_regex
parameter_list|(
name|int
name|options
parameter_list|,
name|pcre_uchar
modifier|*
modifier|*
name|codeptr
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
modifier|*
name|ptrptr
parameter_list|,
name|int
modifier|*
name|errorcodeptr
parameter_list|,
name|BOOL
name|lookbehind
parameter_list|,
name|BOOL
name|reset_bracount
parameter_list|,
name|int
name|skipbytes
parameter_list|,
name|int
name|cond_depth
parameter_list|,
name|pcre_uint32
modifier|*
name|firstcharptr
parameter_list|,
name|pcre_int32
modifier|*
name|firstcharflagsptr
parameter_list|,
name|pcre_uint32
modifier|*
name|reqcharptr
parameter_list|,
name|pcre_int32
modifier|*
name|reqcharflagsptr
parameter_list|,
name|branch_chain
modifier|*
name|bcptr
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
name|int
modifier|*
name|lengthptr
parameter_list|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|ptr
init|=
operator|*
name|ptrptr
decl_stmt|;
name|pcre_uchar
modifier|*
name|code
init|=
operator|*
name|codeptr
decl_stmt|;
name|pcre_uchar
modifier|*
name|last_branch
init|=
name|code
decl_stmt|;
name|pcre_uchar
modifier|*
name|start_bracket
init|=
name|code
decl_stmt|;
name|pcre_uchar
modifier|*
name|reverse_count
init|=
name|NULL
decl_stmt|;
name|open_capitem
name|capitem
decl_stmt|;
name|int
name|capnumber
init|=
literal|0
decl_stmt|;
name|pcre_uint32
name|firstchar
decl_stmt|,
name|reqchar
decl_stmt|;
name|pcre_int32
name|firstcharflags
decl_stmt|,
name|reqcharflags
decl_stmt|;
name|pcre_uint32
name|branchfirstchar
decl_stmt|,
name|branchreqchar
decl_stmt|;
name|pcre_int32
name|branchfirstcharflags
decl_stmt|,
name|branchreqcharflags
decl_stmt|;
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|orig_bracount
decl_stmt|;
name|unsigned
name|int
name|max_bracount
decl_stmt|;
name|branch_chain
name|bc
decl_stmt|;
name|bc
operator|.
name|outer
operator|=
name|bcptr
expr_stmt|;
name|bc
operator|.
name|current_branch
operator|=
name|code
expr_stmt|;
name|firstchar
operator|=
name|reqchar
operator|=
literal|0
expr_stmt|;
name|firstcharflags
operator|=
name|reqcharflags
operator|=
name|REQ_UNSET
expr_stmt|;
comment|/* Accumulate the length for use in the pre-compile phase. Start with the length of the BRA and KET and any extra bytes that are required at the beginning. We accumulate in a local variable to save frequent testing of lenthptr for NULL. We cannot do this by looking at the value of code at the start and end of each alternative, because compiled items are discarded during the pre-compile phase so that the work space is not exceeded. */
name|length
operator|=
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
operator|+
name|skipbytes
expr_stmt|;
comment|/* WARNING: If the above line is changed for any reason, you must also change the code that abstracts option settings at the start of the pattern and makes them global. It tests the value of length for (2 + 2*LINK_SIZE) in the pre-compile phase to find out whether anything has yet been compiled or not. */
comment|/* If this is a capturing subpattern, add to the chain of open capturing items so that we can detect them if (*ACCEPT) is encountered. This is also used to detect groups that contain recursive back references to themselves. Note that only OP_CBRA need be tested here; changing this opcode to one of its variants, e.g. OP_SCBRAPOS, happens later, after the group has been compiled. */
if|if
condition|(
operator|*
name|code
operator|==
name|OP_CBRA
condition|)
block|{
name|capnumber
operator|=
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|capitem
operator|.
name|number
operator|=
name|capnumber
expr_stmt|;
name|capitem
operator|.
name|next
operator|=
name|cd
operator|->
name|open_caps
expr_stmt|;
name|capitem
operator|.
name|flag
operator|=
name|FALSE
expr_stmt|;
name|cd
operator|->
name|open_caps
operator|=
operator|&
name|capitem
expr_stmt|;
block|}
comment|/* Offset is set zero to mark that this bracket is still open */
name|PUT
argument_list|(
name|code
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
operator|+
name|skipbytes
expr_stmt|;
comment|/* Loop for each alternative branch */
name|orig_bracount
operator|=
name|max_bracount
operator|=
name|cd
operator|->
name|bracount
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* For a (?| group, reset the capturing bracket count so that each branch   uses the same numbers. */
if|if
condition|(
name|reset_bracount
condition|)
name|cd
operator|->
name|bracount
operator|=
name|orig_bracount
expr_stmt|;
comment|/* Set up dummy OP_REVERSE if lookbehind assertion */
if|if
condition|(
name|lookbehind
condition|)
block|{
operator|*
name|code
operator|++
operator|=
name|OP_REVERSE
expr_stmt|;
name|reverse_count
operator|=
name|code
expr_stmt|;
name|PUTINC
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
comment|/* Now compile the branch; in the pre-compile phase its length gets added   into the length. */
if|if
condition|(
operator|!
name|compile_branch
argument_list|(
operator|&
name|options
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|ptr
argument_list|,
name|errorcodeptr
argument_list|,
operator|&
name|branchfirstchar
argument_list|,
operator|&
name|branchfirstcharflags
argument_list|,
operator|&
name|branchreqchar
argument_list|,
operator|&
name|branchreqcharflags
argument_list|,
operator|&
name|bc
argument_list|,
name|cond_depth
argument_list|,
name|cd
argument_list|,
operator|(
name|lengthptr
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
operator|&
name|length
argument_list|)
condition|)
block|{
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Keep the highest bracket count in case (?| was used and some branch   has fewer than the rest. */
if|if
condition|(
name|cd
operator|->
name|bracount
operator|>
name|max_bracount
condition|)
name|max_bracount
operator|=
name|cd
operator|->
name|bracount
expr_stmt|;
comment|/* In the real compile phase, there is some post-processing to be done. */
if|if
condition|(
name|lengthptr
operator|==
name|NULL
condition|)
block|{
comment|/* If this is the first branch, the firstchar and reqchar values for the     branch become the values for the regex. */
if|if
condition|(
operator|*
name|last_branch
operator|!=
name|OP_ALT
condition|)
block|{
name|firstchar
operator|=
name|branchfirstchar
expr_stmt|;
name|firstcharflags
operator|=
name|branchfirstcharflags
expr_stmt|;
name|reqchar
operator|=
name|branchreqchar
expr_stmt|;
name|reqcharflags
operator|=
name|branchreqcharflags
expr_stmt|;
block|}
comment|/* If this is not the first branch, the first char and reqchar have to     match the values from all the previous branches, except that if the     previous value for reqchar didn't have REQ_VARY set, it can still match,     and we set REQ_VARY for the regex. */
else|else
block|{
comment|/* If we previously had a firstchar, but it doesn't match the new branch,       we have to abandon the firstchar for the regex, but if there was       previously no reqchar, it takes on the value of the old firstchar. */
if|if
condition|(
name|firstcharflags
operator|>=
literal|0
operator|&&
operator|(
name|firstcharflags
operator|!=
name|branchfirstcharflags
operator|||
name|firstchar
operator|!=
name|branchfirstchar
operator|)
condition|)
block|{
if|if
condition|(
name|reqcharflags
operator|<
literal|0
condition|)
block|{
name|reqchar
operator|=
name|firstchar
expr_stmt|;
name|reqcharflags
operator|=
name|firstcharflags
expr_stmt|;
block|}
name|firstcharflags
operator|=
name|REQ_NONE
expr_stmt|;
block|}
comment|/* If we (now or from before) have no firstchar, a firstchar from the       branch becomes a reqchar if there isn't a branch reqchar. */
if|if
condition|(
name|firstcharflags
operator|<
literal|0
operator|&&
name|branchfirstcharflags
operator|>=
literal|0
operator|&&
name|branchreqcharflags
operator|<
literal|0
condition|)
block|{
name|branchreqchar
operator|=
name|branchfirstchar
expr_stmt|;
name|branchreqcharflags
operator|=
name|branchfirstcharflags
expr_stmt|;
block|}
comment|/* Now ensure that the reqchars match */
if|if
condition|(
operator|(
operator|(
name|reqcharflags
operator|&
operator|~
name|REQ_VARY
operator|)
operator|!=
operator|(
name|branchreqcharflags
operator|&
operator|~
name|REQ_VARY
operator|)
operator|)
operator|||
name|reqchar
operator|!=
name|branchreqchar
condition|)
name|reqcharflags
operator|=
name|REQ_NONE
expr_stmt|;
else|else
block|{
name|reqchar
operator|=
name|branchreqchar
expr_stmt|;
name|reqcharflags
operator||=
name|branchreqcharflags
expr_stmt|;
comment|/* To "or" REQ_VARY */
block|}
block|}
comment|/* If lookbehind, check that this branch matches a fixed-length string, and     put the length into the OP_REVERSE item. Temporarily mark the end of the     branch with OP_END. If the branch contains OP_RECURSE, the result is -3     because there may be forward references that we can't check here. Set a     flag to cause another lookbehind check at the end. Why not do it all at the     end? Because common, erroneous checks are picked up here and the offset of     the problem can be shown. */
if|if
condition|(
name|lookbehind
condition|)
block|{
name|int
name|fixed_length
decl_stmt|;
operator|*
name|code
operator|=
name|OP_END
expr_stmt|;
name|fixed_length
operator|=
name|find_fixedlength
argument_list|(
name|last_branch
argument_list|,
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
argument_list|,
name|FALSE
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"fixed length = %d\n"
operator|,
name|fixed_length
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixed_length
operator|==
operator|-
literal|3
condition|)
block|{
name|cd
operator|->
name|check_lookbehind
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixed_length
operator|<
literal|0
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
operator|(
name|fixed_length
operator|==
operator|-
literal|2
operator|)
condition|?
name|ERR36
else|:
operator|(
name|fixed_length
operator|==
operator|-
literal|4
operator|)
condition|?
name|ERR70
else|:
name|ERR25
expr_stmt|;
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|fixed_length
operator|>
name|cd
operator|->
name|max_lookbehind
condition|)
name|cd
operator|->
name|max_lookbehind
operator|=
name|fixed_length
expr_stmt|;
name|PUT
argument_list|(
name|reverse_count
argument_list|,
literal|0
argument_list|,
name|fixed_length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reached end of expression, either ')' or end of pattern. In the real   compile phase, go back through the alternative branches and reverse the chain   of offsets, with the field in the BRA item now becoming an offset to the   first alternative. If there are no alternatives, it points to the end of the   group. The length in the terminating ket is always the length of the whole   bracketed item. Return leaving the pointer at the terminating char. */
if|if
condition|(
operator|*
name|ptr
operator|!=
name|CHAR_VERTICAL_LINE
condition|)
block|{
if|if
condition|(
name|lengthptr
operator|==
name|NULL
condition|)
block|{
name|int
name|branch_length
init|=
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|last_branch
argument_list|)
decl_stmt|;
do|do
block|{
name|int
name|prev_length
init|=
name|GET
argument_list|(
name|last_branch
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|PUT
argument_list|(
name|last_branch
argument_list|,
literal|1
argument_list|,
name|branch_length
argument_list|)
expr_stmt|;
name|branch_length
operator|=
name|prev_length
expr_stmt|;
name|last_branch
operator|-=
name|branch_length
expr_stmt|;
block|}
do|while
condition|(
name|branch_length
operator|>
literal|0
condition|)
do|;
block|}
comment|/* Fill in the ket */
operator|*
name|code
operator|=
name|OP_KET
expr_stmt|;
name|PUT
argument_list|(
name|code
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_bracket
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
comment|/* If it was a capturing subpattern, check to see if it contained any     recursive back references. If so, we must wrap it in atomic brackets.     In any event, remove the block from the chain. */
if|if
condition|(
name|capnumber
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cd
operator|->
name|open_caps
operator|->
name|flag
condition|)
block|{
name|memmove
argument_list|(
name|start_bracket
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|start_bracket
argument_list|,
name|IN_UCHARS
argument_list|(
name|code
operator|-
name|start_bracket
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|start_bracket
operator|=
name|OP_ONCE
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|PUT
argument_list|(
name|start_bracket
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_bracket
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|OP_KET
expr_stmt|;
name|PUT
argument_list|(
name|code
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_bracket
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
name|length
operator|+=
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
expr_stmt|;
block|}
name|cd
operator|->
name|open_caps
operator|=
name|cd
operator|->
name|open_caps
operator|->
name|next
expr_stmt|;
block|}
comment|/* Retain the highest bracket number, in case resetting was used. */
name|cd
operator|->
name|bracount
operator|=
name|max_bracount
expr_stmt|;
comment|/* Set values to pass back */
operator|*
name|codeptr
operator|=
name|code
expr_stmt|;
operator|*
name|ptrptr
operator|=
name|ptr
expr_stmt|;
operator|*
name|firstcharptr
operator|=
name|firstchar
expr_stmt|;
operator|*
name|firstcharflagsptr
operator|=
name|firstcharflags
expr_stmt|;
operator|*
name|reqcharptr
operator|=
name|reqchar
expr_stmt|;
operator|*
name|reqcharflagsptr
operator|=
name|reqcharflags
expr_stmt|;
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|OFLOW_MAX
operator|-
operator|*
name|lengthptr
operator|<
name|length
condition|)
block|{
operator|*
name|errorcodeptr
operator|=
name|ERR20
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|lengthptr
operator|+=
name|length
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Another branch follows. In the pre-compile phase, we can move the code   pointer back to where it was for the start of the first branch. (That is,   pretend that each branch is the only one.)    In the real compile phase, insert an ALT node. Its length field points back   to the previous branch while the bracket remains open. At the end the chain   is reversed. It's done like this so that the start of the bracket has a   zero offset until it is closed, making it possible to detect recursion. */
if|if
condition|(
name|lengthptr
operator|!=
name|NULL
condition|)
block|{
name|code
operator|=
operator|*
name|codeptr
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
name|skipbytes
expr_stmt|;
name|length
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|code
operator|=
name|OP_ALT
expr_stmt|;
name|PUT
argument_list|(
name|code
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|last_branch
argument_list|)
argument_list|)
expr_stmt|;
name|bc
operator|.
name|current_branch
operator|=
name|last_branch
operator|=
name|code
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* Control never reaches here */
block|}
end_function
begin_comment
comment|/************************************************* *          Check for anchored expression         * *************************************************/
end_comment
begin_comment
comment|/* Try to find out if this is an anchored regular expression. Consider each alternative branch. If they all start with OP_SOD or OP_CIRC, or with a bracket all of whose alternatives start with OP_SOD or OP_CIRC (recurse ad lib), then it's anchored. However, if this is a multiline pattern, then only OP_SOD will be found, because ^ generates OP_CIRCM in that mode.  We can also consider a regex to be anchored if OP_SOM starts all its branches. This is the code for \G, which means "match at start of match position, taking into account the match offset".  A branch is also implicitly anchored if it starts with .* and DOTALL is set, because that will try the rest of the pattern at all possible matching points, so there is no point trying again.... er ....  .... except when the .* appears inside capturing parentheses, and there is a subsequent back reference to those parentheses. We haven't enough information to catch that case precisely.  At first, the best we could do was to detect when .* was in capturing brackets and the highest back reference was greater than or equal to that level. However, by keeping a bitmap of the first 31 back references, we can catch some of the more common cases more precisely.  ... A second exception is when the .* appears inside an atomic group, because this prevents the number of characters it matches from being adjusted.  Arguments:   code           points to start of expression (the bracket)   bracket_map    a bitmap of which brackets we are inside while testing; this                   handles up to substring 31; after that we just have to take                   the less precise approach   cd             points to the compile data block   atomcount      atomic group level  Returns:     TRUE or FALSE */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|is_anchored
name|is_anchored
parameter_list|(
specifier|register
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|unsigned
name|int
name|bracket_map
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
name|int
name|atomcount
parameter_list|)
block|{
do|do
block|{
specifier|const
name|pcre_uchar
modifier|*
name|scode
init|=
name|first_significant_code
argument_list|(
name|code
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|code
index|]
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
specifier|register
name|int
name|op
init|=
operator|*
name|scode
decl_stmt|;
comment|/* Non-capturing brackets */
if|if
condition|(
name|op
operator|==
name|OP_BRA
operator|||
name|op
operator|==
name|OP_BRAPOS
operator|||
name|op
operator|==
name|OP_SBRA
operator|||
name|op
operator|==
name|OP_SBRAPOS
condition|)
block|{
if|if
condition|(
operator|!
name|is_anchored
argument_list|(
name|scode
argument_list|,
name|bracket_map
argument_list|,
name|cd
argument_list|,
name|atomcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Capturing brackets */
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_CBRA
operator|||
name|op
operator|==
name|OP_CBRAPOS
operator|||
name|op
operator|==
name|OP_SCBRA
operator|||
name|op
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|int
name|n
init|=
name|GET2
argument_list|(
name|scode
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
decl_stmt|;
name|int
name|new_map
init|=
name|bracket_map
operator||
operator|(
operator|(
name|n
operator|<
literal|32
operator|)
condition|?
operator|(
literal|1
operator|<<
name|n
operator|)
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_anchored
argument_list|(
name|scode
argument_list|,
name|new_map
argument_list|,
name|cd
argument_list|,
name|atomcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Positive forward assertions and conditions */
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_ASSERT
operator|||
name|op
operator|==
name|OP_COND
condition|)
block|{
if|if
condition|(
operator|!
name|is_anchored
argument_list|(
name|scode
argument_list|,
name|bracket_map
argument_list|,
name|cd
argument_list|,
name|atomcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Atomic groups */
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_ONCE
operator|||
name|op
operator|==
name|OP_ONCE_NC
condition|)
block|{
if|if
condition|(
operator|!
name|is_anchored
argument_list|(
name|scode
argument_list|,
name|bracket_map
argument_list|,
name|cd
argument_list|,
name|atomcount
operator|+
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* .* is not anchored unless DOTALL is set (which generates OP_ALLANY) and    it isn't in brackets that are or may be referenced or inside an atomic    group. */
elseif|else
if|if
condition|(
operator|(
name|op
operator|==
name|OP_TYPESTAR
operator|||
name|op
operator|==
name|OP_TYPEMINSTAR
operator|||
name|op
operator|==
name|OP_TYPEPOSSTAR
operator|)
condition|)
block|{
if|if
condition|(
name|scode
index|[
literal|1
index|]
operator|!=
name|OP_ALLANY
operator|||
operator|(
name|bracket_map
operator|&
name|cd
operator|->
name|backref_map
operator|)
operator|!=
literal|0
operator|||
name|atomcount
operator|>
literal|0
operator|||
name|cd
operator|->
name|had_pruneorskip
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Check for explicit anchoring */
elseif|else
if|if
condition|(
name|op
operator|!=
name|OP_SOD
operator|&&
name|op
operator|!=
name|OP_SOM
operator|&&
name|op
operator|!=
name|OP_CIRC
condition|)
return|return
name|FALSE
return|;
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
comment|/* Loop for each alternative */
return|return
name|TRUE
return|;
block|}
end_function
begin_comment
comment|/************************************************* *         Check for starting with ^ or .*        * *************************************************/
end_comment
begin_comment
comment|/* This is called to find out if every branch starts with ^ or .* so that "first char" processing can be done to speed things up in multiline matching and for non-DOTALL patterns that start with .* (which must start at the beginning or after \n). As in the case of is_anchored() (see above), we have to take account of back references to capturing brackets that contain .* because in that case we can't make the assumption. Also, the appearance of .* inside atomic brackets or in a pattern that contains *PRUNE or *SKIP does not count, because once again the assumption no longer holds.  Arguments:   code           points to start of expression (the bracket)   bracket_map    a bitmap of which brackets we are inside while testing; this                   handles up to substring 31; after that we just have to take                   the less precise approach   cd             points to the compile data   atomcount      atomic group level  Returns:         TRUE or FALSE */
end_comment
begin_function
specifier|static
name|BOOL
DECL|function|is_startline
name|is_startline
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|unsigned
name|int
name|bracket_map
parameter_list|,
name|compile_data
modifier|*
name|cd
parameter_list|,
name|int
name|atomcount
parameter_list|)
block|{
do|do
block|{
specifier|const
name|pcre_uchar
modifier|*
name|scode
init|=
name|first_significant_code
argument_list|(
name|code
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
operator|*
name|code
index|]
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
specifier|register
name|int
name|op
init|=
operator|*
name|scode
decl_stmt|;
comment|/* If we are at the start of a conditional assertion group, *both* the    conditional assertion *and* what follows the condition must satisfy the test    for start of line. Other kinds of condition fail. Note that there may be an    auto-callout at the start of a condition. */
if|if
condition|(
name|op
operator|==
name|OP_COND
condition|)
block|{
name|scode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
if|if
condition|(
operator|*
name|scode
operator|==
name|OP_CALLOUT
condition|)
name|scode
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CALLOUT
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|scode
condition|)
block|{
case|case
name|OP_CREF
case|:
case|case
name|OP_NCREF
case|:
case|case
name|OP_RREF
case|:
case|case
name|OP_NRREF
case|:
case|case
name|OP_DEF
case|:
return|return
name|FALSE
return|;
default|default:
comment|/* Assertion */
if|if
condition|(
operator|!
name|is_startline
argument_list|(
name|scode
argument_list|,
name|bracket_map
argument_list|,
name|cd
argument_list|,
name|atomcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
do|do
name|scode
operator|+=
name|GET
argument_list|(
name|scode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|scode
operator|==
name|OP_ALT
condition|)
do|;
name|scode
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
break|break;
block|}
name|scode
operator|=
name|first_significant_code
argument_list|(
name|scode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|op
operator|=
operator|*
name|scode
expr_stmt|;
block|}
comment|/* Non-capturing brackets */
if|if
condition|(
name|op
operator|==
name|OP_BRA
operator|||
name|op
operator|==
name|OP_BRAPOS
operator|||
name|op
operator|==
name|OP_SBRA
operator|||
name|op
operator|==
name|OP_SBRAPOS
condition|)
block|{
if|if
condition|(
operator|!
name|is_startline
argument_list|(
name|scode
argument_list|,
name|bracket_map
argument_list|,
name|cd
argument_list|,
name|atomcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Capturing brackets */
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_CBRA
operator|||
name|op
operator|==
name|OP_CBRAPOS
operator|||
name|op
operator|==
name|OP_SCBRA
operator|||
name|op
operator|==
name|OP_SCBRAPOS
condition|)
block|{
name|int
name|n
init|=
name|GET2
argument_list|(
name|scode
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
decl_stmt|;
name|int
name|new_map
init|=
name|bracket_map
operator||
operator|(
operator|(
name|n
operator|<
literal|32
operator|)
condition|?
operator|(
literal|1
operator|<<
name|n
operator|)
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_startline
argument_list|(
name|scode
argument_list|,
name|new_map
argument_list|,
name|cd
argument_list|,
name|atomcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Positive forward assertions */
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_ASSERT
condition|)
block|{
if|if
condition|(
operator|!
name|is_startline
argument_list|(
name|scode
argument_list|,
name|bracket_map
argument_list|,
name|cd
argument_list|,
name|atomcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Atomic brackets */
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_ONCE
operator|||
name|op
operator|==
name|OP_ONCE_NC
condition|)
block|{
if|if
condition|(
operator|!
name|is_startline
argument_list|(
name|scode
argument_list|,
name|bracket_map
argument_list|,
name|cd
argument_list|,
name|atomcount
operator|+
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* .* means "start at start or after \n" if it isn't in atomic brackets or    brackets that may be referenced, as long as the pattern does not contain    *PRUNE or *SKIP, because these break the feature. Consider, for example,    /.*?a(*PRUNE)b/ with the subject "aab", which matches "ab", i.e. not at the    start of a line. */
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_TYPESTAR
operator|||
name|op
operator|==
name|OP_TYPEMINSTAR
operator|||
name|op
operator|==
name|OP_TYPEPOSSTAR
condition|)
block|{
if|if
condition|(
name|scode
index|[
literal|1
index|]
operator|!=
name|OP_ANY
operator|||
operator|(
name|bracket_map
operator|&
name|cd
operator|->
name|backref_map
operator|)
operator|!=
literal|0
operator|||
name|atomcount
operator|>
literal|0
operator|||
name|cd
operator|->
name|had_pruneorskip
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Check for explicit circumflex; anything else gives a FALSE result. Note    in particular that this includes atomic brackets OP_ONCE and OP_ONCE_NC    because the number of characters matched by .* cannot be adjusted inside    them. */
elseif|else
if|if
condition|(
name|op
operator|!=
name|OP_CIRC
operator|&&
name|op
operator|!=
name|OP_CIRCM
condition|)
return|return
name|FALSE
return|;
comment|/* Move on to the next alternative */
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
comment|/* Loop for each alternative */
return|return
name|TRUE
return|;
block|}
end_function
begin_comment
comment|/************************************************* *       Check for asserted fixed first char      * *************************************************/
end_comment
begin_comment
comment|/* During compilation, the "first char" settings from forward assertions are discarded, because they can cause conflicts with actual literals that follow. However, if we end up without a first char setting for an unanchored pattern, it is worth scanning the regex to see if there is an initial asserted first char. If all branches start with the same asserted char, or with a bracket all of whose alternatives start with the same asserted char (recurse ad lib), then we return that char, otherwise -1.  Arguments:   code       points to start of expression (the bracket)   flags       points to the first char flags, or to REQ_NONE   inassert   TRUE if in an assertion  Returns:     the fixed first char, or 0 with REQ_NONE in flags */
end_comment
begin_function
specifier|static
name|pcre_uint32
DECL|function|find_firstassertedchar
name|find_firstassertedchar
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|code
parameter_list|,
name|pcre_int32
modifier|*
name|flags
parameter_list|,
name|BOOL
name|inassert
parameter_list|)
block|{
specifier|register
name|pcre_uint32
name|c
init|=
literal|0
decl_stmt|;
name|int
name|cflags
init|=
name|REQ_NONE
decl_stmt|;
operator|*
name|flags
operator|=
name|REQ_NONE
expr_stmt|;
do|do
block|{
name|pcre_uint32
name|d
decl_stmt|;
name|int
name|dflags
decl_stmt|;
name|int
name|xl
init|=
operator|(
operator|*
name|code
operator|==
name|OP_CBRA
operator|||
operator|*
name|code
operator|==
name|OP_SCBRA
operator|||
operator|*
name|code
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|code
operator|==
name|OP_SCBRAPOS
operator|)
condition|?
name|IMM2_SIZE
else|:
literal|0
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|scode
init|=
name|first_significant_code
argument_list|(
name|code
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
name|xl
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
specifier|register
name|pcre_uchar
name|op
init|=
operator|*
name|scode
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|OP_BRA
case|:
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
case|case
name|OP_COND
case|:
name|d
operator|=
name|find_firstassertedchar
argument_list|(
name|scode
argument_list|,
operator|&
name|dflags
argument_list|,
name|op
operator|==
name|OP_ASSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflags
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cflags
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|d
expr_stmt|;
name|cflags
operator|=
name|dflags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|d
operator|||
name|cflags
operator|!=
name|dflags
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|OP_EXACT
case|:
name|scode
operator|+=
name|IMM2_SIZE
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_CHAR
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_POSPLUS
case|:
if|if
condition|(
operator|!
name|inassert
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cflags
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|scode
index|[
literal|1
index|]
expr_stmt|;
name|cflags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|scode
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|OP_EXACTI
case|:
name|scode
operator|+=
name|IMM2_SIZE
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_CHARI
case|:
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_POSPLUSI
case|:
if|if
condition|(
operator|!
name|inassert
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cflags
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|scode
index|[
literal|1
index|]
expr_stmt|;
name|cflags
operator|=
name|REQ_CASELESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|scode
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
break|break;
block|}
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
operator|*
name|flags
operator|=
name|cflags
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/************************************************* *        Compile a Regular Expression            * *************************************************/
end_comment
begin_comment
comment|/* This function takes a string and returns a pointer to a block of store holding a compiled version of the expression. The original API for this function had no error code return variable; it is retained for backwards compatibility. The new function is given a new name.  Arguments:   pattern       the regular expression   options       various option bits   errorcodeptr  pointer to error code variable (pcre_compile2() only)                   can be NULL if you don't want a code value   errorptr      pointer to pointer to error text   erroroffset   ptr offset in pattern where error was detected   tables        pointer to character tables or NULL  Returns:        pointer to compiled data block, or NULL on error,                 with errorptr and erroroffset set */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|pcre
modifier|*
name|PCRE_CALL_CONVENTION
DECL|function|pcre_compile
name|pcre_compile
argument_list|(
specifier|const
name|char
operator|*
name|pattern
argument_list|,
name|int
name|options
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|,
name|int
operator|*
name|erroroffset
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|tables
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|pcre16
modifier|*
name|PCRE_CALL_CONVENTION
name|pcre16_compile
argument_list|(
name|PCRE_SPTR16
name|pattern
argument_list|,
name|int
name|options
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|,
name|int
operator|*
name|erroroffset
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|tables
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|pcre32
modifier|*
name|PCRE_CALL_CONVENTION
name|pcre32_compile
argument_list|(
name|PCRE_SPTR32
name|pattern
argument_list|,
name|int
name|options
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|,
name|int
operator|*
name|erroroffset
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|tables
argument_list|)
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
return|return
name|pcre_compile2
argument_list|(
name|pattern
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|,
name|errorptr
argument_list|,
name|erroroffset
argument_list|,
name|tables
argument_list|)
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
return|return
name|pcre16_compile2
argument_list|(
name|pattern
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|,
name|errorptr
argument_list|,
name|erroroffset
argument_list|,
name|tables
argument_list|)
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
return|return
name|pcre32_compile2
argument_list|(
name|pattern
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|,
name|errorptr
argument_list|,
name|erroroffset
argument_list|,
name|tables
argument_list|)
return|;
endif|#
directive|endif
block|}
end_decl_stmt
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|pcre
modifier|*
name|PCRE_CALL_CONVENTION
DECL|function|pcre_compile2
name|pcre_compile2
argument_list|(
specifier|const
name|char
operator|*
name|pattern
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|errorcodeptr
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|,
name|int
operator|*
name|erroroffset
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|tables
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|pcre16
modifier|*
name|PCRE_CALL_CONVENTION
name|pcre16_compile2
argument_list|(
name|PCRE_SPTR16
name|pattern
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|errorcodeptr
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|,
name|int
operator|*
name|erroroffset
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|tables
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|pcre32
modifier|*
name|PCRE_CALL_CONVENTION
name|pcre32_compile2
argument_list|(
name|PCRE_SPTR32
name|pattern
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|errorcodeptr
argument_list|,
specifier|const
name|char
operator|*
operator|*
name|errorptr
argument_list|,
name|int
operator|*
name|erroroffset
argument_list|,
specifier|const
name|unsigned
name|char
operator|*
name|tables
argument_list|)
endif|#
directive|endif
block|{
name|REAL_PCRE
modifier|*
name|re
decl_stmt|;
name|int
name|length
init|=
literal|1
decl_stmt|;
comment|/* For final END opcode */
name|pcre_uint32
name|firstchar
decl_stmt|,
name|reqchar
decl_stmt|;
name|pcre_int32
name|firstcharflags
decl_stmt|,
name|reqcharflags
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
name|errorcode
init|=
literal|0
decl_stmt|;
name|int
name|skipatstart
init|=
literal|0
decl_stmt|;
name|BOOL
name|utf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|pcre_uchar
modifier|*
name|code
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|codestart
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|ptr
decl_stmt|;
name|compile_data
name|compile_block
decl_stmt|;
name|compile_data
modifier|*
name|cd
init|=
operator|&
name|compile_block
decl_stmt|;
comment|/* This space is used for "compiling" into during the first phase, when we are computing the amount of memory that is needed. Compiled items are thrown away as soon as possible, so that a fairly large buffer should be sufficient for this purpose. The same space is used in the second phase for remembering where to fill in forward references to subpatterns. That may overflow, in which case new memory is obtained from malloc(). */
name|pcre_uchar
name|cworkspace
index|[
name|COMPILE_WORK_SIZE
index|]
decl_stmt|;
comment|/* Set this early so that early errors get offset 0. */
name|ptr
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|pattern
expr_stmt|;
comment|/* We can't pass back an error message if errorptr is NULL; I guess the best we can do is just return NULL, but we can set a code value if there is a code pointer. */
if|if
condition|(
name|errorptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errorcodeptr
operator|!=
name|NULL
condition|)
operator|*
name|errorcodeptr
operator|=
literal|99
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|errorptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|errorcodeptr
operator|!=
name|NULL
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR0
expr_stmt|;
comment|/* However, we can give a message for this error */
if|if
condition|(
name|erroroffset
operator|==
name|NULL
condition|)
block|{
name|errorcode
operator|=
name|ERR16
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN2
goto|;
block|}
operator|*
name|erroroffset
operator|=
literal|0
expr_stmt|;
comment|/* Set up pointers to the individual character tables */
if|if
condition|(
name|tables
operator|==
name|NULL
condition|)
name|tables
operator|=
name|PRIV
argument_list|(
name|default_tables
argument_list|)
expr_stmt|;
name|cd
operator|->
name|lcc
operator|=
name|tables
operator|+
name|lcc_offset
expr_stmt|;
name|cd
operator|->
name|fcc
operator|=
name|tables
operator|+
name|fcc_offset
expr_stmt|;
name|cd
operator|->
name|cbits
operator|=
name|tables
operator|+
name|cbits_offset
expr_stmt|;
name|cd
operator|->
name|ctypes
operator|=
name|tables
operator|+
name|ctypes_offset
expr_stmt|;
comment|/* Check that all undefined public option bits are zero */
if|if
condition|(
operator|(
name|options
operator|&
operator|~
name|PUBLIC_COMPILE_OPTIONS
operator|)
operator|!=
literal|0
condition|)
block|{
name|errorcode
operator|=
name|ERR17
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
block|}
comment|/* Check for global one-time settings at the start of the pattern, and remember the offset for later. */
while|while
condition|(
name|ptr
index|[
name|skipatstart
index|]
operator|==
name|CHAR_LEFT_PARENTHESIS
operator|&&
name|ptr
index|[
name|skipatstart
operator|+
literal|1
index|]
operator|==
name|CHAR_ASTERISK
condition|)
block|{
name|int
name|newnl
init|=
literal|0
decl_stmt|;
name|int
name|newbsr
init|=
literal|0
decl_stmt|;
comment|/* For completeness and backward compatibility, (*UTFn) is supported in the relevant libraries, but (*UTF) is generic and always supported. Note that PCRE_UTF8 == PCRE_UTF16 == PCRE_UTF32. */
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_UTF8_RIGHTPAR
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|7
expr_stmt|;
name|options
operator||=
name|PCRE_UTF8
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPILE_PCRE16
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_UTF16_RIGHTPAR
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|8
expr_stmt|;
name|options
operator||=
name|PCRE_UTF16
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPILE_PCRE32
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_UTF32_RIGHTPAR
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|8
expr_stmt|;
name|options
operator||=
name|PCRE_UTF32
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_UTF_RIGHTPAR
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|6
expr_stmt|;
name|options
operator||=
name|PCRE_UTF8
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_UCP_RIGHTPAR
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|6
expr_stmt|;
name|options
operator||=
name|PCRE_UCP
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_NO_START_OPT_RIGHTPAR
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|15
expr_stmt|;
name|options
operator||=
name|PCRE_NO_START_OPTIMIZE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_CR_RIGHTPAR
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|5
expr_stmt|;
name|newnl
operator|=
name|PCRE_NEWLINE_CR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_LF_RIGHTPAR
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|5
expr_stmt|;
name|newnl
operator|=
name|PCRE_NEWLINE_LF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_CRLF_RIGHTPAR
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|7
expr_stmt|;
name|newnl
operator|=
name|PCRE_NEWLINE_CR
operator|+
name|PCRE_NEWLINE_LF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_ANY_RIGHTPAR
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|6
expr_stmt|;
name|newnl
operator|=
name|PCRE_NEWLINE_ANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_ANYCRLF_RIGHTPAR
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|10
expr_stmt|;
name|newnl
operator|=
name|PCRE_NEWLINE_ANYCRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_BSR_ANYCRLF_RIGHTPAR
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|14
expr_stmt|;
name|newbsr
operator|=
name|PCRE_BSR_ANYCRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNCMP_UC_C8
argument_list|(
name|ptr
operator|+
name|skipatstart
operator|+
literal|2
argument_list|,
name|STRING_BSR_UNICODE_RIGHTPAR
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skipatstart
operator|+=
literal|14
expr_stmt|;
name|newbsr
operator|=
name|PCRE_BSR_UNICODE
expr_stmt|;
block|}
if|if
condition|(
name|newnl
operator|!=
literal|0
condition|)
name|options
operator|=
operator|(
name|options
operator|&
operator|~
name|PCRE_NEWLINE_BITS
operator|)
operator||
name|newnl
expr_stmt|;
elseif|else
if|if
condition|(
name|newbsr
operator|!=
literal|0
condition|)
name|options
operator|=
operator|(
name|options
operator|&
operator|~
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
operator|)
operator||
name|newbsr
expr_stmt|;
else|else
break|break;
block|}
comment|/* PCRE_UTF(16|32) have the same value as PCRE_UTF8. */
name|utf
operator|=
operator|(
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Can't support UTF unless PCRE has been compiled to include the code. The return of an error code from PRIV(valid_utf)() is a new feature, introduced in release 8.13. It is passed back from pcre_[dfa_]exec(), but at the moment is not used here. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
operator|(
name|options
operator|&
name|PCRE_NO_UTF8_CHECK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|errorcode
operator|=
name|PRIV
argument_list|(
name|valid_utf
argument_list|)
argument_list|(
operator|(
name|PCRE_PUCHAR
operator|)
name|pattern
argument_list|,
operator|-
literal|1
argument_list|,
name|erroroffset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|errorcode
operator|=
name|ERR44
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|errorcode
operator|=
name|ERR74
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|errorcode
operator|=
name|ERR77
expr_stmt|;
endif|#
directive|endif
goto|goto
name|PCRE_EARLY_ERROR_RETURN2
goto|;
block|}
else|#
directive|else
if|if
condition|(
name|utf
condition|)
block|{
name|errorcode
operator|=
name|ERR32
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
block|}
endif|#
directive|endif
comment|/* Can't support UCP unless PCRE has been compiled to include the code. */
ifndef|#
directive|ifndef
name|SUPPORT_UCP
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|errorcode
operator|=
name|ERR67
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
block|}
endif|#
directive|endif
comment|/* Check validity of \R options. */
if|if
condition|(
operator|(
name|options
operator|&
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
operator|)
operator|==
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
condition|)
block|{
name|errorcode
operator|=
name|ERR56
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
block|}
comment|/* Handle different types of newline. The three bits give seven cases. The current code allows for fixed one- or two-byte sequences, plus "any" and "anycrlf". */
switch|switch
condition|(
name|options
operator|&
name|PCRE_NEWLINE_BITS
condition|)
block|{
case|case
literal|0
case|:
name|newline
operator|=
name|NEWLINE
expr_stmt|;
break|break;
comment|/* Build-time default */
case|case
name|PCRE_NEWLINE_CR
case|:
name|newline
operator|=
name|CHAR_CR
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_LF
case|:
name|newline
operator|=
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_CR
operator|+
name|PCRE_NEWLINE_LF
case|:
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANY
case|:
name|newline
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANYCRLF
case|:
name|newline
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
name|errorcode
operator|=
name|ERR56
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
block|}
if|if
condition|(
name|newline
operator|==
operator|-
literal|2
condition|)
block|{
name|cd
operator|->
name|nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newline
operator|<
literal|0
condition|)
block|{
name|cd
operator|->
name|nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
block|}
else|else
block|{
name|cd
operator|->
name|nltype
operator|=
name|NLTYPE_FIXED
expr_stmt|;
if|if
condition|(
name|newline
operator|>
literal|255
condition|)
block|{
name|cd
operator|->
name|nllen
operator|=
literal|2
expr_stmt|;
name|cd
operator|->
name|nl
index|[
literal|0
index|]
operator|=
operator|(
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|cd
operator|->
name|nl
index|[
literal|1
index|]
operator|=
name|newline
operator|&
literal|255
expr_stmt|;
block|}
else|else
block|{
name|cd
operator|->
name|nllen
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|nl
index|[
literal|0
index|]
operator|=
name|newline
expr_stmt|;
block|}
block|}
comment|/* Maximum back reference and backref bitmap. The bitmap records up to 31 back references to help in deciding whether (.*) can be treated as anchored or not. */
name|cd
operator|->
name|top_backref
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|backref_map
operator|=
literal|0
expr_stmt|;
comment|/* Reflect pattern for debugging output */
name|DPRINTF
argument_list|(
operator|(
literal|"------------------------------------------------------------------\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|print_puchar
argument_list|(
name|stdout
argument_list|,
operator|(
name|PCRE_PUCHAR
operator|)
name|pattern
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Pretend to compile the pattern while actually just accumulating the length of memory required. This behaviour is triggered by passing a non-NULL final argument to compile_regex(). We pass a block of workspace (cworkspace) for it to compile parts of the pattern into; the compiled code is discarded when it is no longer needed, so hopefully this workspace will never overflow, though there is a test for its doing so. */
name|cd
operator|->
name|bracount
operator|=
name|cd
operator|->
name|final_bracount
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|names_found
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|name_entry_size
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|name_table
operator|=
name|NULL
expr_stmt|;
name|cd
operator|->
name|start_code
operator|=
name|cworkspace
expr_stmt|;
name|cd
operator|->
name|hwm
operator|=
name|cworkspace
expr_stmt|;
name|cd
operator|->
name|start_workspace
operator|=
name|cworkspace
expr_stmt|;
name|cd
operator|->
name|workspace_size
operator|=
name|COMPILE_WORK_SIZE
expr_stmt|;
name|cd
operator|->
name|start_pattern
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|pattern
expr_stmt|;
name|cd
operator|->
name|end_pattern
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
operator|(
name|pattern
operator|+
name|STRLEN_UC
argument_list|(
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|pattern
argument_list|)
operator|)
expr_stmt|;
name|cd
operator|->
name|req_varyopt
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|assert_depth
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|max_lookbehind
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|external_options
operator|=
name|options
expr_stmt|;
name|cd
operator|->
name|external_flags
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|open_caps
operator|=
name|NULL
expr_stmt|;
comment|/* Now do the pre-compile. On error, errorcode will be set non-zero, so we don't need to look at the result of the function here. The initial options have been put into the cd block so that they can be changed if an option setting is found within the regex right at the beginning. Bringing initial option settings outside can help speed up starting point checks. */
name|ptr
operator|+=
name|skipatstart
expr_stmt|;
name|code
operator|=
name|cworkspace
expr_stmt|;
operator|*
name|code
operator|=
name|OP_BRA
expr_stmt|;
operator|(
name|void
operator|)
name|compile_regex
argument_list|(
name|cd
operator|->
name|external_options
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|ptr
argument_list|,
operator|&
name|errorcode
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|firstchar
argument_list|,
operator|&
name|firstcharflags
argument_list|,
operator|&
name|reqchar
argument_list|,
operator|&
name|reqcharflags
argument_list|,
name|NULL
argument_list|,
name|cd
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcode
operator|!=
literal|0
condition|)
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
name|DPRINTF
argument_list|(
operator|(
literal|"end pre-compile: length=%d workspace=%d\n"
operator|,
name|length
operator|,
call|(
name|int
call|)
argument_list|(
name|cd
operator|->
name|hwm
operator|-
name|cworkspace
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|MAX_PATTERN_SIZE
condition|)
block|{
name|errorcode
operator|=
name|ERR20
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
block|}
comment|/* Compute the size of data block needed and get it, either from malloc or externally provided function. Integer overflow should no longer be possible because nowadays we limit the maximum value of cd->names_found and cd->name_entry_size. */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|REAL_PCRE
argument_list|)
operator|+
operator|(
name|length
operator|+
name|cd
operator|->
name|names_found
operator|*
name|cd
operator|->
name|name_entry_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
name|re
operator|=
operator|(
name|REAL_PCRE
operator|*
operator|)
operator|(
name|PUBL
argument_list|(
name|malloc
argument_list|)
operator|)
operator|(
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|NULL
condition|)
block|{
name|errorcode
operator|=
name|ERR21
expr_stmt|;
goto|goto
name|PCRE_EARLY_ERROR_RETURN
goto|;
block|}
comment|/* Put in the magic number, and save the sizes, initial options, internal flags, and character table pointer. NULL is used for the default character tables. The nullpad field is at the end; it's there to help in the case when a regex compiled on a system with 4-byte pointers is run on another with 8-byte pointers. */
name|re
operator|->
name|magic_number
operator|=
name|MAGIC_NUMBER
expr_stmt|;
name|re
operator|->
name|size
operator|=
operator|(
name|int
operator|)
name|size
expr_stmt|;
name|re
operator|->
name|options
operator|=
name|cd
operator|->
name|external_options
expr_stmt|;
name|re
operator|->
name|flags
operator|=
name|cd
operator|->
name|external_flags
expr_stmt|;
name|re
operator|->
name|first_char
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|req_char
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|name_table_offset
operator|=
sizeof|sizeof
argument_list|(
name|REAL_PCRE
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
name|re
operator|->
name|name_entry_size
operator|=
name|cd
operator|->
name|name_entry_size
expr_stmt|;
name|re
operator|->
name|name_count
operator|=
name|cd
operator|->
name|names_found
expr_stmt|;
name|re
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|tables
operator|=
operator|(
name|tables
operator|==
name|PRIV
argument_list|(
name|default_tables
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|tables
expr_stmt|;
name|re
operator|->
name|nullpad
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE32
name|re
operator|->
name|dummy1
operator|=
name|re
operator|->
name|dummy2
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* The starting points of the name/number translation table and of the code are passed around in the compile data block. The start/end pattern and initial options are already set from the pre-compile phase, as is the name_entry_size field. Reset the bracket count and the names_found field. Also reset the hwm field; this time it's used for remembering forward references to subpatterns. */
name|cd
operator|->
name|final_bracount
operator|=
name|cd
operator|->
name|bracount
expr_stmt|;
comment|/* Save for checking forward references */
name|cd
operator|->
name|assert_depth
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|bracount
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|max_lookbehind
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|names_found
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|name_table
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
expr_stmt|;
name|codestart
operator|=
name|cd
operator|->
name|name_table
operator|+
name|re
operator|->
name|name_entry_size
operator|*
name|re
operator|->
name|name_count
expr_stmt|;
name|cd
operator|->
name|start_code
operator|=
name|codestart
expr_stmt|;
name|cd
operator|->
name|hwm
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
operator|(
name|cd
operator|->
name|start_workspace
operator|)
expr_stmt|;
name|cd
operator|->
name|req_varyopt
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|had_accept
operator|=
name|FALSE
expr_stmt|;
name|cd
operator|->
name|had_pruneorskip
operator|=
name|FALSE
expr_stmt|;
name|cd
operator|->
name|check_lookbehind
operator|=
name|FALSE
expr_stmt|;
name|cd
operator|->
name|open_caps
operator|=
name|NULL
expr_stmt|;
comment|/* Set up a starting, non-extracting bracket, then compile the expression. On error, errorcode will be set non-zero, so we don't need to look at the result of the function here. */
name|ptr
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|pattern
operator|+
name|skipatstart
expr_stmt|;
name|code
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|codestart
expr_stmt|;
operator|*
name|code
operator|=
name|OP_BRA
expr_stmt|;
operator|(
name|void
operator|)
name|compile_regex
argument_list|(
name|re
operator|->
name|options
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|ptr
argument_list|,
operator|&
name|errorcode
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|firstchar
argument_list|,
operator|&
name|firstcharflags
argument_list|,
operator|&
name|reqchar
argument_list|,
operator|&
name|reqcharflags
argument_list|,
name|NULL
argument_list|,
name|cd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|re
operator|->
name|top_bracket
operator|=
name|cd
operator|->
name|bracount
expr_stmt|;
name|re
operator|->
name|top_backref
operator|=
name|cd
operator|->
name|top_backref
expr_stmt|;
name|re
operator|->
name|max_lookbehind
operator|=
name|cd
operator|->
name|max_lookbehind
expr_stmt|;
name|re
operator|->
name|flags
operator|=
name|cd
operator|->
name|external_flags
operator||
name|PCRE_MODE
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|had_accept
condition|)
block|{
name|reqchar
operator|=
literal|0
expr_stmt|;
comment|/* Must disable after (*ACCEPT) */
name|reqcharflags
operator|=
name|REQ_NONE
expr_stmt|;
block|}
comment|/* If not reached end of pattern on success, there's an excess bracket. */
if|if
condition|(
name|errorcode
operator|==
literal|0
operator|&&
operator|*
name|ptr
operator|!=
name|CHAR_NULL
condition|)
name|errorcode
operator|=
name|ERR22
expr_stmt|;
comment|/* Fill in the terminating state and check for disastrous overflow, but if debugging, leave the test till after things are printed out. */
operator|*
name|code
operator|++
operator|=
name|OP_END
expr_stmt|;
ifndef|#
directive|ifndef
name|PCRE_DEBUG
if|if
condition|(
name|code
operator|-
name|codestart
operator|>
name|length
condition|)
name|errorcode
operator|=
name|ERR23
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_VALGRIND
comment|/* If the estimated length exceeds the really used length, mark the extra allocated memory as unadressable, so that any out-of-bound reads can be detected. */
name|VALGRIND_MAKE_MEM_NOACCESS
argument_list|(
name|code
argument_list|,
operator|(
name|length
operator|-
operator|(
name|code
operator|-
name|codestart
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill in any forward references that are required. There may be repeated references; optimize for them, as searching a large regex takes time. */
if|if
condition|(
name|cd
operator|->
name|hwm
operator|>
name|cd
operator|->
name|start_workspace
condition|)
block|{
name|int
name|prev_recno
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|groupptr
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|errorcode
operator|==
literal|0
operator|&&
name|cd
operator|->
name|hwm
operator|>
name|cd
operator|->
name|start_workspace
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|recno
decl_stmt|;
name|cd
operator|->
name|hwm
operator|-=
name|LINK_SIZE
expr_stmt|;
name|offset
operator|=
name|GET
argument_list|(
name|cd
operator|->
name|hwm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|recno
operator|=
name|GET
argument_list|(
name|codestart
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|recno
operator|!=
name|prev_recno
condition|)
block|{
name|groupptr
operator|=
name|PRIV
argument_list|(
name|find_bracket
argument_list|)
argument_list|(
name|codestart
argument_list|,
name|utf
argument_list|,
name|recno
argument_list|)
expr_stmt|;
name|prev_recno
operator|=
name|recno
expr_stmt|;
block|}
if|if
condition|(
name|groupptr
operator|==
name|NULL
condition|)
name|errorcode
operator|=
name|ERR53
expr_stmt|;
else|else
name|PUT
argument_list|(
operator|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|codestart
operator|)
argument_list|,
name|offset
argument_list|,
call|(
name|int
call|)
argument_list|(
name|groupptr
operator|-
name|codestart
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the workspace had to be expanded, free the new memory. */
if|if
condition|(
name|cd
operator|->
name|workspace_size
operator|>
name|COMPILE_WORK_SIZE
condition|)
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|cd
operator|->
name|start_workspace
operator|)
expr_stmt|;
comment|/* Give an error if there's back reference to a non-existent capturing subpattern. */
if|if
condition|(
name|errorcode
operator|==
literal|0
operator|&&
name|re
operator|->
name|top_backref
operator|>
name|re
operator|->
name|top_bracket
condition|)
name|errorcode
operator|=
name|ERR15
expr_stmt|;
comment|/* If there were any lookbehind assertions that contained OP_RECURSE (recursions or subroutine calls), a flag is set for them to be checked here, because they may contain forward references. Actual recursions cannot be fixed length, but subroutine calls can. It is done like this so that those without OP_RECURSE that are not fixed length get a diagnosic with a useful offset. The exceptional ones forgo this. We scan the pattern to check that they are fixed length, and set their lengths. */
if|if
condition|(
name|cd
operator|->
name|check_lookbehind
condition|)
block|{
name|pcre_uchar
modifier|*
name|cc
init|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|codestart
decl_stmt|;
comment|/* Loop, searching for OP_REVERSE items, and process those that do not have   their length set. (Actually, it will also re-process any that have a length   of zero, but that is a pathological case, and it does no harm.) When we find   one, we temporarily terminate the branch it is in while we scan it. */
for|for
control|(
name|cc
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|PRIV
argument_list|(
name|find_bracket
argument_list|)
argument_list|(
name|codestart
argument_list|,
name|utf
argument_list|,
operator|-
literal|1
argument_list|)
init|;
name|cc
operator|!=
name|NULL
condition|;
name|cc
operator|=
operator|(
name|pcre_uchar
operator|*
operator|)
name|PRIV
argument_list|(
name|find_bracket
argument_list|)
argument_list|(
name|cc
argument_list|,
name|utf
argument_list|,
operator|-
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|fixed_length
decl_stmt|;
name|pcre_uchar
modifier|*
name|be
init|=
name|cc
operator|-
literal|1
operator|-
name|LINK_SIZE
operator|+
name|GET
argument_list|(
name|cc
argument_list|,
operator|-
name|LINK_SIZE
argument_list|)
decl_stmt|;
name|int
name|end_op
init|=
operator|*
name|be
decl_stmt|;
operator|*
name|be
operator|=
name|OP_END
expr_stmt|;
name|fixed_length
operator|=
name|find_fixedlength
argument_list|(
name|cc
argument_list|,
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
argument_list|,
name|TRUE
argument_list|,
name|cd
argument_list|)
expr_stmt|;
operator|*
name|be
operator|=
name|end_op
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"fixed length = %d\n"
operator|,
name|fixed_length
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixed_length
operator|<
literal|0
condition|)
block|{
name|errorcode
operator|=
operator|(
name|fixed_length
operator|==
operator|-
literal|2
operator|)
condition|?
name|ERR36
else|:
operator|(
name|fixed_length
operator|==
operator|-
literal|4
operator|)
condition|?
name|ERR70
else|:
name|ERR25
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixed_length
operator|>
name|cd
operator|->
name|max_lookbehind
condition|)
name|cd
operator|->
name|max_lookbehind
operator|=
name|fixed_length
expr_stmt|;
name|PUT
argument_list|(
name|cc
argument_list|,
literal|1
argument_list|,
name|fixed_length
argument_list|)
expr_stmt|;
block|}
name|cc
operator|+=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
block|}
comment|/* Failed to compile, or error while post-processing */
if|if
condition|(
name|errorcode
operator|!=
literal|0
condition|)
block|{
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|re
operator|)
expr_stmt|;
name|PCRE_EARLY_ERROR_RETURN
label|:
operator|*
name|erroroffset
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|pattern
argument_list|)
expr_stmt|;
name|PCRE_EARLY_ERROR_RETURN2
label|:
operator|*
name|errorptr
operator|=
name|find_error_text
argument_list|(
name|errorcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcodeptr
operator|!=
name|NULL
condition|)
operator|*
name|errorcodeptr
operator|=
name|errorcode
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* If the anchored option was not passed, set the flag if we can determine that the pattern is anchored by virtue of ^ characters or \A or anything else, such as starting with non-atomic .* when DOTALL is set and there are no occurrences of *PRUNE or *SKIP.  Otherwise, if we know what the first byte has to be, save it, because that speeds up unanchored matches no end. If not, see if we can set the PCRE_STARTLINE flag. This is helpful for multiline matches when all branches start with ^. and also when all branches start with non-atomic .* for non-DOTALL matches when *PRUNE and SKIP are not present. */
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_anchored
argument_list|(
name|codestart
argument_list|,
literal|0
argument_list|,
name|cd
argument_list|,
literal|0
argument_list|)
condition|)
name|re
operator|->
name|options
operator||=
name|PCRE_ANCHORED
expr_stmt|;
else|else
block|{
if|if
condition|(
name|firstcharflags
operator|<
literal|0
condition|)
name|firstchar
operator|=
name|find_firstassertedchar
argument_list|(
name|codestart
argument_list|,
operator|&
name|firstcharflags
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstcharflags
operator|>=
literal|0
condition|)
comment|/* Remove caseless flag for non-caseable chars */
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|re
operator|->
name|first_char
operator|=
name|firstchar
operator|&
literal|0xff
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|re
operator|->
name|first_char
operator|=
name|firstchar
operator|&
literal|0xffff
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|re
operator|->
name|first_char
operator|=
name|firstchar
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|firstcharflags
operator|&
name|REQ_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
comment|/* We ignore non-ASCII first chars in 8 bit mode. */
if|if
condition|(
name|utf
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|first_char
operator|<
literal|128
condition|)
block|{
if|if
condition|(
name|cd
operator|->
name|fcc
index|[
name|re
operator|->
name|first_char
index|]
operator|!=
name|re
operator|->
name|first_char
condition|)
name|re
operator|->
name|flags
operator||=
name|PCRE_FCH_CASELESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UCD_OTHERCASE
argument_list|(
name|re
operator|->
name|first_char
argument_list|)
operator|!=
name|re
operator|->
name|first_char
condition|)
name|re
operator|->
name|flags
operator||=
name|PCRE_FCH_CASELESS
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|MAX_255
argument_list|(
name|re
operator|->
name|first_char
argument_list|)
operator|&&
name|cd
operator|->
name|fcc
index|[
name|re
operator|->
name|first_char
index|]
operator|!=
name|re
operator|->
name|first_char
condition|)
name|re
operator|->
name|flags
operator||=
name|PCRE_FCH_CASELESS
expr_stmt|;
block|}
name|re
operator|->
name|flags
operator||=
name|PCRE_FIRSTSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_startline
argument_list|(
name|codestart
argument_list|,
literal|0
argument_list|,
name|cd
argument_list|,
literal|0
argument_list|)
condition|)
name|re
operator|->
name|flags
operator||=
name|PCRE_STARTLINE
expr_stmt|;
block|}
block|}
comment|/* For an anchored pattern, we use the "required byte" only if it follows a variable length item in the regex. Remove the caseless flag for non-caseable bytes. */
if|if
condition|(
name|reqcharflags
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|==
literal|0
operator|||
operator|(
name|reqcharflags
operator|&
name|REQ_VARY
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|re
operator|->
name|req_char
operator|=
name|reqchar
operator|&
literal|0xff
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|re
operator|->
name|req_char
operator|=
name|reqchar
operator|&
literal|0xffff
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|re
operator|->
name|req_char
operator|=
name|reqchar
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|reqcharflags
operator|&
name|REQ_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
comment|/* We ignore non-ASCII first chars in 8 bit mode. */
if|if
condition|(
name|utf
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|req_char
operator|<
literal|128
condition|)
block|{
if|if
condition|(
name|cd
operator|->
name|fcc
index|[
name|re
operator|->
name|req_char
index|]
operator|!=
name|re
operator|->
name|req_char
condition|)
name|re
operator|->
name|flags
operator||=
name|PCRE_RCH_CASELESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UCD_OTHERCASE
argument_list|(
name|re
operator|->
name|req_char
argument_list|)
operator|!=
name|re
operator|->
name|req_char
condition|)
name|re
operator|->
name|flags
operator||=
name|PCRE_RCH_CASELESS
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|MAX_255
argument_list|(
name|re
operator|->
name|req_char
argument_list|)
operator|&&
name|cd
operator|->
name|fcc
index|[
name|re
operator|->
name|req_char
index|]
operator|!=
name|re
operator|->
name|req_char
condition|)
name|re
operator|->
name|flags
operator||=
name|PCRE_RCH_CASELESS
expr_stmt|;
block|}
name|re
operator|->
name|flags
operator||=
name|PCRE_REQCHSET
expr_stmt|;
block|}
comment|/* Print out the compiled data if debugging is enabled. This is never the case when building a production library. */
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|printf
argument_list|(
literal|"Length = %d top_bracket = %d top_backref = %d\n"
argument_list|,
name|length
argument_list|,
name|re
operator|->
name|top_bracket
argument_list|,
name|re
operator|->
name|top_backref
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options=%08x\n"
argument_list|,
name|re
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|pcre_uchar
name|ch
init|=
name|re
operator|->
name|first_char
decl_stmt|;
specifier|const
name|char
modifier|*
name|caseless
init|=
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FCH_CASELESS
operator|)
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
literal|" (caseless)"
decl_stmt|;
if|if
condition|(
name|PRINTABLE
argument_list|(
name|ch
argument_list|)
condition|)
name|printf
argument_list|(
literal|"First char = %c%s\n"
argument_list|,
name|ch
argument_list|,
name|caseless
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"First char = \\x%02x%s\n"
argument_list|,
name|ch
argument_list|,
name|caseless
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|pcre_uchar
name|ch
init|=
name|re
operator|->
name|req_char
decl_stmt|;
specifier|const
name|char
modifier|*
name|caseless
init|=
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_RCH_CASELESS
operator|)
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
literal|" (caseless)"
decl_stmt|;
if|if
condition|(
name|PRINTABLE
argument_list|(
name|ch
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Req char = %c%s\n"
argument_list|,
name|ch
argument_list|,
name|caseless
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Req char = \\x%02x%s\n"
argument_list|,
name|ch
argument_list|,
name|caseless
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|pcre_printint
argument_list|(
operator|(
name|pcre
operator|*
operator|)
name|re
argument_list|,
name|stdout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|pcre16_printint
argument_list|(
operator|(
name|pcre
operator|*
operator|)
name|re
argument_list|,
name|stdout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|pcre32_printint
argument_list|(
operator|(
name|pcre
operator|*
operator|)
name|re
argument_list|,
name|stdout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This check is done here in the debugging case so that the code that was compiled can be seen. */
if|if
condition|(
name|code
operator|-
name|codestart
operator|>
name|length
condition|)
block|{
operator|(
name|PUBL
argument_list|(
name|free
argument_list|)
operator|)
operator|(
name|re
operator|)
expr_stmt|;
operator|*
name|errorptr
operator|=
name|find_error_text
argument_list|(
name|ERR23
argument_list|)
expr_stmt|;
operator|*
name|erroroffset
operator|=
name|ptr
operator|-
operator|(
name|pcre_uchar
operator|*
operator|)
name|pattern
expr_stmt|;
if|if
condition|(
name|errorcodeptr
operator|!=
name|NULL
condition|)
operator|*
name|errorcodeptr
operator|=
name|ERR23
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* PCRE_DEBUG */
if|#
directive|if
name|defined
name|COMPILE_PCRE8
return|return
operator|(
name|pcre
operator|*
operator|)
name|re
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
return|return
operator|(
name|pcre16
operator|*
operator|)
name|re
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
return|return
operator|(
name|pcre32
operator|*
operator|)
name|re
return|;
endif|#
directive|endif
block|}
end_decl_stmt
begin_comment
comment|/* End of pcre_compile.c */
end_comment
end_unit
