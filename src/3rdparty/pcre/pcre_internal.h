begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2014 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This header contains definitions that are shared between the different modules, but which are not relevant to the exported API. This includes some functions whose names all begin with "_pcre_", "_pcre16_" or "_pcre32_" depending on the PRIV macro. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PCRE_INTERNAL_H
end_ifndef
begin_define
DECL|macro|PCRE_INTERNAL_H
define|#
directive|define
name|PCRE_INTERNAL_H
end_define
begin_comment
comment|/* Define PCRE_DEBUG to get debugging output on stdout. */
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_define
define|#
directive|define
name|PCRE_DEBUG
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PCRE is compiled as an 8 bit library if it is not requested otherwise. */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
name|COMPILE_PCRE16
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
end_if
begin_define
DECL|macro|COMPILE_PCRE8
define|#
directive|define
name|COMPILE_PCRE8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* If SUPPORT_UCP is defined, SUPPORT_UTF must also be defined. The "configure" script ensures this, but not everybody uses "configure". */
end_comment
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|SUPPORT_UTF
operator|)
end_if
begin_define
DECL|macro|SUPPORT_UTF
define|#
directive|define
name|SUPPORT_UTF
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* We define SUPPORT_UTF if SUPPORT_UTF8 is enabled for compatibility reasons with existing code. */
end_comment
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF8
operator|&&
operator|!
operator|(
name|defined
name|SUPPORT_UTF
operator|)
end_if
begin_define
DECL|macro|SUPPORT_UTF
define|#
directive|define
name|SUPPORT_UTF
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Fixme: SUPPORT_UTF8 should be eventually disappear from the code. Until then we define it if SUPPORT_UTF is defined. */
end_comment
begin_if
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
operator|(
name|defined
name|SUPPORT_UTF8
operator|)
end_if
begin_define
DECL|macro|SUPPORT_UTF8
define|#
directive|define
name|SUPPORT_UTF8
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* We do not support both EBCDIC and UTF-8/16/32 at the same time. The "configure" script prevents both being selected, but not everybody uses "configure". */
end_comment
begin_if
if|#
directive|if
name|defined
name|EBCDIC
operator|&&
name|defined
name|SUPPORT_UTF
end_if
begin_error
error|#
directive|error
error|The use of both EBCDIC and SUPPORT_UTF is not supported.
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Use a macro for debugging printing, 'cause that eliminates the use of #ifdef inline, and there are *still* stupid compilers about that don't like indented pre-processor statements, or at least there were when I first wrote this. After all, it had only been about 10 years then...  It turns out that the Mac Debugging.h header also defines the macro DPRINTF, so be absolutely sure we get our version. */
end_comment
begin_undef
DECL|macro|DPRINTF
undef|#
directive|undef
name|DPRINTF
end_undef
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_DEBUG
end_ifdef
begin_define
DECL|macro|DPRINTF
define|#
directive|define
name|DPRINTF
parameter_list|(
name|p
parameter_list|)
value|printf p
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DPRINTF
define|#
directive|define
name|DPRINTF
parameter_list|(
name|p
parameter_list|)
end_define
begin_comment
DECL|macro|DPRINTF
comment|/* Nothing */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Standard C headers plus the external interface definition. The only time setjmp and stdarg are used is when NO_RECURSE is set. */
end_comment
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/* Valgrind (memcheck) support */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_VALGRIND
end_ifdef
begin_include
include|#
directive|include
file|<valgrind/memcheck.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* When compiling a DLL for Windows, the exported symbols have to be declared using some MS magic. I found some useful information on this web page: http://msdn2.microsoft.com/en-us/library/y4h7bcy6(VS.80).aspx. According to the information there, using __declspec(dllexport) without "extern" we have a definition; with "extern" we have a declaration. The settings here override the setting in pcre.h (which is included below); it defines only PCRE_EXP_DECL, which is all that is needed for applications (they just import the symbols). We use:    PCRE_EXP_DECL       for declarations   PCRE_EXP_DEFN       for definitions of exported functions   PCRE_EXP_DATA_DEFN  for definitions of exported variables  The reason for the two DEFN macros is that in non-Windows environments, one does not want to have "extern" before variable definitions because it leads to compiler warnings. So we distinguish between functions and variables. In Windows, the two should always be the same.  The reason for wrapping this in #ifndef PCRE_EXP_DECL is so that pcretest, which is an application, but needs to import this file in order to "peek" at internals, can #include pcre.h first to get an application's-eye view.  In principle, people compiling for non-Windows, non-Unix-like (i.e. uncommon, special-purpose environments) might want to stick other stuff in front of exported symbols. That's why, in the non-Windows case, we set PCRE_EXP_DEFN and PCRE_EXP_DATA_DEFN only if they are not already set. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PCRE_EXP_DECL
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|PCRE_STATIC
end_ifndef
begin_define
DECL|macro|PCRE_EXP_DECL
define|#
directive|define
name|PCRE_EXP_DECL
value|extern __declspec(dllexport)
end_define
begin_define
DECL|macro|PCRE_EXP_DEFN
define|#
directive|define
name|PCRE_EXP_DEFN
value|__declspec(dllexport)
end_define
begin_define
DECL|macro|PCRE_EXP_DATA_DEFN
define|#
directive|define
name|PCRE_EXP_DATA_DEFN
value|__declspec(dllexport)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PCRE_EXP_DECL
define|#
directive|define
name|PCRE_EXP_DECL
value|extern
end_define
begin_define
DECL|macro|PCRE_EXP_DEFN
define|#
directive|define
name|PCRE_EXP_DEFN
end_define
begin_define
DECL|macro|PCRE_EXP_DATA_DEFN
define|#
directive|define
name|PCRE_EXP_DATA_DEFN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_define
DECL|macro|PCRE_EXP_DECL
define|#
directive|define
name|PCRE_EXP_DECL
value|extern "C"
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PCRE_EXP_DECL
define|#
directive|define
name|PCRE_EXP_DECL
value|extern
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PCRE_EXP_DEFN
end_ifndef
begin_define
DECL|macro|PCRE_EXP_DEFN
define|#
directive|define
name|PCRE_EXP_DEFN
value|PCRE_EXP_DECL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PCRE_EXP_DATA_DEFN
end_ifndef
begin_define
DECL|macro|PCRE_EXP_DATA_DEFN
define|#
directive|define
name|PCRE_EXP_DATA_DEFN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* When compiling with the MSVC compiler, it is sometimes necessary to include a "calling convention" before exported function names. (This is secondhand information; I know nothing about MSVC myself). For example, something like    void __cdecl function(....)  might be needed. In order so make this easy, all the exported functions have PCRE_CALL_CONVENTION just before their names. It is rarely needed; if not set, we ensure here that it has no effect. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PCRE_CALL_CONVENTION
end_ifndef
begin_define
DECL|macro|PCRE_CALL_CONVENTION
define|#
directive|define
name|PCRE_CALL_CONVENTION
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* We need to have types that specify unsigned 8, 16 and 32-bit integers. We cannot determine these outside the compilation (e.g. by running a program as part of "configure") because PCRE is often cross-compiled for use on other systems. Instead we make use of the maximum sizes that are available at preprocessor time in standard C environments. */
end_comment
begin_typedef
DECL|typedef|pcre_uint8
typedef|typedef
name|unsigned
name|char
name|pcre_uint8
typedef|;
end_typedef
begin_if
if|#
directive|if
name|USHRT_MAX
operator|==
literal|65535
end_if
begin_typedef
DECL|typedef|pcre_uint16
typedef|typedef
name|unsigned
name|short
name|pcre_uint16
typedef|;
end_typedef
begin_typedef
DECL|typedef|pcre_int16
typedef|typedef
name|short
name|pcre_int16
typedef|;
end_typedef
begin_define
DECL|macro|PCRE_UINT16_MAX
define|#
directive|define
name|PCRE_UINT16_MAX
value|USHRT_MAX
end_define
begin_define
DECL|macro|PCRE_INT16_MAX
define|#
directive|define
name|PCRE_INT16_MAX
value|SHRT_MAX
end_define
begin_elif
elif|#
directive|elif
name|UINT_MAX
operator|==
literal|65535
end_elif
begin_typedef
DECL|typedef|pcre_uint16
typedef|typedef
name|unsigned
name|int
name|pcre_uint16
typedef|;
end_typedef
begin_typedef
DECL|typedef|pcre_int16
typedef|typedef
name|int
name|pcre_int16
typedef|;
end_typedef
begin_define
DECL|macro|PCRE_UINT16_MAX
define|#
directive|define
name|PCRE_UINT16_MAX
value|UINT_MAX
end_define
begin_define
DECL|macro|PCRE_INT16_MAX
define|#
directive|define
name|PCRE_INT16_MAX
value|INT_MAX
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Cannot determine a type for 16-bit integers
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|UINT_MAX
operator|==
literal|4294967295U
end_if
begin_typedef
DECL|typedef|pcre_uint32
typedef|typedef
name|unsigned
name|int
name|pcre_uint32
typedef|;
end_typedef
begin_typedef
DECL|typedef|pcre_int32
typedef|typedef
name|int
name|pcre_int32
typedef|;
end_typedef
begin_define
DECL|macro|PCRE_UINT32_MAX
define|#
directive|define
name|PCRE_UINT32_MAX
value|UINT_MAX
end_define
begin_define
DECL|macro|PCRE_INT32_MAX
define|#
directive|define
name|PCRE_INT32_MAX
value|INT_MAX
end_define
begin_elif
elif|#
directive|elif
name|ULONG_MAX
operator|==
literal|4294967295UL
end_elif
begin_typedef
DECL|typedef|pcre_uint32
typedef|typedef
name|unsigned
name|long
name|int
name|pcre_uint32
typedef|;
end_typedef
begin_typedef
DECL|typedef|pcre_int32
typedef|typedef
name|long
name|int
name|pcre_int32
typedef|;
end_typedef
begin_define
DECL|macro|PCRE_UINT32_MAX
define|#
directive|define
name|PCRE_UINT32_MAX
value|ULONG_MAX
end_define
begin_define
DECL|macro|PCRE_INT32_MAX
define|#
directive|define
name|PCRE_INT32_MAX
value|LONG_MAX
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Cannot determine a type for 32-bit integers
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* When checking for integer overflow in pcre_compile(), we need to handle large integers. If a 64-bit integer type is available, we can use that. Otherwise we have to cast to double, which of course requires floating point arithmetic. Handle this by defining a macro for the appropriate type. If stdint.h is available, include it; it may define INT64_MAX. Systems that do not have stdint.h (e.g. Solaris) may have inttypes.h. The macro int64_t may be set by "configure". */
end_comment
begin_if
if|#
directive|if
name|defined
name|HAVE_STDINT_H
end_if
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_elif
elif|#
directive|elif
name|defined
name|HAVE_INTTYPES_H
end_elif
begin_include
include|#
directive|include
file|<inttypes.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
name|INT64_MAX
operator|||
name|defined
name|int64_t
end_if
begin_define
DECL|macro|INT64_OR_DOUBLE
define|#
directive|define
name|INT64_OR_DOUBLE
value|int64_t
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|INT64_OR_DOUBLE
define|#
directive|define
name|INT64_OR_DOUBLE
value|double
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* All character handling must be done as unsigned characters. Otherwise there are problems with top-bit-set characters and functions such as isspace(). However, we leave the interface to the outside world as char * or short *, because that should make things easier for callers. This character type is called pcre_uchar.  The IN_UCHARS macro multiply its argument with the byte size of the current pcre_uchar type. Useful for memcpy and such operations, whose require the byte size of their input/output buffers.  The MAX_255 macro checks whether its pcre_uchar input is less than 256.  The TABLE_GET macro is designed for accessing elements of tables whose contain exactly 256 items. When the character is able to contain more than 256 items, some check is needed before accessing these tables. */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_typedef
DECL|typedef|pcre_uchar
typedef|typedef
name|unsigned
name|char
name|pcre_uchar
typedef|;
end_typedef
begin_define
DECL|macro|IN_UCHARS
define|#
directive|define
name|IN_UCHARS
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define
begin_define
DECL|macro|MAX_255
define|#
directive|define
name|MAX_255
parameter_list|(
name|c
parameter_list|)
value|1
end_define
begin_define
DECL|macro|TABLE_GET
define|#
directive|define
name|TABLE_GET
parameter_list|(
name|c
parameter_list|,
name|table
parameter_list|,
define|default) ((table)[c])
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_if
if|#
directive|if
name|USHRT_MAX
operator|!=
literal|65535
end_if
begin_comment
comment|/* This is a warning message. Change PCRE_UCHAR16 to a 16 bit data type in pcre.h(.in) and disable (comment out) this message. */
end_comment
begin_error
error|#
directive|error
error|Warning: PCRE_UCHAR16 is not a 16 bit data type.
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|pcre_uchar
typedef|typedef
name|pcre_uint16
name|pcre_uchar
typedef|;
end_typedef
begin_define
DECL|macro|UCHAR_SHIFT
define|#
directive|define
name|UCHAR_SHIFT
value|(1)
end_define
begin_define
DECL|macro|IN_UCHARS
define|#
directive|define
name|IN_UCHARS
parameter_list|(
name|x
parameter_list|)
value|((x)<< UCHAR_SHIFT)
end_define
begin_define
DECL|macro|MAX_255
define|#
directive|define
name|MAX_255
parameter_list|(
name|c
parameter_list|)
value|((c)<= 255u)
end_define
begin_define
DECL|macro|TABLE_GET
define|#
directive|define
name|TABLE_GET
parameter_list|(
name|c
parameter_list|,
name|table
parameter_list|,
define|default) (MAX_255(c)? ((table)[c]):(default))
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_typedef
DECL|typedef|pcre_uchar
typedef|typedef
name|pcre_uint32
name|pcre_uchar
typedef|;
end_typedef
begin_define
DECL|macro|UCHAR_SHIFT
define|#
directive|define
name|UCHAR_SHIFT
value|(2)
end_define
begin_define
DECL|macro|IN_UCHARS
define|#
directive|define
name|IN_UCHARS
parameter_list|(
name|x
parameter_list|)
value|((x)<< UCHAR_SHIFT)
end_define
begin_define
DECL|macro|MAX_255
define|#
directive|define
name|MAX_255
parameter_list|(
name|c
parameter_list|)
value|((c)<= 255u)
end_define
begin_define
DECL|macro|TABLE_GET
define|#
directive|define
name|TABLE_GET
parameter_list|(
name|c
parameter_list|,
name|table
parameter_list|,
define|default) (MAX_255(c)? ((table)[c]):(default))
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Unsupported compiling mode
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16|32] */
end_comment
begin_comment
comment|/* This is an unsigned int value that no character can ever have. UTF-8 characters only go up to 0x7fffffff (though Unicode doesn't go beyond 0x0010ffff). */
end_comment
begin_define
DECL|macro|NOTACHAR
define|#
directive|define
name|NOTACHAR
value|0xffffffff
end_define
begin_comment
comment|/* PCRE is able to support several different kinds of newline (CR, LF, CRLF, "any" and "anycrlf" at present). The following macros are used to package up testing for newlines. NLBLOCK, PSSTART, and PSEND are defined in the various modules to indicate in which datablock the parameters exist, and what the start/end of string field names are. */
end_comment
begin_define
DECL|macro|NLTYPE_FIXED
define|#
directive|define
name|NLTYPE_FIXED
value|0
end_define
begin_comment
DECL|macro|NLTYPE_FIXED
comment|/* Newline is a fixed length string */
end_comment
begin_define
DECL|macro|NLTYPE_ANY
define|#
directive|define
name|NLTYPE_ANY
value|1
end_define
begin_comment
DECL|macro|NLTYPE_ANY
comment|/* Newline is any Unicode line ending */
end_comment
begin_define
DECL|macro|NLTYPE_ANYCRLF
define|#
directive|define
name|NLTYPE_ANYCRLF
value|2
end_define
begin_comment
DECL|macro|NLTYPE_ANYCRLF
comment|/* Newline is CR, LF, or CRLF */
end_comment
begin_comment
comment|/* This macro checks for a newline at the given position */
end_comment
begin_define
DECL|macro|IS_NEWLINE
define|#
directive|define
name|IS_NEWLINE
parameter_list|(
name|p
parameter_list|)
define|\
value|((NLBLOCK->nltype != NLTYPE_FIXED)? \     ((p)< NLBLOCK->PSEND&& \      PRIV(is_newline)((p), NLBLOCK->nltype, NLBLOCK->PSEND, \&(NLBLOCK->nllen), utf)) \     : \     ((p)<= NLBLOCK->PSEND - NLBLOCK->nllen&& \      UCHAR21TEST(p) == NLBLOCK->nl[0]&& \      (NLBLOCK->nllen == 1 || UCHAR21TEST(p+1) == NLBLOCK->nl[1])       \     ) \   )
end_define
begin_comment
comment|/* This macro checks for a newline immediately preceding the given position */
end_comment
begin_define
DECL|macro|WAS_NEWLINE
define|#
directive|define
name|WAS_NEWLINE
parameter_list|(
name|p
parameter_list|)
define|\
value|((NLBLOCK->nltype != NLTYPE_FIXED)? \     ((p)> NLBLOCK->PSSTART&& \      PRIV(was_newline)((p), NLBLOCK->nltype, NLBLOCK->PSSTART, \&(NLBLOCK->nllen), utf)) \     : \     ((p)>= NLBLOCK->PSSTART + NLBLOCK->nllen&& \      UCHAR21TEST(p - NLBLOCK->nllen) == NLBLOCK->nl[0]&&              \      (NLBLOCK->nllen == 1 || UCHAR21TEST(p - NLBLOCK->nllen + 1) == NLBLOCK->nl[1]) \     ) \   )
end_define
begin_comment
comment|/* When PCRE is compiled as a C++ library, the subject pointer can be replaced with a custom type. This makes it possible, for example, to allow pcre_exec() to process subject strings that are discontinuous by using a smart pointer class. It must always be possible to inspect all of the subject string in pcre_exec() because of the way it backtracks. Two macros are required in the normal case, for sign-unspecified and unsigned char pointers. The former is used for the external interface and appears in pcre.h, which is why its name must begin with PCRE_. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|CUSTOM_SUBJECT_PTR
end_ifdef
begin_define
DECL|macro|PCRE_PUCHAR
define|#
directive|define
name|PCRE_PUCHAR
value|CUSTOM_SUBJECT_PTR
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PCRE_PUCHAR
define|#
directive|define
name|PCRE_PUCHAR
value|const pcre_uchar *
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Include the public PCRE header and the definitions of UCP character property values. */
end_comment
begin_include
include|#
directive|include
file|"pcre.h"
end_include
begin_include
include|#
directive|include
file|"ucp.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE32
end_ifdef
begin_comment
comment|/* Assert that the public PCRE_UCHAR32 is a 32-bit type */
end_comment
begin_typedef
DECL|typedef|__assert_pcre_uchar32_size
typedef|typedef
name|int
name|__assert_pcre_uchar32_size
index|[
sizeof|sizeof
argument_list|(
name|PCRE_UCHAR32
argument_list|)
operator|==
literal|4
condition|?
literal|1
else|:
operator|-
literal|1
index|]
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* When compiling for use with the Virtual Pascal compiler, these functions need to have their names changed. PCRE must be compiled with the -DVPCOMPAT option on the command line. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|VPCOMPAT
end_ifdef
begin_define
DECL|macro|strlen
define|#
directive|define
name|strlen
parameter_list|(
name|s
parameter_list|)
value|_strlen(s)
end_define
begin_define
DECL|macro|strncmp
define|#
directive|define
name|strncmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|m
parameter_list|)
value|_strncmp(s1,s2,m)
end_define
begin_define
DECL|macro|memcmp
define|#
directive|define
name|memcmp
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
value|_memcmp(s,c,n)
end_define
begin_define
DECL|macro|memcpy
define|#
directive|define
name|memcpy
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|_memcpy(d,s,n)
end_define
begin_define
DECL|macro|memmove
define|#
directive|define
name|memmove
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|_memmove(d,s,n)
end_define
begin_define
DECL|macro|memset
define|#
directive|define
name|memset
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
value|_memset(s,c,n)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* VPCOMPAT */
end_comment
begin_comment
comment|/* To cope with SunOS4 and other systems that lack memmove() but have bcopy(), define a macro for memmove() if HAVE_MEMMOVE is false, provided that HAVE_BCOPY is set. Otherwise, include an emulating function for those systems that have neither (there some non-Unix environments where this is the case). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMMOVE
end_ifndef
begin_undef
DECL|macro|memmove
undef|#
directive|undef
name|memmove
end_undef
begin_comment
DECL|macro|memmove
comment|/* some systems may have a macro */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BCOPY
end_ifdef
begin_define
DECL|macro|memmove
define|#
directive|define
name|memmove
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|bcopy(b, a, c)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_BCOPY */
end_comment
begin_function
specifier|static
name|void
modifier|*
DECL|function|pcre_memmove
name|pcre_memmove
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
specifier|const
name|void
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|src
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s
decl_stmt|;
if|if
condition|(
name|dest
operator|>
name|src
condition|)
block|{
name|dest
operator|+=
name|n
expr_stmt|;
name|src
operator|+=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
operator|*
operator|(
operator|--
name|dest
operator|)
operator|=
operator|*
operator|(
operator|--
name|src
operator|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|dest
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|dest
operator|-
name|n
operator|)
return|;
block|}
block|}
end_function
begin_define
DECL|macro|memmove
define|#
directive|define
name|memmove
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|pcre_memmove(a, b, c)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* not HAVE_BCOPY */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* not HAVE_MEMMOVE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* not VPCOMPAT */
end_comment
begin_comment
comment|/* PCRE keeps offsets in its compiled code as 2-byte quantities (always stored in big-endian order) by default. These are used, for example, to link from the start of a subpattern to its alternatives and its end. The use of 2 bytes per offset limits the size of the compiled regex to around 64K, which is big enough for almost everybody. However, I received a request for an even bigger limit. For this reason, and also to make the code easier to maintain, the storing and loading of offsets from the byte string is now handled by the macros that are defined here.  The macros are controlled by the value of LINK_SIZE. This defaults to 2 in the config.h file, but can be overridden by using -D on the command line. This is automated on Unix systems via the "configure" command. */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_if
if|#
directive|if
name|LINK_SIZE
operator|==
literal|2
end_if
begin_define
DECL|macro|PUT
define|#
directive|define
name|PUT
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|(a[n] = (d)>> 8), \   (a[(n)+1] = (d)& 255)
end_define
begin_define
DECL|macro|GET
define|#
directive|define
name|GET
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|(((a)[n]<< 8) | (a)[(n)+1])
end_define
begin_define
DECL|macro|MAX_PATTERN_SIZE
define|#
directive|define
name|MAX_PATTERN_SIZE
value|(1<< 16)
end_define
begin_elif
elif|#
directive|elif
name|LINK_SIZE
operator|==
literal|3
end_elif
begin_define
DECL|macro|PUT
define|#
directive|define
name|PUT
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|(a[n] = (d)>> 16),    \   (a[(n)+1] = (d)>> 8), \   (a[(n)+2] = (d)& 255)
end_define
begin_define
DECL|macro|GET
define|#
directive|define
name|GET
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|(((a)[n]<< 16) | ((a)[(n)+1]<< 8) | (a)[(n)+2])
end_define
begin_define
DECL|macro|MAX_PATTERN_SIZE
define|#
directive|define
name|MAX_PATTERN_SIZE
value|(1<< 24)
end_define
begin_elif
elif|#
directive|elif
name|LINK_SIZE
operator|==
literal|4
end_elif
begin_define
DECL|macro|PUT
define|#
directive|define
name|PUT
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|(a[n] = (d)>> 24),     \   (a[(n)+1] = (d)>> 16), \   (a[(n)+2] = (d)>> 8),  \   (a[(n)+3] = (d)& 255)
end_define
begin_define
DECL|macro|GET
define|#
directive|define
name|GET
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|(((a)[n]<< 24) | ((a)[(n)+1]<< 16) | ((a)[(n)+2]<< 8) | (a)[(n)+3])
end_define
begin_comment
comment|/* Keep it positive */
end_comment
begin_define
DECL|macro|MAX_PATTERN_SIZE
define|#
directive|define
name|MAX_PATTERN_SIZE
value|(1<< 30)
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|LINK_SIZE must be either 2, 3, or 4
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_if
if|#
directive|if
name|LINK_SIZE
operator|==
literal|2
end_if
begin_comment
comment|/* Redefine LINK_SIZE as a multiple of sizeof(pcre_uchar) */
end_comment
begin_undef
DECL|macro|LINK_SIZE
undef|#
directive|undef
name|LINK_SIZE
end_undef
begin_define
DECL|macro|LINK_SIZE
define|#
directive|define
name|LINK_SIZE
value|1
end_define
begin_define
DECL|macro|PUT
define|#
directive|define
name|PUT
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|(a[n] = (d))
end_define
begin_define
DECL|macro|GET
define|#
directive|define
name|GET
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|(a[n])
end_define
begin_define
DECL|macro|MAX_PATTERN_SIZE
define|#
directive|define
name|MAX_PATTERN_SIZE
value|(1<< 16)
end_define
begin_elif
elif|#
directive|elif
name|LINK_SIZE
operator|==
literal|3
operator|||
name|LINK_SIZE
operator|==
literal|4
end_elif
begin_comment
comment|/* Redefine LINK_SIZE as a multiple of sizeof(pcre_uchar) */
end_comment
begin_undef
DECL|macro|LINK_SIZE
undef|#
directive|undef
name|LINK_SIZE
end_undef
begin_define
DECL|macro|LINK_SIZE
define|#
directive|define
name|LINK_SIZE
value|2
end_define
begin_define
DECL|macro|PUT
define|#
directive|define
name|PUT
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|(a[n] = (d)>> 16), \   (a[(n)+1] = (d)& 65535)
end_define
begin_define
DECL|macro|GET
define|#
directive|define
name|GET
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|(((a)[n]<< 16) | (a)[(n)+1])
end_define
begin_comment
comment|/* Keep it positive */
end_comment
begin_define
DECL|macro|MAX_PATTERN_SIZE
define|#
directive|define
name|MAX_PATTERN_SIZE
value|(1<< 30)
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|LINK_SIZE must be either 2, 3, or 4
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_comment
comment|/* Only supported LINK_SIZE is 4 */
end_comment
begin_comment
comment|/* Redefine LINK_SIZE as a multiple of sizeof(pcre_uchar) */
end_comment
begin_undef
DECL|macro|LINK_SIZE
undef|#
directive|undef
name|LINK_SIZE
end_undef
begin_define
DECL|macro|LINK_SIZE
define|#
directive|define
name|LINK_SIZE
value|1
end_define
begin_define
DECL|macro|PUT
define|#
directive|define
name|PUT
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|(a[n] = (d))
end_define
begin_define
DECL|macro|GET
define|#
directive|define
name|GET
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|(a[n])
end_define
begin_comment
comment|/* Keep it positive */
end_comment
begin_define
DECL|macro|MAX_PATTERN_SIZE
define|#
directive|define
name|MAX_PATTERN_SIZE
value|(1<< 30)
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Unsupported compiling mode
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16|32] */
end_comment
begin_comment
comment|/* Convenience macro defined in terms of the others */
end_comment
begin_define
DECL|macro|PUTINC
define|#
directive|define
name|PUTINC
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
value|PUT(a,n,d), a += LINK_SIZE
end_define
begin_comment
comment|/* PCRE uses some other 2-byte quantities that do not change when the size of offsets changes. There are used for repeat counts and for other things such as capturing parenthesis numbers in back references. */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_define
DECL|macro|IMM2_SIZE
define|#
directive|define
name|IMM2_SIZE
value|2
end_define
begin_define
DECL|macro|PUT2
define|#
directive|define
name|PUT2
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|a[n] = (d)>> 8; \   a[(n)+1] = (d)& 255
end_define
begin_comment
comment|/* For reasons that I do not understand, the expression in this GET2 macro is treated by gcc as a signed expression, even when a is declared as unsigned. It seems that any kind of arithmetic results in a signed value. */
end_comment
begin_define
DECL|macro|GET2
define|#
directive|define
name|GET2
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|(unsigned int)(((a)[n]<< 8) | (a)[(n)+1])
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_define
DECL|macro|IMM2_SIZE
define|#
directive|define
name|IMM2_SIZE
value|1
end_define
begin_define
DECL|macro|PUT2
define|#
directive|define
name|PUT2
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|a[n] = d
end_define
begin_define
DECL|macro|GET2
define|#
directive|define
name|GET2
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|a[n]
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_define
DECL|macro|IMM2_SIZE
define|#
directive|define
name|IMM2_SIZE
value|1
end_define
begin_define
DECL|macro|PUT2
define|#
directive|define
name|PUT2
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|a[n] = d
end_define
begin_define
DECL|macro|GET2
define|#
directive|define
name|GET2
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
define|\
value|a[n]
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Unsupported compiling mode
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16|32] */
end_comment
begin_define
DECL|macro|PUT2INC
define|#
directive|define
name|PUT2INC
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
value|PUT2(a,n,d), a += IMM2_SIZE
end_define
begin_comment
comment|/* The maximum length of a MARK name is currently one data unit; it may be changed in future to be a fixed number of bytes or to depend on LINK_SIZE. */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
end_if
begin_define
DECL|macro|MAX_MARK
define|#
directive|define
name|MAX_MARK
value|((1u<< 16) - 1)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|MAX_MARK
define|#
directive|define
name|MAX_MARK
value|((1u<< 8) - 1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* There is a proposed future special "UTF-21" mode, in which only the lowest 21 bits of a 32-bit character are interpreted as UTF, with the remaining 11 high-order bits available to the application for other uses. In preparation for the future implementation of this mode, there are macros that load a data item and, if in this special mode, mask it to 21 bits. These macros all have names starting with UCHAR21. In all other modes, including the normal 32-bit library, the macros all have the same simple definitions. When the new mode is implemented, it is expected that these definitions will be varied appropriately using #ifdef when compiling the library that supports the special mode. */
end_comment
begin_define
DECL|macro|UCHAR21
define|#
directive|define
name|UCHAR21
parameter_list|(
name|eptr
parameter_list|)
value|(*(eptr))
end_define
begin_define
DECL|macro|UCHAR21TEST
define|#
directive|define
name|UCHAR21TEST
parameter_list|(
name|eptr
parameter_list|)
value|(*(eptr))
end_define
begin_define
DECL|macro|UCHAR21INC
define|#
directive|define
name|UCHAR21INC
parameter_list|(
name|eptr
parameter_list|)
value|(*(eptr)++)
end_define
begin_define
DECL|macro|UCHAR21INCTEST
define|#
directive|define
name|UCHAR21INCTEST
parameter_list|(
name|eptr
parameter_list|)
value|(*(eptr)++)
end_define
begin_comment
comment|/* When UTF encoding is being used, a character is no longer just a single byte in 8-bit mode or a single short in 16-bit mode. The macros for character handling generate simple sequences when used in the basic mode, and more complicated ones for UTF characters. GETCHARLENTEST and other macros are not used when UTF is not supported. To make sure they can never even appear when UTF support is omitted, we don't even define them. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|SUPPORT_UTF
end_ifndef
begin_comment
comment|/* #define MAX_VALUE_FOR_SINGLE_CHAR */
end_comment
begin_comment
comment|/* #define HAS_EXTRALEN(c) */
end_comment
begin_comment
comment|/* #define GET_EXTRALEN(c) */
end_comment
begin_comment
comment|/* #define NOT_FIRSTCHAR(c) */
end_comment
begin_define
DECL|macro|GETCHAR
define|#
directive|define
name|GETCHAR
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
value|c = *eptr;
end_define
begin_define
DECL|macro|GETCHARTEST
define|#
directive|define
name|GETCHARTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
value|c = *eptr;
end_define
begin_define
DECL|macro|GETCHARINC
define|#
directive|define
name|GETCHARINC
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
value|c = *eptr++;
end_define
begin_define
DECL|macro|GETCHARINCTEST
define|#
directive|define
name|GETCHARINCTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
value|c = *eptr++;
end_define
begin_define
DECL|macro|GETCHARLEN
define|#
directive|define
name|GETCHARLEN
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
value|c = *eptr;
end_define
begin_comment
comment|/* #define GETCHARLENTEST(c, eptr, len) */
end_comment
begin_comment
comment|/* #define BACKCHAR(eptr) */
end_comment
begin_comment
comment|/* #define FORWARDCHAR(eptr) */
end_comment
begin_comment
comment|/* #define ACROSSCHAR(condition, eptr, action) */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SUPPORT_UTF */
end_comment
begin_comment
comment|/* Tests whether the code point needs extra characters to decode. */
end_comment
begin_define
DECL|macro|HASUTF8EXTRALEN
define|#
directive|define
name|HASUTF8EXTRALEN
parameter_list|(
name|c
parameter_list|)
value|((c)>= 0xc0)
end_define
begin_comment
comment|/* Base macro to pick up the remaining bytes of a UTF-8 character, not advancing the pointer. */
end_comment
begin_define
DECL|macro|GETUTF8
define|#
directive|define
name|GETUTF8
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|{ \     if ((c& 0x20) == 0) \       c = ((c& 0x1f)<< 6) | (eptr[1]& 0x3f); \     else if ((c& 0x10) == 0) \       c = ((c& 0x0f)<< 12) | ((eptr[1]& 0x3f)<< 6) | (eptr[2]& 0x3f); \     else if ((c& 0x08) == 0) \       c = ((c& 0x07)<< 18) | ((eptr[1]& 0x3f)<< 12) | \       ((eptr[2]& 0x3f)<< 6) | (eptr[3]& 0x3f); \     else if ((c& 0x04) == 0) \       c = ((c& 0x03)<< 24) | ((eptr[1]& 0x3f)<< 18) | \           ((eptr[2]& 0x3f)<< 12) | ((eptr[3]& 0x3f)<< 6) | \           (eptr[4]& 0x3f); \     else \       c = ((c& 0x01)<< 30) | ((eptr[1]& 0x3f)<< 24) | \           ((eptr[2]& 0x3f)<< 18) | ((eptr[3]& 0x3f)<< 12) | \           ((eptr[4]& 0x3f)<< 6) | (eptr[5]& 0x3f); \     }
end_define
begin_comment
comment|/* Base macro to pick up the remaining bytes of a UTF-8 character, advancing the pointer. */
end_comment
begin_define
DECL|macro|GETUTF8INC
define|#
directive|define
name|GETUTF8INC
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|{ \     if ((c& 0x20) == 0) \       c = ((c& 0x1f)<< 6) | (*eptr++& 0x3f); \     else if ((c& 0x10) == 0) \       { \       c = ((c& 0x0f)<< 12) | ((*eptr& 0x3f)<< 6) | (eptr[1]& 0x3f); \       eptr += 2; \       } \     else if ((c& 0x08) == 0) \       { \       c = ((c& 0x07)<< 18) | ((*eptr& 0x3f)<< 12) | \           ((eptr[1]& 0x3f)<< 6) | (eptr[2]& 0x3f); \       eptr += 3; \       } \     else if ((c& 0x04) == 0) \       { \       c = ((c& 0x03)<< 24) | ((*eptr& 0x3f)<< 18) | \           ((eptr[1]& 0x3f)<< 12) | ((eptr[2]& 0x3f)<< 6) | \           (eptr[3]& 0x3f); \       eptr += 4; \       } \     else \       { \       c = ((c& 0x01)<< 30) | ((*eptr& 0x3f)<< 24) | \           ((eptr[1]& 0x3f)<< 18) | ((eptr[2]& 0x3f)<< 12) | \           ((eptr[3]& 0x3f)<< 6) | (eptr[4]& 0x3f); \       eptr += 5; \       } \     }
end_define
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_comment
comment|/* These macros were originally written in the form of loops that used data from the tables whose names start with PRIV(utf8_table). They were rewritten by a user so as not to use loops, because in some environments this gives a significant performance advantage, and it seems never to do any harm. */
end_comment
begin_comment
comment|/* Tells the biggest code point which can be encoded as a single character. */
end_comment
begin_define
DECL|macro|MAX_VALUE_FOR_SINGLE_CHAR
define|#
directive|define
name|MAX_VALUE_FOR_SINGLE_CHAR
value|127
end_define
begin_comment
comment|/* Tests whether the code point needs extra characters to decode. */
end_comment
begin_define
DECL|macro|HAS_EXTRALEN
define|#
directive|define
name|HAS_EXTRALEN
parameter_list|(
name|c
parameter_list|)
value|((c)>= 0xc0)
end_define
begin_comment
comment|/* Returns with the additional number of characters if IS_MULTICHAR(c) is TRUE. Otherwise it has an undefined behaviour. */
end_comment
begin_define
DECL|macro|GET_EXTRALEN
define|#
directive|define
name|GET_EXTRALEN
parameter_list|(
name|c
parameter_list|)
value|(PRIV(utf8_table4)[(c)& 0x3f])
end_define
begin_comment
comment|/* Returns TRUE, if the given character is not the first character of a UTF sequence. */
end_comment
begin_define
DECL|macro|NOT_FIRSTCHAR
define|#
directive|define
name|NOT_FIRSTCHAR
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xc0) == 0x80)
end_define
begin_comment
comment|/* Get the next UTF-8 character, not advancing the pointer. This is called when we know we are in UTF-8 mode. */
end_comment
begin_define
DECL|macro|GETCHAR
define|#
directive|define
name|GETCHAR
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr; \   if (c>= 0xc0) GETUTF8(c, eptr);
end_define
begin_comment
comment|/* Get the next UTF-8 character, testing for UTF-8 mode, and not advancing the pointer. */
end_comment
begin_define
DECL|macro|GETCHARTEST
define|#
directive|define
name|GETCHARTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr; \   if (utf&& c>= 0xc0) GETUTF8(c, eptr);
end_define
begin_comment
comment|/* Get the next UTF-8 character, advancing the pointer. This is called when we know we are in UTF-8 mode. */
end_comment
begin_define
DECL|macro|GETCHARINC
define|#
directive|define
name|GETCHARINC
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr++; \   if (c>= 0xc0) GETUTF8INC(c, eptr);
end_define
begin_comment
comment|/* Get the next character, testing for UTF-8 mode, and advancing the pointer. This is called when we don't know if we are in UTF-8 mode. */
end_comment
begin_define
DECL|macro|GETCHARINCTEST
define|#
directive|define
name|GETCHARINCTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr++; \   if (utf&& c>= 0xc0) GETUTF8INC(c, eptr);
end_define
begin_comment
comment|/* Base macro to pick up the remaining bytes of a UTF-8 character, not advancing the pointer, incrementing the length. */
end_comment
begin_define
DECL|macro|GETUTF8LEN
define|#
directive|define
name|GETUTF8LEN
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|{ \     if ((c& 0x20) == 0) \       { \       c = ((c& 0x1f)<< 6) | (eptr[1]& 0x3f); \       len++; \       } \     else if ((c& 0x10)  == 0) \       { \       c = ((c& 0x0f)<< 12) | ((eptr[1]& 0x3f)<< 6) | (eptr[2]& 0x3f); \       len += 2; \       } \     else if ((c& 0x08)  == 0) \       {\       c = ((c& 0x07)<< 18) | ((eptr[1]& 0x3f)<< 12) | \           ((eptr[2]& 0x3f)<< 6) | (eptr[3]& 0x3f); \       len += 3; \       } \     else if ((c& 0x04)  == 0) \       { \       c = ((c& 0x03)<< 24) | ((eptr[1]& 0x3f)<< 18) | \           ((eptr[2]& 0x3f)<< 12) | ((eptr[3]& 0x3f)<< 6) | \           (eptr[4]& 0x3f); \       len += 4; \       } \     else \       {\       c = ((c& 0x01)<< 30) | ((eptr[1]& 0x3f)<< 24) | \           ((eptr[2]& 0x3f)<< 18) | ((eptr[3]& 0x3f)<< 12) | \           ((eptr[4]& 0x3f)<< 6) | (eptr[5]& 0x3f); \       len += 5; \       } \     }
end_define
begin_comment
comment|/* Get the next UTF-8 character, not advancing the pointer, incrementing length if there are extra bytes. This is called when we know we are in UTF-8 mode. */
end_comment
begin_define
DECL|macro|GETCHARLEN
define|#
directive|define
name|GETCHARLEN
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|c = *eptr; \   if (c>= 0xc0) GETUTF8LEN(c, eptr, len);
end_define
begin_comment
comment|/* Get the next UTF-8 character, testing for UTF-8 mode, not advancing the pointer, incrementing length if there are extra bytes. This is called when we do not know if we are in UTF-8 mode. */
end_comment
begin_define
DECL|macro|GETCHARLENTEST
define|#
directive|define
name|GETCHARLENTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|c = *eptr; \   if (utf&& c>= 0xc0) GETUTF8LEN(c, eptr, len);
end_define
begin_comment
comment|/* If the pointer is not at the start of a character, move it back until it is. This is called only in UTF-8 mode - we don't put a test within the macro because almost all calls are already within a block of UTF-8 only code. */
end_comment
begin_define
DECL|macro|BACKCHAR
define|#
directive|define
name|BACKCHAR
parameter_list|(
name|eptr
parameter_list|)
value|while((*eptr& 0xc0) == 0x80) eptr--
end_define
begin_comment
comment|/* Same as above, just in the other direction. */
end_comment
begin_define
DECL|macro|FORWARDCHAR
define|#
directive|define
name|FORWARDCHAR
parameter_list|(
name|eptr
parameter_list|)
value|while((*eptr& 0xc0) == 0x80) eptr++
end_define
begin_comment
comment|/* Same as above, but it allows a fully customizable form. */
end_comment
begin_define
DECL|macro|ACROSSCHAR
define|#
directive|define
name|ACROSSCHAR
parameter_list|(
name|condition
parameter_list|,
name|eptr
parameter_list|,
name|action
parameter_list|)
define|\
value|while((condition)&& ((eptr)& 0xc0) == 0x80) action
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_comment
comment|/* Tells the biggest code point which can be encoded as a single character. */
end_comment
begin_define
DECL|macro|MAX_VALUE_FOR_SINGLE_CHAR
define|#
directive|define
name|MAX_VALUE_FOR_SINGLE_CHAR
value|65535
end_define
begin_comment
comment|/* Tests whether the code point needs extra characters to decode. */
end_comment
begin_define
DECL|macro|HAS_EXTRALEN
define|#
directive|define
name|HAS_EXTRALEN
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xfc00) == 0xd800)
end_define
begin_comment
comment|/* Returns with the additional number of characters if IS_MULTICHAR(c) is TRUE. Otherwise it has an undefined behaviour. */
end_comment
begin_define
DECL|macro|GET_EXTRALEN
define|#
directive|define
name|GET_EXTRALEN
parameter_list|(
name|c
parameter_list|)
value|1
end_define
begin_comment
comment|/* Returns TRUE, if the given character is not the first character of a UTF sequence. */
end_comment
begin_define
DECL|macro|NOT_FIRSTCHAR
define|#
directive|define
name|NOT_FIRSTCHAR
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xfc00) == 0xdc00)
end_define
begin_comment
comment|/* Base macro to pick up the low surrogate of a UTF-16 character, not advancing the pointer. */
end_comment
begin_define
DECL|macro|GETUTF16
define|#
directive|define
name|GETUTF16
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|{ c = (((c& 0x3ff)<< 10) | (eptr[1]& 0x3ff)) + 0x10000; }
end_define
begin_comment
comment|/* Get the next UTF-16 character, not advancing the pointer. This is called when we know we are in UTF-16 mode. */
end_comment
begin_define
DECL|macro|GETCHAR
define|#
directive|define
name|GETCHAR
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr; \   if ((c& 0xfc00) == 0xd800) GETUTF16(c, eptr);
end_define
begin_comment
comment|/* Get the next UTF-16 character, testing for UTF-16 mode, and not advancing the pointer. */
end_comment
begin_define
DECL|macro|GETCHARTEST
define|#
directive|define
name|GETCHARTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr; \   if (utf&& (c& 0xfc00) == 0xd800) GETUTF16(c, eptr);
end_define
begin_comment
comment|/* Base macro to pick up the low surrogate of a UTF-16 character, advancing the pointer. */
end_comment
begin_define
DECL|macro|GETUTF16INC
define|#
directive|define
name|GETUTF16INC
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|{ c = (((c& 0x3ff)<< 10) | (*eptr++& 0x3ff)) + 0x10000; }
end_define
begin_comment
comment|/* Get the next UTF-16 character, advancing the pointer. This is called when we know we are in UTF-16 mode. */
end_comment
begin_define
DECL|macro|GETCHARINC
define|#
directive|define
name|GETCHARINC
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr++; \   if ((c& 0xfc00) == 0xd800) GETUTF16INC(c, eptr);
end_define
begin_comment
comment|/* Get the next character, testing for UTF-16 mode, and advancing the pointer. This is called when we don't know if we are in UTF-16 mode. */
end_comment
begin_define
DECL|macro|GETCHARINCTEST
define|#
directive|define
name|GETCHARINCTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *eptr++; \   if (utf&& (c& 0xfc00) == 0xd800) GETUTF16INC(c, eptr);
end_define
begin_comment
comment|/* Base macro to pick up the low surrogate of a UTF-16 character, not advancing the pointer, incrementing the length. */
end_comment
begin_define
DECL|macro|GETUTF16LEN
define|#
directive|define
name|GETUTF16LEN
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|{ c = (((c& 0x3ff)<< 10) | (eptr[1]& 0x3ff)) + 0x10000; len++; }
end_define
begin_comment
comment|/* Get the next UTF-16 character, not advancing the pointer, incrementing length if there is a low surrogate. This is called when we know we are in UTF-16 mode. */
end_comment
begin_define
DECL|macro|GETCHARLEN
define|#
directive|define
name|GETCHARLEN
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|c = *eptr; \   if ((c& 0xfc00) == 0xd800) GETUTF16LEN(c, eptr, len);
end_define
begin_comment
comment|/* Get the next UTF-816character, testing for UTF-16 mode, not advancing the pointer, incrementing length if there is a low surrogate. This is called when we do not know if we are in UTF-16 mode. */
end_comment
begin_define
DECL|macro|GETCHARLENTEST
define|#
directive|define
name|GETCHARLENTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|c = *eptr; \   if (utf&& (c& 0xfc00) == 0xd800) GETUTF16LEN(c, eptr, len);
end_define
begin_comment
comment|/* If the pointer is not at the start of a character, move it back until it is. This is called only in UTF-16 mode - we don't put a test within the macro because almost all calls are already within a block of UTF-16 only code. */
end_comment
begin_define
DECL|macro|BACKCHAR
define|#
directive|define
name|BACKCHAR
parameter_list|(
name|eptr
parameter_list|)
value|if ((*eptr& 0xfc00) == 0xdc00) eptr--
end_define
begin_comment
comment|/* Same as above, just in the other direction. */
end_comment
begin_define
DECL|macro|FORWARDCHAR
define|#
directive|define
name|FORWARDCHAR
parameter_list|(
name|eptr
parameter_list|)
value|if ((*eptr& 0xfc00) == 0xdc00) eptr++
end_define
begin_comment
comment|/* Same as above, but it allows a fully customizable form. */
end_comment
begin_define
DECL|macro|ACROSSCHAR
define|#
directive|define
name|ACROSSCHAR
parameter_list|(
name|condition
parameter_list|,
name|eptr
parameter_list|,
name|action
parameter_list|)
define|\
value|if ((condition)&& ((eptr)& 0xfc00) == 0xdc00) action
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_comment
comment|/* These are trivial for the 32-bit library, since all UTF-32 characters fit into one pcre_uchar unit. */
end_comment
begin_define
DECL|macro|MAX_VALUE_FOR_SINGLE_CHAR
define|#
directive|define
name|MAX_VALUE_FOR_SINGLE_CHAR
value|(0x10ffffu)
end_define
begin_define
DECL|macro|HAS_EXTRALEN
define|#
directive|define
name|HAS_EXTRALEN
parameter_list|(
name|c
parameter_list|)
value|(0)
end_define
begin_define
DECL|macro|GET_EXTRALEN
define|#
directive|define
name|GET_EXTRALEN
parameter_list|(
name|c
parameter_list|)
value|(0)
end_define
begin_define
DECL|macro|NOT_FIRSTCHAR
define|#
directive|define
name|NOT_FIRSTCHAR
parameter_list|(
name|c
parameter_list|)
value|(0)
end_define
begin_comment
comment|/* Get the next UTF-32 character, not advancing the pointer. This is called when we know we are in UTF-32 mode. */
end_comment
begin_define
DECL|macro|GETCHAR
define|#
directive|define
name|GETCHAR
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *(eptr);
end_define
begin_comment
comment|/* Get the next UTF-32 character, testing for UTF-32 mode, and not advancing the pointer. */
end_comment
begin_define
DECL|macro|GETCHARTEST
define|#
directive|define
name|GETCHARTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *(eptr);
end_define
begin_comment
comment|/* Get the next UTF-32 character, advancing the pointer. This is called when we know we are in UTF-32 mode. */
end_comment
begin_define
DECL|macro|GETCHARINC
define|#
directive|define
name|GETCHARINC
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *((eptr)++);
end_define
begin_comment
comment|/* Get the next character, testing for UTF-32 mode, and advancing the pointer. This is called when we don't know if we are in UTF-32 mode. */
end_comment
begin_define
DECL|macro|GETCHARINCTEST
define|#
directive|define
name|GETCHARINCTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|)
define|\
value|c = *((eptr)++);
end_define
begin_comment
comment|/* Get the next UTF-32 character, not advancing the pointer, not incrementing length (since all UTF-32 is of length 1). This is called when we know we are in UTF-32 mode. */
end_comment
begin_define
DECL|macro|GETCHARLEN
define|#
directive|define
name|GETCHARLEN
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|GETCHAR(c, eptr)
end_define
begin_comment
comment|/* Get the next UTF-32character, testing for UTF-32 mode, not advancing the pointer, not incrementing the length (since all UTF-32 is of length 1). This is called when we do not know if we are in UTF-32 mode. */
end_comment
begin_define
DECL|macro|GETCHARLENTEST
define|#
directive|define
name|GETCHARLENTEST
parameter_list|(
name|c
parameter_list|,
name|eptr
parameter_list|,
name|len
parameter_list|)
define|\
value|GETCHARTEST(c, eptr)
end_define
begin_comment
comment|/* If the pointer is not at the start of a character, move it back until it is. This is called only in UTF-32 mode - we don't put a test within the macro because almost all calls are already within a block of UTF-32 only code. These are all no-ops since all UTF-32 characters fit into one pcre_uchar. */
end_comment
begin_define
DECL|macro|BACKCHAR
define|#
directive|define
name|BACKCHAR
parameter_list|(
name|eptr
parameter_list|)
value|do { } while (0)
end_define
begin_comment
comment|/* Same as above, just in the other direction. */
end_comment
begin_define
DECL|macro|FORWARDCHAR
define|#
directive|define
name|FORWARDCHAR
parameter_list|(
name|eptr
parameter_list|)
value|do { } while (0)
end_define
begin_comment
comment|/* Same as above, but it allows a fully customizable form. */
end_comment
begin_define
DECL|macro|ACROSSCHAR
define|#
directive|define
name|ACROSSCHAR
parameter_list|(
name|condition
parameter_list|,
name|eptr
parameter_list|,
name|action
parameter_list|)
value|do { } while (0)
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Unsupported compiling mode
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16|32] */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UTF */
end_comment
begin_comment
comment|/* Tests for Unicode horizontal and vertical whitespace characters must check a number of different values. Using a switch statement for this generates the fastest code (no loop, no memory access), and there are several places in the interpreter code where this happens. In order to ensure that all the case lists remain in step, we use macros so that there is only one place where the lists are defined.  These values are also required as lists in pcre_compile.c when processing \h, \H, \v and \V in a character class. The lists are defined in pcre_tables.c, but macros that define the values are here so that all the definitions are together. The lists must be in ascending character order, terminated by NOTACHAR (which is 0xffffffff).  Any changes should ensure that the various macros are kept in step with each other. NOTE: The values also appear in pcre_jit_compile.c. */
end_comment
begin_comment
comment|/* ------ ASCII/Unicode environments ------ */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|EBCDIC
end_ifndef
begin_define
DECL|macro|HSPACE_LIST
define|#
directive|define
name|HSPACE_LIST
define|\
value|CHAR_HT, CHAR_SPACE, 0xa0, \   0x1680, 0x180e, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, \   0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202f, 0x205f, 0x3000, \   NOTACHAR
end_define
begin_define
DECL|macro|HSPACE_MULTIBYTE_CASES
define|#
directive|define
name|HSPACE_MULTIBYTE_CASES
define|\
value|case 0x1680:
comment|/* OGHAM SPACE MARK */
value|\   case 0x180e:
comment|/* MONGOLIAN VOWEL SEPARATOR */
value|\   case 0x2000:
comment|/* EN QUAD */
value|\   case 0x2001:
comment|/* EM QUAD */
value|\   case 0x2002:
comment|/* EN SPACE */
value|\   case 0x2003:
comment|/* EM SPACE */
value|\   case 0x2004:
comment|/* THREE-PER-EM SPACE */
value|\   case 0x2005:
comment|/* FOUR-PER-EM SPACE */
value|\   case 0x2006:
comment|/* SIX-PER-EM SPACE */
value|\   case 0x2007:
comment|/* FIGURE SPACE */
value|\   case 0x2008:
comment|/* PUNCTUATION SPACE */
value|\   case 0x2009:
comment|/* THIN SPACE */
value|\   case 0x200A:
comment|/* HAIR SPACE */
value|\   case 0x202f:
comment|/* NARROW NO-BREAK SPACE */
value|\   case 0x205f:
comment|/* MEDIUM MATHEMATICAL SPACE */
value|\   case 0x3000
end_define
begin_comment
comment|/* IDEOGRAPHIC SPACE */
end_comment
begin_define
DECL|macro|HSPACE_BYTE_CASES
define|#
directive|define
name|HSPACE_BYTE_CASES
define|\
value|case CHAR_HT: \   case CHAR_SPACE: \   case 0xa0
end_define
begin_comment
comment|/* NBSP */
end_comment
begin_define
DECL|macro|HSPACE_CASES
define|#
directive|define
name|HSPACE_CASES
define|\
value|HSPACE_BYTE_CASES: \   HSPACE_MULTIBYTE_CASES
end_define
begin_define
DECL|macro|VSPACE_LIST
define|#
directive|define
name|VSPACE_LIST
define|\
value|CHAR_LF, CHAR_VT, CHAR_FF, CHAR_CR, CHAR_NEL, 0x2028, 0x2029, NOTACHAR
end_define
begin_define
DECL|macro|VSPACE_MULTIBYTE_CASES
define|#
directive|define
name|VSPACE_MULTIBYTE_CASES
define|\
value|case 0x2028:
comment|/* LINE SEPARATOR */
value|\   case 0x2029
end_define
begin_comment
comment|/* PARAGRAPH SEPARATOR */
end_comment
begin_define
DECL|macro|VSPACE_BYTE_CASES
define|#
directive|define
name|VSPACE_BYTE_CASES
define|\
value|case CHAR_LF: \   case CHAR_VT: \   case CHAR_FF: \   case CHAR_CR: \   case CHAR_NEL
end_define
begin_define
DECL|macro|VSPACE_CASES
define|#
directive|define
name|VSPACE_CASES
define|\
value|VSPACE_BYTE_CASES: \   VSPACE_MULTIBYTE_CASES
end_define
begin_comment
comment|/* ------ EBCDIC environments ------ */
end_comment
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HSPACE_LIST
define|#
directive|define
name|HSPACE_LIST
value|CHAR_HT, CHAR_SPACE
end_define
begin_define
DECL|macro|HSPACE_BYTE_CASES
define|#
directive|define
name|HSPACE_BYTE_CASES
define|\
value|case CHAR_HT: \   case CHAR_SPACE
end_define
begin_define
DECL|macro|HSPACE_CASES
define|#
directive|define
name|HSPACE_CASES
value|HSPACE_BYTE_CASES
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|EBCDIC_NL25
end_ifdef
begin_define
DECL|macro|VSPACE_LIST
define|#
directive|define
name|VSPACE_LIST
define|\
value|CHAR_VT, CHAR_FF, CHAR_CR, CHAR_NEL, CHAR_LF, NOTACHAR
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|VSPACE_LIST
define|#
directive|define
name|VSPACE_LIST
define|\
value|CHAR_VT, CHAR_FF, CHAR_CR, CHAR_LF, CHAR_NEL, NOTACHAR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|VSPACE_BYTE_CASES
define|#
directive|define
name|VSPACE_BYTE_CASES
define|\
value|case CHAR_LF: \   case CHAR_VT: \   case CHAR_FF: \   case CHAR_CR: \   case CHAR_NEL
end_define
begin_define
DECL|macro|VSPACE_CASES
define|#
directive|define
name|VSPACE_CASES
value|VSPACE_BYTE_CASES
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* EBCDIC */
end_comment
begin_comment
comment|/* ------ End of whitespace macros ------ */
end_comment
begin_comment
comment|/* Private flags containing information about the compiled regex. They used to live at the top end of the options word, but that got almost full, so they were moved to a 16-bit flags word - which got almost full, so now they are in a 32-bit flags word. From release 8.00, PCRE_NOPARTIAL is unused, as the restrictions on partial matching have been lifted. It remains for backwards compatibility. */
end_comment
begin_define
DECL|macro|PCRE_MODE8
define|#
directive|define
name|PCRE_MODE8
value|0x00000001
end_define
begin_comment
DECL|macro|PCRE_MODE8
comment|/* compiled in 8 bit mode */
end_comment
begin_define
DECL|macro|PCRE_MODE16
define|#
directive|define
name|PCRE_MODE16
value|0x00000002
end_define
begin_comment
DECL|macro|PCRE_MODE16
comment|/* compiled in 16 bit mode */
end_comment
begin_define
DECL|macro|PCRE_MODE32
define|#
directive|define
name|PCRE_MODE32
value|0x00000004
end_define
begin_comment
DECL|macro|PCRE_MODE32
comment|/* compiled in 32 bit mode */
end_comment
begin_define
DECL|macro|PCRE_FIRSTSET
define|#
directive|define
name|PCRE_FIRSTSET
value|0x00000010
end_define
begin_comment
DECL|macro|PCRE_FIRSTSET
comment|/* first_char is set */
end_comment
begin_define
DECL|macro|PCRE_FCH_CASELESS
define|#
directive|define
name|PCRE_FCH_CASELESS
value|0x00000020
end_define
begin_comment
DECL|macro|PCRE_FCH_CASELESS
comment|/* caseless first char */
end_comment
begin_define
DECL|macro|PCRE_REQCHSET
define|#
directive|define
name|PCRE_REQCHSET
value|0x00000040
end_define
begin_comment
DECL|macro|PCRE_REQCHSET
comment|/* req_byte is set */
end_comment
begin_define
DECL|macro|PCRE_RCH_CASELESS
define|#
directive|define
name|PCRE_RCH_CASELESS
value|0x00000080
end_define
begin_comment
DECL|macro|PCRE_RCH_CASELESS
comment|/* caseless requested char */
end_comment
begin_define
DECL|macro|PCRE_STARTLINE
define|#
directive|define
name|PCRE_STARTLINE
value|0x00000100
end_define
begin_comment
DECL|macro|PCRE_STARTLINE
comment|/* start after \n for multiline */
end_comment
begin_define
DECL|macro|PCRE_NOPARTIAL
define|#
directive|define
name|PCRE_NOPARTIAL
value|0x00000200
end_define
begin_comment
DECL|macro|PCRE_NOPARTIAL
comment|/* can't use partial with this regex */
end_comment
begin_define
DECL|macro|PCRE_JCHANGED
define|#
directive|define
name|PCRE_JCHANGED
value|0x00000400
end_define
begin_comment
DECL|macro|PCRE_JCHANGED
comment|/* j option used in regex */
end_comment
begin_define
DECL|macro|PCRE_HASCRORLF
define|#
directive|define
name|PCRE_HASCRORLF
value|0x00000800
end_define
begin_comment
DECL|macro|PCRE_HASCRORLF
comment|/* explicit \r or \n in pattern */
end_comment
begin_define
DECL|macro|PCRE_HASTHEN
define|#
directive|define
name|PCRE_HASTHEN
value|0x00001000
end_define
begin_comment
DECL|macro|PCRE_HASTHEN
comment|/* pattern contains (*THEN) */
end_comment
begin_define
DECL|macro|PCRE_MLSET
define|#
directive|define
name|PCRE_MLSET
value|0x00002000
end_define
begin_comment
DECL|macro|PCRE_MLSET
comment|/* match limit set by regex */
end_comment
begin_define
DECL|macro|PCRE_RLSET
define|#
directive|define
name|PCRE_RLSET
value|0x00004000
end_define
begin_comment
DECL|macro|PCRE_RLSET
comment|/* recursion limit set by regex */
end_comment
begin_define
DECL|macro|PCRE_MATCH_EMPTY
define|#
directive|define
name|PCRE_MATCH_EMPTY
value|0x00008000
end_define
begin_comment
DECL|macro|PCRE_MATCH_EMPTY
comment|/* pattern can match empty string */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_define
DECL|macro|PCRE_MODE
define|#
directive|define
name|PCRE_MODE
value|PCRE_MODE8
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_define
DECL|macro|PCRE_MODE
define|#
directive|define
name|PCRE_MODE
value|PCRE_MODE16
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_define
DECL|macro|PCRE_MODE
define|#
directive|define
name|PCRE_MODE
value|PCRE_MODE32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|PCRE_MODE_MASK
define|#
directive|define
name|PCRE_MODE_MASK
value|(PCRE_MODE8 | PCRE_MODE16 | PCRE_MODE32)
end_define
begin_comment
comment|/* Flags for the "extra" block produced by pcre_study(). */
end_comment
begin_define
DECL|macro|PCRE_STUDY_MAPPED
define|#
directive|define
name|PCRE_STUDY_MAPPED
value|0x0001
end_define
begin_comment
DECL|macro|PCRE_STUDY_MAPPED
comment|/* a map of starting chars exists */
end_comment
begin_define
DECL|macro|PCRE_STUDY_MINLEN
define|#
directive|define
name|PCRE_STUDY_MINLEN
value|0x0002
end_define
begin_comment
DECL|macro|PCRE_STUDY_MINLEN
comment|/* a minimum length field exists */
end_comment
begin_comment
comment|/* Masks for identifying the public options that are permitted at compile time, run time, or study time, respectively. */
end_comment
begin_define
DECL|macro|PCRE_NEWLINE_BITS
define|#
directive|define
name|PCRE_NEWLINE_BITS
value|(PCRE_NEWLINE_CR|PCRE_NEWLINE_LF|PCRE_NEWLINE_ANY| \                            PCRE_NEWLINE_ANYCRLF)
end_define
begin_define
DECL|macro|PUBLIC_COMPILE_OPTIONS
define|#
directive|define
name|PUBLIC_COMPILE_OPTIONS
define|\
value|(PCRE_CASELESS|PCRE_EXTENDED|PCRE_ANCHORED|PCRE_MULTILINE| \    PCRE_DOTALL|PCRE_DOLLAR_ENDONLY|PCRE_EXTRA|PCRE_UNGREEDY|PCRE_UTF8| \    PCRE_NO_AUTO_CAPTURE|PCRE_NO_AUTO_POSSESS| \    PCRE_NO_UTF8_CHECK|PCRE_AUTO_CALLOUT|PCRE_FIRSTLINE| \    PCRE_DUPNAMES|PCRE_NEWLINE_BITS|PCRE_BSR_ANYCRLF|PCRE_BSR_UNICODE| \    PCRE_JAVASCRIPT_COMPAT|PCRE_UCP|PCRE_NO_START_OPTIMIZE|PCRE_NEVER_UTF)
end_define
begin_define
DECL|macro|PUBLIC_EXEC_OPTIONS
define|#
directive|define
name|PUBLIC_EXEC_OPTIONS
define|\
value|(PCRE_ANCHORED|PCRE_NOTBOL|PCRE_NOTEOL|PCRE_NOTEMPTY|PCRE_NOTEMPTY_ATSTART| \    PCRE_NO_UTF8_CHECK|PCRE_PARTIAL_HARD|PCRE_PARTIAL_SOFT|PCRE_NEWLINE_BITS| \    PCRE_BSR_ANYCRLF|PCRE_BSR_UNICODE|PCRE_NO_START_OPTIMIZE)
end_define
begin_define
DECL|macro|PUBLIC_DFA_EXEC_OPTIONS
define|#
directive|define
name|PUBLIC_DFA_EXEC_OPTIONS
define|\
value|(PCRE_ANCHORED|PCRE_NOTBOL|PCRE_NOTEOL|PCRE_NOTEMPTY|PCRE_NOTEMPTY_ATSTART| \    PCRE_NO_UTF8_CHECK|PCRE_PARTIAL_HARD|PCRE_PARTIAL_SOFT|PCRE_DFA_SHORTEST| \    PCRE_DFA_RESTART|PCRE_NEWLINE_BITS|PCRE_BSR_ANYCRLF|PCRE_BSR_UNICODE| \    PCRE_NO_START_OPTIMIZE)
end_define
begin_define
DECL|macro|PUBLIC_STUDY_OPTIONS
define|#
directive|define
name|PUBLIC_STUDY_OPTIONS
define|\
value|(PCRE_STUDY_JIT_COMPILE|PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE| \     PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE|PCRE_STUDY_EXTRA_NEEDED)
end_define
begin_define
DECL|macro|PUBLIC_JIT_EXEC_OPTIONS
define|#
directive|define
name|PUBLIC_JIT_EXEC_OPTIONS
define|\
value|(PCRE_NO_UTF8_CHECK|PCRE_NOTBOL|PCRE_NOTEOL|PCRE_NOTEMPTY|\     PCRE_NOTEMPTY_ATSTART|PCRE_PARTIAL_SOFT|PCRE_PARTIAL_HARD)
end_define
begin_comment
comment|/* Magic number to provide a small check against being handed junk. */
end_comment
begin_define
DECL|macro|MAGIC_NUMBER
define|#
directive|define
name|MAGIC_NUMBER
value|0x50435245UL
end_define
begin_comment
DECL|macro|MAGIC_NUMBER
comment|/* 'PCRE' */
end_comment
begin_comment
comment|/* This variable is used to detect a loaded regular expression in different endianness. */
end_comment
begin_define
DECL|macro|REVERSED_MAGIC_NUMBER
define|#
directive|define
name|REVERSED_MAGIC_NUMBER
value|0x45524350UL
end_define
begin_comment
DECL|macro|REVERSED_MAGIC_NUMBER
comment|/* 'ERCP' */
end_comment
begin_comment
comment|/* The maximum remaining length of subject we are prepared to search for a req_byte match. */
end_comment
begin_define
DECL|macro|REQ_BYTE_MAX
define|#
directive|define
name|REQ_BYTE_MAX
value|1000
end_define
begin_comment
comment|/* Miscellaneous definitions. The #ifndef is to pacify compiler warnings in environments where these macros are defined elsewhere. Unfortunately, there is no way to do the same for the typedef. */
end_comment
begin_typedef
DECL|typedef|BOOL
typedef|typedef
name|int
name|BOOL
typedef|;
end_typedef
begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef
begin_define
DECL|macro|FALSE
define|#
directive|define
name|FALSE
value|0
end_define
begin_define
DECL|macro|TRUE
define|#
directive|define
name|TRUE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* If PCRE is to support UTF-8 on EBCDIC platforms, we cannot use normal character constants like '*' because the compiler would emit their EBCDIC code, which is different from their ASCII/UTF-8 code. Instead we define macros for the characters so that they always use the ASCII/UTF-8 code when UTF-8 support is enabled. When UTF-8 support is not enabled, the definitions use character literals. Both character and string versions of each character are needed, and there are some longer strings as well.  This means that, on EBCDIC platforms, the PCRE library can handle either EBCDIC, or UTF-8, but not both. To support both in the same compiled library would need different lookups depending on whether PCRE_UTF8 was set or not. This would make it impossible to use characters in switch/case statements, which would reduce performance. For a theoretical use (which nobody has asked for) in a minority area (EBCDIC platforms), this is not sensible. Any application that did need both could compile two versions of the library, using macros to give the functions distinct names. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|SUPPORT_UTF
end_ifndef
begin_comment
comment|/* UTF-8 support is not enabled; use the platform-dependent character literals so that PCRE works in both ASCII and EBCDIC environments, but only in non-UTF mode. Newline characters are problematic in EBCDIC. Though it has CR and LF characters, a common practice has been to use its NL (0x15) character as the line terminator in C-like processing environments. However, sometimes the LF (0x25) character is used instead, according to this Unicode document:  http://unicode.org/standard/reports/tr13/tr13-5.html  PCRE defaults EBCDIC NL to 0x15, but has a build-time option to select 0x25 instead. Whichever is *not* chosen is defined as NEL.  In both ASCII and EBCDIC environments, CHAR_NL and CHAR_LF are synonyms for the same code point. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|EBCDIC
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|EBCDIC_NL25
end_ifndef
begin_define
DECL|macro|CHAR_NL
define|#
directive|define
name|CHAR_NL
value|'\x15'
end_define
begin_define
DECL|macro|CHAR_NEL
define|#
directive|define
name|CHAR_NEL
value|'\x25'
end_define
begin_define
DECL|macro|STR_NL
define|#
directive|define
name|STR_NL
value|"\x15"
end_define
begin_define
DECL|macro|STR_NEL
define|#
directive|define
name|STR_NEL
value|"\x25"
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|CHAR_NL
define|#
directive|define
name|CHAR_NL
value|'\x25'
end_define
begin_define
DECL|macro|CHAR_NEL
define|#
directive|define
name|CHAR_NEL
value|'\x15'
end_define
begin_define
DECL|macro|STR_NL
define|#
directive|define
name|STR_NL
value|"\x25"
end_define
begin_define
DECL|macro|STR_NEL
define|#
directive|define
name|STR_NEL
value|"\x15"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|CHAR_LF
define|#
directive|define
name|CHAR_LF
value|CHAR_NL
end_define
begin_define
DECL|macro|STR_LF
define|#
directive|define
name|STR_LF
value|STR_NL
end_define
begin_define
DECL|macro|CHAR_ESC
define|#
directive|define
name|CHAR_ESC
value|'\047'
end_define
begin_define
DECL|macro|CHAR_DEL
define|#
directive|define
name|CHAR_DEL
value|'\007'
end_define
begin_define
DECL|macro|STR_ESC
define|#
directive|define
name|STR_ESC
value|"\047"
end_define
begin_define
DECL|macro|STR_DEL
define|#
directive|define
name|STR_DEL
value|"\007"
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Not EBCDIC */
end_comment
begin_comment
comment|/* In ASCII/Unicode, linefeed is '\n' and we equate this to NL for compatibility. NEL is the Unicode newline character; make sure it is a positive value. */
end_comment
begin_define
DECL|macro|CHAR_LF
define|#
directive|define
name|CHAR_LF
value|'\n'
end_define
begin_define
DECL|macro|CHAR_NL
define|#
directive|define
name|CHAR_NL
value|CHAR_LF
end_define
begin_define
DECL|macro|CHAR_NEL
define|#
directive|define
name|CHAR_NEL
value|((unsigned char)'\x85')
end_define
begin_define
DECL|macro|CHAR_ESC
define|#
directive|define
name|CHAR_ESC
value|'\033'
end_define
begin_define
DECL|macro|CHAR_DEL
define|#
directive|define
name|CHAR_DEL
value|'\177'
end_define
begin_define
DECL|macro|STR_LF
define|#
directive|define
name|STR_LF
value|"\n"
end_define
begin_define
DECL|macro|STR_NL
define|#
directive|define
name|STR_NL
value|STR_LF
end_define
begin_define
DECL|macro|STR_NEL
define|#
directive|define
name|STR_NEL
value|"\x85"
end_define
begin_define
DECL|macro|STR_ESC
define|#
directive|define
name|STR_ESC
value|"\033"
end_define
begin_define
DECL|macro|STR_DEL
define|#
directive|define
name|STR_DEL
value|"\177"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* EBCDIC */
end_comment
begin_comment
comment|/* The remaining definitions work in both environments. */
end_comment
begin_define
DECL|macro|CHAR_NULL
define|#
directive|define
name|CHAR_NULL
value|'\0'
end_define
begin_define
DECL|macro|CHAR_HT
define|#
directive|define
name|CHAR_HT
value|'\t'
end_define
begin_define
DECL|macro|CHAR_VT
define|#
directive|define
name|CHAR_VT
value|'\v'
end_define
begin_define
DECL|macro|CHAR_FF
define|#
directive|define
name|CHAR_FF
value|'\f'
end_define
begin_define
DECL|macro|CHAR_CR
define|#
directive|define
name|CHAR_CR
value|'\r'
end_define
begin_define
DECL|macro|CHAR_BS
define|#
directive|define
name|CHAR_BS
value|'\b'
end_define
begin_define
DECL|macro|CHAR_BEL
define|#
directive|define
name|CHAR_BEL
value|'\a'
end_define
begin_define
DECL|macro|CHAR_SPACE
define|#
directive|define
name|CHAR_SPACE
value|' '
end_define
begin_define
DECL|macro|CHAR_EXCLAMATION_MARK
define|#
directive|define
name|CHAR_EXCLAMATION_MARK
value|'!'
end_define
begin_define
DECL|macro|CHAR_QUOTATION_MARK
define|#
directive|define
name|CHAR_QUOTATION_MARK
value|'"'
end_define
begin_define
DECL|macro|CHAR_NUMBER_SIGN
define|#
directive|define
name|CHAR_NUMBER_SIGN
value|'#'
end_define
begin_define
DECL|macro|CHAR_DOLLAR_SIGN
define|#
directive|define
name|CHAR_DOLLAR_SIGN
value|'$'
end_define
begin_define
DECL|macro|CHAR_PERCENT_SIGN
define|#
directive|define
name|CHAR_PERCENT_SIGN
value|'%'
end_define
begin_define
DECL|macro|CHAR_AMPERSAND
define|#
directive|define
name|CHAR_AMPERSAND
value|'&'
end_define
begin_define
DECL|macro|CHAR_APOSTROPHE
define|#
directive|define
name|CHAR_APOSTROPHE
value|'\''
end_define
begin_define
DECL|macro|CHAR_LEFT_PARENTHESIS
define|#
directive|define
name|CHAR_LEFT_PARENTHESIS
value|'('
end_define
begin_define
DECL|macro|CHAR_RIGHT_PARENTHESIS
define|#
directive|define
name|CHAR_RIGHT_PARENTHESIS
value|')'
end_define
begin_define
DECL|macro|CHAR_ASTERISK
define|#
directive|define
name|CHAR_ASTERISK
value|'*'
end_define
begin_define
DECL|macro|CHAR_PLUS
define|#
directive|define
name|CHAR_PLUS
value|'+'
end_define
begin_define
DECL|macro|CHAR_COMMA
define|#
directive|define
name|CHAR_COMMA
value|','
end_define
begin_define
DECL|macro|CHAR_MINUS
define|#
directive|define
name|CHAR_MINUS
value|'-'
end_define
begin_define
DECL|macro|CHAR_DOT
define|#
directive|define
name|CHAR_DOT
value|'.'
end_define
begin_define
DECL|macro|CHAR_SLASH
define|#
directive|define
name|CHAR_SLASH
value|'/'
end_define
begin_define
DECL|macro|CHAR_0
define|#
directive|define
name|CHAR_0
value|'0'
end_define
begin_define
DECL|macro|CHAR_1
define|#
directive|define
name|CHAR_1
value|'1'
end_define
begin_define
DECL|macro|CHAR_2
define|#
directive|define
name|CHAR_2
value|'2'
end_define
begin_define
DECL|macro|CHAR_3
define|#
directive|define
name|CHAR_3
value|'3'
end_define
begin_define
DECL|macro|CHAR_4
define|#
directive|define
name|CHAR_4
value|'4'
end_define
begin_define
DECL|macro|CHAR_5
define|#
directive|define
name|CHAR_5
value|'5'
end_define
begin_define
DECL|macro|CHAR_6
define|#
directive|define
name|CHAR_6
value|'6'
end_define
begin_define
DECL|macro|CHAR_7
define|#
directive|define
name|CHAR_7
value|'7'
end_define
begin_define
DECL|macro|CHAR_8
define|#
directive|define
name|CHAR_8
value|'8'
end_define
begin_define
DECL|macro|CHAR_9
define|#
directive|define
name|CHAR_9
value|'9'
end_define
begin_define
DECL|macro|CHAR_COLON
define|#
directive|define
name|CHAR_COLON
value|':'
end_define
begin_define
DECL|macro|CHAR_SEMICOLON
define|#
directive|define
name|CHAR_SEMICOLON
value|';'
end_define
begin_define
DECL|macro|CHAR_LESS_THAN_SIGN
define|#
directive|define
name|CHAR_LESS_THAN_SIGN
value|'<'
end_define
begin_define
DECL|macro|CHAR_EQUALS_SIGN
define|#
directive|define
name|CHAR_EQUALS_SIGN
value|'='
end_define
begin_define
DECL|macro|CHAR_GREATER_THAN_SIGN
define|#
directive|define
name|CHAR_GREATER_THAN_SIGN
value|'>'
end_define
begin_define
DECL|macro|CHAR_QUESTION_MARK
define|#
directive|define
name|CHAR_QUESTION_MARK
value|'?'
end_define
begin_define
DECL|macro|CHAR_COMMERCIAL_AT
define|#
directive|define
name|CHAR_COMMERCIAL_AT
value|'@'
end_define
begin_define
DECL|macro|CHAR_A
define|#
directive|define
name|CHAR_A
value|'A'
end_define
begin_define
DECL|macro|CHAR_B
define|#
directive|define
name|CHAR_B
value|'B'
end_define
begin_define
DECL|macro|CHAR_C
define|#
directive|define
name|CHAR_C
value|'C'
end_define
begin_define
DECL|macro|CHAR_D
define|#
directive|define
name|CHAR_D
value|'D'
end_define
begin_define
DECL|macro|CHAR_E
define|#
directive|define
name|CHAR_E
value|'E'
end_define
begin_define
DECL|macro|CHAR_F
define|#
directive|define
name|CHAR_F
value|'F'
end_define
begin_define
DECL|macro|CHAR_G
define|#
directive|define
name|CHAR_G
value|'G'
end_define
begin_define
DECL|macro|CHAR_H
define|#
directive|define
name|CHAR_H
value|'H'
end_define
begin_define
DECL|macro|CHAR_I
define|#
directive|define
name|CHAR_I
value|'I'
end_define
begin_define
DECL|macro|CHAR_J
define|#
directive|define
name|CHAR_J
value|'J'
end_define
begin_define
DECL|macro|CHAR_K
define|#
directive|define
name|CHAR_K
value|'K'
end_define
begin_define
DECL|macro|CHAR_L
define|#
directive|define
name|CHAR_L
value|'L'
end_define
begin_define
DECL|macro|CHAR_M
define|#
directive|define
name|CHAR_M
value|'M'
end_define
begin_define
DECL|macro|CHAR_N
define|#
directive|define
name|CHAR_N
value|'N'
end_define
begin_define
DECL|macro|CHAR_O
define|#
directive|define
name|CHAR_O
value|'O'
end_define
begin_define
DECL|macro|CHAR_P
define|#
directive|define
name|CHAR_P
value|'P'
end_define
begin_define
DECL|macro|CHAR_Q
define|#
directive|define
name|CHAR_Q
value|'Q'
end_define
begin_define
DECL|macro|CHAR_R
define|#
directive|define
name|CHAR_R
value|'R'
end_define
begin_define
DECL|macro|CHAR_S
define|#
directive|define
name|CHAR_S
value|'S'
end_define
begin_define
DECL|macro|CHAR_T
define|#
directive|define
name|CHAR_T
value|'T'
end_define
begin_define
DECL|macro|CHAR_U
define|#
directive|define
name|CHAR_U
value|'U'
end_define
begin_define
DECL|macro|CHAR_V
define|#
directive|define
name|CHAR_V
value|'V'
end_define
begin_define
DECL|macro|CHAR_W
define|#
directive|define
name|CHAR_W
value|'W'
end_define
begin_define
DECL|macro|CHAR_X
define|#
directive|define
name|CHAR_X
value|'X'
end_define
begin_define
DECL|macro|CHAR_Y
define|#
directive|define
name|CHAR_Y
value|'Y'
end_define
begin_define
DECL|macro|CHAR_Z
define|#
directive|define
name|CHAR_Z
value|'Z'
end_define
begin_define
DECL|macro|CHAR_LEFT_SQUARE_BRACKET
define|#
directive|define
name|CHAR_LEFT_SQUARE_BRACKET
value|'['
end_define
begin_define
DECL|macro|CHAR_BACKSLASH
define|#
directive|define
name|CHAR_BACKSLASH
value|'\\'
end_define
begin_define
DECL|macro|CHAR_RIGHT_SQUARE_BRACKET
define|#
directive|define
name|CHAR_RIGHT_SQUARE_BRACKET
value|']'
end_define
begin_define
DECL|macro|CHAR_CIRCUMFLEX_ACCENT
define|#
directive|define
name|CHAR_CIRCUMFLEX_ACCENT
value|'^'
end_define
begin_define
DECL|macro|CHAR_UNDERSCORE
define|#
directive|define
name|CHAR_UNDERSCORE
value|'_'
end_define
begin_define
DECL|macro|CHAR_GRAVE_ACCENT
define|#
directive|define
name|CHAR_GRAVE_ACCENT
value|'`'
end_define
begin_define
DECL|macro|CHAR_a
define|#
directive|define
name|CHAR_a
value|'a'
end_define
begin_define
DECL|macro|CHAR_b
define|#
directive|define
name|CHAR_b
value|'b'
end_define
begin_define
DECL|macro|CHAR_c
define|#
directive|define
name|CHAR_c
value|'c'
end_define
begin_define
DECL|macro|CHAR_d
define|#
directive|define
name|CHAR_d
value|'d'
end_define
begin_define
DECL|macro|CHAR_e
define|#
directive|define
name|CHAR_e
value|'e'
end_define
begin_define
DECL|macro|CHAR_f
define|#
directive|define
name|CHAR_f
value|'f'
end_define
begin_define
DECL|macro|CHAR_g
define|#
directive|define
name|CHAR_g
value|'g'
end_define
begin_define
DECL|macro|CHAR_h
define|#
directive|define
name|CHAR_h
value|'h'
end_define
begin_define
DECL|macro|CHAR_i
define|#
directive|define
name|CHAR_i
value|'i'
end_define
begin_define
DECL|macro|CHAR_j
define|#
directive|define
name|CHAR_j
value|'j'
end_define
begin_define
DECL|macro|CHAR_k
define|#
directive|define
name|CHAR_k
value|'k'
end_define
begin_define
DECL|macro|CHAR_l
define|#
directive|define
name|CHAR_l
value|'l'
end_define
begin_define
DECL|macro|CHAR_m
define|#
directive|define
name|CHAR_m
value|'m'
end_define
begin_define
DECL|macro|CHAR_n
define|#
directive|define
name|CHAR_n
value|'n'
end_define
begin_define
DECL|macro|CHAR_o
define|#
directive|define
name|CHAR_o
value|'o'
end_define
begin_define
DECL|macro|CHAR_p
define|#
directive|define
name|CHAR_p
value|'p'
end_define
begin_define
DECL|macro|CHAR_q
define|#
directive|define
name|CHAR_q
value|'q'
end_define
begin_define
DECL|macro|CHAR_r
define|#
directive|define
name|CHAR_r
value|'r'
end_define
begin_define
DECL|macro|CHAR_s
define|#
directive|define
name|CHAR_s
value|'s'
end_define
begin_define
DECL|macro|CHAR_t
define|#
directive|define
name|CHAR_t
value|'t'
end_define
begin_define
DECL|macro|CHAR_u
define|#
directive|define
name|CHAR_u
value|'u'
end_define
begin_define
DECL|macro|CHAR_v
define|#
directive|define
name|CHAR_v
value|'v'
end_define
begin_define
DECL|macro|CHAR_w
define|#
directive|define
name|CHAR_w
value|'w'
end_define
begin_define
DECL|macro|CHAR_x
define|#
directive|define
name|CHAR_x
value|'x'
end_define
begin_define
DECL|macro|CHAR_y
define|#
directive|define
name|CHAR_y
value|'y'
end_define
begin_define
DECL|macro|CHAR_z
define|#
directive|define
name|CHAR_z
value|'z'
end_define
begin_define
DECL|macro|CHAR_LEFT_CURLY_BRACKET
define|#
directive|define
name|CHAR_LEFT_CURLY_BRACKET
value|'{'
end_define
begin_define
DECL|macro|CHAR_VERTICAL_LINE
define|#
directive|define
name|CHAR_VERTICAL_LINE
value|'|'
end_define
begin_define
DECL|macro|CHAR_RIGHT_CURLY_BRACKET
define|#
directive|define
name|CHAR_RIGHT_CURLY_BRACKET
value|'}'
end_define
begin_define
DECL|macro|CHAR_TILDE
define|#
directive|define
name|CHAR_TILDE
value|'~'
end_define
begin_define
DECL|macro|STR_HT
define|#
directive|define
name|STR_HT
value|"\t"
end_define
begin_define
DECL|macro|STR_VT
define|#
directive|define
name|STR_VT
value|"\v"
end_define
begin_define
DECL|macro|STR_FF
define|#
directive|define
name|STR_FF
value|"\f"
end_define
begin_define
DECL|macro|STR_CR
define|#
directive|define
name|STR_CR
value|"\r"
end_define
begin_define
DECL|macro|STR_BS
define|#
directive|define
name|STR_BS
value|"\b"
end_define
begin_define
DECL|macro|STR_BEL
define|#
directive|define
name|STR_BEL
value|"\a"
end_define
begin_define
DECL|macro|STR_SPACE
define|#
directive|define
name|STR_SPACE
value|" "
end_define
begin_define
DECL|macro|STR_EXCLAMATION_MARK
define|#
directive|define
name|STR_EXCLAMATION_MARK
value|"!"
end_define
begin_define
DECL|macro|STR_QUOTATION_MARK
define|#
directive|define
name|STR_QUOTATION_MARK
value|"\""
end_define
begin_define
DECL|macro|STR_NUMBER_SIGN
define|#
directive|define
name|STR_NUMBER_SIGN
value|"#"
end_define
begin_define
DECL|macro|STR_DOLLAR_SIGN
define|#
directive|define
name|STR_DOLLAR_SIGN
value|"$"
end_define
begin_define
DECL|macro|STR_PERCENT_SIGN
define|#
directive|define
name|STR_PERCENT_SIGN
value|"%"
end_define
begin_define
DECL|macro|STR_AMPERSAND
define|#
directive|define
name|STR_AMPERSAND
value|"&"
end_define
begin_define
DECL|macro|STR_APOSTROPHE
define|#
directive|define
name|STR_APOSTROPHE
value|"'"
end_define
begin_define
DECL|macro|STR_LEFT_PARENTHESIS
define|#
directive|define
name|STR_LEFT_PARENTHESIS
value|"("
end_define
begin_define
DECL|macro|STR_RIGHT_PARENTHESIS
define|#
directive|define
name|STR_RIGHT_PARENTHESIS
value|")"
end_define
begin_define
DECL|macro|STR_ASTERISK
define|#
directive|define
name|STR_ASTERISK
value|"*"
end_define
begin_define
DECL|macro|STR_PLUS
define|#
directive|define
name|STR_PLUS
value|"+"
end_define
begin_define
DECL|macro|STR_COMMA
define|#
directive|define
name|STR_COMMA
value|","
end_define
begin_define
DECL|macro|STR_MINUS
define|#
directive|define
name|STR_MINUS
value|"-"
end_define
begin_define
DECL|macro|STR_DOT
define|#
directive|define
name|STR_DOT
value|"."
end_define
begin_define
DECL|macro|STR_SLASH
define|#
directive|define
name|STR_SLASH
value|"/"
end_define
begin_define
DECL|macro|STR_0
define|#
directive|define
name|STR_0
value|"0"
end_define
begin_define
DECL|macro|STR_1
define|#
directive|define
name|STR_1
value|"1"
end_define
begin_define
DECL|macro|STR_2
define|#
directive|define
name|STR_2
value|"2"
end_define
begin_define
DECL|macro|STR_3
define|#
directive|define
name|STR_3
value|"3"
end_define
begin_define
DECL|macro|STR_4
define|#
directive|define
name|STR_4
value|"4"
end_define
begin_define
DECL|macro|STR_5
define|#
directive|define
name|STR_5
value|"5"
end_define
begin_define
DECL|macro|STR_6
define|#
directive|define
name|STR_6
value|"6"
end_define
begin_define
DECL|macro|STR_7
define|#
directive|define
name|STR_7
value|"7"
end_define
begin_define
DECL|macro|STR_8
define|#
directive|define
name|STR_8
value|"8"
end_define
begin_define
DECL|macro|STR_9
define|#
directive|define
name|STR_9
value|"9"
end_define
begin_define
DECL|macro|STR_COLON
define|#
directive|define
name|STR_COLON
value|":"
end_define
begin_define
DECL|macro|STR_SEMICOLON
define|#
directive|define
name|STR_SEMICOLON
value|";"
end_define
begin_define
DECL|macro|STR_LESS_THAN_SIGN
define|#
directive|define
name|STR_LESS_THAN_SIGN
value|"<"
end_define
begin_define
DECL|macro|STR_EQUALS_SIGN
define|#
directive|define
name|STR_EQUALS_SIGN
value|"="
end_define
begin_define
DECL|macro|STR_GREATER_THAN_SIGN
define|#
directive|define
name|STR_GREATER_THAN_SIGN
value|">"
end_define
begin_define
DECL|macro|STR_QUESTION_MARK
define|#
directive|define
name|STR_QUESTION_MARK
value|"?"
end_define
begin_define
DECL|macro|STR_COMMERCIAL_AT
define|#
directive|define
name|STR_COMMERCIAL_AT
value|"@"
end_define
begin_define
DECL|macro|STR_A
define|#
directive|define
name|STR_A
value|"A"
end_define
begin_define
DECL|macro|STR_B
define|#
directive|define
name|STR_B
value|"B"
end_define
begin_define
DECL|macro|STR_C
define|#
directive|define
name|STR_C
value|"C"
end_define
begin_define
DECL|macro|STR_D
define|#
directive|define
name|STR_D
value|"D"
end_define
begin_define
DECL|macro|STR_E
define|#
directive|define
name|STR_E
value|"E"
end_define
begin_define
DECL|macro|STR_F
define|#
directive|define
name|STR_F
value|"F"
end_define
begin_define
DECL|macro|STR_G
define|#
directive|define
name|STR_G
value|"G"
end_define
begin_define
DECL|macro|STR_H
define|#
directive|define
name|STR_H
value|"H"
end_define
begin_define
DECL|macro|STR_I
define|#
directive|define
name|STR_I
value|"I"
end_define
begin_define
DECL|macro|STR_J
define|#
directive|define
name|STR_J
value|"J"
end_define
begin_define
DECL|macro|STR_K
define|#
directive|define
name|STR_K
value|"K"
end_define
begin_define
DECL|macro|STR_L
define|#
directive|define
name|STR_L
value|"L"
end_define
begin_define
DECL|macro|STR_M
define|#
directive|define
name|STR_M
value|"M"
end_define
begin_define
DECL|macro|STR_N
define|#
directive|define
name|STR_N
value|"N"
end_define
begin_define
DECL|macro|STR_O
define|#
directive|define
name|STR_O
value|"O"
end_define
begin_define
DECL|macro|STR_P
define|#
directive|define
name|STR_P
value|"P"
end_define
begin_define
DECL|macro|STR_Q
define|#
directive|define
name|STR_Q
value|"Q"
end_define
begin_define
DECL|macro|STR_R
define|#
directive|define
name|STR_R
value|"R"
end_define
begin_define
DECL|macro|STR_S
define|#
directive|define
name|STR_S
value|"S"
end_define
begin_define
DECL|macro|STR_T
define|#
directive|define
name|STR_T
value|"T"
end_define
begin_define
DECL|macro|STR_U
define|#
directive|define
name|STR_U
value|"U"
end_define
begin_define
DECL|macro|STR_V
define|#
directive|define
name|STR_V
value|"V"
end_define
begin_define
DECL|macro|STR_W
define|#
directive|define
name|STR_W
value|"W"
end_define
begin_define
DECL|macro|STR_X
define|#
directive|define
name|STR_X
value|"X"
end_define
begin_define
DECL|macro|STR_Y
define|#
directive|define
name|STR_Y
value|"Y"
end_define
begin_define
DECL|macro|STR_Z
define|#
directive|define
name|STR_Z
value|"Z"
end_define
begin_define
DECL|macro|STR_LEFT_SQUARE_BRACKET
define|#
directive|define
name|STR_LEFT_SQUARE_BRACKET
value|"["
end_define
begin_define
DECL|macro|STR_BACKSLASH
define|#
directive|define
name|STR_BACKSLASH
value|"\\"
end_define
begin_define
DECL|macro|STR_RIGHT_SQUARE_BRACKET
define|#
directive|define
name|STR_RIGHT_SQUARE_BRACKET
value|"]"
end_define
begin_define
DECL|macro|STR_CIRCUMFLEX_ACCENT
define|#
directive|define
name|STR_CIRCUMFLEX_ACCENT
value|"^"
end_define
begin_define
DECL|macro|STR_UNDERSCORE
define|#
directive|define
name|STR_UNDERSCORE
value|"_"
end_define
begin_define
DECL|macro|STR_GRAVE_ACCENT
define|#
directive|define
name|STR_GRAVE_ACCENT
value|"`"
end_define
begin_define
DECL|macro|STR_a
define|#
directive|define
name|STR_a
value|"a"
end_define
begin_define
DECL|macro|STR_b
define|#
directive|define
name|STR_b
value|"b"
end_define
begin_define
DECL|macro|STR_c
define|#
directive|define
name|STR_c
value|"c"
end_define
begin_define
DECL|macro|STR_d
define|#
directive|define
name|STR_d
value|"d"
end_define
begin_define
DECL|macro|STR_e
define|#
directive|define
name|STR_e
value|"e"
end_define
begin_define
DECL|macro|STR_f
define|#
directive|define
name|STR_f
value|"f"
end_define
begin_define
DECL|macro|STR_g
define|#
directive|define
name|STR_g
value|"g"
end_define
begin_define
DECL|macro|STR_h
define|#
directive|define
name|STR_h
value|"h"
end_define
begin_define
DECL|macro|STR_i
define|#
directive|define
name|STR_i
value|"i"
end_define
begin_define
DECL|macro|STR_j
define|#
directive|define
name|STR_j
value|"j"
end_define
begin_define
DECL|macro|STR_k
define|#
directive|define
name|STR_k
value|"k"
end_define
begin_define
DECL|macro|STR_l
define|#
directive|define
name|STR_l
value|"l"
end_define
begin_define
DECL|macro|STR_m
define|#
directive|define
name|STR_m
value|"m"
end_define
begin_define
DECL|macro|STR_n
define|#
directive|define
name|STR_n
value|"n"
end_define
begin_define
DECL|macro|STR_o
define|#
directive|define
name|STR_o
value|"o"
end_define
begin_define
DECL|macro|STR_p
define|#
directive|define
name|STR_p
value|"p"
end_define
begin_define
DECL|macro|STR_q
define|#
directive|define
name|STR_q
value|"q"
end_define
begin_define
DECL|macro|STR_r
define|#
directive|define
name|STR_r
value|"r"
end_define
begin_define
DECL|macro|STR_s
define|#
directive|define
name|STR_s
value|"s"
end_define
begin_define
DECL|macro|STR_t
define|#
directive|define
name|STR_t
value|"t"
end_define
begin_define
DECL|macro|STR_u
define|#
directive|define
name|STR_u
value|"u"
end_define
begin_define
DECL|macro|STR_v
define|#
directive|define
name|STR_v
value|"v"
end_define
begin_define
DECL|macro|STR_w
define|#
directive|define
name|STR_w
value|"w"
end_define
begin_define
DECL|macro|STR_x
define|#
directive|define
name|STR_x
value|"x"
end_define
begin_define
DECL|macro|STR_y
define|#
directive|define
name|STR_y
value|"y"
end_define
begin_define
DECL|macro|STR_z
define|#
directive|define
name|STR_z
value|"z"
end_define
begin_define
DECL|macro|STR_LEFT_CURLY_BRACKET
define|#
directive|define
name|STR_LEFT_CURLY_BRACKET
value|"{"
end_define
begin_define
DECL|macro|STR_VERTICAL_LINE
define|#
directive|define
name|STR_VERTICAL_LINE
value|"|"
end_define
begin_define
DECL|macro|STR_RIGHT_CURLY_BRACKET
define|#
directive|define
name|STR_RIGHT_CURLY_BRACKET
value|"}"
end_define
begin_define
DECL|macro|STR_TILDE
define|#
directive|define
name|STR_TILDE
value|"~"
end_define
begin_define
DECL|macro|STRING_ACCEPT0
define|#
directive|define
name|STRING_ACCEPT0
value|"ACCEPT\0"
end_define
begin_define
DECL|macro|STRING_COMMIT0
define|#
directive|define
name|STRING_COMMIT0
value|"COMMIT\0"
end_define
begin_define
DECL|macro|STRING_F0
define|#
directive|define
name|STRING_F0
value|"F\0"
end_define
begin_define
DECL|macro|STRING_FAIL0
define|#
directive|define
name|STRING_FAIL0
value|"FAIL\0"
end_define
begin_define
DECL|macro|STRING_MARK0
define|#
directive|define
name|STRING_MARK0
value|"MARK\0"
end_define
begin_define
DECL|macro|STRING_PRUNE0
define|#
directive|define
name|STRING_PRUNE0
value|"PRUNE\0"
end_define
begin_define
DECL|macro|STRING_SKIP0
define|#
directive|define
name|STRING_SKIP0
value|"SKIP\0"
end_define
begin_define
DECL|macro|STRING_THEN
define|#
directive|define
name|STRING_THEN
value|"THEN"
end_define
begin_define
DECL|macro|STRING_alpha0
define|#
directive|define
name|STRING_alpha0
value|"alpha\0"
end_define
begin_define
DECL|macro|STRING_lower0
define|#
directive|define
name|STRING_lower0
value|"lower\0"
end_define
begin_define
DECL|macro|STRING_upper0
define|#
directive|define
name|STRING_upper0
value|"upper\0"
end_define
begin_define
DECL|macro|STRING_alnum0
define|#
directive|define
name|STRING_alnum0
value|"alnum\0"
end_define
begin_define
DECL|macro|STRING_ascii0
define|#
directive|define
name|STRING_ascii0
value|"ascii\0"
end_define
begin_define
DECL|macro|STRING_blank0
define|#
directive|define
name|STRING_blank0
value|"blank\0"
end_define
begin_define
DECL|macro|STRING_cntrl0
define|#
directive|define
name|STRING_cntrl0
value|"cntrl\0"
end_define
begin_define
DECL|macro|STRING_digit0
define|#
directive|define
name|STRING_digit0
value|"digit\0"
end_define
begin_define
DECL|macro|STRING_graph0
define|#
directive|define
name|STRING_graph0
value|"graph\0"
end_define
begin_define
DECL|macro|STRING_print0
define|#
directive|define
name|STRING_print0
value|"print\0"
end_define
begin_define
DECL|macro|STRING_punct0
define|#
directive|define
name|STRING_punct0
value|"punct\0"
end_define
begin_define
DECL|macro|STRING_space0
define|#
directive|define
name|STRING_space0
value|"space\0"
end_define
begin_define
DECL|macro|STRING_word0
define|#
directive|define
name|STRING_word0
value|"word\0"
end_define
begin_define
DECL|macro|STRING_xdigit
define|#
directive|define
name|STRING_xdigit
value|"xdigit"
end_define
begin_define
DECL|macro|STRING_DEFINE
define|#
directive|define
name|STRING_DEFINE
value|"DEFINE"
end_define
begin_define
DECL|macro|STRING_WEIRD_STARTWORD
define|#
directive|define
name|STRING_WEIRD_STARTWORD
value|"[:<:]]"
end_define
begin_define
DECL|macro|STRING_WEIRD_ENDWORD
define|#
directive|define
name|STRING_WEIRD_ENDWORD
value|"[:>:]]"
end_define
begin_define
DECL|macro|STRING_CR_RIGHTPAR
define|#
directive|define
name|STRING_CR_RIGHTPAR
value|"CR)"
end_define
begin_define
DECL|macro|STRING_LF_RIGHTPAR
define|#
directive|define
name|STRING_LF_RIGHTPAR
value|"LF)"
end_define
begin_define
DECL|macro|STRING_CRLF_RIGHTPAR
define|#
directive|define
name|STRING_CRLF_RIGHTPAR
value|"CRLF)"
end_define
begin_define
DECL|macro|STRING_ANY_RIGHTPAR
define|#
directive|define
name|STRING_ANY_RIGHTPAR
value|"ANY)"
end_define
begin_define
DECL|macro|STRING_ANYCRLF_RIGHTPAR
define|#
directive|define
name|STRING_ANYCRLF_RIGHTPAR
value|"ANYCRLF)"
end_define
begin_define
DECL|macro|STRING_BSR_ANYCRLF_RIGHTPAR
define|#
directive|define
name|STRING_BSR_ANYCRLF_RIGHTPAR
value|"BSR_ANYCRLF)"
end_define
begin_define
DECL|macro|STRING_BSR_UNICODE_RIGHTPAR
define|#
directive|define
name|STRING_BSR_UNICODE_RIGHTPAR
value|"BSR_UNICODE)"
end_define
begin_define
DECL|macro|STRING_UTF8_RIGHTPAR
define|#
directive|define
name|STRING_UTF8_RIGHTPAR
value|"UTF8)"
end_define
begin_define
DECL|macro|STRING_UTF16_RIGHTPAR
define|#
directive|define
name|STRING_UTF16_RIGHTPAR
value|"UTF16)"
end_define
begin_define
DECL|macro|STRING_UTF32_RIGHTPAR
define|#
directive|define
name|STRING_UTF32_RIGHTPAR
value|"UTF32)"
end_define
begin_define
DECL|macro|STRING_UTF_RIGHTPAR
define|#
directive|define
name|STRING_UTF_RIGHTPAR
value|"UTF)"
end_define
begin_define
DECL|macro|STRING_UCP_RIGHTPAR
define|#
directive|define
name|STRING_UCP_RIGHTPAR
value|"UCP)"
end_define
begin_define
DECL|macro|STRING_NO_AUTO_POSSESS_RIGHTPAR
define|#
directive|define
name|STRING_NO_AUTO_POSSESS_RIGHTPAR
value|"NO_AUTO_POSSESS)"
end_define
begin_define
DECL|macro|STRING_NO_START_OPT_RIGHTPAR
define|#
directive|define
name|STRING_NO_START_OPT_RIGHTPAR
value|"NO_START_OPT)"
end_define
begin_define
DECL|macro|STRING_LIMIT_MATCH_EQ
define|#
directive|define
name|STRING_LIMIT_MATCH_EQ
value|"LIMIT_MATCH="
end_define
begin_define
DECL|macro|STRING_LIMIT_RECURSION_EQ
define|#
directive|define
name|STRING_LIMIT_RECURSION_EQ
value|"LIMIT_RECURSION="
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* SUPPORT_UTF */
end_comment
begin_comment
comment|/* UTF-8 support is enabled; always use UTF-8 (=ASCII) character codes. This works in both modes non-EBCDIC platforms, and on EBCDIC platforms in UTF-8 mode only. */
end_comment
begin_define
DECL|macro|CHAR_HT
define|#
directive|define
name|CHAR_HT
value|'\011'
end_define
begin_define
DECL|macro|CHAR_VT
define|#
directive|define
name|CHAR_VT
value|'\013'
end_define
begin_define
DECL|macro|CHAR_FF
define|#
directive|define
name|CHAR_FF
value|'\014'
end_define
begin_define
DECL|macro|CHAR_CR
define|#
directive|define
name|CHAR_CR
value|'\015'
end_define
begin_define
DECL|macro|CHAR_LF
define|#
directive|define
name|CHAR_LF
value|'\012'
end_define
begin_define
DECL|macro|CHAR_NL
define|#
directive|define
name|CHAR_NL
value|CHAR_LF
end_define
begin_define
DECL|macro|CHAR_NEL
define|#
directive|define
name|CHAR_NEL
value|((unsigned char)'\x85')
end_define
begin_define
DECL|macro|CHAR_BS
define|#
directive|define
name|CHAR_BS
value|'\010'
end_define
begin_define
DECL|macro|CHAR_BEL
define|#
directive|define
name|CHAR_BEL
value|'\007'
end_define
begin_define
DECL|macro|CHAR_ESC
define|#
directive|define
name|CHAR_ESC
value|'\033'
end_define
begin_define
DECL|macro|CHAR_DEL
define|#
directive|define
name|CHAR_DEL
value|'\177'
end_define
begin_define
DECL|macro|CHAR_NULL
define|#
directive|define
name|CHAR_NULL
value|'\0'
end_define
begin_define
DECL|macro|CHAR_SPACE
define|#
directive|define
name|CHAR_SPACE
value|'\040'
end_define
begin_define
DECL|macro|CHAR_EXCLAMATION_MARK
define|#
directive|define
name|CHAR_EXCLAMATION_MARK
value|'\041'
end_define
begin_define
DECL|macro|CHAR_QUOTATION_MARK
define|#
directive|define
name|CHAR_QUOTATION_MARK
value|'\042'
end_define
begin_define
DECL|macro|CHAR_NUMBER_SIGN
define|#
directive|define
name|CHAR_NUMBER_SIGN
value|'\043'
end_define
begin_define
DECL|macro|CHAR_DOLLAR_SIGN
define|#
directive|define
name|CHAR_DOLLAR_SIGN
value|'\044'
end_define
begin_define
DECL|macro|CHAR_PERCENT_SIGN
define|#
directive|define
name|CHAR_PERCENT_SIGN
value|'\045'
end_define
begin_define
DECL|macro|CHAR_AMPERSAND
define|#
directive|define
name|CHAR_AMPERSAND
value|'\046'
end_define
begin_define
DECL|macro|CHAR_APOSTROPHE
define|#
directive|define
name|CHAR_APOSTROPHE
value|'\047'
end_define
begin_define
DECL|macro|CHAR_LEFT_PARENTHESIS
define|#
directive|define
name|CHAR_LEFT_PARENTHESIS
value|'\050'
end_define
begin_define
DECL|macro|CHAR_RIGHT_PARENTHESIS
define|#
directive|define
name|CHAR_RIGHT_PARENTHESIS
value|'\051'
end_define
begin_define
DECL|macro|CHAR_ASTERISK
define|#
directive|define
name|CHAR_ASTERISK
value|'\052'
end_define
begin_define
DECL|macro|CHAR_PLUS
define|#
directive|define
name|CHAR_PLUS
value|'\053'
end_define
begin_define
DECL|macro|CHAR_COMMA
define|#
directive|define
name|CHAR_COMMA
value|'\054'
end_define
begin_define
DECL|macro|CHAR_MINUS
define|#
directive|define
name|CHAR_MINUS
value|'\055'
end_define
begin_define
DECL|macro|CHAR_DOT
define|#
directive|define
name|CHAR_DOT
value|'\056'
end_define
begin_define
DECL|macro|CHAR_SLASH
define|#
directive|define
name|CHAR_SLASH
value|'\057'
end_define
begin_define
DECL|macro|CHAR_0
define|#
directive|define
name|CHAR_0
value|'\060'
end_define
begin_define
DECL|macro|CHAR_1
define|#
directive|define
name|CHAR_1
value|'\061'
end_define
begin_define
DECL|macro|CHAR_2
define|#
directive|define
name|CHAR_2
value|'\062'
end_define
begin_define
DECL|macro|CHAR_3
define|#
directive|define
name|CHAR_3
value|'\063'
end_define
begin_define
DECL|macro|CHAR_4
define|#
directive|define
name|CHAR_4
value|'\064'
end_define
begin_define
DECL|macro|CHAR_5
define|#
directive|define
name|CHAR_5
value|'\065'
end_define
begin_define
DECL|macro|CHAR_6
define|#
directive|define
name|CHAR_6
value|'\066'
end_define
begin_define
DECL|macro|CHAR_7
define|#
directive|define
name|CHAR_7
value|'\067'
end_define
begin_define
DECL|macro|CHAR_8
define|#
directive|define
name|CHAR_8
value|'\070'
end_define
begin_define
DECL|macro|CHAR_9
define|#
directive|define
name|CHAR_9
value|'\071'
end_define
begin_define
DECL|macro|CHAR_COLON
define|#
directive|define
name|CHAR_COLON
value|'\072'
end_define
begin_define
DECL|macro|CHAR_SEMICOLON
define|#
directive|define
name|CHAR_SEMICOLON
value|'\073'
end_define
begin_define
DECL|macro|CHAR_LESS_THAN_SIGN
define|#
directive|define
name|CHAR_LESS_THAN_SIGN
value|'\074'
end_define
begin_define
DECL|macro|CHAR_EQUALS_SIGN
define|#
directive|define
name|CHAR_EQUALS_SIGN
value|'\075'
end_define
begin_define
DECL|macro|CHAR_GREATER_THAN_SIGN
define|#
directive|define
name|CHAR_GREATER_THAN_SIGN
value|'\076'
end_define
begin_define
DECL|macro|CHAR_QUESTION_MARK
define|#
directive|define
name|CHAR_QUESTION_MARK
value|'\077'
end_define
begin_define
DECL|macro|CHAR_COMMERCIAL_AT
define|#
directive|define
name|CHAR_COMMERCIAL_AT
value|'\100'
end_define
begin_define
DECL|macro|CHAR_A
define|#
directive|define
name|CHAR_A
value|'\101'
end_define
begin_define
DECL|macro|CHAR_B
define|#
directive|define
name|CHAR_B
value|'\102'
end_define
begin_define
DECL|macro|CHAR_C
define|#
directive|define
name|CHAR_C
value|'\103'
end_define
begin_define
DECL|macro|CHAR_D
define|#
directive|define
name|CHAR_D
value|'\104'
end_define
begin_define
DECL|macro|CHAR_E
define|#
directive|define
name|CHAR_E
value|'\105'
end_define
begin_define
DECL|macro|CHAR_F
define|#
directive|define
name|CHAR_F
value|'\106'
end_define
begin_define
DECL|macro|CHAR_G
define|#
directive|define
name|CHAR_G
value|'\107'
end_define
begin_define
DECL|macro|CHAR_H
define|#
directive|define
name|CHAR_H
value|'\110'
end_define
begin_define
DECL|macro|CHAR_I
define|#
directive|define
name|CHAR_I
value|'\111'
end_define
begin_define
DECL|macro|CHAR_J
define|#
directive|define
name|CHAR_J
value|'\112'
end_define
begin_define
DECL|macro|CHAR_K
define|#
directive|define
name|CHAR_K
value|'\113'
end_define
begin_define
DECL|macro|CHAR_L
define|#
directive|define
name|CHAR_L
value|'\114'
end_define
begin_define
DECL|macro|CHAR_M
define|#
directive|define
name|CHAR_M
value|'\115'
end_define
begin_define
DECL|macro|CHAR_N
define|#
directive|define
name|CHAR_N
value|'\116'
end_define
begin_define
DECL|macro|CHAR_O
define|#
directive|define
name|CHAR_O
value|'\117'
end_define
begin_define
DECL|macro|CHAR_P
define|#
directive|define
name|CHAR_P
value|'\120'
end_define
begin_define
DECL|macro|CHAR_Q
define|#
directive|define
name|CHAR_Q
value|'\121'
end_define
begin_define
DECL|macro|CHAR_R
define|#
directive|define
name|CHAR_R
value|'\122'
end_define
begin_define
DECL|macro|CHAR_S
define|#
directive|define
name|CHAR_S
value|'\123'
end_define
begin_define
DECL|macro|CHAR_T
define|#
directive|define
name|CHAR_T
value|'\124'
end_define
begin_define
DECL|macro|CHAR_U
define|#
directive|define
name|CHAR_U
value|'\125'
end_define
begin_define
DECL|macro|CHAR_V
define|#
directive|define
name|CHAR_V
value|'\126'
end_define
begin_define
DECL|macro|CHAR_W
define|#
directive|define
name|CHAR_W
value|'\127'
end_define
begin_define
DECL|macro|CHAR_X
define|#
directive|define
name|CHAR_X
value|'\130'
end_define
begin_define
DECL|macro|CHAR_Y
define|#
directive|define
name|CHAR_Y
value|'\131'
end_define
begin_define
DECL|macro|CHAR_Z
define|#
directive|define
name|CHAR_Z
value|'\132'
end_define
begin_define
DECL|macro|CHAR_LEFT_SQUARE_BRACKET
define|#
directive|define
name|CHAR_LEFT_SQUARE_BRACKET
value|'\133'
end_define
begin_define
DECL|macro|CHAR_BACKSLASH
define|#
directive|define
name|CHAR_BACKSLASH
value|'\134'
end_define
begin_define
DECL|macro|CHAR_RIGHT_SQUARE_BRACKET
define|#
directive|define
name|CHAR_RIGHT_SQUARE_BRACKET
value|'\135'
end_define
begin_define
DECL|macro|CHAR_CIRCUMFLEX_ACCENT
define|#
directive|define
name|CHAR_CIRCUMFLEX_ACCENT
value|'\136'
end_define
begin_define
DECL|macro|CHAR_UNDERSCORE
define|#
directive|define
name|CHAR_UNDERSCORE
value|'\137'
end_define
begin_define
DECL|macro|CHAR_GRAVE_ACCENT
define|#
directive|define
name|CHAR_GRAVE_ACCENT
value|'\140'
end_define
begin_define
DECL|macro|CHAR_a
define|#
directive|define
name|CHAR_a
value|'\141'
end_define
begin_define
DECL|macro|CHAR_b
define|#
directive|define
name|CHAR_b
value|'\142'
end_define
begin_define
DECL|macro|CHAR_c
define|#
directive|define
name|CHAR_c
value|'\143'
end_define
begin_define
DECL|macro|CHAR_d
define|#
directive|define
name|CHAR_d
value|'\144'
end_define
begin_define
DECL|macro|CHAR_e
define|#
directive|define
name|CHAR_e
value|'\145'
end_define
begin_define
DECL|macro|CHAR_f
define|#
directive|define
name|CHAR_f
value|'\146'
end_define
begin_define
DECL|macro|CHAR_g
define|#
directive|define
name|CHAR_g
value|'\147'
end_define
begin_define
DECL|macro|CHAR_h
define|#
directive|define
name|CHAR_h
value|'\150'
end_define
begin_define
DECL|macro|CHAR_i
define|#
directive|define
name|CHAR_i
value|'\151'
end_define
begin_define
DECL|macro|CHAR_j
define|#
directive|define
name|CHAR_j
value|'\152'
end_define
begin_define
DECL|macro|CHAR_k
define|#
directive|define
name|CHAR_k
value|'\153'
end_define
begin_define
DECL|macro|CHAR_l
define|#
directive|define
name|CHAR_l
value|'\154'
end_define
begin_define
DECL|macro|CHAR_m
define|#
directive|define
name|CHAR_m
value|'\155'
end_define
begin_define
DECL|macro|CHAR_n
define|#
directive|define
name|CHAR_n
value|'\156'
end_define
begin_define
DECL|macro|CHAR_o
define|#
directive|define
name|CHAR_o
value|'\157'
end_define
begin_define
DECL|macro|CHAR_p
define|#
directive|define
name|CHAR_p
value|'\160'
end_define
begin_define
DECL|macro|CHAR_q
define|#
directive|define
name|CHAR_q
value|'\161'
end_define
begin_define
DECL|macro|CHAR_r
define|#
directive|define
name|CHAR_r
value|'\162'
end_define
begin_define
DECL|macro|CHAR_s
define|#
directive|define
name|CHAR_s
value|'\163'
end_define
begin_define
DECL|macro|CHAR_t
define|#
directive|define
name|CHAR_t
value|'\164'
end_define
begin_define
DECL|macro|CHAR_u
define|#
directive|define
name|CHAR_u
value|'\165'
end_define
begin_define
DECL|macro|CHAR_v
define|#
directive|define
name|CHAR_v
value|'\166'
end_define
begin_define
DECL|macro|CHAR_w
define|#
directive|define
name|CHAR_w
value|'\167'
end_define
begin_define
DECL|macro|CHAR_x
define|#
directive|define
name|CHAR_x
value|'\170'
end_define
begin_define
DECL|macro|CHAR_y
define|#
directive|define
name|CHAR_y
value|'\171'
end_define
begin_define
DECL|macro|CHAR_z
define|#
directive|define
name|CHAR_z
value|'\172'
end_define
begin_define
DECL|macro|CHAR_LEFT_CURLY_BRACKET
define|#
directive|define
name|CHAR_LEFT_CURLY_BRACKET
value|'\173'
end_define
begin_define
DECL|macro|CHAR_VERTICAL_LINE
define|#
directive|define
name|CHAR_VERTICAL_LINE
value|'\174'
end_define
begin_define
DECL|macro|CHAR_RIGHT_CURLY_BRACKET
define|#
directive|define
name|CHAR_RIGHT_CURLY_BRACKET
value|'\175'
end_define
begin_define
DECL|macro|CHAR_TILDE
define|#
directive|define
name|CHAR_TILDE
value|'\176'
end_define
begin_define
DECL|macro|STR_HT
define|#
directive|define
name|STR_HT
value|"\011"
end_define
begin_define
DECL|macro|STR_VT
define|#
directive|define
name|STR_VT
value|"\013"
end_define
begin_define
DECL|macro|STR_FF
define|#
directive|define
name|STR_FF
value|"\014"
end_define
begin_define
DECL|macro|STR_CR
define|#
directive|define
name|STR_CR
value|"\015"
end_define
begin_define
DECL|macro|STR_NL
define|#
directive|define
name|STR_NL
value|"\012"
end_define
begin_define
DECL|macro|STR_BS
define|#
directive|define
name|STR_BS
value|"\010"
end_define
begin_define
DECL|macro|STR_BEL
define|#
directive|define
name|STR_BEL
value|"\007"
end_define
begin_define
DECL|macro|STR_ESC
define|#
directive|define
name|STR_ESC
value|"\033"
end_define
begin_define
DECL|macro|STR_DEL
define|#
directive|define
name|STR_DEL
value|"\177"
end_define
begin_define
DECL|macro|STR_SPACE
define|#
directive|define
name|STR_SPACE
value|"\040"
end_define
begin_define
DECL|macro|STR_EXCLAMATION_MARK
define|#
directive|define
name|STR_EXCLAMATION_MARK
value|"\041"
end_define
begin_define
DECL|macro|STR_QUOTATION_MARK
define|#
directive|define
name|STR_QUOTATION_MARK
value|"\042"
end_define
begin_define
DECL|macro|STR_NUMBER_SIGN
define|#
directive|define
name|STR_NUMBER_SIGN
value|"\043"
end_define
begin_define
DECL|macro|STR_DOLLAR_SIGN
define|#
directive|define
name|STR_DOLLAR_SIGN
value|"\044"
end_define
begin_define
DECL|macro|STR_PERCENT_SIGN
define|#
directive|define
name|STR_PERCENT_SIGN
value|"\045"
end_define
begin_define
DECL|macro|STR_AMPERSAND
define|#
directive|define
name|STR_AMPERSAND
value|"\046"
end_define
begin_define
DECL|macro|STR_APOSTROPHE
define|#
directive|define
name|STR_APOSTROPHE
value|"\047"
end_define
begin_define
DECL|macro|STR_LEFT_PARENTHESIS
define|#
directive|define
name|STR_LEFT_PARENTHESIS
value|"\050"
end_define
begin_define
DECL|macro|STR_RIGHT_PARENTHESIS
define|#
directive|define
name|STR_RIGHT_PARENTHESIS
value|"\051"
end_define
begin_define
DECL|macro|STR_ASTERISK
define|#
directive|define
name|STR_ASTERISK
value|"\052"
end_define
begin_define
DECL|macro|STR_PLUS
define|#
directive|define
name|STR_PLUS
value|"\053"
end_define
begin_define
DECL|macro|STR_COMMA
define|#
directive|define
name|STR_COMMA
value|"\054"
end_define
begin_define
DECL|macro|STR_MINUS
define|#
directive|define
name|STR_MINUS
value|"\055"
end_define
begin_define
DECL|macro|STR_DOT
define|#
directive|define
name|STR_DOT
value|"\056"
end_define
begin_define
DECL|macro|STR_SLASH
define|#
directive|define
name|STR_SLASH
value|"\057"
end_define
begin_define
DECL|macro|STR_0
define|#
directive|define
name|STR_0
value|"\060"
end_define
begin_define
DECL|macro|STR_1
define|#
directive|define
name|STR_1
value|"\061"
end_define
begin_define
DECL|macro|STR_2
define|#
directive|define
name|STR_2
value|"\062"
end_define
begin_define
DECL|macro|STR_3
define|#
directive|define
name|STR_3
value|"\063"
end_define
begin_define
DECL|macro|STR_4
define|#
directive|define
name|STR_4
value|"\064"
end_define
begin_define
DECL|macro|STR_5
define|#
directive|define
name|STR_5
value|"\065"
end_define
begin_define
DECL|macro|STR_6
define|#
directive|define
name|STR_6
value|"\066"
end_define
begin_define
DECL|macro|STR_7
define|#
directive|define
name|STR_7
value|"\067"
end_define
begin_define
DECL|macro|STR_8
define|#
directive|define
name|STR_8
value|"\070"
end_define
begin_define
DECL|macro|STR_9
define|#
directive|define
name|STR_9
value|"\071"
end_define
begin_define
DECL|macro|STR_COLON
define|#
directive|define
name|STR_COLON
value|"\072"
end_define
begin_define
DECL|macro|STR_SEMICOLON
define|#
directive|define
name|STR_SEMICOLON
value|"\073"
end_define
begin_define
DECL|macro|STR_LESS_THAN_SIGN
define|#
directive|define
name|STR_LESS_THAN_SIGN
value|"\074"
end_define
begin_define
DECL|macro|STR_EQUALS_SIGN
define|#
directive|define
name|STR_EQUALS_SIGN
value|"\075"
end_define
begin_define
DECL|macro|STR_GREATER_THAN_SIGN
define|#
directive|define
name|STR_GREATER_THAN_SIGN
value|"\076"
end_define
begin_define
DECL|macro|STR_QUESTION_MARK
define|#
directive|define
name|STR_QUESTION_MARK
value|"\077"
end_define
begin_define
DECL|macro|STR_COMMERCIAL_AT
define|#
directive|define
name|STR_COMMERCIAL_AT
value|"\100"
end_define
begin_define
DECL|macro|STR_A
define|#
directive|define
name|STR_A
value|"\101"
end_define
begin_define
DECL|macro|STR_B
define|#
directive|define
name|STR_B
value|"\102"
end_define
begin_define
DECL|macro|STR_C
define|#
directive|define
name|STR_C
value|"\103"
end_define
begin_define
DECL|macro|STR_D
define|#
directive|define
name|STR_D
value|"\104"
end_define
begin_define
DECL|macro|STR_E
define|#
directive|define
name|STR_E
value|"\105"
end_define
begin_define
DECL|macro|STR_F
define|#
directive|define
name|STR_F
value|"\106"
end_define
begin_define
DECL|macro|STR_G
define|#
directive|define
name|STR_G
value|"\107"
end_define
begin_define
DECL|macro|STR_H
define|#
directive|define
name|STR_H
value|"\110"
end_define
begin_define
DECL|macro|STR_I
define|#
directive|define
name|STR_I
value|"\111"
end_define
begin_define
DECL|macro|STR_J
define|#
directive|define
name|STR_J
value|"\112"
end_define
begin_define
DECL|macro|STR_K
define|#
directive|define
name|STR_K
value|"\113"
end_define
begin_define
DECL|macro|STR_L
define|#
directive|define
name|STR_L
value|"\114"
end_define
begin_define
DECL|macro|STR_M
define|#
directive|define
name|STR_M
value|"\115"
end_define
begin_define
DECL|macro|STR_N
define|#
directive|define
name|STR_N
value|"\116"
end_define
begin_define
DECL|macro|STR_O
define|#
directive|define
name|STR_O
value|"\117"
end_define
begin_define
DECL|macro|STR_P
define|#
directive|define
name|STR_P
value|"\120"
end_define
begin_define
DECL|macro|STR_Q
define|#
directive|define
name|STR_Q
value|"\121"
end_define
begin_define
DECL|macro|STR_R
define|#
directive|define
name|STR_R
value|"\122"
end_define
begin_define
DECL|macro|STR_S
define|#
directive|define
name|STR_S
value|"\123"
end_define
begin_define
DECL|macro|STR_T
define|#
directive|define
name|STR_T
value|"\124"
end_define
begin_define
DECL|macro|STR_U
define|#
directive|define
name|STR_U
value|"\125"
end_define
begin_define
DECL|macro|STR_V
define|#
directive|define
name|STR_V
value|"\126"
end_define
begin_define
DECL|macro|STR_W
define|#
directive|define
name|STR_W
value|"\127"
end_define
begin_define
DECL|macro|STR_X
define|#
directive|define
name|STR_X
value|"\130"
end_define
begin_define
DECL|macro|STR_Y
define|#
directive|define
name|STR_Y
value|"\131"
end_define
begin_define
DECL|macro|STR_Z
define|#
directive|define
name|STR_Z
value|"\132"
end_define
begin_define
DECL|macro|STR_LEFT_SQUARE_BRACKET
define|#
directive|define
name|STR_LEFT_SQUARE_BRACKET
value|"\133"
end_define
begin_define
DECL|macro|STR_BACKSLASH
define|#
directive|define
name|STR_BACKSLASH
value|"\134"
end_define
begin_define
DECL|macro|STR_RIGHT_SQUARE_BRACKET
define|#
directive|define
name|STR_RIGHT_SQUARE_BRACKET
value|"\135"
end_define
begin_define
DECL|macro|STR_CIRCUMFLEX_ACCENT
define|#
directive|define
name|STR_CIRCUMFLEX_ACCENT
value|"\136"
end_define
begin_define
DECL|macro|STR_UNDERSCORE
define|#
directive|define
name|STR_UNDERSCORE
value|"\137"
end_define
begin_define
DECL|macro|STR_GRAVE_ACCENT
define|#
directive|define
name|STR_GRAVE_ACCENT
value|"\140"
end_define
begin_define
DECL|macro|STR_a
define|#
directive|define
name|STR_a
value|"\141"
end_define
begin_define
DECL|macro|STR_b
define|#
directive|define
name|STR_b
value|"\142"
end_define
begin_define
DECL|macro|STR_c
define|#
directive|define
name|STR_c
value|"\143"
end_define
begin_define
DECL|macro|STR_d
define|#
directive|define
name|STR_d
value|"\144"
end_define
begin_define
DECL|macro|STR_e
define|#
directive|define
name|STR_e
value|"\145"
end_define
begin_define
DECL|macro|STR_f
define|#
directive|define
name|STR_f
value|"\146"
end_define
begin_define
DECL|macro|STR_g
define|#
directive|define
name|STR_g
value|"\147"
end_define
begin_define
DECL|macro|STR_h
define|#
directive|define
name|STR_h
value|"\150"
end_define
begin_define
DECL|macro|STR_i
define|#
directive|define
name|STR_i
value|"\151"
end_define
begin_define
DECL|macro|STR_j
define|#
directive|define
name|STR_j
value|"\152"
end_define
begin_define
DECL|macro|STR_k
define|#
directive|define
name|STR_k
value|"\153"
end_define
begin_define
DECL|macro|STR_l
define|#
directive|define
name|STR_l
value|"\154"
end_define
begin_define
DECL|macro|STR_m
define|#
directive|define
name|STR_m
value|"\155"
end_define
begin_define
DECL|macro|STR_n
define|#
directive|define
name|STR_n
value|"\156"
end_define
begin_define
DECL|macro|STR_o
define|#
directive|define
name|STR_o
value|"\157"
end_define
begin_define
DECL|macro|STR_p
define|#
directive|define
name|STR_p
value|"\160"
end_define
begin_define
DECL|macro|STR_q
define|#
directive|define
name|STR_q
value|"\161"
end_define
begin_define
DECL|macro|STR_r
define|#
directive|define
name|STR_r
value|"\162"
end_define
begin_define
DECL|macro|STR_s
define|#
directive|define
name|STR_s
value|"\163"
end_define
begin_define
DECL|macro|STR_t
define|#
directive|define
name|STR_t
value|"\164"
end_define
begin_define
DECL|macro|STR_u
define|#
directive|define
name|STR_u
value|"\165"
end_define
begin_define
DECL|macro|STR_v
define|#
directive|define
name|STR_v
value|"\166"
end_define
begin_define
DECL|macro|STR_w
define|#
directive|define
name|STR_w
value|"\167"
end_define
begin_define
DECL|macro|STR_x
define|#
directive|define
name|STR_x
value|"\170"
end_define
begin_define
DECL|macro|STR_y
define|#
directive|define
name|STR_y
value|"\171"
end_define
begin_define
DECL|macro|STR_z
define|#
directive|define
name|STR_z
value|"\172"
end_define
begin_define
DECL|macro|STR_LEFT_CURLY_BRACKET
define|#
directive|define
name|STR_LEFT_CURLY_BRACKET
value|"\173"
end_define
begin_define
DECL|macro|STR_VERTICAL_LINE
define|#
directive|define
name|STR_VERTICAL_LINE
value|"\174"
end_define
begin_define
DECL|macro|STR_RIGHT_CURLY_BRACKET
define|#
directive|define
name|STR_RIGHT_CURLY_BRACKET
value|"\175"
end_define
begin_define
DECL|macro|STR_TILDE
define|#
directive|define
name|STR_TILDE
value|"\176"
end_define
begin_define
DECL|macro|STRING_ACCEPT0
define|#
directive|define
name|STRING_ACCEPT0
value|STR_A STR_C STR_C STR_E STR_P STR_T "\0"
end_define
begin_define
DECL|macro|STRING_COMMIT0
define|#
directive|define
name|STRING_COMMIT0
value|STR_C STR_O STR_M STR_M STR_I STR_T "\0"
end_define
begin_define
DECL|macro|STRING_F0
define|#
directive|define
name|STRING_F0
value|STR_F "\0"
end_define
begin_define
DECL|macro|STRING_FAIL0
define|#
directive|define
name|STRING_FAIL0
value|STR_F STR_A STR_I STR_L "\0"
end_define
begin_define
DECL|macro|STRING_MARK0
define|#
directive|define
name|STRING_MARK0
value|STR_M STR_A STR_R STR_K "\0"
end_define
begin_define
DECL|macro|STRING_PRUNE0
define|#
directive|define
name|STRING_PRUNE0
value|STR_P STR_R STR_U STR_N STR_E "\0"
end_define
begin_define
DECL|macro|STRING_SKIP0
define|#
directive|define
name|STRING_SKIP0
value|STR_S STR_K STR_I STR_P "\0"
end_define
begin_define
DECL|macro|STRING_THEN
define|#
directive|define
name|STRING_THEN
value|STR_T STR_H STR_E STR_N
end_define
begin_define
DECL|macro|STRING_alpha0
define|#
directive|define
name|STRING_alpha0
value|STR_a STR_l STR_p STR_h STR_a "\0"
end_define
begin_define
DECL|macro|STRING_lower0
define|#
directive|define
name|STRING_lower0
value|STR_l STR_o STR_w STR_e STR_r "\0"
end_define
begin_define
DECL|macro|STRING_upper0
define|#
directive|define
name|STRING_upper0
value|STR_u STR_p STR_p STR_e STR_r "\0"
end_define
begin_define
DECL|macro|STRING_alnum0
define|#
directive|define
name|STRING_alnum0
value|STR_a STR_l STR_n STR_u STR_m "\0"
end_define
begin_define
DECL|macro|STRING_ascii0
define|#
directive|define
name|STRING_ascii0
value|STR_a STR_s STR_c STR_i STR_i "\0"
end_define
begin_define
DECL|macro|STRING_blank0
define|#
directive|define
name|STRING_blank0
value|STR_b STR_l STR_a STR_n STR_k "\0"
end_define
begin_define
DECL|macro|STRING_cntrl0
define|#
directive|define
name|STRING_cntrl0
value|STR_c STR_n STR_t STR_r STR_l "\0"
end_define
begin_define
DECL|macro|STRING_digit0
define|#
directive|define
name|STRING_digit0
value|STR_d STR_i STR_g STR_i STR_t "\0"
end_define
begin_define
DECL|macro|STRING_graph0
define|#
directive|define
name|STRING_graph0
value|STR_g STR_r STR_a STR_p STR_h "\0"
end_define
begin_define
DECL|macro|STRING_print0
define|#
directive|define
name|STRING_print0
value|STR_p STR_r STR_i STR_n STR_t "\0"
end_define
begin_define
DECL|macro|STRING_punct0
define|#
directive|define
name|STRING_punct0
value|STR_p STR_u STR_n STR_c STR_t "\0"
end_define
begin_define
DECL|macro|STRING_space0
define|#
directive|define
name|STRING_space0
value|STR_s STR_p STR_a STR_c STR_e "\0"
end_define
begin_define
DECL|macro|STRING_word0
define|#
directive|define
name|STRING_word0
value|STR_w STR_o STR_r STR_d       "\0"
end_define
begin_define
DECL|macro|STRING_xdigit
define|#
directive|define
name|STRING_xdigit
value|STR_x STR_d STR_i STR_g STR_i STR_t
end_define
begin_define
DECL|macro|STRING_DEFINE
define|#
directive|define
name|STRING_DEFINE
value|STR_D STR_E STR_F STR_I STR_N STR_E
end_define
begin_define
DECL|macro|STRING_WEIRD_STARTWORD
define|#
directive|define
name|STRING_WEIRD_STARTWORD
value|STR_LEFT_SQUARE_BRACKET STR_COLON STR_LESS_THAN_SIGN STR_COLON STR_RIGHT_SQUARE_BRACKET STR_RIGHT_SQUARE_BRACKET
end_define
begin_define
DECL|macro|STRING_WEIRD_ENDWORD
define|#
directive|define
name|STRING_WEIRD_ENDWORD
value|STR_LEFT_SQUARE_BRACKET STR_COLON STR_GREATER_THAN_SIGN STR_COLON STR_RIGHT_SQUARE_BRACKET STR_RIGHT_SQUARE_BRACKET
end_define
begin_define
DECL|macro|STRING_CR_RIGHTPAR
define|#
directive|define
name|STRING_CR_RIGHTPAR
value|STR_C STR_R STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_LF_RIGHTPAR
define|#
directive|define
name|STRING_LF_RIGHTPAR
value|STR_L STR_F STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_CRLF_RIGHTPAR
define|#
directive|define
name|STRING_CRLF_RIGHTPAR
value|STR_C STR_R STR_L STR_F STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_ANY_RIGHTPAR
define|#
directive|define
name|STRING_ANY_RIGHTPAR
value|STR_A STR_N STR_Y STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_ANYCRLF_RIGHTPAR
define|#
directive|define
name|STRING_ANYCRLF_RIGHTPAR
value|STR_A STR_N STR_Y STR_C STR_R STR_L STR_F STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_BSR_ANYCRLF_RIGHTPAR
define|#
directive|define
name|STRING_BSR_ANYCRLF_RIGHTPAR
value|STR_B STR_S STR_R STR_UNDERSCORE STR_A STR_N STR_Y STR_C STR_R STR_L STR_F STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_BSR_UNICODE_RIGHTPAR
define|#
directive|define
name|STRING_BSR_UNICODE_RIGHTPAR
value|STR_B STR_S STR_R STR_UNDERSCORE STR_U STR_N STR_I STR_C STR_O STR_D STR_E STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_UTF8_RIGHTPAR
define|#
directive|define
name|STRING_UTF8_RIGHTPAR
value|STR_U STR_T STR_F STR_8 STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_UTF16_RIGHTPAR
define|#
directive|define
name|STRING_UTF16_RIGHTPAR
value|STR_U STR_T STR_F STR_1 STR_6 STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_UTF32_RIGHTPAR
define|#
directive|define
name|STRING_UTF32_RIGHTPAR
value|STR_U STR_T STR_F STR_3 STR_2 STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_UTF_RIGHTPAR
define|#
directive|define
name|STRING_UTF_RIGHTPAR
value|STR_U STR_T STR_F STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_UCP_RIGHTPAR
define|#
directive|define
name|STRING_UCP_RIGHTPAR
value|STR_U STR_C STR_P STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_NO_AUTO_POSSESS_RIGHTPAR
define|#
directive|define
name|STRING_NO_AUTO_POSSESS_RIGHTPAR
value|STR_N STR_O STR_UNDERSCORE STR_A STR_U STR_T STR_O STR_UNDERSCORE STR_P STR_O STR_S STR_S STR_E STR_S STR_S STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_NO_START_OPT_RIGHTPAR
define|#
directive|define
name|STRING_NO_START_OPT_RIGHTPAR
value|STR_N STR_O STR_UNDERSCORE STR_S STR_T STR_A STR_R STR_T STR_UNDERSCORE STR_O STR_P STR_T STR_RIGHT_PARENTHESIS
end_define
begin_define
DECL|macro|STRING_LIMIT_MATCH_EQ
define|#
directive|define
name|STRING_LIMIT_MATCH_EQ
value|STR_L STR_I STR_M STR_I STR_T STR_UNDERSCORE STR_M STR_A STR_T STR_C STR_H STR_EQUALS_SIGN
end_define
begin_define
DECL|macro|STRING_LIMIT_RECURSION_EQ
define|#
directive|define
name|STRING_LIMIT_RECURSION_EQ
value|STR_L STR_I STR_M STR_I STR_T STR_UNDERSCORE STR_R STR_E STR_C STR_U STR_R STR_S STR_I STR_O STR_N STR_EQUALS_SIGN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UTF */
end_comment
begin_comment
comment|/* Escape items that are just an encoding of a particular data value. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ESC_e
end_ifndef
begin_define
DECL|macro|ESC_e
define|#
directive|define
name|ESC_e
value|CHAR_ESC
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|ESC_f
end_ifndef
begin_define
DECL|macro|ESC_f
define|#
directive|define
name|ESC_f
value|CHAR_FF
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|ESC_n
end_ifndef
begin_define
DECL|macro|ESC_n
define|#
directive|define
name|ESC_n
value|CHAR_LF
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|ESC_r
end_ifndef
begin_define
DECL|macro|ESC_r
define|#
directive|define
name|ESC_r
value|CHAR_CR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* We can't officially use ESC_t because it is a POSIX reserved identifier (presumably because of all the others like size_t). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ESC_tee
end_ifndef
begin_define
DECL|macro|ESC_tee
define|#
directive|define
name|ESC_tee
value|CHAR_HT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Codes for different types of Unicode property */
end_comment
begin_define
DECL|macro|PT_ANY
define|#
directive|define
name|PT_ANY
value|0
end_define
begin_comment
DECL|macro|PT_ANY
comment|/* Any property - matches all chars */
end_comment
begin_define
DECL|macro|PT_LAMP
define|#
directive|define
name|PT_LAMP
value|1
end_define
begin_comment
DECL|macro|PT_LAMP
comment|/* L& - the union of Lu, Ll, Lt */
end_comment
begin_define
DECL|macro|PT_GC
define|#
directive|define
name|PT_GC
value|2
end_define
begin_comment
DECL|macro|PT_GC
comment|/* Specified general characteristic (e.g. L) */
end_comment
begin_define
DECL|macro|PT_PC
define|#
directive|define
name|PT_PC
value|3
end_define
begin_comment
DECL|macro|PT_PC
comment|/* Specified particular characteristic (e.g. Lu) */
end_comment
begin_define
DECL|macro|PT_SC
define|#
directive|define
name|PT_SC
value|4
end_define
begin_comment
DECL|macro|PT_SC
comment|/* Script (e.g. Han) */
end_comment
begin_define
DECL|macro|PT_ALNUM
define|#
directive|define
name|PT_ALNUM
value|5
end_define
begin_comment
DECL|macro|PT_ALNUM
comment|/* Alphanumeric - the union of L and N */
end_comment
begin_define
DECL|macro|PT_SPACE
define|#
directive|define
name|PT_SPACE
value|6
end_define
begin_comment
DECL|macro|PT_SPACE
comment|/* Perl space - Z plus 9,10,12,13 */
end_comment
begin_define
DECL|macro|PT_PXSPACE
define|#
directive|define
name|PT_PXSPACE
value|7
end_define
begin_comment
DECL|macro|PT_PXSPACE
comment|/* POSIX space - Z plus 9,10,11,12,13 */
end_comment
begin_define
DECL|macro|PT_WORD
define|#
directive|define
name|PT_WORD
value|8
end_define
begin_comment
DECL|macro|PT_WORD
comment|/* Word - L plus N plus underscore */
end_comment
begin_define
DECL|macro|PT_CLIST
define|#
directive|define
name|PT_CLIST
value|9
end_define
begin_comment
DECL|macro|PT_CLIST
comment|/* Pseudo-property: match character list */
end_comment
begin_define
DECL|macro|PT_UCNC
define|#
directive|define
name|PT_UCNC
value|10
end_define
begin_comment
DECL|macro|PT_UCNC
comment|/* Universal Character nameable character */
end_comment
begin_define
DECL|macro|PT_TABSIZE
define|#
directive|define
name|PT_TABSIZE
value|11
end_define
begin_comment
DECL|macro|PT_TABSIZE
comment|/* Size of square table for autopossessify tests */
end_comment
begin_comment
comment|/* The following special properties are used only in XCLASS items, when POSIX classes are specified and PCRE_UCP is set - in other words, for Unicode handling of these classes. They are not available via the \p or \P escapes like those in the above list, and so they do not take part in the autopossessifying table. */
end_comment
begin_define
DECL|macro|PT_PXGRAPH
define|#
directive|define
name|PT_PXGRAPH
value|11
end_define
begin_comment
DECL|macro|PT_PXGRAPH
comment|/* [:graph:] - characters that mark the paper */
end_comment
begin_define
DECL|macro|PT_PXPRINT
define|#
directive|define
name|PT_PXPRINT
value|12
end_define
begin_comment
DECL|macro|PT_PXPRINT
comment|/* [:print:] - [:graph:] plus non-control spaces */
end_comment
begin_define
DECL|macro|PT_PXPUNCT
define|#
directive|define
name|PT_PXPUNCT
value|13
end_define
begin_comment
DECL|macro|PT_PXPUNCT
comment|/* [:punct:] - punctuation characters */
end_comment
begin_comment
comment|/* Flag bits and data types for the extended class (OP_XCLASS) for classes that contain characters with values greater than 255. */
end_comment
begin_define
DECL|macro|XCL_NOT
define|#
directive|define
name|XCL_NOT
value|0x01
end_define
begin_comment
DECL|macro|XCL_NOT
comment|/* Flag: this is a negative class */
end_comment
begin_define
DECL|macro|XCL_MAP
define|#
directive|define
name|XCL_MAP
value|0x02
end_define
begin_comment
DECL|macro|XCL_MAP
comment|/* Flag: a 32-byte map is present */
end_comment
begin_define
DECL|macro|XCL_HASPROP
define|#
directive|define
name|XCL_HASPROP
value|0x04
end_define
begin_comment
DECL|macro|XCL_HASPROP
comment|/* Flag: property checks are present. */
end_comment
begin_define
DECL|macro|XCL_END
define|#
directive|define
name|XCL_END
value|0
end_define
begin_comment
DECL|macro|XCL_END
comment|/* Marks end of individual items */
end_comment
begin_define
DECL|macro|XCL_SINGLE
define|#
directive|define
name|XCL_SINGLE
value|1
end_define
begin_comment
DECL|macro|XCL_SINGLE
comment|/* Single item (one multibyte char) follows */
end_comment
begin_define
DECL|macro|XCL_RANGE
define|#
directive|define
name|XCL_RANGE
value|2
end_define
begin_comment
DECL|macro|XCL_RANGE
comment|/* A range (two multibyte chars) follows */
end_comment
begin_define
DECL|macro|XCL_PROP
define|#
directive|define
name|XCL_PROP
value|3
end_define
begin_comment
DECL|macro|XCL_PROP
comment|/* Unicode property (2-byte property code follows) */
end_comment
begin_define
DECL|macro|XCL_NOTPROP
define|#
directive|define
name|XCL_NOTPROP
value|4
end_define
begin_comment
DECL|macro|XCL_NOTPROP
comment|/* Unicode inverted property (ditto) */
end_comment
begin_comment
comment|/* These are escaped items that aren't just an encoding of a particular data value such as \n. They must have non-zero values, as check_escape() returns 0 for a data character.  Also, they must appear in the same order as in the opcode definitions below, up to ESC_z. There's a dummy for OP_ALLANY because it corresponds to "." in DOTALL mode rather than an escape sequence. It is also used for [^] in JavaScript compatibility mode, and for \C in non-utf mode. In non-DOTALL mode, "." behaves like \N.  The special values ESC_DU, ESC_du, etc. are used instead of ESC_D, ESC_d, etc. when PCRE_UCP is set and replacement of \d etc by \p sequences is required. They must be contiguous, and remain in order so that the replacements can be looked up from a table.  Negative numbers are used to encode a backreference (\1, \2, \3, etc.) in check_escape(). There are two tests in the code for an escape greater than ESC_b and less than ESC_Z to detect the types that may be repeated. These are the types that consume characters. If any new escapes are put in between that don't consume a character, that code will have to change. */
end_comment
begin_enum
DECL|enumerator|ESC_A
DECL|enumerator|ESC_G
DECL|enumerator|ESC_K
DECL|enumerator|ESC_B
DECL|enumerator|ESC_b
DECL|enumerator|ESC_D
DECL|enumerator|ESC_d
DECL|enumerator|ESC_S
DECL|enumerator|ESC_s
enum|enum
block|{
name|ESC_A
init|=
literal|1
block|,
name|ESC_G
block|,
name|ESC_K
block|,
name|ESC_B
block|,
name|ESC_b
block|,
name|ESC_D
block|,
name|ESC_d
block|,
name|ESC_S
block|,
name|ESC_s
block|,
DECL|enumerator|ESC_W
DECL|enumerator|ESC_w
DECL|enumerator|ESC_N
DECL|enumerator|ESC_dum
DECL|enumerator|ESC_C
DECL|enumerator|ESC_P
DECL|enumerator|ESC_p
DECL|enumerator|ESC_R
DECL|enumerator|ESC_H
name|ESC_W
block|,
name|ESC_w
block|,
name|ESC_N
block|,
name|ESC_dum
block|,
name|ESC_C
block|,
name|ESC_P
block|,
name|ESC_p
block|,
name|ESC_R
block|,
name|ESC_H
block|,
DECL|enumerator|ESC_h
DECL|enumerator|ESC_V
DECL|enumerator|ESC_v
DECL|enumerator|ESC_X
DECL|enumerator|ESC_Z
DECL|enumerator|ESC_z
name|ESC_h
block|,
name|ESC_V
block|,
name|ESC_v
block|,
name|ESC_X
block|,
name|ESC_Z
block|,
name|ESC_z
block|,
DECL|enumerator|ESC_E
DECL|enumerator|ESC_Q
DECL|enumerator|ESC_g
DECL|enumerator|ESC_k
name|ESC_E
block|,
name|ESC_Q
block|,
name|ESC_g
block|,
name|ESC_k
block|,
DECL|enumerator|ESC_DU
DECL|enumerator|ESC_du
DECL|enumerator|ESC_SU
DECL|enumerator|ESC_su
DECL|enumerator|ESC_WU
DECL|enumerator|ESC_wu
name|ESC_DU
block|,
name|ESC_du
block|,
name|ESC_SU
block|,
name|ESC_su
block|,
name|ESC_WU
block|,
name|ESC_wu
block|}
enum|;
end_enum
begin_comment
comment|/********************** Opcode definitions ******************/
end_comment
begin_comment
comment|/****** NOTE NOTE NOTE ******  Starting from 1 (i.e. after OP_END), the values up to OP_EOD must correspond in order to the list of escapes immediately above. Furthermore, values up to OP_DOLLM must not be changed without adjusting the table called autoposstab in pcre_compile.c  Whenever this list is updated, the two macro definitions that follow must be updated to match. The possessification table called "opcode_possessify" in pcre_compile.c must also be updated, and also the tables called "coptable" and "poptable" in pcre_dfa_exec.c.  ****** NOTE NOTE NOTE ******/
end_comment
begin_comment
comment|/* The values between FIRST_AUTOTAB_OP and LAST_AUTOTAB_RIGHT_OP, inclusive, are used in a table for deciding whether a repeated character type can be auto-possessified. */
end_comment
begin_define
DECL|macro|FIRST_AUTOTAB_OP
define|#
directive|define
name|FIRST_AUTOTAB_OP
value|OP_NOT_DIGIT
end_define
begin_define
DECL|macro|LAST_AUTOTAB_LEFT_OP
define|#
directive|define
name|LAST_AUTOTAB_LEFT_OP
value|OP_EXTUNI
end_define
begin_define
DECL|macro|LAST_AUTOTAB_RIGHT_OP
define|#
directive|define
name|LAST_AUTOTAB_RIGHT_OP
value|OP_DOLLM
end_define
begin_enum
enum|enum
block|{
DECL|enumerator|OP_END
name|OP_END
block|,
comment|/* 0 End of pattern */
comment|/* Values corresponding to backslashed metacharacters */
DECL|enumerator|OP_SOD
name|OP_SOD
block|,
comment|/* 1 Start of data: \A */
DECL|enumerator|OP_SOM
name|OP_SOM
block|,
comment|/* 2 Start of match (subject + offset): \G */
DECL|enumerator|OP_SET_SOM
name|OP_SET_SOM
block|,
comment|/* 3 Set start of match (\K) */
DECL|enumerator|OP_NOT_WORD_BOUNDARY
name|OP_NOT_WORD_BOUNDARY
block|,
comment|/*  4 \B */
DECL|enumerator|OP_WORD_BOUNDARY
name|OP_WORD_BOUNDARY
block|,
comment|/*  5 \b */
DECL|enumerator|OP_NOT_DIGIT
name|OP_NOT_DIGIT
block|,
comment|/*  6 \D */
DECL|enumerator|OP_DIGIT
name|OP_DIGIT
block|,
comment|/*  7 \d */
DECL|enumerator|OP_NOT_WHITESPACE
name|OP_NOT_WHITESPACE
block|,
comment|/*  8 \S */
DECL|enumerator|OP_WHITESPACE
name|OP_WHITESPACE
block|,
comment|/*  9 \s */
DECL|enumerator|OP_NOT_WORDCHAR
name|OP_NOT_WORDCHAR
block|,
comment|/* 10 \W */
DECL|enumerator|OP_WORDCHAR
name|OP_WORDCHAR
block|,
comment|/* 11 \w */
DECL|enumerator|OP_ANY
name|OP_ANY
block|,
comment|/* 12 Match any character except newline (\N) */
DECL|enumerator|OP_ALLANY
name|OP_ALLANY
block|,
comment|/* 13 Match any character */
DECL|enumerator|OP_ANYBYTE
name|OP_ANYBYTE
block|,
comment|/* 14 Match any byte (\C); different to OP_ANY for UTF-8 */
DECL|enumerator|OP_NOTPROP
name|OP_NOTPROP
block|,
comment|/* 15 \P (not Unicode property) */
DECL|enumerator|OP_PROP
name|OP_PROP
block|,
comment|/* 16 \p (Unicode property) */
DECL|enumerator|OP_ANYNL
name|OP_ANYNL
block|,
comment|/* 17 \R (any newline sequence) */
DECL|enumerator|OP_NOT_HSPACE
name|OP_NOT_HSPACE
block|,
comment|/* 18 \H (not horizontal whitespace) */
DECL|enumerator|OP_HSPACE
name|OP_HSPACE
block|,
comment|/* 19 \h (horizontal whitespace) */
DECL|enumerator|OP_NOT_VSPACE
name|OP_NOT_VSPACE
block|,
comment|/* 20 \V (not vertical whitespace) */
DECL|enumerator|OP_VSPACE
name|OP_VSPACE
block|,
comment|/* 21 \v (vertical whitespace) */
DECL|enumerator|OP_EXTUNI
name|OP_EXTUNI
block|,
comment|/* 22 \X (extended Unicode sequence */
DECL|enumerator|OP_EODN
name|OP_EODN
block|,
comment|/* 23 End of data or \n at end of data (\Z) */
DECL|enumerator|OP_EOD
name|OP_EOD
block|,
comment|/* 24 End of data (\z) */
comment|/* Line end assertions */
DECL|enumerator|OP_DOLL
name|OP_DOLL
block|,
comment|/* 25 End of line - not multiline */
DECL|enumerator|OP_DOLLM
name|OP_DOLLM
block|,
comment|/* 26 End of line - multiline */
DECL|enumerator|OP_CIRC
name|OP_CIRC
block|,
comment|/* 27 Start of line - not multiline */
DECL|enumerator|OP_CIRCM
name|OP_CIRCM
block|,
comment|/* 28 Start of line - multiline */
comment|/* Single characters; caseful must precede the caseless ones */
DECL|enumerator|OP_CHAR
name|OP_CHAR
block|,
comment|/* 29 Match one character, casefully */
DECL|enumerator|OP_CHARI
name|OP_CHARI
block|,
comment|/* 30 Match one character, caselessly */
DECL|enumerator|OP_NOT
name|OP_NOT
block|,
comment|/* 31 Match one character, not the given one, casefully */
DECL|enumerator|OP_NOTI
name|OP_NOTI
block|,
comment|/* 32 Match one character, not the given one, caselessly */
comment|/* The following sets of 13 opcodes must always be kept in step because   the offset from the first one is used to generate the others. */
comment|/* Repeated characters; caseful must precede the caseless ones */
DECL|enumerator|OP_STAR
name|OP_STAR
block|,
comment|/* 33 The maximizing and minimizing versions of */
DECL|enumerator|OP_MINSTAR
name|OP_MINSTAR
block|,
comment|/* 34 these six opcodes must come in pairs, with */
DECL|enumerator|OP_PLUS
name|OP_PLUS
block|,
comment|/* 35 the minimizing one second. */
DECL|enumerator|OP_MINPLUS
name|OP_MINPLUS
block|,
comment|/* 36 */
DECL|enumerator|OP_QUERY
name|OP_QUERY
block|,
comment|/* 37 */
DECL|enumerator|OP_MINQUERY
name|OP_MINQUERY
block|,
comment|/* 38 */
DECL|enumerator|OP_UPTO
name|OP_UPTO
block|,
comment|/* 39 From 0 to n matches of one character, caseful*/
DECL|enumerator|OP_MINUPTO
name|OP_MINUPTO
block|,
comment|/* 40 */
DECL|enumerator|OP_EXACT
name|OP_EXACT
block|,
comment|/* 41 Exactly n matches */
DECL|enumerator|OP_POSSTAR
name|OP_POSSTAR
block|,
comment|/* 42 Possessified star, caseful */
DECL|enumerator|OP_POSPLUS
name|OP_POSPLUS
block|,
comment|/* 43 Possessified plus, caseful */
DECL|enumerator|OP_POSQUERY
name|OP_POSQUERY
block|,
comment|/* 44 Posesssified query, caseful */
DECL|enumerator|OP_POSUPTO
name|OP_POSUPTO
block|,
comment|/* 45 Possessified upto, caseful */
comment|/* Repeated characters; caseless must follow the caseful ones */
DECL|enumerator|OP_STARI
name|OP_STARI
block|,
comment|/* 46 */
DECL|enumerator|OP_MINSTARI
name|OP_MINSTARI
block|,
comment|/* 47 */
DECL|enumerator|OP_PLUSI
name|OP_PLUSI
block|,
comment|/* 48 */
DECL|enumerator|OP_MINPLUSI
name|OP_MINPLUSI
block|,
comment|/* 49 */
DECL|enumerator|OP_QUERYI
name|OP_QUERYI
block|,
comment|/* 50 */
DECL|enumerator|OP_MINQUERYI
name|OP_MINQUERYI
block|,
comment|/* 51 */
DECL|enumerator|OP_UPTOI
name|OP_UPTOI
block|,
comment|/* 52 From 0 to n matches of one character, caseless */
DECL|enumerator|OP_MINUPTOI
name|OP_MINUPTOI
block|,
comment|/* 53 */
DECL|enumerator|OP_EXACTI
name|OP_EXACTI
block|,
comment|/* 54 */
DECL|enumerator|OP_POSSTARI
name|OP_POSSTARI
block|,
comment|/* 55 Possessified star, caseless */
DECL|enumerator|OP_POSPLUSI
name|OP_POSPLUSI
block|,
comment|/* 56 Possessified plus, caseless */
DECL|enumerator|OP_POSQUERYI
name|OP_POSQUERYI
block|,
comment|/* 57 Posesssified query, caseless */
DECL|enumerator|OP_POSUPTOI
name|OP_POSUPTOI
block|,
comment|/* 58 Possessified upto, caseless */
comment|/* The negated ones must follow the non-negated ones, and match them */
comment|/* Negated repeated character, caseful; must precede the caseless ones */
DECL|enumerator|OP_NOTSTAR
name|OP_NOTSTAR
block|,
comment|/* 59 The maximizing and minimizing versions of */
DECL|enumerator|OP_NOTMINSTAR
name|OP_NOTMINSTAR
block|,
comment|/* 60 these six opcodes must come in pairs, with */
DECL|enumerator|OP_NOTPLUS
name|OP_NOTPLUS
block|,
comment|/* 61 the minimizing one second. They must be in */
DECL|enumerator|OP_NOTMINPLUS
name|OP_NOTMINPLUS
block|,
comment|/* 62 exactly the same order as those above. */
DECL|enumerator|OP_NOTQUERY
name|OP_NOTQUERY
block|,
comment|/* 63 */
DECL|enumerator|OP_NOTMINQUERY
name|OP_NOTMINQUERY
block|,
comment|/* 64 */
DECL|enumerator|OP_NOTUPTO
name|OP_NOTUPTO
block|,
comment|/* 65 From 0 to n matches, caseful */
DECL|enumerator|OP_NOTMINUPTO
name|OP_NOTMINUPTO
block|,
comment|/* 66 */
DECL|enumerator|OP_NOTEXACT
name|OP_NOTEXACT
block|,
comment|/* 67 Exactly n matches */
DECL|enumerator|OP_NOTPOSSTAR
name|OP_NOTPOSSTAR
block|,
comment|/* 68 Possessified versions, caseful */
DECL|enumerator|OP_NOTPOSPLUS
name|OP_NOTPOSPLUS
block|,
comment|/* 69 */
DECL|enumerator|OP_NOTPOSQUERY
name|OP_NOTPOSQUERY
block|,
comment|/* 70 */
DECL|enumerator|OP_NOTPOSUPTO
name|OP_NOTPOSUPTO
block|,
comment|/* 71 */
comment|/* Negated repeated character, caseless; must follow the caseful ones */
DECL|enumerator|OP_NOTSTARI
name|OP_NOTSTARI
block|,
comment|/* 72 */
DECL|enumerator|OP_NOTMINSTARI
name|OP_NOTMINSTARI
block|,
comment|/* 73 */
DECL|enumerator|OP_NOTPLUSI
name|OP_NOTPLUSI
block|,
comment|/* 74 */
DECL|enumerator|OP_NOTMINPLUSI
name|OP_NOTMINPLUSI
block|,
comment|/* 75 */
DECL|enumerator|OP_NOTQUERYI
name|OP_NOTQUERYI
block|,
comment|/* 76 */
DECL|enumerator|OP_NOTMINQUERYI
name|OP_NOTMINQUERYI
block|,
comment|/* 77 */
DECL|enumerator|OP_NOTUPTOI
name|OP_NOTUPTOI
block|,
comment|/* 78 From 0 to n matches, caseless */
DECL|enumerator|OP_NOTMINUPTOI
name|OP_NOTMINUPTOI
block|,
comment|/* 79 */
DECL|enumerator|OP_NOTEXACTI
name|OP_NOTEXACTI
block|,
comment|/* 80 Exactly n matches */
DECL|enumerator|OP_NOTPOSSTARI
name|OP_NOTPOSSTARI
block|,
comment|/* 81 Possessified versions, caseless */
DECL|enumerator|OP_NOTPOSPLUSI
name|OP_NOTPOSPLUSI
block|,
comment|/* 82 */
DECL|enumerator|OP_NOTPOSQUERYI
name|OP_NOTPOSQUERYI
block|,
comment|/* 83 */
DECL|enumerator|OP_NOTPOSUPTOI
name|OP_NOTPOSUPTOI
block|,
comment|/* 84 */
comment|/* Character types */
DECL|enumerator|OP_TYPESTAR
name|OP_TYPESTAR
block|,
comment|/* 85 The maximizing and minimizing versions of */
DECL|enumerator|OP_TYPEMINSTAR
name|OP_TYPEMINSTAR
block|,
comment|/* 86 these six opcodes must come in pairs, with */
DECL|enumerator|OP_TYPEPLUS
name|OP_TYPEPLUS
block|,
comment|/* 87 the minimizing one second. These codes must */
DECL|enumerator|OP_TYPEMINPLUS
name|OP_TYPEMINPLUS
block|,
comment|/* 88 be in exactly the same order as those above. */
DECL|enumerator|OP_TYPEQUERY
name|OP_TYPEQUERY
block|,
comment|/* 89 */
DECL|enumerator|OP_TYPEMINQUERY
name|OP_TYPEMINQUERY
block|,
comment|/* 90 */
DECL|enumerator|OP_TYPEUPTO
name|OP_TYPEUPTO
block|,
comment|/* 91 From 0 to n matches */
DECL|enumerator|OP_TYPEMINUPTO
name|OP_TYPEMINUPTO
block|,
comment|/* 92 */
DECL|enumerator|OP_TYPEEXACT
name|OP_TYPEEXACT
block|,
comment|/* 93 Exactly n matches */
DECL|enumerator|OP_TYPEPOSSTAR
name|OP_TYPEPOSSTAR
block|,
comment|/* 94 Possessified versions */
DECL|enumerator|OP_TYPEPOSPLUS
name|OP_TYPEPOSPLUS
block|,
comment|/* 95 */
DECL|enumerator|OP_TYPEPOSQUERY
name|OP_TYPEPOSQUERY
block|,
comment|/* 96 */
DECL|enumerator|OP_TYPEPOSUPTO
name|OP_TYPEPOSUPTO
block|,
comment|/* 97 */
comment|/* These are used for character classes and back references; only the   first six are the same as the sets above. */
DECL|enumerator|OP_CRSTAR
name|OP_CRSTAR
block|,
comment|/* 98 The maximizing and minimizing versions of */
DECL|enumerator|OP_CRMINSTAR
name|OP_CRMINSTAR
block|,
comment|/* 99 all these opcodes must come in pairs, with */
DECL|enumerator|OP_CRPLUS
name|OP_CRPLUS
block|,
comment|/* 100 the minimizing one second. These codes must */
DECL|enumerator|OP_CRMINPLUS
name|OP_CRMINPLUS
block|,
comment|/* 101 be in exactly the same order as those above. */
DECL|enumerator|OP_CRQUERY
name|OP_CRQUERY
block|,
comment|/* 102 */
DECL|enumerator|OP_CRMINQUERY
name|OP_CRMINQUERY
block|,
comment|/* 103 */
DECL|enumerator|OP_CRRANGE
name|OP_CRRANGE
block|,
comment|/* 104 These are different to the three sets above. */
DECL|enumerator|OP_CRMINRANGE
name|OP_CRMINRANGE
block|,
comment|/* 105 */
DECL|enumerator|OP_CRPOSSTAR
name|OP_CRPOSSTAR
block|,
comment|/* 106 Possessified versions */
DECL|enumerator|OP_CRPOSPLUS
name|OP_CRPOSPLUS
block|,
comment|/* 107 */
DECL|enumerator|OP_CRPOSQUERY
name|OP_CRPOSQUERY
block|,
comment|/* 108 */
DECL|enumerator|OP_CRPOSRANGE
name|OP_CRPOSRANGE
block|,
comment|/* 109 */
comment|/* End of quantifier opcodes */
DECL|enumerator|OP_CLASS
name|OP_CLASS
block|,
comment|/* 110 Match a character class, chars< 256 only */
DECL|enumerator|OP_NCLASS
name|OP_NCLASS
block|,
comment|/* 111 Same, but the bitmap was created from a negative                               class - the difference is relevant only when a                               character> 255 is encountered. */
DECL|enumerator|OP_XCLASS
name|OP_XCLASS
block|,
comment|/* 112 Extended class for handling> 255 chars within the                               class. This does both positive and negative. */
DECL|enumerator|OP_REF
name|OP_REF
block|,
comment|/* 113 Match a back reference, casefully */
DECL|enumerator|OP_REFI
name|OP_REFI
block|,
comment|/* 114 Match a back reference, caselessly */
DECL|enumerator|OP_DNREF
name|OP_DNREF
block|,
comment|/* 115 Match a duplicate name backref, casefully */
DECL|enumerator|OP_DNREFI
name|OP_DNREFI
block|,
comment|/* 116 Match a duplicate name backref, caselessly */
DECL|enumerator|OP_RECURSE
name|OP_RECURSE
block|,
comment|/* 117 Match a numbered subpattern (possibly recursive) */
DECL|enumerator|OP_CALLOUT
name|OP_CALLOUT
block|,
comment|/* 118 Call out to external function if provided */
DECL|enumerator|OP_ALT
name|OP_ALT
block|,
comment|/* 119 Start of alternation */
DECL|enumerator|OP_KET
name|OP_KET
block|,
comment|/* 120 End of group that doesn't have an unbounded repeat */
DECL|enumerator|OP_KETRMAX
name|OP_KETRMAX
block|,
comment|/* 121 These two must remain together and in this */
DECL|enumerator|OP_KETRMIN
name|OP_KETRMIN
block|,
comment|/* 122 order. They are for groups the repeat for ever. */
DECL|enumerator|OP_KETRPOS
name|OP_KETRPOS
block|,
comment|/* 123 Possessive unlimited repeat. */
comment|/* The assertions must come before BRA, CBRA, ONCE, and COND, and the four   asserts must remain in order. */
DECL|enumerator|OP_REVERSE
name|OP_REVERSE
block|,
comment|/* 124 Move pointer back - used in lookbehind assertions */
DECL|enumerator|OP_ASSERT
name|OP_ASSERT
block|,
comment|/* 125 Positive lookahead */
DECL|enumerator|OP_ASSERT_NOT
name|OP_ASSERT_NOT
block|,
comment|/* 126 Negative lookahead */
DECL|enumerator|OP_ASSERTBACK
name|OP_ASSERTBACK
block|,
comment|/* 127 Positive lookbehind */
DECL|enumerator|OP_ASSERTBACK_NOT
name|OP_ASSERTBACK_NOT
block|,
comment|/* 128 Negative lookbehind */
comment|/* ONCE, ONCE_NC, BRA, BRAPOS, CBRA, CBRAPOS, and COND must come immediately   after the assertions, with ONCE first, as there's a test for>= ONCE for a   subpattern that isn't an assertion. The POS versions must immediately follow   the non-POS versions in each case. */
DECL|enumerator|OP_ONCE
name|OP_ONCE
block|,
comment|/* 129 Atomic group, contains captures */
DECL|enumerator|OP_ONCE_NC
name|OP_ONCE_NC
block|,
comment|/* 130 Atomic group containing no captures */
DECL|enumerator|OP_BRA
name|OP_BRA
block|,
comment|/* 131 Start of non-capturing bracket */
DECL|enumerator|OP_BRAPOS
name|OP_BRAPOS
block|,
comment|/* 132 Ditto, with unlimited, possessive repeat */
DECL|enumerator|OP_CBRA
name|OP_CBRA
block|,
comment|/* 133 Start of capturing bracket */
DECL|enumerator|OP_CBRAPOS
name|OP_CBRAPOS
block|,
comment|/* 134 Ditto, with unlimited, possessive repeat */
DECL|enumerator|OP_COND
name|OP_COND
block|,
comment|/* 135 Conditional group */
comment|/* These five must follow the previous five, in the same order. There's a   check for>= SBRA to distinguish the two sets. */
DECL|enumerator|OP_SBRA
name|OP_SBRA
block|,
comment|/* 136 Start of non-capturing bracket, check empty  */
DECL|enumerator|OP_SBRAPOS
name|OP_SBRAPOS
block|,
comment|/* 137 Ditto, with unlimited, possessive repeat */
DECL|enumerator|OP_SCBRA
name|OP_SCBRA
block|,
comment|/* 138 Start of capturing bracket, check empty */
DECL|enumerator|OP_SCBRAPOS
name|OP_SCBRAPOS
block|,
comment|/* 139 Ditto, with unlimited, possessive repeat */
DECL|enumerator|OP_SCOND
name|OP_SCOND
block|,
comment|/* 140 Conditional group, check empty */
comment|/* The next two pairs must (respectively) be kept together. */
DECL|enumerator|OP_CREF
name|OP_CREF
block|,
comment|/* 141 Used to hold a capture number as condition */
DECL|enumerator|OP_DNCREF
name|OP_DNCREF
block|,
comment|/* 142 Used to point to duplicate names as a condition */
DECL|enumerator|OP_RREF
name|OP_RREF
block|,
comment|/* 143 Used to hold a recursion number as condition */
DECL|enumerator|OP_DNRREF
name|OP_DNRREF
block|,
comment|/* 144 Used to point to duplicate names as a condition */
DECL|enumerator|OP_DEF
name|OP_DEF
block|,
comment|/* 145 The DEFINE condition */
DECL|enumerator|OP_BRAZERO
name|OP_BRAZERO
block|,
comment|/* 146 These two must remain together and in this */
DECL|enumerator|OP_BRAMINZERO
name|OP_BRAMINZERO
block|,
comment|/* 147 order. */
DECL|enumerator|OP_BRAPOSZERO
name|OP_BRAPOSZERO
block|,
comment|/* 148 */
comment|/* These are backtracking control verbs */
DECL|enumerator|OP_MARK
name|OP_MARK
block|,
comment|/* 149 always has an argument */
DECL|enumerator|OP_PRUNE
name|OP_PRUNE
block|,
comment|/* 150 */
DECL|enumerator|OP_PRUNE_ARG
name|OP_PRUNE_ARG
block|,
comment|/* 151 same, but with argument */
DECL|enumerator|OP_SKIP
name|OP_SKIP
block|,
comment|/* 152 */
DECL|enumerator|OP_SKIP_ARG
name|OP_SKIP_ARG
block|,
comment|/* 153 same, but with argument */
DECL|enumerator|OP_THEN
name|OP_THEN
block|,
comment|/* 154 */
DECL|enumerator|OP_THEN_ARG
name|OP_THEN_ARG
block|,
comment|/* 155 same, but with argument */
DECL|enumerator|OP_COMMIT
name|OP_COMMIT
block|,
comment|/* 156 */
comment|/* These are forced failure and success verbs */
DECL|enumerator|OP_FAIL
name|OP_FAIL
block|,
comment|/* 157 */
DECL|enumerator|OP_ACCEPT
name|OP_ACCEPT
block|,
comment|/* 158 */
DECL|enumerator|OP_ASSERT_ACCEPT
name|OP_ASSERT_ACCEPT
block|,
comment|/* 159 Used inside assertions */
DECL|enumerator|OP_CLOSE
name|OP_CLOSE
block|,
comment|/* 160 Used before OP_ACCEPT to close open captures */
comment|/* This is used to skip a subpattern with a {0} quantifier */
DECL|enumerator|OP_SKIPZERO
name|OP_SKIPZERO
block|,
comment|/* 161 */
comment|/* This is not an opcode, but is used to check that tables indexed by opcode   are the correct length, in order to catch updating errors - there have been   some in the past. */
DECL|enumerator|OP_TABLE_LENGTH
name|OP_TABLE_LENGTH
block|}
enum|;
end_enum
begin_comment
comment|/* *** NOTE NOTE NOTE *** Whenever the list above is updated, the two macro definitions that follow must also be updated to match. There are also tables called "opcode_possessify" in pcre_compile.c and "coptable" and "poptable" in pcre_dfa_exec.c that must be updated. */
end_comment
begin_comment
comment|/* This macro defines textual names for all the opcodes. These are used only for debugging, and some of them are only partial names. The macro is referenced only in pcre_printint.c, which fills out the full names in many cases (and in some cases doesn't actually use these names at all). */
end_comment
begin_define
DECL|macro|OP_NAME_LIST
define|#
directive|define
name|OP_NAME_LIST
define|\
value|"End", "\\A", "\\G", "\\K", "\\B", "\\b", "\\D", "\\d",         \   "\\S", "\\s", "\\W", "\\w", "Any", "AllAny", "Anybyte",         \   "notprop", "prop", "\\R", "\\H", "\\h", "\\V", "\\v",           \   "extuni",  "\\Z", "\\z",                                        \   "$", "$", "^", "^", "char", "chari", "not", "noti",             \   "*", "*?", "+", "+?", "?", "??",                                \   "{", "{", "{",                                                  \   "*+","++", "?+", "{",                                           \   "*", "*?", "+", "+?", "?", "??",                                \   "{", "{", "{",                                                  \   "*+","++", "?+", "{",                                           \   "*", "*?", "+", "+?", "?", "??",                                \   "{", "{", "{",                                                  \   "*+","++", "?+", "{",                                           \   "*", "*?", "+", "+?", "?", "??",                                \   "{", "{", "{",                                                  \   "*+","++", "?+", "{",                                           \   "*", "*?", "+", "+?", "?", "??", "{", "{", "{",                 \   "*+","++", "?+", "{",                                           \   "*", "*?", "+", "+?", "?", "??", "{", "{",                      \   "*+","++", "?+", "{",                                           \   "class", "nclass", "xclass", "Ref", "Refi", "DnRef", "DnRefi",  \   "Recurse", "Callout",                                           \   "Alt", "Ket", "KetRmax", "KetRmin", "KetRpos",                  \   "Reverse", "Assert", "Assert not", "AssertB", "AssertB not",    \   "Once", "Once_NC",                                              \   "Bra", "BraPos", "CBra", "CBraPos",                             \   "Cond",                                                         \   "SBra", "SBraPos", "SCBra", "SCBraPos",                         \   "SCond",                                                        \   "Cond ref", "Cond dnref", "Cond rec", "Cond dnrec", "Cond def", \   "Brazero", "Braminzero", "Braposzero",                          \   "*MARK", "*PRUNE", "*PRUNE", "*SKIP", "*SKIP",                  \   "*THEN", "*THEN", "*COMMIT", "*FAIL",                           \   "*ACCEPT", "*ASSERT_ACCEPT",                                    \   "Close", "Skip zero"
end_define
begin_comment
comment|/* This macro defines the length of fixed length operations in the compiled regex. The lengths are used when searching for specific things, and also in the debugging printing of a compiled regex. We use a macro so that it can be defined close to the definitions of the opcodes themselves.  As things have been extended, some of these are no longer fixed lenths, but are minima instead. For example, the length of a single-character repeat may vary in UTF-8 mode. The code that uses this table must know about such things. */
end_comment
begin_define
DECL|macro|OP_LENGTHS
define|#
directive|define
name|OP_LENGTHS
define|\
value|1,
comment|/* End                                    */
value|\   1, 1, 1, 1, 1,
comment|/* \A, \G, \K, \B, \b                     */
value|\   1, 1, 1, 1, 1, 1,
comment|/* \D, \d, \S, \s, \W, \w                 */
value|\   1, 1, 1,
comment|/* Any, AllAny, Anybyte                   */
value|\   3, 3,
comment|/* \P, \p                                 */
value|\   1, 1, 1, 1, 1,
comment|/* \R, \H, \h, \V, \v                     */
value|\   1,
comment|/* \X                                     */
value|\   1, 1, 1, 1, 1, 1,
comment|/* \Z, \z, $, $M ^, ^M                    */
value|\   2,
comment|/* Char  - the minimum length             */
value|\   2,
comment|/* Chari  - the minimum length            */
value|\   2,
comment|/* not                                    */
value|\   2,
comment|/* noti                                   */
value|\
comment|/* Positive single-char repeats                             ** These are */
value|\   2, 2, 2, 2, 2, 2,
comment|/* *, *?, +, +?, ?, ??       ** minima in */
value|\   2+IMM2_SIZE, 2+IMM2_SIZE,
comment|/* upto, minupto             ** mode      */
value|\   2+IMM2_SIZE,
comment|/* exact                                  */
value|\   2, 2, 2, 2+IMM2_SIZE,
comment|/* *+, ++, ?+, upto+                      */
value|\   2, 2, 2, 2, 2, 2,
comment|/* *I, *?I, +I, +?I, ?I, ??I ** UTF-8     */
value|\   2+IMM2_SIZE, 2+IMM2_SIZE,
comment|/* upto I, minupto I                      */
value|\   2+IMM2_SIZE,
comment|/* exact I                                */
value|\   2, 2, 2, 2+IMM2_SIZE,
comment|/* *+I, ++I, ?+I, upto+I                  */
value|\
comment|/* Negative single-char repeats - only for chars< 256                   */
value|\   2, 2, 2, 2, 2, 2,
comment|/* NOT *, *?, +, +?, ?, ??                */
value|\   2+IMM2_SIZE, 2+IMM2_SIZE,
comment|/* NOT upto, minupto                      */
value|\   2+IMM2_SIZE,
comment|/* NOT exact                              */
value|\   2, 2, 2, 2+IMM2_SIZE,
comment|/* Possessive NOT *, +, ?, upto           */
value|\   2, 2, 2, 2, 2, 2,
comment|/* NOT *I, *?I, +I, +?I, ?I, ??I          */
value|\   2+IMM2_SIZE, 2+IMM2_SIZE,
comment|/* NOT upto I, minupto I                  */
value|\   2+IMM2_SIZE,
comment|/* NOT exact I                            */
value|\   2, 2, 2, 2+IMM2_SIZE,
comment|/* Possessive NOT *I, +I, ?I, upto I      */
value|\
comment|/* Positive type repeats                                                 */
value|\   2, 2, 2, 2, 2, 2,
comment|/* Type *, *?, +, +?, ?, ??               */
value|\   2+IMM2_SIZE, 2+IMM2_SIZE,
comment|/* Type upto, minupto                     */
value|\   2+IMM2_SIZE,
comment|/* Type exact                             */
value|\   2, 2, 2, 2+IMM2_SIZE,
comment|/* Possessive *+, ++, ?+, upto+           */
value|\
comment|/* Character class& ref repeats                                         */
value|\   1, 1, 1, 1, 1, 1,
comment|/* *, *?, +, +?, ?, ??                    */
value|\   1+2*IMM2_SIZE, 1+2*IMM2_SIZE,
comment|/* CRRANGE, CRMINRANGE                    */
value|\   1, 1, 1, 1+2*IMM2_SIZE,
comment|/* Possessive *+, ++, ?+, CRPOSRANGE      */
value|\   1+(32/sizeof(pcre_uchar)),
comment|/* CLASS                                  */
value|\   1+(32/sizeof(pcre_uchar)),
comment|/* NCLASS                                 */
value|\   0,
comment|/* XCLASS - variable length               */
value|\   1+IMM2_SIZE,
comment|/* REF                                    */
value|\   1+IMM2_SIZE,
comment|/* REFI                                   */
value|\   1+2*IMM2_SIZE,
comment|/* DNREF                                  */
value|\   1+2*IMM2_SIZE,
comment|/* DNREFI                                 */
value|\   1+LINK_SIZE,
comment|/* RECURSE                                */
value|\   2+2*LINK_SIZE,
comment|/* CALLOUT                                */
value|\   1+LINK_SIZE,
comment|/* Alt                                    */
value|\   1+LINK_SIZE,
comment|/* Ket                                    */
value|\   1+LINK_SIZE,
comment|/* KetRmax                                */
value|\   1+LINK_SIZE,
comment|/* KetRmin                                */
value|\   1+LINK_SIZE,
comment|/* KetRpos                                */
value|\   1+LINK_SIZE,
comment|/* Reverse                                */
value|\   1+LINK_SIZE,
comment|/* Assert                                 */
value|\   1+LINK_SIZE,
comment|/* Assert not                             */
value|\   1+LINK_SIZE,
comment|/* Assert behind                          */
value|\   1+LINK_SIZE,
comment|/* Assert behind not                      */
value|\   1+LINK_SIZE,
comment|/* ONCE                                   */
value|\   1+LINK_SIZE,
comment|/* ONCE_NC                                */
value|\   1+LINK_SIZE,
comment|/* BRA                                    */
value|\   1+LINK_SIZE,
comment|/* BRAPOS                                 */
value|\   1+LINK_SIZE+IMM2_SIZE,
comment|/* CBRA                                   */
value|\   1+LINK_SIZE+IMM2_SIZE,
comment|/* CBRAPOS                                */
value|\   1+LINK_SIZE,
comment|/* COND                                   */
value|\   1+LINK_SIZE,
comment|/* SBRA                                   */
value|\   1+LINK_SIZE,
comment|/* SBRAPOS                                */
value|\   1+LINK_SIZE+IMM2_SIZE,
comment|/* SCBRA                                  */
value|\   1+LINK_SIZE+IMM2_SIZE,
comment|/* SCBRAPOS                               */
value|\   1+LINK_SIZE,
comment|/* SCOND                                  */
value|\   1+IMM2_SIZE, 1+2*IMM2_SIZE,
comment|/* CREF, DNCREF                           */
value|\   1+IMM2_SIZE, 1+2*IMM2_SIZE,
comment|/* RREF, DNRREF                           */
value|\   1,
comment|/* DEF                                    */
value|\   1, 1, 1,
comment|/* BRAZERO, BRAMINZERO, BRAPOSZERO        */
value|\   3, 1, 3,
comment|/* MARK, PRUNE, PRUNE_ARG                 */
value|\   1, 3,
comment|/* SKIP, SKIP_ARG                         */
value|\   1, 3,
comment|/* THEN, THEN_ARG                         */
value|\   1, 1, 1, 1,
comment|/* COMMIT, FAIL, ACCEPT, ASSERT_ACCEPT    */
value|\   1+IMM2_SIZE, 1
end_define
begin_comment
comment|/* CLOSE, SKIPZERO                        */
end_comment
begin_comment
comment|/* A magic value for OP_RREF to indicate the "any recursion" condition. */
end_comment
begin_define
DECL|macro|RREF_ANY
define|#
directive|define
name|RREF_ANY
value|0xffff
end_define
begin_comment
comment|/* Compile time error code numbers. They are given names so that they can more easily be tracked. When a new number is added, the table called eint in pcreposix.c must be updated. */
end_comment
begin_enum
DECL|enumerator|ERR0
DECL|enumerator|ERR1
DECL|enumerator|ERR2
DECL|enumerator|ERR3
DECL|enumerator|ERR4
DECL|enumerator|ERR5
DECL|enumerator|ERR6
DECL|enumerator|ERR7
DECL|enumerator|ERR8
DECL|enumerator|ERR9
enum|enum
block|{
name|ERR0
block|,
name|ERR1
block|,
name|ERR2
block|,
name|ERR3
block|,
name|ERR4
block|,
name|ERR5
block|,
name|ERR6
block|,
name|ERR7
block|,
name|ERR8
block|,
name|ERR9
block|,
DECL|enumerator|ERR10
DECL|enumerator|ERR11
DECL|enumerator|ERR12
DECL|enumerator|ERR13
DECL|enumerator|ERR14
DECL|enumerator|ERR15
DECL|enumerator|ERR16
DECL|enumerator|ERR17
DECL|enumerator|ERR18
DECL|enumerator|ERR19
name|ERR10
block|,
name|ERR11
block|,
name|ERR12
block|,
name|ERR13
block|,
name|ERR14
block|,
name|ERR15
block|,
name|ERR16
block|,
name|ERR17
block|,
name|ERR18
block|,
name|ERR19
block|,
DECL|enumerator|ERR20
DECL|enumerator|ERR21
DECL|enumerator|ERR22
DECL|enumerator|ERR23
DECL|enumerator|ERR24
DECL|enumerator|ERR25
DECL|enumerator|ERR26
DECL|enumerator|ERR27
DECL|enumerator|ERR28
DECL|enumerator|ERR29
name|ERR20
block|,
name|ERR21
block|,
name|ERR22
block|,
name|ERR23
block|,
name|ERR24
block|,
name|ERR25
block|,
name|ERR26
block|,
name|ERR27
block|,
name|ERR28
block|,
name|ERR29
block|,
DECL|enumerator|ERR30
DECL|enumerator|ERR31
DECL|enumerator|ERR32
DECL|enumerator|ERR33
DECL|enumerator|ERR34
DECL|enumerator|ERR35
DECL|enumerator|ERR36
DECL|enumerator|ERR37
DECL|enumerator|ERR38
DECL|enumerator|ERR39
name|ERR30
block|,
name|ERR31
block|,
name|ERR32
block|,
name|ERR33
block|,
name|ERR34
block|,
name|ERR35
block|,
name|ERR36
block|,
name|ERR37
block|,
name|ERR38
block|,
name|ERR39
block|,
DECL|enumerator|ERR40
DECL|enumerator|ERR41
DECL|enumerator|ERR42
DECL|enumerator|ERR43
DECL|enumerator|ERR44
DECL|enumerator|ERR45
DECL|enumerator|ERR46
DECL|enumerator|ERR47
DECL|enumerator|ERR48
DECL|enumerator|ERR49
name|ERR40
block|,
name|ERR41
block|,
name|ERR42
block|,
name|ERR43
block|,
name|ERR44
block|,
name|ERR45
block|,
name|ERR46
block|,
name|ERR47
block|,
name|ERR48
block|,
name|ERR49
block|,
DECL|enumerator|ERR50
DECL|enumerator|ERR51
DECL|enumerator|ERR52
DECL|enumerator|ERR53
DECL|enumerator|ERR54
DECL|enumerator|ERR55
DECL|enumerator|ERR56
DECL|enumerator|ERR57
DECL|enumerator|ERR58
DECL|enumerator|ERR59
name|ERR50
block|,
name|ERR51
block|,
name|ERR52
block|,
name|ERR53
block|,
name|ERR54
block|,
name|ERR55
block|,
name|ERR56
block|,
name|ERR57
block|,
name|ERR58
block|,
name|ERR59
block|,
DECL|enumerator|ERR60
DECL|enumerator|ERR61
DECL|enumerator|ERR62
DECL|enumerator|ERR63
DECL|enumerator|ERR64
DECL|enumerator|ERR65
DECL|enumerator|ERR66
DECL|enumerator|ERR67
DECL|enumerator|ERR68
DECL|enumerator|ERR69
name|ERR60
block|,
name|ERR61
block|,
name|ERR62
block|,
name|ERR63
block|,
name|ERR64
block|,
name|ERR65
block|,
name|ERR66
block|,
name|ERR67
block|,
name|ERR68
block|,
name|ERR69
block|,
DECL|enumerator|ERR70
DECL|enumerator|ERR71
DECL|enumerator|ERR72
DECL|enumerator|ERR73
DECL|enumerator|ERR74
DECL|enumerator|ERR75
DECL|enumerator|ERR76
DECL|enumerator|ERR77
DECL|enumerator|ERR78
DECL|enumerator|ERR79
name|ERR70
block|,
name|ERR71
block|,
name|ERR72
block|,
name|ERR73
block|,
name|ERR74
block|,
name|ERR75
block|,
name|ERR76
block|,
name|ERR77
block|,
name|ERR78
block|,
name|ERR79
block|,
DECL|enumerator|ERR80
DECL|enumerator|ERR81
DECL|enumerator|ERR82
DECL|enumerator|ERR83
DECL|enumerator|ERR84
DECL|enumerator|ERR85
DECL|enumerator|ERRCOUNT
name|ERR80
block|,
name|ERR81
block|,
name|ERR82
block|,
name|ERR83
block|,
name|ERR84
block|,
name|ERR85
block|,
name|ERRCOUNT
block|}
enum|;
end_enum
begin_comment
comment|/* JIT compiling modes. The function list is indexed by them. */
end_comment
begin_enum
DECL|enumerator|JIT_COMPILE
DECL|enumerator|JIT_PARTIAL_SOFT_COMPILE
DECL|enumerator|JIT_PARTIAL_HARD_COMPILE
enum|enum
block|{
name|JIT_COMPILE
block|,
name|JIT_PARTIAL_SOFT_COMPILE
block|,
name|JIT_PARTIAL_HARD_COMPILE
block|,
DECL|enumerator|JIT_NUMBER_OF_COMPILE_MODES
name|JIT_NUMBER_OF_COMPILE_MODES
block|}
enum|;
end_enum
begin_comment
comment|/* The real format of the start of the pcre block; the index of names and the code vector run on as long as necessary after the end. We store an explicit offset to the name table so that if a regex is compiled on one host, saved, and then run on another where the size of pointers is different, all might still be well.  The size of the structure must be a multiple of 8 bytes. For the case of compiled-on-4 and run-on-8, we include an extra pointer that is always NULL so that there are an even number of pointers which therefore are a multiple of 8 bytes.  It is necessary to fork the struct for the 32 bit library, since it needs to use pcre_uint32 for first_char and req_char. We can't put an ifdef inside the typedef because pcretest needs access to the struct of the 8-, 16- and 32-bit variants.  *** WARNING *** When new fields are added to these structures, remember to adjust the code in pcre_byte_order.c that is concerned with swapping the byte order of the fields when a compiled regex is reloaded on a host with different endianness. *** WARNING *** There is also similar byte-flipping code in pcretest.c, which is used for testing the byte-flipping features. It must also be kept in step. *** WARNING *** */
end_comment
begin_typedef
DECL|struct|real_pcre8_or_16
typedef|typedef
struct|struct
name|real_pcre8_or_16
block|{
DECL|member|magic_number
name|pcre_uint32
name|magic_number
decl_stmt|;
DECL|member|size
name|pcre_uint32
name|size
decl_stmt|;
comment|/* Total that was malloced */
DECL|member|options
name|pcre_uint32
name|options
decl_stmt|;
comment|/* Public options */
DECL|member|flags
name|pcre_uint32
name|flags
decl_stmt|;
comment|/* Private flags */
DECL|member|limit_match
name|pcre_uint32
name|limit_match
decl_stmt|;
comment|/* Limit set from regex */
DECL|member|limit_recursion
name|pcre_uint32
name|limit_recursion
decl_stmt|;
comment|/* Limit set from regex */
DECL|member|first_char
name|pcre_uint16
name|first_char
decl_stmt|;
comment|/* Starting character */
DECL|member|req_char
name|pcre_uint16
name|req_char
decl_stmt|;
comment|/* This character must be seen */
DECL|member|max_lookbehind
name|pcre_uint16
name|max_lookbehind
decl_stmt|;
comment|/* Longest lookbehind (characters) */
DECL|member|top_bracket
name|pcre_uint16
name|top_bracket
decl_stmt|;
comment|/* Highest numbered group */
DECL|member|top_backref
name|pcre_uint16
name|top_backref
decl_stmt|;
comment|/* Highest numbered back reference */
DECL|member|name_table_offset
name|pcre_uint16
name|name_table_offset
decl_stmt|;
comment|/* Offset to name table that follows */
DECL|member|name_entry_size
name|pcre_uint16
name|name_entry_size
decl_stmt|;
comment|/* Size of any name items */
DECL|member|name_count
name|pcre_uint16
name|name_count
decl_stmt|;
comment|/* Number of name items */
DECL|member|ref_count
name|pcre_uint16
name|ref_count
decl_stmt|;
comment|/* Reference count */
DECL|member|dummy1
name|pcre_uint16
name|dummy1
decl_stmt|;
comment|/* To ensure size is a multiple of 8 */
DECL|member|dummy2
name|pcre_uint16
name|dummy2
decl_stmt|;
comment|/* To ensure size is a multiple of 8 */
DECL|member|dummy3
name|pcre_uint16
name|dummy3
decl_stmt|;
comment|/* To ensure size is a multiple of 8 */
DECL|member|tables
specifier|const
name|pcre_uint8
modifier|*
name|tables
decl_stmt|;
comment|/* Pointer to tables or NULL for std */
DECL|member|nullpad
name|void
modifier|*
name|nullpad
decl_stmt|;
comment|/* NULL padding */
block|}
DECL|typedef|real_pcre8_or_16
name|real_pcre8_or_16
typedef|;
end_typedef
begin_typedef
DECL|typedef|real_pcre
typedef|typedef
name|struct
name|real_pcre8_or_16
name|real_pcre
typedef|;
end_typedef
begin_typedef
DECL|typedef|real_pcre16
typedef|typedef
name|struct
name|real_pcre8_or_16
name|real_pcre16
typedef|;
end_typedef
begin_typedef
DECL|struct|real_pcre32
typedef|typedef
struct|struct
name|real_pcre32
block|{
DECL|member|magic_number
name|pcre_uint32
name|magic_number
decl_stmt|;
DECL|member|size
name|pcre_uint32
name|size
decl_stmt|;
comment|/* Total that was malloced */
DECL|member|options
name|pcre_uint32
name|options
decl_stmt|;
comment|/* Public options */
DECL|member|flags
name|pcre_uint32
name|flags
decl_stmt|;
comment|/* Private flags */
DECL|member|limit_match
name|pcre_uint32
name|limit_match
decl_stmt|;
comment|/* Limit set from regex */
DECL|member|limit_recursion
name|pcre_uint32
name|limit_recursion
decl_stmt|;
comment|/* Limit set from regex */
DECL|member|first_char
name|pcre_uint32
name|first_char
decl_stmt|;
comment|/* Starting character */
DECL|member|req_char
name|pcre_uint32
name|req_char
decl_stmt|;
comment|/* This character must be seen */
DECL|member|max_lookbehind
name|pcre_uint16
name|max_lookbehind
decl_stmt|;
comment|/* Longest lookbehind (characters) */
DECL|member|top_bracket
name|pcre_uint16
name|top_bracket
decl_stmt|;
comment|/* Highest numbered group */
DECL|member|top_backref
name|pcre_uint16
name|top_backref
decl_stmt|;
comment|/* Highest numbered back reference */
DECL|member|name_table_offset
name|pcre_uint16
name|name_table_offset
decl_stmt|;
comment|/* Offset to name table that follows */
DECL|member|name_entry_size
name|pcre_uint16
name|name_entry_size
decl_stmt|;
comment|/* Size of any name items */
DECL|member|name_count
name|pcre_uint16
name|name_count
decl_stmt|;
comment|/* Number of name items */
DECL|member|ref_count
name|pcre_uint16
name|ref_count
decl_stmt|;
comment|/* Reference count */
DECL|member|dummy
name|pcre_uint16
name|dummy
decl_stmt|;
comment|/* To ensure size is a multiple of 8 */
DECL|member|tables
specifier|const
name|pcre_uint8
modifier|*
name|tables
decl_stmt|;
comment|/* Pointer to tables or NULL for std */
DECL|member|nullpad
name|void
modifier|*
name|nullpad
decl_stmt|;
comment|/* NULL padding */
block|}
DECL|typedef|real_pcre32
name|real_pcre32
typedef|;
end_typedef
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_define
DECL|macro|REAL_PCRE
define|#
directive|define
name|REAL_PCRE
value|real_pcre
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_define
DECL|macro|REAL_PCRE
define|#
directive|define
name|REAL_PCRE
value|real_pcre16
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_define
DECL|macro|REAL_PCRE
define|#
directive|define
name|REAL_PCRE
value|real_pcre32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Assert that the size of REAL_PCRE is divisible by 8 */
end_comment
begin_typedef
DECL|typedef|__assert_real_pcre_size_divisible_8
typedef|typedef
name|int
name|__assert_real_pcre_size_divisible_8
index|[
operator|(
sizeof|sizeof
argument_list|(
name|REAL_PCRE
argument_list|)
operator|%
literal|8
operator|)
operator|==
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
index|]
typedef|;
end_typedef
begin_comment
comment|/* Needed in pcretest to access some fields in the real_pcre* structures  * directly. They're unified for 8/16/32 bits since the structs only differ  * after these fields; if that ever changes, need to fork those defines into  * 8/16 and 32 bit versions. */
end_comment
begin_define
DECL|macro|REAL_PCRE_MAGIC
define|#
directive|define
name|REAL_PCRE_MAGIC
parameter_list|(
name|re
parameter_list|)
value|(((REAL_PCRE*)re)->magic_number)
end_define
begin_define
DECL|macro|REAL_PCRE_SIZE
define|#
directive|define
name|REAL_PCRE_SIZE
parameter_list|(
name|re
parameter_list|)
value|(((REAL_PCRE*)re)->size)
end_define
begin_define
DECL|macro|REAL_PCRE_OPTIONS
define|#
directive|define
name|REAL_PCRE_OPTIONS
parameter_list|(
name|re
parameter_list|)
value|(((REAL_PCRE*)re)->options)
end_define
begin_define
DECL|macro|REAL_PCRE_FLAGS
define|#
directive|define
name|REAL_PCRE_FLAGS
parameter_list|(
name|re
parameter_list|)
value|(((REAL_PCRE*)re)->flags)
end_define
begin_comment
comment|/* The format of the block used to store data from pcre_study(). The same remark (see NOTE above) about extending this structure applies. */
end_comment
begin_typedef
DECL|struct|pcre_study_data
typedef|typedef
struct|struct
name|pcre_study_data
block|{
DECL|member|size
name|pcre_uint32
name|size
decl_stmt|;
comment|/* Total that was malloced */
DECL|member|flags
name|pcre_uint32
name|flags
decl_stmt|;
comment|/* Private flags */
DECL|member|start_bits
name|pcre_uint8
name|start_bits
index|[
literal|32
index|]
decl_stmt|;
comment|/* Starting char bits */
DECL|member|minlength
name|pcre_uint32
name|minlength
decl_stmt|;
comment|/* Minimum subject length */
block|}
DECL|typedef|pcre_study_data
name|pcre_study_data
typedef|;
end_typedef
begin_comment
comment|/* Structure for building a chain of open capturing subpatterns during compiling, so that instructions to close them can be compiled when (*ACCEPT) is encountered. This is also used to identify subpatterns that contain recursive back references to themselves, so that they can be made atomic. */
end_comment
begin_typedef
DECL|struct|open_capitem
typedef|typedef
struct|struct
name|open_capitem
block|{
DECL|member|next
name|struct
name|open_capitem
modifier|*
name|next
decl_stmt|;
comment|/* Chain link */
DECL|member|number
name|pcre_uint16
name|number
decl_stmt|;
comment|/* Capture number */
DECL|member|flag
name|pcre_uint16
name|flag
decl_stmt|;
comment|/* Set TRUE if recursive back ref */
block|}
DECL|typedef|open_capitem
name|open_capitem
typedef|;
end_typedef
begin_comment
comment|/* Structure for building a list of named groups during the first pass of compiling. */
end_comment
begin_typedef
DECL|struct|named_group
typedef|typedef
struct|struct
name|named_group
block|{
DECL|member|name
specifier|const
name|pcre_uchar
modifier|*
name|name
decl_stmt|;
comment|/* Points to the name in the pattern */
DECL|member|length
name|int
name|length
decl_stmt|;
comment|/* Length of the name */
DECL|member|number
name|pcre_uint32
name|number
decl_stmt|;
comment|/* Group number */
block|}
DECL|typedef|named_group
name|named_group
typedef|;
end_typedef
begin_comment
comment|/* Structure for passing "static" information around between the functions doing the compiling, so that they are thread-safe. */
end_comment
begin_typedef
DECL|struct|compile_data
typedef|typedef
struct|struct
name|compile_data
block|{
DECL|member|lcc
specifier|const
name|pcre_uint8
modifier|*
name|lcc
decl_stmt|;
comment|/* Points to lower casing table */
DECL|member|fcc
specifier|const
name|pcre_uint8
modifier|*
name|fcc
decl_stmt|;
comment|/* Points to case-flipping table */
DECL|member|cbits
specifier|const
name|pcre_uint8
modifier|*
name|cbits
decl_stmt|;
comment|/* Points to character type table */
DECL|member|ctypes
specifier|const
name|pcre_uint8
modifier|*
name|ctypes
decl_stmt|;
comment|/* Points to table of type maps */
DECL|member|start_workspace
specifier|const
name|pcre_uchar
modifier|*
name|start_workspace
decl_stmt|;
comment|/* The start of working space */
DECL|member|start_code
specifier|const
name|pcre_uchar
modifier|*
name|start_code
decl_stmt|;
comment|/* The start of the compiled code */
DECL|member|start_pattern
specifier|const
name|pcre_uchar
modifier|*
name|start_pattern
decl_stmt|;
comment|/* The start of the pattern */
DECL|member|end_pattern
specifier|const
name|pcre_uchar
modifier|*
name|end_pattern
decl_stmt|;
comment|/* The end of the pattern */
DECL|member|hwm
name|pcre_uchar
modifier|*
name|hwm
decl_stmt|;
comment|/* High watermark of workspace */
DECL|member|open_caps
name|open_capitem
modifier|*
name|open_caps
decl_stmt|;
comment|/* Chain of open capture items */
DECL|member|named_groups
name|named_group
modifier|*
name|named_groups
decl_stmt|;
comment|/* Points to vector in pre-compile */
DECL|member|name_table
name|pcre_uchar
modifier|*
name|name_table
decl_stmt|;
comment|/* The name/number table */
DECL|member|names_found
name|int
name|names_found
decl_stmt|;
comment|/* Number of entries so far */
DECL|member|name_entry_size
name|int
name|name_entry_size
decl_stmt|;
comment|/* Size of each entry */
DECL|member|named_group_list_size
name|int
name|named_group_list_size
decl_stmt|;
comment|/* Number of entries in the list */
DECL|member|workspace_size
name|int
name|workspace_size
decl_stmt|;
comment|/* Size of workspace */
DECL|member|bracount
name|unsigned
name|int
name|bracount
decl_stmt|;
comment|/* Count of capturing parens as we compile */
DECL|member|final_bracount
name|int
name|final_bracount
decl_stmt|;
comment|/* Saved value after first pass */
DECL|member|max_lookbehind
name|int
name|max_lookbehind
decl_stmt|;
comment|/* Maximum lookbehind (characters) */
DECL|member|top_backref
name|int
name|top_backref
decl_stmt|;
comment|/* Maximum back reference */
DECL|member|backref_map
name|unsigned
name|int
name|backref_map
decl_stmt|;
comment|/* Bitmap of low back refs */
DECL|member|namedrefcount
name|unsigned
name|int
name|namedrefcount
decl_stmt|;
comment|/* Number of backreferences by name */
DECL|member|parens_depth
name|int
name|parens_depth
decl_stmt|;
comment|/* Depth of nested parentheses */
DECL|member|assert_depth
name|int
name|assert_depth
decl_stmt|;
comment|/* Depth of nested assertions */
DECL|member|external_options
name|pcre_uint32
name|external_options
decl_stmt|;
comment|/* External (initial) options */
DECL|member|external_flags
name|pcre_uint32
name|external_flags
decl_stmt|;
comment|/* External flag bits to be set */
DECL|member|req_varyopt
name|int
name|req_varyopt
decl_stmt|;
comment|/* "After variable item" flag for reqbyte */
DECL|member|had_accept
name|BOOL
name|had_accept
decl_stmt|;
comment|/* (*ACCEPT) encountered */
DECL|member|had_pruneorskip
name|BOOL
name|had_pruneorskip
decl_stmt|;
comment|/* (*PRUNE) or (*SKIP) encountered */
DECL|member|check_lookbehind
name|BOOL
name|check_lookbehind
decl_stmt|;
comment|/* Lookbehinds need later checking */
DECL|member|dupnames
name|BOOL
name|dupnames
decl_stmt|;
comment|/* Duplicate names exist */
DECL|member|nltype
name|int
name|nltype
decl_stmt|;
comment|/* Newline type */
DECL|member|nllen
name|int
name|nllen
decl_stmt|;
comment|/* Newline string length */
DECL|member|nl
name|pcre_uchar
name|nl
index|[
literal|4
index|]
decl_stmt|;
comment|/* Newline string when fixed length */
block|}
DECL|typedef|compile_data
name|compile_data
typedef|;
end_typedef
begin_comment
comment|/* Structure for maintaining a chain of pointers to the currently incomplete branches, for testing for left recursion while compiling. */
end_comment
begin_typedef
DECL|struct|branch_chain
typedef|typedef
struct|struct
name|branch_chain
block|{
DECL|member|outer
name|struct
name|branch_chain
modifier|*
name|outer
decl_stmt|;
DECL|member|current_branch
name|pcre_uchar
modifier|*
name|current_branch
decl_stmt|;
block|}
DECL|typedef|branch_chain
name|branch_chain
typedef|;
end_typedef
begin_comment
comment|/* Structure for items in a linked list that represents an explicit recursive call within the pattern; used by pcre_exec(). */
end_comment
begin_typedef
DECL|struct|recursion_info
typedef|typedef
struct|struct
name|recursion_info
block|{
DECL|member|prevrec
name|struct
name|recursion_info
modifier|*
name|prevrec
decl_stmt|;
comment|/* Previous recursion record (or NULL) */
DECL|member|group_num
name|unsigned
name|int
name|group_num
decl_stmt|;
comment|/* Number of group that was called */
DECL|member|offset_save
name|int
modifier|*
name|offset_save
decl_stmt|;
comment|/* Pointer to start of saved offsets */
DECL|member|saved_max
name|int
name|saved_max
decl_stmt|;
comment|/* Number of saved offsets */
DECL|member|saved_capture_last
name|int
name|saved_capture_last
decl_stmt|;
comment|/* Last capture number */
DECL|member|subject_position
name|PCRE_PUCHAR
name|subject_position
decl_stmt|;
comment|/* Position at start of recursion */
block|}
DECL|typedef|recursion_info
name|recursion_info
typedef|;
end_typedef
begin_comment
comment|/* A similar structure for pcre_dfa_exec(). */
end_comment
begin_typedef
DECL|struct|dfa_recursion_info
typedef|typedef
struct|struct
name|dfa_recursion_info
block|{
DECL|member|prevrec
name|struct
name|dfa_recursion_info
modifier|*
name|prevrec
decl_stmt|;
DECL|member|group_num
name|int
name|group_num
decl_stmt|;
DECL|member|subject_position
name|PCRE_PUCHAR
name|subject_position
decl_stmt|;
block|}
DECL|typedef|dfa_recursion_info
name|dfa_recursion_info
typedef|;
end_typedef
begin_comment
comment|/* Structure for building a chain of data for holding the values of the subject pointer at the start of each subpattern, so as to detect when an empty string has been matched by a subpattern - to break infinite loops; used by pcre_exec(). */
end_comment
begin_typedef
DECL|struct|eptrblock
typedef|typedef
struct|struct
name|eptrblock
block|{
DECL|member|epb_prev
name|struct
name|eptrblock
modifier|*
name|epb_prev
decl_stmt|;
DECL|member|epb_saved_eptr
name|PCRE_PUCHAR
name|epb_saved_eptr
decl_stmt|;
block|}
DECL|typedef|eptrblock
name|eptrblock
typedef|;
end_typedef
begin_comment
comment|/* Structure for passing "static" information around between the functions doing traditional NFA matching, so that they are thread-safe. */
end_comment
begin_typedef
DECL|struct|match_data
typedef|typedef
struct|struct
name|match_data
block|{
DECL|member|match_call_count
name|unsigned
name|long
name|int
name|match_call_count
decl_stmt|;
comment|/* As it says */
DECL|member|match_limit
name|unsigned
name|long
name|int
name|match_limit
decl_stmt|;
comment|/* As it says */
DECL|member|match_limit_recursion
name|unsigned
name|long
name|int
name|match_limit_recursion
decl_stmt|;
comment|/* As it says */
DECL|member|offset_vector
name|int
modifier|*
name|offset_vector
decl_stmt|;
comment|/* Offset vector */
DECL|member|offset_end
name|int
name|offset_end
decl_stmt|;
comment|/* One past the end */
DECL|member|offset_max
name|int
name|offset_max
decl_stmt|;
comment|/* The maximum usable for return data */
DECL|member|nltype
name|int
name|nltype
decl_stmt|;
comment|/* Newline type */
DECL|member|nllen
name|int
name|nllen
decl_stmt|;
comment|/* Newline string length */
DECL|member|name_count
name|int
name|name_count
decl_stmt|;
comment|/* Number of names in name table */
DECL|member|name_entry_size
name|int
name|name_entry_size
decl_stmt|;
comment|/* Size of entry in names table */
DECL|member|skip_arg_count
name|unsigned
name|int
name|skip_arg_count
decl_stmt|;
comment|/* For counting SKIP_ARGs */
DECL|member|ignore_skip_arg
name|unsigned
name|int
name|ignore_skip_arg
decl_stmt|;
comment|/* For re-run when SKIP arg name not found */
DECL|member|name_table
name|pcre_uchar
modifier|*
name|name_table
decl_stmt|;
comment|/* Table of names */
DECL|member|nl
name|pcre_uchar
name|nl
index|[
literal|4
index|]
decl_stmt|;
comment|/* Newline string when fixed */
DECL|member|lcc
specifier|const
name|pcre_uint8
modifier|*
name|lcc
decl_stmt|;
comment|/* Points to lower casing table */
DECL|member|fcc
specifier|const
name|pcre_uint8
modifier|*
name|fcc
decl_stmt|;
comment|/* Points to case-flipping table */
DECL|member|ctypes
specifier|const
name|pcre_uint8
modifier|*
name|ctypes
decl_stmt|;
comment|/* Points to table of type maps */
DECL|member|notbol
name|BOOL
name|notbol
decl_stmt|;
comment|/* NOTBOL flag */
DECL|member|noteol
name|BOOL
name|noteol
decl_stmt|;
comment|/* NOTEOL flag */
DECL|member|utf
name|BOOL
name|utf
decl_stmt|;
comment|/* UTF-8 / UTF-16 flag */
DECL|member|jscript_compat
name|BOOL
name|jscript_compat
decl_stmt|;
comment|/* JAVASCRIPT_COMPAT flag */
DECL|member|use_ucp
name|BOOL
name|use_ucp
decl_stmt|;
comment|/* PCRE_UCP flag */
DECL|member|endonly
name|BOOL
name|endonly
decl_stmt|;
comment|/* Dollar not before final \n */
DECL|member|notempty
name|BOOL
name|notempty
decl_stmt|;
comment|/* Empty string match not wanted */
DECL|member|notempty_atstart
name|BOOL
name|notempty_atstart
decl_stmt|;
comment|/* Empty string match at start not wanted */
DECL|member|hitend
name|BOOL
name|hitend
decl_stmt|;
comment|/* Hit the end of the subject at some point */
DECL|member|bsr_anycrlf
name|BOOL
name|bsr_anycrlf
decl_stmt|;
comment|/* \R is just any CRLF, not full Unicode */
DECL|member|hasthen
name|BOOL
name|hasthen
decl_stmt|;
comment|/* Pattern contains (*THEN) */
DECL|member|start_code
specifier|const
name|pcre_uchar
modifier|*
name|start_code
decl_stmt|;
comment|/* For use when recursing */
DECL|member|start_subject
name|PCRE_PUCHAR
name|start_subject
decl_stmt|;
comment|/* Start of the subject string */
DECL|member|end_subject
name|PCRE_PUCHAR
name|end_subject
decl_stmt|;
comment|/* End of the subject string */
DECL|member|start_match_ptr
name|PCRE_PUCHAR
name|start_match_ptr
decl_stmt|;
comment|/* Start of matched string */
DECL|member|end_match_ptr
name|PCRE_PUCHAR
name|end_match_ptr
decl_stmt|;
comment|/* Subject position at end match */
DECL|member|start_used_ptr
name|PCRE_PUCHAR
name|start_used_ptr
decl_stmt|;
comment|/* Earliest consulted character */
DECL|member|partial
name|int
name|partial
decl_stmt|;
comment|/* PARTIAL options */
DECL|member|end_offset_top
name|int
name|end_offset_top
decl_stmt|;
comment|/* Highwater mark at end of match */
DECL|member|capture_last
name|pcre_int32
name|capture_last
decl_stmt|;
comment|/* Most recent capture number + overflow flag */
DECL|member|start_offset
name|int
name|start_offset
decl_stmt|;
comment|/* The start offset value */
DECL|member|match_function_type
name|int
name|match_function_type
decl_stmt|;
comment|/* Set for certain special calls of MATCH() */
DECL|member|eptrchain
name|eptrblock
modifier|*
name|eptrchain
decl_stmt|;
comment|/* Chain of eptrblocks for tail recursions */
DECL|member|eptrn
name|int
name|eptrn
decl_stmt|;
comment|/* Next free eptrblock */
DECL|member|recursive
name|recursion_info
modifier|*
name|recursive
decl_stmt|;
comment|/* Linked list of recursion data */
DECL|member|callout_data
name|void
modifier|*
name|callout_data
decl_stmt|;
comment|/* To pass back to callouts */
DECL|member|mark
specifier|const
name|pcre_uchar
modifier|*
name|mark
decl_stmt|;
comment|/* Mark pointer to pass back on success */
DECL|member|nomatch_mark
specifier|const
name|pcre_uchar
modifier|*
name|nomatch_mark
decl_stmt|;
comment|/* Mark pointer to pass back on failure */
DECL|member|once_target
specifier|const
name|pcre_uchar
modifier|*
name|once_target
decl_stmt|;
comment|/* Where to back up to for atomic groups */
ifdef|#
directive|ifdef
name|NO_RECURSE
DECL|member|match_frames_base
name|void
modifier|*
name|match_frames_base
decl_stmt|;
comment|/* For remembering malloc'd frames */
endif|#
directive|endif
block|}
DECL|typedef|match_data
name|match_data
typedef|;
end_typedef
begin_comment
comment|/* A similar structure is used for the same purpose by the DFA matching functions. */
end_comment
begin_typedef
DECL|struct|dfa_match_data
typedef|typedef
struct|struct
name|dfa_match_data
block|{
DECL|member|start_code
specifier|const
name|pcre_uchar
modifier|*
name|start_code
decl_stmt|;
comment|/* Start of the compiled pattern */
DECL|member|start_subject
specifier|const
name|pcre_uchar
modifier|*
name|start_subject
decl_stmt|;
comment|/* Start of the subject string */
DECL|member|end_subject
specifier|const
name|pcre_uchar
modifier|*
name|end_subject
decl_stmt|;
comment|/* End of subject string */
DECL|member|start_used_ptr
specifier|const
name|pcre_uchar
modifier|*
name|start_used_ptr
decl_stmt|;
comment|/* Earliest consulted character */
DECL|member|tables
specifier|const
name|pcre_uint8
modifier|*
name|tables
decl_stmt|;
comment|/* Character tables */
DECL|member|start_offset
name|int
name|start_offset
decl_stmt|;
comment|/* The start offset value */
DECL|member|moptions
name|int
name|moptions
decl_stmt|;
comment|/* Match options */
DECL|member|poptions
name|int
name|poptions
decl_stmt|;
comment|/* Pattern options */
DECL|member|nltype
name|int
name|nltype
decl_stmt|;
comment|/* Newline type */
DECL|member|nllen
name|int
name|nllen
decl_stmt|;
comment|/* Newline string length */
DECL|member|nl
name|pcre_uchar
name|nl
index|[
literal|4
index|]
decl_stmt|;
comment|/* Newline string when fixed */
DECL|member|callout_data
name|void
modifier|*
name|callout_data
decl_stmt|;
comment|/* To pass back to callouts */
DECL|member|recursive
name|dfa_recursion_info
modifier|*
name|recursive
decl_stmt|;
comment|/* Linked list of recursion data */
block|}
DECL|typedef|dfa_match_data
name|dfa_match_data
typedef|;
end_typedef
begin_comment
comment|/* Bit definitions for entries in the pcre_ctypes table. */
end_comment
begin_define
DECL|macro|ctype_space
define|#
directive|define
name|ctype_space
value|0x01
end_define
begin_define
DECL|macro|ctype_letter
define|#
directive|define
name|ctype_letter
value|0x02
end_define
begin_define
DECL|macro|ctype_digit
define|#
directive|define
name|ctype_digit
value|0x04
end_define
begin_define
DECL|macro|ctype_xdigit
define|#
directive|define
name|ctype_xdigit
value|0x08
end_define
begin_define
DECL|macro|ctype_word
define|#
directive|define
name|ctype_word
value|0x10
end_define
begin_comment
DECL|macro|ctype_word
comment|/* alphanumeric or '_' */
end_comment
begin_define
DECL|macro|ctype_meta
define|#
directive|define
name|ctype_meta
value|0x80
end_define
begin_comment
DECL|macro|ctype_meta
comment|/* regexp meta char or zero (end pattern) */
end_comment
begin_comment
comment|/* Offsets for the bitmap tables in pcre_cbits. Each table contains a set of bits for a class map. Some classes are built by combining these tables. */
end_comment
begin_define
DECL|macro|cbit_space
define|#
directive|define
name|cbit_space
value|0
end_define
begin_comment
DECL|macro|cbit_space
comment|/* [:space:] or \s */
end_comment
begin_define
DECL|macro|cbit_xdigit
define|#
directive|define
name|cbit_xdigit
value|32
end_define
begin_comment
DECL|macro|cbit_xdigit
comment|/* [:xdigit:] */
end_comment
begin_define
DECL|macro|cbit_digit
define|#
directive|define
name|cbit_digit
value|64
end_define
begin_comment
DECL|macro|cbit_digit
comment|/* [:digit:] or \d */
end_comment
begin_define
DECL|macro|cbit_upper
define|#
directive|define
name|cbit_upper
value|96
end_define
begin_comment
DECL|macro|cbit_upper
comment|/* [:upper:] */
end_comment
begin_define
DECL|macro|cbit_lower
define|#
directive|define
name|cbit_lower
value|128
end_define
begin_comment
DECL|macro|cbit_lower
comment|/* [:lower:] */
end_comment
begin_define
DECL|macro|cbit_word
define|#
directive|define
name|cbit_word
value|160
end_define
begin_comment
DECL|macro|cbit_word
comment|/* [:word:] or \w */
end_comment
begin_define
DECL|macro|cbit_graph
define|#
directive|define
name|cbit_graph
value|192
end_define
begin_comment
DECL|macro|cbit_graph
comment|/* [:graph:] */
end_comment
begin_define
DECL|macro|cbit_print
define|#
directive|define
name|cbit_print
value|224
end_define
begin_comment
DECL|macro|cbit_print
comment|/* [:print:] */
end_comment
begin_define
DECL|macro|cbit_punct
define|#
directive|define
name|cbit_punct
value|256
end_define
begin_comment
DECL|macro|cbit_punct
comment|/* [:punct:] */
end_comment
begin_define
DECL|macro|cbit_cntrl
define|#
directive|define
name|cbit_cntrl
value|288
end_define
begin_comment
DECL|macro|cbit_cntrl
comment|/* [:cntrl:] */
end_comment
begin_define
DECL|macro|cbit_length
define|#
directive|define
name|cbit_length
value|320
end_define
begin_comment
DECL|macro|cbit_length
comment|/* Length of the cbits table */
end_comment
begin_comment
comment|/* Offsets of the various tables from the base tables pointer, and total length. */
end_comment
begin_define
DECL|macro|lcc_offset
define|#
directive|define
name|lcc_offset
value|0
end_define
begin_define
DECL|macro|fcc_offset
define|#
directive|define
name|fcc_offset
value|256
end_define
begin_define
DECL|macro|cbits_offset
define|#
directive|define
name|cbits_offset
value|512
end_define
begin_define
DECL|macro|ctypes_offset
define|#
directive|define
name|ctypes_offset
value|(cbits_offset + cbit_length)
end_define
begin_define
DECL|macro|tables_length
define|#
directive|define
name|tables_length
value|(ctypes_offset + 256)
end_define
begin_comment
comment|/* Internal function and data prefixes. */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|PUBL
end_ifndef
begin_define
DECL|macro|PUBL
define|#
directive|define
name|PUBL
parameter_list|(
name|name
parameter_list|)
value|pcre_##name
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PRIV
end_ifndef
begin_define
DECL|macro|PRIV
define|#
directive|define
name|PRIV
parameter_list|(
name|name
parameter_list|)
value|_pcre_##name
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
end_elif
begin_ifndef
ifndef|#
directive|ifndef
name|PUBL
end_ifndef
begin_define
DECL|macro|PUBL
define|#
directive|define
name|PUBL
parameter_list|(
name|name
parameter_list|)
value|pcre16_##name
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PRIV
end_ifndef
begin_define
DECL|macro|PRIV
define|#
directive|define
name|PRIV
parameter_list|(
name|name
parameter_list|)
value|_pcre16_##name
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_ifndef
ifndef|#
directive|ifndef
name|PUBL
end_ifndef
begin_define
DECL|macro|PUBL
define|#
directive|define
name|PUBL
parameter_list|(
name|name
parameter_list|)
value|pcre32_##name
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PRIV
end_ifndef
begin_define
DECL|macro|PRIV
define|#
directive|define
name|PRIV
parameter_list|(
name|name
parameter_list|)
value|_pcre32_##name
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Unsupported compiling mode
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16|32] */
end_comment
begin_comment
comment|/* Layout of the UCP type table that translates property names into types and codes. Each entry used to point directly to a name, but to reduce the number of relocations in shared libraries, it now has an offset into a single string instead. */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|name_offset
name|pcre_uint16
name|name_offset
decl_stmt|;
DECL|member|type
name|pcre_uint16
name|type
decl_stmt|;
DECL|member|value
name|pcre_uint16
name|value
decl_stmt|;
block|}
DECL|typedef|ucp_type_table
name|ucp_type_table
typedef|;
end_typedef
begin_comment
comment|/* Internal shared data tables. These are tables that are used by more than one of the exported public functions. They have to be "external" in the C sense, but are not part of the PCRE public API. The data for these tables is in the pcre_tables.c module. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
end_ifdef
begin_decl_stmt
specifier|extern
specifier|const
name|int
name|PRIV
argument_list|(
name|utf8_table1
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|extern
specifier|const
name|int
name|PRIV
parameter_list|(
name|utf8_table1_size
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
specifier|extern
specifier|const
name|int
name|PRIV
argument_list|(
name|utf8_table2
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|int
name|PRIV
argument_list|(
name|utf8_table3
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint8
name|PRIV
argument_list|(
name|utf8_table4
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE8 */
end_comment
begin_decl_stmt
specifier|extern
specifier|const
name|char
name|PRIV
argument_list|(
name|utt_names
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|ucp_type_table
name|PRIV
argument_list|(
name|utt
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|extern
specifier|const
name|int
name|PRIV
parameter_list|(
name|utt_size
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint8
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint8
name|PRIV
argument_list|(
name|default_tables
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint32
name|PRIV
argument_list|(
name|hspace_list
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint32
name|PRIV
argument_list|(
name|vspace_list
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Internal shared functions. These are functions that are used by more than one of the exported public functions. They have to be "external" in the C sense, but are not part of the PCRE public API. */
end_comment
begin_comment
comment|/* String comparison functions. */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_define
DECL|macro|STRCMP_UC_UC
define|#
directive|define
name|STRCMP_UC_UC
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
define|\
value|strcmp((char *)(str1), (char *)(str2))
end_define
begin_define
DECL|macro|STRCMP_UC_C8
define|#
directive|define
name|STRCMP_UC_C8
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
define|\
value|strcmp((char *)(str1), (str2))
end_define
begin_define
DECL|macro|STRNCMP_UC_UC
define|#
directive|define
name|STRNCMP_UC_UC
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|,
name|num
parameter_list|)
define|\
value|strncmp((char *)(str1), (char *)(str2), (num))
end_define
begin_define
DECL|macro|STRNCMP_UC_C8
define|#
directive|define
name|STRNCMP_UC_C8
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|,
name|num
parameter_list|)
define|\
value|strncmp((char *)(str1), (str2), (num))
end_define
begin_define
DECL|macro|STRLEN_UC
define|#
directive|define
name|STRLEN_UC
parameter_list|(
name|str
parameter_list|)
value|strlen((const char *)str)
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
operator|||
name|defined
name|COMPILE_PCRE32
end_elif
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|strcmp_uc_uc
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|strcmp_uc_c8
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|strncmp_uc_uc
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|strncmp_uc_c8
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|unsigned
name|int
name|PRIV
function_decl|(
name|strlen_uc
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|STRCMP_UC_UC
define|#
directive|define
name|STRCMP_UC_UC
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
define|\
value|PRIV(strcmp_uc_uc)((str1), (str2))
end_define
begin_define
DECL|macro|STRCMP_UC_C8
define|#
directive|define
name|STRCMP_UC_C8
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
define|\
value|PRIV(strcmp_uc_c8)((str1), (str2))
end_define
begin_define
DECL|macro|STRNCMP_UC_UC
define|#
directive|define
name|STRNCMP_UC_UC
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|,
name|num
parameter_list|)
define|\
value|PRIV(strncmp_uc_uc)((str1), (str2), (num))
end_define
begin_define
DECL|macro|STRNCMP_UC_C8
define|#
directive|define
name|STRNCMP_UC_C8
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|,
name|num
parameter_list|)
define|\
value|PRIV(strncmp_uc_c8)((str1), (str2), (num))
end_define
begin_define
DECL|macro|STRLEN_UC
define|#
directive|define
name|STRLEN_UC
parameter_list|(
name|str
parameter_list|)
value|PRIV(strlen_uc)(str)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16|32] */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
operator|||
name|defined
name|COMPILE_PCRE16
end_if
begin_define
DECL|macro|STRCMP_UC_UC_TEST
define|#
directive|define
name|STRCMP_UC_UC_TEST
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
value|STRCMP_UC_UC(str1, str2)
end_define
begin_define
DECL|macro|STRCMP_UC_C8_TEST
define|#
directive|define
name|STRCMP_UC_C8_TEST
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
value|STRCMP_UC_C8(str1, str2)
end_define
begin_elif
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
end_elif
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|strcmp_uc_uc_utf
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|strcmp_uc_c8_utf
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|STRCMP_UC_UC_TEST
define|#
directive|define
name|STRCMP_UC_UC_TEST
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
define|\
value|(utf ? PRIV(strcmp_uc_uc_utf)((str1), (str2)) : PRIV(strcmp_uc_uc)((str1), (str2)))
end_define
begin_define
DECL|macro|STRCMP_UC_C8_TEST
define|#
directive|define
name|STRCMP_UC_C8_TEST
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
define|\
value|(utf ? PRIV(strcmp_uc_c8_utf)((str1), (str2)) : PRIV(strcmp_uc_c8)((str1), (str2)))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPILE_PCRE[8|16|32] */
end_comment
begin_function_decl
specifier|extern
specifier|const
name|pcre_uchar
modifier|*
name|PRIV
function_decl|(
name|find_bracket
function_decl|)
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
name|BOOL
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|BOOL
name|PRIV
function_decl|(
name|is_newline
function_decl|)
parameter_list|(
name|PCRE_PUCHAR
parameter_list|,
name|int
parameter_list|,
name|PCRE_PUCHAR
parameter_list|,
name|int
modifier|*
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|unsigned
name|int
name|PRIV
function_decl|(
name|ord2utf
function_decl|)
parameter_list|(
name|pcre_uint32
parameter_list|,
name|pcre_uchar
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|valid_utf
function_decl|)
parameter_list|(
name|PCRE_PUCHAR
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|BOOL
name|PRIV
function_decl|(
name|was_newline
function_decl|)
parameter_list|(
name|PCRE_PUCHAR
parameter_list|,
name|int
parameter_list|,
name|PCRE_PUCHAR
parameter_list|,
name|int
modifier|*
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|BOOL
name|PRIV
function_decl|(
name|xclass
function_decl|)
parameter_list|(
name|pcre_uint32
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_JIT
end_ifdef
begin_decl_stmt
specifier|extern
name|void
name|PRIV
argument_list|(
name|jit_compile
argument_list|)
argument_list|(
specifier|const
name|REAL_PCRE
operator|*
argument_list|,
name|PUBL
argument_list|(
name|extra
argument_list|)
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|int
name|PRIV
argument_list|(
name|jit_exec
argument_list|)
argument_list|(
specifier|const
name|PUBL
argument_list|(
name|extra
argument_list|)
operator|*
argument_list|,
specifier|const
name|pcre_uchar
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|extern
name|void
name|PRIV
function_decl|(
name|jit_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|PRIV
function_decl|(
name|jit_get_size
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|PRIV
function_decl|(
name|jit_get_target
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Unicode character database (UCD) */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|script
name|pcre_uint8
name|script
decl_stmt|;
comment|/* ucp_Arabic, etc. */
DECL|member|chartype
name|pcre_uint8
name|chartype
decl_stmt|;
comment|/* ucp_Cc, etc. (general categories) */
DECL|member|gbprop
name|pcre_uint8
name|gbprop
decl_stmt|;
comment|/* ucp_gbControl, etc. (grapheme break property) */
DECL|member|caseset
name|pcre_uint8
name|caseset
decl_stmt|;
comment|/* offset to multichar other cases or zero */
DECL|member|other_case
name|pcre_int32
name|other_case
decl_stmt|;
comment|/* offset to other case, or zero if none */
block|}
DECL|typedef|ucd_record
name|ucd_record
typedef|;
end_typedef
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint32
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|ucd_record
name|PRIV
argument_list|(
name|ucd_records
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint8
name|PRIV
argument_list|(
name|ucd_stage1
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint16
name|PRIV
argument_list|(
name|ucd_stage2
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint32
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
specifier|const
name|pcre_uint32
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_JIT
end_ifdef
begin_decl_stmt
specifier|extern
specifier|const
name|int
name|PRIV
argument_list|(
name|ucp_typerange
argument_list|)
decl|[]
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_UCP
end_ifdef
begin_comment
comment|/* UCD access macros */
end_comment
begin_define
DECL|macro|UCD_BLOCK_SIZE
define|#
directive|define
name|UCD_BLOCK_SIZE
value|128
end_define
begin_define
DECL|macro|GET_UCD
define|#
directive|define
name|GET_UCD
parameter_list|(
name|ch
parameter_list|)
value|(PRIV(ucd_records) + \         PRIV(ucd_stage2)[PRIV(ucd_stage1)[(int)(ch) / UCD_BLOCK_SIZE] * \         UCD_BLOCK_SIZE + (int)(ch) % UCD_BLOCK_SIZE])
end_define
begin_define
DECL|macro|UCD_CHARTYPE
define|#
directive|define
name|UCD_CHARTYPE
parameter_list|(
name|ch
parameter_list|)
value|GET_UCD(ch)->chartype
end_define
begin_define
DECL|macro|UCD_SCRIPT
define|#
directive|define
name|UCD_SCRIPT
parameter_list|(
name|ch
parameter_list|)
value|GET_UCD(ch)->script
end_define
begin_define
DECL|macro|UCD_CATEGORY
define|#
directive|define
name|UCD_CATEGORY
parameter_list|(
name|ch
parameter_list|)
value|PRIV(ucp_gentype)[UCD_CHARTYPE(ch)]
end_define
begin_define
DECL|macro|UCD_GRAPHBREAK
define|#
directive|define
name|UCD_GRAPHBREAK
parameter_list|(
name|ch
parameter_list|)
value|GET_UCD(ch)->gbprop
end_define
begin_define
DECL|macro|UCD_CASESET
define|#
directive|define
name|UCD_CASESET
parameter_list|(
name|ch
parameter_list|)
value|GET_UCD(ch)->caseset
end_define
begin_define
DECL|macro|UCD_OTHERCASE
define|#
directive|define
name|UCD_OTHERCASE
parameter_list|(
name|ch
parameter_list|)
value|((pcre_uint32)((int)ch + (int)(GET_UCD(ch)->other_case)))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SUPPORT_UCP */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* End of pcre_internal.h */
end_comment
end_unit
