begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language (but see below for why this module is different).                         Written by Philip Hazel            Copyright (c) 1997-2014 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains the external function pcre_dfa_exec(), which is an alternative matching function that uses a sort of DFA algorithm (not a true FSM). This is NOT Perl-compatible, but it has advantages in certain applications. */
end_comment
begin_comment
comment|/* NOTE ABOUT PERFORMANCE: A user of this function sent some code that improved the performance of his patterns greatly. I could not use it as it stood, as it was not thread safe, and made assumptions about pattern sizes. Also, it caused test 7 to loop, and test 9 to crash with a segfault.  The issue is the check for duplicate states, which is done by a simple linear search up the state list. (Grep for "duplicate" below to find the code.) For many patterns, there will never be many states active at one time, so a simple linear search is fine. In patterns that have many active states, it might be a bottleneck. The suggested code used an indexing scheme to remember which states had previously been used for each character, and avoided the linear search when it knew there was no chance of a duplicate. This was implemented when adding states to the state lists.  I wrote some thread-safe, not-limited code to try something similar at the time of checking for duplicates (instead of when adding states), using index vectors on the stack. It did give a 13% improvement with one specially constructed pattern for certain subject strings, but on other strings and on many of the simpler patterns in the test suite it did worse. The major problem, I think, was the extra time to initialize the index. This had to be done for each call of internal_dfa_exec(). (The supplied patch used a static vector, initialized only once - I suspect this was the cause of the problems with the tests.)  Overall, I concluded that the gains in some cases did not outweigh the losses in others, so I abandoned this code. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|NLBLOCK
define|#
directive|define
name|NLBLOCK
value|md
end_define
begin_comment
DECL|macro|NLBLOCK
comment|/* Block containing newline information */
end_comment
begin_define
DECL|macro|PSSTART
define|#
directive|define
name|PSSTART
value|start_subject
end_define
begin_comment
DECL|macro|PSSTART
comment|/* Field containing processed string start */
end_comment
begin_define
DECL|macro|PSEND
define|#
directive|define
name|PSEND
value|end_subject
end_define
begin_comment
DECL|macro|PSEND
comment|/* Field containing processed string end */
end_comment
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_comment
comment|/* For use to indent debugging output */
end_comment
begin_define
DECL|macro|SP
define|#
directive|define
name|SP
value|"                   "
end_define
begin_comment
comment|/************************************************* *      Code parameters and static tables         * *************************************************/
end_comment
begin_comment
comment|/* These are offsets that are used to turn the OP_TYPESTAR and friends opcodes into others, under special conditions. A gap of 20 between the blocks should be enough. The resulting opcodes don't have to be less than 256 because they are never stored, so we push them well clear of the normal opcodes. */
end_comment
begin_define
DECL|macro|OP_PROP_EXTRA
define|#
directive|define
name|OP_PROP_EXTRA
value|300
end_define
begin_define
DECL|macro|OP_EXTUNI_EXTRA
define|#
directive|define
name|OP_EXTUNI_EXTRA
value|320
end_define
begin_define
DECL|macro|OP_ANYNL_EXTRA
define|#
directive|define
name|OP_ANYNL_EXTRA
value|340
end_define
begin_define
DECL|macro|OP_HSPACE_EXTRA
define|#
directive|define
name|OP_HSPACE_EXTRA
value|360
end_define
begin_define
DECL|macro|OP_VSPACE_EXTRA
define|#
directive|define
name|OP_VSPACE_EXTRA
value|380
end_define
begin_comment
comment|/* This table identifies those opcodes that are followed immediately by a character that is to be tested in some way. This makes it possible to centralize the loading of these characters. In the case of Type * etc, the "character" is the opcode for \D, \d, \S, \s, \W, or \w, which will always be a small value. Non-zero values in the table are the offsets from the opcode where the character is to be found. ***NOTE*** If the start of this table is modified, the three tables that follow must also be modified. */
end_comment
begin_decl_stmt
DECL|variable|coptable
specifier|static
specifier|const
name|pcre_uint8
name|coptable
index|[]
init|=
block|{
literal|0
block|,
comment|/* End                                    */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* \A, \G, \K, \B, \b                     */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* \D, \d, \S, \s, \W, \w                 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Any, AllAny, Anybyte                   */
literal|0
block|,
literal|0
block|,
comment|/* \P, \p                                 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* \R, \H, \h, \V, \v                     */
literal|0
block|,
comment|/* \X                                     */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* \Z, \z, $, $M, ^, ^M                   */
literal|1
block|,
comment|/* Char                                   */
literal|1
block|,
comment|/* Chari                                  */
literal|1
block|,
comment|/* not                                    */
literal|1
block|,
comment|/* noti                                   */
comment|/* Positive single-char repeats                                          */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* *, *?, +, +?, ?, ??                    */
literal|1
operator|+
name|IMM2_SIZE
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* upto, minupto                          */
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* exact                                  */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* *+, ++, ?+, upto+                      */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* *I, *?I, +I, +?I, ?I, ??I              */
literal|1
operator|+
name|IMM2_SIZE
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* upto I, minupto I                      */
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* exact I                                */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* *+I, ++I, ?+I, upto+I                  */
comment|/* Negative single-char repeats - only for chars< 256                   */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT *, *?, +, +?, ?, ??                */
literal|1
operator|+
name|IMM2_SIZE
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* NOT upto, minupto                      */
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* NOT exact                              */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* NOT *+, ++, ?+, upto+                  */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT *I, *?I, +I, +?I, ?I, ??I          */
literal|1
operator|+
name|IMM2_SIZE
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* NOT upto I, minupto I                  */
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* NOT exact I                            */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* NOT *+I, ++I, ?+I, upto+I              */
comment|/* Positive type repeats                                                 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* Type *, *?, +, +?, ?, ??               */
literal|1
operator|+
name|IMM2_SIZE
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* Type upto, minupto                     */
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* Type exact                             */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
operator|+
name|IMM2_SIZE
block|,
comment|/* Type *+, ++, ?+, upto+                 */
comment|/* Character class& ref repeats                                         */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* *, *?, +, +?, ?, ??                    */
literal|0
block|,
literal|0
block|,
comment|/* CRRANGE, CRMINRANGE                    */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Possessive *+, ++, ?+, CRPOSRANGE      */
literal|0
block|,
comment|/* CLASS                                  */
literal|0
block|,
comment|/* NCLASS                                 */
literal|0
block|,
comment|/* XCLASS - variable length               */
literal|0
block|,
comment|/* REF                                    */
literal|0
block|,
comment|/* REFI                                   */
literal|0
block|,
comment|/* DNREF                                  */
literal|0
block|,
comment|/* DNREFI                                 */
literal|0
block|,
comment|/* RECURSE                                */
literal|0
block|,
comment|/* CALLOUT                                */
literal|0
block|,
comment|/* Alt                                    */
literal|0
block|,
comment|/* Ket                                    */
literal|0
block|,
comment|/* KetRmax                                */
literal|0
block|,
comment|/* KetRmin                                */
literal|0
block|,
comment|/* KetRpos                                */
literal|0
block|,
comment|/* Reverse                                */
literal|0
block|,
comment|/* Assert                                 */
literal|0
block|,
comment|/* Assert not                             */
literal|0
block|,
comment|/* Assert behind                          */
literal|0
block|,
comment|/* Assert behind not                      */
literal|0
block|,
literal|0
block|,
comment|/* ONCE, ONCE_NC                          */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* BRA, BRAPOS, CBRA, CBRAPOS, COND       */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */
literal|0
block|,
literal|0
block|,
comment|/* CREF, DNCREF                           */
literal|0
block|,
literal|0
block|,
comment|/* RREF, DNRREF                           */
literal|0
block|,
comment|/* DEF                                    */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* BRAZERO, BRAMINZERO, BRAPOSZERO        */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* MARK, PRUNE, PRUNE_ARG                 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* SKIP, SKIP_ARG, THEN, THEN_ARG         */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* COMMIT, FAIL, ACCEPT, ASSERT_ACCEPT    */
literal|0
block|,
literal|0
comment|/* CLOSE, SKIPZERO  */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* This table identifies those opcodes that inspect a character. It is used to remember the fact that a character could have been inspected when the end of the subject is reached. ***NOTE*** If the start of this table is modified, the two tables that follow must also be modified. */
end_comment
begin_decl_stmt
DECL|variable|poptable
specifier|static
specifier|const
name|pcre_uint8
name|poptable
index|[]
init|=
block|{
literal|0
block|,
comment|/* End                                    */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
comment|/* \A, \G, \K, \B, \b                     */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* \D, \d, \S, \s, \W, \w                 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* Any, AllAny, Anybyte                   */
literal|1
block|,
literal|1
block|,
comment|/* \P, \p                                 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* \R, \H, \h, \V, \v                     */
literal|1
block|,
comment|/* \X                                     */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* \Z, \z, $, $M, ^, ^M                   */
literal|1
block|,
comment|/* Char                                   */
literal|1
block|,
comment|/* Chari                                  */
literal|1
block|,
comment|/* not                                    */
literal|1
block|,
comment|/* noti                                   */
comment|/* Positive single-char repeats                                          */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* *, *?, +, +?, ?, ??                    */
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* upto, minupto, exact                   */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* *+, ++, ?+, upto+                      */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* *I, *?I, +I, +?I, ?I, ??I              */
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* upto I, minupto I, exact I             */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* *+I, ++I, ?+I, upto+I                  */
comment|/* Negative single-char repeats - only for chars< 256                   */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT *, *?, +, +?, ?, ??                */
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT upto, minupto, exact               */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT *+, ++, ?+, upto+                  */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT *I, *?I, +I, +?I, ?I, ??I          */
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT upto I, minupto I, exact I         */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* NOT *+I, ++I, ?+I, upto+I              */
comment|/* Positive type repeats                                                 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* Type *, *?, +, +?, ?, ??               */
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* Type upto, minupto, exact              */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* Type *+, ++, ?+, upto+                 */
comment|/* Character class& ref repeats                                         */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* *, *?, +, +?, ?, ??                    */
literal|1
block|,
literal|1
block|,
comment|/* CRRANGE, CRMINRANGE                    */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* Possessive *+, ++, ?+, CRPOSRANGE      */
literal|1
block|,
comment|/* CLASS                                  */
literal|1
block|,
comment|/* NCLASS                                 */
literal|1
block|,
comment|/* XCLASS - variable length               */
literal|0
block|,
comment|/* REF                                    */
literal|0
block|,
comment|/* REFI                                   */
literal|0
block|,
comment|/* DNREF                                  */
literal|0
block|,
comment|/* DNREFI                                 */
literal|0
block|,
comment|/* RECURSE                                */
literal|0
block|,
comment|/* CALLOUT                                */
literal|0
block|,
comment|/* Alt                                    */
literal|0
block|,
comment|/* Ket                                    */
literal|0
block|,
comment|/* KetRmax                                */
literal|0
block|,
comment|/* KetRmin                                */
literal|0
block|,
comment|/* KetRpos                                */
literal|0
block|,
comment|/* Reverse                                */
literal|0
block|,
comment|/* Assert                                 */
literal|0
block|,
comment|/* Assert not                             */
literal|0
block|,
comment|/* Assert behind                          */
literal|0
block|,
comment|/* Assert behind not                      */
literal|0
block|,
literal|0
block|,
comment|/* ONCE, ONCE_NC                          */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* BRA, BRAPOS, CBRA, CBRAPOS, COND       */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */
literal|0
block|,
literal|0
block|,
comment|/* CREF, DNCREF                           */
literal|0
block|,
literal|0
block|,
comment|/* RREF, DNRREF                           */
literal|0
block|,
comment|/* DEF                                    */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* BRAZERO, BRAMINZERO, BRAPOSZERO        */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* MARK, PRUNE, PRUNE_ARG                 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* SKIP, SKIP_ARG, THEN, THEN_ARG         */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* COMMIT, FAIL, ACCEPT, ASSERT_ACCEPT    */
literal|0
block|,
literal|0
comment|/* CLOSE, SKIPZERO                        */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* These 2 tables allow for compact code for testing for \D, \d, \S, \s, \W, and \w */
end_comment
begin_decl_stmt
DECL|variable|toptable1
specifier|static
specifier|const
name|pcre_uint8
name|toptable1
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ctype_digit
block|,
name|ctype_digit
block|,
name|ctype_space
block|,
name|ctype_space
block|,
name|ctype_word
block|,
name|ctype_word
block|,
literal|0
block|,
literal|0
comment|/* OP_ANY, OP_ALLANY */
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|toptable2
specifier|static
specifier|const
name|pcre_uint8
name|toptable2
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ctype_digit
block|,
literal|0
block|,
name|ctype_space
block|,
literal|0
block|,
name|ctype_word
block|,
literal|0
block|,
literal|1
block|,
literal|1
comment|/* OP_ANY, OP_ALLANY */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Structure for holding data about a particular state, which is in effect the current data for an active path through the match tree. It must consist entirely of ints because the working vector we are passed, and which we put these structures in, is a vector of ints. */
end_comment
begin_typedef
DECL|struct|stateblock
typedef|typedef
struct|struct
name|stateblock
block|{
DECL|member|offset
name|int
name|offset
decl_stmt|;
comment|/* Offset to opcode */
DECL|member|count
name|int
name|count
decl_stmt|;
comment|/* Count for repeats */
DECL|member|data
name|int
name|data
decl_stmt|;
comment|/* Some use extra data */
block|}
DECL|typedef|stateblock
name|stateblock
typedef|;
end_typedef
begin_define
DECL|macro|INTS_PER_STATEBLOCK
define|#
directive|define
name|INTS_PER_STATEBLOCK
value|(int)(sizeof(stateblock)/sizeof(int))
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_DEBUG
end_ifdef
begin_comment
comment|/************************************************* *             Print character string             * *************************************************/
end_comment
begin_comment
comment|/* Character string printing function for debugging.  Arguments:   p            points to string   length       number of bytes   f            where to print  Returns:       nothing */
end_comment
begin_function
specifier|static
name|void
DECL|function|pchars
name|pchars
parameter_list|(
specifier|const
name|pcre_uchar
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|pcre_uint32
name|c
decl_stmt|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\\x{%02x}"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/************************************************* *    Execute a Regular Expression - DFA engine   * *************************************************/
end_comment
begin_comment
comment|/* This internal function applies a compiled pattern to a subject string, starting at a given point, using a DFA engine. This function is called from the external one, possibly multiple times if the pattern is not anchored. The function calls itself recursively for some kinds of subpattern.  Arguments:   md                the match_data block with fixed information   this_start_code   the opening bracket of this subexpression's code   current_subject   where we currently are in the subject string   start_offset      start offset in the subject string   offsets           vector to contain the matching string offsets   offsetcount       size of same   workspace         vector of workspace   wscount           size of same   rlevel            function call recursion level  Returns:> 0 => number of match offset pairs placed in offsets                     = 0 => offsets overflowed; longest matches are present                      -1 => failed to match< -1 => some kind of unexpected problem  The following macros are used for adding states to the two state vectors (one for the current character, one for the following character). */
end_comment
begin_define
DECL|macro|ADD_ACTIVE
define|#
directive|define
name|ADD_ACTIVE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (active_count++< wscount) \     { \     next_active_state->offset = (x); \     next_active_state->count  = (y); \     next_active_state++; \     DPRINTF(("%.*sADD_ACTIVE(%d,%d)\n", rlevel*2-2, SP, (x), (y))); \     } \   else return PCRE_ERROR_DFA_WSSIZE
end_define
begin_define
DECL|macro|ADD_ACTIVE_DATA
define|#
directive|define
name|ADD_ACTIVE_DATA
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
define|\
value|if (active_count++< wscount) \     { \     next_active_state->offset = (x); \     next_active_state->count  = (y); \     next_active_state->data   = (z); \     next_active_state++; \     DPRINTF(("%.*sADD_ACTIVE_DATA(%d,%d,%d)\n", rlevel*2-2, SP, (x), (y), (z))); \     } \   else return PCRE_ERROR_DFA_WSSIZE
end_define
begin_define
DECL|macro|ADD_NEW
define|#
directive|define
name|ADD_NEW
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (new_count++< wscount) \     { \     next_new_state->offset = (x); \     next_new_state->count  = (y); \     next_new_state++; \     DPRINTF(("%.*sADD_NEW(%d,%d)\n", rlevel*2-2, SP, (x), (y))); \     } \   else return PCRE_ERROR_DFA_WSSIZE
end_define
begin_define
DECL|macro|ADD_NEW_DATA
define|#
directive|define
name|ADD_NEW_DATA
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
define|\
value|if (new_count++< wscount) \     { \     next_new_state->offset = (x); \     next_new_state->count  = (y); \     next_new_state->data   = (z); \     next_new_state++; \     DPRINTF(("%.*sADD_NEW_DATA(%d,%d,%d) line %d\n", rlevel*2-2, SP, \       (x), (y), (z), __LINE__)); \     } \   else return PCRE_ERROR_DFA_WSSIZE
end_define
begin_comment
comment|/* And now, here is the code */
end_comment
begin_function
specifier|static
name|int
DECL|function|internal_dfa_exec
name|internal_dfa_exec
parameter_list|(
name|dfa_match_data
modifier|*
name|md
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|this_start_code
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|current_subject
parameter_list|,
name|int
name|start_offset
parameter_list|,
name|int
modifier|*
name|offsets
parameter_list|,
name|int
name|offsetcount
parameter_list|,
name|int
modifier|*
name|workspace
parameter_list|,
name|int
name|wscount
parameter_list|,
name|int
name|rlevel
parameter_list|)
block|{
name|stateblock
modifier|*
name|active_states
decl_stmt|,
modifier|*
name|new_states
decl_stmt|,
modifier|*
name|temp_states
decl_stmt|;
name|stateblock
modifier|*
name|next_active_state
decl_stmt|,
modifier|*
name|next_new_state
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|ctypes
decl_stmt|,
modifier|*
name|lcc
decl_stmt|,
modifier|*
name|fcc
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|end_code
decl_stmt|,
modifier|*
name|first_op
decl_stmt|;
name|dfa_recursion_info
name|new_recursive
decl_stmt|;
name|int
name|active_count
decl_stmt|,
name|new_count
decl_stmt|,
name|match_count
decl_stmt|;
comment|/* Some fields in the md block are frequently referenced, so we load them into independent variables in the hope that this will perform better. */
specifier|const
name|pcre_uchar
modifier|*
name|start_subject
init|=
name|md
operator|->
name|start_subject
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|end_subject
init|=
name|md
operator|->
name|end_subject
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|start_code
init|=
name|md
operator|->
name|start_code
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|BOOL
name|utf
init|=
operator|(
name|md
operator|->
name|poptions
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
decl_stmt|;
else|#
directive|else
name|BOOL
name|utf
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|BOOL
name|reset_could_continue
init|=
name|FALSE
decl_stmt|;
name|rlevel
operator|++
expr_stmt|;
name|offsetcount
operator|&=
operator|(
operator|-
literal|2
operator|)
expr_stmt|;
name|wscount
operator|-=
literal|2
expr_stmt|;
name|wscount
operator|=
operator|(
name|wscount
operator|-
operator|(
name|wscount
operator|%
operator|(
name|INTS_PER_STATEBLOCK
operator|*
literal|2
operator|)
operator|)
operator|)
operator|/
operator|(
literal|2
operator|*
name|INTS_PER_STATEBLOCK
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"\n%.*s---------------------\n"
literal|"%.*sCall to internal_dfa_exec f=%d\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|,
name|rlevel
operator|)
argument_list|)
expr_stmt|;
name|ctypes
operator|=
name|md
operator|->
name|tables
operator|+
name|ctypes_offset
expr_stmt|;
name|lcc
operator|=
name|md
operator|->
name|tables
operator|+
name|lcc_offset
expr_stmt|;
name|fcc
operator|=
name|md
operator|->
name|tables
operator|+
name|fcc_offset
expr_stmt|;
name|match_count
operator|=
name|PCRE_ERROR_NOMATCH
expr_stmt|;
comment|/* A negative number */
name|active_states
operator|=
operator|(
name|stateblock
operator|*
operator|)
operator|(
name|workspace
operator|+
literal|2
operator|)
expr_stmt|;
name|next_new_state
operator|=
name|new_states
operator|=
name|active_states
operator|+
name|wscount
expr_stmt|;
name|new_count
operator|=
literal|0
expr_stmt|;
name|first_op
operator|=
name|this_start_code
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
operator|(
operator|(
operator|*
name|this_start_code
operator|==
name|OP_CBRA
operator|||
operator|*
name|this_start_code
operator|==
name|OP_SCBRA
operator|||
operator|*
name|this_start_code
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|this_start_code
operator|==
name|OP_SCBRAPOS
operator|)
condition|?
name|IMM2_SIZE
else|:
literal|0
operator|)
expr_stmt|;
comment|/* The first thing in any (sub) pattern is a bracket of some sort. Push all the alternative states onto the list, and find out where the end is. This makes is possible to use this function recursively, when we want to stop at a matching internal ket rather than at the end.  If the first opcode in the first alternative is OP_REVERSE, we are dealing with a backward assertion. In that case, we have to find out the maximum amount to move back, and set up each alternative appropriately. */
if|if
condition|(
operator|*
name|first_op
operator|==
name|OP_REVERSE
condition|)
block|{
name|int
name|max_back
init|=
literal|0
decl_stmt|;
name|int
name|gone_back
decl_stmt|;
name|end_code
operator|=
name|this_start_code
expr_stmt|;
do|do
block|{
name|int
name|back
init|=
name|GET
argument_list|(
name|end_code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|back
operator|>
name|max_back
condition|)
name|max_back
operator|=
name|back
expr_stmt|;
name|end_code
operator|+=
name|GET
argument_list|(
name|end_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end_code
operator|==
name|OP_ALT
condition|)
do|;
comment|/* If we can't go back the amount required for the longest lookbehind   pattern, go back as far as we can; some alternatives may still be viable. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
comment|/* In character mode we have to step back character by character */
if|if
condition|(
name|utf
condition|)
block|{
for|for
control|(
name|gone_back
operator|=
literal|0
init|;
name|gone_back
operator|<
name|max_back
condition|;
name|gone_back
operator|++
control|)
block|{
if|if
condition|(
name|current_subject
operator|<=
name|start_subject
condition|)
break|break;
name|current_subject
operator|--
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|current_subject
operator|>
name|start_subject
argument_list|,
operator|*
name|current_subject
argument_list|,
name|current_subject
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* In byte-mode we can do this quickly. */
block|{
name|gone_back
operator|=
operator|(
name|current_subject
operator|-
name|max_back
operator|<
name|start_subject
operator|)
condition|?
call|(
name|int
call|)
argument_list|(
name|current_subject
operator|-
name|start_subject
argument_list|)
else|:
name|max_back
expr_stmt|;
name|current_subject
operator|-=
name|gone_back
expr_stmt|;
block|}
comment|/* Save the earliest consulted character */
if|if
condition|(
name|current_subject
operator|<
name|md
operator|->
name|start_used_ptr
condition|)
name|md
operator|->
name|start_used_ptr
operator|=
name|current_subject
expr_stmt|;
comment|/* Now we can process the individual branches. */
name|end_code
operator|=
name|this_start_code
expr_stmt|;
do|do
block|{
name|int
name|back
init|=
name|GET
argument_list|(
name|end_code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|back
operator|<=
name|gone_back
condition|)
block|{
name|int
name|bstate
init|=
call|(
name|int
call|)
argument_list|(
name|end_code
operator|-
name|start_code
operator|+
literal|2
operator|+
literal|2
operator|*
name|LINK_SIZE
argument_list|)
decl_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
name|bstate
argument_list|,
literal|0
argument_list|,
name|gone_back
operator|-
name|back
argument_list|)
expr_stmt|;
block|}
name|end_code
operator|+=
name|GET
argument_list|(
name|end_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end_code
operator|==
name|OP_ALT
condition|)
do|;
block|}
comment|/* This is the code for a "normal" subpattern (not a backward assertion). The start of a whole pattern is always one of these. If we are at the top level, we may be asked to restart matching from the same point that we reached for a previous partial match. We still have to scan through the top-level branches to find the end state. */
else|else
block|{
name|end_code
operator|=
name|this_start_code
expr_stmt|;
comment|/* Restarting */
if|if
condition|(
name|rlevel
operator|==
literal|1
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_DFA_RESTART
operator|)
operator|!=
literal|0
condition|)
block|{
do|do
block|{
name|end_code
operator|+=
name|GET
argument_list|(
name|end_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end_code
operator|==
name|OP_ALT
condition|)
do|;
name|new_count
operator|=
name|workspace
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|workspace
index|[
literal|0
index|]
condition|)
name|memcpy
argument_list|(
name|new_states
argument_list|,
name|active_states
argument_list|,
name|new_count
operator|*
sizeof|sizeof
argument_list|(
name|stateblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Not restarting */
else|else
block|{
name|int
name|length
init|=
literal|1
operator|+
name|LINK_SIZE
operator|+
operator|(
operator|(
operator|*
name|this_start_code
operator|==
name|OP_CBRA
operator|||
operator|*
name|this_start_code
operator|==
name|OP_SCBRA
operator|||
operator|*
name|this_start_code
operator|==
name|OP_CBRAPOS
operator|||
operator|*
name|this_start_code
operator|==
name|OP_SCBRAPOS
operator|)
condition|?
name|IMM2_SIZE
else|:
literal|0
operator|)
decl_stmt|;
do|do
block|{
name|ADD_NEW
argument_list|(
call|(
name|int
call|)
argument_list|(
name|end_code
operator|-
name|start_code
operator|+
name|length
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_code
operator|+=
name|GET
argument_list|(
name|end_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|length
operator|=
literal|1
operator|+
name|LINK_SIZE
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end_code
operator|==
name|OP_ALT
condition|)
do|;
block|}
block|}
name|workspace
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Bit indicating which vector is current */
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sEnd state = %d\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|,
call|(
name|int
call|)
argument_list|(
name|end_code
operator|-
name|start_code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Loop for scanning the subject */
name|ptr
operator|=
name|current_subject
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|clen
decl_stmt|,
name|dlen
decl_stmt|;
name|pcre_uint32
name|c
decl_stmt|,
name|d
decl_stmt|;
name|int
name|forced_fail
init|=
literal|0
decl_stmt|;
name|BOOL
name|partial_newline
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|could_continue
init|=
name|reset_could_continue
decl_stmt|;
name|reset_could_continue
operator|=
name|FALSE
expr_stmt|;
comment|/* Make the new state list into the active state list and empty the   new state list. */
name|temp_states
operator|=
name|active_states
expr_stmt|;
name|active_states
operator|=
name|new_states
expr_stmt|;
name|new_states
operator|=
name|temp_states
expr_stmt|;
name|active_count
operator|=
name|new_count
expr_stmt|;
name|new_count
operator|=
literal|0
expr_stmt|;
name|workspace
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
comment|/* Remember for the restarting feature */
name|workspace
index|[
literal|1
index|]
operator|=
name|active_count
expr_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|printf
argument_list|(
literal|"%.*sNext character: rest of subject = \""
argument_list|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|pchars
argument_list|(
name|ptr
argument_list|,
name|STRLEN_UC
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%.*sActive states: "
argument_list|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
argument_list|,
name|SP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_count
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d/%d "
argument_list|,
name|active_states
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|active_states
index|[
name|i
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the pointers for adding new states */
name|next_active_state
operator|=
name|active_states
operator|+
name|active_count
expr_stmt|;
name|next_new_state
operator|=
name|new_states
expr_stmt|;
comment|/* Load the current character from the subject outside the loop, as many   different states may want to look at it, and we assume that at least one   will. */
if|if
condition|(
name|ptr
operator|<
name|end_subject
condition|)
block|{
name|clen
operator|=
literal|1
expr_stmt|;
comment|/* Number of data items in the character */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
name|GETCHARLENTEST
argument_list|(
name|c
argument_list|,
name|ptr
argument_list|,
name|clen
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UTF */
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
comment|/* This indicates the end of the subject */
name|c
operator|=
name|NOTACHAR
expr_stmt|;
comment|/* This value should never actually be used */
block|}
comment|/* Scan up the active states and act on each one. The result of an action   may be to add more states to the currently active list (e.g. on hitting a   parenthesis) or it may be to put states on the new list, for considering   when we move the character pointer on. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_count
condition|;
name|i
operator|++
control|)
block|{
name|stateblock
modifier|*
name|current_state
init|=
name|active_states
operator|+
name|i
decl_stmt|;
name|BOOL
name|caseless
init|=
name|FALSE
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|code
decl_stmt|;
name|int
name|state_offset
init|=
name|current_state
operator|->
name|offset
decl_stmt|;
name|int
name|codevalue
decl_stmt|,
name|rrc
decl_stmt|;
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|PCRE_DEBUG
name|printf
argument_list|(
literal|"%.*sProcessing state %d c="
argument_list|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
argument_list|,
name|SP
argument_list|,
name|state_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"EOL\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>
literal|32
operator|&&
name|c
operator|<
literal|127
condition|)
name|printf
argument_list|(
literal|"'%c'\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%02x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A negative offset is a special case meaning "hold off going to this     (negated) state until the number of characters in the data field have     been skipped". If the could_continue flag was passed over from a previous     state, arrange for it to passed on. */
if|if
condition|(
name|state_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|current_state
operator|->
name|data
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sSkipping this character\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|)
argument_list|)
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
name|state_offset
argument_list|,
name|current_state
operator|->
name|count
argument_list|,
name|current_state
operator|->
name|data
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|could_continue
condition|)
name|reset_could_continue
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|current_state
operator|->
name|offset
operator|=
name|state_offset
operator|=
operator|-
name|state_offset
expr_stmt|;
block|}
block|}
comment|/* Check for a duplicate state with the same count, and skip if found.     See the note at the head of this module about the possibility of improving     performance here. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|active_states
index|[
name|j
index|]
operator|.
name|offset
operator|==
name|state_offset
operator|&&
name|active_states
index|[
name|j
index|]
operator|.
name|count
operator|==
name|current_state
operator|->
name|count
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sDuplicate state: skipped\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|NEXT_ACTIVE_STATE
goto|;
block|}
block|}
comment|/* The state offset is the offset to the opcode */
name|code
operator|=
name|start_code
operator|+
name|state_offset
expr_stmt|;
name|codevalue
operator|=
operator|*
name|code
expr_stmt|;
comment|/* If this opcode inspects a character, but we are at the end of the     subject, remember the fact for use when testing for a partial match. */
if|if
condition|(
name|clen
operator|==
literal|0
operator|&&
name|poptable
index|[
name|codevalue
index|]
operator|!=
literal|0
condition|)
name|could_continue
operator|=
name|TRUE
expr_stmt|;
comment|/* If this opcode is followed by an inline character, load it. It is     tempting to test for the presence of a subject character here, but that     is wrong, because sometimes zero repetitions of the subject are     permitted.      We also use this mechanism for opcodes such as OP_TYPEPLUS that take an     argument that is not a data character - but is always one byte long because     the values are small. We have to take special action to deal with  \P, \p,     \H, \h, \V, \v and \X in this case. To keep the other cases fast, convert     these ones to new opcodes. */
if|if
condition|(
name|coptable
index|[
name|codevalue
index|]
operator|>
literal|0
condition|)
block|{
name|dlen
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
operator|(
name|code
operator|+
name|coptable
index|[
name|codevalue
index|]
operator|)
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|d
operator|=
name|code
index|[
name|coptable
index|[
name|codevalue
index|]
index|]
expr_stmt|;
if|if
condition|(
name|codevalue
operator|>=
name|OP_TYPESTAR
condition|)
block|{
switch|switch
condition|(
name|d
condition|)
block|{
case|case
name|OP_ANYBYTE
case|:
return|return
name|PCRE_ERROR_DFA_UITEM
return|;
case|case
name|OP_NOTPROP
case|:
case|case
name|OP_PROP
case|:
name|codevalue
operator|+=
name|OP_PROP_EXTRA
expr_stmt|;
break|break;
case|case
name|OP_ANYNL
case|:
name|codevalue
operator|+=
name|OP_ANYNL_EXTRA
expr_stmt|;
break|break;
case|case
name|OP_EXTUNI
case|:
name|codevalue
operator|+=
name|OP_EXTUNI_EXTRA
expr_stmt|;
break|break;
case|case
name|OP_NOT_HSPACE
case|:
case|case
name|OP_HSPACE
case|:
name|codevalue
operator|+=
name|OP_HSPACE_EXTRA
expr_stmt|;
break|break;
case|case
name|OP_NOT_VSPACE
case|:
case|case
name|OP_VSPACE
case|:
name|codevalue
operator|+=
name|OP_VSPACE_EXTRA
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
name|dlen
operator|=
literal|0
expr_stmt|;
comment|/* Not strictly necessary, but compilers moan */
name|d
operator|=
name|NOTACHAR
expr_stmt|;
comment|/* if these variables are not set. */
block|}
comment|/* Now process the individual opcodes */
switch|switch
condition|(
name|codevalue
condition|)
block|{
comment|/* ========================================================================== */
comment|/* These cases are never obeyed. This is a fudge that causes a compile-       time error if the vectors coptable or poptable, which are indexed by       opcode, are not the correct length. It seems to be the only way to do       such a check at compile time, as the sizeof() operator does not work       in the C preprocessor. */
case|case
name|OP_TABLE_LENGTH
case|:
case|case
name|OP_TABLE_LENGTH
operator|+
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|coptable
argument_list|)
operator|==
name|OP_TABLE_LENGTH
operator|)
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|poptable
argument_list|)
operator|==
name|OP_TABLE_LENGTH
operator|)
operator|)
case|:
break|break;
comment|/* ========================================================================== */
comment|/* Reached a closing bracket. If not at the end of the pattern, carry       on with the next opcode. For repeating opcodes, also add the repeat       state. Note that KETRPOS will always be encountered at the end of the       subpattern, because the possessive subpattern repeats are always handled       using recursive calls. Thus, it never adds any new states.        At the end of the (sub)pattern, unless we have an empty string and       PCRE_NOTEMPTY is set, or PCRE_NOTEMPTY_ATSTART is set and we are at the       start of the subject, save the match data, shifting up all previous       matches so we always have the longest first. */
case|case
name|OP_KET
case|:
case|case
name|OP_KETRMIN
case|:
case|case
name|OP_KETRMAX
case|:
case|case
name|OP_KETRPOS
case|:
if|if
condition|(
name|code
operator|!=
name|end_code
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|codevalue
operator|!=
name|OP_KET
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|-
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ptr
operator|>
name|current_subject
operator|||
operator|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_NOTEMPTY
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_NOTEMPTY_ATSTART
operator|)
operator|==
literal|0
operator|||
name|current_subject
operator|>
name|start_subject
operator|+
name|md
operator|->
name|start_offset
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|match_count
operator|<
literal|0
condition|)
name|match_count
operator|=
operator|(
name|offsetcount
operator|>=
literal|2
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|match_count
operator|>
literal|0
operator|&&
operator|++
name|match_count
operator|*
literal|2
operator|>
name|offsetcount
condition|)
name|match_count
operator|=
literal|0
expr_stmt|;
name|count
operator|=
operator|(
operator|(
name|match_count
operator|==
literal|0
operator|)
condition|?
name|offsetcount
else|:
name|match_count
operator|*
literal|2
operator|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|offsets
operator|+
literal|2
argument_list|,
name|offsets
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetcount
operator|>=
literal|2
condition|)
block|{
name|offsets
index|[
literal|0
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|current_subject
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sSet matched string = \"%.*s\"\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|,
name|offsets
index|[
literal|1
index|]
operator|-
name|offsets
index|[
literal|0
index|]
operator|,
operator|(
name|char
operator|*
operator|)
name|current_subject
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_DFA_SHORTEST
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sEnd of internal_dfa_exec %d: returning %d\n"
literal|"%.*s---------------------\n\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|,
name|rlevel
operator|,
name|match_count
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|)
argument_list|)
expr_stmt|;
return|return
name|match_count
return|;
block|}
block|}
block|}
break|break;
comment|/* ========================================================================== */
comment|/* These opcodes add to the current list of states without looking       at the current character. */
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_ALT
case|:
do|do
block|{
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_code
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_BRA
case|:
case|case
name|OP_SBRA
case|:
do|do
block|{
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_code
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
do|;
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_CBRA
case|:
case|case
name|OP_SCBRA
case|:
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_code
operator|+
literal|1
operator|+
name|LINK_SIZE
operator|+
name|IMM2_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_code
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_BRAZERO
case|:
case|case
name|OP_BRAMINZERO
case|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|1
operator|+
name|GET
argument_list|(
name|code
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_code
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_SKIPZERO
case|:
name|code
operator|+=
literal|1
operator|+
name|GET
argument_list|(
name|code
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|code
operator|==
name|OP_ALT
condition|)
name|code
operator|+=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|code
operator|-
name|start_code
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_CIRC
case|:
if|if
condition|(
name|ptr
operator|==
name|start_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_NOTBOL
operator|)
operator|==
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_CIRCM
case|:
if|if
condition|(
operator|(
name|ptr
operator|==
name|start_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_NOTBOL
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ptr
operator|!=
name|end_subject
operator|&&
name|WAS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_EOD
case|:
if|if
condition|(
name|ptr
operator|>=
name|end_subject
condition|)
block|{
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|could_continue
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_SOD
case|:
if|if
condition|(
name|ptr
operator|==
name|start_subject
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_SOM
case|:
if|if
condition|(
name|ptr
operator|==
name|start_subject
operator|+
name|start_offset
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* ========================================================================== */
comment|/* These opcodes inspect the next subject character, and sometimes       the previous one as well, but do not have an argument. The variable       clen contains the length of the current character and is zero if we are       at the end of the subject. */
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_ANY
case|:
if|if
condition|(
name|clen
operator|>
literal|0
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_ALLANY
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_EODN
case|:
if|if
condition|(
name|clen
operator|==
literal|0
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|could_continue
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|clen
operator|==
literal|0
operator|||
operator|(
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|&&
name|ptr
operator|==
name|end_subject
operator|-
name|md
operator|->
name|nllen
operator|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_DOLL
case|:
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_NOTEOL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|clen
operator|==
literal|0
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|could_continue
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|clen
operator|==
literal|0
operator|||
operator|(
operator|(
name|md
operator|->
name|poptions
operator|&
name|PCRE_DOLLAR_ENDONLY
operator|)
operator|==
literal|0
operator|&&
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|&&
operator|(
name|ptr
operator|==
name|end_subject
operator|-
name|md
operator|->
name|nllen
operator|)
operator|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator||
name|PCRE_PARTIAL_SOFT
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|reset_could_continue
operator|=
name|TRUE
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_DOLLM
case|:
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_NOTEOL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|clen
operator|==
literal|0
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|could_continue
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|clen
operator|==
literal|0
operator|||
operator|(
operator|(
name|md
operator|->
name|poptions
operator|&
name|PCRE_DOLLAR_ENDONLY
operator|)
operator|==
literal|0
operator|&&
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator||
name|PCRE_PARTIAL_SOFT
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|reset_could_continue
operator|=
name|TRUE
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_DIGIT
case|:
case|case
name|OP_WHITESPACE
case|:
case|case
name|OP_WORDCHAR
case|:
if|if
condition|(
name|clen
operator|>
literal|0
operator|&&
name|c
operator|<
literal|256
operator|&&
operator|(
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|toptable1
index|[
name|codevalue
index|]
operator|)
operator|^
name|toptable2
index|[
name|codevalue
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_NOT_DIGIT
case|:
case|case
name|OP_NOT_WHITESPACE
case|:
case|case
name|OP_NOT_WORDCHAR
case|:
if|if
condition|(
name|clen
operator|>
literal|0
operator|&&
operator|(
name|c
operator|>=
literal|256
operator|||
operator|(
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|toptable1
index|[
name|codevalue
index|]
operator|)
operator|^
name|toptable2
index|[
name|codevalue
index|]
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_WORD_BOUNDARY
case|:
case|case
name|OP_NOT_WORD_BOUNDARY
case|:
block|{
name|int
name|left_word
decl_stmt|,
name|right_word
decl_stmt|;
if|if
condition|(
name|ptr
operator|>
name|start_subject
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|temp
init|=
name|ptr
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|temp
operator|<
name|md
operator|->
name|start_used_ptr
condition|)
name|md
operator|->
name|start_used_ptr
operator|=
name|temp
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
condition|)
block|{
name|BACKCHAR
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|GETCHARTEST
argument_list|(
name|d
argument_list|,
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
operator|(
name|md
operator|->
name|poptions
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|'_'
condition|)
name|left_word
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|int
name|cat
init|=
name|UCD_CATEGORY
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|left_word
operator|=
operator|(
name|cat
operator|==
name|ucp_L
operator|||
name|cat
operator|==
name|ucp_N
operator|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|left_word
operator|=
name|d
operator|<
literal|256
operator|&&
operator|(
name|ctypes
index|[
name|d
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
name|left_word
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
if|if
condition|(
operator|(
name|md
operator|->
name|poptions
operator|&
name|PCRE_UCP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|right_word
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|int
name|cat
init|=
name|UCD_CATEGORY
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|right_word
operator|=
operator|(
name|cat
operator|==
name|ucp_L
operator|||
name|cat
operator|==
name|ucp_N
operator|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|right_word
operator|=
name|c
operator|<
literal|256
operator|&&
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|ctype_word
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
name|right_word
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|left_word
operator|==
name|right_word
operator|)
operator|==
operator|(
name|codevalue
operator|==
name|OP_NOT_WORD_BOUNDARY
operator|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
comment|/* Check the next character by Unicode property. We will get here only       if the support is in the binary; otherwise a compile-time error occurs.       */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_PROP
case|:
case|case
name|OP_NOTPROP
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
index|[
literal|1
index|]
condition|)
block|{
case|case
name|PT_ANY
case|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_LAMP
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
expr_stmt|;
break|break;
case|case
name|PT_GC
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|code
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|PT_PC
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|code
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|OK
operator|=
name|prop
operator|->
name|script
operator|==
name|code
index|[
literal|2
index|]
expr_stmt|;
break|break;
comment|/* These are specials for combination cases. */
case|case
name|PT_ALNUM
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
expr_stmt|;
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,           which means that Perl space and POSIX space are now identical. PCRE           was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PT_WORD
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
expr_stmt|;
break|break;
case|case
name|PT_CLIST
case|:
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|code
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PT_UCNC
case|:
name|OK
operator|=
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
expr_stmt|;
break|break;
comment|/* Should never occur, but keep compilers from grumbling. */
default|default:
name|OK
operator|=
name|codevalue
operator|!=
name|OP_PROP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|codevalue
operator|==
name|OP_PROP
operator|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* ========================================================================== */
comment|/* These opcodes likewise inspect the subject character, but have an       argument that is not a data character. It is one of these opcodes:       OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,       OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d. */
case|case
name|OP_TYPEPLUS
case|:
case|case
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_TYPEPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|OP_ANY
operator|&&
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|256
operator|&&
name|d
operator|!=
name|OP_DIGIT
operator|&&
name|d
operator|!=
name|OP_WHITESPACE
operator|&&
name|d
operator|!=
name|OP_WORDCHAR
operator|)
operator|||
operator|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|d
operator|!=
name|OP_ANY
operator|||
operator|!
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|toptable1
index|[
name|d
index|]
operator|)
operator|^
name|toptable2
index|[
name|d
index|]
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|codevalue
operator|==
name|OP_TYPEPOSPLUS
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_TYPEQUERY
case|:
case|case
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_TYPEPOSQUERY
case|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|OP_ANY
operator|&&
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|256
operator|&&
name|d
operator|!=
name|OP_DIGIT
operator|&&
name|d
operator|!=
name|OP_WHITESPACE
operator|&&
name|d
operator|!=
name|OP_WORDCHAR
operator|)
operator|||
operator|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|d
operator|!=
name|OP_ANY
operator|||
operator|!
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|toptable1
index|[
name|d
index|]
operator|)
operator|^
name|toptable2
index|[
name|d
index|]
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_TYPEPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_TYPESTAR
case|:
case|case
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_TYPEPOSSTAR
case|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|OP_ANY
operator|&&
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|256
operator|&&
name|d
operator|!=
name|OP_DIGIT
operator|&&
name|d
operator|!=
name|OP_WHITESPACE
operator|&&
name|d
operator|!=
name|OP_WORDCHAR
operator|)
operator|||
operator|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|d
operator|!=
name|OP_ANY
operator|||
operator|!
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|toptable1
index|[
name|d
index|]
operator|)
operator|^
name|toptable2
index|[
name|d
index|]
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_TYPEPOSSTAR
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_TYPEEXACT
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|OP_ANY
operator|&&
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|256
operator|&&
name|d
operator|!=
name|OP_DIGIT
operator|&&
name|d
operator|!=
name|OP_WHITESPACE
operator|&&
name|d
operator|!=
name|OP_WORDCHAR
operator|)
operator|||
operator|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|d
operator|!=
name|OP_ANY
operator|||
operator|!
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|toptable1
index|[
name|d
index|]
operator|)
operator|^
name|toptable2
index|[
name|d
index|]
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_TYPEUPTO
case|:
case|case
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_TYPEPOSUPTO
case|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|OP_ANY
operator|&&
name|ptr
operator|+
literal|1
operator|>=
name|md
operator|->
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|NLBLOCK
operator|->
name|nltype
operator|==
name|NLTYPE_FIXED
operator|&&
name|NLBLOCK
operator|->
name|nllen
operator|==
literal|2
operator|&&
name|c
operator|==
name|NLBLOCK
operator|->
name|nl
index|[
literal|0
index|]
condition|)
block|{
name|could_continue
operator|=
name|partial_newline
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|>=
literal|256
operator|&&
name|d
operator|!=
name|OP_DIGIT
operator|&&
name|d
operator|!=
name|OP_WHITESPACE
operator|&&
name|d
operator|!=
name|OP_WORDCHAR
operator|)
operator|||
operator|(
name|c
operator|<
literal|256
operator|&&
operator|(
name|d
operator|!=
name|OP_ANY
operator|||
operator|!
name|IS_NEWLINE
argument_list|(
name|ptr
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|ctypes
index|[
name|c
index|]
operator|&
name|toptable1
index|[
name|d
index|]
operator|)
operator|^
name|toptable2
index|[
name|d
index|]
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_TYPEPOSUPTO
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/* ========================================================================== */
comment|/* These are virtual opcodes that are used when something like       OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its       argument. It keeps the code above fast for the other cases. The argument       is in the d variable. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPLUS
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
index|[
literal|2
index|]
condition|)
block|{
case|case
name|PT_ANY
case|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_LAMP
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
expr_stmt|;
break|break;
case|case
name|PT_GC
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|code
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|PT_PC
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|code
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|OK
operator|=
name|prop
operator|->
name|script
operator|==
name|code
index|[
literal|3
index|]
expr_stmt|;
break|break;
comment|/* These are specials for combination cases. */
case|case
name|PT_ALNUM
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
expr_stmt|;
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,           which means that Perl space and POSIX space are now identical. PCRE           was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PT_WORD
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
expr_stmt|;
break|break;
case|case
name|PT_CLIST
case|:
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|code
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PT_UCNC
case|:
name|OK
operator|=
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
expr_stmt|;
break|break;
comment|/* Should never occur, but keep compilers from grumbling. */
default|default:
name|OK
operator|=
name|codevalue
operator|!=
name|OP_PROP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_PROP
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|codevalue
operator|==
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSPLUS
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPLUS
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|nptr
init|=
name|ptr
operator|+
name|clen
decl_stmt|;
name|int
name|ncount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|codevalue
operator|==
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSPLUS
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|nptr
operator|<
name|end_subject
condition|)
block|{
name|dlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|d
operator|=
operator|*
name|nptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
name|nptr
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|ncount
operator|++
expr_stmt|;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|nptr
operator|+=
name|dlen
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPLUS
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|ncount
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
ifndef|#
directive|ifndef
name|EBCDIC
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
comment|/* Not EBCDIC */
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_BSR_ANYCRLF
operator|)
operator|!=
literal|0
condition|)
break|break;
goto|goto
name|ANYNL01
goto|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|ptr
operator|+
literal|1
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
operator|==
name|CHAR_LF
condition|)
name|ncount
operator|=
literal|1
expr_stmt|;
comment|/* Fall through */
name|ANYNL01
label|:
case|case
name|CHAR_LF
case|:
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|codevalue
operator|==
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSPLUS
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPLUS
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_VSPACE
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|codevalue
operator|==
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSPLUS
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPLUS
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEMINPLUS
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_HSPACE
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|codevalue
operator|==
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSPLUS
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEQUERY
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSQUERY
case|:
name|count
operator|=
literal|4
expr_stmt|;
goto|goto
name|QS1
goto|;
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPESTAR
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSSTAR
case|:
name|count
operator|=
literal|0
expr_stmt|;
name|QS1
label|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
index|[
literal|2
index|]
condition|)
block|{
case|case
name|PT_ANY
case|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_LAMP
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
expr_stmt|;
break|break;
case|case
name|PT_GC
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|code
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|PT_PC
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|code
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|OK
operator|=
name|prop
operator|->
name|script
operator|==
name|code
index|[
literal|3
index|]
expr_stmt|;
break|break;
comment|/* These are specials for combination cases. */
case|case
name|PT_ALNUM
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
expr_stmt|;
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,           which means that Perl space and POSIX space are now identical. PCRE           was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PT_WORD
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
expr_stmt|;
break|break;
case|case
name|PT_CLIST
case|:
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|code
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PT_UCNC
case|:
name|OK
operator|=
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
expr_stmt|;
break|break;
comment|/* Should never occur, but keep compilers from grumbling. */
default|default:
name|OK
operator|=
name|codevalue
operator|!=
name|OP_PROP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_PROP
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSSTAR
operator|||
name|codevalue
operator|==
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEQUERY
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSQUERY
case|:
name|count
operator|=
literal|2
expr_stmt|;
goto|goto
name|QS2
goto|;
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPESTAR
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSSTAR
case|:
name|count
operator|=
literal|0
expr_stmt|;
name|QS2
label|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|nptr
init|=
name|ptr
operator|+
name|clen
decl_stmt|;
name|int
name|ncount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|codevalue
operator|==
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSSTAR
operator|||
name|codevalue
operator|==
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|nptr
operator|<
name|end_subject
condition|)
block|{
name|dlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|d
operator|=
operator|*
name|nptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
name|nptr
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|ncount
operator|++
expr_stmt|;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|nptr
operator|+=
name|dlen
expr_stmt|;
block|}
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
name|count
operator|)
argument_list|,
literal|0
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEQUERY
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSQUERY
case|:
name|count
operator|=
literal|2
expr_stmt|;
goto|goto
name|QS3
goto|;
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPESTAR
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSSTAR
case|:
name|count
operator|=
literal|0
expr_stmt|;
name|QS3
label|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|ncount
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
ifndef|#
directive|ifndef
name|EBCDIC
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
comment|/* Not EBCDIC */
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_BSR_ANYCRLF
operator|)
operator|!=
literal|0
condition|)
break|break;
goto|goto
name|ANYNL02
goto|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|ptr
operator|+
literal|1
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
operator|==
name|CHAR_LF
condition|)
name|ncount
operator|=
literal|1
expr_stmt|;
comment|/* Fall through */
name|ANYNL02
label|:
case|case
name|CHAR_LF
case|:
if|if
condition|(
name|codevalue
operator|==
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSSTAR
operator|||
name|codevalue
operator|==
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
operator|(
name|int
operator|)
name|count
operator|)
argument_list|,
literal|0
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEQUERY
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSQUERY
case|:
name|count
operator|=
literal|2
expr_stmt|;
goto|goto
name|QS4
goto|;
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPESTAR
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSSTAR
case|:
name|count
operator|=
literal|0
expr_stmt|;
name|QS4
label|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_VSPACE
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSSTAR
operator|||
name|codevalue
operator|==
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
operator|(
name|int
operator|)
name|count
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEQUERY
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEMINQUERY
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSQUERY
case|:
name|count
operator|=
literal|2
expr_stmt|;
goto|goto
name|QS5
goto|;
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPESTAR
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEMINSTAR
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSSTAR
case|:
name|count
operator|=
literal|0
expr_stmt|;
name|QS5
label|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_HSPACE
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSSTAR
operator|||
name|codevalue
operator|==
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
operator|(
name|int
operator|)
name|count
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
ifdef|#
directive|ifdef
name|SUPPORT_UCP
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEEXACT
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEUPTO
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|codevalue
operator|!=
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEEXACT
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
specifier|const
name|pcre_uint32
modifier|*
name|cp
decl_stmt|;
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|1
index|]
condition|)
block|{
case|case
name|PT_ANY
case|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|PT_LAMP
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
expr_stmt|;
break|break;
case|case
name|PT_GC
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|PT_PC
case|:
name|OK
operator|=
name|prop
operator|->
name|chartype
operator|==
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|PT_SC
case|:
name|OK
operator|=
name|prop
operator|->
name|script
operator|==
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|2
index|]
expr_stmt|;
break|break;
comment|/* These are specials for combination cases. */
case|case
name|PT_ALNUM
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
expr_stmt|;
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,           which means that Perl space and POSIX space are now identical. PCRE           was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PT_WORD
case|:
name|OK
operator|=
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
expr_stmt|;
break|break;
case|case
name|PT_CLIST
case|:
name|cp
operator|=
name|PRIV
argument_list|(
name|ucd_caseless_sets
argument_list|)
operator|+
name|code
index|[
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|2
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
operator|*
name|cp
condition|)
block|{
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|cp
operator|++
condition|)
block|{
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PT_UCNC
case|:
name|OK
operator|=
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|||
operator|(
name|c
operator|>=
literal|0xa0
operator|&&
name|c
operator|<=
literal|0xd7ff
operator|)
operator|||
name|c
operator|>=
literal|0xe000
expr_stmt|;
break|break;
comment|/* Should never occur, but keep compilers from grumbling. */
default|default:
name|OK
operator|=
name|codevalue
operator|!=
name|OP_PROP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_PROP
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_PROP_EXTRA
operator|+
name|OP_TYPEPOSUPTO
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
operator|+
name|IMM2_SIZE
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEEXACT
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEUPTO
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|codevalue
operator|!=
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEEXACT
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|nptr
init|=
name|ptr
operator|+
name|clen
decl_stmt|;
name|int
name|ncount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|codevalue
operator|==
name|OP_EXTUNI_EXTRA
operator|+
name|OP_TYPEPOSUPTO
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|nptr
operator|<
name|end_subject
condition|)
block|{
name|dlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|d
operator|=
operator|*
name|nptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
name|nptr
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|ncount
operator|++
expr_stmt|;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|nptr
operator|+=
name|dlen
expr_stmt|;
block|}
if|if
condition|(
name|nptr
operator|>=
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|reset_could_continue
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
operator|)
argument_list|,
literal|0
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEEXACT
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEUPTO
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|codevalue
operator|!=
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEEXACT
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|ncount
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
ifndef|#
directive|ifndef
name|EBCDIC
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
comment|/* Not EBCDIC */
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_BSR_ANYCRLF
operator|)
operator|!=
literal|0
condition|)
break|break;
goto|goto
name|ANYNL03
goto|;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|ptr
operator|+
literal|1
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
operator|==
name|CHAR_LF
condition|)
name|ncount
operator|=
literal|1
expr_stmt|;
comment|/* Fall through */
name|ANYNL03
label|:
case|case
name|CHAR_LF
case|:
if|if
condition|(
name|codevalue
operator|==
name|OP_ANYNL_EXTRA
operator|+
name|OP_TYPEPOSUPTO
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
operator|)
argument_list|,
literal|0
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEEXACT
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEUPTO
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|codevalue
operator|!=
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEEXACT
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_VSPACE
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_VSPACE_EXTRA
operator|+
name|OP_TYPEPOSUPTO
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEEXACT
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEUPTO
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEMINUPTO
case|:
case|case
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSUPTO
case|:
if|if
condition|(
name|codevalue
operator|!=
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEEXACT
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|BOOL
name|OK
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|OK
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|OK
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OK
operator|==
operator|(
name|d
operator|==
name|OP_HSPACE
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_HSPACE_EXTRA
operator|+
name|OP_TYPEPOSUPTO
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|2
operator|+
name|IMM2_SIZE
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
name|state_offset
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/* ========================================================================== */
comment|/* These opcodes are followed by a character that is usually compared       to the current subject character; it is loaded into d. We still get       here even if there is no subject character, because in some cases zero       repetitions are permitted. */
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_CHAR
case|:
if|if
condition|(
name|clen
operator|>
literal|0
operator|&&
name|c
operator|==
name|d
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_CHARI
case|:
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|d
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|othercase
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|128
condition|)
name|othercase
operator|=
name|fcc
index|[
name|c
index|]
expr_stmt|;
else|else
comment|/* If we have Unicode property support, we can use it to test the             other case of the character. */
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|othercase
operator|=
name|UCD_OTHERCASE
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|othercase
operator|=
name|NOTACHAR
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|==
name|othercase
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
comment|/* Not UTF mode */
block|{
if|if
condition|(
name|TABLE_GET
argument_list|(
name|c
argument_list|,
name|lcc
argument_list|,
name|c
argument_list|)
operator|==
name|TABLE_GET
argument_list|(
name|d
argument_list|,
name|lcc
argument_list|,
name|d
argument_list|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SUPPORT_UCP
comment|/*-----------------------------------------------------------------*/
comment|/* This is a tricky one because it can match more than one character.       Find out how many characters to skip, and then set up a negative state       to wait for them to pass before continuing. */
case|case
name|OP_EXTUNI
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|int
name|lgb
decl_stmt|,
name|rgb
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|nptr
init|=
name|ptr
operator|+
name|clen
decl_stmt|;
name|int
name|ncount
init|=
literal|0
decl_stmt|;
name|lgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|nptr
operator|<
name|end_subject
condition|)
block|{
name|dlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|utf
condition|)
name|d
operator|=
operator|*
name|nptr
expr_stmt|;
else|else
block|{
name|GETCHARLEN
argument_list|(
name|d
argument_list|,
name|nptr
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
name|rgb
operator|=
name|UCD_GRAPHBREAK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gbtable
argument_list|)
index|[
name|lgb
index|]
operator|&
operator|(
literal|1
operator|<<
name|rgb
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|ncount
operator|++
expr_stmt|;
name|lgb
operator|=
name|rgb
expr_stmt|;
name|nptr
operator|+=
name|dlen
expr_stmt|;
block|}
if|if
condition|(
name|nptr
operator|>=
name|end_subject
operator|&&
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|reset_could_continue
operator|=
name|TRUE
expr_stmt|;
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/*-----------------------------------------------------------------*/
comment|/* This is a tricky like EXTUNI because it too can match more than one       character (when CR is followed by LF). In this case, set up a negative       state to wait for one character to pass before continuing. */
case|case
name|OP_ANYNL
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CHAR_VT
case|:
case|case
name|CHAR_FF
case|:
case|case
name|CHAR_NEL
case|:
ifndef|#
directive|ifndef
name|EBCDIC
case|case
literal|0x2028
case|:
case|case
literal|0x2029
case|:
endif|#
directive|endif
comment|/* Not EBCDIC */
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_BSR_ANYCRLF
operator|)
operator|!=
literal|0
condition|)
break|break;
case|case
name|CHAR_LF
case|:
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR_CR
case|:
if|if
condition|(
name|ptr
operator|+
literal|1
operator|>=
name|end_subject
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
condition|)
name|reset_could_continue
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UCHAR21TEST
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
operator|==
name|CHAR_LF
condition|)
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_NOT_VSPACE
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
break|break;
default|default:
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_VSPACE
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
name|VSPACE_CASES
label|:
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_NOT_HSPACE
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
break|break;
default|default:
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_HSPACE
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
comment|/* Match a negated single character casefully. */
case|case
name|OP_NOT
case|:
if|if
condition|(
name|clen
operator|>
literal|0
operator|&&
name|c
operator|!=
name|d
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
comment|/* Match a negated single character caselessly. */
case|case
name|OP_NOTI
case|:
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|otherd
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|d
operator|>=
literal|128
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|otherd
operator|=
name|UCD_OTHERCASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|otherd
operator|=
name|TABLE_GET
argument_list|(
name|d
argument_list|,
name|fcc
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|d
operator|&&
name|c
operator|!=
name|otherd
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_PLUSI
case|:
case|case
name|OP_MINPLUSI
case|:
case|case
name|OP_POSPLUSI
case|:
case|case
name|OP_NOTPLUSI
case|:
case|case
name|OP_NOTMINPLUSI
case|:
case|case
name|OP_NOTPOSPLUSI
case|:
name|caseless
operator|=
name|TRUE
expr_stmt|;
name|codevalue
operator|-=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_PLUS
case|:
case|case
name|OP_MINPLUS
case|:
case|case
name|OP_POSPLUS
case|:
case|case
name|OP_NOTPLUS
case|:
case|case
name|OP_NOTMINPLUS
case|:
case|case
name|OP_NOTPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|pcre_uint32
name|otherd
init|=
name|NOTACHAR
decl_stmt|;
if|if
condition|(
name|caseless
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|d
operator|>=
literal|128
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|otherd
operator|=
name|UCD_OTHERCASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|otherd
operator|=
name|TABLE_GET
argument_list|(
name|d
argument_list|,
name|fcc
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|d
operator|||
name|c
operator|==
name|otherd
operator|)
operator|==
operator|(
name|codevalue
operator|<
name|OP_NOTSTAR
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
operator|(
name|codevalue
operator|==
name|OP_POSPLUS
operator|||
name|codevalue
operator|==
name|OP_NOTPOSPLUS
operator|)
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_QUERYI
case|:
case|case
name|OP_MINQUERYI
case|:
case|case
name|OP_POSQUERYI
case|:
case|case
name|OP_NOTQUERYI
case|:
case|case
name|OP_NOTMINQUERYI
case|:
case|case
name|OP_NOTPOSQUERYI
case|:
name|caseless
operator|=
name|TRUE
expr_stmt|;
name|codevalue
operator|-=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_QUERY
case|:
case|case
name|OP_MINQUERY
case|:
case|case
name|OP_POSQUERY
case|:
case|case
name|OP_NOTQUERY
case|:
case|case
name|OP_NOTMINQUERY
case|:
case|case
name|OP_NOTPOSQUERY
case|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|pcre_uint32
name|otherd
init|=
name|NOTACHAR
decl_stmt|;
if|if
condition|(
name|caseless
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|d
operator|>=
literal|128
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|otherd
operator|=
name|UCD_OTHERCASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|otherd
operator|=
name|TABLE_GET
argument_list|(
name|d
argument_list|,
name|fcc
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|d
operator|||
name|c
operator|==
name|otherd
operator|)
operator|==
operator|(
name|codevalue
operator|<
name|OP_NOTSTAR
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_POSQUERY
operator|||
name|codevalue
operator|==
name|OP_NOTPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_STARI
case|:
case|case
name|OP_MINSTARI
case|:
case|case
name|OP_POSSTARI
case|:
case|case
name|OP_NOTSTARI
case|:
case|case
name|OP_NOTMINSTARI
case|:
case|case
name|OP_NOTPOSSTARI
case|:
name|caseless
operator|=
name|TRUE
expr_stmt|;
name|codevalue
operator|-=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_STAR
case|:
case|case
name|OP_MINSTAR
case|:
case|case
name|OP_POSSTAR
case|:
case|case
name|OP_NOTSTAR
case|:
case|case
name|OP_NOTMINSTAR
case|:
case|case
name|OP_NOTPOSSTAR
case|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|pcre_uint32
name|otherd
init|=
name|NOTACHAR
decl_stmt|;
if|if
condition|(
name|caseless
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|d
operator|>=
literal|128
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|otherd
operator|=
name|UCD_OTHERCASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|otherd
operator|=
name|TABLE_GET
argument_list|(
name|d
argument_list|,
name|fcc
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|d
operator|||
name|c
operator|==
name|otherd
operator|)
operator|==
operator|(
name|codevalue
operator|<
name|OP_NOTSTAR
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_POSSTAR
operator|||
name|codevalue
operator|==
name|OP_NOTPOSSTAR
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_EXACTI
case|:
case|case
name|OP_NOTEXACTI
case|:
name|caseless
operator|=
name|TRUE
expr_stmt|;
name|codevalue
operator|-=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_EXACT
case|:
case|case
name|OP_NOTEXACT
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|pcre_uint32
name|otherd
init|=
name|NOTACHAR
decl_stmt|;
if|if
condition|(
name|caseless
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|d
operator|>=
literal|128
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|otherd
operator|=
name|UCD_OTHERCASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|otherd
operator|=
name|TABLE_GET
argument_list|(
name|d
argument_list|,
name|fcc
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|d
operator|||
name|c
operator|==
name|otherd
operator|)
operator|==
operator|(
name|codevalue
operator|<
name|OP_NOTSTAR
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_UPTOI
case|:
case|case
name|OP_MINUPTOI
case|:
case|case
name|OP_POSUPTOI
case|:
case|case
name|OP_NOTUPTOI
case|:
case|case
name|OP_NOTMINUPTOI
case|:
case|case
name|OP_NOTPOSUPTOI
case|:
name|caseless
operator|=
name|TRUE
expr_stmt|;
name|codevalue
operator|-=
name|OP_STARI
operator|-
name|OP_STAR
expr_stmt|;
comment|/* Fall through */
case|case
name|OP_UPTO
case|:
case|case
name|OP_MINUPTO
case|:
case|case
name|OP_POSUPTO
case|:
case|case
name|OP_NOTUPTO
case|:
case|case
name|OP_NOTMINUPTO
case|:
case|case
name|OP_NOTPOSUPTO
case|:
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Number already matched */
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|pcre_uint32
name|otherd
init|=
name|NOTACHAR
decl_stmt|;
if|if
condition|(
name|caseless
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
name|d
operator|>=
literal|128
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UCP
name|otherd
operator|=
name|UCD_OTHERCASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
else|else
endif|#
directive|endif
comment|/* SUPPORT_UTF */
name|otherd
operator|=
name|TABLE_GET
argument_list|(
name|d
argument_list|,
name|fcc
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|d
operator|||
name|c
operator|==
name|otherd
operator|)
operator|==
operator|(
name|codevalue
operator|<
name|OP_NOTSTAR
operator|)
condition|)
block|{
if|if
condition|(
name|codevalue
operator|==
name|OP_POSUPTO
operator|||
name|codevalue
operator|==
name|OP_NOTPOSUPTO
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_NEW
argument_list|(
name|state_offset
operator|+
name|dlen
operator|+
literal|1
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/* ========================================================================== */
comment|/* These are the class-handling opcodes */
case|case
name|OP_CLASS
case|:
case|case
name|OP_NCLASS
case|:
case|case
name|OP_XCLASS
case|:
block|{
name|BOOL
name|isinclass
init|=
name|FALSE
decl_stmt|;
name|int
name|next_state_offset
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|ecode
decl_stmt|;
comment|/* For a simple class, there is always just a 32-byte table, and we         can set isinclass from it. */
if|if
condition|(
name|codevalue
operator|!=
name|OP_XCLASS
condition|)
block|{
name|ecode
operator|=
name|code
operator|+
literal|1
operator|+
operator|(
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|isinclass
operator|=
operator|(
name|c
operator|>
literal|255
operator|)
condition|?
operator|(
name|codevalue
operator|==
name|OP_NCLASS
operator|)
else|:
operator|(
operator|(
operator|(
operator|(
name|pcre_uint8
operator|*
operator|)
operator|(
name|code
operator|+
literal|1
operator|)
operator|)
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
comment|/* An extended class may have a table or a list of single characters,         ranges, or both, and it may be positive or negative. There's a         function that sorts all this out. */
else|else
block|{
name|ecode
operator|=
name|code
operator|+
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
name|isinclass
operator|=
name|PRIV
argument_list|(
name|xclass
argument_list|)
argument_list|(
name|c
argument_list|,
name|code
operator|+
literal|1
operator|+
name|LINK_SIZE
argument_list|,
name|utf
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, isinclass is set for all kinds of class, and ecode         points to the byte after the end of the class. If there is a         quantifier, this is where it will be. */
name|next_state_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|ecode
operator|-
name|start_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|ecode
condition|)
block|{
case|case
name|OP_CRSTAR
case|:
case|case
name|OP_CRMINSTAR
case|:
case|case
name|OP_CRPOSSTAR
case|:
name|ADD_ACTIVE
argument_list|(
name|next_state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinclass
condition|)
block|{
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_CRPOSSTAR
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_CRPLUS
case|:
case|case
name|OP_CRMINPLUS
case|:
case|case
name|OP_CRPOSPLUS
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|next_state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isinclass
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
operator|*
name|ecode
operator|==
name|OP_CRPOSPLUS
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_CRQUERY
case|:
case|case
name|OP_CRMINQUERY
case|:
case|case
name|OP_CRPOSQUERY
case|:
name|ADD_ACTIVE
argument_list|(
name|next_state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinclass
condition|)
block|{
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_CRPOSQUERY
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
name|ADD_NEW
argument_list|(
name|next_state_offset
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_CRRANGE
case|:
case|case
name|OP_CRMINRANGE
case|:
case|case
name|OP_CRPOSRANGE
case|:
name|count
operator|=
name|current_state
operator|->
name|count
expr_stmt|;
comment|/* Already matched */
if|if
condition|(
name|count
operator|>=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|next_state_offset
operator|+
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isinclass
condition|)
block|{
name|int
name|max
init|=
operator|(
name|int
operator|)
name|GET2
argument_list|(
name|ecode
argument_list|,
literal|1
operator|+
name|IMM2_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|ecode
operator|==
name|OP_CRPOSRANGE
condition|)
block|{
name|active_count
operator|--
expr_stmt|;
comment|/* Remove non-match possibility */
name|next_active_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|count
operator|>=
name|max
operator|&&
name|max
operator|!=
literal|0
condition|)
comment|/* Max 0 => no limit */
block|{
name|ADD_NEW
argument_list|(
name|next_state_offset
operator|+
literal|1
operator|+
literal|2
operator|*
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_NEW
argument_list|(
name|state_offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|isinclass
condition|)
block|{
name|ADD_NEW
argument_list|(
name|next_state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
break|break;
comment|/* ========================================================================== */
comment|/* These are the opcodes for fancy brackets of various kinds. We have       to use recursion in order to handle them. The "always failing" assertion       (?!) is optimised to OP_FAIL when compiling, so we have to support that,       though the other "backtracking verbs" are not supported. */
case|case
name|OP_FAIL
case|:
name|forced_fail
operator|++
expr_stmt|;
comment|/* Count FAILs for multiple states */
break|break;
case|case
name|OP_ASSERT
case|:
case|case
name|OP_ASSERT_NOT
case|:
case|case
name|OP_ASSERTBACK
case|:
case|case
name|OP_ASSERTBACK_NOT
case|:
block|{
name|int
name|rc
decl_stmt|;
name|int
name|local_offsets
index|[
literal|2
index|]
decl_stmt|;
name|int
name|local_workspace
index|[
literal|1000
index|]
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|endasscode
init|=
name|code
operator|+
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|endasscode
operator|==
name|OP_ALT
condition|)
name|endasscode
operator|+=
name|GET
argument_list|(
name|endasscode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|internal_dfa_exec
argument_list|(
name|md
argument_list|,
comment|/* static match data */
name|code
argument_list|,
comment|/* this subexpression's code */
name|ptr
argument_list|,
comment|/* where we currently are */
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
argument_list|,
comment|/* start offset */
name|local_offsets
argument_list|,
comment|/* offset vector */
sizeof|sizeof
argument_list|(
name|local_offsets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|local_workspace
argument_list|,
comment|/* workspace vector */
sizeof|sizeof
argument_list|(
name|local_workspace
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|rlevel
argument_list|)
expr_stmt|;
comment|/* function recursion level */
if|if
condition|(
name|rc
operator|==
name|PCRE_ERROR_DFA_UITEM
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rc
operator|>=
literal|0
operator|)
operator|==
operator|(
name|codevalue
operator|==
name|OP_ASSERT
operator|||
name|codevalue
operator|==
name|OP_ASSERTBACK
operator|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|endasscode
operator|+
name|LINK_SIZE
operator|+
literal|1
operator|-
name|start_code
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_COND
case|:
case|case
name|OP_SCOND
case|:
block|{
name|int
name|local_offsets
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|local_workspace
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|codelink
init|=
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|condcode
decl_stmt|;
comment|/* Because of the way auto-callout works during compile, a callout item         is inserted between OP_COND and an assertion condition. This does not         happen for the other conditions. */
if|if
condition|(
name|code
index|[
name|LINK_SIZE
operator|+
literal|1
index|]
operator|==
name|OP_CALLOUT
condition|)
block|{
name|rrc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|PUBL
argument_list|(
argument|callout_block
argument_list|)
name|cb
expr_stmt|;
name|cb
operator|.
name|version
operator|=
literal|1
expr_stmt|;
comment|/* Version 1 of the callout block */
name|cb
operator|.
name|callout_number
operator|=
name|code
index|[
name|LINK_SIZE
operator|+
literal|2
index|]
expr_stmt|;
name|cb
operator|.
name|offset_vector
operator|=
name|offsets
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR
operator|)
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR16
operator|)
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR32
operator|)
name|start_subject
expr_stmt|;
endif|#
directive|endif
name|cb
operator|.
name|subject_length
operator|=
call|(
name|int
call|)
argument_list|(
name|end_subject
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|start_match
operator|=
call|(
name|int
call|)
argument_list|(
name|current_subject
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|current_position
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|pattern_position
operator|=
name|GET
argument_list|(
name|code
argument_list|,
name|LINK_SIZE
operator|+
literal|3
argument_list|)
expr_stmt|;
name|cb
operator|.
name|next_item_length
operator|=
name|GET
argument_list|(
name|code
argument_list|,
literal|3
operator|+
literal|2
operator|*
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|capture_top
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|capture_last
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|.
name|callout_data
operator|=
name|md
operator|->
name|callout_data
expr_stmt|;
name|cb
operator|.
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* No (*MARK) support */
if|if
condition|(
operator|(
name|rrc
operator|=
operator|(
operator|*
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|)
operator|(
operator|&
name|cb
operator|)
operator|)
operator|<
literal|0
condition|)
return|return
name|rrc
return|;
comment|/* Abandon */
block|}
if|if
condition|(
name|rrc
operator|>
literal|0
condition|)
break|break;
comment|/* Fail this thread */
name|code
operator|+=
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CALLOUT
index|]
expr_stmt|;
comment|/* Skip callout data */
block|}
name|condcode
operator|=
name|code
index|[
name|LINK_SIZE
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Back reference conditions and duplicate named recursion conditions         are not supported */
if|if
condition|(
name|condcode
operator|==
name|OP_CREF
operator|||
name|condcode
operator|==
name|OP_DNCREF
operator|||
name|condcode
operator|==
name|OP_DNRREF
condition|)
return|return
name|PCRE_ERROR_DFA_UCOND
return|;
comment|/* The DEFINE condition is always false */
if|if
condition|(
name|condcode
operator|==
name|OP_DEF
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|codelink
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The only supported version of OP_RREF is for the value RREF_ANY,         which means "test if in any recursion". We can't test for specifically         recursed groups. */
elseif|else
if|if
condition|(
name|condcode
operator|==
name|OP_RREF
condition|)
block|{
name|int
name|value
init|=
name|GET2
argument_list|(
name|code
argument_list|,
name|LINK_SIZE
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|RREF_ANY
condition|)
return|return
name|PCRE_ERROR_DFA_UCOND
return|;
if|if
condition|(
name|md
operator|->
name|recursive
operator|!=
name|NULL
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|LINK_SIZE
operator|+
literal|2
operator|+
name|IMM2_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|codelink
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, the condition is an assertion */
else|else
block|{
name|int
name|rc
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|asscode
init|=
name|code
operator|+
name|LINK_SIZE
operator|+
literal|1
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|endasscode
init|=
name|asscode
operator|+
name|GET
argument_list|(
name|asscode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|endasscode
operator|==
name|OP_ALT
condition|)
name|endasscode
operator|+=
name|GET
argument_list|(
name|endasscode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|internal_dfa_exec
argument_list|(
name|md
argument_list|,
comment|/* fixed match data */
name|asscode
argument_list|,
comment|/* this subexpression's code */
name|ptr
argument_list|,
comment|/* where we currently are */
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
argument_list|,
comment|/* start offset */
name|local_offsets
argument_list|,
comment|/* offset vector */
sizeof|sizeof
argument_list|(
name|local_offsets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|local_workspace
argument_list|,
comment|/* workspace vector */
sizeof|sizeof
argument_list|(
name|local_workspace
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|rlevel
argument_list|)
expr_stmt|;
comment|/* function recursion level */
if|if
condition|(
name|rc
operator|==
name|PCRE_ERROR_DFA_UITEM
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|(
name|rc
operator|>=
literal|0
operator|)
operator|==
operator|(
name|condcode
operator|==
name|OP_ASSERT
operator|||
name|condcode
operator|==
name|OP_ASSERTBACK
operator|)
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
call|(
name|int
call|)
argument_list|(
name|endasscode
operator|+
name|LINK_SIZE
operator|+
literal|1
operator|-
name|start_code
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|codelink
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_RECURSE
case|:
block|{
name|dfa_recursion_info
modifier|*
name|ri
decl_stmt|;
name|int
name|local_offsets
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|local_workspace
index|[
literal|1000
index|]
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|callpat
init|=
name|start_code
operator|+
name|GET
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|recno
init|=
operator|(
name|callpat
operator|==
name|md
operator|->
name|start_code
operator|)
condition|?
literal|0
else|:
name|GET2
argument_list|(
name|callpat
argument_list|,
literal|1
operator|+
name|LINK_SIZE
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sStarting regex recursion\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|)
argument_list|)
expr_stmt|;
comment|/* Check for repeating a recursion without advancing the subject         pointer. This should catch convoluted mutual recursions. (Some simple         cases are caught at compile time.) */
for|for
control|(
name|ri
operator|=
name|md
operator|->
name|recursive
init|;
name|ri
operator|!=
name|NULL
condition|;
name|ri
operator|=
name|ri
operator|->
name|prevrec
control|)
if|if
condition|(
name|recno
operator|==
name|ri
operator|->
name|group_num
operator|&&
name|ptr
operator|==
name|ri
operator|->
name|subject_position
condition|)
return|return
name|PCRE_ERROR_RECURSELOOP
return|;
comment|/* Remember this recursion and where we started it so as to         catch infinite loops. */
name|new_recursive
operator|.
name|group_num
operator|=
name|recno
expr_stmt|;
name|new_recursive
operator|.
name|subject_position
operator|=
name|ptr
expr_stmt|;
name|new_recursive
operator|.
name|prevrec
operator|=
name|md
operator|->
name|recursive
expr_stmt|;
name|md
operator|->
name|recursive
operator|=
operator|&
name|new_recursive
expr_stmt|;
name|rc
operator|=
name|internal_dfa_exec
argument_list|(
name|md
argument_list|,
comment|/* fixed match data */
name|callpat
argument_list|,
comment|/* this subexpression's code */
name|ptr
argument_list|,
comment|/* where we currently are */
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
argument_list|,
comment|/* start offset */
name|local_offsets
argument_list|,
comment|/* offset vector */
sizeof|sizeof
argument_list|(
name|local_offsets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|local_workspace
argument_list|,
comment|/* workspace vector */
sizeof|sizeof
argument_list|(
name|local_workspace
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|rlevel
argument_list|)
expr_stmt|;
comment|/* function recursion level */
name|md
operator|->
name|recursive
operator|=
name|new_recursive
operator|.
name|prevrec
expr_stmt|;
comment|/* Done this recursion */
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sReturn from regex recursion: rc=%d\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
comment|/* Ran out of internal offsets */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
return|return
name|PCRE_ERROR_DFA_RECURSE
return|;
comment|/* For each successful matched substring, set up the next state with a         count of characters to skip before trying it. Note that the count is in         characters, not bytes. */
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|rc
operator|=
name|rc
operator|*
literal|2
operator|-
literal|2
init|;
name|rc
operator|>=
literal|0
condition|;
name|rc
operator|-=
literal|2
control|)
block|{
name|int
name|charcount
init|=
name|local_offsets
index|[
name|rc
operator|+
literal|1
index|]
operator|-
name|local_offsets
index|[
name|rc
index|]
decl_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|p
init|=
name|start_subject
operator|+
name|local_offsets
index|[
name|rc
index|]
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|pp
init|=
name|start_subject
operator|+
name|local_offsets
index|[
name|rc
operator|+
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|pp
condition|)
if|if
condition|(
name|NOT_FIRSTCHAR
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
name|charcount
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|charcount
operator|>
literal|0
condition|)
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
operator|(
name|state_offset
operator|+
name|LINK_SIZE
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|charcount
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
name|PCRE_ERROR_NOMATCH
condition|)
return|return
name|rc
return|;
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_BRAPOS
case|:
case|case
name|OP_SBRAPOS
case|:
case|case
name|OP_CBRAPOS
case|:
case|case
name|OP_SCBRAPOS
case|:
case|case
name|OP_BRAPOSZERO
case|:
block|{
name|int
name|charcount
decl_stmt|,
name|matched_count
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|local_ptr
init|=
name|ptr
decl_stmt|;
name|BOOL
name|allow_zero
decl_stmt|;
if|if
condition|(
name|codevalue
operator|==
name|OP_BRAPOSZERO
condition|)
block|{
name|allow_zero
operator|=
name|TRUE
expr_stmt|;
name|codevalue
operator|=
operator|*
operator|(
operator|++
name|code
operator|)
expr_stmt|;
comment|/* Codevalue will be one of above BRAs */
block|}
else|else
name|allow_zero
operator|=
name|FALSE
expr_stmt|;
comment|/* Loop to match the subpattern as many times as possible as if it were         a complete pattern. */
for|for
control|(
name|matched_count
operator|=
literal|0
init|;
condition|;
name|matched_count
operator|++
control|)
block|{
name|int
name|local_offsets
index|[
literal|2
index|]
decl_stmt|;
name|int
name|local_workspace
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|rc
init|=
name|internal_dfa_exec
argument_list|(
name|md
argument_list|,
comment|/* fixed match data */
name|code
argument_list|,
comment|/* this subexpression's code */
name|local_ptr
argument_list|,
comment|/* where we currently are */
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
argument_list|,
comment|/* start offset */
name|local_offsets
argument_list|,
comment|/* offset vector */
sizeof|sizeof
argument_list|(
name|local_offsets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|local_workspace
argument_list|,
comment|/* workspace vector */
sizeof|sizeof
argument_list|(
name|local_workspace
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|rlevel
argument_list|)
decl_stmt|;
comment|/* function recursion level */
comment|/* Failed to match */
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|!=
name|PCRE_ERROR_NOMATCH
condition|)
return|return
name|rc
return|;
break|break;
block|}
comment|/* Matched: break the loop if zero characters matched. */
name|charcount
operator|=
name|local_offsets
index|[
literal|1
index|]
operator|-
name|local_offsets
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|charcount
operator|==
literal|0
condition|)
break|break;
name|local_ptr
operator|+=
name|charcount
expr_stmt|;
comment|/* Advance temporary position ptr */
block|}
comment|/* At this point we have matched the subpattern matched_count         times, and local_ptr is pointing to the character after the end of the         last match. */
if|if
condition|(
name|matched_count
operator|>
literal|0
operator|||
name|allow_zero
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|end_subpattern
init|=
name|code
decl_stmt|;
name|int
name|next_state_offset
decl_stmt|;
do|do
block|{
name|end_subpattern
operator|+=
name|GET
argument_list|(
name|end_subpattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end_subpattern
operator|==
name|OP_ALT
condition|)
do|;
name|next_state_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|end_subpattern
operator|-
name|start_code
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Optimization: if there are no more active states, and there           are no new states yet set up, then skip over the subject string           right here, to save looping. Otherwise, set up the new state to swing           into action when the end of the matched substring is reached. */
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|active_count
operator|&&
name|new_count
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|local_ptr
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
name|ADD_NEW
argument_list|(
name|next_state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|pcre_uchar
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|pp
init|=
name|local_ptr
decl_stmt|;
name|charcount
operator|=
call|(
name|int
call|)
argument_list|(
name|pp
operator|-
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
condition|)
while|while
condition|(
name|p
operator|<
name|pp
condition|)
if|if
condition|(
name|NOT_FIRSTCHAR
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
name|charcount
operator|--
expr_stmt|;
endif|#
directive|endif
name|ADD_NEW_DATA
argument_list|(
operator|-
name|next_state_offset
argument_list|,
literal|0
argument_list|,
operator|(
name|charcount
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/*-----------------------------------------------------------------*/
case|case
name|OP_ONCE
case|:
case|case
name|OP_ONCE_NC
case|:
block|{
name|int
name|local_offsets
index|[
literal|2
index|]
decl_stmt|;
name|int
name|local_workspace
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|rc
init|=
name|internal_dfa_exec
argument_list|(
name|md
argument_list|,
comment|/* fixed match data */
name|code
argument_list|,
comment|/* this subexpression's code */
name|ptr
argument_list|,
comment|/* where we currently are */
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
argument_list|,
comment|/* start offset */
name|local_offsets
argument_list|,
comment|/* offset vector */
sizeof|sizeof
argument_list|(
name|local_offsets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|local_workspace
argument_list|,
comment|/* workspace vector */
sizeof|sizeof
argument_list|(
name|local_workspace
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
comment|/* size of same */
name|rlevel
argument_list|)
decl_stmt|;
comment|/* function recursion level */
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|end_subpattern
init|=
name|code
decl_stmt|;
name|int
name|charcount
init|=
name|local_offsets
index|[
literal|1
index|]
operator|-
name|local_offsets
index|[
literal|0
index|]
decl_stmt|;
name|int
name|next_state_offset
decl_stmt|,
name|repeat_state_offset
decl_stmt|;
do|do
block|{
name|end_subpattern
operator|+=
name|GET
argument_list|(
name|end_subpattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|end_subpattern
operator|==
name|OP_ALT
condition|)
do|;
name|next_state_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|end_subpattern
operator|-
name|start_code
operator|+
name|LINK_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If the end of this subpattern is KETRMAX or KETRMIN, we must           arrange for the repeat state also to be added to the relevant list.           Calculate the offset, or set -1 for no repeat. */
name|repeat_state_offset
operator|=
operator|(
operator|*
name|end_subpattern
operator|==
name|OP_KETRMAX
operator|||
operator|*
name|end_subpattern
operator|==
name|OP_KETRMIN
operator|)
condition|?
call|(
name|int
call|)
argument_list|(
name|end_subpattern
operator|-
name|start_code
operator|-
name|GET
argument_list|(
name|end_subpattern
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
comment|/* If we have matched an empty string, add the next state at the           current character pointer. This is important so that the duplicate           checking kicks in, which is what breaks infinite loops that match an           empty string. */
if|if
condition|(
name|charcount
operator|==
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|next_state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Optimization: if there are no more active states, and there           are no new states yet set up, then skip over the subject string           right here, to save looping. Otherwise, set up the new state to swing           into action when the end of the matched substring is reached. */
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|active_count
operator|&&
name|new_count
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
name|charcount
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
name|ADD_NEW
argument_list|(
name|next_state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are adding a repeat state at the new character position,             we must fudge things so that it is the only current state.             Otherwise, it might be a duplicate of one we processed before, and             that would cause it to be skipped. */
if|if
condition|(
name|repeat_state_offset
operator|>=
literal|0
condition|)
block|{
name|next_active_state
operator|=
name|active_states
expr_stmt|;
name|active_count
operator|=
literal|0
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|ADD_ACTIVE
argument_list|(
name|repeat_state_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
name|SUPPORT_UTF
operator|&&
operator|!
name|defined
name|COMPILE_PCRE32
if|if
condition|(
name|utf
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|p
init|=
name|start_subject
operator|+
name|local_offsets
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|pp
init|=
name|start_subject
operator|+
name|local_offsets
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|pp
condition|)
if|if
condition|(
name|NOT_FIRSTCHAR
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
name|charcount
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
name|ADD_NEW_DATA
argument_list|(
operator|-
name|next_state_offset
argument_list|,
literal|0
argument_list|,
operator|(
name|charcount
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat_state_offset
operator|>=
literal|0
condition|)
block|{
name|ADD_NEW_DATA
argument_list|(
operator|-
name|repeat_state_offset
argument_list|,
literal|0
argument_list|,
operator|(
name|charcount
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
name|PCRE_ERROR_NOMATCH
condition|)
return|return
name|rc
return|;
block|}
break|break;
comment|/* ========================================================================== */
comment|/* Handle callouts */
case|case
name|OP_CALLOUT
case|:
name|rrc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|PUBL
argument_list|(
argument|callout_block
argument_list|)
name|cb
expr_stmt|;
name|cb
operator|.
name|version
operator|=
literal|1
expr_stmt|;
comment|/* Version 1 of the callout block */
name|cb
operator|.
name|callout_number
operator|=
name|code
index|[
literal|1
index|]
expr_stmt|;
name|cb
operator|.
name|offset_vector
operator|=
name|offsets
expr_stmt|;
if|#
directive|if
name|defined
name|COMPILE_PCRE8
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR
operator|)
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR16
operator|)
name|start_subject
expr_stmt|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|cb
operator|.
name|subject
operator|=
operator|(
name|PCRE_SPTR32
operator|)
name|start_subject
expr_stmt|;
endif|#
directive|endif
name|cb
operator|.
name|subject_length
operator|=
call|(
name|int
call|)
argument_list|(
name|end_subject
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|start_match
operator|=
call|(
name|int
call|)
argument_list|(
name|current_subject
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|current_position
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start_subject
argument_list|)
expr_stmt|;
name|cb
operator|.
name|pattern_position
operator|=
name|GET
argument_list|(
name|code
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cb
operator|.
name|next_item_length
operator|=
name|GET
argument_list|(
name|code
argument_list|,
literal|2
operator|+
name|LINK_SIZE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|capture_top
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|capture_last
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|.
name|callout_data
operator|=
name|md
operator|->
name|callout_data
expr_stmt|;
name|cb
operator|.
name|mark
operator|=
name|NULL
expr_stmt|;
comment|/* No (*MARK) support */
if|if
condition|(
operator|(
name|rrc
operator|=
operator|(
operator|*
name|PUBL
argument_list|(
name|callout
argument_list|)
operator|)
operator|(
operator|&
name|cb
operator|)
operator|)
operator|<
literal|0
condition|)
return|return
name|rrc
return|;
comment|/* Abandon */
block|}
if|if
condition|(
name|rrc
operator|==
literal|0
condition|)
block|{
name|ADD_ACTIVE
argument_list|(
name|state_offset
operator|+
name|PRIV
argument_list|(
name|OP_lengths
argument_list|)
index|[
name|OP_CALLOUT
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* ========================================================================== */
default|default:
comment|/* Unsupported opcode */
return|return
name|PCRE_ERROR_DFA_UITEM
return|;
block|}
name|NEXT_ACTIVE_STATE
label|:
continue|continue;
block|}
comment|/* End of loop scanning active states */
comment|/* We have finished the processing at the current subject character. If no   new states have been set for the next character, we have found all the   matches that we are going to find. If we are at the top level and partial   matching has been requested, check for appropriate conditions.    The "forced_ fail" variable counts the number of (*F) encountered for the   character. If it is equal to the original active_count (saved in   workspace[1]) it means that (*F) was found on every active state. In this   case we don't want to give a partial match.    The "could_continue" variable is true if a state could have continued but   for the fact that the end of the subject was reached. */
if|if
condition|(
name|new_count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|rlevel
operator|==
literal|1
operator|&&
comment|/* Top level, and */
name|could_continue
operator|&&
comment|/* Some could go on, and */
name|forced_fail
operator|!=
name|workspace
index|[
literal|1
index|]
operator|&&
comment|/* Not all forced fail& */
operator|(
comment|/* either... */
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
comment|/* Hard partial */
operator|||
comment|/* or... */
operator|(
operator|(
name|md
operator|->
name|moptions
operator|&
name|PCRE_PARTIAL_SOFT
operator|)
operator|!=
literal|0
operator|&&
comment|/* Soft partial and */
name|match_count
operator|<
literal|0
operator|)
comment|/* no matches */
operator|)
operator|&&
comment|/* And... */
operator|(
name|partial_newline
operator|||
comment|/* Either partial NL */
operator|(
comment|/* or ... */
name|ptr
operator|>=
name|end_subject
operator|&&
comment|/* End of subject and */
name|ptr
operator|>
name|md
operator|->
name|start_used_ptr
operator|)
comment|/* Inspected non-empty string */
operator|)
condition|)
name|match_count
operator|=
name|PCRE_ERROR_PARTIAL
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%.*sEnd of internal_dfa_exec %d: returning %d\n"
literal|"%.*s---------------------\n\n"
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|,
name|rlevel
operator|,
name|match_count
operator|,
name|rlevel
operator|*
literal|2
operator|-
literal|2
operator|,
name|SP
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* In effect, "return", but see the comment below */
block|}
comment|/* One or more states are active for the next character. */
name|ptr
operator|+=
name|clen
expr_stmt|;
comment|/* Advance to next subject character */
block|}
comment|/* Loop to move along the subject string */
comment|/* Control gets here from "break" a few lines above. We do it this way because if we use "return" above, we have compiler trouble. Some compilers warn if there's nothing here because they think the function doesn't return a value. On the other hand, if we put a dummy statement here, some more clever compilers complain that it can't be reached. Sigh. */
return|return
name|match_count
return|;
block|}
end_function
begin_comment
comment|/************************************************* *    Execute a Regular Expression - DFA engine   * *************************************************/
end_comment
begin_comment
comment|/* This external function applies a compiled re to a subject string using a DFA engine. This function calls the internal function multiple times if the pattern is not anchored.  Arguments:   argument_re     points to the compiled expression   extra_data      points to extra data or is NULL   subject         points to the subject string   length          length of subject string (may contain binary zeros)   start_offset    where to start in the subject string   options         option bits   offsets         vector of match offsets   offsetcount     size of same   workspace       workspace vector   wscount         size of same  Returns:> 0 => number of match offset pairs placed in offsets                   = 0 => offsets overflowed; longest matches are present                    -1 => failed to match< -1 => some kind of unexpected problem */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_dfa_exec
name|pcre_dfa_exec
argument_list|(
specifier|const
name|pcre
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre_extra
operator|*
name|extra_data
argument_list|,
specifier|const
name|char
operator|*
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|,
name|int
operator|*
name|workspace
argument_list|,
name|int
name|wscount
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_dfa_exec
argument_list|(
specifier|const
name|pcre16
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre16_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR16
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|,
name|int
operator|*
name|workspace
argument_list|,
name|int
name|wscount
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre32_dfa_exec
argument_list|(
specifier|const
name|pcre32
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre32_extra
operator|*
name|extra_data
argument_list|,
name|PCRE_SPTR32
name|subject
argument_list|,
name|int
name|length
argument_list|,
name|int
name|start_offset
argument_list|,
name|int
name|options
argument_list|,
name|int
operator|*
name|offsets
argument_list|,
name|int
name|offsetcount
argument_list|,
name|int
operator|*
name|workspace
argument_list|,
name|int
name|wscount
argument_list|)
endif|#
directive|endif
block|{
name|REAL_PCRE
modifier|*
name|re
init|=
operator|(
name|REAL_PCRE
operator|*
operator|)
name|argument_re
decl_stmt|;
name|dfa_match_data
name|match_block
decl_stmt|;
name|dfa_match_data
modifier|*
name|md
init|=
operator|&
name|match_block
decl_stmt|;
name|BOOL
name|utf
decl_stmt|,
name|anchored
decl_stmt|,
name|startline
decl_stmt|,
name|firstline
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|current_subject
decl_stmt|,
modifier|*
name|end_subject
decl_stmt|;
specifier|const
name|pcre_study_data
modifier|*
name|study
init|=
name|NULL
decl_stmt|;
specifier|const
name|pcre_uchar
modifier|*
name|req_char_ptr
decl_stmt|;
specifier|const
name|pcre_uint8
modifier|*
name|start_bits
init|=
name|NULL
decl_stmt|;
name|BOOL
name|has_first_char
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|has_req_char
init|=
name|FALSE
decl_stmt|;
name|pcre_uchar
name|first_char
init|=
literal|0
decl_stmt|;
name|pcre_uchar
name|first_char2
init|=
literal|0
decl_stmt|;
name|pcre_uchar
name|req_char
init|=
literal|0
decl_stmt|;
name|pcre_uchar
name|req_char2
init|=
literal|0
decl_stmt|;
name|int
name|newline
decl_stmt|;
comment|/* Plausibility checks */
if|if
condition|(
operator|(
name|options
operator|&
operator|~
name|PUBLIC_DFA_EXEC_OPTIONS
operator|)
operator|!=
literal|0
condition|)
return|return
name|PCRE_ERROR_BADOPTION
return|;
if|if
condition|(
name|re
operator|==
name|NULL
operator|||
name|subject
operator|==
name|NULL
operator|||
name|workspace
operator|==
name|NULL
operator|||
operator|(
name|offsets
operator|==
name|NULL
operator|&&
name|offsetcount
operator|>
literal|0
operator|)
condition|)
return|return
name|PCRE_ERROR_NULL
return|;
if|if
condition|(
name|offsetcount
operator|<
literal|0
condition|)
return|return
name|PCRE_ERROR_BADCOUNT
return|;
if|if
condition|(
name|wscount
operator|<
literal|20
condition|)
return|return
name|PCRE_ERROR_DFA_WSSIZE
return|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
return|return
name|PCRE_ERROR_BADLENGTH
return|;
if|if
condition|(
name|start_offset
operator|<
literal|0
operator|||
name|start_offset
operator|>
name|length
condition|)
return|return
name|PCRE_ERROR_BADOFFSET
return|;
comment|/* Check that the first field in the block is the magic number. If it is not, return with PCRE_ERROR_BADMAGIC. However, if the magic number is equal to REVERSED_MAGIC_NUMBER we return with PCRE_ERROR_BADENDIANNESS, which means that the pattern is likely compiled with different endianness. */
if|if
condition|(
name|re
operator|->
name|magic_number
operator|!=
name|MAGIC_NUMBER
condition|)
return|return
name|re
operator|->
name|magic_number
operator|==
name|REVERSED_MAGIC_NUMBER
condition|?
name|PCRE_ERROR_BADENDIANNESS
else|:
name|PCRE_ERROR_BADMAGIC
return|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_MODE
operator|)
operator|==
literal|0
condition|)
return|return
name|PCRE_ERROR_BADMODE
return|;
comment|/* If restarting after a partial match, do some sanity checks on the contents of the workspace. */
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_DFA_RESTART
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|workspace
index|[
literal|0
index|]
operator|&
operator|(
operator|-
literal|2
operator|)
operator|)
operator|!=
literal|0
operator|||
name|workspace
index|[
literal|1
index|]
operator|<
literal|1
operator|||
name|workspace
index|[
literal|1
index|]
operator|>
operator|(
name|wscount
operator|-
literal|2
operator|)
operator|/
name|INTS_PER_STATEBLOCK
condition|)
return|return
name|PCRE_ERROR_DFA_BADRESTART
return|;
block|}
comment|/* Set up study, callout, and table data */
name|md
operator|->
name|tables
operator|=
name|re
operator|->
name|tables
expr_stmt|;
name|md
operator|->
name|callout_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|extra_data
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
name|extra_data
operator|->
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_STUDY_DATA
operator|)
operator|!=
literal|0
condition|)
name|study
operator|=
operator|(
specifier|const
name|pcre_study_data
operator|*
operator|)
name|extra_data
operator|->
name|study_data
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_MATCH_LIMIT
operator|)
operator|!=
literal|0
condition|)
return|return
name|PCRE_ERROR_DFA_UMLIMIT
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_MATCH_LIMIT_RECURSION
operator|)
operator|!=
literal|0
condition|)
return|return
name|PCRE_ERROR_DFA_UMLIMIT
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_CALLOUT_DATA
operator|)
operator|!=
literal|0
condition|)
name|md
operator|->
name|callout_data
operator|=
name|extra_data
operator|->
name|callout_data
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PCRE_EXTRA_TABLES
operator|)
operator|!=
literal|0
condition|)
name|md
operator|->
name|tables
operator|=
name|extra_data
operator|->
name|tables
expr_stmt|;
block|}
comment|/* Set some local values */
name|current_subject
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|subject
operator|+
name|start_offset
expr_stmt|;
name|end_subject
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|subject
operator|+
name|length
expr_stmt|;
name|req_char_ptr
operator|=
name|current_subject
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
comment|/* PCRE_UTF(16|32) have the same value as PCRE_UTF8. */
name|utf
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_UTF8
operator|)
operator|!=
literal|0
expr_stmt|;
else|#
directive|else
name|utf
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|anchored
operator|=
operator|(
name|options
operator|&
operator|(
name|PCRE_ANCHORED
operator||
name|PCRE_DFA_RESTART
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_ANCHORED
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* The remaining fixed data for passing around. */
name|md
operator|->
name|start_code
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|argument_re
operator|+
name|re
operator|->
name|name_table_offset
operator|+
name|re
operator|->
name|name_count
operator|*
name|re
operator|->
name|name_entry_size
expr_stmt|;
name|md
operator|->
name|start_subject
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|subject
expr_stmt|;
name|md
operator|->
name|end_subject
operator|=
name|end_subject
expr_stmt|;
name|md
operator|->
name|start_offset
operator|=
name|start_offset
expr_stmt|;
name|md
operator|->
name|moptions
operator|=
name|options
expr_stmt|;
name|md
operator|->
name|poptions
operator|=
name|re
operator|->
name|options
expr_stmt|;
comment|/* If the BSR option is not set at match time, copy what was set at compile time. */
if|if
condition|(
operator|(
name|md
operator|->
name|moptions
operator|&
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|md
operator|->
name|moptions
operator||=
name|re
operator|->
name|options
operator|&
operator|(
name|PCRE_BSR_ANYCRLF
operator||
name|PCRE_BSR_UNICODE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSR_ANYCRLF
else|else
name|md
operator|->
name|moptions
operator||=
name|PCRE_BSR_ANYCRLF
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Handle different types of newline. The three bits give eight cases. If nothing is set at run time, whatever was used at compile time applies. */
switch|switch
condition|(
operator|(
operator|(
operator|(
name|options
operator|&
name|PCRE_NEWLINE_BITS
operator|)
operator|==
literal|0
operator|)
condition|?
name|re
operator|->
name|options
else|:
operator|(
name|pcre_uint32
operator|)
name|options
operator|)
operator|&
name|PCRE_NEWLINE_BITS
condition|)
block|{
case|case
literal|0
case|:
name|newline
operator|=
name|NEWLINE
expr_stmt|;
break|break;
comment|/* Compile-time default */
case|case
name|PCRE_NEWLINE_CR
case|:
name|newline
operator|=
name|CHAR_CR
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_LF
case|:
name|newline
operator|=
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_CR
operator|+
name|PCRE_NEWLINE_LF
case|:
name|newline
operator|=
operator|(
name|CHAR_CR
operator|<<
literal|8
operator|)
operator||
name|CHAR_NL
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANY
case|:
name|newline
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PCRE_NEWLINE_ANYCRLF
case|:
name|newline
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
default|default:
return|return
name|PCRE_ERROR_BADNEWLINE
return|;
block|}
if|if
condition|(
name|newline
operator|==
operator|-
literal|2
condition|)
block|{
name|md
operator|->
name|nltype
operator|=
name|NLTYPE_ANYCRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newline
operator|<
literal|0
condition|)
block|{
name|md
operator|->
name|nltype
operator|=
name|NLTYPE_ANY
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|nltype
operator|=
name|NLTYPE_FIXED
expr_stmt|;
if|if
condition|(
name|newline
operator|>
literal|255
condition|)
block|{
name|md
operator|->
name|nllen
operator|=
literal|2
expr_stmt|;
name|md
operator|->
name|nl
index|[
literal|0
index|]
operator|=
operator|(
name|newline
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|md
operator|->
name|nl
index|[
literal|1
index|]
operator|=
name|newline
operator|&
literal|255
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|nllen
operator|=
literal|1
expr_stmt|;
name|md
operator|->
name|nl
index|[
literal|0
index|]
operator|=
name|newline
expr_stmt|;
block|}
block|}
comment|/* Check a UTF-8 string if required. Unfortunately there's no way of passing back the character offset. */
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
operator|&&
operator|(
name|options
operator|&
name|PCRE_NO_UTF8_CHECK
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|erroroffset
decl_stmt|;
name|int
name|errorcode
init|=
name|PRIV
argument_list|(
name|valid_utf
argument_list|)
argument_list|(
operator|(
name|pcre_uchar
operator|*
operator|)
name|subject
argument_list|,
name|length
argument_list|,
operator|&
name|erroroffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|errorcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offsetcount
operator|>=
literal|2
condition|)
block|{
name|offsets
index|[
literal|0
index|]
operator|=
name|erroroffset
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
name|errorcode
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|COMPILE_PCRE8
return|return
operator|(
name|errorcode
operator|<=
name|PCRE_UTF8_ERR5
operator|&&
operator|(
name|options
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
operator|)
condition|?
name|PCRE_ERROR_SHORTUTF8
else|:
name|PCRE_ERROR_BADUTF8
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
return|return
operator|(
name|errorcode
operator|<=
name|PCRE_UTF16_ERR1
operator|&&
operator|(
name|options
operator|&
name|PCRE_PARTIAL_HARD
operator|)
operator|!=
literal|0
operator|)
condition|?
name|PCRE_ERROR_SHORTUTF16
else|:
name|PCRE_ERROR_BADUTF16
return|;
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
return|return
name|PCRE_ERROR_BADUTF32
return|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
name|COMPILE_PCRE8
operator|||
name|defined
name|COMPILE_PCRE16
if|if
condition|(
name|start_offset
operator|>
literal|0
operator|&&
name|start_offset
operator|<
name|length
operator|&&
name|NOT_FIRSTCHAR
argument_list|(
operator|(
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
operator|)
index|[
name|start_offset
index|]
argument_list|)
condition|)
return|return
name|PCRE_ERROR_BADUTF8_OFFSET
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* If the exec call supplied NULL for tables, use the inbuilt ones. This is a feature that makes it possible to save compiled regex and re-use them in other programs later. */
if|if
condition|(
name|md
operator|->
name|tables
operator|==
name|NULL
condition|)
name|md
operator|->
name|tables
operator|=
name|PRIV
argument_list|(
name|default_tables
argument_list|)
expr_stmt|;
comment|/* The "must be at the start of a line" flags are used in a loop when finding where to start. */
name|startline
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|!=
literal|0
expr_stmt|;
name|firstline
operator|=
operator|(
name|re
operator|->
name|options
operator|&
name|PCRE_FIRSTLINE
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Set up the first character to match, if available. The first_byte value is never set for an anchored regular expression, but the anchoring may be forced at run time, so we have to test for anchoring. The first char may be unset for an unanchored pattern, of course. If there's no first char and the pattern was studied, there may be a bitmap of possible first characters. */
if|if
condition|(
operator|!
name|anchored
condition|)
block|{
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|has_first_char
operator|=
name|TRUE
expr_stmt|;
name|first_char
operator|=
name|first_char2
operator|=
call|(
name|pcre_uchar
call|)
argument_list|(
name|re
operator|->
name|first_char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FCH_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|first_char2
operator|=
name|TABLE_GET
argument_list|(
name|first_char
argument_list|,
name|md
operator|->
name|tables
operator|+
name|fcc_offset
argument_list|,
name|first_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|utf
operator|&&
name|first_char
operator|>
literal|127
condition|)
name|first_char2
operator|=
name|UCD_OTHERCASE
argument_list|(
name|first_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|startline
operator|&&
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MAPPED
operator|)
operator|!=
literal|0
condition|)
name|start_bits
operator|=
name|study
operator|->
name|start_bits
expr_stmt|;
block|}
block|}
comment|/* For anchored or unanchored matches, there may be a "last known required character" set. */
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|has_req_char
operator|=
name|TRUE
expr_stmt|;
name|req_char
operator|=
name|req_char2
operator|=
call|(
name|pcre_uchar
call|)
argument_list|(
name|re
operator|->
name|req_char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_RCH_CASELESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|req_char2
operator|=
name|TABLE_GET
argument_list|(
name|req_char
argument_list|,
name|md
operator|->
name|tables
operator|+
name|fcc_offset
argument_list|,
name|req_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|SUPPORT_UCP
operator|&&
operator|!
operator|(
name|defined
name|COMPILE_PCRE8
operator|)
if|if
condition|(
name|utf
operator|&&
name|req_char
operator|>
literal|127
condition|)
name|req_char2
operator|=
name|UCD_OTHERCASE
argument_list|(
name|req_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Call the main matching function, looping for a non-anchored regex after a failed match. If not restarting, perform certain optimizations at the start of a match. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|PCRE_DFA_RESTART
operator|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|pcre_uchar
modifier|*
name|save_end_subject
init|=
name|end_subject
decl_stmt|;
comment|/* If firstline is TRUE, the start of the match is constrained to the first     line of a multiline string. Implement this by temporarily adjusting     end_subject so that we stop scanning at a newline. If the match fails at     the newline, later code breaks this loop. */
if|if
condition|(
name|firstline
condition|)
block|{
name|PCRE_PUCHAR
name|t
init|=
name|current_subject
decl_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
while|while
condition|(
name|t
operator|<
name|md
operator|->
name|end_subject
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|t
operator|<
name|end_subject
argument_list|,
operator|*
name|t
argument_list|,
name|t
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
while|while
condition|(
name|t
operator|<
name|md
operator|->
name|end_subject
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
name|end_subject
operator|=
name|t
expr_stmt|;
block|}
comment|/* There are some optimizations that avoid running the match if a known     starting point is not found. However, there is an option that disables     these, for testing and for ensuring that all callouts do actually occur.     The option can be set in the regex by (*NO_START_OPT) or passed in     match-time options. */
if|if
condition|(
operator|(
operator|(
name|options
operator||
name|re
operator|->
name|options
operator|)
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Advance to a known first pcre_uchar (i.e. data item) */
if|if
condition|(
name|has_first_char
condition|)
block|{
if|if
condition|(
name|first_char
operator|!=
name|first_char2
condition|)
block|{
name|pcre_uchar
name|csc
decl_stmt|;
while|while
condition|(
name|current_subject
operator|<
name|end_subject
operator|&&
operator|(
name|csc
operator|=
name|UCHAR21TEST
argument_list|(
name|current_subject
argument_list|)
operator|)
operator|!=
name|first_char
operator|&&
name|csc
operator|!=
name|first_char2
condition|)
name|current_subject
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
name|current_subject
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|current_subject
argument_list|)
operator|!=
name|first_char
condition|)
name|current_subject
operator|++
expr_stmt|;
block|}
comment|/* Or to just after a linebreak for a multiline match if possible */
elseif|else
if|if
condition|(
name|startline
condition|)
block|{
if|if
condition|(
name|current_subject
operator|>
name|md
operator|->
name|start_subject
operator|+
name|start_offset
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
while|while
condition|(
name|current_subject
operator|<
name|end_subject
operator|&&
operator|!
name|WAS_NEWLINE
argument_list|(
name|current_subject
argument_list|)
condition|)
block|{
name|current_subject
operator|++
expr_stmt|;
name|ACROSSCHAR
argument_list|(
name|current_subject
operator|<
name|end_subject
argument_list|,
operator|*
name|current_subject
argument_list|,
name|current_subject
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
while|while
condition|(
name|current_subject
operator|<
name|end_subject
operator|&&
operator|!
name|WAS_NEWLINE
argument_list|(
name|current_subject
argument_list|)
condition|)
name|current_subject
operator|++
expr_stmt|;
comment|/* If we have just passed a CR and the newline option is ANY or           ANYCRLF, and we are now at a LF, advance the match position by one           more character. */
if|if
condition|(
name|UCHAR21TEST
argument_list|(
name|current_subject
operator|-
literal|1
argument_list|)
operator|==
name|CHAR_CR
operator|&&
operator|(
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
operator|)
operator|&&
name|current_subject
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|current_subject
argument_list|)
operator|==
name|CHAR_NL
condition|)
name|current_subject
operator|++
expr_stmt|;
block|}
block|}
comment|/* Advance to a non-unique first pcre_uchar after study */
elseif|else
if|if
condition|(
name|start_bits
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|current_subject
operator|<
name|end_subject
condition|)
block|{
specifier|register
name|pcre_uint32
name|c
init|=
name|UCHAR21TEST
argument_list|(
name|current_subject
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILE_PCRE8
if|if
condition|(
name|c
operator|>
literal|255
condition|)
name|c
operator|=
literal|255
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|start_bits
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|current_subject
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Restore fudged end_subject */
name|end_subject
operator|=
name|save_end_subject
expr_stmt|;
comment|/* The following two optimizations are disabled for partial matching or if     disabling is explicitly requested (and of course, by the test above, this     code is not obeyed when restarting after a partial match). */
if|if
condition|(
operator|(
operator|(
name|options
operator||
name|re
operator|->
name|options
operator|)
operator|&
name|PCRE_NO_START_OPTIMIZE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|options
operator|&
operator|(
name|PCRE_PARTIAL_HARD
operator||
name|PCRE_PARTIAL_SOFT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If the pattern was studied, a minimum subject length may be set. This       is a lower bound; no actual string of that length may actually match the       pattern. Although the value is, strictly, in characters, we treat it as       in pcre_uchar units to avoid spending too much time in this optimization.       */
if|if
condition|(
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MINLEN
operator|)
operator|!=
literal|0
operator|&&
call|(
name|pcre_uint32
call|)
argument_list|(
name|end_subject
operator|-
name|current_subject
argument_list|)
operator|<
name|study
operator|->
name|minlength
condition|)
return|return
name|PCRE_ERROR_NOMATCH
return|;
comment|/* If req_char is set, we know that that pcre_uchar must appear in the       subject for the match to succeed. If the first pcre_uchar is set,       req_char must be later in the subject; otherwise the test starts at the       match point. This optimization can save a huge amount of work in patterns       with nested unlimited repeats that aren't going to match. Writing       separate code for cased/caseless versions makes it go faster, as does       using an autoincrement and backing off on a match.        HOWEVER: when the subject string is very, very long, searching to its end       can take a long time, and give bad performance on quite ordinary       patterns. This showed up when somebody was matching /^C/ on a 32-megabyte       string... so we don't do this when the string is sufficiently long. */
if|if
condition|(
name|has_req_char
operator|&&
name|end_subject
operator|-
name|current_subject
operator|<
name|REQ_BYTE_MAX
condition|)
block|{
specifier|register
name|PCRE_PUCHAR
name|p
init|=
name|current_subject
operator|+
operator|(
name|has_first_char
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
comment|/* We don't need to repeat the search if we haven't yet reached the         place we found it at last time. */
if|if
condition|(
name|p
operator|>
name|req_char_ptr
condition|)
block|{
if|if
condition|(
name|req_char
operator|!=
name|req_char2
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end_subject
condition|)
block|{
specifier|register
name|pcre_uint32
name|pp
init|=
name|UCHAR21INCTEST
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp
operator|==
name|req_char
operator|||
name|pp
operator|==
name|req_char2
condition|)
block|{
name|p
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|<
name|end_subject
condition|)
block|{
if|if
condition|(
name|UCHAR21INCTEST
argument_list|(
name|p
argument_list|)
operator|==
name|req_char
condition|)
block|{
name|p
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we can't find the required pcre_uchar, break the matching loop,           which will cause a return or PCRE_ERROR_NOMATCH. */
if|if
condition|(
name|p
operator|>=
name|end_subject
condition|)
break|break;
comment|/* If we have found the required pcre_uchar, save the point where we           found it, so that we don't search again next time round the loop if           the start hasn't passed this point yet. */
name|req_char_ptr
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* End of optimizations that are done when not restarting */
comment|/* OK, now we can do the business */
name|md
operator|->
name|start_used_ptr
operator|=
name|current_subject
expr_stmt|;
name|md
operator|->
name|recursive
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
name|internal_dfa_exec
argument_list|(
name|md
argument_list|,
comment|/* fixed match data */
name|md
operator|->
name|start_code
argument_list|,
comment|/* this subexpression's code */
name|current_subject
argument_list|,
comment|/* where we currently are */
name|start_offset
argument_list|,
comment|/* start offset in subject */
name|offsets
argument_list|,
comment|/* offset vector */
name|offsetcount
argument_list|,
comment|/* size of same */
name|workspace
argument_list|,
comment|/* workspace vector */
name|wscount
argument_list|,
comment|/* size of same */
literal|0
argument_list|)
expr_stmt|;
comment|/* function recurse level */
comment|/* Anything other than "no match" means we are done, always; otherwise, carry   on only if not anchored. */
if|if
condition|(
name|rc
operator|!=
name|PCRE_ERROR_NOMATCH
operator|||
name|anchored
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|PCRE_ERROR_PARTIAL
operator|&&
name|offsetcount
operator|>=
literal|2
condition|)
block|{
name|offsets
index|[
literal|0
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|md
operator|->
name|start_used_ptr
operator|-
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|1
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|end_subject
operator|-
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetcount
operator|>
literal|2
condition|)
name|offsets
index|[
literal|2
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|current_subject
operator|-
operator|(
name|PCRE_PUCHAR
operator|)
name|subject
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
comment|/* Advance to the next subject character unless we are at the end of a line   and firstline is set. */
if|if
condition|(
name|firstline
operator|&&
name|IS_NEWLINE
argument_list|(
name|current_subject
argument_list|)
condition|)
break|break;
name|current_subject
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|ACROSSCHAR
argument_list|(
name|current_subject
operator|<
name|end_subject
argument_list|,
operator|*
name|current_subject
argument_list|,
name|current_subject
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|current_subject
operator|>
name|end_subject
condition|)
break|break;
comment|/* If we have just passed a CR and we are now at a LF, and the pattern does   not contain any explicit matches for \r or \n, and the newline option is CRLF   or ANY or ANYCRLF, advance the match position by one more character. */
if|if
condition|(
name|UCHAR21TEST
argument_list|(
name|current_subject
operator|-
literal|1
argument_list|)
operator|==
name|CHAR_CR
operator|&&
name|current_subject
operator|<
name|end_subject
operator|&&
name|UCHAR21TEST
argument_list|(
name|current_subject
argument_list|)
operator|==
name|CHAR_NL
operator|&&
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_HASCRORLF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANY
operator|||
name|md
operator|->
name|nltype
operator|==
name|NLTYPE_ANYCRLF
operator|||
name|md
operator|->
name|nllen
operator|==
literal|2
operator|)
condition|)
name|current_subject
operator|++
expr_stmt|;
block|}
comment|/* "Bumpalong" loop */
return|return
name|PCRE_ERROR_NOMATCH
return|;
block|}
end_decl_stmt
begin_comment
comment|/* End of pcre_dfa_exec.c */
end_comment
end_unit
