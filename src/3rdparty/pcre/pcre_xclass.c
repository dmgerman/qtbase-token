begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2012 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains an internal function that is used to match an extended class. It is used by both pcre_exec() and pcre_def_exec(). */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_comment
comment|/************************************************* *       Match character against an XCLASS        * *************************************************/
end_comment
begin_comment
comment|/* This function is called to match a character against an extended class that might contain values> 255 and/or Unicode properties.  Arguments:   c           the character   data        points to the flag byte of the XCLASS data  Returns:      TRUE if character matches, else FALSE */
end_comment
begin_function
name|BOOL
DECL|function|xclass
name|PRIV
function|(
name|xclass
function|)
parameter_list|(
name|int
name|c
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|data
parameter_list|,
name|BOOL
name|utf
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|BOOL
name|negated
init|=
operator|(
operator|*
name|data
operator|&
name|XCL_NOT
operator|)
operator|!=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|utf
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
comment|/* In 8 bit mode, this must always be TRUE. Help the compiler to know that. */
name|utf
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* Character values< 256 are matched against a bitmap, if one is present. If not, we still carry on, because there may be ranges that start below 256 in the additional data. */
if|if
condition|(
name|c
operator|<
literal|256
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|data
operator|&
name|XCL_MAP
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|pcre_uint8
operator|*
operator|)
operator|(
name|data
operator|+
literal|1
operator|)
operator|)
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|!
name|negated
return|;
comment|/* char found */
block|}
comment|/* First skip the bit map if present. Then match against the list of Unicode properties or large chars or ranges that end with a large char. We won't ever encounter XCL_PROP or XCL_NOTPROP when UCP support is not compiled. */
if|if
condition|(
operator|(
operator|*
name|data
operator|++
operator|&
name|XCL_MAP
operator|)
operator|!=
literal|0
condition|)
name|data
operator|+=
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
operator|*
name|data
operator|++
operator|)
operator|!=
name|XCL_END
condition|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|XCL_SINGLE
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
block|}
else|else
endif|#
directive|endif
name|x
operator|=
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|x
condition|)
return|return
operator|!
name|negated
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|XCL_RANGE
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
name|GETCHARINC
argument_list|(
name|y
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
block|}
else|else
endif|#
directive|endif
block|{
name|x
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|y
operator|=
operator|*
name|data
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
name|x
operator|&&
name|c
operator|<=
name|y
condition|)
return|return
operator|!
name|negated
return|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
else|else
comment|/* XCL_PROP& XCL_NOTPROP */
block|{
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|PT_ANY
case|:
if|if
condition|(
name|t
operator|==
name|XCL_PROP
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_LAMP
case|:
if|if
condition|(
operator|(
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_GC
case|:
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|==
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_PC
case|:
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|==
name|prop
operator|->
name|chartype
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_SC
case|:
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|==
name|prop
operator|->
name|script
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_ALNUM
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
operator|||
name|c
operator|==
name|CHAR_HT
operator|||
name|c
operator|==
name|CHAR_NL
operator|||
name|c
operator|==
name|CHAR_FF
operator|||
name|c
operator|==
name|CHAR_CR
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
operator|||
name|c
operator|==
name|CHAR_HT
operator|||
name|c
operator|==
name|CHAR_NL
operator|||
name|c
operator|==
name|CHAR_VT
operator|||
name|c
operator|==
name|CHAR_FF
operator|||
name|c
operator|==
name|CHAR_CR
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_WORD
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
operator|)
operator|==
operator|(
name|t
operator|==
name|XCL_PROP
operator|)
condition|)
return|return
operator|!
name|negated
return|;
break|break;
comment|/* This should never occur, but compilers may mutter if there is no       default. */
default|default:
return|return
name|FALSE
return|;
block|}
name|data
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
return|return
name|negated
return|;
comment|/* char did not match */
block|}
end_function
begin_comment
comment|/* End of pcre_xclass.c */
end_comment
end_unit
