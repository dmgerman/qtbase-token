begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2013 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains an internal function that is used to match an extended class. It is used by both pcre_exec() and pcre_def_exec(). */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_comment
comment|/************************************************* *       Match character against an XCLASS        * *************************************************/
end_comment
begin_comment
comment|/* This function is called to match a character against an extended class that might contain values> 255 and/or Unicode properties.  Arguments:   c           the character   data        points to the flag byte of the XCLASS data  Returns:      TRUE if character matches, else FALSE */
end_comment
begin_function
name|BOOL
DECL|function|xclass
name|PRIV
function|(
name|xclass
function|)
parameter_list|(
name|pcre_uint32
name|c
parameter_list|,
specifier|const
name|pcre_uchar
modifier|*
name|data
parameter_list|,
name|BOOL
name|utf
parameter_list|)
block|{
name|pcre_uchar
name|t
decl_stmt|;
name|BOOL
name|negated
init|=
operator|(
operator|*
name|data
operator|&
name|XCL_NOT
operator|)
operator|!=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|utf
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPILE_PCRE8
comment|/* In 8 bit mode, this must always be TRUE. Help the compiler to know that. */
name|utf
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* Character values< 256 are matched against a bitmap, if one is present. If not, we still carry on, because there may be ranges that start below 256 in the additional data. */
if|if
condition|(
name|c
operator|<
literal|256
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|data
operator|&
name|XCL_HASPROP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|data
operator|&
name|XCL_MAP
operator|)
operator|==
literal|0
condition|)
return|return
name|negated
return|;
return|return
operator|(
operator|(
operator|(
name|pcre_uint8
operator|*
operator|)
operator|(
name|data
operator|+
literal|1
operator|)
operator|)
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|data
operator|&
name|XCL_MAP
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|pcre_uint8
operator|*
operator|)
operator|(
name|data
operator|+
literal|1
operator|)
operator|)
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|!
name|negated
return|;
comment|/* char found */
block|}
comment|/* First skip the bit map if present. Then match against the list of Unicode properties or large chars or ranges that end with a large char. We won't ever encounter XCL_PROP or XCL_NOTPROP when UCP support is not compiled. */
if|if
condition|(
operator|(
operator|*
name|data
operator|++
operator|&
name|XCL_MAP
operator|)
operator|!=
literal|0
condition|)
name|data
operator|+=
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|pcre_uchar
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
operator|*
name|data
operator|++
operator|)
operator|!=
name|XCL_END
condition|)
block|{
name|pcre_uint32
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|XCL_SINGLE
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
block|}
else|else
endif|#
directive|endif
name|x
operator|=
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|x
condition|)
return|return
operator|!
name|negated
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|XCL_RANGE
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_UTF
if|if
condition|(
name|utf
condition|)
block|{
name|GETCHARINC
argument_list|(
name|x
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
name|GETCHARINC
argument_list|(
name|y
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* macro generates multiple statements */
block|}
else|else
endif|#
directive|endif
block|{
name|x
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|y
operator|=
operator|*
name|data
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
name|x
operator|&&
name|c
operator|<=
name|y
condition|)
return|return
operator|!
name|negated
return|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_UCP
else|else
comment|/* XCL_PROP& XCL_NOTPROP */
block|{
specifier|const
name|ucd_record
modifier|*
name|prop
init|=
name|GET_UCD
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|BOOL
name|isprop
init|=
name|t
operator|==
name|XCL_PROP
decl_stmt|;
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|PT_ANY
case|:
if|if
condition|(
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_LAMP
case|:
if|if
condition|(
operator|(
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lu
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Ll
operator|||
name|prop
operator|->
name|chartype
operator|==
name|ucp_Lt
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_GC
case|:
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|==
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_PC
case|:
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|==
name|prop
operator|->
name|chartype
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_SC
case|:
if|if
condition|(
operator|(
name|data
index|[
literal|1
index|]
operator|==
name|prop
operator|->
name|script
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_ALNUM
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
comment|/* Perl space used to exclude VT, but from Perl 5.18 it is included,       which means that Perl space and POSIX space are now identical. PCRE       was changed at release 8.34. */
case|case
name|PT_SPACE
case|:
comment|/* Perl space */
case|case
name|PT_PXSPACE
case|:
comment|/* POSIX space */
switch|switch
condition|(
name|c
condition|)
block|{
name|HSPACE_CASES
label|:
name|VSPACE_CASES
label|:
if|if
condition|(
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
default|default:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_Z
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
block|}
break|break;
case|case
name|PT_WORD
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_L
operator|||
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_N
operator|||
name|c
operator|==
name|CHAR_UNDERSCORE
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
case|case
name|PT_UCNC
case|:
if|if
condition|(
name|c
operator|<
literal|0xa0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
name|CHAR_DOLLAR_SIGN
operator|||
name|c
operator|==
name|CHAR_COMMERCIAL_AT
operator|||
name|c
operator|==
name|CHAR_GRAVE_ACCENT
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|<
literal|0xd800
operator|||
name|c
operator|>
literal|0xdfff
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
block|}
break|break;
comment|/* The following three properties can occur only in an XCLASS, as there       is no \p or \P coding for them. */
comment|/* Graphic character. Implement this as not Z (space or separator) and       not C (other), except for Cf (format) with a few exceptions. This seems       to be what Perl does. The exceptional characters are:        U+061C           Arabic Letter Mark       U+180E           Mongolian Vowel Separator       U+2066 - U+2069  Various "isolate"s       */
case|case
name|PT_PXGRAPH
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|!=
name|ucp_Z
operator|&&
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|!=
name|ucp_C
operator|||
operator|(
name|prop
operator|->
name|chartype
operator|==
name|ucp_Cf
operator|&&
name|c
operator|!=
literal|0x061c
operator|&&
name|c
operator|!=
literal|0x180e
operator|&&
operator|(
name|c
operator|<
literal|0x2066
operator|||
name|c
operator|>
literal|0x2069
operator|)
operator|)
operator|)
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
comment|/* Printable character: same as graphic, with the addition of Zs, i.e.       not Zl and not Zp, and U+180E. */
case|case
name|PT_PXPRINT
case|:
if|if
condition|(
operator|(
name|prop
operator|->
name|chartype
operator|!=
name|ucp_Zl
operator|&&
name|prop
operator|->
name|chartype
operator|!=
name|ucp_Zp
operator|&&
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|!=
name|ucp_C
operator|||
operator|(
name|prop
operator|->
name|chartype
operator|==
name|ucp_Cf
operator|&&
name|c
operator|!=
literal|0x061c
operator|&&
operator|(
name|c
operator|<
literal|0x2066
operator|||
name|c
operator|>
literal|0x2069
operator|)
operator|)
operator|)
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
comment|/* Punctuation: all Unicode punctuation, plus ASCII characters that       Unicode treats as symbols rather than punctuation, for Perl       compatibility (these are $+<=>^`|~). */
case|case
name|PT_PXPUNCT
case|:
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_P
operator|||
operator|(
name|c
operator|<
literal|256
operator|&&
name|PRIV
argument_list|(
name|ucp_gentype
argument_list|)
index|[
name|prop
operator|->
name|chartype
index|]
operator|==
name|ucp_S
operator|)
operator|)
operator|==
name|isprop
condition|)
return|return
operator|!
name|negated
return|;
break|break;
comment|/* This should never occur, but compilers may mutter if there is no       default. */
default|default:
return|return
name|FALSE
return|;
block|}
name|data
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SUPPORT_UCP */
block|}
return|return
name|negated
return|;
comment|/* char did not match */
block|}
end_function
begin_comment
comment|/* End of pcre_xclass.c */
end_comment
end_unit
