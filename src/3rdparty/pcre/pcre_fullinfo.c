begin_unit
begin_comment
comment|/************************************************* *      Perl-Compatible Regular Expressions       * *************************************************/
end_comment
begin_comment
comment|/* PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.                         Written by Philip Hazel            Copyright (c) 1997-2013 University of Cambridge  ----------------------------------------------------------------------------- Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.      * Neither the name of the University of Cambridge nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* This module contains the external function pcre_fullinfo(), which returns information about a compiled pattern. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PCRE_HAVE_CONFIG_H
end_ifdef
begin_include
include|#
directive|include
file|"config.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"pcre_internal.h"
end_include
begin_comment
comment|/************************************************* *        Return info about compiled pattern      * *************************************************/
end_comment
begin_comment
comment|/* This is a newer "info" function which has an extensible interface so that additional items can be added compatibly.  Arguments:   argument_re      points to compiled code   extra_data       points extra data, or NULL   what             what information is required   where            where to put the information  Returns:           0 if data returned, negative on error */
end_comment
begin_if
if|#
directive|if
name|defined
name|COMPILE_PCRE8
end_if
begin_decl_stmt
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
DECL|function|pcre_fullinfo
name|pcre_fullinfo
argument_list|(
specifier|const
name|pcre
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre_extra
operator|*
name|extra_data
argument_list|,
name|int
name|what
argument_list|,
name|void
operator|*
name|where
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE16
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre16_fullinfo
argument_list|(
specifier|const
name|pcre16
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre16_extra
operator|*
name|extra_data
argument_list|,
name|int
name|what
argument_list|,
name|void
operator|*
name|where
argument_list|)
elif|#
directive|elif
name|defined
name|COMPILE_PCRE32
name|PCRE_EXP_DEFN
name|int
name|PCRE_CALL_CONVENTION
name|pcre32_fullinfo
argument_list|(
specifier|const
name|pcre32
operator|*
name|argument_re
argument_list|,
specifier|const
name|pcre32_extra
operator|*
name|extra_data
argument_list|,
name|int
name|what
argument_list|,
name|void
operator|*
name|where
argument_list|)
endif|#
directive|endif
block|{
specifier|const
name|REAL_PCRE
modifier|*
name|re
init|=
operator|(
specifier|const
name|REAL_PCRE
operator|*
operator|)
name|argument_re
decl_stmt|;
specifier|const
name|pcre_study_data
modifier|*
name|study
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|re
operator|==
name|NULL
operator|||
name|where
operator|==
name|NULL
condition|)
return|return
name|PCRE_ERROR_NULL
return|;
if|if
condition|(
name|extra_data
operator|!=
name|NULL
operator|&&
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_STUDY_DATA
operator|)
operator|!=
literal|0
condition|)
name|study
operator|=
operator|(
specifier|const
name|pcre_study_data
operator|*
operator|)
name|extra_data
operator|->
name|study_data
expr_stmt|;
comment|/* Check that the first field in the block is the magic number. If it is not, return with PCRE_ERROR_BADMAGIC. However, if the magic number is equal to REVERSED_MAGIC_NUMBER we return with PCRE_ERROR_BADENDIANNESS, which means that the pattern is likely compiled with different endianness. */
if|if
condition|(
name|re
operator|->
name|magic_number
operator|!=
name|MAGIC_NUMBER
condition|)
return|return
name|re
operator|->
name|magic_number
operator|==
name|REVERSED_MAGIC_NUMBER
condition|?
name|PCRE_ERROR_BADENDIANNESS
else|:
name|PCRE_ERROR_BADMAGIC
return|;
comment|/* Check that this pattern was compiled in the correct bit mode */
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_MODE
operator|)
operator|==
literal|0
condition|)
return|return
name|PCRE_ERROR_BADMODE
return|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|PCRE_INFO_OPTIONS
case|:
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|options
operator|&
name|PUBLIC_COMPILE_OPTIONS
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_SIZE
case|:
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_STUDYSIZE
case|:
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|study
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|study
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_JITSIZE
case|:
ifdef|#
directive|ifdef
name|SUPPORT_JIT
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|extra_data
operator|!=
name|NULL
operator|&&
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|)
operator|!=
literal|0
operator|&&
name|extra_data
operator|->
name|executable_jit
operator|!=
name|NULL
operator|)
condition|?
name|PRIV
argument_list|(
name|jit_get_size
argument_list|)
argument_list|(
name|extra_data
operator|->
name|executable_jit
argument_list|)
else|:
literal|0
expr_stmt|;
else|#
directive|else
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|where
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|PCRE_INFO_CAPTURECOUNT
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|top_bracket
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_BACKREFMAX
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|top_backref
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_FIRSTBYTE
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
operator|)
condition|?
operator|(
name|int
operator|)
name|re
operator|->
name|first_char
else|:
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|!=
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|-
literal|2
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_FIRSTCHARACTER
case|:
operator|*
operator|(
operator|(
name|pcre_uint32
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
condition|?
name|re
operator|->
name|first_char
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_FIRSTCHARACTERFLAGS
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_FIRSTSET
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_STARTLINE
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
break|break;
comment|/* Make sure we pass back the pointer to the bit vector in the external   block, not the internal copy (with flipped integer fields). */
case|case
name|PCRE_INFO_FIRSTTABLE
case|:
operator|*
operator|(
operator|(
specifier|const
name|pcre_uint8
operator|*
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MAPPED
operator|)
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
specifier|const
name|pcre_study_data
operator|*
operator|)
name|extra_data
operator|->
name|study_data
operator|)
operator|->
name|start_bits
else|:
name|NULL
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_MINLENGTH
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|study
operator|!=
name|NULL
operator|&&
operator|(
name|study
operator|->
name|flags
operator|&
name|PCRE_STUDY_MINLEN
operator|)
operator|!=
literal|0
operator|)
condition|?
call|(
name|int
call|)
argument_list|(
name|study
operator|->
name|minlength
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_JIT
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
name|extra_data
operator|!=
name|NULL
operator|&&
operator|(
name|extra_data
operator|->
name|flags
operator|&
name|PCRE_EXTRA_EXECUTABLE_JIT
operator|)
operator|!=
literal|0
operator|&&
name|extra_data
operator|->
name|executable_jit
operator|!=
name|NULL
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_LASTLITERAL
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
operator|)
condition|?
operator|(
name|int
operator|)
name|re
operator|->
name|req_char
else|:
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_REQUIREDCHAR
case|:
operator|*
operator|(
operator|(
name|pcre_uint32
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
operator|)
condition|?
name|re
operator|->
name|req_char
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_REQUIREDCHARFLAGS
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_REQCHSET
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_NAMEENTRYSIZE
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|name_entry_size
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_NAMECOUNT
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|name_count
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_NAMETABLE
case|:
operator|*
operator|(
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
specifier|const
name|pcre_uchar
operator|*
operator|)
name|re
operator|+
name|re
operator|->
name|name_table_offset
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_DEFAULT_TABLES
case|:
operator|*
operator|(
operator|(
specifier|const
name|pcre_uint8
operator|*
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
specifier|const
name|pcre_uint8
operator|*
operator|)
operator|(
name|PRIV
argument_list|(
name|default_tables
argument_list|)
operator|)
expr_stmt|;
break|break;
comment|/* From release 8.00 this will always return TRUE because NOPARTIAL is   no longer ever set (the restrictions have been removed). */
case|case
name|PCRE_INFO_OKPARTIAL
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_NOPARTIAL
operator|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_JCHANGED
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_JCHANGED
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_HASCRORLF
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_HASCRORLF
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_MAXLOOKBEHIND
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|max_lookbehind
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_MATCHLIMIT
case|:
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_MLSET
operator|)
operator|==
literal|0
condition|)
return|return
name|PCRE_ERROR_UNSET
return|;
operator|*
operator|(
operator|(
name|pcre_uint32
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|limit_match
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_RECURSIONLIMIT
case|:
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_RLSET
operator|)
operator|==
literal|0
condition|)
return|return
name|PCRE_ERROR_UNSET
return|;
operator|*
operator|(
operator|(
name|pcre_uint32
operator|*
operator|)
name|where
operator|)
operator|=
name|re
operator|->
name|limit_recursion
expr_stmt|;
break|break;
case|case
name|PCRE_INFO_MATCH_EMPTY
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|where
operator|)
operator|=
operator|(
name|re
operator|->
name|flags
operator|&
name|PCRE_MATCH_EMPTY
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|PCRE_ERROR_BADOPTION
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt
begin_comment
comment|/* End of pcre_fullinfo.c */
end_comment
end_unit
