begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_include
include|#
directive|include
file|"keymap.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_function
name|bool
DECL|function|LookupString
name|LookupString
parameter_list|(
specifier|const
name|LookupEntry
name|tab
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
modifier|*
name|value_rtrn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|string
condition|)
return|return
name|false
return|;
for|for
control|(
specifier|const
name|LookupEntry
modifier|*
name|entry
init|=
name|tab
init|;
name|entry
operator|->
name|name
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|istreq
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|string
argument_list|)
condition|)
block|{
operator|*
name|value_rtrn
operator|=
name|entry
operator|->
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|LookupValue
name|LookupValue
parameter_list|(
specifier|const
name|LookupEntry
name|tab
index|[]
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
for|for
control|(
specifier|const
name|LookupEntry
modifier|*
name|entry
init|=
name|tab
init|;
name|entry
operator|->
name|name
condition|;
name|entry
operator|++
control|)
if|if
condition|(
name|entry
operator|->
name|value
operator|==
name|value
condition|)
return|return
name|entry
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ctrlMaskNames
specifier|const
name|LookupEntry
name|ctrlMaskNames
index|[]
init|=
block|{
block|{
literal|"RepeatKeys"
block|,
name|CONTROL_REPEAT
block|}
block|,
block|{
literal|"Repeat"
block|,
name|CONTROL_REPEAT
block|}
block|,
block|{
literal|"AutoRepeat"
block|,
name|CONTROL_REPEAT
block|}
block|,
block|{
literal|"SlowKeys"
block|,
name|CONTROL_SLOW
block|}
block|,
block|{
literal|"BounceKeys"
block|,
name|CONTROL_DEBOUNCE
block|}
block|,
block|{
literal|"StickyKeys"
block|,
name|CONTROL_STICKY
block|}
block|,
block|{
literal|"MouseKeys"
block|,
name|CONTROL_MOUSEKEYS
block|}
block|,
block|{
literal|"MouseKeysAccel"
block|,
name|CONTROL_MOUSEKEYS_ACCEL
block|}
block|,
block|{
literal|"AccessXKeys"
block|,
name|CONTROL_AX
block|}
block|,
block|{
literal|"AccessXTimeout"
block|,
name|CONTROL_AX_TIMEOUT
block|}
block|,
block|{
literal|"AccessXFeedback"
block|,
name|CONTROL_AX_FEEDBACK
block|}
block|,
block|{
literal|"AudibleBell"
block|,
name|CONTROL_BELL
block|}
block|,
block|{
literal|"IgnoreGroupLock"
block|,
name|CONTROL_IGNORE_GROUP_LOCK
block|}
block|,
block|{
literal|"all"
block|,
name|CONTROL_ALL
block|}
block|,
block|{
literal|"none"
block|,
literal|0
block|}
block|,
block|{
literal|"Overlay1"
block|,
literal|0
block|}
block|,
block|{
literal|"Overlay2"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|modComponentMaskNames
specifier|const
name|LookupEntry
name|modComponentMaskNames
index|[]
init|=
block|{
block|{
literal|"base"
block|,
name|XKB_STATE_MODS_DEPRESSED
block|}
block|,
block|{
literal|"latched"
block|,
name|XKB_STATE_MODS_LATCHED
block|}
block|,
block|{
literal|"locked"
block|,
name|XKB_STATE_MODS_LOCKED
block|}
block|,
block|{
literal|"effective"
block|,
name|XKB_STATE_MODS_EFFECTIVE
block|}
block|,
block|{
literal|"compat"
block|,
name|XKB_STATE_MODS_EFFECTIVE
block|}
block|,
block|{
literal|"any"
block|,
name|XKB_STATE_MODS_EFFECTIVE
block|}
block|,
block|{
literal|"none"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|groupComponentMaskNames
specifier|const
name|LookupEntry
name|groupComponentMaskNames
index|[]
init|=
block|{
block|{
literal|"base"
block|,
name|XKB_STATE_LAYOUT_DEPRESSED
block|}
block|,
block|{
literal|"latched"
block|,
name|XKB_STATE_LAYOUT_LATCHED
block|}
block|,
block|{
literal|"locked"
block|,
name|XKB_STATE_LAYOUT_LOCKED
block|}
block|,
block|{
literal|"effective"
block|,
name|XKB_STATE_LAYOUT_EFFECTIVE
block|}
block|,
block|{
literal|"any"
block|,
name|XKB_STATE_LAYOUT_EFFECTIVE
block|}
block|,
block|{
literal|"none"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|groupMaskNames
specifier|const
name|LookupEntry
name|groupMaskNames
index|[]
init|=
block|{
block|{
literal|"Group1"
block|,
literal|0x01
block|}
block|,
block|{
literal|"Group2"
block|,
literal|0x02
block|}
block|,
block|{
literal|"Group3"
block|,
literal|0x04
block|}
block|,
block|{
literal|"Group4"
block|,
literal|0x08
block|}
block|,
block|{
literal|"Group5"
block|,
literal|0x10
block|}
block|,
block|{
literal|"Group6"
block|,
literal|0x20
block|}
block|,
block|{
literal|"Group7"
block|,
literal|0x40
block|}
block|,
block|{
literal|"Group8"
block|,
literal|0x80
block|}
block|,
block|{
literal|"none"
block|,
literal|0x00
block|}
block|,
block|{
literal|"all"
block|,
literal|0xff
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|groupNames
specifier|const
name|LookupEntry
name|groupNames
index|[]
init|=
block|{
block|{
literal|"Group1"
block|,
literal|1
block|}
block|,
block|{
literal|"Group2"
block|,
literal|2
block|}
block|,
block|{
literal|"Group3"
block|,
literal|3
block|}
block|,
block|{
literal|"Group4"
block|,
literal|4
block|}
block|,
block|{
literal|"Group5"
block|,
literal|5
block|}
block|,
block|{
literal|"Group6"
block|,
literal|6
block|}
block|,
block|{
literal|"Group7"
block|,
literal|7
block|}
block|,
block|{
literal|"Group8"
block|,
literal|8
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|levelNames
specifier|const
name|LookupEntry
name|levelNames
index|[]
init|=
block|{
block|{
literal|"Level1"
block|,
literal|1
block|}
block|,
block|{
literal|"Level2"
block|,
literal|2
block|}
block|,
block|{
literal|"Level3"
block|,
literal|3
block|}
block|,
block|{
literal|"Level4"
block|,
literal|4
block|}
block|,
block|{
literal|"Level5"
block|,
literal|5
block|}
block|,
block|{
literal|"Level6"
block|,
literal|6
block|}
block|,
block|{
literal|"Level7"
block|,
literal|7
block|}
block|,
block|{
literal|"Level8"
block|,
literal|8
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|buttonNames
specifier|const
name|LookupEntry
name|buttonNames
index|[]
init|=
block|{
block|{
literal|"Button1"
block|,
literal|1
block|}
block|,
block|{
literal|"Button2"
block|,
literal|2
block|}
block|,
block|{
literal|"Button3"
block|,
literal|3
block|}
block|,
block|{
literal|"Button4"
block|,
literal|4
block|}
block|,
block|{
literal|"Button5"
block|,
literal|5
block|}
block|,
block|{
literal|"default"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|useModMapValueNames
specifier|const
name|LookupEntry
name|useModMapValueNames
index|[]
init|=
block|{
block|{
literal|"LevelOne"
block|,
literal|1
block|}
block|,
block|{
literal|"Level1"
block|,
literal|1
block|}
block|,
block|{
literal|"AnyLevel"
block|,
literal|0
block|}
block|,
block|{
literal|"any"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|actionTypeNames
specifier|const
name|LookupEntry
name|actionTypeNames
index|[]
init|=
block|{
block|{
literal|"NoAction"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"SetMods"
block|,
name|ACTION_TYPE_MOD_SET
block|}
block|,
block|{
literal|"LatchMods"
block|,
name|ACTION_TYPE_MOD_LATCH
block|}
block|,
block|{
literal|"LockMods"
block|,
name|ACTION_TYPE_MOD_LOCK
block|}
block|,
block|{
literal|"SetGroup"
block|,
name|ACTION_TYPE_GROUP_SET
block|}
block|,
block|{
literal|"LatchGroup"
block|,
name|ACTION_TYPE_GROUP_LATCH
block|}
block|,
block|{
literal|"LockGroup"
block|,
name|ACTION_TYPE_GROUP_LOCK
block|}
block|,
block|{
literal|"MovePtr"
block|,
name|ACTION_TYPE_PTR_MOVE
block|}
block|,
block|{
literal|"MovePointer"
block|,
name|ACTION_TYPE_PTR_MOVE
block|}
block|,
block|{
literal|"PtrBtn"
block|,
name|ACTION_TYPE_PTR_BUTTON
block|}
block|,
block|{
literal|"PointerButton"
block|,
name|ACTION_TYPE_PTR_BUTTON
block|}
block|,
block|{
literal|"LockPtrBtn"
block|,
name|ACTION_TYPE_PTR_LOCK
block|}
block|,
block|{
literal|"LockPtrButton"
block|,
name|ACTION_TYPE_PTR_LOCK
block|}
block|,
block|{
literal|"LockPointerButton"
block|,
name|ACTION_TYPE_PTR_LOCK
block|}
block|,
block|{
literal|"LockPointerBtn"
block|,
name|ACTION_TYPE_PTR_LOCK
block|}
block|,
block|{
literal|"SetPtrDflt"
block|,
name|ACTION_TYPE_PTR_DEFAULT
block|}
block|,
block|{
literal|"SetPointerDefault"
block|,
name|ACTION_TYPE_PTR_DEFAULT
block|}
block|,
block|{
literal|"Terminate"
block|,
name|ACTION_TYPE_TERMINATE
block|}
block|,
block|{
literal|"TerminateServer"
block|,
name|ACTION_TYPE_TERMINATE
block|}
block|,
block|{
literal|"SwitchScreen"
block|,
name|ACTION_TYPE_SWITCH_VT
block|}
block|,
block|{
literal|"SetControls"
block|,
name|ACTION_TYPE_CTRL_SET
block|}
block|,
block|{
literal|"LockControls"
block|,
name|ACTION_TYPE_CTRL_LOCK
block|}
block|,
block|{
literal|"Private"
block|,
name|ACTION_TYPE_PRIVATE
block|}
block|,
comment|/* deprecated actions below here - unused */
block|{
literal|"RedirectKey"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"Redirect"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"ISOLock"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"ActionMessage"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"MessageAction"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"Message"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DeviceBtn"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DevBtn"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DevButton"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DeviceButton"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"LockDeviceBtn"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"LockDevBtn"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"LockDevButton"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"LockDeviceButton"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DeviceValuator"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DevVal"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DeviceVal"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
literal|"DevValuator"
block|,
name|ACTION_TYPE_NONE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|symInterpretMatchMaskNames
specifier|const
name|LookupEntry
name|symInterpretMatchMaskNames
index|[]
init|=
block|{
block|{
literal|"NoneOf"
block|,
name|MATCH_NONE
block|}
block|,
block|{
literal|"AnyOfOrNone"
block|,
name|MATCH_ANY_OR_NONE
block|}
block|,
block|{
literal|"AnyOf"
block|,
name|MATCH_ANY
block|}
block|,
block|{
literal|"AllOf"
block|,
name|MATCH_ALL
block|}
block|,
block|{
literal|"Exactly"
block|,
name|MATCH_EXACTLY
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_function
specifier|const
name|char
modifier|*
DECL|function|ModIndexText
name|ModIndexText
parameter_list|(
specifier|const
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_mod_index_t
name|ndx
parameter_list|)
block|{
if|if
condition|(
name|ndx
operator|==
name|XKB_MOD_INVALID
condition|)
return|return
literal|"none"
return|;
if|if
condition|(
name|ndx
operator|>=
name|darray_size
argument_list|(
name|keymap
operator|->
name|mods
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|darray_item
argument_list|(
name|keymap
operator|->
name|mods
argument_list|,
name|ndx
argument_list|)
operator|.
name|name
argument_list|)
return|;
block|}
end_function
begin_function
name|xkb_mod_index_t
DECL|function|ModNameToIndex
name|ModNameToIndex
parameter_list|(
specifier|const
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_atom_t
name|name
parameter_list|,
name|enum
name|mod_type
name|type
parameter_list|)
block|{
name|xkb_mod_index_t
name|i
decl_stmt|;
specifier|const
name|struct
name|xkb_mod
modifier|*
name|mod
decl_stmt|;
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|mod
argument_list|,
argument|keymap->mods
argument_list|)
if|if
condition|(
operator|(
name|mod
operator|->
name|type
operator|&
name|type
operator|)
operator|&&
name|name
operator|==
name|mod
operator|->
name|name
condition|)
return|return
name|i
return|;
return|return
name|XKB_MOD_INVALID
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|ActionTypeText
name|ActionTypeText
parameter_list|(
name|enum
name|xkb_action_type
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|LookupValue
argument_list|(
name|actionTypeNames
argument_list|,
name|type
argument_list|)
decl_stmt|;
return|return
name|name
condition|?
name|name
else|:
literal|"Private"
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|KeysymText
name|KeysymText
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|xkb_keysym_t
name|sym
parameter_list|)
block|{
name|char
modifier|*
name|buffer
init|=
name|xkb_context_get_buffer
argument_list|(
name|ctx
argument_list|,
literal|64
argument_list|)
decl_stmt|;
name|xkb_keysym_get_name
argument_list|(
name|sym
argument_list|,
name|buffer
argument_list|,
literal|64
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|KeyNameText
name|KeyNameText
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|xkb_atom_t
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|strlen_safe
argument_list|(
name|sname
argument_list|)
operator|+
literal|3
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xkb_context_get_buffer
argument_list|(
name|ctx
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"<%s>"
argument_list|,
name|strempty
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|SIMatchText
name|SIMatchText
parameter_list|(
name|enum
name|xkb_match_operation
name|type
parameter_list|)
block|{
return|return
name|LookupValue
argument_list|(
name|symInterpretMatchMaskNames
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|ModMaskText
name|ModMaskText
parameter_list|(
specifier|const
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_mod_mask_t
name|mask
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|xkb_mod_index_t
name|i
decl_stmt|;
specifier|const
name|struct
name|xkb_mod
modifier|*
name|mod
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
literal|"none"
return|;
if|if
condition|(
name|mask
operator|==
name|MOD_REAL_MASK_ALL
condition|)
return|return
literal|"all"
return|;
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|mod
argument_list|,
argument|keymap->mods
argument_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
name|ret
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|pos
argument_list|,
literal|"%s%s"
argument_list|,
name|pos
operator|==
literal|0
condition|?
literal|""
else|:
literal|"+"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|mod
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
operator|||
name|pos
operator|+
name|ret
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
else|else
name|pos
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|strcpy
argument_list|(
name|xkb_context_get_buffer
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|LedStateMaskText
name|LedStateMaskText
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_state_component
name|mask
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
literal|"0"
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
name|mask
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|i
operator|)
expr_stmt|;
name|ret
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|pos
argument_list|,
literal|"%s%s"
argument_list|,
name|pos
operator|==
literal|0
condition|?
literal|""
else|:
literal|"+"
argument_list|,
name|LookupValue
argument_list|(
name|modComponentMaskNames
argument_list|,
literal|1u
operator|<<
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
operator|||
name|pos
operator|+
name|ret
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
else|else
name|pos
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|strcpy
argument_list|(
name|xkb_context_get_buffer
argument_list|(
name|ctx
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|ControlMaskText
name|ControlMaskText
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_action_controls
name|mask
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
literal|"none"
return|;
if|if
condition|(
name|mask
operator|==
name|CONTROL_ALL
condition|)
return|return
literal|"all"
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
name|mask
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|i
operator|)
expr_stmt|;
name|ret
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|pos
argument_list|,
literal|"%s%s"
argument_list|,
name|pos
operator|==
literal|0
condition|?
literal|""
else|:
literal|"+"
argument_list|,
name|LookupValue
argument_list|(
name|ctrlMaskNames
argument_list|,
literal|1u
operator|<<
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
operator|||
name|pos
operator|+
name|ret
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
else|else
name|pos
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|strcpy
argument_list|(
name|xkb_context_get_buffer
argument_list|(
name|ctx
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function
end_unit
