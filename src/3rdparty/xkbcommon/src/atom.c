begin_unit
begin_comment
comment|/***********************************************************  * Copyright 1987, 1998  The Open Group  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation.  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN  * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Except as contained in this notice, the name of The Open Group shall not be  * used in advertising or otherwise to promote the sale, use or other dealings  * in this Software without prior written authorization from The Open Group.  *  *  * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.  *  *                      All Rights Reserved  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted,  * provided that the above copyright notice appear in all copies and that  * both that copyright notice and this permission notice appear in  * supporting documentation, and that the name of Digital not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  *  * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL  * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  *  ******************************************************************/
end_comment
begin_comment
comment|/************************************************************  * Copyright 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|"atom.h"
end_include
begin_struct
DECL|struct|atom_node
struct|struct
name|atom_node
block|{
DECL|member|left
DECL|member|right
name|struct
name|atom_node
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
DECL|member|atom
name|xkb_atom_t
name|atom
decl_stmt|;
DECL|member|fingerprint
name|unsigned
name|int
name|fingerprint
decl_stmt|;
DECL|member|string
name|char
modifier|*
name|string
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|atom_table
struct|struct
name|atom_table
block|{
DECL|member|root
name|struct
name|atom_node
modifier|*
name|root
decl_stmt|;
DECL|member|table
name|darray
argument_list|(
argument|struct atom_node *
argument_list|)
name|table
expr_stmt|;
block|}
struct|;
end_struct
begin_function
name|struct
name|atom_table
modifier|*
DECL|function|atom_table_new
name|atom_table_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|atom_table
modifier|*
name|table
decl_stmt|;
name|table
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
name|NULL
return|;
name|darray_init
argument_list|(
name|table
operator|->
name|table
argument_list|)
expr_stmt|;
name|darray_growalloc
argument_list|(
name|table
operator|->
name|table
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|table
operator|->
name|table
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|free_atom
name|free_atom
parameter_list|(
name|struct
name|atom_node
modifier|*
name|patom
parameter_list|)
block|{
if|if
condition|(
operator|!
name|patom
condition|)
return|return;
name|free_atom
argument_list|(
name|patom
operator|->
name|left
argument_list|)
expr_stmt|;
name|free_atom
argument_list|(
name|patom
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patom
operator|->
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patom
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|atom_table_free
name|atom_table_free
parameter_list|(
name|struct
name|atom_table
modifier|*
name|table
parameter_list|)
block|{
if|if
condition|(
operator|!
name|table
condition|)
return|return;
name|free_atom
argument_list|(
name|table
operator|->
name|root
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|table
operator|->
name|table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|atom_text
name|atom_text
parameter_list|(
name|struct
name|atom_table
modifier|*
name|table
parameter_list|,
name|xkb_atom_t
name|atom
parameter_list|)
block|{
if|if
condition|(
name|atom
operator|>=
name|darray_size
argument_list|(
name|table
operator|->
name|table
argument_list|)
operator|||
name|darray_item
argument_list|(
name|table
operator|->
name|table
argument_list|,
name|atom
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|darray_item
argument_list|(
name|table
operator|->
name|table
argument_list|,
name|atom
argument_list|)
operator|->
name|string
return|;
block|}
end_function
begin_function
name|char
modifier|*
DECL|function|atom_strdup
name|atom_strdup
parameter_list|(
name|struct
name|atom_table
modifier|*
name|table
parameter_list|,
name|xkb_atom_t
name|atom
parameter_list|)
block|{
return|return
name|strdup_safe
argument_list|(
name|atom_text
argument_list|(
name|table
argument_list|,
name|atom
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|find_node_pointer
name|find_node_pointer
parameter_list|(
name|struct
name|atom_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|struct
name|atom_node
modifier|*
modifier|*
modifier|*
name|np_out
parameter_list|,
name|unsigned
name|int
modifier|*
name|fingerprint_out
parameter_list|)
block|{
name|struct
name|atom_node
modifier|*
modifier|*
name|np
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|unsigned
name|int
name|fp
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|np
operator|=
operator|&
name|table
operator|->
name|root
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|fp
operator|*
literal|27
operator|+
name|string
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|=
name|fp
operator|*
literal|27
operator|+
name|string
index|[
name|len
operator|-
literal|1
operator|-
name|i
index|]
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|np
condition|)
block|{
if|if
condition|(
name|fp
operator|<
operator|(
operator|*
name|np
operator|)
operator|->
name|fingerprint
condition|)
block|{
name|np
operator|=
operator|&
operator|(
operator|(
operator|*
name|np
operator|)
operator|->
name|left
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|>
operator|(
operator|*
name|np
operator|)
operator|->
name|fingerprint
condition|)
block|{
name|np
operator|=
operator|&
operator|(
operator|(
operator|*
name|np
operator|)
operator|->
name|right
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* now start testing the strings */
name|comp
operator|=
name|strncmp
argument_list|(
name|string
argument_list|,
operator|(
operator|*
name|np
operator|)
operator|->
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|<
literal|0
operator|||
operator|(
name|comp
operator|==
literal|0
operator|&&
name|len
operator|<
name|strlen
argument_list|(
operator|(
operator|*
name|np
operator|)
operator|->
name|string
argument_list|)
operator|)
condition|)
block|{
name|np
operator|=
operator|&
operator|(
operator|(
operator|*
name|np
operator|)
operator|->
name|left
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|>
literal|0
condition|)
block|{
name|np
operator|=
operator|&
operator|(
operator|(
operator|*
name|np
operator|)
operator|->
name|right
operator|)
expr_stmt|;
block|}
else|else
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|fingerprint_out
operator|=
name|fp
expr_stmt|;
operator|*
name|np_out
operator|=
name|np
expr_stmt|;
return|return
name|found
return|;
block|}
end_function
begin_function
name|xkb_atom_t
DECL|function|atom_lookup
name|atom_lookup
parameter_list|(
name|struct
name|atom_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|atom_node
modifier|*
modifier|*
name|np
decl_stmt|;
name|unsigned
name|int
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
return|return
name|XKB_ATOM_NONE
return|;
if|if
condition|(
operator|!
name|find_node_pointer
argument_list|(
name|table
argument_list|,
name|string
argument_list|,
operator|&
name|np
argument_list|,
operator|&
name|fp
argument_list|)
condition|)
return|return
name|XKB_ATOM_NONE
return|;
return|return
operator|(
operator|*
name|np
operator|)
operator|->
name|atom
return|;
block|}
end_function
begin_comment
comment|/*  * If steal is true, we do not strdup @string; therefore it must be  * dynamically allocated, not be free'd by the caller and not be used  * afterwards. Use to avoid some redundant allocations.  */
end_comment
begin_function
name|xkb_atom_t
DECL|function|atom_intern
name|atom_intern
parameter_list|(
name|struct
name|atom_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|bool
name|steal
parameter_list|)
block|{
name|struct
name|atom_node
modifier|*
modifier|*
name|np
decl_stmt|;
name|struct
name|atom_node
modifier|*
name|nd
decl_stmt|;
name|unsigned
name|int
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
return|return
name|XKB_ATOM_NONE
return|;
if|if
condition|(
name|find_node_pointer
argument_list|(
name|table
argument_list|,
name|string
argument_list|,
operator|&
name|np
argument_list|,
operator|&
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|steal
condition|)
name|free
argument_list|(
name|UNCONSTIFY
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|np
operator|)
operator|->
name|atom
return|;
block|}
name|nd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
return|return
name|XKB_ATOM_NONE
return|;
if|if
condition|(
name|steal
condition|)
block|{
name|nd
operator|->
name|string
operator|=
name|UNCONSTIFY
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nd
operator|->
name|string
operator|=
name|strdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|string
condition|)
block|{
name|free
argument_list|(
name|nd
argument_list|)
expr_stmt|;
return|return
name|XKB_ATOM_NONE
return|;
block|}
block|}
operator|*
name|np
operator|=
name|nd
expr_stmt|;
name|nd
operator|->
name|left
operator|=
name|nd
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|nd
operator|->
name|fingerprint
operator|=
name|fp
expr_stmt|;
name|nd
operator|->
name|atom
operator|=
name|darray_size
argument_list|(
name|table
operator|->
name|table
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|table
operator|->
name|table
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
name|nd
operator|->
name|atom
return|;
block|}
end_function
end_unit
