begin_unit
begin_comment
comment|/*  * Copyright Â© 2013 Ran Benita  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"x11-priv.h"
end_include
begin_comment
comment|/*  * References for the lonesome traveler:  * Xkb protocol specification:  *      http://www.x.org/releases/current/doc/kbproto/xkbproto.html  * The XCB xkb XML protocol file:  *      /user/share/xcb/xkb.xml  * The XCB xkb header file:  *      /usr/include/xcb/xkb.h  * The old kbproto header files:  *      /usr/include/X11/extensions/XKB{,proto,str}.h  * Xlib XKB source code:  *<libX11>/src/xkb/XKBGetMap.c (and friends)  * X server XKB protocol handling:  *<xserver>/xkb/xkb.c  * Man pages:  *      XkbGetMap(3), XkbGetCompatMap(3), etc.  */
end_comment
begin_comment
comment|/* Constants from /usr/include/X11/extensions/XKB.h */
end_comment
begin_comment
comment|/* XkbNumModifiers. */
end_comment
begin_define
DECL|macro|NUM_REAL_MODS
define|#
directive|define
name|NUM_REAL_MODS
value|8u
end_define
begin_comment
comment|/* XkbNumVirtualMods. */
end_comment
begin_define
DECL|macro|NUM_VMODS
define|#
directive|define
name|NUM_VMODS
value|16u
end_define
begin_comment
comment|/* XkbNoModifier. */
end_comment
begin_define
DECL|macro|NO_MODIFIER
define|#
directive|define
name|NO_MODIFIER
value|0xff
end_define
begin_comment
comment|/* XkbNumIndicators. */
end_comment
begin_define
DECL|macro|NUM_INDICATORS
define|#
directive|define
name|NUM_INDICATORS
value|32u
end_define
begin_comment
comment|/* XkbAllIndicatorsMask. */
end_comment
begin_define
DECL|macro|ALL_INDICATORS_MASK
define|#
directive|define
name|ALL_INDICATORS_MASK
value|0xffffffff
end_define
begin_comment
comment|/* Some macros. Not very nice but it'd be worse without them. */
end_comment
begin_comment
comment|/*  * We try not to trust the server too much and be paranoid. If we get  * something which we definitely shouldn't, we fail.  */
end_comment
begin_define
DECL|macro|STRINGIFY
define|#
directive|define
name|STRINGIFY
parameter_list|(
name|expr
parameter_list|)
value|#expr
end_define
begin_define
DECL|macro|FAIL_UNLESS
define|#
directive|define
name|FAIL_UNLESS
parameter_list|(
name|expr
parameter_list|)
value|do {                                          \     if (!(expr)) {                                                      \         log_err(keymap->ctx,                                            \                 "x11: failed to get keymap from X server: unmet condition in %s(): %s\n", \                 __func__, STRINGIFY(expr));                             \         goto fail;                                                      \     }                                                                   \ } while (0)
end_define
begin_define
DECL|macro|FAIL_IF_BAD_REPLY
define|#
directive|define
name|FAIL_IF_BAD_REPLY
parameter_list|(
name|reply
parameter_list|,
name|request_name
parameter_list|)
value|do {                     \     if (!reply) {                                                       \         log_err(keymap->ctx,                                            \                 "x11: failed to get keymap from X server: %s request failed\n", \                 (request_name));                                        \         goto fail;                                                      \     }                                                                   \ } while (0)
end_define
begin_define
DECL|macro|ALLOC_OR_FAIL
define|#
directive|define
name|ALLOC_OR_FAIL
parameter_list|(
name|arr
parameter_list|,
name|nmemb
parameter_list|)
value|do {                                  \     if ((nmemb)> 0) {                                                  \         (arr) = calloc((nmemb), sizeof(*(arr)));                        \         if (!(arr))                                                     \             goto fail;                                                  \     }                                                                   \ } while (0)
end_define
begin_function
specifier|static
name|xkb_mod_mask_t
DECL|function|translate_mods
name|translate_mods
parameter_list|(
name|uint8_t
name|rmods
parameter_list|,
name|uint16_t
name|vmods_low
parameter_list|,
name|uint16_t
name|vmods_high
parameter_list|)
block|{
comment|/* We represent mod masks in a single uint32_t value, with real mods      * first and vmods after (though we don't make these distinctions). */
return|return
operator|(
operator|(
name|xkb_mod_mask_t
operator|)
name|rmods
operator|)
operator||
operator|(
operator|(
name|xkb_mod_mask_t
operator|)
name|vmods_low
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|xkb_mod_mask_t
operator|)
name|vmods_high
operator|<<
literal|16
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|enum
name|xkb_action_controls
DECL|function|translate_controls_mask
name|translate_controls_mask
parameter_list|(
name|uint32_t
name|wire
parameter_list|)
block|{
name|enum
name|xkb_action_controls
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_REPEAT_KEYS
condition|)
name|ret
operator||=
name|CONTROL_REPEAT
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_SLOW_KEYS
condition|)
name|ret
operator||=
name|CONTROL_SLOW
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_BOUNCE_KEYS
condition|)
name|ret
operator||=
name|CONTROL_DEBOUNCE
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_STICKY_KEYS
condition|)
name|ret
operator||=
name|CONTROL_STICKY
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_MOUSE_KEYS
condition|)
name|ret
operator||=
name|CONTROL_MOUSEKEYS
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_MOUSE_KEYS_ACCEL
condition|)
name|ret
operator||=
name|CONTROL_MOUSEKEYS_ACCEL
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_ACCESS_X_KEYS
condition|)
name|ret
operator||=
name|CONTROL_AX
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_ACCESS_X_TIMEOUT_MASK
condition|)
name|ret
operator||=
name|CONTROL_AX_TIMEOUT
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_ACCESS_X_FEEDBACK_MASK
condition|)
name|ret
operator||=
name|CONTROL_AX_FEEDBACK
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_AUDIBLE_BELL_MASK
condition|)
name|ret
operator||=
name|CONTROL_BELL
expr_stmt|;
if|if
condition|(
name|wire
operator|&
name|XCB_XKB_BOOL_CTRL_IGNORE_GROUP_LOCK_MASK
condition|)
name|ret
operator||=
name|CONTROL_IGNORE_GROUP_LOCK
expr_stmt|;
comment|/* Some controls are not supported and don't appear here. */
return|return
name|ret
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|translate_action
name|translate_action
parameter_list|(
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
specifier|const
name|xcb_xkb_action_t
modifier|*
name|wire
parameter_list|)
block|{
switch|switch
condition|(
name|wire
operator|->
name|type
condition|)
block|{
case|case
name|XCB_XKB_SA_TYPE_SET_MODS
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_MOD_SET
expr_stmt|;
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mods
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|setmods
operator|.
name|realMods
argument_list|,
name|wire
operator|->
name|setmods
operator|.
name|vmodsLow
argument_list|,
name|wire
operator|->
name|setmods
operator|.
name|vmodsHigh
argument_list|)
expr_stmt|;
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mask
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|setmods
operator|.
name|mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|setmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_CLEAR_LOCKS
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_LOCK_CLEAR
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|setmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_LATCH_TO_LOCK
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_LATCH_TO_LOCK
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|setmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_USE_MOD_MAP_MODS
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_MODS_LOOKUP_MODMAP
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_LATCH_MODS
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_MOD_LATCH
expr_stmt|;
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mods
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|latchmods
operator|.
name|realMods
argument_list|,
name|wire
operator|->
name|latchmods
operator|.
name|vmodsLow
argument_list|,
name|wire
operator|->
name|latchmods
operator|.
name|vmodsHigh
argument_list|)
expr_stmt|;
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mask
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|latchmods
operator|.
name|mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|latchmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_CLEAR_LOCKS
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_LOCK_CLEAR
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|latchmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_LATCH_TO_LOCK
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_LATCH_TO_LOCK
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|latchmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_USE_MOD_MAP_MODS
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_MODS_LOOKUP_MODMAP
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_LOCK_MODS
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_MOD_LOCK
expr_stmt|;
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mods
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|lockmods
operator|.
name|realMods
argument_list|,
name|wire
operator|->
name|lockmods
operator|.
name|vmodsLow
argument_list|,
name|wire
operator|->
name|lockmods
operator|.
name|vmodsHigh
argument_list|)
expr_stmt|;
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mask
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|lockmods
operator|.
name|mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|lockmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_ISO_LOCK_FLAG_NO_LOCK
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_LOCK_NO_LOCK
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|lockmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_ISO_LOCK_FLAG_NO_UNLOCK
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_LOCK_NO_UNLOCK
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|lockmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_USE_MOD_MAP_MODS
condition|)
name|action
operator|->
name|mods
operator|.
name|flags
operator||=
name|ACTION_MODS_LOOKUP_MODMAP
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_SET_GROUP
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_GROUP_SET
expr_stmt|;
name|action
operator|->
name|group
operator|.
name|group
operator|=
name|wire
operator|->
name|setgroup
operator|.
name|group
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|setmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_CLEAR_LOCKS
condition|)
name|action
operator|->
name|group
operator|.
name|flags
operator||=
name|ACTION_LOCK_CLEAR
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|setmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_LATCH_TO_LOCK
condition|)
name|action
operator|->
name|group
operator|.
name|flags
operator||=
name|ACTION_LATCH_TO_LOCK
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|setmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_ISO_LOCK_FLAG_GROUP_ABSOLUTE
condition|)
name|action
operator|->
name|group
operator|.
name|flags
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_LATCH_GROUP
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_GROUP_LATCH
expr_stmt|;
name|action
operator|->
name|group
operator|.
name|group
operator|=
name|wire
operator|->
name|latchgroup
operator|.
name|group
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|latchmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_CLEAR_LOCKS
condition|)
name|action
operator|->
name|group
operator|.
name|flags
operator||=
name|ACTION_LOCK_CLEAR
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|latchmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_LATCH_TO_LOCK
condition|)
name|action
operator|->
name|group
operator|.
name|flags
operator||=
name|ACTION_LATCH_TO_LOCK
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|latchmods
operator|.
name|flags
operator|&
name|XCB_XKB_SA_ISO_LOCK_FLAG_GROUP_ABSOLUTE
condition|)
name|action
operator|->
name|group
operator|.
name|flags
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_LOCK_GROUP
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_GROUP_LOCK
expr_stmt|;
name|action
operator|->
name|group
operator|.
name|group
operator|=
name|wire
operator|->
name|lockgroup
operator|.
name|group
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|lockgroup
operator|.
name|flags
operator|&
name|XCB_XKB_SA_ISO_LOCK_FLAG_GROUP_ABSOLUTE
condition|)
name|action
operator|->
name|group
operator|.
name|flags
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_MOVE_PTR
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_PTR_MOVE
expr_stmt|;
name|action
operator|->
name|ptr
operator|.
name|x
operator|=
operator|(
name|wire
operator|->
name|moveptr
operator|.
name|xLow
operator||
operator|(
name|wire
operator|->
name|moveptr
operator|.
name|xHigh
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|action
operator|->
name|ptr
operator|.
name|y
operator|=
operator|(
name|wire
operator|->
name|moveptr
operator|.
name|yLow
operator||
operator|(
name|wire
operator|->
name|moveptr
operator|.
name|yHigh
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|wire
operator|->
name|moveptr
operator|.
name|flags
operator|&
name|XCB_XKB_SA_MOVE_PTR_FLAG_NO_ACCELERATION
operator|)
condition|)
name|action
operator|->
name|ptr
operator|.
name|flags
operator||=
name|ACTION_ACCEL
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|moveptr
operator|.
name|flags
operator|&
name|XCB_XKB_SA_MOVE_PTR_FLAG_MOVE_ABSOLUTE_X
condition|)
name|action
operator|->
name|ptr
operator|.
name|flags
operator||=
name|ACTION_ABSOLUTE_X
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|moveptr
operator|.
name|flags
operator|&
name|XCB_XKB_SA_MOVE_PTR_FLAG_MOVE_ABSOLUTE_Y
condition|)
name|action
operator|->
name|ptr
operator|.
name|flags
operator||=
name|ACTION_ABSOLUTE_Y
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_PTR_BTN
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_PTR_BUTTON
expr_stmt|;
name|action
operator|->
name|btn
operator|.
name|count
operator|=
name|wire
operator|->
name|ptrbtn
operator|.
name|count
expr_stmt|;
name|action
operator|->
name|btn
operator|.
name|button
operator|=
name|wire
operator|->
name|ptrbtn
operator|.
name|button
expr_stmt|;
name|action
operator|->
name|btn
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_LOCK_PTR_BTN
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_PTR_LOCK
expr_stmt|;
name|action
operator|->
name|btn
operator|.
name|button
operator|=
name|wire
operator|->
name|lockptrbtn
operator|.
name|button
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|lockptrbtn
operator|.
name|flags
operator|&
name|XCB_XKB_SA_ISO_LOCK_FLAG_NO_LOCK
condition|)
name|action
operator|->
name|btn
operator|.
name|flags
operator||=
name|ACTION_LOCK_NO_LOCK
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|lockptrbtn
operator|.
name|flags
operator|&
name|XCB_XKB_SA_ISO_LOCK_FLAG_NO_UNLOCK
condition|)
name|action
operator|->
name|btn
operator|.
name|flags
operator||=
name|ACTION_LOCK_NO_UNLOCK
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_SET_PTR_DFLT
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_PTR_DEFAULT
expr_stmt|;
name|action
operator|->
name|dflt
operator|.
name|value
operator|=
name|wire
operator|->
name|setptrdflt
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|setptrdflt
operator|.
name|flags
operator|&
name|XCB_XKB_SA_SET_PTR_DFLT_FLAG_DFLT_BTN_ABSOLUTE
condition|)
name|action
operator|->
name|dflt
operator|.
name|flags
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_TERMINATE
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_TERMINATE
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_SWITCH_SCREEN
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_SWITCH_VT
expr_stmt|;
name|action
operator|->
name|screen
operator|.
name|screen
operator|=
name|wire
operator|->
name|switchscreen
operator|.
name|newScreen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|wire
operator|->
name|switchscreen
operator|.
name|flags
operator|&
name|XCB_XKB_SWITCH_SCREEN_FLAG_APPLICATION
operator|)
condition|)
name|action
operator|->
name|screen
operator|.
name|flags
operator||=
name|ACTION_SAME_SCREEN
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|switchscreen
operator|.
name|flags
operator|&
name|XCB_XKB_SWITCH_SCREEN_FLAG_ABSOLUTE
condition|)
name|action
operator|->
name|screen
operator|.
name|flags
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SA_TYPE_SET_CONTROLS
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_CTRL_SET
expr_stmt|;
block|{
specifier|const
name|uint16_t
name|mask
init|=
operator|(
name|wire
operator|->
name|setcontrols
operator|.
name|boolCtrlsLow
operator||
operator|(
name|wire
operator|->
name|setcontrols
operator|.
name|boolCtrlsHigh
operator|<<
literal|8
operator|)
operator|)
decl_stmt|;
name|action
operator|->
name|ctrls
operator|.
name|ctrls
operator|=
name|translate_controls_mask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XCB_XKB_SA_TYPE_LOCK_CONTROLS
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_CTRL_LOCK
expr_stmt|;
block|{
specifier|const
name|uint16_t
name|mask
init|=
operator|(
name|wire
operator|->
name|lockcontrols
operator|.
name|boolCtrlsLow
operator||
operator|(
name|wire
operator|->
name|lockcontrols
operator|.
name|boolCtrlsHigh
operator|<<
literal|8
operator|)
operator|)
decl_stmt|;
name|action
operator|->
name|ctrls
operator|.
name|ctrls
operator|=
name|translate_controls_mask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XCB_XKB_SA_TYPE_NO_ACTION
case|:
comment|/* We don't support these. */
case|case
name|XCB_XKB_SA_TYPE_ISO_LOCK
case|:
case|case
name|XCB_XKB_SA_TYPE_REDIRECT_KEY
case|:
case|case
name|XCB_XKB_SA_TYPE_ACTION_MESSAGE
case|:
case|case
name|XCB_XKB_SA_TYPE_DEVICE_BTN
case|:
case|case
name|XCB_XKB_SA_TYPE_LOCK_DEVICE_BTN
case|:
case|case
name|XCB_XKB_SA_TYPE_DEVICE_VALUATOR
case|:
name|action
operator|->
name|type
operator|=
name|ACTION_TYPE_NONE
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_types
name|get_types
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_map_map_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|types_length
init|=
name|xcb_xkb_get_map_map_types_rtrn_length
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|xcb_xkb_key_type_iterator_t
name|types_iter
init|=
name|xcb_xkb_get_map_map_types_rtrn_iterator
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstType
operator|==
literal|0
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|num_types
operator|=
name|reply
operator|->
name|nTypes
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|keymap
operator|->
name|types
argument_list|,
name|keymap
operator|->
name|num_types
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|types_length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_key_type_t
modifier|*
name|wire_type
init|=
name|types_iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key_type
modifier|*
name|type
init|=
operator|&
name|keymap
operator|->
name|types
index|[
name|i
index|]
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|wire_type
operator|->
name|numLevels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|type
operator|->
name|mods
operator|.
name|mods
operator|=
name|translate_mods
argument_list|(
name|wire_type
operator|->
name|mods_mods
argument_list|,
name|wire_type
operator|->
name|mods_vmods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|->
name|mods
operator|.
name|mask
operator|=
name|translate_mods
argument_list|(
name|wire_type
operator|->
name|mods_mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|->
name|num_levels
operator|=
name|wire_type
operator|->
name|numLevels
expr_stmt|;
block|{
name|int
name|entries_length
init|=
name|xcb_xkb_key_type_map_length
argument_list|(
name|wire_type
argument_list|)
decl_stmt|;
name|xcb_xkb_kt_map_entry_iterator_t
name|entries_iter
init|=
name|xcb_xkb_key_type_map_iterator
argument_list|(
name|wire_type
argument_list|)
decl_stmt|;
name|type
operator|->
name|num_entries
operator|=
name|wire_type
operator|->
name|nMapEntries
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|type
operator|->
name|entries
argument_list|,
name|type
operator|->
name|num_entries
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|entries_length
condition|;
name|j
operator|++
control|)
block|{
name|xcb_xkb_kt_map_entry_t
modifier|*
name|wire_entry
init|=
name|entries_iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
init|=
operator|&
name|type
operator|->
name|entries
index|[
name|j
index|]
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|wire_entry
operator|->
name|level
operator|<
name|type
operator|->
name|num_levels
argument_list|)
expr_stmt|;
name|entry
operator|->
name|level
operator|=
name|wire_entry
operator|->
name|level
expr_stmt|;
name|entry
operator|->
name|mods
operator|.
name|mods
operator|=
name|translate_mods
argument_list|(
name|wire_entry
operator|->
name|mods_mods
argument_list|,
name|wire_entry
operator|->
name|mods_vmods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|mods
operator|.
name|mask
operator|=
name|translate_mods
argument_list|(
name|wire_entry
operator|->
name|mods_mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xcb_xkb_kt_map_entry_next
argument_list|(
operator|&
name|entries_iter
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|int
name|preserves_length
init|=
name|xcb_xkb_key_type_preserve_length
argument_list|(
name|wire_type
argument_list|)
decl_stmt|;
name|xcb_xkb_mod_def_iterator_t
name|preserves_iter
init|=
name|xcb_xkb_key_type_preserve_iterator
argument_list|(
name|wire_type
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
operator|(
name|unsigned
operator|)
name|preserves_length
operator|<=
name|type
operator|->
name|num_entries
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|preserves_length
condition|;
name|j
operator|++
control|)
block|{
name|xcb_xkb_mod_def_t
modifier|*
name|wire_preserve
init|=
name|preserves_iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
init|=
operator|&
name|type
operator|->
name|entries
index|[
name|j
index|]
decl_stmt|;
name|entry
operator|->
name|preserve
operator|.
name|mods
operator|=
name|translate_mods
argument_list|(
name|wire_preserve
operator|->
name|realMods
argument_list|,
name|wire_preserve
operator|->
name|vmods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|preserve
operator|.
name|mask
operator|=
name|translate_mods
argument_list|(
name|wire_preserve
operator|->
name|mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xcb_xkb_mod_def_next
argument_list|(
operator|&
name|preserves_iter
argument_list|)
expr_stmt|;
block|}
block|}
name|xcb_xkb_key_type_next
argument_list|(
operator|&
name|types_iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_sym_maps
name|get_sym_maps
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_map_map_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|sym_maps_length
init|=
name|xcb_xkb_get_map_map_syms_rtrn_length
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|xcb_xkb_key_sym_map_iterator_t
name|sym_maps_iter
init|=
name|xcb_xkb_get_map_map_syms_rtrn_iterator
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|minKeyCode
operator|<=
name|reply
operator|->
name|maxKeyCode
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstKeySym
operator|>=
name|reply
operator|->
name|minKeyCode
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstKeySym
operator|+
name|reply
operator|->
name|nKeySyms
operator|<=
name|reply
operator|->
name|maxKeyCode
operator|+
literal|1
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|min_key_code
operator|=
name|reply
operator|->
name|minKeyCode
expr_stmt|;
name|keymap
operator|->
name|max_key_code
operator|=
name|reply
operator|->
name|maxKeyCode
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|keymap
operator|->
name|keys
argument_list|,
name|keymap
operator|->
name|max_key_code
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|xkb_keycode_t
name|kc
init|=
name|keymap
operator|->
name|min_key_code
init|;
name|kc
operator|<=
name|keymap
operator|->
name|max_key_code
condition|;
name|kc
operator|++
control|)
name|keymap
operator|->
name|keys
index|[
name|kc
index|]
operator|.
name|keycode
operator|=
name|kc
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sym_maps_length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_key_sym_map_t
modifier|*
name|wire_sym_map
init|=
name|sym_maps_iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key
modifier|*
name|key
init|=
operator|&
name|keymap
operator|->
name|keys
index|[
name|reply
operator|->
name|firstKeySym
operator|+
name|i
index|]
decl_stmt|;
name|key
operator|->
name|num_groups
operator|=
name|wire_sym_map
operator|->
name|groupInfo
operator|&
literal|0x0f
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|key
operator|->
name|num_groups
operator|<=
name|ARRAY_SIZE
argument_list|(
name|wire_sym_map
operator|->
name|kt_index
argument_list|)
argument_list|)
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|key
operator|->
name|groups
argument_list|,
name|key
operator|->
name|num_groups
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|key
operator|->
name|num_groups
condition|;
name|j
operator|++
control|)
block|{
name|FAIL_UNLESS
argument_list|(
name|wire_sym_map
operator|->
name|kt_index
index|[
name|j
index|]
operator|<
name|keymap
operator|->
name|num_types
argument_list|)
expr_stmt|;
name|key
operator|->
name|groups
index|[
name|j
index|]
operator|.
name|type
operator|=
operator|&
name|keymap
operator|->
name|types
index|[
name|wire_sym_map
operator|->
name|kt_index
index|[
name|j
index|]
index|]
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|key
operator|->
name|groups
index|[
name|j
index|]
operator|.
name|levels
argument_list|,
name|key
operator|->
name|groups
index|[
name|j
index|]
operator|.
name|type
operator|->
name|num_levels
argument_list|)
expr_stmt|;
block|}
name|key
operator|->
name|out_of_range_group_number
operator|=
operator|(
name|wire_sym_map
operator|->
name|groupInfo
operator|&
literal|0x30
operator|)
operator|>>
literal|4
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|key
operator|->
name|out_of_range_group_number
operator|<=
name|key
operator|->
name|num_groups
argument_list|)
expr_stmt|;
if|if
condition|(
name|wire_sym_map
operator|->
name|groupInfo
operator|&
name|XCB_XKB_GROUPS_WRAP_CLAMP_INTO_RANGE
condition|)
name|key
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_SATURATE
expr_stmt|;
elseif|else
if|if
condition|(
name|wire_sym_map
operator|->
name|groupInfo
operator|&
name|XCB_XKB_GROUPS_WRAP_REDIRECT_INTO_RANGE
condition|)
name|key
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_REDIRECT
expr_stmt|;
else|else
name|key
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_WRAP
expr_stmt|;
block|{
name|int
name|syms_length
init|=
name|xcb_xkb_key_sym_map_syms_length
argument_list|(
name|wire_sym_map
argument_list|)
decl_stmt|;
name|xcb_keysym_t
modifier|*
name|syms_iter
init|=
name|xcb_xkb_key_sym_map_syms
argument_list|(
name|wire_sym_map
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
operator|(
name|unsigned
operator|)
name|syms_length
operator|==
name|wire_sym_map
operator|->
name|width
operator|*
name|key
operator|->
name|num_groups
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|syms_length
condition|;
name|j
operator|++
control|)
block|{
name|xcb_keysym_t
name|wire_keysym
init|=
operator|*
name|syms_iter
decl_stmt|;
specifier|const
name|xkb_layout_index_t
name|group
init|=
name|j
operator|/
name|wire_sym_map
operator|->
name|width
decl_stmt|;
specifier|const
name|xkb_level_index_t
name|level
init|=
name|j
operator|%
name|wire_sym_map
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|level
operator|<
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|type
operator|->
name|num_levels
operator|&&
name|wire_keysym
operator|!=
name|XKB_KEY_NoSymbol
condition|)
block|{
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|levels
index|[
name|level
index|]
operator|.
name|num_syms
operator|=
literal|1
expr_stmt|;
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|levels
index|[
name|level
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|wire_keysym
expr_stmt|;
block|}
name|syms_iter
operator|++
expr_stmt|;
block|}
block|}
name|xcb_xkb_key_sym_map_next
argument_list|(
operator|&
name|sym_maps_iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_actions
name|get_actions
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_map_map_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|acts_count_length
init|=
name|xcb_xkb_get_map_map_acts_rtrn_count_length
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|acts_count_iter
init|=
name|xcb_xkb_get_map_map_acts_rtrn_count
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|xcb_xkb_action_iterator_t
name|acts_iter
init|=
name|xcb_xkb_get_map_map_acts_rtrn_acts_iterator
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|xcb_xkb_key_sym_map_iterator_t
name|sym_maps_iter
init|=
name|xcb_xkb_get_map_map_syms_rtrn_iterator
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstKeyAction
operator|==
name|keymap
operator|->
name|min_key_code
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstKeyAction
operator|+
name|reply
operator|->
name|nKeyActions
operator|==
name|keymap
operator|->
name|max_key_code
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|acts_count_length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_key_sym_map_t
modifier|*
name|wire_sym_map
init|=
name|sym_maps_iter
operator|.
name|data
decl_stmt|;
name|int
name|syms_length
init|=
name|xcb_xkb_key_sym_map_syms_length
argument_list|(
name|wire_sym_map
argument_list|)
decl_stmt|;
name|uint8_t
name|wire_count
init|=
operator|*
name|acts_count_iter
decl_stmt|;
name|struct
name|xkb_key
modifier|*
name|key
init|=
operator|&
name|keymap
operator|->
name|keys
index|[
name|reply
operator|->
name|firstKeyAction
operator|+
name|i
index|]
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|wire_count
operator|==
literal|0
operator|||
name|wire_count
operator|==
name|syms_length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|wire_count
condition|;
name|j
operator|++
control|)
block|{
name|xcb_xkb_action_t
modifier|*
name|wire_action
init|=
name|acts_iter
operator|.
name|data
decl_stmt|;
specifier|const
name|xkb_layout_index_t
name|group
init|=
name|j
operator|/
name|wire_sym_map
operator|->
name|width
decl_stmt|;
specifier|const
name|xkb_level_index_t
name|level
init|=
name|j
operator|%
name|wire_sym_map
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|level
operator|<
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|type
operator|->
name|num_levels
condition|)
block|{
name|union
name|xkb_action
modifier|*
name|action
init|=
operator|&
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|levels
index|[
name|level
index|]
operator|.
name|action
decl_stmt|;
name|translate_action
argument_list|(
name|action
argument_list|,
name|wire_action
argument_list|)
expr_stmt|;
block|}
name|xcb_xkb_action_next
argument_list|(
operator|&
name|acts_iter
argument_list|)
expr_stmt|;
block|}
name|acts_count_iter
operator|++
expr_stmt|;
name|xcb_xkb_key_sym_map_next
argument_list|(
operator|&
name|sym_maps_iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_vmods
name|get_vmods
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_map_map_t
modifier|*
name|map
parameter_list|)
block|{
name|uint8_t
modifier|*
name|iter
init|=
name|xcb_xkb_get_map_map_vmods_rtrn
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|darray_resize0
argument_list|(
name|keymap
operator|->
name|mods
argument_list|,
name|NUM_REAL_MODS
operator|+
name|msb_pos
argument_list|(
name|reply
operator|->
name|virtualMods
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_VMODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reply
operator|->
name|virtualMods
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
condition|)
block|{
name|uint8_t
name|wire
init|=
operator|*
name|iter
decl_stmt|;
name|struct
name|xkb_mod
modifier|*
name|mod
init|=
operator|&
name|darray_item
argument_list|(
name|keymap
operator|->
name|mods
argument_list|,
name|NUM_REAL_MODS
operator|+
name|i
argument_list|)
decl_stmt|;
name|mod
operator|->
name|type
operator|=
name|MOD_VIRT
expr_stmt|;
name|mod
operator|->
name|mapping
operator|=
name|translate_mods
argument_list|(
name|wire
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iter
operator|++
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_explicits
name|get_explicits
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_map_map_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|length
init|=
name|xcb_xkb_get_map_map_explicit_rtrn_length
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|xcb_xkb_set_explicit_iterator_t
name|iter
init|=
name|xcb_xkb_get_map_map_explicit_rtrn_iterator
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_set_explicit_t
modifier|*
name|wire
init|=
name|iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|wire
operator|->
name|keycode
operator|>=
name|keymap
operator|->
name|min_key_code
operator|&&
name|wire
operator|->
name|keycode
operator|<=
name|keymap
operator|->
name|max_key_code
argument_list|)
expr_stmt|;
name|key
operator|=
operator|&
name|keymap
operator|->
name|keys
index|[
name|wire
operator|->
name|keycode
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|wire
operator|->
name|explicit
operator|&
name|XCB_XKB_EXPLICIT_KEY_TYPE_1
operator|)
operator|&&
name|key
operator|->
name|num_groups
operator|>
literal|0
condition|)
name|key
operator|->
name|groups
index|[
literal|0
index|]
operator|.
name|explicit_type
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|wire
operator|->
name|explicit
operator|&
name|XCB_XKB_EXPLICIT_KEY_TYPE_2
operator|)
operator|&&
name|key
operator|->
name|num_groups
operator|>
literal|1
condition|)
name|key
operator|->
name|groups
index|[
literal|1
index|]
operator|.
name|explicit_type
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|wire
operator|->
name|explicit
operator|&
name|XCB_XKB_EXPLICIT_KEY_TYPE_3
operator|)
operator|&&
name|key
operator|->
name|num_groups
operator|>
literal|2
condition|)
name|key
operator|->
name|groups
index|[
literal|2
index|]
operator|.
name|explicit_type
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|wire
operator|->
name|explicit
operator|&
name|XCB_XKB_EXPLICIT_KEY_TYPE_4
operator|)
operator|&&
name|key
operator|->
name|num_groups
operator|>
literal|3
condition|)
name|key
operator|->
name|groups
index|[
literal|3
index|]
operator|.
name|explicit_type
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|explicit
operator|&
name|XCB_XKB_EXPLICIT_INTERPRET
condition|)
name|key
operator|->
name|explicit
operator||=
name|EXPLICIT_INTERP
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|explicit
operator|&
name|XCB_XKB_EXPLICIT_AUTO_REPEAT
condition|)
name|key
operator|->
name|explicit
operator||=
name|EXPLICIT_REPEAT
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|explicit
operator|&
name|XCB_XKB_EXPLICIT_V_MOD_MAP
condition|)
name|key
operator|->
name|explicit
operator||=
name|EXPLICIT_VMODMAP
expr_stmt|;
name|xcb_xkb_set_explicit_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_modmaps
name|get_modmaps
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_map_map_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|length
init|=
name|xcb_xkb_get_map_map_modmap_rtrn_length
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|xcb_xkb_key_mod_map_iterator_t
name|iter
init|=
name|xcb_xkb_get_map_map_modmap_rtrn_iterator
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_key_mod_map_t
modifier|*
name|wire
init|=
name|iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|wire
operator|->
name|keycode
operator|>=
name|keymap
operator|->
name|min_key_code
operator|&&
name|wire
operator|->
name|keycode
operator|<=
name|keymap
operator|->
name|max_key_code
argument_list|)
expr_stmt|;
name|key
operator|=
operator|&
name|keymap
operator|->
name|keys
index|[
name|wire
operator|->
name|keycode
index|]
expr_stmt|;
name|key
operator|->
name|modmap
operator|=
name|wire
operator|->
name|mods
expr_stmt|;
name|xcb_xkb_key_mod_map_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_vmodmaps
name|get_vmodmaps
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_map_map_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|length
init|=
name|xcb_xkb_get_map_map_vmodmap_rtrn_length
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|xcb_xkb_key_v_mod_map_iterator_t
name|iter
init|=
name|xcb_xkb_get_map_map_vmodmap_rtrn_iterator
argument_list|(
name|reply
argument_list|,
name|map
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_key_v_mod_map_t
modifier|*
name|wire
init|=
name|iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|wire
operator|->
name|keycode
operator|>=
name|keymap
operator|->
name|min_key_code
operator|&&
name|wire
operator|->
name|keycode
operator|<=
name|keymap
operator|->
name|max_key_code
argument_list|)
expr_stmt|;
name|key
operator|=
operator|&
name|keymap
operator|->
name|keys
index|[
name|wire
operator|->
name|keycode
index|]
expr_stmt|;
name|key
operator|->
name|vmodmap
operator|=
name|translate_mods
argument_list|(
literal|0
argument_list|,
name|wire
operator|->
name|vmods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xcb_xkb_key_v_mod_map_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_map
name|get_map
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|uint16_t
name|device_id
parameter_list|)
block|{
specifier|static
specifier|const
name|xcb_xkb_map_part_t
name|required_components
init|=
operator|(
name|XCB_XKB_MAP_PART_KEY_TYPES
operator||
name|XCB_XKB_MAP_PART_KEY_SYMS
operator||
name|XCB_XKB_MAP_PART_MODIFIER_MAP
operator||
name|XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS
operator||
name|XCB_XKB_MAP_PART_KEY_ACTIONS
operator||
name|XCB_XKB_MAP_PART_VIRTUAL_MODS
operator||
name|XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP
operator|)
decl_stmt|;
name|xcb_xkb_get_map_cookie_t
name|cookie
init|=
name|xcb_xkb_get_map
argument_list|(
name|conn
argument_list|,
name|device_id
argument_list|,
name|required_components
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xcb_xkb_get_map_reply_t
modifier|*
name|reply
init|=
name|xcb_xkb_get_map_reply
argument_list|(
name|conn
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|xcb_xkb_get_map_map_t
name|map
decl_stmt|;
name|FAIL_IF_BAD_REPLY
argument_list|(
name|reply
argument_list|,
literal|"XkbGetMap"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|->
name|present
operator|&
name|required_components
operator|)
operator|!=
name|required_components
condition|)
goto|goto
name|fail
goto|;
name|xcb_xkb_get_map_map_unpack
argument_list|(
name|xcb_xkb_get_map_map
argument_list|(
name|reply
argument_list|)
argument_list|,
name|reply
operator|->
name|nTypes
argument_list|,
name|reply
operator|->
name|nKeySyms
argument_list|,
name|reply
operator|->
name|nKeyActions
argument_list|,
name|reply
operator|->
name|totalActions
argument_list|,
name|reply
operator|->
name|totalKeyBehaviors
argument_list|,
name|reply
operator|->
name|virtualMods
argument_list|,
name|reply
operator|->
name|totalKeyExplicit
argument_list|,
name|reply
operator|->
name|totalModMapKeys
argument_list|,
name|reply
operator|->
name|totalVModMapKeys
argument_list|,
name|reply
operator|->
name|present
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_types
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|map
argument_list|)
operator|||
operator|!
name|get_sym_maps
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|map
argument_list|)
operator|||
operator|!
name|get_actions
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|map
argument_list|)
operator|||
operator|!
name|get_vmods
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|map
argument_list|)
operator|||
operator|!
name|get_explicits
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|map
argument_list|)
operator|||
operator|!
name|get_modmaps
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|map
argument_list|)
operator|||
operator|!
name|get_vmodmaps
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|map
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_indicators
name|get_indicators
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_indicator_map_reply_t
modifier|*
name|reply
parameter_list|)
block|{
name|xcb_xkb_indicator_map_iterator_t
name|iter
init|=
name|xcb_xkb_get_indicator_map_maps_iterator
argument_list|(
name|reply
argument_list|)
decl_stmt|;
name|darray_resize0
argument_list|(
name|keymap
operator|->
name|leds
argument_list|,
name|msb_pos
argument_list|(
name|reply
operator|->
name|which
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_INDICATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reply
operator|->
name|which
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
condition|)
block|{
name|xcb_xkb_indicator_map_t
modifier|*
name|wire
init|=
name|iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_led
modifier|*
name|led
init|=
operator|&
name|darray_item
argument_list|(
name|keymap
operator|->
name|leds
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichGroups
operator|&
name|XCB_XKB_IM_GROUPS_WHICH_USE_BASE
condition|)
name|led
operator|->
name|which_groups
operator||=
name|XKB_STATE_LAYOUT_DEPRESSED
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichGroups
operator|&
name|XCB_XKB_IM_GROUPS_WHICH_USE_LATCHED
condition|)
name|led
operator|->
name|which_groups
operator||=
name|XKB_STATE_LAYOUT_LATCHED
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichGroups
operator|&
name|XCB_XKB_IM_GROUPS_WHICH_USE_LOCKED
condition|)
name|led
operator|->
name|which_groups
operator||=
name|XKB_STATE_LAYOUT_LOCKED
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichGroups
operator|&
name|XCB_XKB_IM_GROUPS_WHICH_USE_EFFECTIVE
condition|)
name|led
operator|->
name|which_groups
operator||=
name|XKB_STATE_LAYOUT_EFFECTIVE
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichGroups
operator|&
name|XCB_XKB_IM_GROUPS_WHICH_USE_COMPAT
condition|)
name|led
operator|->
name|which_groups
operator||=
name|XKB_STATE_LAYOUT_EFFECTIVE
expr_stmt|;
name|led
operator|->
name|groups
operator|=
name|wire
operator|->
name|groups
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichMods
operator|&
name|XCB_XKB_IM_MODS_WHICH_USE_BASE
condition|)
name|led
operator|->
name|which_mods
operator||=
name|XKB_STATE_MODS_DEPRESSED
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichMods
operator|&
name|XCB_XKB_IM_MODS_WHICH_USE_LATCHED
condition|)
name|led
operator|->
name|which_mods
operator||=
name|XKB_STATE_MODS_LATCHED
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichMods
operator|&
name|XCB_XKB_IM_MODS_WHICH_USE_LOCKED
condition|)
name|led
operator|->
name|which_mods
operator||=
name|XKB_STATE_MODS_LOCKED
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichMods
operator|&
name|XCB_XKB_IM_MODS_WHICH_USE_EFFECTIVE
condition|)
name|led
operator|->
name|which_mods
operator||=
name|XKB_STATE_MODS_EFFECTIVE
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|whichMods
operator|&
name|XCB_XKB_IM_MODS_WHICH_USE_COMPAT
condition|)
name|led
operator|->
name|which_mods
operator||=
name|XKB_STATE_MODS_EFFECTIVE
expr_stmt|;
name|led
operator|->
name|mods
operator|.
name|mods
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|realMods
argument_list|,
name|wire
operator|->
name|vmods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|led
operator|->
name|mods
operator|.
name|mask
operator|=
name|translate_mods
argument_list|(
name|wire
operator|->
name|mods
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|led
operator|->
name|ctrls
operator|=
name|translate_controls_mask
argument_list|(
name|wire
operator|->
name|ctrls
argument_list|)
expr_stmt|;
name|xcb_xkb_indicator_map_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_indicator_map
name|get_indicator_map
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|uint16_t
name|device_id
parameter_list|)
block|{
name|xcb_xkb_get_indicator_map_cookie_t
name|cookie
init|=
name|xcb_xkb_get_indicator_map
argument_list|(
name|conn
argument_list|,
name|device_id
argument_list|,
name|ALL_INDICATORS_MASK
argument_list|)
decl_stmt|;
name|xcb_xkb_get_indicator_map_reply_t
modifier|*
name|reply
init|=
name|xcb_xkb_get_indicator_map_reply
argument_list|(
name|conn
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|FAIL_IF_BAD_REPLY
argument_list|(
name|reply
argument_list|,
literal|"XkbGetIndicatorMap"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_indicators
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_sym_interprets
name|get_sym_interprets
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_compat_map_reply_t
modifier|*
name|reply
parameter_list|)
block|{
name|int
name|length
init|=
name|xcb_xkb_get_compat_map_si_rtrn_length
argument_list|(
name|reply
argument_list|)
decl_stmt|;
name|xcb_xkb_sym_interpret_iterator_t
name|iter
init|=
name|xcb_xkb_get_compat_map_si_rtrn_iterator
argument_list|(
name|reply
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstSIRtrn
operator|==
literal|0
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|nSIRtrn
operator|==
name|reply
operator|->
name|nTotalSI
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|num_sym_interprets
operator|=
name|reply
operator|->
name|nSIRtrn
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|keymap
operator|->
name|sym_interprets
argument_list|,
name|keymap
operator|->
name|num_sym_interprets
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_sym_interpret_t
modifier|*
name|wire
init|=
name|iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_sym_interpret
modifier|*
name|sym_interpret
init|=
operator|&
name|keymap
operator|->
name|sym_interprets
index|[
name|i
index|]
decl_stmt|;
name|sym_interpret
operator|->
name|sym
operator|=
name|wire
operator|->
name|sym
expr_stmt|;
switch|switch
condition|(
name|wire
operator|->
name|match
operator|&
name|XCB_XKB_SYM_INTERP_MATCH_OP_MASK
condition|)
block|{
case|case
name|XCB_XKB_SYM_INTERPRET_MATCH_NONE_OF
case|:
name|sym_interpret
operator|->
name|match
operator|=
name|MATCH_NONE
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SYM_INTERPRET_MATCH_ANY_OF_OR_NONE
case|:
name|sym_interpret
operator|->
name|match
operator|=
name|MATCH_ANY_OR_NONE
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SYM_INTERPRET_MATCH_ANY_OF
case|:
name|sym_interpret
operator|->
name|match
operator|=
name|MATCH_ANY
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SYM_INTERPRET_MATCH_ALL_OF
case|:
name|sym_interpret
operator|->
name|match
operator|=
name|MATCH_ALL
expr_stmt|;
break|break;
case|case
name|XCB_XKB_SYM_INTERPRET_MATCH_EXACTLY
case|:
name|sym_interpret
operator|->
name|match
operator|=
name|MATCH_EXACTLY
expr_stmt|;
break|break;
block|}
name|sym_interpret
operator|->
name|level_one_only
operator|=
operator|!
operator|!
operator|(
name|wire
operator|->
name|match
operator|&
name|XCB_XKB_SYM_INTERP_MATCH_LEVEL_ONE_ONLY
operator|)
expr_stmt|;
name|sym_interpret
operator|->
name|mods
operator|=
name|wire
operator|->
name|mods
expr_stmt|;
if|if
condition|(
name|wire
operator|->
name|virtualMod
operator|==
name|NO_MODIFIER
condition|)
name|sym_interpret
operator|->
name|virtual_mod
operator|=
name|XKB_MOD_INVALID
expr_stmt|;
else|else
name|sym_interpret
operator|->
name|virtual_mod
operator|=
name|NUM_REAL_MODS
operator|+
name|wire
operator|->
name|virtualMod
expr_stmt|;
name|sym_interpret
operator|->
name|repeat
operator|=
operator|!
operator|!
operator|(
name|wire
operator|->
name|flags
operator|&
literal|0x01
operator|)
expr_stmt|;
name|translate_action
argument_list|(
operator|&
name|sym_interpret
operator|->
name|action
argument_list|,
operator|(
name|xcb_xkb_action_t
operator|*
operator|)
operator|&
name|wire
operator|->
name|action
argument_list|)
expr_stmt|;
name|xcb_xkb_sym_interpret_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_compat_map
name|get_compat_map
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|uint16_t
name|device_id
parameter_list|)
block|{
name|xcb_xkb_get_compat_map_cookie_t
name|cookie
init|=
name|xcb_xkb_get_compat_map
argument_list|(
name|conn
argument_list|,
name|device_id
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xcb_xkb_get_compat_map_reply_t
modifier|*
name|reply
init|=
name|xcb_xkb_get_compat_map_reply
argument_list|(
name|conn
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|FAIL_IF_BAD_REPLY
argument_list|(
name|reply
argument_list|,
literal|"XkbGetCompatMap"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sym_interprets
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_type_names
name|get_type_names
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_names_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_names_value_list_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|key_type_names_length
init|=
name|xcb_xkb_get_names_value_list_type_names_length
argument_list|(
name|reply
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|xcb_atom_t
modifier|*
name|key_type_names_iter
init|=
name|xcb_xkb_get_names_value_list_type_names
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|int
name|n_levels_per_type_length
init|=
name|xcb_xkb_get_names_value_list_n_levels_per_type_length
argument_list|(
name|reply
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|n_levels_per_type_iter
init|=
name|xcb_xkb_get_names_value_list_n_levels_per_type
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|xcb_atom_t
modifier|*
name|kt_level_names_iter
init|=
name|xcb_xkb_get_names_value_list_kt_level_names
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|nTypes
operator|==
name|keymap
operator|->
name|num_types
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|key_type_names_length
operator|==
name|n_levels_per_type_length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key_type_names_length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_atom_t
name|wire_type_name
init|=
operator|*
name|key_type_names_iter
decl_stmt|;
name|uint8_t
name|wire_num_levels
init|=
operator|*
name|n_levels_per_type_iter
decl_stmt|;
name|struct
name|xkb_key_type
modifier|*
name|type
init|=
operator|&
name|keymap
operator|->
name|types
index|[
name|i
index|]
decl_stmt|;
comment|/* Levels must have names. */
name|FAIL_UNLESS
argument_list|(
name|type
operator|->
name|num_levels
operator|==
name|wire_num_levels
argument_list|)
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|type
operator|->
name|level_names
argument_list|,
name|type
operator|->
name|num_levels
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adopt_atom
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|conn
argument_list|,
name|wire_type_name
argument_list|,
operator|&
name|type
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|adopt_atoms
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|conn
argument_list|,
name|kt_level_names_iter
argument_list|,
name|type
operator|->
name|level_names
argument_list|,
name|wire_num_levels
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|kt_level_names_iter
operator|+=
name|wire_num_levels
expr_stmt|;
name|key_type_names_iter
operator|++
expr_stmt|;
name|n_levels_per_type_iter
operator|++
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_indicator_names
name|get_indicator_names
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_names_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_names_value_list_t
modifier|*
name|list
parameter_list|)
block|{
name|xcb_atom_t
modifier|*
name|iter
init|=
name|xcb_xkb_get_names_value_list_indicator_names
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|msb_pos
argument_list|(
name|reply
operator|->
name|indicators
argument_list|)
operator|<=
name|darray_size
argument_list|(
name|keymap
operator|->
name|leds
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_INDICATORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reply
operator|->
name|indicators
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
condition|)
block|{
name|xcb_atom_t
name|wire
init|=
operator|*
name|iter
decl_stmt|;
name|struct
name|xkb_led
modifier|*
name|led
init|=
operator|&
name|darray_item
argument_list|(
name|keymap
operator|->
name|leds
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|adopt_atom
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|conn
argument_list|,
name|wire
argument_list|,
operator|&
name|led
operator|->
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|iter
operator|++
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_vmod_names
name|get_vmod_names
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_names_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_names_value_list_t
modifier|*
name|list
parameter_list|)
block|{
name|xcb_atom_t
modifier|*
name|iter
init|=
name|xcb_xkb_get_names_value_list_virtual_mod_names
argument_list|(
name|list
argument_list|)
decl_stmt|;
comment|/*      * GetMap's reply->virtualMods is always 0xffff. This one really      * tells us which vmods exist (a vmod must have a name), so we fix      * up the size here.      */
name|darray_resize0
argument_list|(
name|keymap
operator|->
name|mods
argument_list|,
name|NUM_REAL_MODS
operator|+
name|msb_pos
argument_list|(
name|reply
operator|->
name|virtualMods
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_VMODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reply
operator|->
name|virtualMods
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
condition|)
block|{
name|xcb_atom_t
name|wire
init|=
operator|*
name|iter
decl_stmt|;
name|struct
name|xkb_mod
modifier|*
name|mod
init|=
operator|&
name|darray_item
argument_list|(
name|keymap
operator|->
name|mods
argument_list|,
name|NUM_REAL_MODS
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|adopt_atom
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|conn
argument_list|,
name|wire
argument_list|,
operator|&
name|mod
operator|->
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|iter
operator|++
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_group_names
name|get_group_names
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_names_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_names_value_list_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|length
init|=
name|xcb_xkb_get_names_value_list_groups_length
argument_list|(
name|reply
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|xcb_atom_t
modifier|*
name|iter
init|=
name|xcb_xkb_get_names_value_list_groups
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|keymap
operator|->
name|num_group_names
operator|=
name|msb_pos
argument_list|(
name|reply
operator|->
name|groupNames
argument_list|)
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|keymap
operator|->
name|group_names
argument_list|,
name|keymap
operator|->
name|num_group_names
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adopt_atoms
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|conn
argument_list|,
name|iter
argument_list|,
name|keymap
operator|->
name|group_names
argument_list|,
name|length
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_key_names
name|get_key_names
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_names_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_names_value_list_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|length
init|=
name|xcb_xkb_get_names_value_list_key_names_length
argument_list|(
name|reply
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|xcb_xkb_key_name_iterator_t
name|iter
init|=
name|xcb_xkb_get_names_value_list_key_names_iterator
argument_list|(
name|reply
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|minKeyCode
operator|==
name|keymap
operator|->
name|min_key_code
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|maxKeyCode
operator|==
name|keymap
operator|->
name|max_key_code
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstKey
operator|==
name|keymap
operator|->
name|min_key_code
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|firstKey
operator|+
name|reply
operator|->
name|nKeys
operator|-
literal|1U
operator|==
name|keymap
operator|->
name|max_key_code
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_key_name_t
modifier|*
name|wire
init|=
name|iter
operator|.
name|data
decl_stmt|;
name|xkb_atom_t
modifier|*
name|key_name
init|=
operator|&
name|keymap
operator|->
name|keys
index|[
name|reply
operator|->
name|firstKey
operator|+
name|i
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|wire
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|key_name
operator|=
name|XKB_ATOM_NONE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|key_name
operator|=
name|xkb_atom_intern
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|wire
operator|->
name|name
argument_list|,
name|strnlen
argument_list|(
name|wire
operator|->
name|name
argument_list|,
name|XCB_XKB_CONST_KEY_NAME_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|key_name
condition|)
return|return
name|false
return|;
block|}
name|xcb_xkb_key_name_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_aliases
name|get_aliases
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|xcb_xkb_get_names_reply_t
modifier|*
name|reply
parameter_list|,
name|xcb_xkb_get_names_value_list_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|length
init|=
name|xcb_xkb_get_names_value_list_key_aliases_length
argument_list|(
name|reply
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|xcb_xkb_key_alias_iterator_t
name|iter
init|=
name|xcb_xkb_get_names_value_list_key_aliases_iterator
argument_list|(
name|reply
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|keymap
operator|->
name|num_key_aliases
operator|=
name|reply
operator|->
name|nKeyAliases
expr_stmt|;
name|ALLOC_OR_FAIL
argument_list|(
name|keymap
operator|->
name|key_aliases
argument_list|,
name|keymap
operator|->
name|num_key_aliases
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|xcb_xkb_key_alias_t
modifier|*
name|wire
init|=
name|iter
operator|.
name|data
decl_stmt|;
name|struct
name|xkb_key_alias
modifier|*
name|alias
init|=
operator|&
name|keymap
operator|->
name|key_aliases
index|[
name|i
index|]
decl_stmt|;
name|alias
operator|->
name|real
operator|=
name|xkb_atom_intern
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|wire
operator|->
name|real
argument_list|,
name|strnlen
argument_list|(
name|wire
operator|->
name|real
argument_list|,
name|XCB_XKB_CONST_KEY_NAME_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
name|alias
operator|->
name|alias
operator|=
name|xkb_atom_intern
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|wire
operator|->
name|alias
argument_list|,
name|strnlen
argument_list|(
name|wire
operator|->
name|alias
argument_list|,
name|XCB_XKB_CONST_KEY_NAME_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alias
operator|->
name|real
operator|||
operator|!
name|alias
operator|->
name|alias
condition|)
goto|goto
name|fail
goto|;
name|xcb_xkb_key_alias_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_names
name|get_names
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|uint16_t
name|device_id
parameter_list|)
block|{
specifier|static
specifier|const
name|xcb_xkb_name_detail_t
name|wanted
init|=
operator|(
name|XCB_XKB_NAME_DETAIL_KEYCODES
operator||
name|XCB_XKB_NAME_DETAIL_SYMBOLS
operator||
name|XCB_XKB_NAME_DETAIL_TYPES
operator||
name|XCB_XKB_NAME_DETAIL_COMPAT
operator||
name|XCB_XKB_NAME_DETAIL_KEY_TYPE_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_KT_LEVEL_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_INDICATOR_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_KEY_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_KEY_ALIASES
operator||
name|XCB_XKB_NAME_DETAIL_VIRTUAL_MOD_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_GROUP_NAMES
operator|)
decl_stmt|;
specifier|static
specifier|const
name|xcb_xkb_name_detail_t
name|required
init|=
operator|(
name|XCB_XKB_NAME_DETAIL_KEY_TYPE_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_KT_LEVEL_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_KEY_NAMES
operator||
name|XCB_XKB_NAME_DETAIL_VIRTUAL_MOD_NAMES
operator|)
decl_stmt|;
name|xcb_xkb_get_names_cookie_t
name|cookie
init|=
name|xcb_xkb_get_names
argument_list|(
name|conn
argument_list|,
name|device_id
argument_list|,
name|wanted
argument_list|)
decl_stmt|;
name|xcb_xkb_get_names_reply_t
modifier|*
name|reply
init|=
name|xcb_xkb_get_names_reply
argument_list|(
name|conn
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|xcb_xkb_get_names_value_list_t
name|list
decl_stmt|;
name|FAIL_IF_BAD_REPLY
argument_list|(
name|reply
argument_list|,
literal|"XkbGetNames"
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
operator|(
name|reply
operator|->
name|which
operator|&
name|required
operator|)
operator|==
name|required
argument_list|)
expr_stmt|;
name|xcb_xkb_get_names_value_list_unpack
argument_list|(
name|xcb_xkb_get_names_value_list
argument_list|(
name|reply
argument_list|)
argument_list|,
name|reply
operator|->
name|nTypes
argument_list|,
name|reply
operator|->
name|indicators
argument_list|,
name|reply
operator|->
name|virtualMods
argument_list|,
name|reply
operator|->
name|groupNames
argument_list|,
name|reply
operator|->
name|nKeys
argument_list|,
name|reply
operator|->
name|nKeyAliases
argument_list|,
name|reply
operator|->
name|nRadioGroups
argument_list|,
name|reply
operator|->
name|which
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_atom_name
argument_list|(
name|conn
argument_list|,
name|list
operator|.
name|keycodesName
argument_list|,
operator|&
name|keymap
operator|->
name|keycodes_section_name
argument_list|)
operator|||
operator|!
name|get_atom_name
argument_list|(
name|conn
argument_list|,
name|list
operator|.
name|symbolsName
argument_list|,
operator|&
name|keymap
operator|->
name|symbols_section_name
argument_list|)
operator|||
operator|!
name|get_atom_name
argument_list|(
name|conn
argument_list|,
name|list
operator|.
name|typesName
argument_list|,
operator|&
name|keymap
operator|->
name|types_section_name
argument_list|)
operator|||
operator|!
name|get_atom_name
argument_list|(
name|conn
argument_list|,
name|list
operator|.
name|compatName
argument_list|,
operator|&
name|keymap
operator|->
name|compat_section_name
argument_list|)
operator|||
operator|!
name|get_type_names
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|list
argument_list|)
operator|||
operator|!
name|get_indicator_names
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|list
argument_list|)
operator|||
operator|!
name|get_vmod_names
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|list
argument_list|)
operator|||
operator|!
name|get_group_names
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|list
argument_list|)
operator|||
operator|!
name|get_key_names
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|list
argument_list|)
operator|||
operator|!
name|get_aliases
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|reply
argument_list|,
operator|&
name|list
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|XkbEscapeMapName
argument_list|(
name|keymap
operator|->
name|keycodes_section_name
argument_list|)
expr_stmt|;
name|XkbEscapeMapName
argument_list|(
name|keymap
operator|->
name|symbols_section_name
argument_list|)
expr_stmt|;
name|XkbEscapeMapName
argument_list|(
name|keymap
operator|->
name|types_section_name
argument_list|)
expr_stmt|;
name|XkbEscapeMapName
argument_list|(
name|keymap
operator|->
name|compat_section_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|get_controls
name|get_controls
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|uint16_t
name|device_id
parameter_list|)
block|{
name|xcb_xkb_get_controls_cookie_t
name|cookie
init|=
name|xcb_xkb_get_controls
argument_list|(
name|conn
argument_list|,
name|device_id
argument_list|)
decl_stmt|;
name|xcb_xkb_get_controls_reply_t
modifier|*
name|reply
init|=
name|xcb_xkb_get_controls_reply
argument_list|(
name|conn
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|FAIL_IF_BAD_REPLY
argument_list|(
name|reply
argument_list|,
literal|"XkbGetControls"
argument_list|)
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|reply
operator|->
name|numGroups
operator|>
literal|0
operator|&&
name|reply
operator|->
name|numGroups
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|enabled_ctrls
operator|=
name|translate_controls_mask
argument_list|(
name|reply
operator|->
name|enabledControls
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|num_groups
operator|=
name|reply
operator|->
name|numGroups
expr_stmt|;
name|FAIL_UNLESS
argument_list|(
name|keymap
operator|->
name|max_key_code
operator|<
name|XCB_XKB_CONST_PER_KEY_BIT_ARRAY_SIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|xkb_keycode_t
name|i
init|=
name|keymap
operator|->
name|min_key_code
init|;
name|i
operator|<=
name|keymap
operator|->
name|max_key_code
condition|;
name|i
operator|++
control|)
name|keymap
operator|->
name|keys
index|[
name|i
index|]
operator|.
name|repeats
operator|=
operator|!
operator|!
operator|(
name|reply
operator|->
name|perKeyRepeat
index|[
name|i
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|struct
name|xkb_keymap
modifier|*
DECL|function|xkb_x11_keymap_new_from_device
name|xkb_x11_keymap_new_from_device
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|xcb_connection_t
modifier|*
name|conn
parameter_list|,
name|int32_t
name|device_id
parameter_list|,
name|enum
name|xkb_keymap_compile_flags
name|flags
parameter_list|)
block|{
name|struct
name|xkb_keymap
modifier|*
name|keymap
decl_stmt|;
specifier|const
name|enum
name|xkb_keymap_format
name|format
init|=
name|XKB_KEYMAP_FORMAT_TEXT_V1
decl_stmt|;
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|XKB_KEYMAP_COMPILE_NO_FLAGS
operator|)
condition|)
block|{
name|log_err_func
argument_list|(
name|ctx
argument_list|,
literal|"unrecognized flags: %#x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|device_id
operator|<
literal|0
operator|||
name|device_id
operator|>
literal|255
condition|)
block|{
name|log_err_func
argument_list|(
name|ctx
argument_list|,
literal|"illegal device ID: %d\n"
argument_list|,
name|device_id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|keymap
operator|=
name|xkb_keymap_new
argument_list|(
name|ctx
argument_list|,
name|format
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keymap
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|get_map
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|device_id
argument_list|)
operator|||
operator|!
name|get_indicator_map
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|device_id
argument_list|)
operator|||
operator|!
name|get_compat_map
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|device_id
argument_list|)
operator|||
operator|!
name|get_names
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|device_id
argument_list|)
operator|||
operator|!
name|get_controls
argument_list|(
name|keymap
argument_list|,
name|conn
argument_list|,
name|device_id
argument_list|)
condition|)
block|{
name|xkb_keymap_unref
argument_list|(
name|keymap
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|keymap
return|;
block|}
end_function
end_unit
