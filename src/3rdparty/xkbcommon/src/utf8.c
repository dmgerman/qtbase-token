begin_unit
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2014 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Rob Bradford<rob@linux.intel.com>  */
end_comment
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_include
include|#
directive|include
file|<stdbool.h>
end_include
begin_include
include|#
directive|include
file|<inttypes.h>
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_function
name|int
DECL|function|utf32_to_utf8
name|utf32_to_utf8
parameter_list|(
name|uint32_t
name|unichar
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|shift
decl_stmt|,
name|length
decl_stmt|;
name|uint8_t
name|head
decl_stmt|;
if|if
condition|(
name|unichar
operator|<=
literal|0x007f
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
name|unichar
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|unichar
operator|<=
literal|0x07FF
condition|)
block|{
name|length
operator|=
literal|2
expr_stmt|;
name|head
operator|=
literal|0xc0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unichar
operator|<=
literal|0xffff
condition|)
block|{
name|length
operator|=
literal|3
expr_stmt|;
name|head
operator|=
literal|0xe0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unichar
operator|<=
literal|0x1fffff
condition|)
block|{
name|length
operator|=
literal|4
expr_stmt|;
name|head
operator|=
literal|0xf0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unichar
operator|<=
literal|0x3ffffff
condition|)
block|{
name|length
operator|=
literal|5
expr_stmt|;
name|head
operator|=
literal|0xf8
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
literal|6
expr_stmt|;
name|head
operator|=
literal|0xfc
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
name|length
operator|-
literal|1
operator|,
name|shift
operator|=
literal|0
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|shift
operator|+=
literal|6
control|)
name|buffer
index|[
name|count
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|unichar
operator|>>
name|shift
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|head
operator||
operator|(
operator|(
name|unichar
operator|>>
name|shift
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|buffer
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|length
operator|+
literal|1
return|;
block|}
end_function
begin_function
name|bool
DECL|function|is_valid_utf8
name|is_valid_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|ss
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|tail_bytes
init|=
literal|0
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|s
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ss
decl_stmt|;
comment|/* This beauty is from:      *  The Unicode Standard Version 6.2 - Core Specification, Table 3.7      *  http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf#G7404      * We can optimize if needed. */
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|<=
literal|0x7F
condition|)
block|{
name|tail_bytes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|>=
literal|0xC2
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0xDF
condition|)
block|{
name|tail_bytes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|0xE0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
operator|||
operator|!
operator|(
name|s
index|[
name|i
index|]
operator|>=
literal|0xA0
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0xBF
operator|)
condition|)
return|return
name|false
return|;
name|tail_bytes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|>=
literal|0xE1
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0xEC
condition|)
block|{
name|tail_bytes
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|0xED
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
operator|||
operator|!
operator|(
name|s
index|[
name|i
index|]
operator|>=
literal|0x80
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0x9F
operator|)
condition|)
return|return
name|false
return|;
name|tail_bytes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|>=
literal|0xEE
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0xEF
condition|)
block|{
name|tail_bytes
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|0xF0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
operator|||
operator|!
operator|(
name|s
index|[
name|i
index|]
operator|>=
literal|0x90
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0xBF
operator|)
condition|)
return|return
name|false
return|;
name|tail_bytes
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|>=
literal|0xF1
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0xF3
condition|)
block|{
name|tail_bytes
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|0xF4
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
operator|||
operator|!
operator|(
name|s
index|[
name|i
index|]
operator|>=
literal|0x80
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0x8F
operator|)
condition|)
return|return
name|false
return|;
name|tail_bytes
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|tail_bytes
operator|>
literal|0
operator|&&
name|s
index|[
name|i
index|]
operator|>=
literal|0x80
operator|&&
name|s
index|[
name|i
index|]
operator|<=
literal|0xBF
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|tail_bytes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|tail_bytes
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function
end_unit
