begin_unit
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  */
end_comment
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|"xkbcommon/xkbcommon.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|"context.h"
end_include
begin_function
name|unsigned
name|int
DECL|function|xkb_context_num_failed_include_paths
name|xkb_context_num_failed_include_paths
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|darray_size
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|)
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_context_failed_include_path_get
name|xkb_context_failed_include_path_get
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|xkb_context_num_failed_include_paths
argument_list|(
name|ctx
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|darray_item
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function
begin_function
name|xkb_atom_t
DECL|function|xkb_atom_lookup
name|xkb_atom_lookup
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|atom_lookup
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
name|xkb_atom_t
DECL|function|xkb_atom_intern
name|xkb_atom_intern
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|atom_intern
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function
begin_function
name|xkb_atom_t
DECL|function|xkb_atom_steal
name|xkb_atom_steal
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|atom_intern
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_atom_text
name|xkb_atom_text
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|xkb_atom_t
name|atom
parameter_list|)
block|{
return|return
name|atom_text
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|atom
argument_list|)
return|;
block|}
end_function
begin_function
name|void
DECL|function|xkb_log
name|xkb_log
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
name|int
name|verbosity
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|log_level
operator|<
name|level
operator|||
name|ctx
operator|->
name|log_verbosity
operator|<
name|verbosity
condition|)
return|return;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|log_fn
argument_list|(
name|ctx
argument_list|,
name|level
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|char
modifier|*
DECL|function|xkb_context_get_buffer
name|xkb_context_get_buffer
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|rtrn
decl_stmt|;
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|text_buffer
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|text_buffer
argument_list|)
operator|-
name|ctx
operator|->
name|text_next
operator|<=
name|size
condition|)
name|ctx
operator|->
name|text_next
operator|=
literal|0
expr_stmt|;
name|rtrn
operator|=
operator|&
name|ctx
operator|->
name|text_buffer
index|[
name|ctx
operator|->
name|text_next
index|]
expr_stmt|;
name|ctx
operator|->
name|text_next
operator|+=
name|size
expr_stmt|;
return|return
name|rtrn
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_XKB_VARIANT
end_ifndef
begin_define
DECL|macro|DEFAULT_XKB_VARIANT
define|#
directive|define
name|DEFAULT_XKB_VARIANT
value|NULL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_XKB_OPTIONS
end_ifndef
begin_define
DECL|macro|DEFAULT_XKB_OPTIONS
define|#
directive|define
name|DEFAULT_XKB_OPTIONS
value|NULL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_rules
name|xkb_context_get_default_rules
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|secure_getenv
argument_list|(
literal|"XKB_DEFAULT_RULES"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_RULES
return|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_model
name|xkb_context_get_default_model
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|secure_getenv
argument_list|(
literal|"XKB_DEFAULT_MODEL"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_MODEL
return|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_layout
name|xkb_context_get_default_layout
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|secure_getenv
argument_list|(
literal|"XKB_DEFAULT_LAYOUT"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_LAYOUT
return|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_variant
name|xkb_context_get_default_variant
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|layout
init|=
name|secure_getenv
argument_list|(
literal|"XKB_DEFAULT_LAYOUT"
argument_list|)
decl_stmt|;
comment|/* We don't want to inherit the variant if they haven't also set a      * layout, since they're so closely paired. */
if|if
condition|(
name|layout
operator|&&
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|secure_getenv
argument_list|(
literal|"XKB_DEFAULT_VARIANT"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_VARIANT
return|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_options
name|xkb_context_get_default_options
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|secure_getenv
argument_list|(
literal|"XKB_DEFAULT_OPTIONS"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_OPTIONS
return|;
block|}
end_function
begin_function
name|void
DECL|function|xkb_context_sanitize_rule_names
name|xkb_context_sanitize_rule_names
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|struct
name|xkb_rule_names
modifier|*
name|rmlvo
parameter_list|)
block|{
if|if
condition|(
name|isempty
argument_list|(
name|rmlvo
operator|->
name|rules
argument_list|)
condition|)
name|rmlvo
operator|->
name|rules
operator|=
name|xkb_context_get_default_rules
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isempty
argument_list|(
name|rmlvo
operator|->
name|model
argument_list|)
condition|)
name|rmlvo
operator|->
name|model
operator|=
name|xkb_context_get_default_model
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Layout and variant are tied together, so don't try to use one from      * the caller and one from the environment. */
if|if
condition|(
name|isempty
argument_list|(
name|rmlvo
operator|->
name|layout
argument_list|)
condition|)
block|{
name|rmlvo
operator|->
name|layout
operator|=
name|xkb_context_get_default_layout
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|rmlvo
operator|->
name|variant
operator|=
name|xkb_context_get_default_variant
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* Options can be empty, so respect that if passed in. */
if|if
condition|(
name|rmlvo
operator|->
name|options
operator|==
name|NULL
condition|)
name|rmlvo
operator|->
name|options
operator|=
name|xkb_context_get_default_options
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
