begin_unit
begin_comment
comment|/*  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|XKBCOMP_SCANNER_UTILS_H
end_ifndef
begin_define
DECL|macro|XKBCOMP_SCANNER_UTILS_H
define|#
directive|define
name|XKBCOMP_SCANNER_UTILS_H
end_define
begin_comment
comment|/* Point to some substring in the file; used to avoid copying. */
end_comment
begin_struct
DECL|struct|sval
struct|struct
name|sval
block|{
DECL|member|start
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
DECL|member|len
name|unsigned
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|darray_sval
typedef|typedef
name|darray
argument_list|(
argument|struct sval
argument_list|)
name|darray_sval
expr_stmt|;
end_typedef
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|svaleq
name|svaleq
parameter_list|(
name|struct
name|sval
name|s1
parameter_list|,
name|struct
name|sval
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|len
operator|==
name|s2
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|s1
operator|.
name|start
argument_list|,
name|s2
operator|.
name|start
argument_list|,
name|s1
operator|.
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|svaleq_prefix
name|svaleq_prefix
parameter_list|(
name|struct
name|sval
name|s1
parameter_list|,
name|struct
name|sval
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|len
operator|<=
name|s2
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|s1
operator|.
name|start
argument_list|,
name|s2
operator|.
name|start
argument_list|,
name|s1
operator|.
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|scanner
struct|struct
name|scanner
block|{
DECL|member|s
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
DECL|member|pos
name|size_t
name|pos
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
DECL|member|buf
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
DECL|member|buf_pos
name|size_t
name|buf_pos
decl_stmt|;
DECL|member|line
DECL|member|column
name|unsigned
name|line
decl_stmt|,
name|column
decl_stmt|;
comment|/* The line/column of the start of the current token. */
DECL|member|token_line
DECL|member|token_column
name|unsigned
name|token_line
decl_stmt|,
name|token_column
decl_stmt|;
DECL|member|file_name
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
DECL|member|ctx
name|struct
name|xkb_context
modifier|*
name|ctx
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|scanner_log
define|#
directive|define
name|scanner_log
parameter_list|(
name|scanner
parameter_list|,
name|level
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|xkb_log((scanner)->ctx, (level), 0, \             "%s:%u:%u: " fmt "\n", \              (scanner)->file_name, \              (scanner)->token_line, (scanner)->token_column, ##__VA_ARGS__)
end_define
begin_define
DECL|macro|scanner_err
define|#
directive|define
name|scanner_err
parameter_list|(
name|scanner
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|scanner_log(scanner, XKB_LOG_LEVEL_ERROR, fmt, ##__VA_ARGS__)
end_define
begin_define
DECL|macro|scanner_warn
define|#
directive|define
name|scanner_warn
parameter_list|(
name|scanner
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|scanner_log(scanner, XKB_LOG_LEVEL_WARNING, fmt, ##__VA_ARGS__)
end_define
begin_function
specifier|static
specifier|inline
name|void
DECL|function|scanner_init
name|scanner_init
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|s
operator|->
name|s
operator|=
name|string
expr_stmt|;
name|s
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|s
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|line
operator|=
name|s
operator|->
name|column
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|token_line
operator|=
name|s
operator|->
name|token_column
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|file_name
operator|=
name|file_name
expr_stmt|;
name|s
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|char
DECL|function|peek
name|peek
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|s
operator|->
name|pos
operator|>=
name|s
operator|->
name|len
argument_list|)
condition|)
return|return
literal|'\0'
return|;
return|return
name|s
operator|->
name|s
index|[
name|s
operator|->
name|pos
index|]
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|eof
name|eof
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
operator|->
name|pos
operator|>=
name|s
operator|->
name|len
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|eol
name|eol
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
return|return
name|peek
argument_list|(
name|s
argument_list|)
operator|==
literal|'\n'
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|char
DECL|function|next
name|next
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|eof
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
return|return
literal|'\0'
return|;
if|if
condition|(
name|unlikely
argument_list|(
name|eol
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|s
operator|->
name|line
operator|++
expr_stmt|;
name|s
operator|->
name|column
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|column
operator|++
expr_stmt|;
block|}
return|return
name|s
operator|->
name|s
index|[
name|s
operator|->
name|pos
operator|++
index|]
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|chr
name|chr
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|likely
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
operator|!=
name|ch
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|->
name|pos
operator|++
expr_stmt|;
name|s
operator|->
name|column
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|str
name|str
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|len
operator|-
name|s
operator|->
name|pos
operator|<
name|len
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
operator|->
name|s
operator|+
name|s
operator|->
name|pos
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|s
operator|->
name|pos
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|column
operator|+=
name|len
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_define
DECL|macro|lit
define|#
directive|define
name|lit
parameter_list|(
name|s
parameter_list|,
name|literal
parameter_list|)
value|str(s, literal, sizeof(literal) - 1)
end_define
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|buf_append
name|buf_append
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|buf_pos
operator|+
literal|1
operator|>=
sizeof|sizeof
argument_list|(
name|s
operator|->
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|->
name|buf
index|[
name|s
operator|->
name|buf_pos
operator|++
index|]
operator|=
name|ch
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|oct
name|oct
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|out
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
operator|*
name|out
operator|=
literal|0
init|;
name|peek
argument_list|(
name|s
argument_list|)
operator|>=
literal|'0'
operator|&&
name|peek
argument_list|(
name|s
argument_list|)
operator|<=
literal|'7'
operator|&&
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
operator|*
name|out
operator|=
operator|*
name|out
operator|*
literal|8
operator|+
name|next
argument_list|(
name|s
argument_list|)
operator|-
literal|'0'
expr_stmt|;
return|return
name|i
operator|>
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
end_unit
