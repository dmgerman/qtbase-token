begin_unit
begin_comment
comment|/*  * Copyright (C) 2011 Joseph Adams<joeyadams3.14159@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|CCAN_DARRAY_H
end_ifndef
begin_define
DECL|macro|CCAN_DARRAY_H
define|#
directive|define
name|CCAN_DARRAY_H
end_define
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/*  * SYNOPSIS  *  * Life cycle of a darray (dynamically-allocated array):  *  *     darray(int) a = darray_new();  *     darray_free(a);  *  *     struct {darray(int) a;} foo;  *     darray_init(foo.a);  *     darray_free(foo.a);  *  * Typedefs for darrays of common types:  *  *     darray_char, darray_schar, darray_uchar  *     darray_short, darray_int, darray_long  *     darray_ushort, darray_uint, darray_ulong  *  * Access:  *  *     T      darray_item(darray(T) arr, size_t index);  *     size_t darray_size(darray(T) arr);  *     size_t darray_alloc(darray(T) arr);  *     bool   darray_empty(darray(T) arr);  *  *     // Access raw memory, starting from the item in offset.  *     // Not safe, be careful, etc.  *     T*     darray_mem(darray(T) arr, size_t offset);  *  * Insertion (single item):  *  *     void   darray_append(darray(T) arr, T item);  *     void   darray_prepend(darray(T) arr, T item);  *     void   darray_push(darray(T) arr, T item); // same as darray_append  *  * Insertion (multiple items):  *  *     void   darray_append_items(darray(T) arr, T *items, size_t count);  *     void   darray_prepend_items(darray(T) arr, T *items, size_t count);  *  *     void   darray_appends(darray(T) arr, [T item, [...]]);  *     void   darray_prepends(darray(T) arr, [T item, [...]]);  *  * Removal:  *  *     T      darray_pop(darray(T) arr | darray_size(arr) != 0);  *     T*     darray_pop_check(darray(T*) arr);  *  * Replacement:  *  *     void   darray_from_items(darray(T) arr, T *items, size_t count);  *     void   darray_from_c(darray(T) arr, T c_array[N]);  *  * String buffer:  *  *     void   darray_append_string(darray(char) arr, const char *str);  *     void   darray_append_lit(darray(char) arr, char stringLiteral[N+1]);  *  *     void   darray_prepend_string(darray(char) arr, const char *str);  *     void   darray_prepend_lit(darray(char) arr, char stringLiteral[N+1]);  *  *     void   darray_from_string(darray(T) arr, const char *str);  *     void   darray_from_lit(darray(char) arr, char stringLiteral[N+1]);  *  * Size management:  *  *     void   darray_resize(darray(T) arr, size_t newSize);  *     void   darray_resize0(darray(T) arr, size_t newSize);  *  *     void   darray_realloc(darray(T) arr, size_t newAlloc);  *     void   darray_growalloc(darray(T) arr, size_t newAlloc);  *  * Traversal:  *  *     darray_foreach(T *&i, darray(T) arr) {...}  *     darray_foreach_reverse(T *&i, darray(T) arr) {...}  *  * Except for darray_foreach and darray_foreach_reverse,  * all macros evaluate their non-darray arguments only once.  */
end_comment
begin_comment
comment|/*** Life cycle ***/
end_comment
begin_define
DECL|macro|darray
define|#
directive|define
name|darray
parameter_list|(
name|type
parameter_list|)
value|struct { type *item; size_t size; size_t alloc; }
end_define
begin_define
DECL|macro|darray_new
define|#
directive|define
name|darray_new
parameter_list|()
value|{ 0, 0, 0 }
end_define
begin_define
DECL|macro|darray_init
define|#
directive|define
name|darray_init
parameter_list|(
name|arr
parameter_list|)
value|do { \     (arr).item = 0; (arr).size = 0; (arr).alloc = 0; \ } while (0)
end_define
begin_define
DECL|macro|darray_free
define|#
directive|define
name|darray_free
parameter_list|(
name|arr
parameter_list|)
value|do { \     free((arr).item); darray_init(arr); \ } while (0)
end_define
begin_comment
comment|/*  * Typedefs for darrays of common types.  These are useful  * when you want to pass a pointer to an darray(T) around.  *  * The following will produce an incompatible pointer warning:  *  *     void foo(darray(int) *arr);  *     darray(int) arr = darray_new();  *     foo(&arr);  *  * The workaround:  *  *     void foo(darray_int *arr);  *     darray_int arr = darray_new();  *     foo(&arr);  */
end_comment
begin_typedef
DECL|typedef|darray_char
typedef|typedef
name|darray
argument_list|(
argument|char
argument_list|)
name|darray_char
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_schar
typedef|typedef
name|darray
argument_list|(
argument|signed char
argument_list|)
name|darray_schar
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_uchar
typedef|typedef
name|darray
argument_list|(
argument|unsigned char
argument_list|)
name|darray_uchar
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_short
typedef|typedef
name|darray
argument_list|(
argument|short
argument_list|)
name|darray_short
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_int
typedef|typedef
name|darray
argument_list|(
argument|int
argument_list|)
name|darray_int
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_long
typedef|typedef
name|darray
argument_list|(
argument|long
argument_list|)
name|darray_long
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_ushort
typedef|typedef
name|darray
argument_list|(
argument|unsigned short
argument_list|)
name|darray_ushort
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_uint
typedef|typedef
name|darray
argument_list|(
argument|unsigned int
argument_list|)
name|darray_uint
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_ulong
typedef|typedef
name|darray
argument_list|(
argument|unsigned long
argument_list|)
name|darray_ulong
expr_stmt|;
end_typedef
begin_comment
comment|/*** Access ***/
end_comment
begin_define
DECL|macro|darray_item
define|#
directive|define
name|darray_item
parameter_list|(
name|arr
parameter_list|,
name|i
parameter_list|)
value|((arr).item[i])
end_define
begin_define
DECL|macro|darray_size
define|#
directive|define
name|darray_size
parameter_list|(
name|arr
parameter_list|)
value|((arr).size)
end_define
begin_define
DECL|macro|darray_alloc
define|#
directive|define
name|darray_alloc
parameter_list|(
name|arr
parameter_list|)
value|((arr).alloc)
end_define
begin_define
DECL|macro|darray_empty
define|#
directive|define
name|darray_empty
parameter_list|(
name|arr
parameter_list|)
value|((arr).size == 0)
end_define
begin_define
DECL|macro|darray_mem
define|#
directive|define
name|darray_mem
parameter_list|(
name|arr
parameter_list|,
name|offset
parameter_list|)
value|((arr).item + (offset))
end_define
begin_define
DECL|macro|darray_same
define|#
directive|define
name|darray_same
parameter_list|(
name|arr1
parameter_list|,
name|arr2
parameter_list|)
value|((arr1).item == (arr2).item)
end_define
begin_comment
comment|/*** Insertion (single item) ***/
end_comment
begin_define
DECL|macro|darray_append
define|#
directive|define
name|darray_append
parameter_list|(
name|arr
parameter_list|,
modifier|...
parameter_list|)
value|do { \     darray_resize(arr, (arr).size + 1); \     (arr).item[(arr).size - 1] = (__VA_ARGS__); \ } while (0)
end_define
begin_define
DECL|macro|darray_prepend
define|#
directive|define
name|darray_prepend
parameter_list|(
name|arr
parameter_list|,
modifier|...
parameter_list|)
value|do { \     darray_resize(arr, (arr).size + 1); \     memmove((arr).item + 1, (arr).item, \             ((arr).size - 1) * sizeof(*(arr).item)); \     (arr).item[0] = (__VA_ARGS__); \ } while (0)
end_define
begin_define
DECL|macro|darray_push
define|#
directive|define
name|darray_push
parameter_list|(
name|arr
parameter_list|,
modifier|...
parameter_list|)
value|darray_append(arr, __VA_ARGS__)
end_define
begin_comment
comment|/*** Insertion (multiple items) ***/
end_comment
begin_define
DECL|macro|darray_append_items
define|#
directive|define
name|darray_append_items
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     size_t __count = (count), __oldSize = (arr).size; \     darray_resize(arr, __oldSize + __count); \     memcpy((arr).item + __oldSize, items, __count * sizeof(*(arr).item)); \ } while (0)
end_define
begin_define
DECL|macro|darray_prepend_items
define|#
directive|define
name|darray_prepend_items
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     size_t __count = (count), __oldSize = (arr).size; \     darray_resize(arr, __count + __oldSize); \     memmove((arr).item + __count, (arr).item, \             __oldSize * sizeof(*(arr).item)); \     memcpy((arr).item, items, __count * sizeof(*(arr).item)); \ } while (0)
end_define
begin_define
DECL|macro|darray_append_items_nullterminate
define|#
directive|define
name|darray_append_items_nullterminate
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     size_t __count = (count), __oldSize = (arr).size; \     darray_resize(arr, __oldSize + __count + 1); \     memcpy((arr).item + __oldSize, items, __count * sizeof(*(arr).item)); \     (arr).item[--(arr).size] = 0; \ } while (0)
end_define
begin_define
DECL|macro|darray_prepend_items_nullterminate
define|#
directive|define
name|darray_prepend_items_nullterminate
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     size_t __count = (count), __oldSize = (arr).size; \     darray_resize(arr, __count + __oldSize + 1); \     memmove((arr).item + __count, (arr).item, \             __oldSize * sizeof(*(arr).item)); \     memcpy((arr).item, items, __count * sizeof(*(arr).item)); \     (arr).item[--(arr).size] = 0; \ } while (0)
end_define
begin_define
DECL|macro|darray_appends_t
define|#
directive|define
name|darray_appends_t
parameter_list|(
name|arr
parameter_list|,
name|type
parameter_list|,
modifier|...
parameter_list|)
value|do { \     type __src[] = { __VA_ARGS__ }; \     darray_append_items(arr, __src, sizeof(__src) / sizeof(*__src)); \ } while (0)
end_define
begin_define
DECL|macro|darray_prepends_t
define|#
directive|define
name|darray_prepends_t
parameter_list|(
name|arr
parameter_list|,
name|type
parameter_list|,
modifier|...
parameter_list|)
value|do { \     type __src[] = { __VA_ARGS__ }; \     darray_prepend_items(arr, __src, sizeof(__src) / sizeof(*__src)); \ } while (0)
end_define
begin_comment
comment|/*** Removal ***/
end_comment
begin_comment
comment|/* Warning: Do not call darray_pop on an empty darray. */
end_comment
begin_define
DECL|macro|darray_pop
define|#
directive|define
name|darray_pop
parameter_list|(
name|arr
parameter_list|)
value|((arr).item[--(arr).size])
end_define
begin_define
DECL|macro|darray_pop_check
define|#
directive|define
name|darray_pop_check
parameter_list|(
name|arr
parameter_list|)
value|((arr).size ? darray_pop(arr) : NULL)
end_define
begin_comment
comment|/*** Replacement ***/
end_comment
begin_define
DECL|macro|darray_from_items
define|#
directive|define
name|darray_from_items
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     size_t __count = (count); \     darray_resize(arr, __count); \     memcpy((arr).item, items, __count * sizeof(*(arr).item)); \ } while (0)
end_define
begin_define
DECL|macro|darray_from_c
define|#
directive|define
name|darray_from_c
parameter_list|(
name|arr
parameter_list|,
name|c_array
parameter_list|)
define|\
value|darray_from_items(arr, c_array, sizeof(c_array) / sizeof(*(c_array)))
end_define
begin_define
DECL|macro|darray_copy
define|#
directive|define
name|darray_copy
parameter_list|(
name|arr_to
parameter_list|,
name|arr_from
parameter_list|)
define|\
value|darray_from_items((arr_to), (arr_from).item, (arr_from).size)
end_define
begin_comment
comment|/*** String buffer ***/
end_comment
begin_define
DECL|macro|darray_append_string
define|#
directive|define
name|darray_append_string
parameter_list|(
name|arr
parameter_list|,
name|str
parameter_list|)
value|do { \     const char *__str = (str); \     darray_append_items(arr, __str, strlen(__str) + 1); \     (arr).size--; \ } while (0)
end_define
begin_define
DECL|macro|darray_append_lit
define|#
directive|define
name|darray_append_lit
parameter_list|(
name|arr
parameter_list|,
name|stringLiteral
parameter_list|)
value|do { \     darray_append_items(arr, stringLiteral, sizeof(stringLiteral)); \     (arr).size--; \ } while (0)
end_define
begin_define
DECL|macro|darray_prepend_string
define|#
directive|define
name|darray_prepend_string
parameter_list|(
name|arr
parameter_list|,
name|str
parameter_list|)
value|do { \     const char *__str = (str); \     darray_prepend_items_nullterminate(arr, __str, strlen(__str)); \ } while (0)
end_define
begin_define
DECL|macro|darray_prepend_lit
define|#
directive|define
name|darray_prepend_lit
parameter_list|(
name|arr
parameter_list|,
name|stringLiteral
parameter_list|)
define|\
value|darray_prepend_items_nullterminate(arr, stringLiteral, \                                        sizeof(stringLiteral) - 1)
end_define
begin_define
DECL|macro|darray_from_string
define|#
directive|define
name|darray_from_string
parameter_list|(
name|arr
parameter_list|,
name|str
parameter_list|)
value|do { \     const char *__str = (str); \     darray_from_items(arr, __str, strlen(__str) + 1); \     (arr).size--; \ } while (0)
end_define
begin_define
DECL|macro|darray_from_lit
define|#
directive|define
name|darray_from_lit
parameter_list|(
name|arr
parameter_list|,
name|stringLiteral
parameter_list|)
value|do { \     darray_from_items(arr, stringLiteral, sizeof(stringLiteral)); \     (arr).size--; \ } while (0)
end_define
begin_comment
comment|/*** Size management ***/
end_comment
begin_define
DECL|macro|darray_resize
define|#
directive|define
name|darray_resize
parameter_list|(
name|arr
parameter_list|,
name|newSize
parameter_list|)
define|\
value|darray_growalloc(arr, (arr).size = (newSize))
end_define
begin_define
DECL|macro|darray_resize0
define|#
directive|define
name|darray_resize0
parameter_list|(
name|arr
parameter_list|,
name|newSize
parameter_list|)
value|do { \     size_t __oldSize = (arr).size, __newSize = (newSize); \     (arr).size = __newSize; \     if (__newSize> __oldSize) { \         darray_growalloc(arr, __newSize); \         memset(&(arr).item[__oldSize], 0, \                (__newSize - __oldSize) * sizeof(*(arr).item)); \     } \ } while (0)
end_define
begin_define
DECL|macro|darray_realloc
define|#
directive|define
name|darray_realloc
parameter_list|(
name|arr
parameter_list|,
name|newAlloc
parameter_list|)
value|do { \     (arr).item = realloc((arr).item, \                          ((arr).alloc = (newAlloc)) * sizeof(*(arr).item)); \ } while (0)
end_define
begin_define
DECL|macro|darray_growalloc
define|#
directive|define
name|darray_growalloc
parameter_list|(
name|arr
parameter_list|,
name|need
parameter_list|)
value|do { \     size_t __need = (need); \     if (__need> (arr).alloc) \     darray_realloc(arr, darray_next_alloc((arr).alloc, __need)); \ } while (0)
end_define
begin_function
specifier|static
specifier|inline
name|size_t
DECL|function|darray_next_alloc
name|darray_next_alloc
parameter_list|(
name|size_t
name|alloc
parameter_list|,
name|size_t
name|need
parameter_list|)
block|{
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|alloc
operator|<
name|need
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function
begin_comment
comment|/*** Traversal ***/
end_comment
begin_comment
comment|/*  * darray_foreach(T *&i, darray(T) arr) {...}  *  * Traverse a darray.  `i` must be declared in advance as a pointer to an item.  */
end_comment
begin_define
DECL|macro|darray_foreach
define|#
directive|define
name|darray_foreach
parameter_list|(
name|i
parameter_list|,
name|arr
parameter_list|)
define|\
value|for ((i) =&(arr).item[0]; (i)<&(arr).item[(arr).size]; (i)++)
end_define
begin_define
DECL|macro|darray_foreach_from
define|#
directive|define
name|darray_foreach_from
parameter_list|(
name|i
parameter_list|,
name|arr
parameter_list|,
name|from
parameter_list|)
define|\
value|for ((i) =&(arr).item[from]; (i)<&(arr).item[(arr).size]; (i)++)
end_define
begin_comment
comment|/* Iterate on index and value at the same time, like Python's enumerate. */
end_comment
begin_define
DECL|macro|darray_enumerate
define|#
directive|define
name|darray_enumerate
parameter_list|(
name|idx
parameter_list|,
name|val
parameter_list|,
name|arr
parameter_list|)
define|\
value|for ((idx) = 0, (val) =&(arr).item[0]; \          (idx)< (arr).size; \          (idx)++, (val)++)
end_define
begin_define
DECL|macro|darray_enumerate_from
define|#
directive|define
name|darray_enumerate_from
parameter_list|(
name|idx
parameter_list|,
name|val
parameter_list|,
name|arr
parameter_list|,
name|from
parameter_list|)
define|\
value|for ((idx) = (from), (val) =&(arr).item[0]; \          (idx)< (arr).size; \          (idx)++, (val)++)
end_define
begin_comment
comment|/*  * darray_foreach_reverse(T *&i, darray(T) arr) {...}  *  * Like darray_foreach, but traverse in reverse order.  */
end_comment
begin_define
DECL|macro|darray_foreach_reverse
define|#
directive|define
name|darray_foreach_reverse
parameter_list|(
name|i
parameter_list|,
name|arr
parameter_list|)
define|\
value|for ((i) =&(arr).item[(arr).size]; (i)-->&(arr).item[0]; )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CCAN_DARRAY_H */
end_comment
begin_comment
comment|/*  *  * darray_growalloc(arr, newAlloc) sees if the darray can currently hold newAlloc items;  *      if not, it increases the alloc to satisfy this requirement, allocating slack  *      space to avoid having to reallocate for every size increment.  *  * darray_from_string(arr, str) copies a string to an darray_char.  *  * darray_push(arr, item) pushes an item to the end of the darray.  * darray_pop(arr) pops it back out.  Be sure there is at least one item in the darray before calling.  * darray_pop_check(arr) does the same as darray_pop, but returns NULL if there are no more items left in the darray.  *  * darray_make_room(arr, room) ensures there's 'room' elements of space after the end of the darray, and it returns a pointer to this space.  * Currently requires HAVE_STATEMENT_EXPR, but I plan to remove this dependency by creating an inline function.  *  * The following require HAVE_TYPEOF==1 :  *  * darray_appends(arr, item0, item1...) appends a collection of comma-delimited items to the darray.  * darray_prepends(arr, item0, item1...) prepends a collection of comma-delimited items to the darray.\  *  *  * Examples:  *  *      darray(int)  arr;  *      int        *i;  *  *      darray_appends(arr, 0,1,2,3,4);  *      darray_appends(arr, -5,-4,-3,-2,-1);  *      darray_foreach(i, arr)  *              printf("%d ", *i);  *      printf("\n");  *  *      darray_free(arr);  *  *  *      typedef struct {int n,d;} Fraction;  *      darray(Fraction) fractions;  *      Fraction        *i;  *  *      darray_appends(fractions, {3,4}, {3,5}, {2,1});  *      darray_foreach(i, fractions)  *              printf("%d/%d\n", i->n, i->d);  *  *      darray_free(fractions);  */
end_comment
end_unit
