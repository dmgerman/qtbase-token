begin_unit
begin_comment
comment|/*  * Copyright (C) 2011 Joseph Adams<joeyadams3.14159@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|CCAN_DARRAY_H
end_ifndef
begin_define
DECL|macro|CCAN_DARRAY_H
define|#
directive|define
name|CCAN_DARRAY_H
end_define
begin_comment
comment|/* Originally taken from: http://ccodearchive.net/info/darray.html  * But modified for libxkbcommon. */
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_define
DECL|macro|darray
define|#
directive|define
name|darray
parameter_list|(
name|type
parameter_list|)
value|struct { type *item; unsigned size; unsigned alloc; }
end_define
begin_define
DECL|macro|darray_new
define|#
directive|define
name|darray_new
parameter_list|()
value|{ 0, 0, 0 }
end_define
begin_define
DECL|macro|darray_init
define|#
directive|define
name|darray_init
parameter_list|(
name|arr
parameter_list|)
value|do { \     (arr).item = 0; (arr).size = 0; (arr).alloc = 0; \ } while (0)
end_define
begin_define
DECL|macro|darray_free
define|#
directive|define
name|darray_free
parameter_list|(
name|arr
parameter_list|)
value|do { \     free((arr).item); \     darray_init(arr); \ } while (0)
end_define
begin_comment
comment|/*  * Typedefs for darrays of common types.  These are useful  * when you want to pass a pointer to an darray(T) around.  *  * The following will produce an incompatible pointer warning:  *  *     void foo(darray(int) *arr);  *     darray(int) arr = darray_new();  *     foo(&arr);  *  * The workaround:  *  *     void foo(darray_int *arr);  *     darray_int arr = darray_new();  *     foo(&arr);  */
end_comment
begin_typedef
DECL|typedef|darray_char
typedef|typedef
name|darray
argument_list|(
argument|char
argument_list|)
name|darray_char
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_schar
typedef|typedef
name|darray
argument_list|(
argument|signed char
argument_list|)
name|darray_schar
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_uchar
typedef|typedef
name|darray
argument_list|(
argument|unsigned char
argument_list|)
name|darray_uchar
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_short
typedef|typedef
name|darray
argument_list|(
argument|short
argument_list|)
name|darray_short
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_int
typedef|typedef
name|darray
argument_list|(
argument|int
argument_list|)
name|darray_int
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_long
typedef|typedef
name|darray
argument_list|(
argument|long
argument_list|)
name|darray_long
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_ushort
typedef|typedef
name|darray
argument_list|(
argument|unsigned short
argument_list|)
name|darray_ushort
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_uint
typedef|typedef
name|darray
argument_list|(
argument|unsigned int
argument_list|)
name|darray_uint
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|darray_ulong
typedef|typedef
name|darray
argument_list|(
argument|unsigned long
argument_list|)
name|darray_ulong
expr_stmt|;
end_typedef
begin_comment
comment|/*** Access ***/
end_comment
begin_define
DECL|macro|darray_item
define|#
directive|define
name|darray_item
parameter_list|(
name|arr
parameter_list|,
name|i
parameter_list|)
value|((arr).item[i])
end_define
begin_define
DECL|macro|darray_size
define|#
directive|define
name|darray_size
parameter_list|(
name|arr
parameter_list|)
value|((arr).size)
end_define
begin_define
DECL|macro|darray_empty
define|#
directive|define
name|darray_empty
parameter_list|(
name|arr
parameter_list|)
value|((arr).size == 0)
end_define
begin_define
DECL|macro|darray_mem
define|#
directive|define
name|darray_mem
parameter_list|(
name|arr
parameter_list|,
name|offset
parameter_list|)
value|((arr).item + (offset))
end_define
begin_comment
comment|/*** Insertion (single item) ***/
end_comment
begin_define
DECL|macro|darray_append
define|#
directive|define
name|darray_append
parameter_list|(
name|arr
parameter_list|,
modifier|...
parameter_list|)
value|do { \     darray_resize(arr, (arr).size + 1); \     (arr).item[(arr).size - 1] = (__VA_ARGS__); \ } while (0)
end_define
begin_comment
comment|/*** Insertion (multiple items) ***/
end_comment
begin_define
DECL|macro|darray_append_items
define|#
directive|define
name|darray_append_items
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     unsigned __count = (count), __oldSize = (arr).size; \     darray_resize(arr, __oldSize + __count); \     memcpy((arr).item + __oldSize, items, __count * sizeof(*(arr).item)); \ } while (0)
end_define
begin_define
DECL|macro|darray_from_items
define|#
directive|define
name|darray_from_items
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     unsigned __count = (count); \     darray_resize(arr, __count); \     memcpy((arr).item, items, __count * sizeof(*(arr).item)); \ } while (0)
end_define
begin_define
DECL|macro|darray_copy
define|#
directive|define
name|darray_copy
parameter_list|(
name|arr_to
parameter_list|,
name|arr_from
parameter_list|)
define|\
value|darray_from_items((arr_to), (arr_from).item, (arr_from).size)
end_define
begin_comment
comment|/*** String buffer ***/
end_comment
begin_define
DECL|macro|darray_append_string
define|#
directive|define
name|darray_append_string
parameter_list|(
name|arr
parameter_list|,
name|str
parameter_list|)
value|do { \     const char *__str = (str); \     darray_append_items(arr, __str, strlen(__str) + 1); \     (arr).size--; \ } while (0)
end_define
begin_define
DECL|macro|darray_append_lit
define|#
directive|define
name|darray_append_lit
parameter_list|(
name|arr
parameter_list|,
name|stringLiteral
parameter_list|)
value|do { \     darray_append_items(arr, stringLiteral, sizeof(stringLiteral)); \     (arr).size--; \ } while (0)
end_define
begin_define
DECL|macro|darray_appends_nullterminate
define|#
directive|define
name|darray_appends_nullterminate
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     unsigned __count = (count), __oldSize = (arr).size; \     darray_resize(arr, __oldSize + __count + 1); \     memcpy((arr).item + __oldSize, items, __count * sizeof(*(arr).item)); \     (arr).item[--(arr).size] = 0; \ } while (0)
end_define
begin_define
DECL|macro|darray_prepends_nullterminate
define|#
directive|define
name|darray_prepends_nullterminate
parameter_list|(
name|arr
parameter_list|,
name|items
parameter_list|,
name|count
parameter_list|)
value|do { \     unsigned __count = (count), __oldSize = (arr).size; \     darray_resize(arr, __count + __oldSize + 1); \     memmove((arr).item + __count, (arr).item, \             __oldSize * sizeof(*(arr).item)); \     memcpy((arr).item, items, __count * sizeof(*(arr).item)); \     (arr).item[--(arr).size] = 0; \ } while (0)
end_define
begin_comment
comment|/*** Size management ***/
end_comment
begin_define
DECL|macro|darray_resize
define|#
directive|define
name|darray_resize
parameter_list|(
name|arr
parameter_list|,
name|newSize
parameter_list|)
define|\
value|darray_growalloc(arr, (arr).size = (newSize))
end_define
begin_define
DECL|macro|darray_resize0
define|#
directive|define
name|darray_resize0
parameter_list|(
name|arr
parameter_list|,
name|newSize
parameter_list|)
value|do { \     unsigned __oldSize = (arr).size, __newSize = (newSize); \     (arr).size = __newSize; \     if (__newSize> __oldSize) { \         darray_growalloc(arr, __newSize); \         memset(&(arr).item[__oldSize], 0, \                (__newSize - __oldSize) * sizeof(*(arr).item)); \     } \ } while (0)
end_define
begin_define
DECL|macro|darray_realloc
define|#
directive|define
name|darray_realloc
parameter_list|(
name|arr
parameter_list|,
name|newAlloc
parameter_list|)
value|do { \     (arr).item = realloc((arr).item, \                          ((arr).alloc = (newAlloc)) * sizeof(*(arr).item)); \ } while (0)
end_define
begin_define
DECL|macro|darray_growalloc
define|#
directive|define
name|darray_growalloc
parameter_list|(
name|arr
parameter_list|,
name|need
parameter_list|)
value|do { \     unsigned __need = (need); \     if (__need> (arr).alloc) \         darray_realloc(arr, darray_next_alloc((arr).alloc, __need, \                                               sizeof(*(arr).item))); \ } while (0)
end_define
begin_function
specifier|static
specifier|inline
name|unsigned
DECL|function|darray_next_alloc
name|darray_next_alloc
parameter_list|(
name|unsigned
name|alloc
parameter_list|,
name|unsigned
name|need
parameter_list|,
name|unsigned
name|itemSize
parameter_list|)
block|{
name|assert
argument_list|(
name|need
operator|<
name|UINT_MAX
operator|/
name|itemSize
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Overflow. */
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|alloc
operator|<
name|need
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function
begin_comment
comment|/*** Traversal ***/
end_comment
begin_define
DECL|macro|darray_foreach
define|#
directive|define
name|darray_foreach
parameter_list|(
name|i
parameter_list|,
name|arr
parameter_list|)
define|\
value|for ((i) =&(arr).item[0]; (i)<&(arr).item[(arr).size]; (i)++)
end_define
begin_define
DECL|macro|darray_foreach_from
define|#
directive|define
name|darray_foreach_from
parameter_list|(
name|i
parameter_list|,
name|arr
parameter_list|,
name|from
parameter_list|)
define|\
value|for ((i) =&(arr).item[from]; (i)<&(arr).item[(arr).size]; (i)++)
end_define
begin_comment
comment|/* Iterate on index and value at the same time, like Python's enumerate. */
end_comment
begin_define
DECL|macro|darray_enumerate
define|#
directive|define
name|darray_enumerate
parameter_list|(
name|idx
parameter_list|,
name|val
parameter_list|,
name|arr
parameter_list|)
define|\
value|for ((idx) = 0, (val) =&(arr).item[0]; \          (idx)< (arr).size; \          (idx)++, (val)++)
end_define
begin_define
DECL|macro|darray_enumerate_from
define|#
directive|define
name|darray_enumerate_from
parameter_list|(
name|idx
parameter_list|,
name|val
parameter_list|,
name|arr
parameter_list|,
name|from
parameter_list|)
define|\
value|for ((idx) = (from), (val) =&(arr).item[0]; \          (idx)< (arr).size; \          (idx)++, (val)++)
end_define
begin_define
DECL|macro|darray_foreach_reverse
define|#
directive|define
name|darray_foreach_reverse
parameter_list|(
name|i
parameter_list|,
name|arr
parameter_list|)
define|\
value|for ((i) =&(arr).item[(arr).size]; (i)-->&(arr).item[0]; )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CCAN_DARRAY_H */
end_comment
end_unit
