begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"include.h"
end_include
begin_comment
comment|/**  * Parse an include statement. Each call returns a file name, along with  * (possibly) a specific map in the file, an explicit group designator, and  * the separator from the next file, used to determine the merge mode.  *  * @param str_inout Input statement, modified in-place. Should be passed in  * repeatedly. If str_inout is NULL, the parsing has completed.  *  * @param file_rtrn Set to the name of the include file to be used. Combined  * with an enum xkb_file_type, this determines which file to look for in the  * include path.  *  * @param map_rtrn Set to the string between '(' and ')', if any. This will  * result in the compilation of a specific named map within the file (e.g.  * xkb_symbols "basic" { ... }) , as opposed to the default map of the file.  *  * @param nextop_rtrn Set to the next operation in the complete statement,  * which is '\0' if it's the last file or '+' or '|' if there are more.  * Separating the files with '+' sets the merge mode to MERGE_MODE_OVERRIDE,  * while '|' sets the merge mode to MERGE_MODE_AUGMENT.  *  * @param extra_data Set to the string after ':', if any. Currently the  * extra data is only used for setting an explicit group index for a symbols  * file.  *  * @return true if parsing was successful, false for an illegal string.  *  * Example: "evdev+aliases(qwerty):2"  *      str_inout = "aliases(qwerty):2"  *      file_rtrn = "evdev"  *      map_rtrn = NULL  *      nextop_retrn = "+"  *      extra_data = NULL  *  * 2nd run with "aliases(qwerty):2"  *      str_inout = NULL  *      file_rtrn = "aliases"  *      map_rtrn = "qwerty"  *      nextop_retrn = ""  *      extra_data = "2"  *  */
end_comment
begin_function
name|bool
DECL|function|ParseIncludeMap
name|ParseIncludeMap
parameter_list|(
name|char
modifier|*
modifier|*
name|str_inout
parameter_list|,
name|char
modifier|*
modifier|*
name|file_rtrn
parameter_list|,
name|char
modifier|*
modifier|*
name|map_rtrn
parameter_list|,
name|char
modifier|*
name|nextop_rtrn
parameter_list|,
name|char
modifier|*
modifier|*
name|extra_data
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|str
operator|=
operator|*
name|str_inout
expr_stmt|;
comment|/*      * Find the position in the string where the next file is included,      * if there is more than one left in the statement.      */
name|next
operator|=
name|strpbrk
argument_list|(
name|str
argument_list|,
literal|"|+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
comment|/* Got more files, this function will be called again. */
operator|*
name|nextop_rtrn
operator|=
operator|*
name|next
expr_stmt|;
comment|/* Separate the string, for strchr etc. to work on this file only. */
operator|*
name|next
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the last file in this statement, won't be called again. */
operator|*
name|nextop_rtrn
operator|=
literal|'\0'
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Search for the explicit group designator, if any. If it's there,      * it goes after the file name and map.      */
name|tmp
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|extra_data
operator|=
name|strdup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|extra_data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Look for a map, if any. */
name|tmp
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
comment|/* No map. */
operator|*
name|file_rtrn
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
name|map_rtrn
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* Map without file - invalid. */
name|free
argument_list|(
operator|*
name|extra_data
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* Got a map; separate the file and the map for the strdup's. */
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|file_rtrn
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
name|tmp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|free
argument_list|(
operator|*
name|file_rtrn
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|extra_data
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|map_rtrn
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the next file for the next call, if any. */
if|if
condition|(
operator|*
name|nextop_rtrn
operator|==
literal|'\0'
condition|)
operator|*
name|str_inout
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|nextop_rtrn
operator|==
literal|'|'
operator|||
operator|*
name|nextop_rtrn
operator|==
literal|'+'
condition|)
operator|*
name|str_inout
operator|=
name|next
expr_stmt|;
else|else
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|xkb_file_type_include_dirs
specifier|static
specifier|const
name|char
modifier|*
name|xkb_file_type_include_dirs
index|[
name|_FILE_TYPE_NUM_ENTRIES
index|]
init|=
block|{
index|[
name|FILE_TYPE_KEYCODES
index|]
operator|=
literal|"keycodes"
block|,
index|[
name|FILE_TYPE_TYPES
index|]
operator|=
literal|"types"
block|,
index|[
name|FILE_TYPE_COMPAT
index|]
operator|=
literal|"compat"
block|,
index|[
name|FILE_TYPE_SYMBOLS
index|]
operator|=
literal|"symbols"
block|,
index|[
name|FILE_TYPE_GEOMETRY
index|]
operator|=
literal|"geometry"
block|,
index|[
name|FILE_TYPE_KEYMAP
index|]
operator|=
literal|"keymap"
block|,
index|[
name|FILE_TYPE_RULES
index|]
operator|=
literal|"rules"
block|, }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/**  * Return the xkb directory based on the type.  */
end_comment
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|DirectoryForInclude
name|DirectoryForInclude
parameter_list|(
name|enum
name|xkb_file_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|_FILE_TYPE_NUM_ENTRIES
condition|)
return|return
literal|""
return|;
return|return
name|xkb_file_type_include_dirs
index|[
name|type
index|]
return|;
block|}
end_function
begin_function
name|FILE
modifier|*
DECL|function|FindFileInXkbPath
name|FindFileInXkbPath
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|xkb_file_type
name|type
parameter_list|,
name|char
modifier|*
modifier|*
name|pathRtrn
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|typeDir
decl_stmt|;
name|typeDir
operator|=
name|DirectoryForInclude
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xkb_context_num_include_paths
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ret
init|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|xkb_context_include_path_get
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
argument_list|,
name|typeDir
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"File name (%s/%s/%s) too long\n"
argument_list|,
name|xkb_context_include_path_get
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
argument_list|,
name|typeDir
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|file
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Couldn't find file \"%s/%s\" in include paths\n"
argument_list|,
name|typeDir
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xkb_context_num_include_paths
argument_list|(
name|ctx
argument_list|)
operator|>
literal|0
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"%d include paths searched:\n"
argument_list|,
name|xkb_context_num_include_paths
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xkb_context_num_include_paths
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
control|)
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"\t%s\n"
argument_list|,
name|xkb_context_include_path_get
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"There are no include paths to search\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xkb_context_num_failed_include_paths
argument_list|(
name|ctx
argument_list|)
operator|>
literal|0
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"%d include paths could not be added:\n"
argument_list|,
name|xkb_context_num_failed_include_paths
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xkb_context_num_failed_include_paths
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
control|)
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"\t%s\n"
argument_list|,
name|xkb_context_failed_include_path_get
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|pathRtrn
condition|)
operator|*
name|pathRtrn
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
end_function
begin_function
name|XkbFile
modifier|*
DECL|function|ProcessIncludeFile
name|ProcessIncludeFile
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|IncludeStmt
modifier|*
name|stmt
parameter_list|,
name|enum
name|xkb_file_type
name|file_type
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|XkbFile
modifier|*
name|xkb_file
decl_stmt|;
name|file
operator|=
name|FindFileInXkbPath
argument_list|(
name|ctx
argument_list|,
name|stmt
operator|->
name|file
argument_list|,
name|file_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return
name|false
return|;
name|xkb_file
operator|=
name|XkbParseFile
argument_list|(
name|ctx
argument_list|,
name|file
argument_list|,
name|stmt
operator|->
name|file
argument_list|,
name|stmt
operator|->
name|map
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xkb_file
condition|)
block|{
if|if
condition|(
name|stmt
operator|->
name|map
condition|)
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Couldn't process include statement for '%s(%s)'\n"
argument_list|,
name|stmt
operator|->
name|file
argument_list|,
name|stmt
operator|->
name|map
argument_list|)
expr_stmt|;
else|else
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Couldn't process include statement for '%s'\n"
argument_list|,
name|stmt
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|xkb_file
operator|->
name|file_type
operator|!=
name|file_type
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Include file wrong type (expected %s, got %s); "
literal|"Include file \"%s\" ignored\n"
argument_list|,
name|xkb_file_type_to_string
argument_list|(
name|file_type
argument_list|)
argument_list|,
name|xkb_file_type_to_string
argument_list|(
name|xkb_file
operator|->
name|file_type
argument_list|)
argument_list|,
name|stmt
operator|->
name|file
argument_list|)
expr_stmt|;
name|FreeXkbFile
argument_list|(
name|xkb_file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* FIXME: we have to check recursive includes here (or somewhere) */
return|return
name|xkb_file
return|;
block|}
end_function
end_unit
