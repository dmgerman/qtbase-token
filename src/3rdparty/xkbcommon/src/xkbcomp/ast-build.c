begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  *         Ran Benita<ran234@gmail.com>  */
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"ast-build.h"
end_include
begin_include
include|#
directive|include
file|"parser-priv.h"
end_include
begin_include
include|#
directive|include
file|"include.h"
end_include
begin_function
name|ParseCommon
modifier|*
DECL|function|AppendStmt
name|AppendStmt
parameter_list|(
name|ParseCommon
modifier|*
name|to
parameter_list|,
name|ParseCommon
modifier|*
name|append
parameter_list|)
block|{
name|ParseCommon
modifier|*
name|iter
decl_stmt|;
if|if
condition|(
operator|!
name|to
condition|)
return|return
name|append
return|;
for|for
control|(
name|iter
operator|=
name|to
init|;
name|iter
operator|->
name|next
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
empty_stmt|;
name|iter
operator|->
name|next
operator|=
name|append
expr_stmt|;
return|return
name|to
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|ExprCreate
name|ExprCreate
parameter_list|(
name|enum
name|expr_op_type
name|op
parameter_list|,
name|enum
name|expr_value_type
name|type
parameter_list|)
block|{
name|ExprDef
modifier|*
name|expr
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|NULL
return|;
name|expr
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_EXPR
expr_stmt|;
name|expr
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|expr
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|expr
operator|->
name|value_type
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|ExprCreateUnary
name|ExprCreateUnary
parameter_list|(
name|enum
name|expr_op_type
name|op
parameter_list|,
name|enum
name|expr_value_type
name|type
parameter_list|,
name|ExprDef
modifier|*
name|child
parameter_list|)
block|{
name|ExprDef
modifier|*
name|expr
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|NULL
return|;
name|expr
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_EXPR
expr_stmt|;
name|expr
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|expr
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|expr
operator|->
name|value_type
operator|=
name|type
expr_stmt|;
name|expr
operator|->
name|value
operator|.
name|child
operator|=
name|child
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|ExprCreateBinary
name|ExprCreateBinary
parameter_list|(
name|enum
name|expr_op_type
name|op
parameter_list|,
name|ExprDef
modifier|*
name|left
parameter_list|,
name|ExprDef
modifier|*
name|right
parameter_list|)
block|{
name|ExprDef
modifier|*
name|expr
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|NULL
return|;
name|expr
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_EXPR
expr_stmt|;
name|expr
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|expr
operator|->
name|op
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|EXPR_ASSIGN
operator|||
name|left
operator|->
name|value_type
operator|==
name|EXPR_TYPE_UNKNOWN
condition|)
name|expr
operator|->
name|value_type
operator|=
name|right
operator|->
name|value_type
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|->
name|value_type
operator|==
name|right
operator|->
name|value_type
operator|||
name|right
operator|->
name|value_type
operator|==
name|EXPR_TYPE_UNKNOWN
condition|)
name|expr
operator|->
name|value_type
operator|=
name|left
operator|->
name|value_type
expr_stmt|;
else|else
name|expr
operator|->
name|value_type
operator|=
name|EXPR_TYPE_UNKNOWN
expr_stmt|;
name|expr
operator|->
name|value
operator|.
name|binary
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|expr
operator|->
name|value
operator|.
name|binary
operator|.
name|right
operator|=
name|right
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function
begin_function
name|KeycodeDef
modifier|*
DECL|function|KeycodeCreate
name|KeycodeCreate
parameter_list|(
name|xkb_atom_t
name|name
parameter_list|,
name|int64_t
name|value
parameter_list|)
block|{
name|KeycodeDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_KEYCODE
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|def
operator|->
name|value
operator|=
name|value
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|KeyAliasDef
modifier|*
DECL|function|KeyAliasCreate
name|KeyAliasCreate
parameter_list|(
name|xkb_atom_t
name|alias
parameter_list|,
name|xkb_atom_t
name|real
parameter_list|)
block|{
name|KeyAliasDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_ALIAS
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|alias
operator|=
name|alias
expr_stmt|;
name|def
operator|->
name|real
operator|=
name|real
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|VModDef
modifier|*
DECL|function|VModCreate
name|VModCreate
parameter_list|(
name|xkb_atom_t
name|name
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|VModDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_VMOD
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|def
operator|->
name|value
operator|=
name|value
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|VarDef
modifier|*
DECL|function|VarCreate
name|VarCreate
parameter_list|(
name|ExprDef
modifier|*
name|name
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|VarDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_VAR
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|def
operator|->
name|value
operator|=
name|value
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|VarDef
modifier|*
DECL|function|BoolVarCreate
name|BoolVarCreate
parameter_list|(
name|xkb_atom_t
name|nameToken
parameter_list|,
name|unsigned
name|set
parameter_list|)
block|{
name|ExprDef
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|VarDef
modifier|*
name|def
decl_stmt|;
name|name
operator|=
name|ExprCreate
argument_list|(
name|EXPR_IDENT
argument_list|,
name|EXPR_TYPE_UNKNOWN
argument_list|)
expr_stmt|;
name|name
operator|->
name|value
operator|.
name|str
operator|=
name|nameToken
expr_stmt|;
name|value
operator|=
name|ExprCreate
argument_list|(
name|EXPR_VALUE
argument_list|,
name|EXPR_TYPE_BOOLEAN
argument_list|)
expr_stmt|;
name|value
operator|->
name|value
operator|.
name|uval
operator|=
name|set
expr_stmt|;
name|def
operator|=
name|VarCreate
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|InterpDef
modifier|*
DECL|function|InterpCreate
name|InterpCreate
parameter_list|(
name|char
modifier|*
name|sym
parameter_list|,
name|ExprDef
modifier|*
name|match
parameter_list|)
block|{
name|InterpDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_INTERP
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|def
operator|->
name|match
operator|=
name|match
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|KeyTypeDef
modifier|*
DECL|function|KeyTypeCreate
name|KeyTypeCreate
parameter_list|(
name|xkb_atom_t
name|name
parameter_list|,
name|VarDef
modifier|*
name|body
parameter_list|)
block|{
name|KeyTypeDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_TYPE
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|merge
operator|=
name|MERGE_DEFAULT
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|def
operator|->
name|body
operator|=
name|body
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|SymbolsDef
modifier|*
DECL|function|SymbolsCreate
name|SymbolsCreate
parameter_list|(
name|xkb_atom_t
name|keyName
parameter_list|,
name|ExprDef
modifier|*
name|symbols
parameter_list|)
block|{
name|SymbolsDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_SYMBOLS
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|merge
operator|=
name|MERGE_DEFAULT
expr_stmt|;
name|def
operator|->
name|keyName
operator|=
name|keyName
expr_stmt|;
name|def
operator|->
name|symbols
operator|=
name|symbols
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|GroupCompatDef
modifier|*
DECL|function|GroupCompatCreate
name|GroupCompatCreate
parameter_list|(
name|int
name|group
parameter_list|,
name|ExprDef
modifier|*
name|val
parameter_list|)
block|{
name|GroupCompatDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_GROUP_COMPAT
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|merge
operator|=
name|MERGE_DEFAULT
expr_stmt|;
name|def
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|def
operator|->
name|def
operator|=
name|val
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|ModMapDef
modifier|*
DECL|function|ModMapCreate
name|ModMapCreate
parameter_list|(
name|uint32_t
name|modifier
parameter_list|,
name|ExprDef
modifier|*
name|keys
parameter_list|)
block|{
name|ModMapDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_MODMAP
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|merge
operator|=
name|MERGE_DEFAULT
expr_stmt|;
name|def
operator|->
name|modifier
operator|=
name|modifier
expr_stmt|;
name|def
operator|->
name|keys
operator|=
name|keys
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|LedMapDef
modifier|*
DECL|function|LedMapCreate
name|LedMapCreate
parameter_list|(
name|xkb_atom_t
name|name
parameter_list|,
name|VarDef
modifier|*
name|body
parameter_list|)
block|{
name|LedMapDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_LED_MAP
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|merge
operator|=
name|MERGE_DEFAULT
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|def
operator|->
name|body
operator|=
name|body
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|LedNameDef
modifier|*
DECL|function|LedNameCreate
name|LedNameCreate
parameter_list|(
name|int
name|ndx
parameter_list|,
name|ExprDef
modifier|*
name|name
parameter_list|,
name|bool
name|virtual
parameter_list|)
block|{
name|LedNameDef
modifier|*
name|def
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|NULL
return|;
name|def
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_LED_NAME
expr_stmt|;
name|def
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|merge
operator|=
name|MERGE_DEFAULT
expr_stmt|;
name|def
operator|->
name|ndx
operator|=
name|ndx
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|def
operator|->
name|virtual
operator|=
name|virtual
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|ActionCreate
name|ActionCreate
parameter_list|(
name|xkb_atom_t
name|name
parameter_list|,
name|ExprDef
modifier|*
name|args
parameter_list|)
block|{
name|ExprDef
modifier|*
name|act
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|act
condition|)
return|return
name|NULL
return|;
name|act
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_EXPR
expr_stmt|;
name|act
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|act
operator|->
name|op
operator|=
name|EXPR_ACTION_DECL
expr_stmt|;
name|act
operator|->
name|value
operator|.
name|action
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|act
operator|->
name|value
operator|.
name|action
operator|.
name|args
operator|=
name|args
expr_stmt|;
return|return
name|act
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|CreateKeysymList
name|CreateKeysymList
parameter_list|(
name|char
modifier|*
name|sym
parameter_list|)
block|{
name|ExprDef
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|ExprCreate
argument_list|(
name|EXPR_KEYSYM_LIST
argument_list|,
name|EXPR_TYPE_SYMBOLS
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|def
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|def
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|def
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|def
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|def
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|def
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|def
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|CreateMultiKeysymList
name|CreateMultiKeysymList
parameter_list|(
name|ExprDef
modifier|*
name|list
parameter_list|)
block|{
name|size_t
name|nLevels
init|=
name|darray_size
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|)
decl_stmt|;
name|darray_resize
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|darray_resize
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|darray_item
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|darray_item
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|,
literal|0
argument_list|)
operator|=
name|nLevels
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|AppendKeysymList
name|AppendKeysymList
parameter_list|(
name|ExprDef
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|sym
parameter_list|)
block|{
name|size_t
name|nSyms
init|=
name|darray_size
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|)
decl_stmt|;
name|darray_append
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|,
name|nSyms
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|,
name|sym
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
name|ExprDef
modifier|*
DECL|function|AppendMultiKeysymList
name|AppendMultiKeysymList
parameter_list|(
name|ExprDef
modifier|*
name|list
parameter_list|,
name|ExprDef
modifier|*
name|append
parameter_list|)
block|{
name|size_t
name|nSyms
init|=
name|darray_size
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|)
decl_stmt|;
name|size_t
name|numEntries
init|=
name|darray_size
argument_list|(
name|append
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|)
decl_stmt|;
name|darray_append
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|,
name|nSyms
argument_list|)
expr_stmt|;
name|darray_append
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|,
name|numEntries
argument_list|)
expr_stmt|;
name|darray_append_items
argument_list|(
name|list
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|,
name|darray_mem
argument_list|(
name|append
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|,
literal|0
argument_list|)
argument_list|,
name|numEntries
argument_list|)
expr_stmt|;
name|darray_resize
argument_list|(
name|append
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FreeStmt
argument_list|(
operator|&
name|append
operator|->
name|common
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|FreeInclude
parameter_list|(
name|IncludeStmt
modifier|*
name|incl
parameter_list|)
function_decl|;
end_function_decl
begin_function
name|IncludeStmt
modifier|*
DECL|function|IncludeCreate
name|IncludeCreate
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|IncludeStmt
modifier|*
name|incl
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|map
decl_stmt|,
modifier|*
name|stmt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|extra_data
decl_stmt|;
name|char
name|nextop
decl_stmt|;
name|incl
operator|=
name|first
operator|=
name|NULL
expr_stmt|;
name|file
operator|=
name|map
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|=
name|str
expr_stmt|;
name|stmt
operator|=
name|strdup_safe
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
operator|&&
operator|*
name|tmp
condition|)
block|{
if|if
condition|(
operator|!
name|ParseIncludeMap
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nextop
argument_list|,
operator|&
name|extra_data
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/*          * Given an RMLVO (here layout) like 'us,,fr', the rules parser          * will give out something like 'pc+us+:2+fr:3+inet(evdev)'.          * We should just skip the ':2' in this case and leave it to the          * appropriate section to deal with the empty group.          */
if|if
condition|(
name|isempty
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra_data
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|first
operator|=
name|incl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|incl
operator|->
name|next_incl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|incl
operator|=
name|incl
operator|->
name|next_incl
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|incl
condition|)
block|{
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Allocation failure in IncludeCreate; "
literal|"Using only part of the include\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|incl
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_INCLUDE
expr_stmt|;
name|incl
operator|->
name|common
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|incl
operator|->
name|merge
operator|=
name|merge
expr_stmt|;
name|incl
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
name|incl
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|incl
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|incl
operator|->
name|modifier
operator|=
name|extra_data
expr_stmt|;
name|incl
operator|->
name|next_incl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nextop
operator|==
literal|'|'
condition|)
name|merge
operator|=
name|MERGE_AUGMENT
expr_stmt|;
else|else
name|merge
operator|=
name|MERGE_OVERRIDE
expr_stmt|;
block|}
if|if
condition|(
name|first
condition|)
name|first
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
else|else
name|free
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
return|return
name|first
return|;
name|err
label|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Illegal include statement \"%s\"; Ignored\n"
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|FreeInclude
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|EscapeMapName
name|EscapeMapName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/*      * All latin-1 alphanumerics, plus parens, slash, minus, underscore and      * wildcards.      */
specifier|static
specifier|const
name|unsigned
name|char
name|legal
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xa7
block|,
literal|0xff
block|,
literal|0x83
block|,
literal|0xfe
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x87
block|,
literal|0xfe
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x07
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
while|while
condition|(
operator|*
name|name
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|legal
index|[
operator|*
name|name
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
operator|*
name|name
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
operator|*
name|name
operator|=
literal|'_'
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
name|XkbFile
modifier|*
DECL|function|XkbFileCreate
name|XkbFileCreate
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_file_type
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|ParseCommon
modifier|*
name|defs
parameter_list|,
name|enum
name|xkb_map_flags
name|flags
parameter_list|)
block|{
name|XkbFile
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return
name|NULL
return|;
name|EscapeMapName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|file
operator|->
name|file_type
operator|=
name|type
expr_stmt|;
name|file
operator|->
name|topName
operator|=
name|strdup_safe
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|file
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|file
operator|->
name|defs
operator|=
name|defs
expr_stmt|;
name|file
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
name|file
return|;
block|}
end_function
begin_function
name|XkbFile
modifier|*
DECL|function|XkbFileFromComponents
name|XkbFileFromComponents
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|struct
name|xkb_component_names
modifier|*
name|kkctgs
parameter_list|)
block|{
name|char
modifier|*
specifier|const
name|components
index|[]
init|=
block|{
name|kkctgs
operator|->
name|keycodes
block|,
name|kkctgs
operator|->
name|types
block|,
name|kkctgs
operator|->
name|compat
block|,
name|kkctgs
operator|->
name|symbols
block|,     }
decl_stmt|;
name|enum
name|xkb_file_type
name|type
decl_stmt|;
name|IncludeStmt
modifier|*
name|include
init|=
name|NULL
decl_stmt|;
name|XkbFile
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|ParseCommon
modifier|*
name|defs
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|type
operator|=
name|FIRST_KEYMAP_FILE_TYPE
init|;
name|type
operator|<=
name|LAST_KEYMAP_FILE_TYPE
condition|;
name|type
operator|++
control|)
block|{
name|include
operator|=
name|IncludeCreate
argument_list|(
name|ctx
argument_list|,
name|components
index|[
name|type
index|]
argument_list|,
name|MERGE_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|include
condition|)
goto|goto
name|err
goto|;
name|file
operator|=
name|XkbFileCreate
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
operator|&
name|include
operator|->
name|common
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|FreeInclude
argument_list|(
name|include
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|defs
operator|=
name|AppendStmt
argument_list|(
name|defs
argument_list|,
operator|&
name|file
operator|->
name|common
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|XkbFileCreate
argument_list|(
name|ctx
argument_list|,
name|FILE_TYPE_KEYMAP
argument_list|,
name|NULL
argument_list|,
name|defs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
goto|goto
name|err
goto|;
return|return
name|file
return|;
name|err
label|:
name|FreeXkbFile
argument_list|(
operator|(
name|XkbFile
operator|*
operator|)
name|defs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|FreeExpr
name|FreeExpr
parameter_list|(
name|ExprDef
modifier|*
name|expr
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return;
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
case|case
name|EXPR_ACTION_LIST
case|:
case|case
name|EXPR_NEGATE
case|:
case|case
name|EXPR_UNARY_PLUS
case|:
case|case
name|EXPR_NOT
case|:
case|case
name|EXPR_INVERT
case|:
name|FreeStmt
argument_list|(
operator|&
name|expr
operator|->
name|value
operator|.
name|child
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_DIVIDE
case|:
case|case
name|EXPR_ADD
case|:
case|case
name|EXPR_SUBTRACT
case|:
case|case
name|EXPR_MULTIPLY
case|:
case|case
name|EXPR_ASSIGN
case|:
name|FreeStmt
argument_list|(
operator|&
name|expr
operator|->
name|value
operator|.
name|binary
operator|.
name|left
operator|->
name|common
argument_list|)
expr_stmt|;
name|FreeStmt
argument_list|(
operator|&
name|expr
operator|->
name|value
operator|.
name|binary
operator|.
name|right
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_ACTION_DECL
case|:
name|FreeStmt
argument_list|(
operator|&
name|expr
operator|->
name|value
operator|.
name|action
operator|.
name|args
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_ARRAY_REF
case|:
name|FreeStmt
argument_list|(
operator|&
name|expr
operator|->
name|value
operator|.
name|array
operator|.
name|entry
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_KEYSYM_LIST
case|:
name|darray_foreach
argument_list|(
argument|sym
argument_list|,
argument|expr->value.list.syms
argument_list|)
name|free
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|expr
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|expr
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|expr
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|FreeInclude
name|FreeInclude
parameter_list|(
name|IncludeStmt
modifier|*
name|incl
parameter_list|)
block|{
name|IncludeStmt
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|incl
condition|)
block|{
name|next
operator|=
name|incl
operator|->
name|next_incl
expr_stmt|;
name|free
argument_list|(
name|incl
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|incl
operator|->
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|incl
operator|->
name|modifier
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|incl
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|incl
argument_list|)
expr_stmt|;
name|incl
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
DECL|function|FreeStmt
name|FreeStmt
parameter_list|(
name|ParseCommon
modifier|*
name|stmt
parameter_list|)
block|{
name|ParseCommon
modifier|*
name|next
decl_stmt|;
name|YYSTYPE
name|u
decl_stmt|;
while|while
condition|(
name|stmt
condition|)
block|{
name|next
operator|=
name|stmt
operator|->
name|next
expr_stmt|;
name|u
operator|.
name|any
operator|=
name|stmt
expr_stmt|;
switch|switch
condition|(
name|stmt
operator|->
name|type
condition|)
block|{
case|case
name|STMT_INCLUDE
case|:
name|FreeInclude
argument_list|(
operator|(
name|IncludeStmt
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
comment|/* stmt is already free'd here. */
name|stmt
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|STMT_EXPR
case|:
name|FreeExpr
argument_list|(
name|u
operator|.
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_VAR
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|var
operator|->
name|name
operator|->
name|common
argument_list|)
expr_stmt|;
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|var
operator|->
name|value
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_TYPE
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|keyType
operator|->
name|body
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_INTERP
case|:
name|free
argument_list|(
name|u
operator|.
name|interp
operator|->
name|sym
argument_list|)
expr_stmt|;
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|interp
operator|->
name|match
operator|->
name|common
argument_list|)
expr_stmt|;
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|interp
operator|->
name|def
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_VMOD
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|vmod
operator|->
name|value
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_SYMBOLS
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|syms
operator|->
name|symbols
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_MODMAP
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|modMask
operator|->
name|keys
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_GROUP_COMPAT
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|groupCompat
operator|->
name|def
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_LED_MAP
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|ledMap
operator|->
name|body
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_LED_NAME
case|:
name|FreeStmt
argument_list|(
operator|&
name|u
operator|.
name|ledName
operator|->
name|name
operator|->
name|common
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
DECL|function|FreeXkbFile
name|FreeXkbFile
parameter_list|(
name|XkbFile
modifier|*
name|file
parameter_list|)
block|{
name|XkbFile
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|file
condition|)
block|{
name|next
operator|=
operator|(
name|XkbFile
operator|*
operator|)
name|file
operator|->
name|common
operator|.
name|next
expr_stmt|;
switch|switch
condition|(
name|file
operator|->
name|file_type
condition|)
block|{
case|case
name|FILE_TYPE_KEYMAP
case|:
name|FreeXkbFile
argument_list|(
operator|(
name|XkbFile
operator|*
operator|)
name|file
operator|->
name|defs
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE_TYPES
case|:
case|case
name|FILE_TYPE_COMPAT
case|:
case|case
name|FILE_TYPE_SYMBOLS
case|:
case|case
name|FILE_TYPE_KEYCODES
case|:
case|case
name|FILE_TYPE_GEOMETRY
case|:
name|FreeStmt
argument_list|(
name|file
operator|->
name|defs
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
operator|->
name|topName
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|xkb_file_type_strings
specifier|static
specifier|const
name|char
modifier|*
name|xkb_file_type_strings
index|[
name|_FILE_TYPE_NUM_ENTRIES
index|]
init|=
block|{
index|[
name|FILE_TYPE_KEYCODES
index|]
operator|=
literal|"xkb_keycodes"
block|,
index|[
name|FILE_TYPE_TYPES
index|]
operator|=
literal|"xkb_types"
block|,
index|[
name|FILE_TYPE_COMPAT
index|]
operator|=
literal|"xkb_compatibility"
block|,
index|[
name|FILE_TYPE_SYMBOLS
index|]
operator|=
literal|"xkb_symbols"
block|,
index|[
name|FILE_TYPE_GEOMETRY
index|]
operator|=
literal|"xkb_geometry"
block|,
index|[
name|FILE_TYPE_KEYMAP
index|]
operator|=
literal|"xkb_keymap"
block|,
index|[
name|FILE_TYPE_RULES
index|]
operator|=
literal|"rules"
block|, }
decl_stmt|;
end_decl_stmt
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_file_type_to_string
name|xkb_file_type_to_string
parameter_list|(
name|enum
name|xkb_file_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>
name|_FILE_TYPE_NUM_ENTRIES
condition|)
return|return
literal|"unknown"
return|;
return|return
name|xkb_file_type_strings
index|[
name|type
index|]
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|stmt_type_strings
specifier|static
specifier|const
name|char
modifier|*
name|stmt_type_strings
index|[
name|_STMT_NUM_VALUES
index|]
init|=
block|{
index|[
name|STMT_UNKNOWN
index|]
operator|=
literal|"unknown statement"
block|,
index|[
name|STMT_INCLUDE
index|]
operator|=
literal|"include statement"
block|,
index|[
name|STMT_KEYCODE
index|]
operator|=
literal|"key name definition"
block|,
index|[
name|STMT_ALIAS
index|]
operator|=
literal|"key alias definition"
block|,
index|[
name|STMT_EXPR
index|]
operator|=
literal|"expression"
block|,
index|[
name|STMT_VAR
index|]
operator|=
literal|"variable definition"
block|,
index|[
name|STMT_TYPE
index|]
operator|=
literal|"key type definition"
block|,
index|[
name|STMT_INTERP
index|]
operator|=
literal|"symbol interpretation definition"
block|,
index|[
name|STMT_VMOD
index|]
operator|=
literal|"virtual modifiers definition"
block|,
index|[
name|STMT_SYMBOLS
index|]
operator|=
literal|"key symbols definition"
block|,
index|[
name|STMT_MODMAP
index|]
operator|=
literal|"modifier map declaration"
block|,
index|[
name|STMT_GROUP_COMPAT
index|]
operator|=
literal|"group declaration"
block|,
index|[
name|STMT_LED_MAP
index|]
operator|=
literal|"indicator map declaration"
block|,
index|[
name|STMT_LED_NAME
index|]
operator|=
literal|"indicator name declaration"
block|, }
decl_stmt|;
end_decl_stmt
begin_function
specifier|const
name|char
modifier|*
DECL|function|stmt_type_to_string
name|stmt_type_to_string
parameter_list|(
name|enum
name|stmt_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|_STMT_NUM_VALUES
condition|)
return|return
name|NULL
return|;
return|return
name|stmt_type_strings
index|[
name|type
index|]
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|expr_op_type_strings
specifier|static
specifier|const
name|char
modifier|*
name|expr_op_type_strings
index|[
name|_EXPR_NUM_VALUES
index|]
init|=
block|{
index|[
name|EXPR_VALUE
index|]
operator|=
literal|"literal"
block|,
index|[
name|EXPR_IDENT
index|]
operator|=
literal|"identifier"
block|,
index|[
name|EXPR_ACTION_DECL
index|]
operator|=
literal|"action declaration"
block|,
index|[
name|EXPR_FIELD_REF
index|]
operator|=
literal|"field reference"
block|,
index|[
name|EXPR_ARRAY_REF
index|]
operator|=
literal|"array reference"
block|,
index|[
name|EXPR_KEYSYM_LIST
index|]
operator|=
literal|"list of keysyms"
block|,
index|[
name|EXPR_ACTION_LIST
index|]
operator|=
literal|"list of actions"
block|,
index|[
name|EXPR_ADD
index|]
operator|=
literal|"addition"
block|,
index|[
name|EXPR_SUBTRACT
index|]
operator|=
literal|"subtraction"
block|,
index|[
name|EXPR_MULTIPLY
index|]
operator|=
literal|"multiplication"
block|,
index|[
name|EXPR_DIVIDE
index|]
operator|=
literal|"division"
block|,
index|[
name|EXPR_ASSIGN
index|]
operator|=
literal|"assignment"
block|,
index|[
name|EXPR_NOT
index|]
operator|=
literal|"logical negation"
block|,
index|[
name|EXPR_NEGATE
index|]
operator|=
literal|"arithmetic negation"
block|,
index|[
name|EXPR_INVERT
index|]
operator|=
literal|"bitwise inversion"
block|,
index|[
name|EXPR_UNARY_PLUS
index|]
operator|=
literal|"unary plus"
block|, }
decl_stmt|;
end_decl_stmt
begin_function
specifier|const
name|char
modifier|*
DECL|function|expr_op_type_to_string
name|expr_op_type_to_string
parameter_list|(
name|enum
name|expr_op_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|_EXPR_NUM_VALUES
condition|)
return|return
name|NULL
return|;
return|return
name|expr_op_type_strings
index|[
name|type
index|]
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|expr_value_type_strings
specifier|static
specifier|const
name|char
modifier|*
name|expr_value_type_strings
index|[
name|_EXPR_TYPE_NUM_VALUES
index|]
init|=
block|{
index|[
name|EXPR_TYPE_UNKNOWN
index|]
operator|=
literal|"unknown"
block|,
index|[
name|EXPR_TYPE_BOOLEAN
index|]
operator|=
literal|"boolean"
block|,
index|[
name|EXPR_TYPE_INT
index|]
operator|=
literal|"int"
block|,
index|[
name|EXPR_TYPE_STRING
index|]
operator|=
literal|"string"
block|,
index|[
name|EXPR_TYPE_ACTION
index|]
operator|=
literal|"action"
block|,
index|[
name|EXPR_TYPE_KEYNAME
index|]
operator|=
literal|"keyname"
block|,
index|[
name|EXPR_TYPE_SYMBOLS
index|]
operator|=
literal|"symbols"
block|, }
decl_stmt|;
end_decl_stmt
begin_function
specifier|const
name|char
modifier|*
DECL|function|expr_value_type_to_string
name|expr_value_type_to_string
parameter_list|(
name|enum
name|expr_value_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|_EXPR_TYPE_NUM_VALUES
condition|)
return|return
name|NULL
return|;
return|return
name|expr_value_type_strings
index|[
name|type
index|]
return|;
block|}
end_function
end_unit
