begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"expr.h"
end_include
begin_include
include|#
directive|include
file|"action.h"
end_include
begin_include
include|#
directive|include
file|"vmod.h"
end_include
begin_include
include|#
directive|include
file|"include.h"
end_include
begin_comment
comment|/*  * The xkb_compat section  * =====================  * This section is the third to be processed, after xkb_keycodes and  * xkb_types.  *  * Interpret statements  * --------------------  * Statements of the form:  *      interpret Num_Lock+Any { ... }  *      interpret Shift_Lock+AnyOf(Shift+Lock) { ... }  *  * The xkb_symbols section (see symbols.c) allows the keymap author to do,  * among other things, the following for each key:  * - Bind an action, like SetMods or LockGroup, to the key. Actions, like  *   symbols, are specified for each level of each group in the key  *   separately.  * - Add a virtual modifier to the key's virtual modifier mapping (vmodmap).  * - Specify whether the key should repeat or not.  *  * However, doing this for each key (or level) is tedious and inflexible.  * Interpret's are a mechanism to apply these settings to a bunch of  * keys/levels at once.  *  * Each interpret specifies a condition by which it attaches to certain  * levels. The condition consists of two parts:  * - A keysym. If the level has a different (or more than one) keysym, the  *   match failes. Leaving out the keysym is equivalent to using the  *   NoSymbol keysym, which always matches successfully.  * - A modifier predicate. The predicate consists of a matching operation  *   and a mask of (real) modifiers. The modifers are matched against the  *   key's modifier map (modmap). The matching operation can be one of the  *   following:  *   + AnyOfOrNone - The modmap must either be empty or include at least  *     one of the specified modifiers.  *   + AnyOf - The modmap must include at least one of the specified  *     modifiers.  *   + NoneOf - The modmap must not include any of the specified modifiers.  *   + AllOf - The modmap must include all of the specified modifiers (but  *     may include others as well).  *   + Exactly - The modmap must be exactly the same as the specified  *     modifiers.  *   Leaving out the predicate is equivalent to usign AnyOfOrNone while  *   specifying all modifiers. Leaving out just the matching condtition  *   is equivalent to using Exactly.  * An interpret may also include "useModMapMods = level1;" - see below.  *  * If a level fulfils the conditions of several interpret's, only the  * most specific one is used:  * - A specific keysym will always match before a generic NoSymbol  *   condition.  * - If the keysyms are the same, the interpret with the more specific  *   matching operation is used. The above list is sorted from least to  *   most specific.  * - If both the keysyms and the matching operations are the same (but the  *   modifiers are different), the first interpret is used.  *  * As described above, once an interpret "attaches" to a level, it can bind  * an action to that level, add one virtual modifier to the key's vmodmap,  * or set the key's repeat setting. You should note the following:  * - The key repeat is a property of the entire key; it is not level-specific.  *   In order to avoid confusion, it is only inspected for the first level of  *   the first group; the interpret's repeat setting is ignored when applied  *   to other levels.  * - If one of the above fields was set directly for a key in xkb_symbols,  *   the explicit setting takes precedence over the interpret.  *  * The body of the statment may include statements of the following  * forms (all of which are optional):  *  * - useModMapMods statement:  *      useModMapMods = level1;  *  *   When set to 'level1', the interpret will only match levels which are  *   the first level of the first group of the keys. This can be useful in  *   conjunction with e.g. a virtualModifier statement.  *  * - action statement:  *      action = LockMods(modifiers=NumLock);  *  *   Bind this action to the matching levels.  *  * - virtual modifier statement:  *      virtualModifier = NumLock;  *  *   Add this virtual modifier to the key's vmodmap. The given virtual  *   modifier must be declared at the top level of the file with a  *   virtual_modifiers statement, e.g.:  *      virtual_modifiers NumLock;  *  * - repeat statement:  *      repeat = True;  *  *   Set whether the key should repeat or not. Must be a boolean value.  *  * Led map statements  * ------------------------  * Statements of the form:  *      indicator "Shift Lock" { ... }  *  *   This statement specifies the behavior and binding of the LED (a.k.a  *   indicator) with the given name ("Shift Lock" above). The name should  *   have been declared previously in the xkb_keycodes section (see Led  *   name statement), and given an index there. If it wasn't, it is created  *   with the next free index.  *   The body of the statement describes the conditions of the keyboard  *   state which will cause the LED to be lit. It may include the following  *   statements:  *  * - modifiers statment:  *      modifiers = ScrollLock;  *  *   If the given modifiers are in the required state (see below), the  *   led is lit.  *  * - whichModifierState statment:  *      whichModState = Latched + Locked;  *  *   Can be any combination of:  *      base, latched, locked, effective  *      any (i.e. all of the above)  *      none (i.e. none of the above)  *      compat (legacy value, treated as effective)  *   This will cause the respective portion of the modifer state (see  *   struct xkb_state) to be matched against the modifiers given in the  *   "modifiers" statement.  *  *   Here's a simple example:  *      indicator "Num Lock" {  *          modifiers = NumLock;  *          whichModState = Locked;  *      };  *   Whenever the NumLock modifier is locked, the Num Lock LED will light  *   up.  *  * - groups statment:  *      groups = All - group1;  *  *   If the given groups are in the required state (see below), the led  *   is lit.  *  * - whichGroupState statment:  *      whichGroupState = Effective;  *  *   Can be any combination of:  *      base, latched, locked, effective  *      any (i.e. all of the above)  *      none (i.e. none of the above)  *   This will cause the respective portion of the group state (see  *   struct xkb_state) to be matched against the groups given in the  *   "groups" statement.  *  *   Note: the above conditions are disjunctive, i.e. if any of them are  *   satisfied the led is lit.  *  * Virtual modifier statements  * ---------------------------  * Statements of the form:  *     virtual_modifiers LControl;  *  * Can appear in the xkb_types, xkb_compat, xkb_symbols sections.  * TODO  *  * Effect on keymap  * ----------------  * After all of the xkb_compat sections have been compiled, the following  * members of struct xkb_keymap are finalized:  *      darray(struct xkb_sym_interpret) sym_interprets;  *      darray(struct xkb_led) leds;  *      char *compat_section_name;  * TODO: virtual modifiers.  */
end_comment
begin_enum
DECL|enum|si_field
enum|enum
name|si_field
block|{
DECL|enumerator|SI_FIELD_VIRTUAL_MOD
name|SI_FIELD_VIRTUAL_MOD
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|SI_FIELD_ACTION
name|SI_FIELD_ACTION
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|SI_FIELD_AUTO_REPEAT
name|SI_FIELD_AUTO_REPEAT
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
DECL|enumerator|SI_FIELD_LEVEL_ONE_ONLY
name|SI_FIELD_LEVEL_ONE_ONLY
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|, }
enum|;
end_enum
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|defined
name|enum
name|si_field
name|defined
decl_stmt|;
DECL|member|merge
name|enum
name|merge_mode
name|merge
decl_stmt|;
DECL|member|interp
name|struct
name|xkb_sym_interpret
name|interp
decl_stmt|;
block|}
DECL|typedef|SymInterpInfo
name|SymInterpInfo
typedef|;
end_typedef
begin_enum
DECL|enum|led_field
enum|enum
name|led_field
block|{
DECL|enumerator|LED_FIELD_MODS
name|LED_FIELD_MODS
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|LED_FIELD_GROUPS
name|LED_FIELD_GROUPS
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|LED_FIELD_CTRLS
name|LED_FIELD_CTRLS
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|, }
enum|;
end_enum
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|defined
name|enum
name|led_field
name|defined
decl_stmt|;
DECL|member|merge
name|enum
name|merge_mode
name|merge
decl_stmt|;
DECL|member|led
name|struct
name|xkb_led
name|led
decl_stmt|;
block|}
DECL|typedef|LedInfo
name|LedInfo
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|errorCount
name|int
name|errorCount
decl_stmt|;
DECL|member|default_interp
name|SymInterpInfo
name|default_interp
decl_stmt|;
name|darray
argument_list|(
argument|SymInterpInfo
argument_list|)
name|interps
expr_stmt|;
DECL|member|default_led
name|LedInfo
name|default_led
decl_stmt|;
name|darray
argument_list|(
argument|LedInfo
argument_list|)
name|leds
expr_stmt|;
DECL|member|actions
name|ActionsInfo
modifier|*
name|actions
decl_stmt|;
DECL|member|keymap
name|struct
name|xkb_keymap
modifier|*
name|keymap
decl_stmt|;
block|}
DECL|typedef|CompatInfo
name|CompatInfo
typedef|;
end_typedef
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|siText
name|siText
parameter_list|(
name|SymInterpInfo
modifier|*
name|si
parameter_list|,
name|CompatInfo
modifier|*
name|info
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|xkb_context_get_buffer
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|128
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|==
operator|&
name|info
operator|->
name|default_interp
condition|)
return|return
literal|"default"
return|;
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|128
argument_list|,
literal|"%s+%s(%s)"
argument_list|,
name|KeysymText
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|si
operator|->
name|interp
operator|.
name|sym
argument_list|)
argument_list|,
name|SIMatchText
argument_list|(
name|si
operator|->
name|interp
operator|.
name|match
argument_list|)
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|si
operator|->
name|interp
operator|.
name|mods
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportSINotArray
name|ReportSINotArray
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|SymInterpInfo
modifier|*
name|si
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|)
block|{
return|return
name|ReportNotArray
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"symbol interpretation"
argument_list|,
name|field
argument_list|,
name|siText
argument_list|(
name|si
argument_list|,
name|info
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportSIBadType
name|ReportSIBadType
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|SymInterpInfo
modifier|*
name|si
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|wanted
parameter_list|)
block|{
return|return
name|ReportBadType
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"symbol interpretation"
argument_list|,
name|field
argument_list|,
name|siText
argument_list|(
name|si
argument_list|,
name|info
argument_list|)
argument_list|,
name|wanted
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportLedBadType
name|ReportLedBadType
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|LedInfo
modifier|*
name|ledi
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|wanted
parameter_list|)
block|{
return|return
name|ReportBadType
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"indicator map"
argument_list|,
name|field
argument_list|,
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|ledi
operator|->
name|led
operator|.
name|name
argument_list|)
argument_list|,
name|wanted
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportLedNotArray
name|ReportLedNotArray
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|LedInfo
modifier|*
name|ledi
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|)
block|{
return|return
name|ReportNotArray
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"indicator map"
argument_list|,
name|field
argument_list|,
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|ledi
operator|->
name|led
operator|.
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|InitCompatInfo
name|InitCompatInfo
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|ActionsInfo
modifier|*
name|actions
parameter_list|)
block|{
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|keymap
operator|=
name|keymap
expr_stmt|;
name|info
operator|->
name|actions
operator|=
name|actions
expr_stmt|;
name|info
operator|->
name|default_interp
operator|.
name|merge
operator|=
name|MERGE_OVERRIDE
expr_stmt|;
name|info
operator|->
name|default_interp
operator|.
name|interp
operator|.
name|virtual_mod
operator|=
name|XKB_MOD_INVALID
expr_stmt|;
name|info
operator|->
name|default_led
operator|.
name|merge
operator|=
name|MERGE_OVERRIDE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ClearCompatInfo
name|ClearCompatInfo
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|)
block|{
name|free
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|info
operator|->
name|interps
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|info
operator|->
name|leds
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|SymInterpInfo
modifier|*
DECL|function|FindMatchingInterp
name|FindMatchingInterp
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|SymInterpInfo
modifier|*
name|new
parameter_list|)
block|{
name|SymInterpInfo
modifier|*
name|old
decl_stmt|;
name|darray_foreach
argument_list|(
argument|old
argument_list|,
argument|info->interps
argument_list|)
if|if
condition|(
name|old
operator|->
name|interp
operator|.
name|sym
operator|==
name|new
operator|->
name|interp
operator|.
name|sym
operator|&&
name|old
operator|->
name|interp
operator|.
name|mods
operator|==
name|new
operator|->
name|interp
operator|.
name|mods
operator|&&
name|old
operator|->
name|interp
operator|.
name|match
operator|==
name|new
operator|->
name|interp
operator|.
name|match
condition|)
return|return
name|old
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|UseNewInterpField
name|UseNewInterpField
parameter_list|(
name|enum
name|si_field
name|field
parameter_list|,
name|SymInterpInfo
modifier|*
name|old
parameter_list|,
name|SymInterpInfo
modifier|*
name|new
parameter_list|,
name|bool
name|report
parameter_list|,
name|enum
name|si_field
modifier|*
name|collide
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|old
operator|->
name|defined
operator|&
name|field
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|new
operator|->
name|defined
operator|&
name|field
condition|)
block|{
if|if
condition|(
name|report
condition|)
operator|*
name|collide
operator||=
name|field
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|merge
operator|!=
name|MERGE_AUGMENT
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddInterp
name|AddInterp
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|SymInterpInfo
modifier|*
name|new
parameter_list|,
name|bool
name|same_file
parameter_list|)
block|{
name|SymInterpInfo
modifier|*
name|old
init|=
name|FindMatchingInterp
argument_list|(
name|info
argument_list|,
name|new
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
condition|)
block|{
specifier|const
name|int
name|verbosity
init|=
name|xkb_context_get_log_verbosity
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|report
init|=
operator|(
name|same_file
operator|&&
name|verbosity
operator|>
literal|0
operator|)
operator|||
name|verbosity
operator|>
literal|9
decl_stmt|;
name|enum
name|si_field
name|collide
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|new
operator|->
name|merge
operator|==
name|MERGE_REPLACE
condition|)
block|{
if|if
condition|(
name|report
condition|)
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Multiple definitions for \"%s\"; "
literal|"Earlier interpretation ignored\n"
argument_list|,
name|siText
argument_list|(
name|new
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|old
operator|=
operator|*
name|new
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|UseNewInterpField
argument_list|(
name|SI_FIELD_VIRTUAL_MOD
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|old
operator|->
name|interp
operator|.
name|virtual_mod
operator|=
name|new
operator|->
name|interp
operator|.
name|virtual_mod
expr_stmt|;
name|old
operator|->
name|defined
operator||=
name|SI_FIELD_VIRTUAL_MOD
expr_stmt|;
block|}
if|if
condition|(
name|UseNewInterpField
argument_list|(
name|SI_FIELD_ACTION
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|old
operator|->
name|interp
operator|.
name|action
operator|=
name|new
operator|->
name|interp
operator|.
name|action
expr_stmt|;
name|old
operator|->
name|defined
operator||=
name|SI_FIELD_ACTION
expr_stmt|;
block|}
if|if
condition|(
name|UseNewInterpField
argument_list|(
name|SI_FIELD_AUTO_REPEAT
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|old
operator|->
name|interp
operator|.
name|repeat
operator|=
name|new
operator|->
name|interp
operator|.
name|repeat
expr_stmt|;
name|old
operator|->
name|defined
operator||=
name|SI_FIELD_AUTO_REPEAT
expr_stmt|;
block|}
if|if
condition|(
name|UseNewInterpField
argument_list|(
name|SI_FIELD_LEVEL_ONE_ONLY
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|old
operator|->
name|interp
operator|.
name|level_one_only
operator|=
name|new
operator|->
name|interp
operator|.
name|level_one_only
expr_stmt|;
name|old
operator|->
name|defined
operator||=
name|SI_FIELD_LEVEL_ONE_ONLY
expr_stmt|;
block|}
if|if
condition|(
name|collide
condition|)
block|{
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Multiple interpretations of \"%s\"; "
literal|"Using %s definition for duplicate fields\n"
argument_list|,
name|siText
argument_list|(
name|new
argument_list|,
name|info
argument_list|)
argument_list|,
operator|(
name|new
operator|->
name|merge
operator|!=
name|MERGE_AUGMENT
condition|?
literal|"last"
else|:
literal|"first"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
name|darray_append
argument_list|(
name|info
operator|->
name|interps
argument_list|,
operator|*
name|new
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|ResolveStateAndPredicate
name|ResolveStateAndPredicate
parameter_list|(
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|enum
name|xkb_match_operation
modifier|*
name|pred_rtrn
parameter_list|,
name|xkb_mod_mask_t
modifier|*
name|mods_rtrn
parameter_list|,
name|CompatInfo
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
block|{
operator|*
name|pred_rtrn
operator|=
name|MATCH_ANY_OR_NONE
expr_stmt|;
operator|*
name|mods_rtrn
operator|=
name|MOD_REAL_MASK_ALL
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|pred_rtrn
operator|=
name|MATCH_EXACTLY
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|op
operator|==
name|EXPR_ACTION_DECL
condition|)
block|{
specifier|const
name|char
modifier|*
name|pred_txt
init|=
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|expr
operator|->
name|value
operator|.
name|action
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|LookupString
argument_list|(
name|symInterpretMatchMaskNames
argument_list|,
name|pred_txt
argument_list|,
name|pred_rtrn
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal modifier predicate \"%s\"; Ignored\n"
argument_list|,
name|pred_txt
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|expr
operator|=
name|expr
operator|->
name|value
operator|.
name|action
operator|.
name|args
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|->
name|op
operator|==
name|EXPR_IDENT
condition|)
block|{
specifier|const
name|char
modifier|*
name|pred_txt
init|=
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|expr
operator|->
name|value
operator|.
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_txt
operator|&&
name|istreq
argument_list|(
name|pred_txt
argument_list|,
literal|"any"
argument_list|)
condition|)
block|{
operator|*
name|pred_rtrn
operator|=
name|MATCH_ANY
expr_stmt|;
operator|*
name|mods_rtrn
operator|=
name|MOD_REAL_MASK_ALL
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|ExprResolveModMask
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|expr
argument_list|,
name|MOD_REAL
argument_list|,
name|mods_rtrn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|UseNewLEDField
name|UseNewLEDField
parameter_list|(
name|enum
name|led_field
name|field
parameter_list|,
name|LedInfo
modifier|*
name|old
parameter_list|,
name|LedInfo
modifier|*
name|new
parameter_list|,
name|bool
name|report
parameter_list|,
name|enum
name|led_field
modifier|*
name|collide
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|old
operator|->
name|defined
operator|&
name|field
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|new
operator|->
name|defined
operator|&
name|field
condition|)
block|{
if|if
condition|(
name|report
condition|)
operator|*
name|collide
operator||=
name|field
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|merge
operator|!=
name|MERGE_AUGMENT
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddLedMap
name|AddLedMap
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|LedInfo
modifier|*
name|new
parameter_list|,
name|bool
name|same_file
parameter_list|)
block|{
name|LedInfo
modifier|*
name|old
decl_stmt|;
name|enum
name|led_field
name|collide
decl_stmt|;
name|struct
name|xkb_context
modifier|*
name|ctx
init|=
name|info
operator|->
name|keymap
operator|->
name|ctx
decl_stmt|;
specifier|const
name|int
name|verbosity
init|=
name|xkb_context_get_log_verbosity
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|report
init|=
operator|(
name|same_file
operator|&&
name|verbosity
operator|>
literal|0
operator|)
operator|||
name|verbosity
operator|>
literal|9
decl_stmt|;
name|darray_foreach
argument_list|(
argument|old
argument_list|,
argument|info->leds
argument_list|)
block|{
if|if
condition|(
name|old
operator|->
name|led
operator|.
name|name
operator|!=
name|new
operator|->
name|led
operator|.
name|name
condition|)
continue|continue;
if|if
condition|(
name|old
operator|->
name|led
operator|.
name|mods
operator|.
name|mods
operator|==
name|new
operator|->
name|led
operator|.
name|mods
operator|.
name|mods
operator|&&
name|old
operator|->
name|led
operator|.
name|groups
operator|==
name|new
operator|->
name|led
operator|.
name|groups
operator|&&
name|old
operator|->
name|led
operator|.
name|ctrls
operator|==
name|new
operator|->
name|led
operator|.
name|ctrls
operator|&&
name|old
operator|->
name|led
operator|.
name|which_mods
operator|==
name|new
operator|->
name|led
operator|.
name|which_mods
operator|&&
name|old
operator|->
name|led
operator|.
name|which_groups
operator|==
name|new
operator|->
name|led
operator|.
name|which_groups
condition|)
block|{
name|old
operator|->
name|defined
operator||=
name|new
operator|->
name|defined
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|new
operator|->
name|merge
operator|==
name|MERGE_REPLACE
condition|)
block|{
if|if
condition|(
name|report
condition|)
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Map for indicator %s redefined; "
literal|"Earlier definition ignored\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|old
operator|->
name|led
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|old
operator|=
operator|*
name|new
expr_stmt|;
return|return
name|true
return|;
block|}
name|collide
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|UseNewLEDField
argument_list|(
name|LED_FIELD_MODS
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|old
operator|->
name|led
operator|.
name|which_mods
operator|=
name|new
operator|->
name|led
operator|.
name|which_mods
expr_stmt|;
name|old
operator|->
name|led
operator|.
name|mods
operator|=
name|new
operator|->
name|led
operator|.
name|mods
expr_stmt|;
name|old
operator|->
name|defined
operator||=
name|LED_FIELD_MODS
expr_stmt|;
block|}
if|if
condition|(
name|UseNewLEDField
argument_list|(
name|LED_FIELD_GROUPS
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|old
operator|->
name|led
operator|.
name|which_groups
operator|=
name|new
operator|->
name|led
operator|.
name|which_groups
expr_stmt|;
name|old
operator|->
name|led
operator|.
name|groups
operator|=
name|new
operator|->
name|led
operator|.
name|groups
expr_stmt|;
name|old
operator|->
name|defined
operator||=
name|LED_FIELD_GROUPS
expr_stmt|;
block|}
if|if
condition|(
name|UseNewLEDField
argument_list|(
name|LED_FIELD_CTRLS
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|old
operator|->
name|led
operator|.
name|ctrls
operator|=
name|new
operator|->
name|led
operator|.
name|ctrls
expr_stmt|;
name|old
operator|->
name|defined
operator||=
name|LED_FIELD_CTRLS
expr_stmt|;
block|}
if|if
condition|(
name|collide
condition|)
block|{
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Map for indicator %s redefined; "
literal|"Using %s definition for duplicate fields\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|old
operator|->
name|led
operator|.
name|name
argument_list|)
argument_list|,
operator|(
name|new
operator|->
name|merge
operator|==
name|MERGE_AUGMENT
condition|?
literal|"first"
else|:
literal|"last"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
name|darray_append
argument_list|(
name|info
operator|->
name|leds
argument_list|,
operator|*
name|new
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|MergeIncludedCompatMaps
name|MergeIncludedCompatMaps
parameter_list|(
name|CompatInfo
modifier|*
name|into
parameter_list|,
name|CompatInfo
modifier|*
name|from
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|SymInterpInfo
modifier|*
name|si
decl_stmt|;
name|LedInfo
modifier|*
name|ledi
decl_stmt|;
if|if
condition|(
name|from
operator|->
name|errorCount
operator|>
literal|0
condition|)
block|{
name|into
operator|->
name|errorCount
operator|+=
name|from
operator|->
name|errorCount
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|into
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|into
operator|->
name|name
operator|=
name|from
operator|->
name|name
expr_stmt|;
name|from
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
name|darray_foreach
argument_list|(
argument|si
argument_list|,
argument|from->interps
argument_list|)
block|{
name|si
operator|->
name|merge
operator|=
operator|(
name|merge
operator|==
name|MERGE_DEFAULT
condition|?
name|si
operator|->
name|merge
else|:
name|merge
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|AddInterp
argument_list|(
name|into
argument_list|,
name|si
argument_list|,
name|false
argument_list|)
condition|)
name|into
operator|->
name|errorCount
operator|++
expr_stmt|;
block|}
name|darray_foreach
argument_list|(
argument|ledi
argument_list|,
argument|from->leds
argument_list|)
block|{
name|ledi
operator|->
name|merge
operator|=
operator|(
name|merge
operator|==
name|MERGE_DEFAULT
condition|?
name|ledi
operator|->
name|merge
else|:
name|merge
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|AddLedMap
argument_list|(
name|into
argument_list|,
name|ledi
argument_list|,
name|false
argument_list|)
condition|)
name|into
operator|->
name|errorCount
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|HandleCompatMapFile
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|XkbFile
modifier|*
name|file
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
name|bool
DECL|function|HandleIncludeCompatMap
name|HandleIncludeCompatMap
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|IncludeStmt
modifier|*
name|include
parameter_list|)
block|{
name|CompatInfo
name|included
decl_stmt|;
name|InitCompatInfo
argument_list|(
operator|&
name|included
argument_list|,
name|info
operator|->
name|keymap
argument_list|,
name|info
operator|->
name|actions
argument_list|)
expr_stmt|;
name|included
operator|.
name|name
operator|=
name|include
operator|->
name|stmt
expr_stmt|;
name|include
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|IncludeStmt
modifier|*
name|stmt
init|=
name|include
init|;
name|stmt
condition|;
name|stmt
operator|=
name|stmt
operator|->
name|next_incl
control|)
block|{
name|CompatInfo
name|next_incl
decl_stmt|;
name|XkbFile
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|ProcessIncludeFile
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|stmt
argument_list|,
name|FILE_TYPE_COMPAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|info
operator|->
name|errorCount
operator|+=
literal|10
expr_stmt|;
name|ClearCompatInfo
argument_list|(
operator|&
name|included
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|InitCompatInfo
argument_list|(
operator|&
name|next_incl
argument_list|,
name|info
operator|->
name|keymap
argument_list|,
name|info
operator|->
name|actions
argument_list|)
expr_stmt|;
name|next_incl
operator|.
name|default_interp
operator|=
name|info
operator|->
name|default_interp
expr_stmt|;
name|next_incl
operator|.
name|default_interp
operator|.
name|merge
operator|=
name|stmt
operator|->
name|merge
expr_stmt|;
name|next_incl
operator|.
name|default_led
operator|=
name|info
operator|->
name|default_led
expr_stmt|;
name|next_incl
operator|.
name|default_led
operator|.
name|merge
operator|=
name|stmt
operator|->
name|merge
expr_stmt|;
name|HandleCompatMapFile
argument_list|(
operator|&
name|next_incl
argument_list|,
name|file
argument_list|,
name|MERGE_OVERRIDE
argument_list|)
expr_stmt|;
name|MergeIncludedCompatMaps
argument_list|(
operator|&
name|included
argument_list|,
operator|&
name|next_incl
argument_list|,
name|stmt
operator|->
name|merge
argument_list|)
expr_stmt|;
name|ClearCompatInfo
argument_list|(
operator|&
name|next_incl
argument_list|)
expr_stmt|;
name|FreeXkbFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|MergeIncludedCompatMaps
argument_list|(
name|info
argument_list|,
operator|&
name|included
argument_list|,
name|include
operator|->
name|merge
argument_list|)
expr_stmt|;
name|ClearCompatInfo
argument_list|(
operator|&
name|included
argument_list|)
expr_stmt|;
return|return
operator|(
name|info
operator|->
name|errorCount
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|SetInterpField
name|SetInterpField
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|SymInterpInfo
modifier|*
name|si
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_keymap
modifier|*
name|keymap
init|=
name|info
operator|->
name|keymap
decl_stmt|;
name|xkb_mod_index_t
name|ndx
decl_stmt|;
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"action"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportSINotArray
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|HandleActionDef
argument_list|(
name|value
argument_list|,
name|keymap
argument_list|,
operator|&
name|si
operator|->
name|interp
operator|.
name|action
argument_list|,
name|info
operator|->
name|actions
argument_list|)
condition|)
return|return
name|false
return|;
name|si
operator|->
name|defined
operator||=
name|SI_FIELD_ACTION
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"virtualmodifier"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"virtualmod"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportSINotArray
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveMod
argument_list|(
name|keymap
argument_list|,
name|value
argument_list|,
name|MOD_VIRT
argument_list|,
operator|&
name|ndx
argument_list|)
condition|)
return|return
name|ReportSIBadType
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|,
literal|"virtual modifier"
argument_list|)
return|;
name|si
operator|->
name|interp
operator|.
name|virtual_mod
operator|=
name|ndx
expr_stmt|;
name|si
operator|->
name|defined
operator||=
name|SI_FIELD_VIRTUAL_MOD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"repeat"
argument_list|)
condition|)
block|{
name|bool
name|set
decl_stmt|;
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportSINotArray
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveBoolean
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|set
argument_list|)
condition|)
return|return
name|ReportSIBadType
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|,
literal|"boolean"
argument_list|)
return|;
name|si
operator|->
name|interp
operator|.
name|repeat
operator|=
name|set
expr_stmt|;
name|si
operator|->
name|defined
operator||=
name|SI_FIELD_AUTO_REPEAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"locking"
argument_list|)
condition|)
block|{
name|log_dbg
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The \"locking\" field in symbol interpretation is unsupported; "
literal|"Ignored\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"usemodmap"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"usemodmapmods"
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportSINotArray
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveEnum
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|,
name|useModMapValueNames
argument_list|)
condition|)
return|return
name|ReportSIBadType
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|,
literal|"level specification"
argument_list|)
return|;
name|si
operator|->
name|interp
operator|.
name|level_one_only
operator|=
operator|!
operator|!
name|val
expr_stmt|;
name|si
operator|->
name|defined
operator||=
name|SI_FIELD_LEVEL_ONE_ONLY
expr_stmt|;
block|}
else|else
block|{
return|return
name|ReportBadField
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"symbol interpretation"
argument_list|,
name|field
argument_list|,
name|siText
argument_list|(
name|si
argument_list|,
name|info
argument_list|)
argument_list|)
return|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|SetLedMapField
name|SetLedMapField
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|LedInfo
modifier|*
name|ledi
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|bool
name|ok
init|=
name|true
decl_stmt|;
name|struct
name|xkb_keymap
modifier|*
name|keymap
init|=
name|info
operator|->
name|keymap
decl_stmt|;
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"modifiers"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"mods"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportLedNotArray
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveModMask
argument_list|(
name|keymap
argument_list|,
name|value
argument_list|,
name|MOD_BOTH
argument_list|,
operator|&
name|ledi
operator|->
name|led
operator|.
name|mods
operator|.
name|mods
argument_list|)
condition|)
return|return
name|ReportLedBadType
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|,
literal|"modifier mask"
argument_list|)
return|;
name|ledi
operator|->
name|defined
operator||=
name|LED_FIELD_MODS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groups"
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportLedNotArray
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveMask
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|mask
argument_list|,
name|groupMaskNames
argument_list|)
condition|)
return|return
name|ReportLedBadType
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|,
literal|"group mask"
argument_list|)
return|;
name|ledi
operator|->
name|led
operator|.
name|groups
operator|=
name|mask
expr_stmt|;
name|ledi
operator|->
name|defined
operator||=
name|LED_FIELD_GROUPS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"controls"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"ctrls"
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportLedNotArray
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveMask
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|mask
argument_list|,
name|ctrlMaskNames
argument_list|)
condition|)
return|return
name|ReportLedBadType
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|,
literal|"controls mask"
argument_list|)
return|;
name|ledi
operator|->
name|led
operator|.
name|ctrls
operator|=
name|mask
expr_stmt|;
name|ledi
operator|->
name|defined
operator||=
name|LED_FIELD_CTRLS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"allowexplicit"
argument_list|)
condition|)
block|{
name|log_dbg
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The \"allowExplicit\" field in indicator statements is unsupported; "
literal|"Ignored\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"whichmodstate"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"whichmodifierstate"
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportLedNotArray
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveMask
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|mask
argument_list|,
name|modComponentMaskNames
argument_list|)
condition|)
return|return
name|ReportLedBadType
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|,
literal|"mask of modifier state components"
argument_list|)
return|;
name|ledi
operator|->
name|led
operator|.
name|which_mods
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"whichgroupstate"
argument_list|)
condition|)
block|{
name|unsigned
name|mask
decl_stmt|;
if|if
condition|(
name|arrayNdx
condition|)
return|return
name|ReportLedNotArray
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveMask
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|mask
argument_list|,
name|groupComponentMaskNames
argument_list|)
condition|)
return|return
name|ReportLedBadType
argument_list|(
name|info
argument_list|,
name|ledi
argument_list|,
name|field
argument_list|,
literal|"mask of group state components"
argument_list|)
return|;
name|ledi
operator|->
name|led
operator|.
name|which_groups
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"driveskbd"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"driveskeyboard"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"leddriveskbd"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"leddriveskeyboard"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"indicatordriveskbd"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"indicatordriveskeyboard"
argument_list|)
condition|)
block|{
name|log_dbg
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The \"%s\" field in indicator statements is unsupported; "
literal|"Ignored\n"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"index"
argument_list|)
condition|)
block|{
comment|/* Users should see this, it might cause unexpected behavior. */
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The \"index\" field in indicator statements is unsupported; "
literal|"Ignored\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Unknown field %s in map for %s indicator; "
literal|"Definition ignored\n"
argument_list|,
name|field
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|ledi
operator|->
name|led
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleGlobalVar
name|HandleGlobalVar
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|VarDef
modifier|*
name|stmt
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|ExprDef
modifier|*
name|ndx
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveLhs
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|stmt
operator|->
name|name
argument_list|,
operator|&
name|elem
argument_list|,
operator|&
name|field
argument_list|,
operator|&
name|ndx
argument_list|)
condition|)
name|ret
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|elem
operator|&&
name|istreq
argument_list|(
name|elem
argument_list|,
literal|"interpret"
argument_list|)
condition|)
name|ret
operator|=
name|SetInterpField
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|default_interp
argument_list|,
name|field
argument_list|,
name|ndx
argument_list|,
name|stmt
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elem
operator|&&
name|istreq
argument_list|(
name|elem
argument_list|,
literal|"indicator"
argument_list|)
condition|)
name|ret
operator|=
name|SetLedMapField
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|default_led
argument_list|,
name|field
argument_list|,
name|ndx
argument_list|,
name|stmt
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|SetActionField
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|elem
argument_list|,
name|field
argument_list|,
name|ndx
argument_list|,
name|stmt
operator|->
name|value
argument_list|,
name|info
operator|->
name|actions
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleInterpBody
name|HandleInterpBody
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|VarDef
modifier|*
name|def
parameter_list|,
name|SymInterpInfo
modifier|*
name|si
parameter_list|)
block|{
name|bool
name|ok
init|=
name|true
decl_stmt|;
specifier|const
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|ExprDef
modifier|*
name|arrayNdx
decl_stmt|;
for|for
control|(
init|;
name|def
condition|;
name|def
operator|=
operator|(
name|VarDef
operator|*
operator|)
name|def
operator|->
name|common
operator|.
name|next
control|)
block|{
if|if
condition|(
name|def
operator|->
name|name
operator|&&
name|def
operator|->
name|name
operator|->
name|op
operator|==
name|EXPR_FIELD_REF
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot set a global default value from within an interpret statement; "
literal|"Move statements to the global file scope\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|ok
operator|=
name|ExprResolveLhs
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|def
operator|->
name|name
argument_list|,
operator|&
name|elem
argument_list|,
operator|&
name|field
argument_list|,
operator|&
name|arrayNdx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
name|ok
operator|=
name|SetInterpField
argument_list|(
name|info
argument_list|,
name|si
argument_list|,
name|field
argument_list|,
name|arrayNdx
argument_list|,
name|def
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleInterpDef
name|HandleInterpDef
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|InterpDef
modifier|*
name|def
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|enum
name|xkb_match_operation
name|pred
decl_stmt|;
name|xkb_mod_mask_t
name|mods
decl_stmt|;
name|SymInterpInfo
name|si
decl_stmt|;
if|if
condition|(
operator|!
name|ResolveStateAndPredicate
argument_list|(
name|def
operator|->
name|match
argument_list|,
operator|&
name|pred
argument_list|,
operator|&
name|mods
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Couldn't determine matching modifiers; "
literal|"Symbol interpretation ignored\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|si
operator|=
name|info
operator|->
name|default_interp
expr_stmt|;
name|si
operator|.
name|merge
operator|=
name|merge
operator|=
operator|(
name|def
operator|->
name|merge
operator|==
name|MERGE_DEFAULT
condition|?
name|merge
else|:
name|def
operator|->
name|merge
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|LookupKeysym
argument_list|(
name|def
operator|->
name|sym
argument_list|,
operator|&
name|si
operator|.
name|interp
operator|.
name|sym
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Could not resolve keysym %s; "
literal|"Symbol interpretation ignored\n"
argument_list|,
name|def
operator|->
name|sym
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|si
operator|.
name|interp
operator|.
name|match
operator|=
name|pred
expr_stmt|;
name|si
operator|.
name|interp
operator|.
name|mods
operator|=
name|mods
expr_stmt|;
if|if
condition|(
operator|!
name|HandleInterpBody
argument_list|(
name|info
argument_list|,
name|def
operator|->
name|def
argument_list|,
operator|&
name|si
argument_list|)
condition|)
block|{
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|AddInterp
argument_list|(
name|info
argument_list|,
operator|&
name|si
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleLedMapDef
name|HandleLedMapDef
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|LedMapDef
modifier|*
name|def
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|LedInfo
name|ledi
decl_stmt|;
name|VarDef
modifier|*
name|var
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|def
operator|->
name|merge
operator|!=
name|MERGE_DEFAULT
condition|)
name|merge
operator|=
name|def
operator|->
name|merge
expr_stmt|;
name|ledi
operator|=
name|info
operator|->
name|default_led
expr_stmt|;
name|ledi
operator|.
name|merge
operator|=
name|merge
expr_stmt|;
name|ledi
operator|.
name|led
operator|.
name|name
operator|=
name|def
operator|->
name|name
expr_stmt|;
name|ok
operator|=
name|true
expr_stmt|;
for|for
control|(
name|var
operator|=
name|def
operator|->
name|body
init|;
name|var
operator|!=
name|NULL
condition|;
name|var
operator|=
operator|(
name|VarDef
operator|*
operator|)
name|var
operator|->
name|common
operator|.
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|ExprDef
modifier|*
name|arrayNdx
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveLhs
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|var
operator|->
name|name
argument_list|,
operator|&
name|elem
argument_list|,
operator|&
name|field
argument_list|,
operator|&
name|arrayNdx
argument_list|)
condition|)
block|{
name|ok
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|elem
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot set defaults for \"%s\" element in indicator map; "
literal|"Assignment to %s.%s ignored\n"
argument_list|,
name|elem
argument_list|,
name|elem
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
name|SetLedMapField
argument_list|(
name|info
argument_list|,
operator|&
name|ledi
argument_list|,
name|field
argument_list|,
name|arrayNdx
argument_list|,
name|var
operator|->
name|value
argument_list|)
operator|&&
name|ok
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
condition|)
return|return
name|AddLedMap
argument_list|(
name|info
argument_list|,
operator|&
name|ledi
argument_list|,
name|true
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|HandleCompatMapFile
name|HandleCompatMapFile
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|XkbFile
modifier|*
name|file
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|merge
operator|=
operator|(
name|merge
operator|==
name|MERGE_DEFAULT
condition|?
name|MERGE_AUGMENT
else|:
name|merge
operator|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|strdup_safe
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ParseCommon
modifier|*
name|stmt
init|=
name|file
operator|->
name|defs
init|;
name|stmt
condition|;
name|stmt
operator|=
name|stmt
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|stmt
operator|->
name|type
condition|)
block|{
case|case
name|STMT_INCLUDE
case|:
name|ok
operator|=
name|HandleIncludeCompatMap
argument_list|(
name|info
argument_list|,
operator|(
name|IncludeStmt
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_INTERP
case|:
name|ok
operator|=
name|HandleInterpDef
argument_list|(
name|info
argument_list|,
operator|(
name|InterpDef
operator|*
operator|)
name|stmt
argument_list|,
name|merge
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_GROUP_COMPAT
case|:
name|log_dbg
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The \"group\" statement in compat is unsupported; "
literal|"Ignored\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|STMT_LED_MAP
case|:
name|ok
operator|=
name|HandleLedMapDef
argument_list|(
name|info
argument_list|,
operator|(
name|LedMapDef
operator|*
operator|)
name|stmt
argument_list|,
name|merge
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_VAR
case|:
name|ok
operator|=
name|HandleGlobalVar
argument_list|(
name|info
argument_list|,
operator|(
name|VarDef
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_VMOD
case|:
name|ok
operator|=
name|HandleVModDef
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
operator|(
name|VModDef
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Interpretation files may not include other types; "
literal|"Ignoring %s\n"
argument_list|,
name|stmt_type_to_string
argument_list|(
name|stmt
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|errorCount
operator|>
literal|10
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Abandoning compatibility map \"%s\"\n"
argument_list|,
name|file
operator|->
name|topName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|CopyInterps
name|CopyInterps
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|,
name|bool
name|needSymbol
parameter_list|,
name|enum
name|xkb_match_operation
name|pred
parameter_list|)
block|{
name|SymInterpInfo
modifier|*
name|si
decl_stmt|;
name|darray_foreach
argument_list|(
argument|si
argument_list|,
argument|info->interps
argument_list|)
if|if
condition|(
name|si
operator|->
name|interp
operator|.
name|match
operator|==
name|pred
operator|&&
operator|(
name|si
operator|->
name|interp
operator|.
name|sym
operator|!=
name|XKB_KEY_NoSymbol
operator|)
operator|==
name|needSymbol
condition|)
name|darray_append
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|sym_interprets
argument_list|,
name|si
operator|->
name|interp
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|CopyLedMapDefs
name|CopyLedMapDefs
parameter_list|(
name|CompatInfo
modifier|*
name|info
parameter_list|)
block|{
name|LedInfo
modifier|*
name|ledi
decl_stmt|;
name|xkb_led_index_t
name|i
decl_stmt|;
name|struct
name|xkb_led
modifier|*
name|led
decl_stmt|;
name|struct
name|xkb_keymap
modifier|*
name|keymap
init|=
name|info
operator|->
name|keymap
decl_stmt|;
name|darray_foreach
argument_list|(
argument|ledi
argument_list|,
argument|info->leds
argument_list|)
block|{
comment|/*          * Find the LED with the given name, if it was already declared          * in keycodes.          */
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|led
argument_list|,
argument|keymap->leds
argument_list|)
if|if
condition|(
name|led
operator|->
name|name
operator|==
name|ledi
operator|->
name|led
operator|.
name|name
condition|)
break|break;
comment|/* Not previously declared; create it with next free index. */
if|if
condition|(
name|i
operator|>=
name|darray_size
argument_list|(
name|keymap
operator|->
name|leds
argument_list|)
condition|)
block|{
name|log_dbg
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Indicator name \"%s\" was not declared in the keycodes section; "
literal|"Adding new indicator\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|ledi
operator|->
name|led
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|led
argument_list|,
argument|keymap->leds
argument_list|)
if|if
condition|(
name|led
operator|->
name|name
operator|==
name|XKB_ATOM_NONE
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|darray_size
argument_list|(
name|keymap
operator|->
name|leds
argument_list|)
condition|)
block|{
comment|/* Not place to put it; ignore. */
if|if
condition|(
name|i
operator|>=
name|XKB_MAX_LEDS
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Too many indicators (maximum is %d); "
literal|"Indicator name \"%s\" ignored\n"
argument_list|,
name|XKB_MAX_LEDS
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|ledi
operator|->
name|led
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add a new LED. */
name|darray_resize
argument_list|(
name|keymap
operator|->
name|leds
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|led
operator|=
operator|&
name|darray_item
argument_list|(
name|keymap
operator|->
name|leds
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|led
operator|=
name|ledi
operator|->
name|led
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|groups
operator|!=
literal|0
operator|&&
name|led
operator|->
name|which_groups
operator|==
literal|0
condition|)
name|led
operator|->
name|which_groups
operator|=
name|XKB_STATE_LAYOUT_EFFECTIVE
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|mods
operator|.
name|mods
operator|!=
literal|0
operator|&&
name|led
operator|->
name|which_mods
operator|==
literal|0
condition|)
name|led
operator|->
name|which_mods
operator|=
name|XKB_STATE_MODS_EFFECTIVE
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|CopyCompatToKeymap
name|CopyCompatToKeymap
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|CompatInfo
modifier|*
name|info
parameter_list|)
block|{
name|keymap
operator|->
name|compat_section_name
operator|=
name|strdup_safe
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|darray_empty
argument_list|(
name|info
operator|->
name|interps
argument_list|)
condition|)
block|{
comment|/* Most specific to least specific. */
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|true
argument_list|,
name|MATCH_EXACTLY
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|true
argument_list|,
name|MATCH_ALL
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|true
argument_list|,
name|MATCH_NONE
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|true
argument_list|,
name|MATCH_ANY
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|true
argument_list|,
name|MATCH_ANY_OR_NONE
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|MATCH_EXACTLY
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|MATCH_ALL
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|MATCH_NONE
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|MATCH_ANY
argument_list|)
expr_stmt|;
name|CopyInterps
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|MATCH_ANY_OR_NONE
argument_list|)
expr_stmt|;
block|}
name|CopyLedMapDefs
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|CompileCompatMap
name|CompileCompatMap
parameter_list|(
name|XkbFile
modifier|*
name|file
parameter_list|,
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|CompatInfo
name|info
decl_stmt|;
name|ActionsInfo
modifier|*
name|actions
decl_stmt|;
name|actions
operator|=
name|NewActionsInfo
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|actions
condition|)
return|return
name|false
return|;
name|InitCompatInfo
argument_list|(
operator|&
name|info
argument_list|,
name|keymap
argument_list|,
name|actions
argument_list|)
expr_stmt|;
name|info
operator|.
name|default_interp
operator|.
name|merge
operator|=
name|merge
expr_stmt|;
name|info
operator|.
name|default_led
operator|.
name|merge
operator|=
name|merge
expr_stmt|;
name|HandleCompatMapFile
argument_list|(
operator|&
name|info
argument_list|,
name|file
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|errorCount
operator|!=
literal|0
condition|)
goto|goto
name|err_info
goto|;
if|if
condition|(
operator|!
name|CopyCompatToKeymap
argument_list|(
name|keymap
argument_list|,
operator|&
name|info
argument_list|)
condition|)
goto|goto
name|err_info
goto|;
name|ClearCompatInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|FreeActionsInfo
argument_list|(
name|actions
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|err_info
label|:
name|ClearCompatInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|FreeActionsInfo
argument_list|(
name|actions
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
end_unit
