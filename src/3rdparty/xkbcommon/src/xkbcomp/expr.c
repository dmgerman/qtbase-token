begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"expr.h"
end_include
begin_typedef
DECL|typedef|IdentLookupFunc
typedef|typedef
name|bool
function_decl|(
modifier|*
name|IdentLookupFunc
function_decl|)
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|priv
parameter_list|,
name|xkb_atom_t
name|field
parameter_list|,
name|enum
name|expr_value_type
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|val_rtrn
parameter_list|)
function_decl|;
end_typedef
begin_function
name|bool
DECL|function|ExprResolveLhs
name|ExprResolveLhs
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|elem_rtrn
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|field_rtrn
parameter_list|,
name|ExprDef
modifier|*
modifier|*
name|index_rtrn
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_IDENT
case|:
operator|*
name|elem_rtrn
operator|=
name|NULL
expr_stmt|;
operator|*
name|field_rtrn
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|)
expr_stmt|;
operator|*
name|index_rtrn
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_FIELD_REF
case|:
operator|*
name|elem_rtrn
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|element
argument_list|)
expr_stmt|;
operator|*
name|field_rtrn
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|field
argument_list|)
expr_stmt|;
operator|*
name|index_rtrn
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_ARRAY_REF
case|:
operator|*
name|elem_rtrn
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|array_ref
operator|.
name|element
argument_list|)
expr_stmt|;
operator|*
name|field_rtrn
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|array_ref
operator|.
name|field
argument_list|)
expr_stmt|;
operator|*
name|index_rtrn
operator|=
name|expr
operator|->
name|array_ref
operator|.
name|entry
expr_stmt|;
return|return
name|true
return|;
default|default:
break|break;
block|}
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Unexpected operator %d in ResolveLhs\n"
argument_list|,
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|SimpleLookup
name|SimpleLookup
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|priv
parameter_list|,
name|xkb_atom_t
name|field
parameter_list|,
name|enum
name|expr_value_type
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|val_rtrn
parameter_list|)
block|{
specifier|const
name|LookupEntry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|||
name|field
operator|==
name|XKB_ATOM_NONE
operator|||
name|type
operator|!=
name|EXPR_TYPE_INT
condition|)
return|return
name|false
return|;
name|str
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|field
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|priv
init|;
name|entry
operator|&&
name|entry
operator|->
name|name
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|istreq
argument_list|(
name|str
argument_list|,
name|entry
operator|->
name|name
argument_list|)
condition|)
block|{
operator|*
name|val_rtrn
operator|=
name|entry
operator|->
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function
begin_comment
comment|/* Data passed in the *priv argument for LookupModMask. */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|keymap
specifier|const
name|struct
name|xkb_keymap
modifier|*
name|keymap
decl_stmt|;
DECL|member|mod_type
name|enum
name|mod_type
name|mod_type
decl_stmt|;
block|}
DECL|typedef|LookupModMaskPriv
name|LookupModMaskPriv
typedef|;
end_typedef
begin_function
specifier|static
name|bool
DECL|function|LookupModMask
name|LookupModMask
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|priv
parameter_list|,
name|xkb_atom_t
name|field
parameter_list|,
name|enum
name|expr_value_type
name|type
parameter_list|,
name|xkb_mod_mask_t
modifier|*
name|val_rtrn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|xkb_mod_index_t
name|ndx
decl_stmt|;
specifier|const
name|LookupModMaskPriv
modifier|*
name|arg
init|=
name|priv
decl_stmt|;
specifier|const
name|struct
name|xkb_keymap
modifier|*
name|keymap
init|=
name|arg
operator|->
name|keymap
decl_stmt|;
name|enum
name|mod_type
name|mod_type
init|=
name|arg
operator|->
name|mod_type
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|EXPR_TYPE_INT
condition|)
return|return
name|false
return|;
name|str
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|istreq
argument_list|(
name|str
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
operator|*
name|val_rtrn
operator|=
name|MOD_REAL_MASK_ALL
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|istreq
argument_list|(
name|str
argument_list|,
literal|"none"
argument_list|)
condition|)
block|{
operator|*
name|val_rtrn
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
name|ndx
operator|=
name|ModNameToIndex
argument_list|(
name|keymap
argument_list|,
name|field
argument_list|,
name|mod_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|==
name|XKB_MOD_INVALID
condition|)
return|return
name|false
return|;
operator|*
name|val_rtrn
operator|=
operator|(
literal|1u
operator|<<
name|ndx
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveBoolean
name|ExprResolveBoolean
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|bool
modifier|*
name|set_rtrn
parameter_list|)
block|{
name|bool
name|ok
init|=
name|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|ident
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_VALUE
case|:
if|if
condition|(
name|expr
operator|->
name|expr
operator|.
name|value_type
operator|!=
name|EXPR_TYPE_BOOLEAN
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Found constant of type %s where boolean was expected\n"
argument_list|,
name|expr_value_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|set_rtrn
operator|=
name|expr
operator|->
name|boolean
operator|.
name|set
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_IDENT
case|:
name|ident
operator|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
condition|)
block|{
if|if
condition|(
name|istreq
argument_list|(
name|ident
argument_list|,
literal|"true"
argument_list|)
operator|||
name|istreq
argument_list|(
name|ident
argument_list|,
literal|"yes"
argument_list|)
operator|||
name|istreq
argument_list|(
name|ident
argument_list|,
literal|"on"
argument_list|)
condition|)
block|{
operator|*
name|set_rtrn
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|ident
argument_list|,
literal|"false"
argument_list|)
operator|||
name|istreq
argument_list|(
name|ident
argument_list|,
literal|"no"
argument_list|)
operator|||
name|istreq
argument_list|(
name|ident
argument_list|,
literal|"off"
argument_list|)
condition|)
block|{
operator|*
name|set_rtrn
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Identifier \"%s\" of type boolean is unknown\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_FIELD_REF
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Default \"%s.%s\" of type boolean is unknown\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|element
argument_list|)
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|field
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_INVERT
case|:
case|case
name|EXPR_NOT
case|:
name|ok
operator|=
name|ExprResolveBoolean
argument_list|(
name|ctx
argument_list|,
name|expr
argument_list|,
name|set_rtrn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|set_rtrn
operator|=
operator|!
operator|*
name|set_rtrn
expr_stmt|;
return|return
name|ok
return|;
case|case
name|EXPR_ADD
case|:
case|case
name|EXPR_SUBTRACT
case|:
case|case
name|EXPR_MULTIPLY
case|:
case|case
name|EXPR_DIVIDE
case|:
case|case
name|EXPR_ASSIGN
case|:
case|case
name|EXPR_NEGATE
case|:
case|case
name|EXPR_UNARY_PLUS
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"%s of boolean values not permitted\n"
argument_list|,
name|expr_op_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Unknown operator %d in ResolveBoolean\n"
argument_list|,
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveKeyCode
name|ExprResolveKeyCode
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|xkb_keycode_t
modifier|*
name|kc
parameter_list|)
block|{
name|xkb_keycode_t
name|leftRtrn
decl_stmt|,
name|rightRtrn
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_VALUE
case|:
if|if
condition|(
name|expr
operator|->
name|expr
operator|.
name|value_type
operator|!=
name|EXPR_TYPE_INT
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Found constant of type %s where an int was expected\n"
argument_list|,
name|expr_value_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|kc
operator|=
operator|(
name|xkb_keycode_t
operator|)
name|expr
operator|->
name|integer
operator|.
name|ival
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_ADD
case|:
case|case
name|EXPR_SUBTRACT
case|:
case|case
name|EXPR_MULTIPLY
case|:
case|case
name|EXPR_DIVIDE
case|:
if|if
condition|(
operator|!
name|ExprResolveKeyCode
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|binary
operator|.
name|left
argument_list|,
operator|&
name|leftRtrn
argument_list|)
operator|||
operator|!
name|ExprResolveKeyCode
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|binary
operator|.
name|right
argument_list|,
operator|&
name|rightRtrn
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_ADD
case|:
operator|*
name|kc
operator|=
name|leftRtrn
operator|+
name|rightRtrn
expr_stmt|;
break|break;
case|case
name|EXPR_SUBTRACT
case|:
operator|*
name|kc
operator|=
name|leftRtrn
operator|-
name|rightRtrn
expr_stmt|;
break|break;
case|case
name|EXPR_MULTIPLY
case|:
operator|*
name|kc
operator|=
name|leftRtrn
operator|*
name|rightRtrn
expr_stmt|;
break|break;
case|case
name|EXPR_DIVIDE
case|:
if|if
condition|(
name|rightRtrn
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Cannot divide by zero: %d / %d\n"
argument_list|,
name|leftRtrn
argument_list|,
name|rightRtrn
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|kc
operator|=
name|leftRtrn
operator|/
name|rightRtrn
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|true
return|;
case|case
name|EXPR_NEGATE
case|:
if|if
condition|(
operator|!
name|ExprResolveKeyCode
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|unary
operator|.
name|child
argument_list|,
operator|&
name|leftRtrn
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|kc
operator|=
operator|~
name|leftRtrn
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_UNARY_PLUS
case|:
return|return
name|ExprResolveKeyCode
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|unary
operator|.
name|child
argument_list|,
name|kc
argument_list|)
return|;
default|default:
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Unknown operator %d in ResolveKeyCode\n"
argument_list|,
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|false
return|;
block|}
end_function
begin_comment
comment|/**  * This function returns ... something.  It's a bit of a guess, really.  *  * If an integer is given in value ctx, it will be returned in ival.  * If an ident or field reference is given, the lookup function (if given)  * will be called.  At the moment, only SimpleLookup use this, and they both  * return the results in uval.  And don't support field references.  *  * Cool.  */
end_comment
begin_function
specifier|static
name|bool
DECL|function|ExprResolveIntegerLookup
name|ExprResolveIntegerLookup
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|int
modifier|*
name|val_rtrn
parameter_list|,
name|IdentLookupFunc
name|lookup
parameter_list|,
specifier|const
name|void
modifier|*
name|lookupPriv
parameter_list|)
block|{
name|bool
name|ok
init|=
name|false
decl_stmt|;
name|int
name|l
decl_stmt|,
name|r
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
name|ExprDef
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_VALUE
case|:
if|if
condition|(
name|expr
operator|->
name|expr
operator|.
name|value_type
operator|!=
name|EXPR_TYPE_INT
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Found constant of type %s where an int was expected\n"
argument_list|,
name|expr_value_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|val_rtrn
operator|=
name|expr
operator|->
name|integer
operator|.
name|ival
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_IDENT
case|:
if|if
condition|(
name|lookup
condition|)
name|ok
operator|=
name|lookup
argument_list|(
name|ctx
argument_list|,
name|lookupPriv
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|,
name|EXPR_TYPE_INT
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Identifier \"%s\" of type int is unknown\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|val_rtrn
operator|=
operator|(
name|int
operator|)
name|u
expr_stmt|;
return|return
name|ok
return|;
case|case
name|EXPR_FIELD_REF
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Default \"%s.%s\" of type int is unknown\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|element
argument_list|)
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|field
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_ADD
case|:
case|case
name|EXPR_SUBTRACT
case|:
case|case
name|EXPR_MULTIPLY
case|:
case|case
name|EXPR_DIVIDE
case|:
name|left
operator|=
name|expr
operator|->
name|binary
operator|.
name|left
expr_stmt|;
name|right
operator|=
name|expr
operator|->
name|binary
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|left
argument_list|,
operator|&
name|l
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
operator|||
operator|!
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|right
argument_list|,
operator|&
name|r
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_ADD
case|:
operator|*
name|val_rtrn
operator|=
name|l
operator|+
name|r
expr_stmt|;
break|break;
case|case
name|EXPR_SUBTRACT
case|:
operator|*
name|val_rtrn
operator|=
name|l
operator|-
name|r
expr_stmt|;
break|break;
case|case
name|EXPR_MULTIPLY
case|:
operator|*
name|val_rtrn
operator|=
name|l
operator|*
name|r
expr_stmt|;
break|break;
case|case
name|EXPR_DIVIDE
case|:
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Cannot divide by zero: %d / %d\n"
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|val_rtrn
operator|=
name|l
operator|/
name|r
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|true
return|;
case|case
name|EXPR_ASSIGN
case|:
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Assignment operator not implemented yet\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_NOT
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"The ! operator cannot be applied to an integer\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_INVERT
case|:
case|case
name|EXPR_NEGATE
case|:
name|left
operator|=
name|expr
operator|->
name|unary
operator|.
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|left
argument_list|,
operator|&
name|l
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|val_rtrn
operator|=
operator|(
name|expr
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
condition|?
operator|-
name|l
else|:
operator|~
name|l
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_UNARY_PLUS
case|:
name|left
operator|=
name|expr
operator|->
name|unary
operator|.
name|child
expr_stmt|;
return|return
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|left
argument_list|,
name|val_rtrn
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
return|;
default|default:
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Unknown operator %d in ResolveInteger\n"
argument_list|,
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveInteger
name|ExprResolveInteger
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|int
modifier|*
name|val_rtrn
parameter_list|)
block|{
return|return
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|expr
argument_list|,
name|val_rtrn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveGroup
name|ExprResolveGroup
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|xkb_layout_index_t
modifier|*
name|group_rtrn
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|int
name|result
decl_stmt|;
name|ok
operator|=
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|expr
argument_list|,
operator|&
name|result
argument_list|,
name|SimpleLookup
argument_list|,
name|groupNames
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
if|if
condition|(
name|result
operator|<=
literal|0
operator|||
name|result
operator|>
name|XKB_MAX_GROUPS
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Group index %u is out of range (1..%d)\n"
argument_list|,
name|result
argument_list|,
name|XKB_MAX_GROUPS
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|group_rtrn
operator|=
operator|(
name|xkb_layout_index_t
operator|)
name|result
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveLevel
name|ExprResolveLevel
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|xkb_level_index_t
modifier|*
name|level_rtrn
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|int
name|result
decl_stmt|;
name|ok
operator|=
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|expr
argument_list|,
operator|&
name|result
argument_list|,
name|SimpleLookup
argument_list|,
name|levelNames
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
if|if
condition|(
name|result
operator|<
literal|1
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Shift level %d is out of range\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Level is zero-indexed from now on. */
operator|*
name|level_rtrn
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|result
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveButton
name|ExprResolveButton
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|int
modifier|*
name|btn_rtrn
parameter_list|)
block|{
return|return
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|expr
argument_list|,
name|btn_rtrn
argument_list|,
name|SimpleLookup
argument_list|,
name|buttonNames
argument_list|)
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveString
name|ExprResolveString
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|xkb_atom_t
modifier|*
name|val_rtrn
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_VALUE
case|:
if|if
condition|(
name|expr
operator|->
name|expr
operator|.
name|value_type
operator|!=
name|EXPR_TYPE_STRING
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Found constant of type %s, expected a string\n"
argument_list|,
name|expr_value_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|val_rtrn
operator|=
name|expr
operator|->
name|string
operator|.
name|str
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_IDENT
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Identifier \"%s\" of type string not found\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_FIELD_REF
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Default \"%s.%s\" of type string not found\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|element
argument_list|)
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|field
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_ADD
case|:
case|case
name|EXPR_SUBTRACT
case|:
case|case
name|EXPR_MULTIPLY
case|:
case|case
name|EXPR_DIVIDE
case|:
case|case
name|EXPR_ASSIGN
case|:
case|case
name|EXPR_NEGATE
case|:
case|case
name|EXPR_INVERT
case|:
case|case
name|EXPR_NOT
case|:
case|case
name|EXPR_UNARY_PLUS
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"%s of strings not permitted\n"
argument_list|,
name|expr_op_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
default|default:
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Unknown operator %d in ResolveString\n"
argument_list|,
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveEnum
name|ExprResolveEnum
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|unsigned
name|int
modifier|*
name|val_rtrn
parameter_list|,
specifier|const
name|LookupEntry
modifier|*
name|values
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
operator|!=
name|EXPR_IDENT
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Found a %s where an enumerated value was expected\n"
argument_list|,
name|expr_op_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|SimpleLookup
argument_list|(
name|ctx
argument_list|,
name|values
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|,
name|EXPR_TYPE_INT
argument_list|,
name|val_rtrn
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Illegal identifier %s; expected one of:\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|values
operator|&&
name|values
operator|->
name|name
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"\t%s\n"
argument_list|,
name|values
operator|->
name|name
argument_list|)
expr_stmt|;
name|values
operator|++
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|ExprResolveMaskLookup
name|ExprResolveMaskLookup
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|unsigned
name|int
modifier|*
name|val_rtrn
parameter_list|,
name|IdentLookupFunc
name|lookup
parameter_list|,
specifier|const
name|void
modifier|*
name|lookupPriv
parameter_list|)
block|{
name|bool
name|ok
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|l
decl_stmt|,
name|r
decl_stmt|;
name|int
name|v
decl_stmt|;
name|ExprDef
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
specifier|const
name|char
modifier|*
name|bogus
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_VALUE
case|:
if|if
condition|(
name|expr
operator|->
name|expr
operator|.
name|value_type
operator|!=
name|EXPR_TYPE_INT
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Found constant of type %s where a mask was expected\n"
argument_list|,
name|expr_value_type_to_string
argument_list|(
name|expr
operator|->
name|expr
operator|.
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|val_rtrn
operator|=
operator|(
name|unsigned
name|int
operator|)
name|expr
operator|->
name|integer
operator|.
name|ival
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_IDENT
case|:
name|ok
operator|=
name|lookup
argument_list|(
name|ctx
argument_list|,
name|lookupPriv
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|,
name|EXPR_TYPE_INT
argument_list|,
name|val_rtrn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Identifier \"%s\" of type int is unknown\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
case|case
name|EXPR_FIELD_REF
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Default \"%s.%s\" of type int is unknown\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|element
argument_list|)
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|field_ref
operator|.
name|field
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_ARRAY_REF
case|:
name|bogus
operator|=
literal|"array reference"
expr_stmt|;
case|case
name|EXPR_ACTION_DECL
case|:
if|if
condition|(
name|bogus
operator|==
name|NULL
condition|)
name|bogus
operator|=
literal|"function use"
expr_stmt|;
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Unexpected %s in mask expression; Expression Ignored\n"
argument_list|,
name|bogus
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|EXPR_ADD
case|:
case|case
name|EXPR_SUBTRACT
case|:
case|case
name|EXPR_MULTIPLY
case|:
case|case
name|EXPR_DIVIDE
case|:
name|left
operator|=
name|expr
operator|->
name|binary
operator|.
name|left
expr_stmt|;
name|right
operator|=
name|expr
operator|->
name|binary
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
name|ExprResolveMaskLookup
argument_list|(
name|ctx
argument_list|,
name|left
argument_list|,
operator|&
name|l
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
operator|||
operator|!
name|ExprResolveMaskLookup
argument_list|(
name|ctx
argument_list|,
name|right
argument_list|,
operator|&
name|r
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
condition|)
block|{
case|case
name|EXPR_ADD
case|:
operator|*
name|val_rtrn
operator|=
name|l
operator||
name|r
expr_stmt|;
break|break;
case|case
name|EXPR_SUBTRACT
case|:
operator|*
name|val_rtrn
operator|=
name|l
operator|&
operator|(
operator|~
name|r
operator|)
expr_stmt|;
break|break;
case|case
name|EXPR_MULTIPLY
case|:
case|case
name|EXPR_DIVIDE
case|:
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Cannot %s masks; Illegal operation ignored\n"
argument_list|,
operator|(
name|expr
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_DIVIDE
condition|?
literal|"divide"
else|:
literal|"multiply"
operator|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
default|default:
break|break;
block|}
return|return
name|true
return|;
case|case
name|EXPR_ASSIGN
case|:
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Assignment operator not implemented yet\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_INVERT
case|:
name|left
operator|=
name|expr
operator|->
name|unary
operator|.
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|left
argument_list|,
operator|&
name|v
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|val_rtrn
operator|=
operator|~
name|v
expr_stmt|;
return|return
name|true
return|;
case|case
name|EXPR_UNARY_PLUS
case|:
case|case
name|EXPR_NEGATE
case|:
case|case
name|EXPR_NOT
case|:
name|left
operator|=
name|expr
operator|->
name|unary
operator|.
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|ExprResolveIntegerLookup
argument_list|(
name|ctx
argument_list|,
name|left
argument_list|,
operator|&
name|v
argument_list|,
name|lookup
argument_list|,
name|lookupPriv
argument_list|)
condition|)
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"The %s operator cannot be used with a mask\n"
argument_list|,
operator|(
name|expr
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
condition|?
literal|"-"
else|:
literal|"!"
operator|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
default|default:
name|log_wsgo
argument_list|(
name|ctx
argument_list|,
literal|"Unknown operator %d in ResolveMask\n"
argument_list|,
name|expr
operator|->
name|expr
operator|.
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveMask
name|ExprResolveMask
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|unsigned
name|int
modifier|*
name|mask_rtrn
parameter_list|,
specifier|const
name|LookupEntry
modifier|*
name|values
parameter_list|)
block|{
return|return
name|ExprResolveMaskLookup
argument_list|(
name|ctx
argument_list|,
name|expr
argument_list|,
name|mask_rtrn
argument_list|,
name|SimpleLookup
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveModMask
name|ExprResolveModMask
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|enum
name|mod_type
name|mod_type
parameter_list|,
name|xkb_mod_mask_t
modifier|*
name|mask_rtrn
parameter_list|)
block|{
name|LookupModMaskPriv
name|priv
init|=
block|{
operator|.
name|keymap
operator|=
name|keymap
block|,
operator|.
name|mod_type
operator|=
name|mod_type
block|}
decl_stmt|;
return|return
name|ExprResolveMaskLookup
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|expr
argument_list|,
name|mask_rtrn
argument_list|,
name|LookupModMask
argument_list|,
operator|&
name|priv
argument_list|)
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveKeySym
name|ExprResolveKeySym
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|expr
parameter_list|,
name|xkb_keysym_t
modifier|*
name|sym_rtrn
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_IDENT
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|expr
operator|->
name|ident
operator|.
name|ident
argument_list|)
decl_stmt|;
operator|*
name|sym_rtrn
operator|=
name|xkb_keysym_from_name
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sym_rtrn
operator|!=
name|XKB_KEY_NoSymbol
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|ExprResolveInteger
argument_list|(
name|ctx
argument_list|,
name|expr
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>=
literal|10
condition|)
return|return
name|false
return|;
operator|*
name|sym_rtrn
operator|=
name|XKB_KEY_0
operator|+
operator|(
name|xkb_keysym_t
operator|)
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|ExprResolveMod
name|ExprResolveMod
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|def
parameter_list|,
name|enum
name|mod_type
name|mod_type
parameter_list|,
name|xkb_mod_index_t
modifier|*
name|ndx_rtrn
parameter_list|)
block|{
name|xkb_mod_index_t
name|ndx
decl_stmt|;
name|xkb_atom_t
name|name
decl_stmt|;
if|if
condition|(
name|def
operator|->
name|expr
operator|.
name|op
operator|!=
name|EXPR_IDENT
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot resolve virtual modifier: "
literal|"found %s where a virtual modifier name was expected\n"
argument_list|,
name|expr_op_type_to_string
argument_list|(
name|def
operator|->
name|expr
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|name
operator|=
name|def
operator|->
name|ident
operator|.
name|ident
expr_stmt|;
name|ndx
operator|=
name|ModNameToIndex
argument_list|(
name|keymap
argument_list|,
name|name
argument_list|,
name|mod_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|==
name|XKB_MOD_INVALID
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot resolve virtual modifier: "
literal|"\"%s\" was not previously declared\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|ndx_rtrn
operator|=
name|ndx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
end_unit
