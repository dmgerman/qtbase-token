begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"vmod.h"
end_include
begin_include
include|#
directive|include
file|"expr.h"
end_include
begin_include
include|#
directive|include
file|"include.h"
end_include
begin_comment
comment|/*  * The xkb_types section  * =====================  * This section is the second to be processesed, after xkb_keycodes.  * However, it is completely independent and could have been the first  * to be processed (it does not refer to specific keys as specified in  * the xkb_keycodes section).  *  * This section defines key types, which, given a key and a keyboard  * state (i.e. modifier state and group), determine the shift level to  * be used in translating the key to keysyms. These types are assigned  * to each group in each key, in the xkb_symbols section.  *  * Key types are called this way because, in a way, they really describe  * the "type" of the key (or more correctly, a specific group of the  * key). For example, an ordinary keymap will provide a type called  * "KEYPAD", which consists of two levels, with the second level being  * chosen according to the state of the Num Lock (or Shift) modifiers.  * Another example is a type called "ONE_LEVEL", which is usually  * assigned to keys such as Escape; these have just one level and are  * not affected by the modifier state. Yet more common examples are  * "TWO_LEVEL" (with Shift choosing the second level), "ALPHABETIC"  * (where Caps Lock may also choose the second level), etc.  *  * Type definitions  * ----------------  *  Statements of the form:  *      type "FOUR_LEVEL" { ... }  *  * The above would create a new type named "FOUR_LEVEL".  * The body of the definition may include statements of the following  * forms:  *  * - level_name statements (mandatory for each level in the type):  *      level_name[Level1] = "Base";  *  *   Gives each level in this type a descriptive name. It isn't used  *   for any thing.  *   Note: A level may be specified as Level[1-8] or just a number (can  *   be more than 8).  *  * - modifiers statement (mandatory, should be specified only once):  *      modifiers = Shift+Lock+LevelThree;  *  *   A mask of real and virtual modifiers. These are the only modifiers  *   being considered when matching the modifier state against the type.  *   The other modifiers, whether active or not, are masked out in the  *   calculation.  *  * - map entry statements (should have at least as many mappings as there  *   are levels in the type):  *      map[Shift+LevelThree] = Level4;  *  *   If the active modifiers, masked with the type's modifiers (as stated  *   above), match (i.e. equal) the modifiers inside the map[] statement,  *   then the level in the right hand side is chosen. For example, in the  *   above, if in the current keyboard state the Shift and LevelThree  *   modifiers are active, while the Lock modifier is not, then the  *   keysym(s) in the 4th level of the group will be returned to the  *   user.  *  * - preserve statements:  *      map[Shift+Lock+LevelThree] = Level5;  *      preserve[Shift+Lock+LevelThree] = Lock;  *  *   When a map entry matches the active modifiers and the level it  *   specified is chosen, then these modifiers are said to be "consumed";  *   for example, in a simple US keymap where the "g" key is assigned an  *   ordinary ALPHABETIC key type, if the Lock (Caps Lock) modifier is  *   active and the key is pressed, then a "G" keysym is produced (as  *   opposed to lower-case "g"). This is because the type definition has  *   a map entry like the following:  *      map[Lock] = Level2;  *   And as such the Lock modifier is consumed. This information is  *   relevant for applications which further process the modifiers,  *   since by then the consumed modifiers have already "done their part"  *   and should be masked out.  *  *   However, sometimes even if a modifier is actually used to choose  *   the shift level (as Lock above), it should *not* be reported as  *   consumed, for various reasons. In this case, a preserve[] statement  *   can be used to augment the map entry. The modifiers inside the square  *   brackets should match one of the map[] statements in the type. The  *   right hand side should consists of modifiers from the left hand  *   side; these modifiers are then "preserved" and not reported as  *   consumed.  *  * Virtual modifier statements  * ---------------------------  * Statements of the form:  *     virtual_modifiers LControl;  *  * Can appear in the xkb_types, xkb_compat, xkb_symbols sections.  * TODO  *  * Effect on keymap  * ----------------  * After all of the xkb_types sections have been compiled, the following  * members of struct xkb_keymap are finalized:  *      struct xkb_key_type *types;  *      unsigned int num_types;  *      char *types_section_name;  * TODO: virtual modifiers.  */
end_comment
begin_enum
DECL|enum|type_field
enum|enum
name|type_field
block|{
DECL|enumerator|TYPE_FIELD_MASK
name|TYPE_FIELD_MASK
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|TYPE_FIELD_MAP
name|TYPE_FIELD_MAP
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|TYPE_FIELD_PRESERVE
name|TYPE_FIELD_PRESERVE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
DECL|enumerator|TYPE_FIELD_LEVEL_NAME
name|TYPE_FIELD_LEVEL_NAME
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|, }
enum|;
end_enum
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|defined
name|enum
name|type_field
name|defined
decl_stmt|;
DECL|member|merge
name|enum
name|merge_mode
name|merge
decl_stmt|;
DECL|member|name
name|xkb_atom_t
name|name
decl_stmt|;
DECL|member|mods
name|xkb_mod_mask_t
name|mods
decl_stmt|;
DECL|member|num_levels
name|xkb_level_index_t
name|num_levels
decl_stmt|;
DECL|member|entries
name|darray
argument_list|(
argument|struct xkb_key_type_entry
argument_list|)
name|entries
expr_stmt|;
name|darray
argument_list|(
argument|xkb_atom_t
argument_list|)
name|level_names
expr_stmt|;
block|}
DECL|typedef|KeyTypeInfo
name|KeyTypeInfo
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|errorCount
name|int
name|errorCount
decl_stmt|;
name|darray
argument_list|(
argument|KeyTypeInfo
argument_list|)
name|types
expr_stmt|;
DECL|member|keymap
name|struct
name|xkb_keymap
modifier|*
name|keymap
decl_stmt|;
block|}
DECL|typedef|KeyTypesInfo
name|KeyTypesInfo
typedef|;
end_typedef
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
DECL|function|MapEntryTxt
name|MapEntryTxt
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
parameter_list|)
block|{
return|return
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|entry
operator|->
name|mods
operator|.
name|mods
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
DECL|function|TypeTxt
name|TypeTxt
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|)
block|{
return|return
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
DECL|function|TypeMaskTxt
name|TypeMaskTxt
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|)
block|{
return|return
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|type
operator|->
name|mods
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportTypeShouldBeArray
name|ReportTypeShouldBeArray
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|)
block|{
return|return
name|ReportShouldBeArray
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"key type"
argument_list|,
name|field
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportTypeBadType
name|ReportTypeBadType
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|wanted
parameter_list|)
block|{
return|return
name|ReportBadType
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"key type"
argument_list|,
name|field
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
name|wanted
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportTypeBadWidth
name|ReportTypeBadWidth
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|has
parameter_list|,
name|int
name|needs
parameter_list|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Key type \"%s\" has %d levels, must have %d; "
literal|"Illegal type definition ignored\n"
argument_list|,
name|type
argument_list|,
name|has
argument_list|,
name|needs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|void
DECL|function|InitKeyTypesInfo
name|InitKeyTypesInfo
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
block|{
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|keymap
operator|=
name|keymap
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ClearKeyTypeInfo
name|ClearKeyTypeInfo
parameter_list|(
name|KeyTypeInfo
modifier|*
name|type
parameter_list|)
block|{
name|darray_free
argument_list|(
name|type
operator|->
name|entries
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|type
operator|->
name|level_names
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ClearKeyTypesInfo
name|ClearKeyTypesInfo
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|)
block|{
name|free
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|info
operator|->
name|types
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|KeyTypeInfo
modifier|*
DECL|function|FindMatchingKeyType
name|FindMatchingKeyType
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|xkb_atom_t
name|name
parameter_list|)
block|{
name|KeyTypeInfo
modifier|*
name|old
decl_stmt|;
name|darray_foreach
argument_list|(
argument|old
argument_list|,
argument|info->types
argument_list|)
if|if
condition|(
name|old
operator|->
name|name
operator|==
name|name
condition|)
return|return
name|old
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddKeyType
name|AddKeyType
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|new
parameter_list|,
name|bool
name|same_file
parameter_list|)
block|{
name|KeyTypeInfo
modifier|*
name|old
decl_stmt|;
specifier|const
name|int
name|verbosity
init|=
name|xkb_context_get_log_verbosity
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|)
decl_stmt|;
name|old
operator|=
name|FindMatchingKeyType
argument_list|(
name|info
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
if|if
condition|(
name|new
operator|->
name|merge
operator|==
name|MERGE_REPLACE
operator|||
name|new
operator|->
name|merge
operator|==
name|MERGE_OVERRIDE
condition|)
block|{
if|if
condition|(
operator|(
name|same_file
operator|&&
name|verbosity
operator|>
literal|0
operator|)
operator|||
name|verbosity
operator|>
literal|9
condition|)
block|{
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Multiple definitions of the %s key type; "
literal|"Earlier definition ignored\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ClearKeyTypeInfo
argument_list|(
name|old
argument_list|)
expr_stmt|;
operator|*
name|old
operator|=
operator|*
name|new
expr_stmt|;
name|darray_init
argument_list|(
name|new
operator|->
name|entries
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|new
operator|->
name|level_names
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|same_file
condition|)
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|4
argument_list|,
literal|"Multiple definitions of the %s key type; "
literal|"Later definition ignored\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ClearKeyTypeInfo
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|darray_append
argument_list|(
name|info
operator|->
name|types
argument_list|,
operator|*
name|new
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|void
DECL|function|MergeIncludedKeyTypes
name|MergeIncludedKeyTypes
parameter_list|(
name|KeyTypesInfo
modifier|*
name|into
parameter_list|,
name|KeyTypesInfo
modifier|*
name|from
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|KeyTypeInfo
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|from
operator|->
name|errorCount
operator|>
literal|0
condition|)
block|{
name|into
operator|->
name|errorCount
operator|+=
name|from
operator|->
name|errorCount
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|into
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|into
operator|->
name|name
operator|=
name|from
operator|->
name|name
expr_stmt|;
name|from
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
name|darray_foreach
argument_list|(
argument|type
argument_list|,
argument|from->types
argument_list|)
block|{
name|type
operator|->
name|merge
operator|=
operator|(
name|merge
operator|==
name|MERGE_DEFAULT
condition|?
name|type
operator|->
name|merge
else|:
name|merge
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|AddKeyType
argument_list|(
name|into
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
condition|)
name|into
operator|->
name|errorCount
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|HandleKeyTypesFile
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|XkbFile
modifier|*
name|file
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
name|bool
DECL|function|HandleIncludeKeyTypes
name|HandleIncludeKeyTypes
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|IncludeStmt
modifier|*
name|include
parameter_list|)
block|{
name|KeyTypesInfo
name|included
decl_stmt|;
name|InitKeyTypesInfo
argument_list|(
operator|&
name|included
argument_list|,
name|info
operator|->
name|keymap
argument_list|)
expr_stmt|;
name|included
operator|.
name|name
operator|=
name|include
operator|->
name|stmt
expr_stmt|;
name|include
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|IncludeStmt
modifier|*
name|stmt
init|=
name|include
init|;
name|stmt
condition|;
name|stmt
operator|=
name|stmt
operator|->
name|next_incl
control|)
block|{
name|KeyTypesInfo
name|next_incl
decl_stmt|;
name|XkbFile
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|ProcessIncludeFile
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|stmt
argument_list|,
name|FILE_TYPE_TYPES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|info
operator|->
name|errorCount
operator|+=
literal|10
expr_stmt|;
name|ClearKeyTypesInfo
argument_list|(
operator|&
name|included
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|InitKeyTypesInfo
argument_list|(
operator|&
name|next_incl
argument_list|,
name|info
operator|->
name|keymap
argument_list|)
expr_stmt|;
name|HandleKeyTypesFile
argument_list|(
operator|&
name|next_incl
argument_list|,
name|file
argument_list|,
name|stmt
operator|->
name|merge
argument_list|)
expr_stmt|;
name|MergeIncludedKeyTypes
argument_list|(
operator|&
name|included
argument_list|,
operator|&
name|next_incl
argument_list|,
name|stmt
operator|->
name|merge
argument_list|)
expr_stmt|;
name|ClearKeyTypesInfo
argument_list|(
operator|&
name|next_incl
argument_list|)
expr_stmt|;
name|FreeXkbFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|MergeIncludedKeyTypes
argument_list|(
name|info
argument_list|,
operator|&
name|included
argument_list|,
name|include
operator|->
name|merge
argument_list|)
expr_stmt|;
name|ClearKeyTypesInfo
argument_list|(
operator|&
name|included
argument_list|)
expr_stmt|;
return|return
operator|(
name|info
operator|->
name|errorCount
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|SetModifiers
name|SetModifiers
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|xkb_mod_mask_t
name|mods
decl_stmt|;
if|if
condition|(
name|arrayNdx
condition|)
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The modifiers field of a key type is not an array; "
literal|"Illegal array subscript ignored\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExprResolveModMask
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|value
argument_list|,
name|MOD_BOTH
argument_list|,
operator|&
name|mods
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Key type mask field must be a modifier mask; "
literal|"Key type definition ignored\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|type
operator|->
name|defined
operator|&
name|TYPE_FIELD_MASK
condition|)
block|{
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Multiple modifier mask definitions for key type %s; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
argument_list|,
name|TypeMaskTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|mods
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|type
operator|->
name|mods
operator|=
name|mods
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|struct
name|xkb_key_type_entry
modifier|*
DECL|function|FindMatchingMapEntry
name|FindMatchingMapEntry
parameter_list|(
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|xkb_mod_mask_t
name|mods
parameter_list|)
block|{
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
decl_stmt|;
name|darray_foreach
argument_list|(
argument|entry
argument_list|,
argument|type->entries
argument_list|)
if|if
condition|(
name|entry
operator|->
name|mods
operator|.
name|mods
operator|==
name|mods
condition|)
return|return
name|entry
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddMapEntry
name|AddMapEntry
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|struct
name|xkb_key_type_entry
modifier|*
name|new
parameter_list|,
name|bool
name|clobber
parameter_list|,
name|bool
name|report
parameter_list|)
block|{
name|struct
name|xkb_key_type_entry
modifier|*
name|old
decl_stmt|;
name|old
operator|=
name|FindMatchingMapEntry
argument_list|(
name|type
argument_list|,
name|new
operator|->
name|mods
operator|.
name|mods
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
if|if
condition|(
name|report
operator|&&
name|old
operator|->
name|level
operator|!=
name|new
operator|->
name|level
condition|)
block|{
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Multiple map entries for %s in %s; "
literal|"Using %d, ignoring %d\n"
argument_list|,
name|MapEntryTxt
argument_list|(
name|info
argument_list|,
name|new
argument_list|)
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
operator|(
name|clobber
condition|?
name|new
operator|->
name|level
else|:
name|old
operator|->
name|level
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|clobber
condition|?
name|old
operator|->
name|level
else|:
name|new
operator|->
name|level
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|10
argument_list|,
literal|"Multiple occurrences of map[%s]= %d in %s; Ignored\n"
argument_list|,
name|MapEntryTxt
argument_list|(
name|info
argument_list|,
name|new
argument_list|)
argument_list|,
name|new
operator|->
name|level
operator|+
literal|1
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|clobber
condition|)
block|{
if|if
condition|(
name|new
operator|->
name|level
operator|>=
name|type
operator|->
name|num_levels
condition|)
name|type
operator|->
name|num_levels
operator|=
name|new
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|old
operator|->
name|level
operator|=
name|new
operator|->
name|level
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|new
operator|->
name|level
operator|>=
name|type
operator|->
name|num_levels
condition|)
name|type
operator|->
name|num_levels
operator|=
name|new
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|darray_append
argument_list|(
name|type
operator|->
name|entries
argument_list|,
operator|*
name|new
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|SetMapEntry
name|SetMapEntry
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_key_type_entry
name|entry
decl_stmt|;
if|if
condition|(
name|arrayNdx
operator|==
name|NULL
condition|)
return|return
name|ReportTypeShouldBeArray
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
literal|"map entry"
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveModMask
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|arrayNdx
argument_list|,
name|MOD_BOTH
argument_list|,
operator|&
name|entry
operator|.
name|mods
operator|.
name|mods
argument_list|)
condition|)
return|return
name|ReportTypeBadType
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
literal|"map entry"
argument_list|,
literal|"modifier mask"
argument_list|)
return|;
if|if
condition|(
name|entry
operator|.
name|mods
operator|.
name|mods
operator|&
operator|(
operator|~
name|type
operator|->
name|mods
operator|)
condition|)
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"Map entry for unused modifiers in %s; "
literal|"Using %s instead of %s\n"
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|entry
operator|.
name|mods
operator|.
name|mods
operator|&
name|type
operator|->
name|mods
argument_list|)
argument_list|,
name|MapEntryTxt
argument_list|(
name|info
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|mods
operator|.
name|mods
operator|&=
name|type
operator|->
name|mods
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ExprResolveLevel
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|entry
operator|.
name|level
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Level specifications in a key type must be integer; "
literal|"Ignoring malformed level specification\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|entry
operator|.
name|preserve
operator|.
name|mods
operator|=
literal|0
expr_stmt|;
return|return
name|AddMapEntry
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
operator|&
name|entry
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|AddPreserve
name|AddPreserve
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|xkb_mod_mask_t
name|mods
parameter_list|,
name|xkb_mod_mask_t
name|preserve_mods
parameter_list|)
block|{
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|xkb_key_type_entry
name|new
decl_stmt|;
name|darray_foreach
argument_list|(
argument|entry
argument_list|,
argument|type->entries
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|mods
operator|.
name|mods
operator|!=
name|mods
condition|)
continue|continue;
comment|/* Map exists without previous preserve (or "None"); override. */
if|if
condition|(
name|entry
operator|->
name|preserve
operator|.
name|mods
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|preserve
operator|.
name|mods
operator|=
name|preserve_mods
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Map exists with same preserve; do nothing. */
if|if
condition|(
name|entry
operator|->
name|preserve
operator|.
name|mods
operator|==
name|preserve_mods
condition|)
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|10
argument_list|,
literal|"Identical definitions for preserve[%s] in %s; "
literal|"Ignored\n"
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|mods
argument_list|)
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Map exists with different preserve; latter wins. */
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"Multiple definitions for preserve[%s] in %s; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|mods
argument_list|)
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|preserve_mods
argument_list|)
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|entry
operator|->
name|preserve
operator|.
name|mods
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|preserve
operator|.
name|mods
operator|=
name|preserve_mods
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/*      * Map does not exist, i.e. preserve[] came before map[].      * Create a map with the specified mask mapping to Level1. The level      * may be overridden later with an explicit map[] statement.      */
name|new
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|new
operator|.
name|mods
operator|.
name|mods
operator|=
name|mods
expr_stmt|;
name|new
operator|.
name|preserve
operator|.
name|mods
operator|=
name|preserve_mods
expr_stmt|;
name|darray_append
argument_list|(
name|type
operator|->
name|entries
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|SetPreserve
name|SetPreserve
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|xkb_mod_mask_t
name|mods
decl_stmt|,
name|preserve_mods
decl_stmt|;
if|if
condition|(
name|arrayNdx
operator|==
name|NULL
condition|)
return|return
name|ReportTypeShouldBeArray
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
literal|"preserve entry"
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveModMask
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|arrayNdx
argument_list|,
name|MOD_BOTH
argument_list|,
operator|&
name|mods
argument_list|)
condition|)
return|return
name|ReportTypeBadType
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
literal|"preserve entry"
argument_list|,
literal|"modifier mask"
argument_list|)
return|;
if|if
condition|(
name|mods
operator|&
operator|~
name|type
operator|->
name|mods
condition|)
block|{
specifier|const
name|char
modifier|*
name|before
decl_stmt|,
modifier|*
name|after
decl_stmt|;
name|before
operator|=
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|mods
argument_list|)
expr_stmt|;
name|mods
operator|&=
name|type
operator|->
name|mods
expr_stmt|;
name|after
operator|=
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|mods
argument_list|)
expr_stmt|;
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"Preserve for modifiers not used by the %s type; "
literal|"Index %s converted to %s\n"
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
name|before
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ExprResolveModMask
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|value
argument_list|,
name|MOD_BOTH
argument_list|,
operator|&
name|preserve_mods
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Preserve value in a key type is not a modifier mask; "
literal|"Ignoring preserve[%s] in type %s\n"
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|mods
argument_list|)
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|preserve_mods
operator|&
operator|~
name|mods
condition|)
block|{
specifier|const
name|char
modifier|*
name|before
decl_stmt|,
modifier|*
name|after
decl_stmt|;
name|before
operator|=
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|preserve_mods
argument_list|)
expr_stmt|;
name|preserve_mods
operator|&=
name|mods
expr_stmt|;
name|after
operator|=
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|preserve_mods
argument_list|)
expr_stmt|;
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"Illegal value for preserve[%s] in type %s; "
literal|"Converted %s to %s\n"
argument_list|,
name|ModMaskText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|mods
argument_list|)
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
name|before
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|AddPreserve
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|mods
argument_list|,
name|preserve_mods
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|AddLevelName
name|AddLevelName
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|xkb_level_index_t
name|level
parameter_list|,
name|xkb_atom_t
name|name
parameter_list|,
name|bool
name|clobber
parameter_list|)
block|{
comment|/* New name. */
if|if
condition|(
name|level
operator|>=
name|darray_size
argument_list|(
name|type
operator|->
name|level_names
argument_list|)
condition|)
block|{
name|darray_resize0
argument_list|(
name|type
operator|->
name|level_names
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Same level, same name. */
if|if
condition|(
name|darray_item
argument_list|(
name|type
operator|->
name|level_names
argument_list|,
name|level
argument_list|)
operator|==
name|name
condition|)
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|10
argument_list|,
literal|"Duplicate names for level %d of key type %s; Ignored\n"
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Same level, different name. */
if|if
condition|(
name|darray_item
argument_list|(
name|type
operator|->
name|level_names
argument_list|,
name|level
argument_list|)
operator|!=
name|XKB_ATOM_NONE
condition|)
block|{
specifier|const
name|char
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|old
operator|=
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|darray_item
argument_list|(
name|type
operator|->
name|level_names
argument_list|,
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"Multiple names for level %d of key type %s; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|,
operator|(
name|clobber
condition|?
name|new
else|:
name|old
operator|)
argument_list|,
operator|(
name|clobber
condition|?
name|old
else|:
name|new
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clobber
condition|)
return|return
name|true
return|;
block|}
comment|/* XXX: What about different level, same name? */
name|finish
label|:
name|darray_item
argument_list|(
name|type
operator|->
name|level_names
argument_list|,
name|level
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|SetLevelName
name|SetLevelName
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|xkb_level_index_t
name|level
decl_stmt|;
name|xkb_atom_t
name|level_name
decl_stmt|;
name|struct
name|xkb_context
modifier|*
name|ctx
init|=
name|info
operator|->
name|keymap
operator|->
name|ctx
decl_stmt|;
if|if
condition|(
name|arrayNdx
operator|==
name|NULL
condition|)
return|return
name|ReportTypeShouldBeArray
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
literal|"level name"
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveLevel
argument_list|(
name|ctx
argument_list|,
name|arrayNdx
argument_list|,
operator|&
name|level
argument_list|)
condition|)
return|return
name|ReportTypeBadType
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
literal|"level name"
argument_list|,
literal|"integer"
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveString
argument_list|(
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|level_name
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Non-string name for level %d in key type %s; "
literal|"Ignoring illegal level name definition\n"
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|AddLevelName
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|level
argument_list|,
name|level_name
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|SetKeyTypeField
name|SetKeyTypeField
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|bool
name|ok
init|=
name|false
decl_stmt|;
name|enum
name|type_field
name|type_field
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"modifiers"
argument_list|)
condition|)
block|{
name|type_field
operator|=
name|TYPE_FIELD_MASK
expr_stmt|;
name|ok
operator|=
name|SetModifiers
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|arrayNdx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"map"
argument_list|)
condition|)
block|{
name|type_field
operator|=
name|TYPE_FIELD_MAP
expr_stmt|;
name|ok
operator|=
name|SetMapEntry
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|arrayNdx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"preserve"
argument_list|)
condition|)
block|{
name|type_field
operator|=
name|TYPE_FIELD_PRESERVE
expr_stmt|;
name|ok
operator|=
name|SetPreserve
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|arrayNdx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"levelname"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"level_name"
argument_list|)
condition|)
block|{
name|type_field
operator|=
name|TYPE_FIELD_LEVEL_NAME
expr_stmt|;
name|ok
operator|=
name|SetLevelName
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|arrayNdx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Unknown field %s in key type %s; Definition ignored\n"
argument_list|,
name|field
argument_list|,
name|TypeTxt
argument_list|(
name|info
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|->
name|defined
operator||=
name|type_field
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleKeyTypeBody
name|HandleKeyTypeBody
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|VarDef
modifier|*
name|def
parameter_list|,
name|KeyTypeInfo
modifier|*
name|type
parameter_list|)
block|{
name|bool
name|ok
init|=
name|true
decl_stmt|;
specifier|const
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|ExprDef
modifier|*
name|arrayNdx
decl_stmt|;
for|for
control|(
init|;
name|def
condition|;
name|def
operator|=
operator|(
name|VarDef
operator|*
operator|)
name|def
operator|->
name|common
operator|.
name|next
control|)
block|{
name|ok
operator|=
name|ExprResolveLhs
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|def
operator|->
name|name
argument_list|,
operator|&
name|elem
argument_list|,
operator|&
name|field
argument_list|,
operator|&
name|arrayNdx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
if|if
condition|(
name|elem
operator|&&
name|istreq
argument_list|(
name|elem
argument_list|,
literal|"type"
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Support for changing the default type has been removed; "
literal|"Statement ignored\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ok
operator|=
name|SetKeyTypeField
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
name|field
argument_list|,
name|arrayNdx
argument_list|,
name|def
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleKeyTypeDef
name|HandleKeyTypeDef
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|KeyTypeDef
modifier|*
name|def
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|KeyTypeInfo
name|type
init|=
block|{
operator|.
name|defined
operator|=
literal|0
block|,
operator|.
name|merge
operator|=
operator|(
name|def
operator|->
name|merge
operator|==
name|MERGE_DEFAULT
operator|?
name|merge
operator|:
name|def
operator|->
name|merge
operator|)
block|,
operator|.
name|name
operator|=
name|def
operator|->
name|name
block|,
operator|.
name|mods
operator|=
literal|0
block|,
operator|.
name|num_levels
operator|=
literal|1
block|,
operator|.
name|entries
operator|=
name|darray_new
argument_list|()
block|,
operator|.
name|level_names
operator|=
name|darray_new
argument_list|()
block|,     }
decl_stmt|;
if|if
condition|(
operator|!
name|HandleKeyTypeBody
argument_list|(
name|info
argument_list|,
name|def
operator|->
name|body
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|AddKeyType
argument_list|(
name|info
argument_list|,
operator|&
name|type
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|HandleKeyTypesFile
name|HandleKeyTypesFile
parameter_list|(
name|KeyTypesInfo
modifier|*
name|info
parameter_list|,
name|XkbFile
modifier|*
name|file
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|free
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|strdup_safe
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ParseCommon
modifier|*
name|stmt
init|=
name|file
operator|->
name|defs
init|;
name|stmt
condition|;
name|stmt
operator|=
name|stmt
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|stmt
operator|->
name|type
condition|)
block|{
case|case
name|STMT_INCLUDE
case|:
name|ok
operator|=
name|HandleIncludeKeyTypes
argument_list|(
name|info
argument_list|,
operator|(
name|IncludeStmt
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_TYPE
case|:
name|ok
operator|=
name|HandleKeyTypeDef
argument_list|(
name|info
argument_list|,
operator|(
name|KeyTypeDef
operator|*
operator|)
name|stmt
argument_list|,
name|merge
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_VAR
case|:
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Support for changing the default type has been removed; "
literal|"Statement ignored\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|STMT_VMOD
case|:
name|ok
operator|=
name|HandleVModDef
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
operator|(
name|VModDef
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Key type files may not include other declarations; "
literal|"Ignoring %s\n"
argument_list|,
name|stmt_type_to_string
argument_list|(
name|stmt
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|errorCount
operator|>
literal|10
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Abandoning keytypes file \"%s\"\n"
argument_list|,
name|file
operator|->
name|topName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|CopyKeyTypesToKeymap
name|CopyKeyTypesToKeymap
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|KeyTypesInfo
modifier|*
name|info
parameter_list|)
block|{
name|keymap
operator|->
name|types_section_name
operator|=
name|strdup_safe
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|num_types
operator|=
name|darray_size
argument_list|(
name|info
operator|->
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|keymap
operator|->
name|num_types
operator|==
literal|0
condition|)
name|keymap
operator|->
name|num_types
operator|=
literal|1
expr_stmt|;
name|keymap
operator|->
name|types
operator|=
name|calloc
argument_list|(
name|keymap
operator|->
name|num_types
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|keymap
operator|->
name|types
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * If no types were specified, a default unnamed one-level type is      * used for all keys.      */
if|if
condition|(
name|darray_empty
argument_list|(
name|info
operator|->
name|types
argument_list|)
condition|)
block|{
name|struct
name|xkb_key_type
modifier|*
name|type
init|=
operator|&
name|keymap
operator|->
name|types
index|[
literal|0
index|]
decl_stmt|;
name|type
operator|->
name|mods
operator|.
name|mods
operator|=
literal|0
expr_stmt|;
name|type
operator|->
name|num_levels
operator|=
literal|1
expr_stmt|;
name|type
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
name|type
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
name|type
operator|->
name|name
operator|=
name|xkb_atom_intern
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|type
operator|->
name|level_names
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keymap
operator|->
name|num_types
condition|;
name|i
operator|++
control|)
block|{
name|KeyTypeInfo
modifier|*
name|def
init|=
operator|&
name|darray_item
argument_list|(
name|info
operator|->
name|types
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|xkb_key_type
modifier|*
name|type
init|=
operator|&
name|keymap
operator|->
name|types
index|[
name|i
index|]
decl_stmt|;
name|type
operator|->
name|mods
operator|.
name|mods
operator|=
name|def
operator|->
name|mods
expr_stmt|;
name|type
operator|->
name|num_levels
operator|=
name|def
operator|->
name|num_levels
expr_stmt|;
name|type
operator|->
name|entries
operator|=
name|darray_mem
argument_list|(
name|def
operator|->
name|entries
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|->
name|num_entries
operator|=
name|darray_size
argument_list|(
name|def
operator|->
name|entries
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|def
operator|->
name|entries
argument_list|)
expr_stmt|;
name|type
operator|->
name|name
operator|=
name|def
operator|->
name|name
expr_stmt|;
name|type
operator|->
name|level_names
operator|=
name|darray_mem
argument_list|(
name|def
operator|->
name|level_names
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|def
operator|->
name|level_names
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
name|bool
DECL|function|CompileKeyTypes
name|CompileKeyTypes
parameter_list|(
name|XkbFile
modifier|*
name|file
parameter_list|,
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|KeyTypesInfo
name|info
decl_stmt|;
name|InitKeyTypesInfo
argument_list|(
operator|&
name|info
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
name|HandleKeyTypesFile
argument_list|(
operator|&
name|info
argument_list|,
name|file
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|errorCount
operator|!=
literal|0
condition|)
goto|goto
name|err_info
goto|;
if|if
condition|(
operator|!
name|CopyKeyTypesToKeymap
argument_list|(
name|keymap
argument_list|,
operator|&
name|info
argument_list|)
condition|)
goto|goto
name|err_info
goto|;
name|ClearKeyTypesInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|err_info
label|:
name|ClearKeyTypesInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
end_unit
