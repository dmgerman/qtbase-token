begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<fcntl.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"rules.h"
end_include
begin_include
include|#
directive|include
file|"include.h"
end_include
begin_comment
comment|/*  * The rules file  * ==============  * The purpose of this file is to map between configuration values that  * are easy for a user to specify and understand, and the configuration  * values xkbcomp uses and understands.  * xkbcomp uses the xkb_component_names struct, which maps directly to  * include statements of the appropriate sections, called for short  * KcCGST (see keycodes.c, types.c, compat.c, symbols.c; geometry.c was  * removed). These are not really intuitive or straight-forward for  * the uninitiated.  * Instead, the user passes in a xkb_rule_names struct, which consists  * of the name of a rules file (in Linux this is usually "evdev"), a  * keyboard model (e.g. "pc105"), a set of layouts (which will end up  * in different groups, e.g. "us,fr"), variants (used to alter/augment  * the respective layout, e.g. "intl,dvorak"), and a set of options  * (used to tweak some general behavior of the keyboard, e.g.  * "ctrl:nocaps,compose:menu" to make the Caps Lock key act like Ctrl  * and the Menu key like Compose). We call these RMLVO.  *  * Format of the file  * ------------------  * The file consists of rule sets, each consisting of rules (one per  * line), which match the MLVO values on the left hand side, and, if  * the values match to the values the user passed in, results in the  * values on the right hand side being added to the resulting KcCGST.  * Since some values are related and repeated often, it is possible  * to group them together and refer to them by a group name in the  * rules.  * Along with matching values by simple string equality, and for  * membership in a group defined previously, rules may also contain  * "wildcard" values - "*" - which always match. These usually appear  * near the end.  *  * Grammer  * -------  * (It might be helpful to look at a file like rules/evdev along with  * this grammer. Comments, whitespace, etc. are not shown.)  *  * File         ::= { "!" (Group | RuleSet) }  *  * Group        ::= GroupName "=" { GroupElement } "\n"  * GroupName    ::= "$"<ident>  * GroupElement ::=<ident>  *  * RuleSet      ::= Mapping { Rule }  *  * Mapping      ::= { Mlvo } "=" { Kccgst } "\n"  * Mlvo         ::= "model" | "option" | ("layout" | "variant") [ Index ]  * Index        ::= "[" 1..XKB_NUM_GROUPS "]"  * Kccgst       ::= "keycodes" | "symbols" | "types" | "compat" | "geometry"  *  * Rule         ::= { MlvoValue } "=" { KccgstValue } "\n"  * MlvoValue    ::= "*" | GroupName |<ident>  * KccgstValue  ::=<ident>  *  * Notes:  * - The order of values in a Rule must be the same as the Mapping it  *   follows. The mapping line determines the meaning of the values in  *   the rules which follow in the RuleSet.  * - If a Rule is matched, %-expansion is performed on the KccgstValue,  *   as follows:  *   %m, %l, %v:  *      The model, layout or variant, if only one was given (e.g.  *      %l for "us,il" is invalid).  *   %l[1], %v[1]:  *      Layout or variant for the specified group Index, if more than  *      one was given (e.g. %l[1] for "us" is invalid).  *   %+m, %+l, %+v, %+l[1], %+v[1]  *      As above, but prefixed with '+'. Similarly, '|', '-', '_' may be  *      used instead of '+'.  *   %(m), %(l), %(l[1]), %(v), %(v[1]):  *      As above, but prefixed by '(' and suffixed by ')'.  *   In case the expansion is invalid, as described above, it is  *   skipped (the rest of the string is still processed); this includes  *   the prefix and suffix (that's why you shouldn't use e.g. "(%v[1])").  */
end_comment
begin_comment
comment|/* Scanner / Lexer */
end_comment
begin_comment
comment|/* Point to some substring in the file; used to avoid copying. */
end_comment
begin_struct
DECL|struct|sval
struct|struct
name|sval
block|{
DECL|member|start
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
DECL|member|len
name|unsigned
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|darray_sval
typedef|typedef
name|darray
argument_list|(
argument|struct sval
argument_list|)
name|darray_sval
expr_stmt|;
end_typedef
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|svaleq
name|svaleq
parameter_list|(
name|struct
name|sval
name|s1
parameter_list|,
name|struct
name|sval
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|len
operator|==
name|s2
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|s1
operator|.
name|start
argument_list|,
name|s2
operator|.
name|start
argument_list|,
name|s1
operator|.
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|svaleq_prefix
name|svaleq_prefix
parameter_list|(
name|struct
name|sval
name|s1
parameter_list|,
name|struct
name|sval
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|len
operator|<=
name|s2
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|s1
operator|.
name|start
argument_list|,
name|s2
operator|.
name|start
argument_list|,
name|s1
operator|.
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Values returned with some tokens, like yylval. */
end_comment
begin_union
DECL|union|lvalue
union|union
name|lvalue
block|{
DECL|member|string
name|struct
name|sval
name|string
decl_stmt|;
block|}
union|;
end_union
begin_comment
comment|/*  * Holds the location in the file of the last processed token,  * like yylloc.  */
end_comment
begin_struct
DECL|struct|location
struct|struct
name|location
block|{
DECL|member|line
DECL|member|column
name|int
name|line
decl_stmt|,
name|column
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|scanner
struct|struct
name|scanner
block|{
DECL|member|s
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
DECL|member|pos
name|size_t
name|pos
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
DECL|member|line
DECL|member|column
name|int
name|line
decl_stmt|,
name|column
decl_stmt|;
DECL|member|file_name
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
DECL|member|ctx
name|struct
name|xkb_context
modifier|*
name|ctx
decl_stmt|;
block|}
struct|;
end_struct
begin_enum
DECL|enum|rules_token
enum|enum
name|rules_token
block|{
DECL|enumerator|TOK_END_OF_FILE
name|TOK_END_OF_FILE
init|=
literal|0
block|,
DECL|enumerator|TOK_END_OF_LINE
name|TOK_END_OF_LINE
block|,
DECL|enumerator|TOK_IDENTIFIER
name|TOK_IDENTIFIER
block|,
DECL|enumerator|TOK_GROUP_NAME
name|TOK_GROUP_NAME
block|,
DECL|enumerator|TOK_BANG
name|TOK_BANG
block|,
DECL|enumerator|TOK_EQUALS
name|TOK_EQUALS
block|,
DECL|enumerator|TOK_STAR
name|TOK_STAR
block|,
DECL|enumerator|TOK_ERROR
name|TOK_ERROR
block|}
enum|;
end_enum
begin_function
specifier|static
name|void
DECL|function|scanner_init
name|scanner_init
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|s
operator|->
name|s
operator|=
name|string
expr_stmt|;
name|s
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|s
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|line
operator|=
name|s
operator|->
name|column
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|file_name
operator|=
name|file_name
expr_stmt|;
name|s
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function
begin_comment
comment|/* C99 is stupid. Just use the 1 variant when there are no args. */
end_comment
begin_define
DECL|macro|scanner_error1
define|#
directive|define
name|scanner_error1
parameter_list|(
name|scanner
parameter_list|,
name|loc
parameter_list|,
name|msg
parameter_list|)
define|\
value|log_warn(scanner->ctx, "rules/%s:%d:%d: " msg "\n", \              scanner->file_name, loc->line, loc->column)
end_define
begin_define
DECL|macro|scanner_error
define|#
directive|define
name|scanner_error
parameter_list|(
name|scanner
parameter_list|,
name|loc
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|log_warn(scanner->ctx, "rules/%s:%d:%d: " fmt "\n", \              scanner->file_name, loc->line, loc->column, __VA_ARGS__)
end_define
begin_function
specifier|static
name|char
DECL|function|peek
name|peek
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
operator|->
name|pos
operator|<
name|s
operator|->
name|len
condition|?
name|s
operator|->
name|s
index|[
name|s
operator|->
name|pos
index|]
else|:
literal|'\0'
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|eof
name|eof
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
return|return
name|peek
argument_list|(
name|s
argument_list|)
operator|==
literal|'\0'
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|eol
name|eol
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
return|return
name|peek
argument_list|(
name|s
argument_list|)
operator|==
literal|'\n'
return|;
block|}
end_function
begin_function
specifier|static
name|char
DECL|function|next
name|next
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|eof
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|'\0'
return|;
if|if
condition|(
name|eol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|s
operator|->
name|line
operator|++
expr_stmt|;
name|s
operator|->
name|column
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|column
operator|++
expr_stmt|;
block|}
return|return
name|s
operator|->
name|s
index|[
name|s
operator|->
name|pos
operator|++
index|]
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|chr
name|chr
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|peek
argument_list|(
name|s
argument_list|)
operator|!=
name|ch
condition|)
return|return
name|false
return|;
name|s
operator|->
name|pos
operator|++
expr_stmt|;
name|s
operator|->
name|column
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|str
name|str
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|len
operator|-
name|s
operator|->
name|pos
operator|<
name|len
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
operator|->
name|s
operator|+
name|s
operator|->
name|pos
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|s
operator|->
name|pos
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|column
operator|+=
name|len
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_define
DECL|macro|lit
define|#
directive|define
name|lit
parameter_list|(
name|s
parameter_list|,
name|literal
parameter_list|)
value|str(s, literal, sizeof(literal) - 1)
end_define
begin_function
specifier|static
name|enum
name|rules_token
DECL|function|lex
name|lex
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|union
name|lvalue
modifier|*
name|val
parameter_list|,
name|struct
name|location
modifier|*
name|loc
parameter_list|)
block|{
name|skip_more_whitespace_and_comments
label|:
comment|/* Skip spaces. */
while|while
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|' '
argument_list|)
operator|||
name|chr
argument_list|(
name|s
argument_list|,
literal|'\t'
argument_list|)
condition|)
empty_stmt|;
comment|/* Skip comments. */
if|if
condition|(
name|lit
argument_list|(
name|s
argument_list|,
literal|"//"
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|eof
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|eol
argument_list|(
name|s
argument_list|)
condition|)
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* New line. */
if|if
condition|(
name|eol
argument_list|(
name|s
argument_list|)
condition|)
block|{
while|while
condition|(
name|eol
argument_list|(
name|s
argument_list|)
condition|)
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|TOK_END_OF_LINE
return|;
block|}
comment|/* Escaped line continuation. */
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'\\'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|eol
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|scanner_error1
argument_list|(
name|s
argument_list|,
name|loc
argument_list|,
literal|"illegal new line escape; must appear at end of line"
argument_list|)
expr_stmt|;
return|return
name|TOK_ERROR
return|;
block|}
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|skip_more_whitespace_and_comments
goto|;
block|}
comment|/* See if we're done. */
if|if
condition|(
name|eof
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|TOK_END_OF_FILE
return|;
comment|/* New token. */
name|loc
operator|->
name|line
operator|=
name|s
operator|->
name|line
expr_stmt|;
name|loc
operator|->
name|column
operator|=
name|s
operator|->
name|column
expr_stmt|;
comment|/* Operators and punctuation. */
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'!'
argument_list|)
condition|)
return|return
name|TOK_BANG
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'='
argument_list|)
condition|)
return|return
name|TOK_EQUALS
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'*'
argument_list|)
condition|)
return|return
name|TOK_STAR
return|;
comment|/* Group name. */
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
name|val
operator|->
name|string
operator|.
name|start
operator|=
name|s
operator|->
name|s
operator|+
name|s
operator|->
name|pos
expr_stmt|;
name|val
operator|->
name|string
operator|.
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isgraph
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|val
operator|->
name|string
operator|.
name|len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|->
name|string
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|scanner_error1
argument_list|(
name|s
argument_list|,
name|loc
argument_list|,
literal|"unexpected character after \'$\'; expected name"
argument_list|)
expr_stmt|;
return|return
name|TOK_ERROR
return|;
block|}
return|return
name|TOK_GROUP_NAME
return|;
block|}
comment|/* Identifier. */
if|if
condition|(
name|isgraph
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|val
operator|->
name|string
operator|.
name|start
operator|=
name|s
operator|->
name|s
operator|+
name|s
operator|->
name|pos
expr_stmt|;
name|val
operator|->
name|string
operator|.
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isgraph
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|val
operator|->
name|string
operator|.
name|len
operator|++
expr_stmt|;
block|}
return|return
name|TOK_IDENTIFIER
return|;
block|}
name|scanner_error1
argument_list|(
name|s
argument_list|,
name|loc
argument_list|,
literal|"unrecognized token"
argument_list|)
expr_stmt|;
return|return
name|TOK_ERROR
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_enum
DECL|enum|rules_mlvo
enum|enum
name|rules_mlvo
block|{
DECL|enumerator|MLVO_MODEL
name|MLVO_MODEL
block|,
DECL|enumerator|MLVO_LAYOUT
name|MLVO_LAYOUT
block|,
DECL|enumerator|MLVO_VARIANT
name|MLVO_VARIANT
block|,
DECL|enumerator|MLVO_OPTION
name|MLVO_OPTION
block|,
DECL|enumerator|_MLVO_NUM_ENTRIES
name|_MLVO_NUM_ENTRIES
block|}
enum|;
end_enum
begin_define
DECL|macro|SVAL_LIT
define|#
directive|define
name|SVAL_LIT
parameter_list|(
name|literal
parameter_list|)
value|{ literal, sizeof(literal) - 1 }
end_define
begin_decl_stmt
DECL|variable|rules_mlvo_svals
specifier|static
specifier|const
name|struct
name|sval
name|rules_mlvo_svals
index|[
name|_MLVO_NUM_ENTRIES
index|]
init|=
block|{
index|[
name|MLVO_MODEL
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"model"
argument_list|)
block|,
index|[
name|MLVO_LAYOUT
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"layout"
argument_list|)
block|,
index|[
name|MLVO_VARIANT
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"variant"
argument_list|)
block|,
index|[
name|MLVO_OPTION
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"option"
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|rules_kccgst
enum|enum
name|rules_kccgst
block|{
DECL|enumerator|KCCGST_KEYCODES
name|KCCGST_KEYCODES
block|,
DECL|enumerator|KCCGST_TYPES
name|KCCGST_TYPES
block|,
DECL|enumerator|KCCGST_COMPAT
name|KCCGST_COMPAT
block|,
DECL|enumerator|KCCGST_SYMBOLS
name|KCCGST_SYMBOLS
block|,
DECL|enumerator|KCCGST_GEOMETRY
name|KCCGST_GEOMETRY
block|,
DECL|enumerator|_KCCGST_NUM_ENTRIES
name|_KCCGST_NUM_ENTRIES
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|rules_kccgst_svals
specifier|static
specifier|const
name|struct
name|sval
name|rules_kccgst_svals
index|[
name|_KCCGST_NUM_ENTRIES
index|]
init|=
block|{
index|[
name|KCCGST_KEYCODES
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"keycodes"
argument_list|)
block|,
index|[
name|KCCGST_TYPES
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"types"
argument_list|)
block|,
index|[
name|KCCGST_COMPAT
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"compat"
argument_list|)
block|,
index|[
name|KCCGST_SYMBOLS
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"symbols"
argument_list|)
block|,
index|[
name|KCCGST_GEOMETRY
index|]
operator|=
name|SVAL_LIT
argument_list|(
literal|"geometry"
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * A broken-down version of xkb_rule_names (without the rules,  * obviously).  */
end_comment
begin_struct
DECL|struct|rule_names
struct|struct
name|rule_names
block|{
DECL|member|model
name|struct
name|sval
name|model
decl_stmt|;
DECL|member|layouts
name|darray_sval
name|layouts
decl_stmt|;
DECL|member|variants
name|darray_sval
name|variants
decl_stmt|;
DECL|member|options
name|darray_sval
name|options
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|group
struct|struct
name|group
block|{
DECL|member|name
name|struct
name|sval
name|name
decl_stmt|;
DECL|member|elements
name|darray_sval
name|elements
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|mapping
struct|struct
name|mapping
block|{
DECL|member|mlvo_at_pos
name|int
name|mlvo_at_pos
index|[
name|_MLVO_NUM_ENTRIES
index|]
decl_stmt|;
DECL|member|num_mlvo
name|unsigned
name|int
name|num_mlvo
decl_stmt|;
DECL|member|defined_mlvo_mask
name|unsigned
name|int
name|defined_mlvo_mask
decl_stmt|;
DECL|member|layout_idx
DECL|member|variant_idx
name|xkb_layout_index_t
name|layout_idx
decl_stmt|,
name|variant_idx
decl_stmt|;
DECL|member|kccgst_at_pos
name|int
name|kccgst_at_pos
index|[
name|_KCCGST_NUM_ENTRIES
index|]
decl_stmt|;
DECL|member|num_kccgst
name|unsigned
name|int
name|num_kccgst
decl_stmt|;
DECL|member|defined_kccgst_mask
name|unsigned
name|int
name|defined_kccgst_mask
decl_stmt|;
DECL|member|skip
name|bool
name|skip
decl_stmt|;
block|}
struct|;
end_struct
begin_enum
DECL|enum|mlvo_match_type
enum|enum
name|mlvo_match_type
block|{
DECL|enumerator|MLVO_MATCH_NORMAL
name|MLVO_MATCH_NORMAL
init|=
literal|0
block|,
DECL|enumerator|MLVO_MATCH_WILDCARD
name|MLVO_MATCH_WILDCARD
block|,
DECL|enumerator|MLVO_MATCH_GROUP
name|MLVO_MATCH_GROUP
block|, }
enum|;
end_enum
begin_struct
DECL|struct|rule
struct|struct
name|rule
block|{
DECL|member|mlvo_value_at_pos
name|struct
name|sval
name|mlvo_value_at_pos
index|[
name|_MLVO_NUM_ENTRIES
index|]
decl_stmt|;
DECL|member|match_type_at_pos
name|enum
name|mlvo_match_type
name|match_type_at_pos
index|[
name|_MLVO_NUM_ENTRIES
index|]
decl_stmt|;
DECL|member|num_mlvo_values
name|unsigned
name|int
name|num_mlvo_values
decl_stmt|;
DECL|member|kccgst_value_at_pos
name|struct
name|sval
name|kccgst_value_at_pos
index|[
name|_KCCGST_NUM_ENTRIES
index|]
decl_stmt|;
DECL|member|num_kccgst_values
name|unsigned
name|int
name|num_kccgst_values
decl_stmt|;
DECL|member|skip
name|bool
name|skip
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * This is the main object used to match a given RMLVO against a rules  * file and aggragate the results in a KcCGST. It goes through a simple  * matching state machine, with tokens as transitions (see  * matcher_match()).  */
end_comment
begin_struct
DECL|struct|matcher
struct|struct
name|matcher
block|{
DECL|member|ctx
name|struct
name|xkb_context
modifier|*
name|ctx
decl_stmt|;
comment|/* Input.*/
DECL|member|rmlvo
name|struct
name|rule_names
name|rmlvo
decl_stmt|;
DECL|member|loc
name|struct
name|location
name|loc
decl_stmt|;
DECL|member|val
name|union
name|lvalue
name|val
decl_stmt|;
DECL|member|scanner
name|struct
name|scanner
name|scanner
decl_stmt|;
DECL|member|groups
name|darray
argument_list|(
argument|struct group
argument_list|)
name|groups
expr_stmt|;
comment|/* Current mapping. */
DECL|member|mapping
name|struct
name|mapping
name|mapping
decl_stmt|;
comment|/* Current rule. */
DECL|member|rule
name|struct
name|rule
name|rule
decl_stmt|;
comment|/* Output. */
DECL|member|kccgst
name|darray_char
name|kccgst
index|[
name|_KCCGST_NUM_ENTRIES
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_function
specifier|static
name|struct
name|sval
DECL|function|strip_spaces
name|strip_spaces
parameter_list|(
name|struct
name|sval
name|v
parameter_list|)
block|{
while|while
condition|(
name|v
operator|.
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|v
operator|.
name|start
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|v
operator|.
name|len
operator|--
expr_stmt|;
name|v
operator|.
name|start
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|v
operator|.
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|v
operator|.
name|start
index|[
name|v
operator|.
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|v
operator|.
name|len
operator|--
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_function
specifier|static
name|darray_sval
DECL|function|split_comma_separated_string
name|split_comma_separated_string
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|darray_sval
name|arr
init|=
name|darray_new
argument_list|()
decl_stmt|;
name|struct
name|sval
name|val
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
comment|/*      * Make sure the array returned by this function always includes at      * least one value, e.g. "" -> { "" } and "," -> { "", "" }.      */
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|darray_append
argument_list|(
name|arr
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|arr
return|;
block|}
while|while
condition|(
name|true
condition|)
block|{
name|val
operator|.
name|start
operator|=
name|s
expr_stmt|;
name|val
operator|.
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|','
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|val
operator|.
name|len
operator|++
expr_stmt|;
block|}
name|darray_append
argument_list|(
name|arr
argument_list|,
name|strip_spaces
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
block|}
return|return
name|arr
return|;
block|}
end_function
begin_function
specifier|static
name|struct
name|matcher
modifier|*
DECL|function|matcher_new
name|matcher_new
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|struct
name|xkb_rule_names
modifier|*
name|rmlvo
parameter_list|)
block|{
name|struct
name|matcher
modifier|*
name|m
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|m
operator|->
name|rmlvo
operator|.
name|model
operator|.
name|start
operator|=
name|rmlvo
operator|->
name|model
expr_stmt|;
name|m
operator|->
name|rmlvo
operator|.
name|model
operator|.
name|len
operator|=
name|rmlvo
operator|->
name|model
condition|?
name|strlen
argument_list|(
name|rmlvo
operator|->
name|model
argument_list|)
else|:
literal|0
expr_stmt|;
name|m
operator|->
name|rmlvo
operator|.
name|layouts
operator|=
name|split_comma_separated_string
argument_list|(
name|rmlvo
operator|->
name|layout
argument_list|)
expr_stmt|;
name|m
operator|->
name|rmlvo
operator|.
name|variants
operator|=
name|split_comma_separated_string
argument_list|(
name|rmlvo
operator|->
name|variant
argument_list|)
expr_stmt|;
name|m
operator|->
name|rmlvo
operator|.
name|options
operator|=
name|split_comma_separated_string
argument_list|(
name|rmlvo
operator|->
name|options
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_free
name|matcher_free
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|group
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
name|darray_free
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|options
argument_list|)
expr_stmt|;
name|darray_foreach
argument_list|(
argument|group
argument_list|,
argument|m->groups
argument_list|)
name|darray_free
argument_list|(
name|group
operator|->
name|elements
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|m
operator|->
name|groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* C99 is stupid. Just use the 1 variant when there are no args. */
end_comment
begin_define
DECL|macro|matcher_error1
define|#
directive|define
name|matcher_error1
parameter_list|(
name|matcher
parameter_list|,
name|msg
parameter_list|)
define|\
value|log_warn(matcher->ctx, "rules/%s:%d:%d: " msg "\n", \              matcher->scanner.file_name, matcher->loc.line, \              matcher->loc.column)
end_define
begin_define
DECL|macro|matcher_error
define|#
directive|define
name|matcher_error
parameter_list|(
name|matcher
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|log_warn(matcher->ctx, "rules/%s:%d:%d: " fmt "\n", \              matcher->scanner.file_name, matcher->loc.line, \              matcher->loc.column, __VA_ARGS__)
end_define
begin_function
specifier|static
name|void
DECL|function|matcher_group_start_new
name|matcher_group_start_new
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|name
parameter_list|)
block|{
name|struct
name|group
name|group
init|=
block|{
operator|.
name|name
operator|=
name|name
block|,
operator|.
name|elements
operator|=
name|darray_new
argument_list|()
block|}
decl_stmt|;
name|darray_append
argument_list|(
name|m
operator|->
name|groups
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_group_add_element
name|matcher_group_add_element
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|element
parameter_list|)
block|{
name|darray_append
argument_list|(
name|darray_item
argument_list|(
name|m
operator|->
name|groups
argument_list|,
name|darray_size
argument_list|(
name|m
operator|->
name|groups
argument_list|)
operator|-
literal|1
argument_list|)
operator|.
name|elements
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_mapping_start_new
name|matcher_mapping_start_new
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_MLVO_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
name|m
operator|->
name|mapping
operator|.
name|mlvo_at_pos
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_KCCGST_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
name|m
operator|->
name|mapping
operator|.
name|kccgst_at_pos
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|layout_idx
operator|=
name|m
operator|->
name|mapping
operator|.
name|variant_idx
operator|=
name|XKB_LAYOUT_INVALID
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|num_mlvo
operator|=
name|m
operator|->
name|mapping
operator|.
name|num_kccgst
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|defined_mlvo_mask
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|defined_kccgst_mask
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|false
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|extract_layout_index
name|extract_layout_index
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|max_len
parameter_list|,
name|xkb_layout_index_t
modifier|*
name|out
parameter_list|)
block|{
comment|/* This function is pretty stupid, but works for now. */
operator|*
name|out
operator|=
name|XKB_LAYOUT_INVALID
expr_stmt|;
if|if
condition|(
name|max_len
operator|<
literal|3
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'['
operator|||
operator|!
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|||
name|s
index|[
literal|2
index|]
operator|!=
literal|']'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
operator|<
literal|1
operator|||
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
operator|>
name|XKB_MAX_GROUPS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* To zero-based index. */
operator|*
name|out
operator|=
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
operator|-
literal|1
expr_stmt|;
return|return
literal|3
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_mapping_set_mlvo
name|matcher_mapping_set_mlvo
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|ident
parameter_list|)
block|{
name|enum
name|rules_mlvo
name|mlvo
decl_stmt|;
name|struct
name|sval
name|mlvo_sval
decl_stmt|;
name|xkb_layout_index_t
name|idx
decl_stmt|;
name|int
name|consumed
decl_stmt|;
for|for
control|(
name|mlvo
operator|=
literal|0
init|;
name|mlvo
operator|<
name|_MLVO_NUM_ENTRIES
condition|;
name|mlvo
operator|++
control|)
block|{
name|mlvo_sval
operator|=
name|rules_mlvo_svals
index|[
name|mlvo
index|]
expr_stmt|;
if|if
condition|(
name|svaleq_prefix
argument_list|(
name|mlvo_sval
argument_list|,
name|ident
argument_list|)
condition|)
break|break;
block|}
comment|/* Not found. */
if|if
condition|(
name|mlvo
operator|>=
name|_MLVO_NUM_ENTRIES
condition|)
block|{
name|matcher_error
argument_list|(
name|m
argument_list|,
literal|"invalid mapping: %.*s is not a valid value here; "
literal|"ignoring rule set"
argument_list|,
name|ident
operator|.
name|len
argument_list|,
name|ident
operator|.
name|start
argument_list|)
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|defined_mlvo_mask
operator|&
operator|(
literal|1
operator|<<
name|mlvo
operator|)
condition|)
block|{
name|matcher_error
argument_list|(
name|m
argument_list|,
literal|"invalid mapping: %.*s appears twice on the same line; "
literal|"ignoring rule set"
argument_list|,
name|mlvo_sval
operator|.
name|len
argument_list|,
name|mlvo_sval
operator|.
name|start
argument_list|)
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
comment|/* If there are leftovers still, it must be an index. */
if|if
condition|(
name|mlvo_sval
operator|.
name|len
operator|<
name|ident
operator|.
name|len
condition|)
block|{
name|consumed
operator|=
name|extract_layout_index
argument_list|(
name|ident
operator|.
name|start
operator|+
name|mlvo_sval
operator|.
name|len
argument_list|,
name|ident
operator|.
name|len
operator|-
name|mlvo_sval
operator|.
name|len
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|ident
operator|.
name|len
operator|-
name|mlvo_sval
operator|.
name|len
argument_list|)
operator|!=
name|consumed
condition|)
block|{
name|matcher_error
argument_list|(
name|m
argument_list|,
literal|"invalid mapping:\" %.*s\" may only be followed by a valid group index; "
literal|"ignoring rule set"
argument_list|,
name|mlvo_sval
operator|.
name|len
argument_list|,
name|mlvo_sval
operator|.
name|start
argument_list|)
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mlvo
operator|==
name|MLVO_LAYOUT
condition|)
block|{
name|m
operator|->
name|mapping
operator|.
name|layout_idx
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mlvo
operator|==
name|MLVO_VARIANT
condition|)
block|{
name|m
operator|->
name|mapping
operator|.
name|variant_idx
operator|=
name|idx
expr_stmt|;
block|}
else|else
block|{
name|matcher_error
argument_list|(
name|m
argument_list|,
literal|"invalid mapping: \"%.*s\" cannot be followed by a group index; "
literal|"ignoring rule set"
argument_list|,
name|mlvo_sval
operator|.
name|len
argument_list|,
name|mlvo_sval
operator|.
name|start
argument_list|)
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
block|}
name|m
operator|->
name|mapping
operator|.
name|mlvo_at_pos
index|[
name|m
operator|->
name|mapping
operator|.
name|num_mlvo
index|]
operator|=
name|mlvo
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|defined_mlvo_mask
operator||=
literal|1
operator|<<
name|mlvo
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|num_mlvo
operator|++
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_mapping_set_kccgst
name|matcher_mapping_set_kccgst
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|ident
parameter_list|)
block|{
name|enum
name|rules_kccgst
name|kccgst
decl_stmt|;
name|struct
name|sval
name|kccgst_sval
decl_stmt|;
for|for
control|(
name|kccgst
operator|=
literal|0
init|;
name|kccgst
operator|<
name|_KCCGST_NUM_ENTRIES
condition|;
name|kccgst
operator|++
control|)
block|{
name|kccgst_sval
operator|=
name|rules_kccgst_svals
index|[
name|kccgst
index|]
expr_stmt|;
if|if
condition|(
name|svaleq
argument_list|(
name|rules_kccgst_svals
index|[
name|kccgst
index|]
argument_list|,
name|ident
argument_list|)
condition|)
break|break;
block|}
comment|/* Not found. */
if|if
condition|(
name|kccgst
operator|>=
name|_KCCGST_NUM_ENTRIES
condition|)
block|{
name|matcher_error
argument_list|(
name|m
argument_list|,
literal|"invalid mapping: %.*s is not a valid value here; "
literal|"ignoring rule set"
argument_list|,
name|ident
operator|.
name|len
argument_list|,
name|ident
operator|.
name|start
argument_list|)
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|defined_kccgst_mask
operator|&
operator|(
literal|1
operator|<<
name|kccgst
operator|)
condition|)
block|{
name|matcher_error
argument_list|(
name|m
argument_list|,
literal|"invalid mapping: %.*s appears twice on the same line; "
literal|"ignoring rule set"
argument_list|,
name|kccgst_sval
operator|.
name|len
argument_list|,
name|kccgst_sval
operator|.
name|start
argument_list|)
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|mapping
operator|.
name|kccgst_at_pos
index|[
name|m
operator|->
name|mapping
operator|.
name|num_kccgst
index|]
operator|=
name|kccgst
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|defined_kccgst_mask
operator||=
literal|1
operator|<<
name|kccgst
expr_stmt|;
name|m
operator|->
name|mapping
operator|.
name|num_kccgst
operator|++
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_mapping_verify
name|matcher_mapping_verify
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|num_mlvo
operator|==
literal|0
condition|)
block|{
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"invalid mapping: must have at least one value on the left hand side; "
literal|"ignoring rule set"
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|num_kccgst
operator|==
literal|0
condition|)
block|{
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"invalid mapping: must have at least one value on the right hand side; "
literal|"ignoring rule set"
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
comment|/*      * This following is very stupid, but this is how it works.      * See the "Notes" section in the overview above.      */
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|defined_mlvo_mask
operator|&
operator|(
literal|1
operator|<<
name|MLVO_LAYOUT
operator|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|layout_idx
operator|==
name|XKB_LAYOUT_INVALID
condition|)
block|{
if|if
condition|(
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|)
operator|>
literal|1
condition|)
goto|goto
name|skip
goto|;
block|}
else|else
block|{
if|if
condition|(
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|)
operator|==
literal|1
operator|||
name|m
operator|->
name|mapping
operator|.
name|layout_idx
operator|>=
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|)
condition|)
goto|goto
name|skip
goto|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|defined_mlvo_mask
operator|&
operator|(
literal|1
operator|<<
name|MLVO_VARIANT
operator|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|mapping
operator|.
name|variant_idx
operator|==
name|XKB_LAYOUT_INVALID
condition|)
block|{
if|if
condition|(
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|)
operator|>
literal|1
condition|)
goto|goto
name|skip
goto|;
block|}
else|else
block|{
if|if
condition|(
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|)
operator|==
literal|1
operator|||
name|m
operator|->
name|mapping
operator|.
name|variant_idx
operator|>=
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|)
condition|)
goto|goto
name|skip
goto|;
block|}
block|}
return|return;
name|skip
label|:
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_start_new
name|matcher_rule_start_new
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|m
operator|->
name|rule
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|rule
operator|.
name|skip
operator|=
name|m
operator|->
name|mapping
operator|.
name|skip
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_set_mlvo_common
name|matcher_rule_set_mlvo_common
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|ident
parameter_list|,
name|enum
name|mlvo_match_type
name|match_type
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|rule
operator|.
name|num_mlvo_values
operator|+
literal|1
operator|>
name|m
operator|->
name|mapping
operator|.
name|num_mlvo
condition|)
block|{
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"invalid rule: has more values than the mapping line; "
literal|"ignoring rule"
argument_list|)
expr_stmt|;
name|m
operator|->
name|rule
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|rule
operator|.
name|match_type_at_pos
index|[
name|m
operator|->
name|rule
operator|.
name|num_mlvo_values
index|]
operator|=
name|match_type
expr_stmt|;
name|m
operator|->
name|rule
operator|.
name|mlvo_value_at_pos
index|[
name|m
operator|->
name|rule
operator|.
name|num_mlvo_values
index|]
operator|=
name|ident
expr_stmt|;
name|m
operator|->
name|rule
operator|.
name|num_mlvo_values
operator|++
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_set_mlvo_wildcard
name|matcher_rule_set_mlvo_wildcard
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sval
name|dummy
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|matcher_rule_set_mlvo_common
argument_list|(
name|m
argument_list|,
name|dummy
argument_list|,
name|MLVO_MATCH_WILDCARD
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_set_mlvo_group
name|matcher_rule_set_mlvo_group
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|ident
parameter_list|)
block|{
name|matcher_rule_set_mlvo_common
argument_list|(
name|m
argument_list|,
name|ident
argument_list|,
name|MLVO_MATCH_GROUP
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_set_mlvo
name|matcher_rule_set_mlvo
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|ident
parameter_list|)
block|{
name|matcher_rule_set_mlvo_common
argument_list|(
name|m
argument_list|,
name|ident
argument_list|,
name|MLVO_MATCH_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_set_kccgst
name|matcher_rule_set_kccgst
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|ident
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|rule
operator|.
name|num_kccgst_values
operator|+
literal|1
operator|>
name|m
operator|->
name|mapping
operator|.
name|num_kccgst
condition|)
block|{
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"invalid rule: has more values than the mapping line; "
literal|"ignoring rule"
argument_list|)
expr_stmt|;
name|m
operator|->
name|rule
operator|.
name|skip
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|rule
operator|.
name|kccgst_value_at_pos
index|[
name|m
operator|->
name|rule
operator|.
name|num_kccgst_values
index|]
operator|=
name|ident
expr_stmt|;
name|m
operator|->
name|rule
operator|.
name|num_kccgst_values
operator|++
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|match_group
name|match_group
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|group_name
parameter_list|,
name|struct
name|sval
name|to
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|struct
name|sval
modifier|*
name|element
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|darray_foreach
argument_list|(
argument|group
argument_list|,
argument|m->groups
argument_list|)
block|{
if|if
condition|(
name|svaleq
argument_list|(
name|group
operator|->
name|name
argument_list|,
name|group_name
argument_list|)
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/*          * rules/evdev intentionally uses some undeclared group names          * in rules (e.g. commented group definitions which may be          * uncommented if needed). So we continue silently.          */
return|return
name|false
return|;
block|}
name|darray_foreach
argument_list|(
argument|element
argument_list|,
argument|group->elements
argument_list|)
if|if
condition|(
name|svaleq
argument_list|(
name|to
argument_list|,
operator|*
name|element
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|match_value
name|match_value
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|struct
name|sval
name|val
parameter_list|,
name|struct
name|sval
name|to
parameter_list|,
name|enum
name|mlvo_match_type
name|match_type
parameter_list|)
block|{
if|if
condition|(
name|match_type
operator|==
name|MLVO_MATCH_WILDCARD
condition|)
return|return
name|true
return|;
if|if
condition|(
name|match_type
operator|==
name|MLVO_MATCH_GROUP
condition|)
return|return
name|match_group
argument_list|(
name|m
argument_list|,
name|val
argument_list|,
name|to
argument_list|)
return|;
return|return
name|svaleq
argument_list|(
name|val
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * This function performs %-expansion on @value (see overview above),  * and appends the result to @to.  */
end_comment
begin_function
specifier|static
name|bool
DECL|function|append_expanded_kccgst_value
name|append_expanded_kccgst_value
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
name|darray_char
modifier|*
name|to
parameter_list|,
name|struct
name|sval
name|value
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|original_size
init|=
name|darray_size
argument_list|(
operator|*
name|to
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|value
operator|.
name|start
decl_stmt|;
name|xkb_layout_index_t
name|idx
decl_stmt|;
name|int
name|consumed
decl_stmt|;
name|enum
name|rules_mlvo
name|mlv
decl_stmt|;
name|struct
name|sval
name|expanded
decl_stmt|;
name|char
name|pfx
decl_stmt|,
name|sfx
decl_stmt|;
comment|/*      * Appending  bar to  foo ->  foo (not an error if this happens)      * Appending +bar to  foo ->  foo+bar      * Appending  bar to +foo ->  bar+foo      * Appending +bar to +foo -> +foo+bar      */
if|if
condition|(
operator|!
name|darray_empty
argument_list|(
operator|*
name|to
argument_list|)
operator|&&
name|s
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|&&
name|s
index|[
literal|0
index|]
operator|!=
literal|'|'
condition|)
block|{
if|if
condition|(
name|darray_item
argument_list|(
operator|*
name|to
argument_list|,
literal|0
argument_list|)
operator|==
literal|'+'
operator|||
name|darray_item
argument_list|(
operator|*
name|to
argument_list|,
literal|0
argument_list|)
operator|==
literal|'|'
condition|)
name|darray_prepend_items_nullterminate
argument_list|(
operator|*
name|to
argument_list|,
name|value
operator|.
name|start
argument_list|,
name|value
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/*      * Some ugly hand-lexing here, but going through the scanner is more      * trouble than it's worth, and the format is ugly on its own merit.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|len
condition|;
control|)
block|{
comment|/* Check if that's a start of an expansion. */
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
literal|'%'
condition|)
block|{
comment|/* Just a normal character. */
name|darray_append_items_nullterminate
argument_list|(
operator|*
name|to
argument_list|,
operator|&
name|s
index|[
name|i
operator|++
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|value
operator|.
name|len
condition|)
goto|goto
name|error
goto|;
name|pfx
operator|=
name|sfx
operator|=
literal|0
expr_stmt|;
comment|/* Check for prefix. */
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'('
operator|||
name|s
index|[
name|i
index|]
operator|==
literal|'+'
operator|||
name|s
index|[
name|i
index|]
operator|==
literal|'|'
operator|||
name|s
index|[
name|i
index|]
operator|==
literal|'_'
operator|||
name|s
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|pfx
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'('
condition|)
name|sfx
operator|=
literal|')'
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|value
operator|.
name|len
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Mandatory model/layout/variant specifier. */
switch|switch
condition|(
name|s
index|[
name|i
operator|++
index|]
condition|)
block|{
case|case
literal|'m'
case|:
name|mlv
operator|=
name|MLVO_MODEL
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|mlv
operator|=
name|MLVO_LAYOUT
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|mlv
operator|=
name|MLVO_VARIANT
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
comment|/* Check for index. */
name|idx
operator|=
name|XKB_LAYOUT_INVALID
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|value
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|mlv
operator|!=
name|MLVO_LAYOUT
operator|&&
name|mlv
operator|!=
name|MLVO_VARIANT
condition|)
block|{
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"invalid index in %%-expansion; "
literal|"may only index layout or variant"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|consumed
operator|=
name|extract_layout_index
argument_list|(
name|s
operator|+
name|i
argument_list|,
name|value
operator|.
name|len
operator|-
name|i
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumed
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|i
operator|+=
name|consumed
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|XKB_LAYOUT_INVALID
expr_stmt|;
block|}
block|}
comment|/* Check for suffix, if there supposed to be one. */
if|if
condition|(
name|sfx
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|value
operator|.
name|len
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|s
index|[
name|i
operator|++
index|]
operator|!=
name|sfx
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Get the expanded value. */
name|expanded
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mlv
operator|==
name|MLVO_LAYOUT
condition|)
block|{
if|if
condition|(
name|idx
operator|!=
name|XKB_LAYOUT_INVALID
operator|&&
name|idx
operator|<
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|)
operator|&&
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|)
operator|>
literal|1
condition|)
name|expanded
operator|=
name|darray_item
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|,
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|XKB_LAYOUT_INVALID
operator|&&
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|)
operator|==
literal|1
condition|)
name|expanded
operator|=
name|darray_item
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mlv
operator|==
name|MLVO_VARIANT
condition|)
block|{
if|if
condition|(
name|idx
operator|!=
name|XKB_LAYOUT_INVALID
operator|&&
name|idx
operator|<
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|)
operator|&&
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|)
operator|>
literal|1
condition|)
name|expanded
operator|=
name|darray_item
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|,
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|XKB_LAYOUT_INVALID
operator|&&
name|darray_size
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|)
operator|==
literal|1
condition|)
name|expanded
operator|=
name|darray_item
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mlv
operator|==
name|MLVO_MODEL
condition|)
block|{
name|expanded
operator|=
name|m
operator|->
name|rmlvo
operator|.
name|model
expr_stmt|;
block|}
comment|/* If we didn't get one, skip silently. */
if|if
condition|(
name|expanded
operator|.
name|len
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pfx
operator|!=
literal|0
condition|)
name|darray_append_items_nullterminate
argument_list|(
operator|*
name|to
argument_list|,
operator|&
name|pfx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|darray_append_items_nullterminate
argument_list|(
operator|*
name|to
argument_list|,
name|expanded
operator|.
name|start
argument_list|,
name|expanded
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfx
operator|!=
literal|0
condition|)
name|darray_append_items_nullterminate
argument_list|(
operator|*
name|to
argument_list|,
operator|&
name|sfx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|error
label|:
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"invalid %%-expansion in value; not used"
argument_list|)
expr_stmt|;
name|darray_resize
argument_list|(
operator|*
name|to
argument_list|,
name|original_size
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_verify
name|matcher_rule_verify
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|rule
operator|.
name|num_mlvo_values
operator|!=
name|m
operator|->
name|mapping
operator|.
name|num_mlvo
operator|||
name|m
operator|->
name|rule
operator|.
name|num_kccgst_values
operator|!=
name|m
operator|->
name|mapping
operator|.
name|num_kccgst
condition|)
block|{
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"invalid rule: must have same number of values as mapping line;"
literal|"ignoring rule"
argument_list|)
expr_stmt|;
name|m
operator|->
name|rule
operator|.
name|skip
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|matcher_rule_apply_if_matches
name|matcher_rule_apply_if_matches
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|enum
name|rules_mlvo
name|mlvo
decl_stmt|;
name|enum
name|rules_kccgst
name|kccgst
decl_stmt|;
name|struct
name|sval
name|value
decl_stmt|,
modifier|*
name|option
decl_stmt|;
name|enum
name|mlvo_match_type
name|match_type
decl_stmt|;
name|bool
name|matched
init|=
name|false
decl_stmt|;
name|xkb_layout_index_t
name|idx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|mapping
operator|.
name|num_mlvo
condition|;
name|i
operator|++
control|)
block|{
name|mlvo
operator|=
name|m
operator|->
name|mapping
operator|.
name|mlvo_at_pos
index|[
name|i
index|]
expr_stmt|;
name|value
operator|=
name|m
operator|->
name|rule
operator|.
name|mlvo_value_at_pos
index|[
name|i
index|]
expr_stmt|;
name|match_type
operator|=
name|m
operator|->
name|rule
operator|.
name|match_type_at_pos
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mlvo
operator|==
name|MLVO_MODEL
condition|)
block|{
name|matched
operator|=
name|match_value
argument_list|(
name|m
argument_list|,
name|value
argument_list|,
name|m
operator|->
name|rmlvo
operator|.
name|model
argument_list|,
name|match_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mlvo
operator|==
name|MLVO_LAYOUT
condition|)
block|{
name|idx
operator|=
name|m
operator|->
name|mapping
operator|.
name|layout_idx
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|==
name|XKB_LAYOUT_INVALID
condition|?
literal|0
else|:
name|idx
operator|)
expr_stmt|;
name|matched
operator|=
name|match_value
argument_list|(
name|m
argument_list|,
name|value
argument_list|,
name|darray_item
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|layouts
argument_list|,
name|idx
argument_list|)
argument_list|,
name|match_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mlvo
operator|==
name|MLVO_VARIANT
condition|)
block|{
name|idx
operator|=
name|m
operator|->
name|mapping
operator|.
name|layout_idx
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|==
name|XKB_LAYOUT_INVALID
condition|?
literal|0
else|:
name|idx
operator|)
expr_stmt|;
name|matched
operator|=
name|match_value
argument_list|(
name|m
argument_list|,
name|value
argument_list|,
name|darray_item
argument_list|(
name|m
operator|->
name|rmlvo
operator|.
name|variants
argument_list|,
name|idx
argument_list|)
argument_list|,
name|match_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mlvo
operator|==
name|MLVO_OPTION
condition|)
block|{
name|darray_foreach
argument_list|(
argument|option
argument_list|,
argument|m->rmlvo.options
argument_list|)
block|{
name|matched
operator|=
name|match_value
argument_list|(
name|m
argument_list|,
name|value
argument_list|,
operator|*
name|option
argument_list|,
name|match_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|mapping
operator|.
name|num_kccgst
condition|;
name|i
operator|++
control|)
block|{
name|kccgst
operator|=
name|m
operator|->
name|mapping
operator|.
name|kccgst_at_pos
index|[
name|i
index|]
expr_stmt|;
name|value
operator|=
name|m
operator|->
name|rule
operator|.
name|kccgst_value_at_pos
index|[
name|i
index|]
expr_stmt|;
name|append_expanded_kccgst_value
argument_list|(
name|m
argument_list|,
operator|&
name|m
operator|->
name|kccgst
index|[
name|kccgst
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/*      * If a rule matches in a rule set, the rest of the set should be      * skipped. However, rule sets matching against options may contain      * several legitimate rules, so they are processed entirely.      */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|mapping
operator|.
name|defined_mlvo_mask
operator|&
operator|(
literal|1
operator|<<
name|MLVO_OPTION
operator|)
operator|)
condition|)
name|m
operator|->
name|mapping
operator|.
name|skip
operator|=
name|true
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|enum
name|rules_token
DECL|function|gettok
name|gettok
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|)
block|{
return|return
name|lex
argument_list|(
operator|&
name|m
operator|->
name|scanner
argument_list|,
operator|&
name|m
operator|->
name|val
argument_list|,
operator|&
name|m
operator|->
name|loc
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|matcher_match
name|matcher_match
parameter_list|(
name|struct
name|matcher
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|struct
name|xkb_component_names
modifier|*
name|out
parameter_list|)
block|{
name|enum
name|rules_token
name|tok
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|false
return|;
name|scanner_init
argument_list|(
operator|&
name|m
operator|->
name|scanner
argument_list|,
name|m
operator|->
name|ctx
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|initial
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_BANG
case|:
goto|goto
name|bang
goto|;
case|case
name|TOK_END_OF_LINE
case|:
goto|goto
name|initial
goto|;
case|case
name|TOK_END_OF_FILE
case|:
goto|goto
name|finish
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|bang
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_GROUP_NAME
case|:
name|matcher_group_start_new
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|group_name
goto|;
case|case
name|TOK_IDENTIFIER
case|:
name|matcher_mapping_start_new
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|matcher_mapping_set_mlvo
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|mapping_mlvo
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|group_name
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_EQUALS
case|:
goto|goto
name|group_element
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|group_element
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_IDENTIFIER
case|:
name|matcher_group_add_element
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|group_element
goto|;
case|case
name|TOK_END_OF_LINE
case|:
goto|goto
name|initial
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|mapping_mlvo
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_IDENTIFIER
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|mapping
operator|.
name|skip
condition|)
name|matcher_mapping_set_mlvo
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|mapping_mlvo
goto|;
case|case
name|TOK_EQUALS
case|:
goto|goto
name|mapping_kccgst
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|mapping_kccgst
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_IDENTIFIER
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|mapping
operator|.
name|skip
condition|)
name|matcher_mapping_set_kccgst
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|mapping_kccgst
goto|;
case|case
name|TOK_END_OF_LINE
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|mapping
operator|.
name|skip
condition|)
name|matcher_mapping_verify
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rule_mlvo_first
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|rule_mlvo_first
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_BANG
case|:
goto|goto
name|bang
goto|;
case|case
name|TOK_END_OF_LINE
case|:
goto|goto
name|rule_mlvo_first
goto|;
case|case
name|TOK_END_OF_FILE
case|:
goto|goto
name|finish
goto|;
default|default:
name|matcher_rule_start_new
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rule_mlvo_no_tok
goto|;
block|}
name|rule_mlvo
label|:
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rule_mlvo_no_tok
label|:
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_IDENTIFIER
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|rule
operator|.
name|skip
condition|)
name|matcher_rule_set_mlvo
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|rule_mlvo
goto|;
case|case
name|TOK_STAR
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|rule
operator|.
name|skip
condition|)
name|matcher_rule_set_mlvo_wildcard
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rule_mlvo
goto|;
case|case
name|TOK_GROUP_NAME
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|rule
operator|.
name|skip
condition|)
name|matcher_rule_set_mlvo_group
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|rule_mlvo
goto|;
case|case
name|TOK_EQUALS
case|:
goto|goto
name|rule_kccgst
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|rule_kccgst
label|:
switch|switch
condition|(
name|tok
operator|=
name|gettok
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|TOK_IDENTIFIER
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|rule
operator|.
name|skip
condition|)
name|matcher_rule_set_kccgst
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|val
operator|.
name|string
argument_list|)
expr_stmt|;
goto|goto
name|rule_kccgst
goto|;
case|case
name|TOK_END_OF_LINE
case|:
if|if
condition|(
operator|!
name|m
operator|->
name|rule
operator|.
name|skip
condition|)
name|matcher_rule_verify
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|rule
operator|.
name|skip
condition|)
name|matcher_rule_apply_if_matches
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rule_mlvo_first
goto|;
default|default:
goto|goto
name|unexpected
goto|;
block|}
name|unexpected
label|:
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_ERROR
case|:
goto|goto
name|error
goto|;
default|default:
goto|goto
name|state_error
goto|;
block|}
name|finish
label|:
if|if
condition|(
name|darray_empty
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_KEYCODES
index|]
argument_list|)
operator|||
name|darray_empty
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_TYPES
index|]
argument_list|)
operator|||
name|darray_empty
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_COMPAT
index|]
argument_list|)
operator|||
comment|/* darray_empty(m->kccgst[KCCGST_GEOMETRY]) || */
name|darray_empty
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_SYMBOLS
index|]
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|out
operator|->
name|keycodes
operator|=
name|darray_mem
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_KEYCODES
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|->
name|types
operator|=
name|darray_mem
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_TYPES
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|->
name|compat
operator|=
name|darray_mem
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_COMPAT
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* out->geometry = darray_mem(m->kccgst[KCCGST_GEOMETRY], 0); */
name|darray_free
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_GEOMETRY
index|]
argument_list|)
expr_stmt|;
name|out
operator|->
name|symbols
operator|=
name|darray_mem
argument_list|(
name|m
operator|->
name|kccgst
index|[
name|KCCGST_SYMBOLS
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|state_error
label|:
name|matcher_error1
argument_list|(
name|m
argument_list|,
literal|"unexpected token"
argument_list|)
expr_stmt|;
name|error
label|:
return|return
name|false
return|;
block|}
end_function
begin_function
name|bool
DECL|function|xkb_components_from_rules
name|xkb_components_from_rules
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|struct
name|xkb_rule_names
modifier|*
name|rmlvo
parameter_list|,
name|struct
name|xkb_component_names
modifier|*
name|out
parameter_list|)
block|{
name|bool
name|ret
init|=
name|false
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|matcher
modifier|*
name|matcher
decl_stmt|;
name|file
operator|=
name|FindFileInXkbPath
argument_list|(
name|ctx
argument_list|,
name|rmlvo
operator|->
name|rules
argument_list|,
name|FILE_TYPE_RULES
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
goto|goto
name|err_out
goto|;
name|fd
operator|=
name|fileno
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Couldn't stat rules file\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_file
goto|;
block|}
name|string
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|stat_buf
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|MAP_FAILED
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Couldn't mmap rules file (%lld bytes)\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|stat_buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
goto|goto
name|err_file
goto|;
block|}
name|matcher
operator|=
name|matcher_new
argument_list|(
name|ctx
argument_list|,
name|rmlvo
argument_list|)
expr_stmt|;
name|ret
operator|=
name|matcher_match
argument_list|(
name|matcher
argument_list|,
name|string
argument_list|,
name|stat_buf
operator|.
name|st_size
argument_list|,
name|rmlvo
operator|->
name|rules
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"No components returned from XKB rules \"%s\"\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|matcher_free
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|string
argument_list|,
name|stat_buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|err_file
label|:
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|err_out
label|:
return|return
name|ret
return|;
block|}
end_function
end_unit
