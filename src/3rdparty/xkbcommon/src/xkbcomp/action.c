begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  *         Ran Benita<ran234@gmail.com>  */
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"expr.h"
end_include
begin_include
include|#
directive|include
file|"action.h"
end_include
begin_decl_stmt
DECL|variable|constTrue
specifier|static
specifier|const
name|ExprBoolean
name|constTrue
init|=
block|{
operator|.
name|expr
operator|=
block|{
operator|.
name|common
operator|=
block|{
operator|.
name|type
operator|=
name|STMT_EXPR
block|,
operator|.
name|next
operator|=
name|NULL
block|}
block|,
operator|.
name|op
operator|=
name|EXPR_VALUE
block|,
operator|.
name|value_type
operator|=
name|EXPR_TYPE_BOOLEAN
block|,     }
block|,
operator|.
name|set
operator|=
name|true
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|constFalse
specifier|static
specifier|const
name|ExprBoolean
name|constFalse
init|=
block|{
operator|.
name|expr
operator|=
block|{
operator|.
name|common
operator|=
block|{
operator|.
name|type
operator|=
name|STMT_EXPR
block|,
operator|.
name|next
operator|=
name|NULL
block|}
block|,
operator|.
name|op
operator|=
name|EXPR_VALUE
block|,
operator|.
name|value_type
operator|=
name|EXPR_TYPE_BOOLEAN
block|,     }
block|,
operator|.
name|set
operator|=
name|false
block|, }
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|action_field
enum|enum
name|action_field
block|{
DECL|enumerator|ACTION_FIELD_CLEAR_LOCKS
name|ACTION_FIELD_CLEAR_LOCKS
block|,
DECL|enumerator|ACTION_FIELD_LATCH_TO_LOCK
name|ACTION_FIELD_LATCH_TO_LOCK
block|,
DECL|enumerator|ACTION_FIELD_GEN_KEY_EVENT
name|ACTION_FIELD_GEN_KEY_EVENT
block|,
DECL|enumerator|ACTION_FIELD_REPORT
name|ACTION_FIELD_REPORT
block|,
DECL|enumerator|ACTION_FIELD_DEFAULT
name|ACTION_FIELD_DEFAULT
block|,
DECL|enumerator|ACTION_FIELD_AFFECT
name|ACTION_FIELD_AFFECT
block|,
DECL|enumerator|ACTION_FIELD_INCREMENT
name|ACTION_FIELD_INCREMENT
block|,
DECL|enumerator|ACTION_FIELD_MODIFIERS
name|ACTION_FIELD_MODIFIERS
block|,
DECL|enumerator|ACTION_FIELD_GROUP
name|ACTION_FIELD_GROUP
block|,
DECL|enumerator|ACTION_FIELD_X
name|ACTION_FIELD_X
block|,
DECL|enumerator|ACTION_FIELD_Y
name|ACTION_FIELD_Y
block|,
DECL|enumerator|ACTION_FIELD_ACCEL
name|ACTION_FIELD_ACCEL
block|,
DECL|enumerator|ACTION_FIELD_BUTTON
name|ACTION_FIELD_BUTTON
block|,
DECL|enumerator|ACTION_FIELD_VALUE
name|ACTION_FIELD_VALUE
block|,
DECL|enumerator|ACTION_FIELD_CONTROLS
name|ACTION_FIELD_CONTROLS
block|,
DECL|enumerator|ACTION_FIELD_TYPE
name|ACTION_FIELD_TYPE
block|,
DECL|enumerator|ACTION_FIELD_COUNT
name|ACTION_FIELD_COUNT
block|,
DECL|enumerator|ACTION_FIELD_SCREEN
name|ACTION_FIELD_SCREEN
block|,
DECL|enumerator|ACTION_FIELD_SAME
name|ACTION_FIELD_SAME
block|,
DECL|enumerator|ACTION_FIELD_DATA
name|ACTION_FIELD_DATA
block|,
DECL|enumerator|ACTION_FIELD_DEVICE
name|ACTION_FIELD_DEVICE
block|,
DECL|enumerator|ACTION_FIELD_KEYCODE
name|ACTION_FIELD_KEYCODE
block|,
DECL|enumerator|ACTION_FIELD_MODS_TO_CLEAR
name|ACTION_FIELD_MODS_TO_CLEAR
block|, }
enum|;
end_enum
begin_function
name|ActionsInfo
modifier|*
DECL|function|NewActionsInfo
name|NewActionsInfo
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|type
decl_stmt|;
name|ActionsInfo
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|_ACTION_TYPE_NUM_ENTRIES
condition|;
name|type
operator|++
control|)
name|info
operator|->
name|actions
index|[
name|type
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
comment|/* Apply some "factory defaults". */
comment|/* Increment default button. */
name|info
operator|->
name|actions
index|[
name|ACTION_TYPE_PTR_DEFAULT
index|]
operator|.
name|dflt
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|actions
index|[
name|ACTION_TYPE_PTR_DEFAULT
index|]
operator|.
name|dflt
operator|.
name|value
operator|=
literal|1
expr_stmt|;
return|return
name|info
return|;
block|}
end_function
begin_function
name|void
DECL|function|FreeActionsInfo
name|FreeActionsInfo
parameter_list|(
name|ActionsInfo
modifier|*
name|info
parameter_list|)
block|{
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|fieldStrings
specifier|static
specifier|const
name|LookupEntry
name|fieldStrings
index|[]
init|=
block|{
block|{
literal|"clearLocks"
block|,
name|ACTION_FIELD_CLEAR_LOCKS
block|}
block|,
block|{
literal|"latchToLock"
block|,
name|ACTION_FIELD_LATCH_TO_LOCK
block|}
block|,
block|{
literal|"genKeyEvent"
block|,
name|ACTION_FIELD_GEN_KEY_EVENT
block|}
block|,
block|{
literal|"generateKeyEvent"
block|,
name|ACTION_FIELD_GEN_KEY_EVENT
block|}
block|,
block|{
literal|"report"
block|,
name|ACTION_FIELD_REPORT
block|}
block|,
block|{
literal|"default"
block|,
name|ACTION_FIELD_DEFAULT
block|}
block|,
block|{
literal|"affect"
block|,
name|ACTION_FIELD_AFFECT
block|}
block|,
block|{
literal|"increment"
block|,
name|ACTION_FIELD_INCREMENT
block|}
block|,
block|{
literal|"modifiers"
block|,
name|ACTION_FIELD_MODIFIERS
block|}
block|,
block|{
literal|"mods"
block|,
name|ACTION_FIELD_MODIFIERS
block|}
block|,
block|{
literal|"group"
block|,
name|ACTION_FIELD_GROUP
block|}
block|,
block|{
literal|"x"
block|,
name|ACTION_FIELD_X
block|}
block|,
block|{
literal|"y"
block|,
name|ACTION_FIELD_Y
block|}
block|,
block|{
literal|"accel"
block|,
name|ACTION_FIELD_ACCEL
block|}
block|,
block|{
literal|"accelerate"
block|,
name|ACTION_FIELD_ACCEL
block|}
block|,
block|{
literal|"repeat"
block|,
name|ACTION_FIELD_ACCEL
block|}
block|,
block|{
literal|"button"
block|,
name|ACTION_FIELD_BUTTON
block|}
block|,
block|{
literal|"value"
block|,
name|ACTION_FIELD_VALUE
block|}
block|,
block|{
literal|"controls"
block|,
name|ACTION_FIELD_CONTROLS
block|}
block|,
block|{
literal|"ctrls"
block|,
name|ACTION_FIELD_CONTROLS
block|}
block|,
block|{
literal|"type"
block|,
name|ACTION_FIELD_TYPE
block|}
block|,
block|{
literal|"count"
block|,
name|ACTION_FIELD_COUNT
block|}
block|,
block|{
literal|"screen"
block|,
name|ACTION_FIELD_SCREEN
block|}
block|,
block|{
literal|"same"
block|,
name|ACTION_FIELD_SAME
block|}
block|,
block|{
literal|"sameServer"
block|,
name|ACTION_FIELD_SAME
block|}
block|,
block|{
literal|"data"
block|,
name|ACTION_FIELD_DATA
block|}
block|,
block|{
literal|"device"
block|,
name|ACTION_FIELD_DEVICE
block|}
block|,
block|{
literal|"dev"
block|,
name|ACTION_FIELD_DEVICE
block|}
block|,
block|{
literal|"key"
block|,
name|ACTION_FIELD_KEYCODE
block|}
block|,
block|{
literal|"keycode"
block|,
name|ACTION_FIELD_KEYCODE
block|}
block|,
block|{
literal|"kc"
block|,
name|ACTION_FIELD_KEYCODE
block|}
block|,
block|{
literal|"clearmods"
block|,
name|ACTION_FIELD_MODS_TO_CLEAR
block|}
block|,
block|{
literal|"clearmodifiers"
block|,
name|ACTION_FIELD_MODS_TO_CLEAR
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|bool
DECL|function|stringToAction
name|stringToAction
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
modifier|*
name|type_rtrn
parameter_list|)
block|{
return|return
name|LookupString
argument_list|(
name|actionTypeNames
argument_list|,
name|str
argument_list|,
name|type_rtrn
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|stringToField
name|stringToField
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|enum
name|action_field
modifier|*
name|field_rtrn
parameter_list|)
block|{
return|return
name|LookupString
argument_list|(
name|fieldStrings
argument_list|,
name|str
argument_list|,
name|field_rtrn
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|fieldText
name|fieldText
parameter_list|(
name|enum
name|action_field
name|field
parameter_list|)
block|{
return|return
name|LookupValue
argument_list|(
name|fieldStrings
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportMismatch
name|ReportMismatch
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|xkb_action_type
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Value of %s field must be of type %s; "
literal|"Action %s definition ignored\n"
argument_list|,
name|fieldText
argument_list|(
name|field
argument_list|)
argument_list|,
name|type
argument_list|,
name|ActionTypeText
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportIllegal
name|ReportIllegal
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|xkb_action_type
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Field %s is not defined for an action of type %s; "
literal|"Action definition ignored\n"
argument_list|,
name|fieldText
argument_list|(
name|field
argument_list|)
argument_list|,
name|ActionTypeText
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|bool
DECL|function|ReportActionNotArray
name|ReportActionNotArray
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|xkb_action_type
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The %s field in the %s action is not an array; "
literal|"Action definition ignored\n"
argument_list|,
name|fieldText
argument_list|(
name|field
argument_list|)
argument_list|,
name|ActionTypeText
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleNoAction
name|HandleNoAction
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|CheckLatchLockFlags
name|CheckLatchLockFlags
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|xkb_action_type
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|,
name|enum
name|xkb_action_flags
modifier|*
name|flags_inout
parameter_list|)
block|{
name|enum
name|xkb_action_flags
name|tmp
decl_stmt|;
name|bool
name|result
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_CLEAR_LOCKS
condition|)
name|tmp
operator|=
name|ACTION_LOCK_CLEAR
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_LATCH_TO_LOCK
condition|)
name|tmp
operator|=
name|ACTION_LATCH_TO_LOCK
expr_stmt|;
else|else
return|return
name|false
return|;
comment|/* WSGO! */
if|if
condition|(
operator|!
name|ExprResolveBoolean
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|result
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
argument_list|,
name|field
argument_list|,
literal|"boolean"
argument_list|)
return|;
if|if
condition|(
name|result
condition|)
operator|*
name|flags_inout
operator||=
name|tmp
expr_stmt|;
else|else
operator|*
name|flags_inout
operator|&=
operator|~
name|tmp
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|CheckModifierField
name|CheckModifierField
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|xkb_action_type
name|action
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|,
name|enum
name|xkb_action_flags
modifier|*
name|flags_inout
parameter_list|,
name|xkb_mod_mask_t
modifier|*
name|mods_rtrn
parameter_list|)
block|{
if|if
condition|(
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_IDENT
condition|)
block|{
specifier|const
name|char
modifier|*
name|valStr
decl_stmt|;
name|valStr
operator|=
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
operator|->
name|ident
operator|.
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|valStr
operator|&&
operator|(
name|istreq
argument_list|(
name|valStr
argument_list|,
literal|"usemodmapmods"
argument_list|)
operator|||
name|istreq
argument_list|(
name|valStr
argument_list|,
literal|"modmapmods"
argument_list|)
operator|)
condition|)
block|{
operator|*
name|mods_rtrn
operator|=
literal|0
expr_stmt|;
operator|*
name|flags_inout
operator||=
name|ACTION_MODS_LOOKUP_MODMAP
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ExprResolveModMask
argument_list|(
name|keymap
argument_list|,
name|value
argument_list|,
name|MOD_BOTH
argument_list|,
name|mods_rtrn
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
argument_list|,
name|ACTION_FIELD_MODIFIERS
argument_list|,
literal|"modifier mask"
argument_list|)
return|;
operator|*
name|flags_inout
operator|&=
operator|~
name|ACTION_MODS_LOOKUP_MODMAP
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleSetLatchMods
name|HandleSetLatchMods
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_mod_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|mods
decl_stmt|;
name|enum
name|xkb_action_flags
name|rtrn
decl_stmt|,
name|t1
decl_stmt|;
name|xkb_mod_mask_t
name|t2
decl_stmt|;
if|if
condition|(
name|array_ndx
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|ACTION_FIELD_CLEAR_LOCKS
case|:
case|case
name|ACTION_FIELD_LATCH_TO_LOCK
case|:
case|case
name|ACTION_FIELD_MODIFIERS
case|:
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|ACTION_FIELD_CLEAR_LOCKS
case|:
case|case
name|ACTION_FIELD_LATCH_TO_LOCK
case|:
name|rtrn
operator|=
name|act
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|CheckLatchLockFlags
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
operator|&
name|rtrn
argument_list|)
condition|)
block|{
name|act
operator|->
name|flags
operator|=
name|rtrn
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|ACTION_FIELD_MODIFIERS
case|:
name|t1
operator|=
name|act
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|CheckModifierField
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|value
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
condition|)
block|{
name|act
operator|->
name|flags
operator|=
name|t1
expr_stmt|;
name|act
operator|->
name|mods
operator|.
name|mods
operator|=
name|t2
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
default|default:
break|break;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleLockMods
name|HandleLockMods
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_mod_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|mods
decl_stmt|;
name|enum
name|xkb_action_flags
name|t1
decl_stmt|;
name|xkb_mod_mask_t
name|t2
decl_stmt|;
if|if
condition|(
name|array_ndx
operator|&&
name|field
operator|==
name|ACTION_FIELD_MODIFIERS
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|ACTION_FIELD_MODIFIERS
case|:
name|t1
operator|=
name|act
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|CheckModifierField
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|value
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
condition|)
block|{
name|act
operator|->
name|flags
operator|=
name|t1
expr_stmt|;
name|act
operator|->
name|mods
operator|.
name|mods
operator|=
name|t2
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
default|default:
break|break;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|CheckGroupField
name|CheckGroupField
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|unsigned
name|action
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|,
name|enum
name|xkb_action_flags
modifier|*
name|flags_inout
parameter_list|,
name|xkb_layout_index_t
modifier|*
name|grp_rtrn
parameter_list|)
block|{
specifier|const
name|ExprDef
modifier|*
name|spec
decl_stmt|;
if|if
condition|(
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
operator|||
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_UNARY_PLUS
condition|)
block|{
operator|*
name|flags_inout
operator|&=
operator|~
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
name|spec
operator|=
name|value
operator|->
name|unary
operator|.
name|child
expr_stmt|;
block|}
else|else
block|{
operator|*
name|flags_inout
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
name|spec
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ExprResolveGroup
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|spec
argument_list|,
name|grp_rtrn
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
argument_list|,
name|ACTION_FIELD_GROUP
argument_list|,
literal|"integer (range 1..8)"
argument_list|)
return|;
if|if
condition|(
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
condition|)
operator|*
name|grp_rtrn
operator|=
operator|-
operator|*
name|grp_rtrn
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|->
name|expr
operator|.
name|op
operator|!=
name|EXPR_UNARY_PLUS
condition|)
operator|(
operator|*
name|grp_rtrn
operator|)
operator|--
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleSetLatchGroup
name|HandleSetLatchGroup
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_group_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|group
decl_stmt|;
name|enum
name|xkb_action_flags
name|rtrn
decl_stmt|,
name|t1
decl_stmt|;
name|xkb_layout_index_t
name|t2
decl_stmt|;
if|if
condition|(
name|array_ndx
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|ACTION_FIELD_CLEAR_LOCKS
case|:
case|case
name|ACTION_FIELD_LATCH_TO_LOCK
case|:
case|case
name|ACTION_FIELD_GROUP
case|:
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|ACTION_FIELD_CLEAR_LOCKS
case|:
case|case
name|ACTION_FIELD_LATCH_TO_LOCK
case|:
name|rtrn
operator|=
name|act
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|CheckLatchLockFlags
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
operator|&
name|rtrn
argument_list|)
condition|)
block|{
name|act
operator|->
name|flags
operator|=
name|rtrn
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|ACTION_FIELD_GROUP
case|:
name|t1
operator|=
name|act
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|CheckGroupField
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|value
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
condition|)
block|{
name|act
operator|->
name|flags
operator|=
name|t1
expr_stmt|;
name|act
operator|->
name|group
operator|=
name|t2
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
default|default:
break|break;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleLockGroup
name|HandleLockGroup
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_group_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|group
decl_stmt|;
name|enum
name|xkb_action_flags
name|t1
decl_stmt|;
name|xkb_layout_index_t
name|t2
decl_stmt|;
if|if
condition|(
operator|(
name|array_ndx
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|field
operator|==
name|ACTION_FIELD_GROUP
operator|)
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_GROUP
condition|)
block|{
name|t1
operator|=
name|act
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|CheckGroupField
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|value
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
condition|)
block|{
name|act
operator|->
name|flags
operator|=
name|t1
expr_stmt|;
name|act
operator|->
name|group
operator|=
name|t2
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleMovePtr
name|HandleMovePtr
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_pointer_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|ptr
decl_stmt|;
if|if
condition|(
name|array_ndx
operator|&&
operator|(
name|field
operator|==
name|ACTION_FIELD_X
operator|||
name|field
operator|==
name|ACTION_FIELD_Y
operator|)
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_X
operator|||
name|field
operator|==
name|ACTION_FIELD_Y
condition|)
block|{
name|int
name|val
decl_stmt|;
specifier|const
name|bool
name|absolute
init|=
operator|(
name|value
operator|->
name|expr
operator|.
name|op
operator|!=
name|EXPR_NEGATE
operator|&&
name|value
operator|->
name|expr
operator|.
name|op
operator|!=
name|EXPR_UNARY_PLUS
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveInteger
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"integer"
argument_list|)
return|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_X
condition|)
block|{
if|if
condition|(
name|absolute
condition|)
name|act
operator|->
name|flags
operator||=
name|ACTION_ABSOLUTE_X
expr_stmt|;
name|act
operator|->
name|x
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|absolute
condition|)
name|act
operator|->
name|flags
operator||=
name|ACTION_ABSOLUTE_Y
expr_stmt|;
name|act
operator|->
name|y
operator|=
name|val
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_ACCEL
condition|)
block|{
name|bool
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveBoolean
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|set
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"boolean"
argument_list|)
return|;
if|if
condition|(
name|set
condition|)
name|act
operator|->
name|flags
operator|&=
operator|~
name|ACTION_NO_ACCEL
expr_stmt|;
else|else
name|act
operator|->
name|flags
operator||=
name|ACTION_NO_ACCEL
expr_stmt|;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|lockWhich
specifier|static
specifier|const
name|LookupEntry
name|lockWhich
index|[]
init|=
block|{
block|{
literal|"both"
block|,
literal|0
block|}
block|,
block|{
literal|"lock"
block|,
name|ACTION_LOCK_NO_UNLOCK
block|}
block|,
block|{
literal|"neither"
block|,
operator|(
name|ACTION_LOCK_NO_LOCK
operator||
name|ACTION_LOCK_NO_UNLOCK
operator|)
block|}
block|,
block|{
literal|"unlock"
block|,
name|ACTION_LOCK_NO_LOCK
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|bool
DECL|function|HandlePtrBtn
name|HandlePtrBtn
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_pointer_button_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|btn
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_BUTTON
condition|)
block|{
name|int
name|btn
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveButton
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|btn
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"integer (range 1..5)"
argument_list|)
return|;
if|if
condition|(
name|btn
operator|<
literal|0
operator|||
name|btn
operator|>
literal|5
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Button must specify default or be in the range 1..5; "
literal|"Illegal button value %d ignored\n"
argument_list|,
name|btn
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|act
operator|->
name|button
operator|=
name|btn
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|action
operator|->
name|type
operator|==
name|ACTION_TYPE_PTR_LOCK
operator|&&
name|field
operator|==
name|ACTION_FIELD_AFFECT
condition|)
block|{
name|enum
name|xkb_action_flags
name|val
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveEnum
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|,
name|lockWhich
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"lock or unlock"
argument_list|)
return|;
name|act
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ACTION_LOCK_NO_LOCK
operator||
name|ACTION_LOCK_NO_UNLOCK
operator|)
expr_stmt|;
name|act
operator|->
name|flags
operator||=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_COUNT
condition|)
block|{
name|int
name|btn
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
comment|/* XXX: Should this actually be ResolveButton? */
if|if
condition|(
operator|!
name|ExprResolveButton
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|btn
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"integer"
argument_list|)
return|;
if|if
condition|(
name|btn
operator|<
literal|0
operator|||
name|btn
operator|>
literal|255
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The count field must have a value in the range 0..255; "
literal|"Illegal count %d ignored\n"
argument_list|,
name|btn
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|act
operator|->
name|count
operator|=
name|btn
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ptrDflts
specifier|static
specifier|const
name|LookupEntry
name|ptrDflts
index|[]
init|=
block|{
block|{
literal|"dfltbtn"
block|,
literal|1
block|}
block|,
block|{
literal|"defaultbutton"
block|,
literal|1
block|}
block|,
block|{
literal|"button"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|bool
DECL|function|HandleSetPtrDflt
name|HandleSetPtrDflt
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_pointer_default_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|dflt
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_AFFECT
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveEnum
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|,
name|ptrDflts
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"pointer component"
argument_list|)
return|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_BUTTON
operator|||
name|field
operator|==
name|ACTION_FIELD_VALUE
condition|)
block|{
specifier|const
name|ExprDef
modifier|*
name|button
decl_stmt|;
name|int
name|btn
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
operator|||
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_UNARY_PLUS
condition|)
block|{
name|act
operator|->
name|flags
operator|&=
operator|~
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
name|button
operator|=
name|value
operator|->
name|unary
operator|.
name|child
expr_stmt|;
block|}
else|else
block|{
name|act
operator|->
name|flags
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
name|button
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ExprResolveButton
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|button
argument_list|,
operator|&
name|btn
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"integer (range 1..5)"
argument_list|)
return|;
if|if
condition|(
name|btn
operator|<
literal|0
operator|||
name|btn
operator|>
literal|5
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"New default button value must be in the range 1..5; "
literal|"Illegal default button value %d ignored\n"
argument_list|,
name|btn
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|btn
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot set default pointer button to \"default\"; "
literal|"Illegal default button setting ignored\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|act
operator|->
name|value
operator|=
operator|(
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
condition|?
operator|-
name|btn
else|:
name|btn
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleSwitchScreen
name|HandleSwitchScreen
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_switch_screen_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|screen
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_SCREEN
condition|)
block|{
specifier|const
name|ExprDef
modifier|*
name|scrn
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
operator|||
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_UNARY_PLUS
condition|)
block|{
name|act
operator|->
name|flags
operator|&=
operator|~
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
name|scrn
operator|=
name|value
operator|->
name|unary
operator|.
name|child
expr_stmt|;
block|}
else|else
block|{
name|act
operator|->
name|flags
operator||=
name|ACTION_ABSOLUTE_SWITCH
expr_stmt|;
name|scrn
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ExprResolveInteger
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|scrn
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"integer (0..255)"
argument_list|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|255
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Screen index must be in the range 1..255; "
literal|"Illegal screen value %d ignored\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|act
operator|->
name|screen
operator|=
operator|(
name|value
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NEGATE
condition|?
operator|-
name|val
else|:
name|val
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_SAME
condition|)
block|{
name|bool
name|set
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveBoolean
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|set
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"boolean"
argument_list|)
return|;
if|if
condition|(
name|set
condition|)
name|act
operator|->
name|flags
operator|&=
operator|~
name|ACTION_SAME_SCREEN
expr_stmt|;
else|else
name|act
operator|->
name|flags
operator||=
name|ACTION_SAME_SCREEN
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleSetLockControls
name|HandleSetLockControls
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_controls_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|ctrls
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_CONTROLS
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|array_ndx
condition|)
return|return
name|ReportActionNotArray
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
if|if
condition|(
operator|!
name|ExprResolveMask
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|mask
argument_list|,
name|ctrlMaskNames
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"controls mask"
argument_list|)
return|;
name|act
operator|->
name|ctrls
operator|=
name|mask
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandlePrivate
name|HandlePrivate
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xkb_private_action
modifier|*
name|act
init|=
operator|&
name|action
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_TYPE
condition|)
block|{
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveInteger
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|type
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|ACTION_TYPE_PRIVATE
argument_list|,
name|field
argument_list|,
literal|"integer"
argument_list|)
return|;
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>
literal|255
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Private action type must be in the range 0..255; "
literal|"Illegal type %d ignored\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/*          * It's possible for someone to write something like this:          *      actions = [ Private(type=3,data[0]=1,data[1]=3,data[2]=3) ]          * where the type refers to some existing action type, e.g. LockMods.          * This assumes that this action's struct is laid out in memory          * exactly as described in the XKB specification and libraries.          * We, however, have changed these structs in various ways, so this          * assumption is no longer true. Since this is a lousy "feature", we          * make actions like these no-ops for now.          */
if|if
condition|(
name|type
operator|<
name|ACTION_TYPE_PRIVATE
condition|)
block|{
name|log_info
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Private actions of type %s are not supported; Ignored\n"
argument_list|,
name|ActionTypeText
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|act
operator|->
name|type
operator|=
name|ACTION_TYPE_NONE
expr_stmt|;
block|}
else|else
block|{
name|act
operator|->
name|type
operator|=
operator|(
expr|enum
name|xkb_action_type
operator|)
name|type
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|field
operator|==
name|ACTION_FIELD_DATA
condition|)
block|{
if|if
condition|(
name|array_ndx
operator|==
name|NULL
condition|)
block|{
name|xkb_atom_t
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveString
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"string"
argument_list|)
return|;
name|str
operator|=
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
operator|||
name|len
operator|>
literal|7
condition|)
block|{
name|log_warn
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"A private action has 7 data bytes; "
literal|"Extra %d bytes ignored\n"
argument_list|,
name|len
operator|-
literal|6
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|act
operator|->
name|data
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|act
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|int
name|ndx
decl_stmt|,
name|datum
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveInteger
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|array_ndx
argument_list|,
operator|&
name|ndx
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Array subscript must be integer; "
literal|"Illegal subscript ignored\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|ndx
operator|<
literal|0
operator|||
name|ndx
operator|>=
sizeof|sizeof
argument_list|(
name|act
operator|->
name|data
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The data for a private action is %lu bytes long; "
literal|"Attempt to use data[%d] ignored\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|act
operator|->
name|data
argument_list|)
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ExprResolveInteger
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|datum
argument_list|)
condition|)
return|return
name|ReportMismatch
argument_list|(
name|keymap
argument_list|,
name|act
operator|->
name|type
argument_list|,
name|field
argument_list|,
literal|"integer"
argument_list|)
return|;
if|if
condition|(
name|datum
operator|<
literal|0
operator|||
name|datum
operator|>
literal|255
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"All data for a private action must be 0..255; "
literal|"Illegal datum %d ignored\n"
argument_list|,
name|datum
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|act
operator|->
name|data
index|[
name|ndx
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|datum
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|ReportIllegal
argument_list|(
name|keymap
argument_list|,
name|ACTION_TYPE_NONE
argument_list|,
name|field
argument_list|)
return|;
block|}
end_function
begin_typedef
DECL|typedef|actionHandler
typedef|typedef
name|bool
function_decl|(
modifier|*
name|actionHandler
function_decl|)
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|enum
name|action_field
name|field
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
specifier|const
name|ExprDef
modifier|*
name|value
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|handleAction
specifier|static
specifier|const
name|actionHandler
name|handleAction
index|[
name|_ACTION_TYPE_NUM_ENTRIES
index|]
init|=
block|{
index|[
name|ACTION_TYPE_NONE
index|]
operator|=
name|HandleNoAction
block|,
index|[
name|ACTION_TYPE_MOD_SET
index|]
operator|=
name|HandleSetLatchMods
block|,
index|[
name|ACTION_TYPE_MOD_LATCH
index|]
operator|=
name|HandleSetLatchMods
block|,
index|[
name|ACTION_TYPE_MOD_LOCK
index|]
operator|=
name|HandleLockMods
block|,
index|[
name|ACTION_TYPE_GROUP_SET
index|]
operator|=
name|HandleSetLatchGroup
block|,
index|[
name|ACTION_TYPE_GROUP_LATCH
index|]
operator|=
name|HandleSetLatchGroup
block|,
index|[
name|ACTION_TYPE_GROUP_LOCK
index|]
operator|=
name|HandleLockGroup
block|,
index|[
name|ACTION_TYPE_PTR_MOVE
index|]
operator|=
name|HandleMovePtr
block|,
index|[
name|ACTION_TYPE_PTR_BUTTON
index|]
operator|=
name|HandlePtrBtn
block|,
index|[
name|ACTION_TYPE_PTR_LOCK
index|]
operator|=
name|HandlePtrBtn
block|,
index|[
name|ACTION_TYPE_PTR_DEFAULT
index|]
operator|=
name|HandleSetPtrDflt
block|,
index|[
name|ACTION_TYPE_TERMINATE
index|]
operator|=
name|HandleNoAction
block|,
index|[
name|ACTION_TYPE_SWITCH_VT
index|]
operator|=
name|HandleSwitchScreen
block|,
index|[
name|ACTION_TYPE_CTRL_SET
index|]
operator|=
name|HandleSetLockControls
block|,
index|[
name|ACTION_TYPE_CTRL_LOCK
index|]
operator|=
name|HandleSetLockControls
block|,
index|[
name|ACTION_TYPE_PRIVATE
index|]
operator|=
name|HandlePrivate
block|, }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
name|bool
DECL|function|HandleActionDef
name|HandleActionDef
parameter_list|(
name|ExprDef
modifier|*
name|def
parameter_list|,
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
name|ActionsInfo
modifier|*
name|info
parameter_list|)
block|{
name|ExprDef
modifier|*
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|handler_type
decl_stmt|;
if|if
condition|(
name|def
operator|->
name|expr
operator|.
name|op
operator|!=
name|EXPR_ACTION_DECL
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Expected an action definition, found %s\n"
argument_list|,
name|expr_op_type_to_string
argument_list|(
name|def
operator|->
name|expr
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|str
operator|=
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|def
operator|->
name|action
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stringToAction
argument_list|(
name|str
argument_list|,
operator|&
name|handler_type
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Unknown action %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/*      * Get the default values for this action type, as modified by      * statements such as:      *     latchMods.clearLocks = True;      */
operator|*
name|action
operator|=
name|info
operator|->
name|actions
index|[
name|handler_type
index|]
expr_stmt|;
comment|/*      * Now change the action properties as specified for this      * particular instance, e.g. "modifiers" and "clearLocks" in:      *     SetMods(modifiers=Alt,clearLocks);      */
for|for
control|(
name|arg
operator|=
name|def
operator|->
name|action
operator|.
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
operator|(
name|ExprDef
operator|*
operator|)
name|arg
operator|->
name|common
operator|.
name|next
control|)
block|{
specifier|const
name|ExprDef
modifier|*
name|value
decl_stmt|;
name|ExprDef
modifier|*
name|field
decl_stmt|,
modifier|*
name|arrayRtrn
decl_stmt|;
specifier|const
name|char
modifier|*
name|elemRtrn
decl_stmt|,
modifier|*
name|fieldRtrn
decl_stmt|;
name|enum
name|action_field
name|fieldNdx
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_ASSIGN
condition|)
block|{
name|field
operator|=
name|arg
operator|->
name|binary
operator|.
name|left
expr_stmt|;
name|value
operator|=
name|arg
operator|->
name|binary
operator|.
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_NOT
operator|||
name|arg
operator|->
name|expr
operator|.
name|op
operator|==
name|EXPR_INVERT
condition|)
block|{
name|field
operator|=
name|arg
operator|->
name|unary
operator|.
name|child
expr_stmt|;
name|value
operator|=
operator|(
specifier|const
name|ExprDef
operator|*
operator|)
operator|&
name|constFalse
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
name|arg
expr_stmt|;
name|value
operator|=
operator|(
specifier|const
name|ExprDef
operator|*
operator|)
operator|&
name|constTrue
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ExprResolveLhs
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|field
argument_list|,
operator|&
name|elemRtrn
argument_list|,
operator|&
name|fieldRtrn
argument_list|,
operator|&
name|arrayRtrn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elemRtrn
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot change defaults in an action definition; "
literal|"Ignoring attempt to change %s.%s\n"
argument_list|,
name|elemRtrn
argument_list|,
name|fieldRtrn
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|stringToField
argument_list|(
name|fieldRtrn
argument_list|,
operator|&
name|fieldNdx
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Unknown field name %s\n"
argument_list|,
name|fieldRtrn
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|handleAction
index|[
name|handler_type
index|]
operator|(
name|keymap
operator|,
name|action
operator|,
name|fieldNdx
operator|,
name|arrayRtrn
operator|,
name|value
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|SetActionField
name|SetActionField
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|ExprDef
modifier|*
name|array_ndx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|,
name|ActionsInfo
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|action
decl_stmt|;
name|enum
name|action_field
name|action_field
decl_stmt|;
if|if
condition|(
operator|!
name|stringToAction
argument_list|(
name|elem
argument_list|,
operator|&
name|action
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|stringToField
argument_list|(
name|field
argument_list|,
operator|&
name|action_field
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"\"%s\" is not a legal field name\n"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|handleAction
index|[
name|action
index|]
operator|(
name|keymap
operator|,
operator|&
name|info
operator|->
name|actions
index|[
name|action
index|]
operator|,
name|action_field
operator|,
name|array_ndx
operator|,
name|value
operator|)
return|;
block|}
end_function
end_unit
