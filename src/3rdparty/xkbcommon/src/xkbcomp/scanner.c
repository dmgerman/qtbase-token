begin_unit
begin_line
line|#
directive|line
number|2
file|"src/xkbcomp/scanner.c"
end_line
begin_line
line|#
directive|line
number|4
file|"src/xkbcomp/scanner.c"
end_line
begin_define
DECL|macro|YY_INT_ALIGNED
define|#
directive|define
name|YY_INT_ALIGNED
value|short int
end_define
begin_comment
comment|/* A lexical scanner generated by flex */
end_comment
begin_define
DECL|macro|FLEX_SCANNER
define|#
directive|define
name|FLEX_SCANNER
end_define
begin_define
DECL|macro|YY_FLEX_MAJOR_VERSION
define|#
directive|define
name|YY_FLEX_MAJOR_VERSION
value|2
end_define
begin_define
DECL|macro|YY_FLEX_MINOR_VERSION
define|#
directive|define
name|YY_FLEX_MINOR_VERSION
value|5
end_define
begin_define
DECL|macro|YY_FLEX_SUBMINOR_VERSION
define|#
directive|define
name|YY_FLEX_SUBMINOR_VERSION
value|35
end_define
begin_if
if|#
directive|if
name|YY_FLEX_SUBMINOR_VERSION
operator|>
literal|0
end_if
begin_define
DECL|macro|FLEX_BETA
define|#
directive|define
name|FLEX_BETA
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* First, we deal with  platform-specific or compiler-specific issues. */
end_comment
begin_comment
comment|/* begin standard C headers. */
end_comment
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_comment
comment|/* end standard C headers. */
end_comment
begin_comment
comment|/* flex integer type definitions */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FLEXINT_H
end_ifndef
begin_define
DECL|macro|FLEXINT_H
define|#
directive|define
name|FLEXINT_H
end_define
begin_comment
comment|/* C99 systems have<inttypes.h>. Non-C99 systems may or may not. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if
begin_comment
comment|/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,  * if you want the limit (max/min) macros for int types.   */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|__STDC_LIMIT_MACROS
end_ifndef
begin_define
DECL|macro|__STDC_LIMIT_MACROS
define|#
directive|define
name|__STDC_LIMIT_MACROS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<inttypes.h>
end_include
begin_typedef
DECL|typedef|flex_int8_t
typedef|typedef
name|int8_t
name|flex_int8_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_uint8_t
typedef|typedef
name|uint8_t
name|flex_uint8_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_int16_t
typedef|typedef
name|int16_t
name|flex_int16_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_uint16_t
typedef|typedef
name|uint16_t
name|flex_uint16_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_int32_t
typedef|typedef
name|int32_t
name|flex_int32_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_uint32_t
typedef|typedef
name|uint32_t
name|flex_uint32_t
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|flex_int8_t
typedef|typedef
name|signed
name|char
name|flex_int8_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_int16_t
typedef|typedef
name|short
name|int
name|flex_int16_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_int32_t
typedef|typedef
name|int
name|flex_int32_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_uint8_t
typedef|typedef
name|unsigned
name|char
name|flex_uint8_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_uint16_t
typedef|typedef
name|unsigned
name|short
name|int
name|flex_uint16_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|flex_uint32_t
typedef|typedef
name|unsigned
name|int
name|flex_uint32_t
typedef|;
end_typedef
begin_comment
comment|/* Limits of integral types. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|INT8_MIN
end_ifndef
begin_define
DECL|macro|INT8_MIN
define|#
directive|define
name|INT8_MIN
value|(-128)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|INT16_MIN
end_ifndef
begin_define
DECL|macro|INT16_MIN
define|#
directive|define
name|INT16_MIN
value|(-32767-1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|INT32_MIN
end_ifndef
begin_define
DECL|macro|INT32_MIN
define|#
directive|define
name|INT32_MIN
value|(-2147483647-1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|INT8_MAX
end_ifndef
begin_define
DECL|macro|INT8_MAX
define|#
directive|define
name|INT8_MAX
value|(127)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|INT16_MAX
end_ifndef
begin_define
DECL|macro|INT16_MAX
define|#
directive|define
name|INT16_MAX
value|(32767)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|INT32_MAX
end_ifndef
begin_define
DECL|macro|INT32_MAX
define|#
directive|define
name|INT32_MAX
value|(2147483647)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|UINT8_MAX
end_ifndef
begin_define
DECL|macro|UINT8_MAX
define|#
directive|define
name|UINT8_MAX
value|(255U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|UINT16_MAX
end_ifndef
begin_define
DECL|macro|UINT16_MAX
define|#
directive|define
name|UINT16_MAX
value|(65535U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|UINT32_MAX
end_ifndef
begin_define
DECL|macro|UINT32_MAX
define|#
directive|define
name|UINT32_MAX
value|(4294967295U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ! C99 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ! FLEXINT_H */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_comment
comment|/* The "const" storage-class-modifier is valid. */
end_comment
begin_define
DECL|macro|YY_USE_CONST
define|#
directive|define
name|YY_USE_CONST
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ! __cplusplus */
end_comment
begin_comment
comment|/* C99 requires __STDC__ to be defined as 1. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if
begin_define
DECL|macro|YY_USE_CONST
define|#
directive|define
name|YY_USE_CONST
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined (__STDC__) */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ! __cplusplus */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|YY_USE_CONST
end_ifdef
begin_define
DECL|macro|yyconst
define|#
directive|define
name|yyconst
value|const
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|yyconst
define|#
directive|define
name|yyconst
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Returned upon end-of-file. */
end_comment
begin_define
DECL|macro|YY_NULL
define|#
directive|define
name|YY_NULL
value|0
end_define
begin_comment
comment|/* Promotes a possibly negative, possibly signed char to an unsigned  * integer for use as an array index.  If the signed char is negative,  * we want to instead treat it as an 8-bit unsigned char, hence the  * double cast.  */
end_comment
begin_define
DECL|macro|YY_SC_TO_UI
define|#
directive|define
name|YY_SC_TO_UI
parameter_list|(
name|c
parameter_list|)
value|((unsigned int) (unsigned char) c)
end_define
begin_comment
comment|/* An opaque pointer. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_TYPEDEF_YY_SCANNER_T
end_ifndef
begin_define
DECL|macro|YY_TYPEDEF_YY_SCANNER_T
define|#
directive|define
name|YY_TYPEDEF_YY_SCANNER_T
end_define
begin_typedef
DECL|typedef|yyscan_t
typedef|typedef
name|void
modifier|*
name|yyscan_t
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* For convenience, these vars (plus the bison vars far below)    are macros in the reentrant scanner. */
end_comment
begin_define
DECL|macro|yyin
define|#
directive|define
name|yyin
value|yyg->yyin_r
end_define
begin_define
DECL|macro|yyout
define|#
directive|define
name|yyout
value|yyg->yyout_r
end_define
begin_define
DECL|macro|yyextra
define|#
directive|define
name|yyextra
value|yyg->yyextra_r
end_define
begin_define
DECL|macro|yyleng
define|#
directive|define
name|yyleng
value|yyg->yyleng_r
end_define
begin_define
DECL|macro|yytext
define|#
directive|define
name|yytext
value|yyg->yytext_r
end_define
begin_define
DECL|macro|yylineno
define|#
directive|define
name|yylineno
value|(YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
end_define
begin_define
DECL|macro|yycolumn
define|#
directive|define
name|yycolumn
value|(YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
end_define
begin_define
DECL|macro|yy_flex_debug
define|#
directive|define
name|yy_flex_debug
value|yyg->yy_flex_debug_r
end_define
begin_comment
comment|/* Enter a start condition.  This macro really ought to take a parameter,  * but we do it the disgusting crufty way forced on us by the ()-less  * definition of BEGIN.  */
end_comment
begin_define
DECL|macro|BEGIN
define|#
directive|define
name|BEGIN
value|yyg->yy_start = 1 + 2 *
end_define
begin_comment
comment|/* Translate the current start state into a value that can be later handed  * to BEGIN to return to the state.  The YYSTATE alias is for lex  * compatibility.  */
end_comment
begin_define
DECL|macro|YY_START
define|#
directive|define
name|YY_START
value|((yyg->yy_start - 1) / 2)
end_define
begin_define
DECL|macro|YYSTATE
define|#
directive|define
name|YYSTATE
value|YY_START
end_define
begin_comment
comment|/* Action number for EOF rule of a given start state. */
end_comment
begin_define
DECL|macro|YY_STATE_EOF
define|#
directive|define
name|YY_STATE_EOF
parameter_list|(
name|state
parameter_list|)
value|(YY_END_OF_BUFFER + state + 1)
end_define
begin_comment
comment|/* Special action meaning "start processing a new file". */
end_comment
begin_define
DECL|macro|YY_NEW_FILE
define|#
directive|define
name|YY_NEW_FILE
value|_xkbcommon_restart(yyin ,yyscanner )
end_define
begin_define
DECL|macro|YY_END_OF_BUFFER_CHAR
define|#
directive|define
name|YY_END_OF_BUFFER_CHAR
value|0
end_define
begin_comment
comment|/* Size of default input buffer. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_BUF_SIZE
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef
begin_comment
comment|/* On IA-64, the buffer size is 16k, not 8k.  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.  * Ditto for the __ia64__ case accordingly.  */
end_comment
begin_define
DECL|macro|YY_BUF_SIZE
define|#
directive|define
name|YY_BUF_SIZE
value|32768
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|YY_BUF_SIZE
define|#
directive|define
name|YY_BUF_SIZE
value|16384
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __ia64__ */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The state buf must be large enough to hold one state per character in the main buffer.  */
end_comment
begin_define
DECL|macro|YY_STATE_BUF_SIZE
define|#
directive|define
name|YY_STATE_BUF_SIZE
value|((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|YY_TYPEDEF_YY_BUFFER_STATE
end_ifndef
begin_define
DECL|macro|YY_TYPEDEF_YY_BUFFER_STATE
define|#
directive|define
name|YY_TYPEDEF_YY_BUFFER_STATE
end_define
begin_typedef
DECL|typedef|YY_BUFFER_STATE
typedef|typedef
name|struct
name|yy_buffer_state
modifier|*
name|YY_BUFFER_STATE
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|EOB_ACT_CONTINUE_SCAN
define|#
directive|define
name|EOB_ACT_CONTINUE_SCAN
value|0
end_define
begin_define
DECL|macro|EOB_ACT_END_OF_FILE
define|#
directive|define
name|EOB_ACT_END_OF_FILE
value|1
end_define
begin_define
DECL|macro|EOB_ACT_LAST_MATCH
define|#
directive|define
name|EOB_ACT_LAST_MATCH
value|2
end_define
begin_comment
comment|/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires      *       access to the local variable yy_act. Since yyless() is a macro, it would break      *       existing scanners that call yyless() from OUTSIDE _xkbcommon_lex.       *       One obvious solution it to make yy_act a global. I tried that, and saw      *       a 5% performance hit in a non-yylineno scanner, because yy_act is      *       normally declared as a register variable-- so it is not worth it.      */
end_comment
begin_define
DECL|macro|YY_LESS_LINENO
define|#
directive|define
name|YY_LESS_LINENO
parameter_list|(
name|n
parameter_list|)
define|\
value|do { \                 int yyl;\                 for ( yyl = n; yyl< yyleng; ++yyl )\                     if ( yytext[yyl] == '\n' )\                         --yylineno;\             }while(0)
end_define
begin_comment
comment|/* Return all but the first "n" matched characters back to the input stream. */
end_comment
begin_define
DECL|macro|yyless
define|#
directive|define
name|yyless
parameter_list|(
name|n
parameter_list|)
define|\
value|do \ 		{ \
comment|/* Undo effects of setting up yytext. */
value|\         int yyless_macro_arg = (n); \         YY_LESS_LINENO(yyless_macro_arg);\ 		*yy_cp = yyg->yy_hold_char; \ 		YY_RESTORE_YY_MORE_OFFSET \ 		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \ 		YY_DO_BEFORE_ACTION;
comment|/* set up yytext again */
value|\ 		} \ 	while ( 0 )
end_define
begin_define
DECL|macro|unput
define|#
directive|define
name|unput
parameter_list|(
name|c
parameter_list|)
value|yyunput( c, yyg->yytext_ptr , yyscanner )
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|YY_TYPEDEF_YY_SIZE_T
end_ifndef
begin_define
DECL|macro|YY_TYPEDEF_YY_SIZE_T
define|#
directive|define
name|YY_TYPEDEF_YY_SIZE_T
end_define
begin_typedef
DECL|typedef|yy_size_t
typedef|typedef
name|size_t
name|yy_size_t
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|YY_STRUCT_YY_BUFFER_STATE
end_ifndef
begin_define
DECL|macro|YY_STRUCT_YY_BUFFER_STATE
define|#
directive|define
name|YY_STRUCT_YY_BUFFER_STATE
end_define
begin_struct
DECL|struct|yy_buffer_state
struct|struct
name|yy_buffer_state
block|{
DECL|member|yy_input_file
name|FILE
modifier|*
name|yy_input_file
decl_stmt|;
DECL|member|yy_ch_buf
name|char
modifier|*
name|yy_ch_buf
decl_stmt|;
comment|/* input buffer */
DECL|member|yy_buf_pos
name|char
modifier|*
name|yy_buf_pos
decl_stmt|;
comment|/* current position in input buffer */
comment|/* Size of input buffer in bytes, not including room for EOB 	 * characters. 	 */
DECL|member|yy_buf_size
name|yy_size_t
name|yy_buf_size
decl_stmt|;
comment|/* Number of characters read into yy_ch_buf, not including EOB 	 * characters. 	 */
DECL|member|yy_n_chars
name|int
name|yy_n_chars
decl_stmt|;
comment|/* Whether we "own" the buffer - i.e., we know we created it, 	 * and can realloc() it to grow it, and should free() it to 	 * delete it. 	 */
DECL|member|yy_is_our_buffer
name|int
name|yy_is_our_buffer
decl_stmt|;
comment|/* Whether this is an "interactive" input source; if so, and 	 * if we're using stdio for input, then we want to use getc() 	 * instead of fread(), to make sure we stop fetching input after 	 * each newline. 	 */
DECL|member|yy_is_interactive
name|int
name|yy_is_interactive
decl_stmt|;
comment|/* Whether we're considered to be at the beginning of a line. 	 * If so, '^' rules will be active on the next match, otherwise 	 * not. 	 */
DECL|member|yy_at_bol
name|int
name|yy_at_bol
decl_stmt|;
DECL|member|yy_bs_lineno
name|int
name|yy_bs_lineno
decl_stmt|;
comment|/**< The line count. */
DECL|member|yy_bs_column
name|int
name|yy_bs_column
decl_stmt|;
comment|/**< The column count. */
comment|/* Whether to try to fill the input buffer when we reach the 	 * end of it. 	 */
DECL|member|yy_fill_buffer
name|int
name|yy_fill_buffer
decl_stmt|;
DECL|member|yy_buffer_status
name|int
name|yy_buffer_status
decl_stmt|;
DECL|macro|YY_BUFFER_NEW
define|#
directive|define
name|YY_BUFFER_NEW
value|0
DECL|macro|YY_BUFFER_NORMAL
define|#
directive|define
name|YY_BUFFER_NORMAL
value|1
comment|/* When an EOF's been seen but there's still some text to process 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we 	 * shouldn't try reading from the input source any more.  We might 	 * still have a bunch of tokens to match, though, because of 	 * possible backing-up. 	 * 	 * When we actually see the EOF, we change the status to "new" 	 * (via _xkbcommon_restart()), so that the user can continue scanning by 	 * just pointing yyin at a new input file. 	 */
DECL|macro|YY_BUFFER_EOF_PENDING
define|#
directive|define
name|YY_BUFFER_EOF_PENDING
value|2
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !YY_STRUCT_YY_BUFFER_STATE */
end_comment
begin_comment
comment|/* We provide macros for accessing buffer states in case in the  * future we want to put the buffer states in a more general  * "scanner state".  *  * Returns the top of the stack, or NULL.  */
end_comment
begin_define
DECL|macro|YY_CURRENT_BUFFER
define|#
directive|define
name|YY_CURRENT_BUFFER
value|( yyg->yy_buffer_stack \                           ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \                           : NULL)
end_define
begin_comment
comment|/* Same as previous macro, but useful when we know that the buffer stack is not  * NULL or when we need an lvalue. For internal use only.  */
end_comment
begin_define
DECL|macro|YY_CURRENT_BUFFER_LVALUE
define|#
directive|define
name|YY_CURRENT_BUFFER_LVALUE
value|yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
end_define
begin_function_decl
name|void
name|_xkbcommon_restart
parameter_list|(
name|FILE
modifier|*
name|input_file
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon__switch_to_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|YY_BUFFER_STATE
name|_xkbcommon__create_buffer
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon__delete_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon__flush_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_push_buffer_state
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_pop_buffer_state
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|_xkbcommon_ensure_buffer_stack
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|_xkbcommon__load_buffer_state
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|_xkbcommon__init_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|YY_FLUSH_BUFFER
define|#
directive|define
name|YY_FLUSH_BUFFER
value|_xkbcommon__flush_buffer(YY_CURRENT_BUFFER ,yyscanner)
end_define
begin_function_decl
name|YY_BUFFER_STATE
name|_xkbcommon__scan_buffer
parameter_list|(
name|char
modifier|*
name|base
parameter_list|,
name|yy_size_t
name|size
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|YY_BUFFER_STATE
name|_xkbcommon__scan_string
parameter_list|(
name|yyconst
name|char
modifier|*
name|yy_str
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|YY_BUFFER_STATE
name|_xkbcommon__scan_bytes
parameter_list|(
name|yyconst
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|len
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|_xkbcommon_alloc
parameter_list|(
name|yy_size_t
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|_xkbcommon_realloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|yy_size_t
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|yy_new_buffer
define|#
directive|define
name|yy_new_buffer
value|_xkbcommon__create_buffer
end_define
begin_define
DECL|macro|yy_set_interactive
define|#
directive|define
name|yy_set_interactive
parameter_list|(
name|is_interactive
parameter_list|)
define|\
value|{ \ 	if ( ! YY_CURRENT_BUFFER ){ \         _xkbcommon_ensure_buffer_stack (yyscanner); \ 		YY_CURRENT_BUFFER_LVALUE =    \             _xkbcommon__create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \ 	} \ 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \ 	}
end_define
begin_define
DECL|macro|yy_set_bol
define|#
directive|define
name|yy_set_bol
parameter_list|(
name|at_bol
parameter_list|)
define|\
value|{ \ 	if ( ! YY_CURRENT_BUFFER ){\         _xkbcommon_ensure_buffer_stack (yyscanner); \ 		YY_CURRENT_BUFFER_LVALUE =    \             _xkbcommon__create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \ 	} \ 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \ 	}
end_define
begin_define
DECL|macro|YY_AT_BOL
define|#
directive|define
name|YY_AT_BOL
parameter_list|()
value|(YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
end_define
begin_comment
comment|/* Begin user sect3 */
end_comment
begin_define
DECL|macro|_xkbcommon_wrap
define|#
directive|define
name|_xkbcommon_wrap
parameter_list|(
name|n
parameter_list|)
value|1
end_define
begin_define
DECL|macro|YY_SKIP_YYWRAP
define|#
directive|define
name|YY_SKIP_YYWRAP
end_define
begin_typedef
DECL|typedef|YY_CHAR
typedef|typedef
name|unsigned
name|char
name|YY_CHAR
typedef|;
end_typedef
begin_typedef
DECL|typedef|yy_state_type
typedef|typedef
name|int
name|yy_state_type
typedef|;
end_typedef
begin_define
DECL|macro|yytext_ptr
define|#
directive|define
name|yytext_ptr
value|yytext_r
end_define
begin_function_decl
specifier|static
name|yy_state_type
name|yy_get_previous_state
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|yy_state_type
name|yy_try_NUL_trans
parameter_list|(
name|yy_state_type
name|current_state
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|yy_get_next_buffer
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|yy_fatal_error
parameter_list|(
name|yyconst
name|char
name|msg
index|[]
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Done after the current pattern has been matched and before the  * corresponding action - sets up yytext.  */
end_comment
begin_define
DECL|macro|YY_DO_BEFORE_ACTION
define|#
directive|define
name|YY_DO_BEFORE_ACTION
define|\
value|yyg->yytext_ptr = yy_bp; \ 	yyleng = (size_t) (yy_cp - yy_bp); \ 	yyg->yy_hold_char = *yy_cp; \ 	*yy_cp = '\0'; \ 	yyg->yy_c_buf_p = yy_cp;
end_define
begin_define
DECL|macro|YY_NUM_RULES
define|#
directive|define
name|YY_NUM_RULES
value|83
end_define
begin_define
DECL|macro|YY_END_OF_BUFFER
define|#
directive|define
name|YY_END_OF_BUFFER
value|84
end_define
begin_comment
comment|/* This struct is not used in this scanner,    but its presence is necessary. */
end_comment
begin_struct
DECL|struct|yy_trans_info
struct|struct
name|yy_trans_info
block|{
DECL|member|yy_verify
name|flex_int32_t
name|yy_verify
decl_stmt|;
DECL|member|yy_nxt
name|flex_int32_t
name|yy_nxt
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|yy_accept
specifier|static
name|yyconst
name|flex_int16_t
name|yy_accept
index|[
literal|336
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|84
block|,
literal|82
block|,
literal|81
block|,
literal|81
block|,
literal|79
block|,
literal|3
block|,
literal|2
block|,
literal|72
block|,
literal|73
block|,
literal|69
block|,
literal|66
block|,
literal|77
block|,
literal|67
block|,
literal|76
block|,
literal|68
block|,
literal|63
block|,
literal|63
block|,
literal|78
block|,
literal|82
block|,
literal|65
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|74
block|,
literal|75
block|,
literal|70
block|,
literal|71
block|,
literal|80
block|,
literal|14
block|,
literal|83
block|,
literal|4
block|,
literal|14
block|,
literal|81
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|63
block|,
literal|0
block|,
literal|0
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|5
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|9
block|,
literal|8
block|,
literal|12
block|,
literal|1
block|,
literal|64
block|,
literal|62
block|,
literal|15
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|39
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|47
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|5
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|48
block|,
literal|54
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|51
block|,
literal|36
block|,
literal|61
block|,
literal|61
block|,
literal|5
block|,
literal|61
block|,
literal|40
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|41
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|46
block|,
literal|53
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|38
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|34
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|42
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|29
block|,
literal|33
block|,
literal|61
block|,
literal|27
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|43
block|,
literal|52
block|,
literal|50
block|,
literal|61
block|,
literal|32
block|,
literal|30
block|,
literal|49
block|,
literal|55
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|28
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|31
block|,
literal|61
block|,
literal|45
block|,
literal|37
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|18
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|20
block|,
literal|61
block|,
literal|61
block|,
literal|16
block|,
literal|26
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|58
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|19
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|44
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|24
block|,
literal|17
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|59
block|,
literal|57
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|25
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|21
block|,
literal|61
block|,
literal|60
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|56
block|,
literal|35
block|,
literal|22
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|23
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yy_ec
specifier|static
name|yyconst
name|flex_int32_t
name|yy_ec
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|1
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|1
block|,
literal|1
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|31
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|31
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|1
block|,
literal|49
block|,
literal|1
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|31
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|31
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|31
block|,
literal|73
block|,
literal|1
block|,
literal|74
block|,
literal|75
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yy_meta
specifier|static
name|yyconst
name|flex_int32_t
name|yy_meta
index|[
literal|76
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yy_base
specifier|static
name|yyconst
name|flex_int16_t
name|yy_base
index|[
literal|342
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|73
block|,
literal|74
block|,
literal|263
block|,
literal|695
block|,
literal|78
block|,
literal|80
block|,
literal|695
block|,
literal|695
block|,
literal|0
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|203
block|,
literal|71
block|,
literal|76
block|,
literal|695
block|,
literal|0
block|,
literal|695
block|,
literal|66
block|,
literal|0
block|,
literal|59
block|,
literal|54
block|,
literal|58
block|,
literal|67
block|,
literal|65
block|,
literal|75
block|,
literal|67
block|,
literal|68
block|,
literal|64
block|,
literal|86
block|,
literal|83
block|,
literal|109
block|,
literal|98
block|,
literal|81
block|,
literal|82
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|158
block|,
literal|114
block|,
literal|0
block|,
literal|0
block|,
literal|132
block|,
literal|138
block|,
literal|0
block|,
literal|158
block|,
literal|0
block|,
literal|100
block|,
literal|128
block|,
literal|100
block|,
literal|123
block|,
literal|109
block|,
literal|124
block|,
literal|136
block|,
literal|166
block|,
literal|131
block|,
literal|141
block|,
literal|152
block|,
literal|140
block|,
literal|156
block|,
literal|150
block|,
literal|157
block|,
literal|156
block|,
literal|159
block|,
literal|179
block|,
literal|171
block|,
literal|164
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|221
block|,
literal|229
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|695
block|,
literal|0
block|,
literal|232
block|,
literal|0
block|,
literal|695
block|,
literal|192
block|,
literal|202
block|,
literal|199
block|,
literal|206
block|,
literal|200
block|,
literal|217
block|,
literal|216
block|,
literal|201
block|,
literal|226
block|,
literal|220
block|,
literal|224
block|,
literal|229
block|,
literal|220
block|,
literal|222
block|,
literal|232
block|,
literal|231
block|,
literal|227
block|,
literal|230
block|,
literal|238
block|,
literal|0
block|,
literal|232
block|,
literal|236
block|,
literal|244
block|,
literal|236
block|,
literal|251
block|,
literal|247
block|,
literal|115
block|,
literal|279
block|,
literal|252
block|,
literal|250
block|,
literal|256
block|,
literal|263
block|,
literal|278
block|,
literal|266
block|,
literal|268
block|,
literal|272
block|,
literal|284
block|,
literal|271
block|,
literal|289
block|,
literal|279
block|,
literal|296
block|,
literal|0
block|,
literal|0
block|,
literal|292
block|,
literal|298
block|,
literal|288
block|,
literal|293
block|,
literal|292
block|,
literal|296
block|,
literal|305
block|,
literal|301
block|,
literal|307
block|,
literal|312
block|,
literal|0
block|,
literal|0
block|,
literal|288
block|,
literal|342
block|,
literal|347
block|,
literal|305
block|,
literal|0
block|,
literal|307
block|,
literal|310
block|,
literal|315
block|,
literal|320
block|,
literal|313
block|,
literal|0
block|,
literal|323
block|,
literal|335
block|,
literal|346
block|,
literal|336
block|,
literal|351
block|,
literal|348
block|,
literal|346
block|,
literal|357
block|,
literal|349
block|,
literal|364
block|,
literal|357
block|,
literal|367
block|,
literal|366
block|,
literal|356
block|,
literal|0
block|,
literal|0
block|,
literal|371
block|,
literal|359
block|,
literal|371
block|,
literal|373
block|,
literal|381
block|,
literal|379
block|,
literal|367
block|,
literal|0
block|,
literal|372
block|,
literal|394
block|,
literal|380
block|,
literal|383
block|,
literal|390
block|,
literal|0
block|,
literal|402
block|,
literal|390
block|,
literal|394
block|,
literal|113
block|,
literal|408
block|,
literal|0
block|,
literal|399
block|,
literal|411
block|,
literal|396
block|,
literal|413
block|,
literal|409
block|,
literal|417
block|,
literal|410
block|,
literal|413
block|,
literal|414
block|,
literal|413
block|,
literal|407
block|,
literal|409
block|,
literal|421
block|,
literal|424
block|,
literal|423
block|,
literal|427
block|,
literal|424
block|,
literal|0
block|,
literal|0
block|,
literal|432
block|,
literal|0
block|,
literal|434
block|,
literal|448
block|,
literal|445
block|,
literal|440
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|454
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|110
block|,
literal|446
block|,
literal|450
block|,
literal|462
block|,
literal|453
block|,
literal|468
block|,
literal|469
block|,
literal|467
block|,
literal|472
block|,
literal|473
block|,
literal|108
block|,
literal|457
block|,
literal|461
block|,
literal|477
block|,
literal|63
block|,
literal|0
block|,
literal|472
block|,
literal|485
block|,
literal|483
block|,
literal|476
block|,
literal|491
block|,
literal|474
block|,
literal|482
block|,
literal|483
block|,
literal|485
block|,
literal|487
block|,
literal|61
block|,
literal|497
block|,
literal|0
block|,
literal|0
block|,
literal|485
block|,
literal|500
block|,
literal|500
block|,
literal|498
block|,
literal|500
block|,
literal|518
block|,
literal|508
block|,
literal|507
block|,
literal|508
block|,
literal|516
block|,
literal|0
block|,
literal|520
block|,
literal|525
block|,
literal|528
block|,
literal|519
block|,
literal|529
block|,
literal|538
block|,
literal|537
block|,
literal|538
block|,
literal|526
block|,
literal|540
block|,
literal|0
block|,
literal|0
block|,
literal|539
block|,
literal|534
block|,
literal|546
block|,
literal|539
block|,
literal|534
block|,
literal|0
block|,
literal|535
block|,
literal|547
block|,
literal|556
block|,
literal|566
block|,
literal|558
block|,
literal|548
block|,
literal|556
block|,
literal|575
block|,
literal|0
block|,
literal|53
block|,
literal|565
block|,
literal|563
block|,
literal|564
block|,
literal|0
block|,
literal|578
block|,
literal|578
block|,
literal|587
block|,
literal|0
block|,
literal|0
block|,
literal|573
block|,
literal|581
block|,
literal|574
block|,
literal|0
block|,
literal|0
block|,
literal|580
block|,
literal|583
block|,
literal|581
block|,
literal|0
block|,
literal|595
block|,
literal|586
block|,
literal|598
block|,
literal|595
block|,
literal|0
block|,
literal|586
block|,
literal|0
block|,
literal|594
block|,
literal|594
block|,
literal|596
block|,
literal|602
block|,
literal|599
block|,
literal|0
block|,
literal|0
block|,
literal|49
block|,
literal|612
block|,
literal|604
block|,
literal|610
block|,
literal|0
block|,
literal|695
block|,
literal|674
block|,
literal|679
block|,
literal|682
block|,
literal|684
block|,
literal|689
block|,
literal|90
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yy_def
specifier|static
name|yyconst
name|flex_int16_t
name|yy_def
index|[
literal|342
index|]
init|=
block|{
literal|0
block|,
literal|335
block|,
literal|1
block|,
literal|336
block|,
literal|336
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|337
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|338
block|,
literal|335
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|337
block|,
literal|340
block|,
literal|335
block|,
literal|335
block|,
literal|341
block|,
literal|338
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|340
block|,
literal|335
block|,
literal|341
block|,
literal|335
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|335
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|335
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|339
block|,
literal|0
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yy_nxt
specifier|static
name|yyconst
name|flex_int16_t
name|yy_nxt
index|[
literal|771
index|]
init|=
block|{
literal|0
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|6
block|,
literal|25
block|,
literal|26
block|,
literal|26
block|,
literal|27
block|,
literal|26
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|26
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|26
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|26
block|,
literal|40
block|,
literal|26
block|,
literal|41
block|,
literal|26
block|,
literal|42
block|,
literal|6
block|,
literal|43
block|,
literal|26
block|,
literal|25
block|,
literal|26
block|,
literal|26
block|,
literal|27
block|,
literal|26
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|26
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|26
block|,
literal|40
block|,
literal|26
block|,
literal|41
block|,
literal|26
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|48
block|,
literal|48
block|,
literal|49
block|,
literal|49
block|,
literal|51
block|,
literal|51
block|,
literal|51
block|,
literal|51
block|,
literal|54
block|,
literal|62
block|,
literal|55
block|,
literal|55
block|,
literal|55
block|,
literal|54
block|,
literal|59
block|,
literal|55
block|,
literal|55
block|,
literal|55
block|,
literal|93
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|331
block|,
literal|60
block|,
literal|66
block|,
literal|67
block|,
literal|308
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|61
block|,
literal|72
block|,
literal|73
block|,
literal|271
block|,
literal|80
block|,
literal|260
block|,
literal|62
block|,
literal|81
block|,
literal|56
block|,
literal|51
block|,
literal|51
block|,
literal|59
block|,
literal|74
block|,
literal|50
block|,
literal|50
block|,
literal|63
block|,
literal|64
block|,
literal|78
block|,
literal|65
block|,
literal|60
block|,
literal|66
block|,
literal|99
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|61
block|,
literal|75
block|,
literal|72
block|,
literal|73
block|,
literal|76
block|,
literal|80
block|,
literal|95
block|,
literal|81
block|,
literal|56
block|,
literal|79
block|,
literal|101
block|,
literal|77
block|,
literal|74
block|,
literal|92
block|,
literal|92
block|,
literal|92
block|,
literal|100
block|,
literal|54
block|,
literal|78
block|,
literal|55
block|,
literal|55
block|,
literal|55
block|,
literal|99
block|,
literal|256
block|,
literal|96
block|,
literal|245
block|,
literal|102
block|,
literal|103
block|,
literal|220
block|,
literal|75
block|,
literal|151
block|,
literal|97
block|,
literal|76
block|,
literal|95
block|,
literal|98
block|,
literal|108
block|,
literal|79
block|,
literal|101
block|,
literal|77
block|,
literal|82
block|,
literal|82
block|,
literal|83
block|,
literal|107
block|,
literal|109
block|,
literal|100
block|,
literal|94
block|,
literal|110
block|,
literal|84
block|,
literal|111
block|,
literal|115
block|,
literal|85
block|,
literal|86
block|,
literal|96
block|,
literal|102
block|,
literal|112
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|97
block|,
literal|87
block|,
literal|113
block|,
literal|98
block|,
literal|88
block|,
literal|108
block|,
literal|89
block|,
literal|114
block|,
literal|90
block|,
literal|116
block|,
literal|121
block|,
literal|107
block|,
literal|117
block|,
literal|109
block|,
literal|106
block|,
literal|110
block|,
literal|118
block|,
literal|84
block|,
literal|111
block|,
literal|115
block|,
literal|85
block|,
literal|86
block|,
literal|119
block|,
literal|112
block|,
literal|120
block|,
literal|53
block|,
literal|104
block|,
literal|105
block|,
literal|87
block|,
literal|113
block|,
literal|123
block|,
literal|88
block|,
literal|124
block|,
literal|89
block|,
literal|114
block|,
literal|90
block|,
literal|125
block|,
literal|116
block|,
literal|121
block|,
literal|117
block|,
literal|126
block|,
literal|106
block|,
literal|127
block|,
literal|118
block|,
literal|122
block|,
literal|122
block|,
literal|83
block|,
literal|128
block|,
literal|129
block|,
literal|119
block|,
literal|130
block|,
literal|120
block|,
literal|83
block|,
literal|83
block|,
literal|83
block|,
literal|92
block|,
literal|92
block|,
literal|92
block|,
literal|123
block|,
literal|131
block|,
literal|124
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|125
block|,
literal|135
block|,
literal|137
block|,
literal|136
block|,
literal|126
block|,
literal|127
block|,
literal|138
block|,
literal|335
block|,
literal|141
block|,
literal|142
block|,
literal|139
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|335
block|,
literal|148
block|,
literal|149
block|,
literal|155
block|,
literal|131
block|,
literal|132
block|,
literal|140
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|137
block|,
literal|136
block|,
literal|150
block|,
literal|153
block|,
literal|154
block|,
literal|138
block|,
literal|141
block|,
literal|142
block|,
literal|139
block|,
literal|152
block|,
literal|152
block|,
literal|83
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|156
block|,
literal|147
block|,
literal|148
block|,
literal|157
block|,
literal|149
block|,
literal|155
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|335
block|,
literal|162
block|,
literal|163
block|,
literal|150
block|,
literal|153
block|,
literal|154
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|335
block|,
literal|168
block|,
literal|169
block|,
literal|335
block|,
literal|170
block|,
literal|172
block|,
literal|173
block|,
literal|156
block|,
literal|177
block|,
literal|171
block|,
literal|174
block|,
literal|157
block|,
literal|175
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|176
block|,
literal|161
block|,
literal|162
block|,
literal|184
block|,
literal|163
block|,
literal|185
block|,
literal|189
block|,
literal|164
block|,
literal|186
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|168
block|,
literal|187
block|,
literal|169
block|,
literal|170
block|,
literal|188
block|,
literal|172
block|,
literal|173
block|,
literal|177
block|,
literal|171
block|,
literal|190
block|,
literal|174
block|,
literal|191
block|,
literal|175
block|,
literal|83
block|,
literal|83
block|,
literal|83
block|,
literal|176
block|,
literal|178
block|,
literal|184
block|,
literal|192
block|,
literal|185
block|,
literal|179
block|,
literal|189
block|,
literal|186
block|,
literal|193
block|,
literal|180
block|,
literal|181
block|,
literal|194
block|,
literal|187
block|,
literal|195
block|,
literal|197
block|,
literal|188
block|,
literal|182
block|,
literal|183
block|,
literal|196
block|,
literal|198
block|,
literal|190
block|,
literal|199
block|,
literal|200
block|,
literal|191
block|,
literal|201
block|,
literal|202
block|,
literal|335
block|,
literal|203
block|,
literal|204
block|,
literal|178
block|,
literal|205
block|,
literal|192
block|,
literal|206
block|,
literal|179
block|,
literal|207
block|,
literal|193
block|,
literal|180
block|,
literal|181
block|,
literal|208
block|,
literal|194
block|,
literal|209
block|,
literal|195
block|,
literal|197
block|,
literal|182
block|,
literal|183
block|,
literal|196
block|,
literal|198
block|,
literal|211
block|,
literal|212
block|,
literal|199
block|,
literal|200
block|,
literal|213
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|214
block|,
literal|204
block|,
literal|205
block|,
literal|215
block|,
literal|210
block|,
literal|206
block|,
literal|216
block|,
literal|207
block|,
literal|217
block|,
literal|335
block|,
literal|218
block|,
literal|208
block|,
literal|219
block|,
literal|209
block|,
literal|221
block|,
literal|335
block|,
literal|222
block|,
literal|223
block|,
literal|225
block|,
literal|211
block|,
literal|212
block|,
literal|224
block|,
literal|226
block|,
literal|227
block|,
literal|213
block|,
literal|228
block|,
literal|229
block|,
literal|214
block|,
literal|230
block|,
literal|231
block|,
literal|215
block|,
literal|210
block|,
literal|232
block|,
literal|216
block|,
literal|233
block|,
literal|234
block|,
literal|217
block|,
literal|218
block|,
literal|235
block|,
literal|219
block|,
literal|236
block|,
literal|237
block|,
literal|221
block|,
literal|222
block|,
literal|238
block|,
literal|223
block|,
literal|225
block|,
literal|239
block|,
literal|224
block|,
literal|226
block|,
literal|240
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|241
block|,
literal|230
block|,
literal|231
block|,
literal|242
block|,
literal|243
block|,
literal|232
block|,
literal|244
block|,
literal|233
block|,
literal|234
block|,
literal|246
block|,
literal|247
block|,
literal|235
block|,
literal|248
block|,
literal|236
block|,
literal|237
block|,
literal|250
block|,
literal|251
block|,
literal|238
block|,
literal|252
block|,
literal|253
block|,
literal|239
block|,
literal|257
block|,
literal|249
block|,
literal|240
block|,
literal|254
block|,
literal|255
block|,
literal|335
block|,
literal|258
block|,
literal|241
block|,
literal|259
block|,
literal|242
block|,
literal|243
block|,
literal|261
block|,
literal|262
block|,
literal|244
block|,
literal|263
block|,
literal|246
block|,
literal|247
block|,
literal|264
block|,
literal|265
block|,
literal|248
block|,
literal|266
block|,
literal|250
block|,
literal|267
block|,
literal|251
block|,
literal|268
block|,
literal|252
block|,
literal|253
block|,
literal|257
block|,
literal|249
block|,
literal|269
block|,
literal|270
block|,
literal|254
block|,
literal|255
block|,
literal|258
block|,
literal|272
block|,
literal|273
block|,
literal|259
block|,
literal|274
block|,
literal|261
block|,
literal|275
block|,
literal|262
block|,
literal|276
block|,
literal|263
block|,
literal|277
block|,
literal|264
block|,
literal|278
block|,
literal|265
block|,
literal|266
block|,
literal|279
block|,
literal|267
block|,
literal|280
block|,
literal|268
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|284
block|,
literal|269
block|,
literal|270
block|,
literal|285
block|,
literal|286
block|,
literal|288
block|,
literal|272
block|,
literal|273
block|,
literal|287
block|,
literal|274
block|,
literal|289
block|,
literal|275
block|,
literal|290
block|,
literal|276
block|,
literal|293
block|,
literal|277
block|,
literal|294
block|,
literal|278
block|,
literal|291
block|,
literal|295
block|,
literal|297
block|,
literal|279
block|,
literal|280
block|,
literal|296
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|298
block|,
literal|284
block|,
literal|299
block|,
literal|300
block|,
literal|285
block|,
literal|286
block|,
literal|288
block|,
literal|301
block|,
literal|287
block|,
literal|302
block|,
literal|292
block|,
literal|289
block|,
literal|303
block|,
literal|290
block|,
literal|293
block|,
literal|304
block|,
literal|305
block|,
literal|294
block|,
literal|306
block|,
literal|291
block|,
literal|295
block|,
literal|297
block|,
literal|307
block|,
literal|296
block|,
literal|309
block|,
literal|310
block|,
literal|311
block|,
literal|298
block|,
literal|312
block|,
literal|299
block|,
literal|300
block|,
literal|313
block|,
literal|314
block|,
literal|318
block|,
literal|301
block|,
literal|315
block|,
literal|316
block|,
literal|302
block|,
literal|317
block|,
literal|319
block|,
literal|303
block|,
literal|320
block|,
literal|304
block|,
literal|305
block|,
literal|321
block|,
literal|306
block|,
literal|322
block|,
literal|323
block|,
literal|324
block|,
literal|333
block|,
literal|307
block|,
literal|309
block|,
literal|310
block|,
literal|311
block|,
literal|325
block|,
literal|326
block|,
literal|312
block|,
literal|327
block|,
literal|328
block|,
literal|313
block|,
literal|314
block|,
literal|318
block|,
literal|315
block|,
literal|316
block|,
literal|329
block|,
literal|317
block|,
literal|319
block|,
literal|330
block|,
literal|320
block|,
literal|332
block|,
literal|334
block|,
literal|335
block|,
literal|321
block|,
literal|322
block|,
literal|335
block|,
literal|323
block|,
literal|324
block|,
literal|333
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|325
block|,
literal|326
block|,
literal|335
block|,
literal|327
block|,
literal|328
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|329
block|,
literal|335
block|,
literal|335
block|,
literal|330
block|,
literal|335
block|,
literal|332
block|,
literal|334
block|,
literal|47
block|,
literal|47
block|,
literal|47
block|,
literal|47
block|,
literal|47
block|,
literal|52
block|,
literal|335
block|,
literal|52
block|,
literal|52
block|,
literal|52
block|,
literal|57
block|,
literal|57
block|,
literal|57
block|,
literal|58
block|,
literal|58
block|,
literal|91
block|,
literal|335
block|,
literal|91
block|,
literal|91
block|,
literal|91
block|,
literal|5
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|yy_chk
specifier|static
name|yyconst
name|flex_int16_t
name|yy_chk
index|[
literal|771
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|20
block|,
literal|27
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|25
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|341
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|330
block|,
literal|25
block|,
literal|31
block|,
literal|32
block|,
literal|297
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|35
block|,
literal|25
block|,
literal|36
block|,
literal|37
block|,
literal|255
block|,
literal|40
block|,
literal|243
block|,
literal|27
block|,
literal|41
block|,
literal|20
block|,
literal|51
block|,
literal|51
block|,
literal|25
block|,
literal|37
block|,
literal|3
block|,
literal|4
block|,
literal|28
block|,
literal|29
block|,
literal|39
block|,
literal|30
block|,
literal|25
block|,
literal|31
block|,
literal|61
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|35
block|,
literal|25
block|,
literal|38
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|40
block|,
literal|59
block|,
literal|41
block|,
literal|20
block|,
literal|39
block|,
literal|63
block|,
literal|38
block|,
literal|37
block|,
literal|54
block|,
literal|54
block|,
literal|54
block|,
literal|62
block|,
literal|55
block|,
literal|39
block|,
literal|55
block|,
literal|55
block|,
literal|55
block|,
literal|61
block|,
literal|239
block|,
literal|60
block|,
literal|229
block|,
literal|64
block|,
literal|65
block|,
literal|194
block|,
literal|38
block|,
literal|121
block|,
literal|60
block|,
literal|38
block|,
literal|59
block|,
literal|60
block|,
literal|68
block|,
literal|39
block|,
literal|63
block|,
literal|38
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|67
block|,
literal|69
block|,
literal|62
block|,
literal|57
block|,
literal|70
block|,
literal|50
block|,
literal|71
block|,
literal|75
block|,
literal|50
block|,
literal|50
block|,
literal|60
block|,
literal|64
block|,
literal|72
block|,
literal|65
block|,
literal|66
block|,
literal|66
block|,
literal|60
block|,
literal|50
block|,
literal|73
block|,
literal|60
block|,
literal|50
block|,
literal|68
block|,
literal|50
block|,
literal|74
block|,
literal|50
block|,
literal|76
block|,
literal|81
block|,
literal|67
block|,
literal|77
block|,
literal|69
block|,
literal|66
block|,
literal|70
block|,
literal|78
block|,
literal|50
block|,
literal|71
block|,
literal|75
block|,
literal|50
block|,
literal|50
block|,
literal|79
block|,
literal|72
block|,
literal|80
block|,
literal|19
block|,
literal|66
block|,
literal|66
block|,
literal|50
block|,
literal|73
block|,
literal|95
block|,
literal|50
block|,
literal|96
block|,
literal|50
block|,
literal|74
block|,
literal|50
block|,
literal|97
block|,
literal|76
block|,
literal|81
block|,
literal|77
block|,
literal|98
block|,
literal|66
block|,
literal|99
block|,
literal|78
block|,
literal|82
block|,
literal|82
block|,
literal|82
block|,
literal|100
block|,
literal|101
block|,
literal|79
block|,
literal|102
block|,
literal|80
block|,
literal|83
block|,
literal|83
block|,
literal|83
block|,
literal|92
block|,
literal|92
block|,
literal|92
block|,
literal|95
block|,
literal|103
block|,
literal|96
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|97
block|,
literal|107
block|,
literal|108
block|,
literal|107
block|,
literal|98
block|,
literal|99
block|,
literal|109
block|,
literal|5
block|,
literal|110
block|,
literal|111
block|,
literal|109
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|112
block|,
literal|113
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|0
block|,
literal|118
block|,
literal|119
block|,
literal|125
block|,
literal|103
block|,
literal|104
block|,
literal|109
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|107
block|,
literal|120
block|,
literal|123
block|,
literal|124
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|109
block|,
literal|122
block|,
literal|122
block|,
literal|122
block|,
literal|112
block|,
literal|113
block|,
literal|115
block|,
literal|116
block|,
literal|126
block|,
literal|117
block|,
literal|118
block|,
literal|127
block|,
literal|119
block|,
literal|125
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|0
block|,
literal|132
block|,
literal|133
block|,
literal|120
block|,
literal|123
block|,
literal|124
block|,
literal|134
block|,
literal|135
block|,
literal|138
block|,
literal|139
block|,
literal|0
block|,
literal|140
block|,
literal|141
block|,
literal|0
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|126
block|,
literal|150
block|,
literal|142
block|,
literal|145
block|,
literal|127
block|,
literal|146
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|147
block|,
literal|131
block|,
literal|132
block|,
literal|153
block|,
literal|133
block|,
literal|155
block|,
literal|159
block|,
literal|134
block|,
literal|156
block|,
literal|135
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|157
block|,
literal|141
block|,
literal|142
block|,
literal|158
block|,
literal|143
block|,
literal|144
block|,
literal|150
block|,
literal|142
block|,
literal|161
block|,
literal|145
block|,
literal|162
block|,
literal|146
block|,
literal|152
block|,
literal|152
block|,
literal|152
block|,
literal|147
block|,
literal|151
block|,
literal|153
block|,
literal|163
block|,
literal|155
block|,
literal|151
block|,
literal|159
block|,
literal|156
block|,
literal|164
block|,
literal|151
block|,
literal|151
block|,
literal|165
block|,
literal|157
block|,
literal|166
block|,
literal|168
block|,
literal|158
block|,
literal|151
block|,
literal|151
block|,
literal|167
block|,
literal|169
block|,
literal|161
block|,
literal|170
block|,
literal|171
block|,
literal|162
block|,
literal|172
block|,
literal|173
block|,
literal|0
block|,
literal|174
block|,
literal|177
block|,
literal|151
block|,
literal|178
block|,
literal|163
block|,
literal|179
block|,
literal|151
block|,
literal|180
block|,
literal|164
block|,
literal|151
block|,
literal|151
block|,
literal|181
block|,
literal|165
block|,
literal|182
block|,
literal|166
block|,
literal|168
block|,
literal|151
block|,
literal|151
block|,
literal|167
block|,
literal|169
block|,
literal|183
block|,
literal|185
block|,
literal|170
block|,
literal|171
block|,
literal|186
block|,
literal|172
block|,
literal|173
block|,
literal|174
block|,
literal|187
block|,
literal|177
block|,
literal|178
block|,
literal|188
block|,
literal|182
block|,
literal|179
block|,
literal|189
block|,
literal|180
block|,
literal|191
block|,
literal|0
block|,
literal|192
block|,
literal|181
block|,
literal|193
block|,
literal|182
block|,
literal|195
block|,
literal|0
block|,
literal|197
block|,
literal|198
block|,
literal|200
block|,
literal|183
block|,
literal|185
block|,
literal|199
block|,
literal|201
block|,
literal|202
block|,
literal|186
block|,
literal|203
block|,
literal|204
block|,
literal|187
block|,
literal|205
block|,
literal|206
block|,
literal|188
block|,
literal|182
block|,
literal|207
block|,
literal|189
block|,
literal|208
block|,
literal|209
block|,
literal|191
block|,
literal|192
block|,
literal|210
block|,
literal|193
block|,
literal|211
block|,
literal|212
block|,
literal|195
block|,
literal|197
block|,
literal|213
block|,
literal|198
block|,
literal|200
block|,
literal|216
block|,
literal|199
block|,
literal|201
block|,
literal|218
block|,
literal|202
block|,
literal|203
block|,
literal|204
block|,
literal|219
block|,
literal|205
block|,
literal|206
block|,
literal|220
block|,
literal|221
block|,
literal|207
block|,
literal|225
block|,
literal|208
block|,
literal|209
block|,
literal|230
block|,
literal|231
block|,
literal|210
block|,
literal|232
block|,
literal|211
block|,
literal|212
block|,
literal|233
block|,
literal|234
block|,
literal|213
block|,
literal|235
block|,
literal|236
block|,
literal|216
block|,
literal|240
block|,
literal|232
block|,
literal|218
block|,
literal|237
block|,
literal|238
block|,
literal|0
block|,
literal|241
block|,
literal|219
block|,
literal|242
block|,
literal|220
block|,
literal|221
block|,
literal|245
block|,
literal|246
block|,
literal|225
block|,
literal|247
block|,
literal|230
block|,
literal|231
block|,
literal|248
block|,
literal|249
block|,
literal|232
block|,
literal|250
block|,
literal|233
block|,
literal|251
block|,
literal|234
block|,
literal|252
block|,
literal|235
block|,
literal|236
block|,
literal|240
block|,
literal|232
block|,
literal|253
block|,
literal|254
block|,
literal|237
block|,
literal|238
block|,
literal|241
block|,
literal|256
block|,
literal|259
block|,
literal|242
block|,
literal|260
block|,
literal|245
block|,
literal|260
block|,
literal|246
block|,
literal|261
block|,
literal|247
block|,
literal|262
block|,
literal|248
block|,
literal|263
block|,
literal|249
block|,
literal|250
block|,
literal|264
block|,
literal|251
block|,
literal|265
block|,
literal|252
block|,
literal|266
block|,
literal|267
block|,
literal|268
block|,
literal|270
block|,
literal|253
block|,
literal|254
block|,
literal|271
block|,
literal|272
block|,
literal|274
block|,
literal|256
block|,
literal|259
block|,
literal|273
block|,
literal|260
block|,
literal|275
block|,
literal|260
block|,
literal|276
block|,
literal|261
block|,
literal|278
block|,
literal|262
block|,
literal|279
block|,
literal|263
block|,
literal|277
block|,
literal|282
block|,
literal|284
block|,
literal|264
block|,
literal|265
block|,
literal|283
block|,
literal|266
block|,
literal|267
block|,
literal|268
block|,
literal|285
block|,
literal|270
block|,
literal|286
block|,
literal|288
block|,
literal|271
block|,
literal|272
block|,
literal|274
block|,
literal|289
block|,
literal|273
block|,
literal|290
block|,
literal|277
block|,
literal|275
block|,
literal|291
block|,
literal|276
block|,
literal|278
block|,
literal|292
block|,
literal|293
block|,
literal|279
block|,
literal|294
block|,
literal|277
block|,
literal|282
block|,
literal|284
block|,
literal|295
block|,
literal|283
block|,
literal|298
block|,
literal|299
block|,
literal|300
block|,
literal|285
block|,
literal|302
block|,
literal|286
block|,
literal|288
block|,
literal|303
block|,
literal|304
block|,
literal|312
block|,
literal|289
block|,
literal|307
block|,
literal|308
block|,
literal|290
block|,
literal|309
block|,
literal|313
block|,
literal|291
block|,
literal|314
block|,
literal|292
block|,
literal|293
block|,
literal|316
block|,
literal|294
block|,
literal|317
block|,
literal|318
block|,
literal|319
block|,
literal|332
block|,
literal|295
block|,
literal|298
block|,
literal|299
block|,
literal|300
block|,
literal|321
block|,
literal|323
block|,
literal|302
block|,
literal|324
block|,
literal|325
block|,
literal|303
block|,
literal|304
block|,
literal|312
block|,
literal|307
block|,
literal|308
block|,
literal|326
block|,
literal|309
block|,
literal|313
block|,
literal|327
block|,
literal|314
block|,
literal|331
block|,
literal|333
block|,
literal|0
block|,
literal|316
block|,
literal|317
block|,
literal|0
block|,
literal|318
block|,
literal|319
block|,
literal|332
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|321
block|,
literal|323
block|,
literal|0
block|,
literal|324
block|,
literal|325
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|326
block|,
literal|0
block|,
literal|0
block|,
literal|327
block|,
literal|0
block|,
literal|331
block|,
literal|333
block|,
literal|336
block|,
literal|336
block|,
literal|336
block|,
literal|336
block|,
literal|336
block|,
literal|337
block|,
literal|0
block|,
literal|337
block|,
literal|337
block|,
literal|337
block|,
literal|338
block|,
literal|338
block|,
literal|338
block|,
literal|339
block|,
literal|339
block|,
literal|340
block|,
literal|0
block|,
literal|340
block|,
literal|340
block|,
literal|340
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|,
literal|335
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Table of booleans, true if rule could match eol. */
end_comment
begin_decl_stmt
DECL|variable|yy_rule_can_match_eol
specifier|static
name|yyconst
name|flex_int32_t
name|yy_rule_can_match_eol
index|[
literal|84
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,     }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* The intent behind this definition is that it'll catch  * any uses of REJECT which flex missed.  */
end_comment
begin_define
DECL|macro|REJECT
define|#
directive|define
name|REJECT
value|reject_used_but_not_detected
end_define
begin_define
DECL|macro|yymore
define|#
directive|define
name|yymore
parameter_list|()
value|yymore_used_but_not_detected
end_define
begin_define
DECL|macro|YY_MORE_ADJ
define|#
directive|define
name|YY_MORE_ADJ
value|0
end_define
begin_define
DECL|macro|YY_RESTORE_YY_MORE_OFFSET
define|#
directive|define
name|YY_RESTORE_YY_MORE_OFFSET
end_define
begin_line
line|#
directive|line
number|1
file|"scanner.l"
end_line
begin_comment
comment|/************************************************************  Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.   Permission to use, copy, modify, and distribute this  software and its documentation for any purpose and without  fee is hereby granted, provided that the above copyright  notice appear in all copies and that both that copyright  notice and this permission notice appear in supporting  documentation, and that the name of Silicon Graphics not be  used in advertising or publicity pertaining to distribution  of the software without specific prior written permission.  Silicon Graphics makes no representation about the suitability  of this software for any purpose. It is provided "as is"  without any express or implied warranty.   SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  THE USE OR PERFORMANCE OF THIS SOFTWARE.   ********************************************************/
end_comment
begin_line
line|#
directive|line
number|28
file|"scanner.l"
end_line
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"parser-priv.h"
end_include
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|ignored
literal|"-Wmissing-noreturn"
end_pragma
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|ignored
literal|"-Wredundant-decls"
end_pragma
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|push
end_pragma
begin_struct
DECL|struct|scanner_extra
struct|struct
name|scanner_extra
block|{
DECL|member|ctx
name|struct
name|xkb_context
modifier|*
name|ctx
decl_stmt|;
DECL|member|file_name
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
DECL|member|scanBuf
name|char
name|scanBuf
index|[
literal|1024
index|]
decl_stmt|;
DECL|member|s
name|char
modifier|*
name|s
decl_stmt|;
block|}
struct|;
end_struct
begin_function_decl
specifier|static
name|void
name|scanner_error_extra
parameter_list|(
name|struct
name|YYLTYPE
modifier|*
name|loc
parameter_list|,
name|struct
name|scanner_extra
modifier|*
name|extra
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|YY_USER_ACTION
define|#
directive|define
name|YY_USER_ACTION
value|{                \         yylloc->first_line = yylineno;  \         yylloc->last_line = yylineno;   \ }
end_define
begin_define
DECL|macro|APPEND_S
define|#
directive|define
name|APPEND_S
parameter_list|(
name|ch
parameter_list|)
value|do {                                               \     if (yyextra->s - yyextra->scanBuf>= sizeof(yyextra->scanBuf) - 1)  \         return ERROR_TOK;                                               \     *yyextra->s++ = ch;                                                 \ } while (0)
end_define
begin_define
DECL|macro|YY_NO_UNISTD_H
define|#
directive|define
name|YY_NO_UNISTD_H
value|1
end_define
begin_define
DECL|macro|YY_NO_INPUT
define|#
directive|define
name|YY_NO_INPUT
value|1
end_define
begin_line
line|#
directive|line
number|803
file|"src/xkbcomp/scanner.c"
end_line
begin_define
DECL|macro|INITIAL
define|#
directive|define
name|INITIAL
value|0
end_define
begin_define
DECL|macro|S_STR
define|#
directive|define
name|S_STR
value|1
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|YY_NO_UNISTD_H
end_ifndef
begin_comment
comment|/* Special case for "unistd.h", since it is non-ANSI. We include it way  * down here because we want the user's section 1 to have been scanned first.  * The user has a chance to override it with an option.  */
end_comment
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|YY_EXTRA_TYPE
define|#
directive|define
name|YY_EXTRA_TYPE
value|struct scanner_extra *
end_define
begin_comment
comment|/* Holds the entire state of the reentrant scanner. */
end_comment
begin_struct
DECL|struct|yyguts_t
struct|struct
name|yyguts_t
block|{
comment|/* User-defined. Not touched by flex. */
DECL|member|yyextra_r
name|YY_EXTRA_TYPE
name|yyextra_r
decl_stmt|;
comment|/* The rest are the same as the globals declared in the non-reentrant scanner. */
DECL|member|yyin_r
DECL|member|yyout_r
name|FILE
modifier|*
name|yyin_r
decl_stmt|,
modifier|*
name|yyout_r
decl_stmt|;
DECL|member|yy_buffer_stack_top
name|size_t
name|yy_buffer_stack_top
decl_stmt|;
comment|/**< index of top of stack. */
DECL|member|yy_buffer_stack_max
name|size_t
name|yy_buffer_stack_max
decl_stmt|;
comment|/**< capacity of stack. */
DECL|member|yy_buffer_stack
name|YY_BUFFER_STATE
modifier|*
name|yy_buffer_stack
decl_stmt|;
comment|/**< Stack as an array. */
DECL|member|yy_hold_char
name|char
name|yy_hold_char
decl_stmt|;
DECL|member|yy_n_chars
name|int
name|yy_n_chars
decl_stmt|;
DECL|member|yyleng_r
name|int
name|yyleng_r
decl_stmt|;
DECL|member|yy_c_buf_p
name|char
modifier|*
name|yy_c_buf_p
decl_stmt|;
DECL|member|yy_init
name|int
name|yy_init
decl_stmt|;
DECL|member|yy_start
name|int
name|yy_start
decl_stmt|;
DECL|member|yy_did_buffer_switch_on_eof
name|int
name|yy_did_buffer_switch_on_eof
decl_stmt|;
DECL|member|yy_start_stack_ptr
name|int
name|yy_start_stack_ptr
decl_stmt|;
DECL|member|yy_start_stack_depth
name|int
name|yy_start_stack_depth
decl_stmt|;
DECL|member|yy_start_stack
name|int
modifier|*
name|yy_start_stack
decl_stmt|;
DECL|member|yy_last_accepting_state
name|yy_state_type
name|yy_last_accepting_state
decl_stmt|;
DECL|member|yy_last_accepting_cpos
name|char
modifier|*
name|yy_last_accepting_cpos
decl_stmt|;
DECL|member|yylineno_r
name|int
name|yylineno_r
decl_stmt|;
DECL|member|yy_flex_debug_r
name|int
name|yy_flex_debug_r
decl_stmt|;
DECL|member|yytext_r
name|char
modifier|*
name|yytext_r
decl_stmt|;
DECL|member|yy_more_flag
name|int
name|yy_more_flag
decl_stmt|;
DECL|member|yy_more_len
name|int
name|yy_more_len
decl_stmt|;
DECL|member|yylval_r
name|YYSTYPE
modifier|*
name|yylval_r
decl_stmt|;
DECL|member|yylloc_r
name|YYLTYPE
modifier|*
name|yylloc_r
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* end struct yyguts_t */
end_comment
begin_function_decl
specifier|static
name|int
name|yy_init_globals
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* This must go here because YYSTYPE and YYLTYPE are included      * from bison output in section 1.*/
end_comment
begin_define
DECL|macro|yylval
define|#
directive|define
name|yylval
value|yyg->yylval_r
end_define
begin_define
DECL|macro|yylloc
define|#
directive|define
name|yylloc
value|yyg->yylloc_r
end_define
begin_function_decl
name|int
name|_xkbcommon_lex_init
parameter_list|(
name|yyscan_t
modifier|*
name|scanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|_xkbcommon_lex_init_extra
parameter_list|(
name|YY_EXTRA_TYPE
name|user_defined
parameter_list|,
name|yyscan_t
modifier|*
name|scanner
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Accessor methods to globals.    These are made visible to non-reentrant scanners for convenience. */
end_comment
begin_function_decl
name|int
name|_xkbcommon_lex_destroy
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|_xkbcommon_get_debug
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_set_debug
parameter_list|(
name|int
name|debug_flag
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|YY_EXTRA_TYPE
name|_xkbcommon_get_extra
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_set_extra
parameter_list|(
name|YY_EXTRA_TYPE
name|user_defined
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|FILE
modifier|*
name|_xkbcommon_get_in
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_set_in
parameter_list|(
name|FILE
modifier|*
name|in_str
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|FILE
modifier|*
name|_xkbcommon_get_out
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_set_out
parameter_list|(
name|FILE
modifier|*
name|out_str
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|_xkbcommon_get_leng
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|char
modifier|*
name|_xkbcommon_get_text
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|_xkbcommon_get_lineno
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_set_lineno
parameter_list|(
name|int
name|line_number
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|YYSTYPE
modifier|*
name|_xkbcommon_get_lval
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_set_lval
parameter_list|(
name|YYSTYPE
modifier|*
name|yylval_param
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|YYLTYPE
modifier|*
name|_xkbcommon_get_lloc
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_xkbcommon_set_lloc
parameter_list|(
name|YYLTYPE
modifier|*
name|yylloc_param
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Macros after this point can all be overridden by user definitions in  * section 1.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_SKIP_YYWRAP
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
name|int
name|_xkbcommon_wrap
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_extern
begin_else
else|#
directive|else
end_else
begin_function_decl
specifier|extern
name|int
name|_xkbcommon_wrap
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|yytext_ptr
end_ifndef
begin_function_decl
specifier|static
name|void
name|yy_flex_strncpy
parameter_list|(
name|char
modifier|*
parameter_list|,
name|yyconst
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|YY_NEED_STRLEN
end_ifdef
begin_function_decl
specifier|static
name|int
name|yy_flex_strlen
parameter_list|(
name|yyconst
name|char
modifier|*
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|YY_NO_INPUT
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_function_decl
specifier|static
name|int
name|yyinput
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_else
else|#
directive|else
end_else
begin_function_decl
specifier|static
name|int
name|input
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Amount of stuff to slurp up with each read. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_READ_BUF_SIZE
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef
begin_comment
comment|/* On IA-64, the buffer size is 16k, not 8k */
end_comment
begin_define
DECL|macro|YY_READ_BUF_SIZE
define|#
directive|define
name|YY_READ_BUF_SIZE
value|16384
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|YY_READ_BUF_SIZE
define|#
directive|define
name|YY_READ_BUF_SIZE
value|8192
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __ia64__ */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Copy whatever the last rule matched to the standard output. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ECHO
end_ifndef
begin_comment
comment|/* This used to be an fputs(), but since the string might contain NUL's,  * we now use fwrite().  */
end_comment
begin_define
DECL|macro|ECHO
define|#
directive|define
name|ECHO
value|do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,  * is returned in "result".  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_INPUT
end_ifndef
begin_define
DECL|macro|YY_INPUT
define|#
directive|define
name|YY_INPUT
parameter_list|(
name|buf
parameter_list|,
name|result
parameter_list|,
name|max_size
parameter_list|)
define|\
value|if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \ 		{ \ 		int c = '*'; \ 		size_t n; \ 		for ( n = 0; n< max_size&& \ 			     (c = getc( yyin )) != EOF&& c != '\n'; ++n ) \ 			buf[n] = (char) c; \ 		if ( c == '\n' ) \ 			buf[n++] = (char) c; \ 		if ( c == EOF&& ferror( yyin ) ) \ 			YY_FATAL_ERROR( "input in flex scanner failed" ); \ 		result = n; \ 		} \ 	else \ 		{ \ 		errno=0; \ 		while ( (result = fread(buf, 1, max_size, yyin))==0&& ferror(yyin)) \ 			{ \ 			if( errno != EINTR) \ 				{ \ 				YY_FATAL_ERROR( "input in flex scanner failed" ); \ 				break; \ 				} \ 			errno=0; \ 			clearerr(yyin); \ 			} \ 		}\ \  #endif
end_define
begin_comment
comment|/* No semi-colon after return; correct usage is to write "yyterminate();" -  * we don't want an extra ';' after the "return" because that will cause  * some compilers to complain about unreachable statements.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|yyterminate
end_ifndef
begin_define
DECL|macro|yyterminate
define|#
directive|define
name|yyterminate
parameter_list|()
value|return YY_NULL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Number of entries by which start-condition stack grows. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_START_STACK_INCR
end_ifndef
begin_define
DECL|macro|YY_START_STACK_INCR
define|#
directive|define
name|YY_START_STACK_INCR
value|25
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Report a fatal error. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_FATAL_ERROR
end_ifndef
begin_define
DECL|macro|YY_FATAL_ERROR
define|#
directive|define
name|YY_FATAL_ERROR
parameter_list|(
name|msg
parameter_list|)
value|yy_fatal_error( msg , yyscanner)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* end tables serialization structures and prototypes */
end_comment
begin_comment
comment|/* Default declaration of generated scanner - a define so the user can  * easily add parameters.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_DECL
end_ifndef
begin_define
DECL|macro|YY_DECL_IS_OURS
define|#
directive|define
name|YY_DECL_IS_OURS
value|1
end_define
begin_function_decl
specifier|extern
name|int
name|_xkbcommon_lex
function_decl|\
parameter_list|(
name|YYSTYPE
modifier|*
name|yylval_param
parameter_list|,
name|YYLTYPE
modifier|*
name|yylloc_param
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|YY_DECL
define|#
directive|define
name|YY_DECL
value|int _xkbcommon_lex \                (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !YY_DECL */
end_comment
begin_comment
comment|/* Code executed at the beginning of each rule, after yytext and yyleng  * have been set up.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_USER_ACTION
end_ifndef
begin_define
DECL|macro|YY_USER_ACTION
define|#
directive|define
name|YY_USER_ACTION
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Code executed at the end of each rule. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|YY_BREAK
end_ifndef
begin_define
DECL|macro|YY_BREAK
define|#
directive|define
name|YY_BREAK
value|break;
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|YY_RULE_SETUP
define|#
directive|define
name|YY_RULE_SETUP
define|\
value|YY_USER_ACTION
end_define
begin_comment
comment|/** The main scanner function which does all the work.  */
end_comment
begin_macro
name|YY_DECL
end_macro
begin_block
block|{
specifier|register
name|yy_state_type
name|yy_current_state
decl_stmt|;
specifier|register
name|char
modifier|*
name|yy_cp
decl_stmt|,
modifier|*
name|yy_bp
decl_stmt|;
specifier|register
name|int
name|yy_act
decl_stmt|;
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
line|#
directive|line
number|69
file|"scanner.l"
line|#
directive|line
number|1049
file|"src/xkbcomp/scanner.c"
name|yylval
operator|=
name|yylval_param
expr_stmt|;
name|yylloc
operator|=
name|yylloc_param
expr_stmt|;
if|if
condition|(
operator|!
name|yyg
operator|->
name|yy_init
condition|)
block|{
name|yyg
operator|->
name|yy_init
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|YY_USER_INIT
name|YY_USER_INIT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|yyg
operator|->
name|yy_start
condition|)
name|yyg
operator|->
name|yy_start
operator|=
literal|1
expr_stmt|;
comment|/* first start state */
if|if
condition|(
operator|!
name|yyin
condition|)
name|yyin
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|yyout
condition|)
name|yyout
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
block|{
name|_xkbcommon_ensure_buffer_stack
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|_xkbcommon__create_buffer
argument_list|(
name|yyin
argument_list|,
name|YY_BUF_SIZE
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
block|}
name|_xkbcommon__load_buffer_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
comment|/* loops until end-of-file is reached */
block|{
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
comment|/* Support of yytext. */
operator|*
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_hold_char
expr_stmt|;
comment|/* yy_bp points to the position in yy_ch_buf of the start of 		 * the current run. 		 */
name|yy_bp
operator|=
name|yy_cp
expr_stmt|;
name|yy_current_state
operator|=
name|yyg
operator|->
name|yy_start
expr_stmt|;
name|yy_match
label|:
do|do
block|{
specifier|register
name|YY_CHAR
name|yy_c
init|=
name|yy_ec
index|[
name|YY_SC_TO_UI
argument_list|(
operator|*
name|yy_cp
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|yy_accept
index|[
name|yy_current_state
index|]
condition|)
block|{
name|yyg
operator|->
name|yy_last_accepting_state
operator|=
name|yy_current_state
expr_stmt|;
name|yyg
operator|->
name|yy_last_accepting_cpos
operator|=
name|yy_cp
expr_stmt|;
block|}
while|while
condition|(
name|yy_chk
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
name|yy_c
index|]
operator|!=
name|yy_current_state
condition|)
block|{
name|yy_current_state
operator|=
operator|(
name|int
operator|)
name|yy_def
index|[
name|yy_current_state
index|]
expr_stmt|;
if|if
condition|(
name|yy_current_state
operator|>=
literal|336
condition|)
name|yy_c
operator|=
name|yy_meta
index|[
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
name|yy_current_state
operator|=
name|yy_nxt
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
operator|++
name|yy_cp
expr_stmt|;
block|}
do|while
condition|(
name|yy_current_state
operator|!=
literal|335
condition|)
do|;
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_last_accepting_cpos
expr_stmt|;
name|yy_current_state
operator|=
name|yyg
operator|->
name|yy_last_accepting_state
expr_stmt|;
name|yy_find_action
label|:
name|yy_act
operator|=
name|yy_accept
index|[
name|yy_current_state
index|]
expr_stmt|;
name|YY_DO_BEFORE_ACTION
expr_stmt|;
if|if
condition|(
name|yy_act
operator|!=
name|YY_END_OF_BUFFER
operator|&&
name|yy_rule_can_match_eol
index|[
name|yy_act
index|]
condition|)
block|{
name|int
name|yyl
decl_stmt|;
for|for
control|(
name|yyl
operator|=
literal|0
init|;
name|yyl
operator|<
name|yyleng
condition|;
operator|++
name|yyl
control|)
if|if
condition|(
name|yytext
index|[
name|yyl
index|]
operator|==
literal|'\n'
condition|)
do|do
block|{
name|yylineno
operator|++
expr_stmt|;
name|yycolumn
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
block|}
name|do_action
label|:
comment|/* This label is used only to access EOF actions. */
switch|switch
condition|(
name|yy_act
condition|)
block|{
comment|/* beginning of action switch */
case|case
literal|0
case|:
comment|/* must back up */
comment|/* undo the effects of YY_DO_BEFORE_ACTION */
operator|*
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_hold_char
expr_stmt|;
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_last_accepting_cpos
expr_stmt|;
name|yy_current_state
operator|=
name|yyg
operator|->
name|yy_last_accepting_state
expr_stmt|;
goto|goto
name|yy_find_action
goto|;
case|case
literal|1
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|71
file|"scanner.l"
name|YY_BREAK
case|case
literal|2
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|72
file|"scanner.l"
name|YY_BREAK
case|case
literal|3
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|74
file|"scanner.l"
name|yyextra
operator|->
name|s
init|=
name|yyextra
operator|->
name|scanBuf
decl_stmt|;
name|BEGIN
argument_list|(
name|S_STR
argument_list|)
expr_stmt|;
name|YY_BREAK
case|case
literal|4
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|76
file|"scanner.l"
block|{
name|BEGIN
argument_list|(
name|INITIAL
argument_list|)
expr_stmt|;
operator|*
name|yyextra
operator|->
name|s
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|->
name|str
operator|=
name|strdup
argument_list|(
name|yyextra
operator|->
name|scanBuf
argument_list|)
expr_stmt|;
return|return
name|STRING
return|;
block|}
name|YY_BREAK
case|case
literal|5
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|83
file|"scanner.l"
block|{
comment|/* octal escape sequence */
name|unsigned
name|int
name|result
decl_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|yytext
operator|+
literal|1
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0xff
condition|)
block|{
name|scanner_error_extra
argument_list|(
name|yylloc
argument_list|,
name|yyextra
argument_list|,
literal|"Illegal octal escape"
argument_list|)
expr_stmt|;
return|return
name|ERROR_TOK
return|;
block|}
name|APPEND_S
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|YY_BREAK
case|case
literal|6
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|98
file|"scanner.l"
block|{
name|scanner_error_extra
argument_list|(
name|yylloc
argument_list|,
name|yyextra
argument_list|,
literal|"Illegal octal escape"
argument_list|)
expr_stmt|;
return|return
name|ERROR_TOK
return|;
block|}
name|YY_BREAK
case|case
literal|7
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|104
file|"scanner.l"
name|APPEND_S
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
name|YY_BREAK
case|case
literal|8
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|105
file|"scanner.l"
name|APPEND_S
argument_list|(
literal|'\t'
argument_list|)
decl_stmt|;
name|YY_BREAK
case|case
literal|9
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|106
file|"scanner.l"
name|APPEND_S
argument_list|(
literal|'\r'
argument_list|)
decl_stmt|;
name|YY_BREAK
case|case
literal|10
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|107
file|"scanner.l"
name|APPEND_S
argument_list|(
literal|'\b'
argument_list|)
decl_stmt|;
name|YY_BREAK
case|case
literal|11
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|108
file|"scanner.l"
name|APPEND_S
argument_list|(
literal|'\f'
argument_list|)
decl_stmt|;
name|YY_BREAK
case|case
literal|12
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|109
file|"scanner.l"
name|APPEND_S
argument_list|(
literal|'\v'
argument_list|)
decl_stmt|;
name|YY_BREAK
case|case
literal|13
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|110
file|"scanner.l"
name|APPEND_S
argument_list|(
literal|'\033'
argument_list|)
decl_stmt|;
name|YY_BREAK
case|case
literal|14
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|112
file|"scanner.l"
name|APPEND_S
parameter_list|(
name|yytext
index|[
literal|0
index|]
parameter_list|)
function_decl|;
name|YY_BREAK
case|case
literal|15
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|114
file|"scanner.l"
block|{
comment|/* We don't want the brackets. */
name|yytext
index|[
name|yyleng
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yytext
operator|++
expr_stmt|;
name|yylval
operator|->
name|sval
operator|=
name|xkb_atom_intern
argument_list|(
name|yyextra
operator|->
name|ctx
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
return|return
name|KEYNAME
return|;
block|}
name|YY_BREAK
case|case
literal|16
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|122
file|"scanner.l"
return|return
name|XKB_KEYMAP
return|;
name|YY_BREAK
case|case
literal|17
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|123
file|"scanner.l"
return|return
name|XKB_KEYCODES
return|;
name|YY_BREAK
case|case
literal|18
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|124
file|"scanner.l"
return|return
name|XKB_TYPES
return|;
name|YY_BREAK
case|case
literal|19
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|125
file|"scanner.l"
return|return
name|XKB_SYMBOLS
return|;
name|YY_BREAK
case|case
literal|20
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|126
file|"scanner.l"
return|return
name|XKB_COMPATMAP
return|;
name|YY_BREAK
case|case
literal|21
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|127
file|"scanner.l"
return|return
name|XKB_COMPATMAP
return|;
name|YY_BREAK
case|case
literal|22
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|128
file|"scanner.l"
return|return
name|XKB_COMPATMAP
return|;
name|YY_BREAK
case|case
literal|23
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|129
file|"scanner.l"
return|return
name|XKB_COMPATMAP
return|;
name|YY_BREAK
case|case
literal|24
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|130
file|"scanner.l"
return|return
name|XKB_GEOMETRY
return|;
name|YY_BREAK
case|case
literal|25
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|131
file|"scanner.l"
return|return
name|XKB_SEMANTICS
return|;
name|YY_BREAK
case|case
literal|26
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|132
file|"scanner.l"
return|return
name|XKB_LAYOUT
return|;
name|YY_BREAK
case|case
literal|27
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|133
file|"scanner.l"
return|return
name|INCLUDE
return|;
name|YY_BREAK
case|case
literal|28
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|134
file|"scanner.l"
return|return
name|OVERRIDE
return|;
name|YY_BREAK
case|case
literal|29
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|135
file|"scanner.l"
return|return
name|AUGMENT
return|;
name|YY_BREAK
case|case
literal|30
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|136
file|"scanner.l"
return|return
name|REPLACE
return|;
name|YY_BREAK
case|case
literal|31
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|137
file|"scanner.l"
return|return
name|ALTERNATE
return|;
name|YY_BREAK
case|case
literal|32
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|138
file|"scanner.l"
return|return
name|PARTIAL
return|;
name|YY_BREAK
case|case
literal|33
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|139
file|"scanner.l"
return|return
name|DEFAULT
return|;
name|YY_BREAK
case|case
literal|34
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|140
file|"scanner.l"
return|return
name|HIDDEN
return|;
name|YY_BREAK
case|case
literal|35
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|141
file|"scanner.l"
return|return
name|VIRTUAL_MODS
return|;
name|YY_BREAK
case|case
literal|36
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|142
file|"scanner.l"
return|return
name|TYPE
return|;
name|YY_BREAK
case|case
literal|37
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|143
file|"scanner.l"
return|return
name|INTERPRET
return|;
name|YY_BREAK
case|case
literal|38
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|144
file|"scanner.l"
return|return
name|ACTION_TOK
return|;
name|YY_BREAK
case|case
literal|39
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|145
file|"scanner.l"
return|return
name|KEY
return|;
name|YY_BREAK
case|case
literal|40
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|146
file|"scanner.l"
return|return
name|ALIAS
return|;
name|YY_BREAK
case|case
literal|41
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|147
file|"scanner.l"
return|return
name|GROUP
return|;
name|YY_BREAK
case|case
literal|42
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|148
file|"scanner.l"
return|return
name|MODIFIER_MAP
return|;
name|YY_BREAK
case|case
literal|43
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|149
file|"scanner.l"
return|return
name|MODIFIER_MAP
return|;
name|YY_BREAK
case|case
literal|44
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|150
file|"scanner.l"
return|return
name|MODIFIER_MAP
return|;
name|YY_BREAK
case|case
literal|45
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|151
file|"scanner.l"
return|return
name|INDICATOR
return|;
name|YY_BREAK
case|case
literal|46
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|152
file|"scanner.l"
return|return
name|SHAPE
return|;
name|YY_BREAK
case|case
literal|47
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|153
file|"scanner.l"
return|return
name|ROW
return|;
name|YY_BREAK
case|case
literal|48
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|154
file|"scanner.l"
return|return
name|KEYS
return|;
name|YY_BREAK
case|case
literal|49
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|155
file|"scanner.l"
return|return
name|SECTION
return|;
name|YY_BREAK
case|case
literal|50
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|156
file|"scanner.l"
return|return
name|OVERLAY
return|;
name|YY_BREAK
case|case
literal|51
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|157
file|"scanner.l"
return|return
name|TEXT
return|;
name|YY_BREAK
case|case
literal|52
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|158
file|"scanner.l"
return|return
name|OUTLINE
return|;
name|YY_BREAK
case|case
literal|53
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|159
file|"scanner.l"
return|return
name|SOLID
return|;
name|YY_BREAK
case|case
literal|54
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|160
file|"scanner.l"
return|return
name|LOGO
return|;
name|YY_BREAK
case|case
literal|55
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|161
file|"scanner.l"
return|return
name|VIRTUAL
return|;
name|YY_BREAK
case|case
literal|56
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|162
file|"scanner.l"
return|return
name|ALPHANUMERIC_KEYS
return|;
name|YY_BREAK
case|case
literal|57
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|163
file|"scanner.l"
return|return
name|MODIFIER_KEYS
return|;
name|YY_BREAK
case|case
literal|58
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|164
file|"scanner.l"
return|return
name|KEYPAD_KEYS
return|;
name|YY_BREAK
case|case
literal|59
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|165
file|"scanner.l"
return|return
name|FUNCTION_KEYS
return|;
name|YY_BREAK
case|case
literal|60
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|166
file|"scanner.l"
return|return
name|ALTERNATE_GROUP
return|;
name|YY_BREAK
case|case
literal|61
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|168
file|"scanner.l"
name|yylval
operator|->
name|str
init|=
name|strdup
argument_list|(
name|yytext
argument_list|)
decl_stmt|;
return|return
name|IDENT
return|;
name|YY_BREAK
case|case
literal|62
case|:
line|#
directive|line
number|171
file|"scanner.l"
case|case
literal|63
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|171
file|"scanner.l"
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|yylval
operator|->
name|num
operator|=
name|strtoul
argument_list|(
name|yytext
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|INTEGER
return|;
block|}
name|YY_BREAK
case|case
literal|64
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|177
file|"scanner.l"
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|yylval
operator|->
name|num
operator|=
name|strtod
argument_list|(
name|yytext
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
return|return
name|FLOAT
return|;
block|}
name|YY_BREAK
case|case
literal|65
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|184
file|"scanner.l"
return|return
name|EQUALS
return|;
name|YY_BREAK
case|case
literal|66
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|185
file|"scanner.l"
return|return
name|PLUS
return|;
name|YY_BREAK
case|case
literal|67
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|186
file|"scanner.l"
return|return
name|MINUS
return|;
name|YY_BREAK
case|case
literal|68
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|187
file|"scanner.l"
return|return
name|DIVIDE
return|;
name|YY_BREAK
case|case
literal|69
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|188
file|"scanner.l"
return|return
name|TIMES
return|;
name|YY_BREAK
case|case
literal|70
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|189
file|"scanner.l"
return|return
name|OBRACE
return|;
name|YY_BREAK
case|case
literal|71
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|190
file|"scanner.l"
return|return
name|CBRACE
return|;
name|YY_BREAK
case|case
literal|72
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|191
file|"scanner.l"
return|return
name|OPAREN
return|;
name|YY_BREAK
case|case
literal|73
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|192
file|"scanner.l"
return|return
name|CPAREN
return|;
name|YY_BREAK
case|case
literal|74
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|193
file|"scanner.l"
return|return
name|OBRACKET
return|;
name|YY_BREAK
case|case
literal|75
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|194
file|"scanner.l"
return|return
name|CBRACKET
return|;
name|YY_BREAK
case|case
literal|76
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|195
file|"scanner.l"
return|return
name|DOT
return|;
name|YY_BREAK
case|case
literal|77
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|196
file|"scanner.l"
return|return
name|COMMA
return|;
name|YY_BREAK
case|case
literal|78
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|197
file|"scanner.l"
return|return
name|SEMI
return|;
name|YY_BREAK
case|case
literal|79
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|198
file|"scanner.l"
return|return
name|EXCLAM
return|;
name|YY_BREAK
case|case
literal|80
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|199
file|"scanner.l"
return|return
name|INVERT
return|;
name|YY_BREAK
case|case
literal|81
case|:
comment|/* rule 81 can match eol */
name|YY_RULE_SETUP
line|#
directive|line
number|201
file|"scanner.l"
name|YY_BREAK
case|case
name|YY_STATE_EOF
argument_list|(
name|INITIAL
argument_list|)
case|:
case|case
name|YY_STATE_EOF
argument_list|(
name|S_STR
argument_list|)
case|:
line|#
directive|line
number|203
file|"scanner.l"
return|return
name|END_OF_FILE
return|;
name|YY_BREAK
case|case
literal|82
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|205
file|"scanner.l"
return|return
name|ERROR_TOK
return|;
name|YY_BREAK
case|case
literal|83
case|:
name|YY_RULE_SETUP
line|#
directive|line
number|207
file|"scanner.l"
name|ECHO
decl_stmt|;
name|YY_BREAK
line|#
directive|line
number|1600
file|"src/xkbcomp/scanner.c"
case|case
name|YY_END_OF_BUFFER
case|:
block|{
comment|/* Amount of text matched not including the EOB char. */
name|int
name|yy_amount_of_matched_text
init|=
call|(
name|int
call|)
argument_list|(
name|yy_cp
operator|-
name|yyg
operator|->
name|yytext_ptr
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Undo the effects of YY_DO_BEFORE_ACTION. */
operator|*
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_hold_char
expr_stmt|;
name|YY_RESTORE_YY_MORE_OFFSET
if|if
condition|(
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|==
name|YY_BUFFER_NEW
condition|)
block|{
comment|/* We're scanning a new file or input source.  It's 			 * possible that this happened because the user 			 * just pointed yyin at a new source and called 			 * _xkbcommon_lex().  If so, then we have to assure 			 * consistency between YY_CURRENT_BUFFER and our 			 * globals.  Here is the right place to do so, because 			 * this is the first action (other than possibly a 			 * back-up) that will match for the new input source. 			 */
name|yyg
operator|->
name|yy_n_chars
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_input_file
operator|=
name|yyin
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_NORMAL
expr_stmt|;
block|}
comment|/* Note that here we test for yy_c_buf_p "<=" to the position 		 * of the first EOB in the buffer, since yy_c_buf_p will 		 * already have been incremented past the NUL character 		 * (since all states make transitions on EOB to the 		 * end-of-buffer state).  Contrast this with the test 		 * in input(). 		 */
if|if
condition|(
name|yyg
operator|->
name|yy_c_buf_p
operator|<=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|yyg
operator|->
name|yy_n_chars
index|]
condition|)
block|{
comment|/* This was really a NUL. */
name|yy_state_type
name|yy_next_state
decl_stmt|;
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|yy_amount_of_matched_text
expr_stmt|;
name|yy_current_state
operator|=
name|yy_get_previous_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
comment|/* Okay, we're now positioned to make the NUL 			 * transition.  We couldn't have 			 * yy_get_previous_state() go ahead and do it 			 * for us because it doesn't know how to deal 			 * with the possibility of jamming (and we don't 			 * want to build jamming into it because then it 			 * will run more slowly). 			 */
name|yy_next_state
operator|=
name|yy_try_NUL_trans
argument_list|(
name|yy_current_state
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|yy_bp
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|YY_MORE_ADJ
expr_stmt|;
if|if
condition|(
name|yy_next_state
condition|)
block|{
comment|/* Consume the NUL. */
name|yy_cp
operator|=
operator|++
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
name|yy_current_state
operator|=
name|yy_next_state
expr_stmt|;
goto|goto
name|yy_match
goto|;
block|}
else|else
block|{
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_last_accepting_cpos
expr_stmt|;
name|yy_current_state
operator|=
name|yyg
operator|->
name|yy_last_accepting_state
expr_stmt|;
goto|goto
name|yy_find_action
goto|;
block|}
block|}
else|else
switch|switch
condition|(
name|yy_get_next_buffer
argument_list|(
name|yyscanner
argument_list|)
condition|)
block|{
case|case
name|EOB_ACT_END_OF_FILE
case|:
block|{
name|yyg
operator|->
name|yy_did_buffer_switch_on_eof
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_xkbcommon_wrap
argument_list|(
name|yyscanner
argument_list|)
condition|)
block|{
comment|/* Note: because we've taken care in 					 * yy_get_next_buffer() to have set up 					 * yytext, we can now set up 					 * yy_c_buf_p so that if some total 					 * hoser (like flex itself) wants to 					 * call the scanner after we return the 					 * YY_NULL, it'll still work - another 					 * YY_NULL will get returned. 					 */
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|YY_MORE_ADJ
expr_stmt|;
name|yy_act
operator|=
name|YY_STATE_EOF
argument_list|(
name|YY_START
argument_list|)
expr_stmt|;
goto|goto
name|do_action
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|yyg
operator|->
name|yy_did_buffer_switch_on_eof
condition|)
name|YY_NEW_FILE
expr_stmt|;
block|}
break|break;
block|}
case|case
name|EOB_ACT_CONTINUE_SCAN
case|:
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|yy_amount_of_matched_text
expr_stmt|;
name|yy_current_state
operator|=
name|yy_get_previous_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
name|yy_bp
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|YY_MORE_ADJ
expr_stmt|;
goto|goto
name|yy_match
goto|;
case|case
name|EOB_ACT_LAST_MATCH
case|:
name|yyg
operator|->
name|yy_c_buf_p
operator|=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|yyg
operator|->
name|yy_n_chars
index|]
expr_stmt|;
name|yy_current_state
operator|=
name|yy_get_previous_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
name|yy_cp
operator|=
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
name|yy_bp
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|YY_MORE_ADJ
expr_stmt|;
goto|goto
name|yy_find_action
goto|;
block|}
break|break;
block|}
default|default:
name|YY_FATAL_ERROR
argument_list|(
literal|"fatal flex scanner internal error--no action found"
argument_list|)
expr_stmt|;
block|}
comment|/* end of action switch */
block|}
comment|/* end of scanning one token */
block|}
end_block
begin_comment
comment|/* end of _xkbcommon_lex */
end_comment
begin_comment
comment|/* yy_get_next_buffer - try to read in a new buffer  *  * Returns a code representing an action:  *	EOB_ACT_LAST_MATCH -  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position  *	EOB_ACT_END_OF_FILE - end of file  */
end_comment
begin_function
DECL|function|yy_get_next_buffer
specifier|static
name|int
name|yy_get_next_buffer
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
init|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|source
init|=
name|yyg
operator|->
name|yytext_ptr
decl_stmt|;
specifier|register
name|int
name|number_to_move
decl_stmt|,
name|i
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
if|if
condition|(
name|yyg
operator|->
name|yy_c_buf_p
operator|>
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|yyg
operator|->
name|yy_n_chars
operator|+
literal|1
index|]
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"fatal flex scanner internal error--end of buffer missed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_fill_buffer
operator|==
literal|0
condition|)
block|{
comment|/* Don't try to fill the buffer, so this is an EOF. */
if|if
condition|(
name|yyg
operator|->
name|yy_c_buf_p
operator|-
name|yyg
operator|->
name|yytext_ptr
operator|-
name|YY_MORE_ADJ
operator|==
literal|1
condition|)
block|{
comment|/* We matched a single character, the EOB, so 			 * treat this as a final EOF. 			 */
return|return
name|EOB_ACT_END_OF_FILE
return|;
block|}
else|else
block|{
comment|/* We matched some text prior to the EOB, first 			 * process it. 			 */
return|return
name|EOB_ACT_LAST_MATCH
return|;
block|}
block|}
comment|/* Try to read more data. */
comment|/* First move last chars to start of buffer. */
name|number_to_move
operator|=
call|(
name|int
call|)
argument_list|(
name|yyg
operator|->
name|yy_c_buf_p
operator|-
name|yyg
operator|->
name|yytext_ptr
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_to_move
condition|;
operator|++
name|i
control|)
operator|*
operator|(
name|dest
operator|++
operator|)
operator|=
operator|*
operator|(
name|source
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|==
name|YY_BUFFER_EOF_PENDING
condition|)
comment|/* don't do the read, it's not guaranteed to return an EOF, 		 * just force an EOF 		 */
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
name|yyg
operator|->
name|yy_n_chars
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|num_to_read
init|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_size
operator|-
name|number_to_move
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|num_to_read
operator|<=
literal|0
condition|)
block|{
comment|/* Not enough room in the buffer - grow it. */
comment|/* just a shorter name for the current buffer */
name|YY_BUFFER_STATE
name|b
init|=
name|YY_CURRENT_BUFFER
decl_stmt|;
name|int
name|yy_c_buf_p_offset
init|=
call|(
name|int
call|)
argument_list|(
name|yyg
operator|->
name|yy_c_buf_p
operator|-
name|b
operator|->
name|yy_ch_buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|yy_is_our_buffer
condition|)
block|{
name|int
name|new_size
init|=
name|b
operator|->
name|yy_buf_size
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|new_size
operator|<=
literal|0
condition|)
name|b
operator|->
name|yy_buf_size
operator|+=
name|b
operator|->
name|yy_buf_size
operator|/
literal|8
expr_stmt|;
else|else
name|b
operator|->
name|yy_buf_size
operator|*=
literal|2
expr_stmt|;
name|b
operator|->
name|yy_ch_buf
operator|=
operator|(
name|char
operator|*
operator|)
comment|/* Include room in for 2 EOB chars. */
name|_xkbcommon_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|b
operator|->
name|yy_ch_buf
argument_list|,
name|b
operator|->
name|yy_buf_size
operator|+
literal|2
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Can't grow it, we don't own it. */
name|b
operator|->
name|yy_ch_buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|yy_ch_buf
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"fatal error - scanner input buffer overflow"
argument_list|)
expr_stmt|;
name|yyg
operator|->
name|yy_c_buf_p
operator|=
operator|&
name|b
operator|->
name|yy_ch_buf
index|[
name|yy_c_buf_p_offset
index|]
expr_stmt|;
name|num_to_read
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_size
operator|-
name|number_to_move
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|num_to_read
operator|>
name|YY_READ_BUF_SIZE
condition|)
name|num_to_read
operator|=
name|YY_READ_BUF_SIZE
expr_stmt|;
comment|/* Read in more data. */
name|YY_INPUT
argument_list|(
operator|(
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|number_to_move
index|]
operator|)
argument_list|,
name|yyg
operator|->
name|yy_n_chars
argument_list|,
operator|(
name|size_t
operator|)
name|num_to_read
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
name|yyg
operator|->
name|yy_n_chars
expr_stmt|;
block|}
if|if
condition|(
name|yyg
operator|->
name|yy_n_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|number_to_move
operator|==
name|YY_MORE_ADJ
condition|)
block|{
name|ret_val
operator|=
name|EOB_ACT_END_OF_FILE
expr_stmt|;
name|_xkbcommon_restart
argument_list|(
name|yyin
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|EOB_ACT_LAST_MATCH
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_EOF_PENDING
expr_stmt|;
block|}
block|}
else|else
name|ret_val
operator|=
name|EOB_ACT_CONTINUE_SCAN
expr_stmt|;
if|if
condition|(
call|(
name|yy_size_t
call|)
argument_list|(
name|yyg
operator|->
name|yy_n_chars
operator|+
name|number_to_move
argument_list|)
operator|>
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_size
condition|)
block|{
comment|/* Extend the array by 50%, plus the number we really need. */
name|yy_size_t
name|new_size
init|=
name|yyg
operator|->
name|yy_n_chars
operator|+
name|number_to_move
operator|+
operator|(
name|yyg
operator|->
name|yy_n_chars
operator|>>
literal|1
operator|)
decl_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|_xkbcommon_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
argument_list|,
name|new_size
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in yy_get_next_buffer()"
argument_list|)
expr_stmt|;
block|}
name|yyg
operator|->
name|yy_n_chars
operator|+=
name|number_to_move
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|yyg
operator|->
name|yy_n_chars
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|yyg
operator|->
name|yy_n_chars
operator|+
literal|1
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|yyg
operator|->
name|yytext_ptr
operator|=
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
literal|0
index|]
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function
begin_comment
comment|/* yy_get_previous_state - get the state just before the EOB char was reached */
end_comment
begin_function
DECL|function|yy_get_previous_state
specifier|static
name|yy_state_type
name|yy_get_previous_state
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
specifier|register
name|yy_state_type
name|yy_current_state
decl_stmt|;
specifier|register
name|char
modifier|*
name|yy_cp
decl_stmt|;
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yy_current_state
operator|=
name|yyg
operator|->
name|yy_start
expr_stmt|;
for|for
control|(
name|yy_cp
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|YY_MORE_ADJ
init|;
name|yy_cp
operator|<
name|yyg
operator|->
name|yy_c_buf_p
condition|;
operator|++
name|yy_cp
control|)
block|{
specifier|register
name|YY_CHAR
name|yy_c
init|=
operator|(
operator|*
name|yy_cp
condition|?
name|yy_ec
index|[
name|YY_SC_TO_UI
argument_list|(
operator|*
name|yy_cp
argument_list|)
index|]
else|:
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|yy_accept
index|[
name|yy_current_state
index|]
condition|)
block|{
name|yyg
operator|->
name|yy_last_accepting_state
operator|=
name|yy_current_state
expr_stmt|;
name|yyg
operator|->
name|yy_last_accepting_cpos
operator|=
name|yy_cp
expr_stmt|;
block|}
while|while
condition|(
name|yy_chk
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
name|yy_c
index|]
operator|!=
name|yy_current_state
condition|)
block|{
name|yy_current_state
operator|=
operator|(
name|int
operator|)
name|yy_def
index|[
name|yy_current_state
index|]
expr_stmt|;
if|if
condition|(
name|yy_current_state
operator|>=
literal|336
condition|)
name|yy_c
operator|=
name|yy_meta
index|[
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
name|yy_current_state
operator|=
name|yy_nxt
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
return|return
name|yy_current_state
return|;
block|}
end_function
begin_comment
comment|/* yy_try_NUL_trans - try to make a transition on the NUL character  *  * synopsis  *	next_state = yy_try_NUL_trans( current_state );  */
end_comment
begin_function
DECL|function|yy_try_NUL_trans
specifier|static
name|yy_state_type
name|yy_try_NUL_trans
parameter_list|(
name|yy_state_type
name|yy_current_state
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
specifier|register
name|int
name|yy_is_jam
decl_stmt|;
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
comment|/* This var may be unused depending upon options. */
specifier|register
name|char
modifier|*
name|yy_cp
init|=
name|yyg
operator|->
name|yy_c_buf_p
decl_stmt|;
specifier|register
name|YY_CHAR
name|yy_c
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|yy_accept
index|[
name|yy_current_state
index|]
condition|)
block|{
name|yyg
operator|->
name|yy_last_accepting_state
operator|=
name|yy_current_state
expr_stmt|;
name|yyg
operator|->
name|yy_last_accepting_cpos
operator|=
name|yy_cp
expr_stmt|;
block|}
while|while
condition|(
name|yy_chk
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
name|yy_c
index|]
operator|!=
name|yy_current_state
condition|)
block|{
name|yy_current_state
operator|=
operator|(
name|int
operator|)
name|yy_def
index|[
name|yy_current_state
index|]
expr_stmt|;
if|if
condition|(
name|yy_current_state
operator|>=
literal|336
condition|)
name|yy_c
operator|=
name|yy_meta
index|[
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
block|}
name|yy_current_state
operator|=
name|yy_nxt
index|[
name|yy_base
index|[
name|yy_current_state
index|]
operator|+
operator|(
name|unsigned
name|int
operator|)
name|yy_c
index|]
expr_stmt|;
name|yy_is_jam
operator|=
operator|(
name|yy_current_state
operator|==
literal|335
operator|)
expr_stmt|;
return|return
name|yy_is_jam
condition|?
literal|0
else|:
name|yy_current_state
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|YY_NO_INPUT
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_decl_stmt
DECL|function|yyinput
specifier|static
name|int
name|yyinput
argument_list|(
name|yyscan_t
name|yyscanner
argument_list|)
else|#
directive|else
decl|static
name|int
name|input
argument_list|(
name|yyscan_t
name|yyscanner
argument_list|)
endif|#
directive|endif
block|{
name|int
name|c
decl_stmt|;
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
operator|*
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|yyg
operator|->
name|yy_hold_char
expr_stmt|;
if|if
condition|(
operator|*
name|yyg
operator|->
name|yy_c_buf_p
operator|==
name|YY_END_OF_BUFFER_CHAR
condition|)
block|{
comment|/* yy_c_buf_p now points to the character we want to return. 		 * If this occurs *before* the EOB characters, then it's a 		 * valid NUL; if not, then we've hit the end of the buffer. 		 */
if|if
condition|(
name|yyg
operator|->
name|yy_c_buf_p
operator|<
operator|&
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_ch_buf
index|[
name|yyg
operator|->
name|yy_n_chars
index|]
condition|)
comment|/* This was really a NUL. */
operator|*
name|yyg
operator|->
name|yy_c_buf_p
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
comment|/* need more input */
name|int
name|offset
init|=
name|yyg
operator|->
name|yy_c_buf_p
operator|-
name|yyg
operator|->
name|yytext_ptr
decl_stmt|;
operator|++
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
switch|switch
condition|(
name|yy_get_next_buffer
argument_list|(
name|yyscanner
argument_list|)
condition|)
block|{
case|case
name|EOB_ACT_LAST_MATCH
case|:
comment|/* This happens because yy_g_n_b() 					 * sees that we've accumulated a 					 * token and flags that we need to 					 * try matching the token before 					 * proceeding.  But for input(), 					 * there's no matching to consider. 					 * So convert the EOB_ACT_LAST_MATCH 					 * to EOB_ACT_END_OF_FILE. 					 */
comment|/* Reset buffer status. */
name|_xkbcommon_restart
argument_list|(
name|yyin
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|EOB_ACT_END_OF_FILE
case|:
block|{
if|if
condition|(
name|_xkbcommon_wrap
argument_list|(
name|yyscanner
argument_list|)
condition|)
return|return
name|EOF
return|;
if|if
condition|(
operator|!
name|yyg
operator|->
name|yy_did_buffer_switch_on_eof
condition|)
name|YY_NEW_FILE
expr_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
return|return
name|yyinput
argument_list|(
name|yyscanner
argument_list|)
return|;
else|#
directive|else
return|return
name|input
argument_list|(
name|yyscanner
argument_list|)
return|;
endif|#
directive|endif
block|}
case|case
name|EOB_ACT_CONTINUE_SCAN
case|:
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|yyg
operator|->
name|yytext_ptr
operator|+
name|offset
expr_stmt|;
break|break;
block|}
block|}
block|}
name|c
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
comment|/* cast for 8-bit char's */
operator|*
name|yyg
operator|->
name|yy_c_buf_p
operator|=
literal|'\0'
expr_stmt|;
comment|/* preserve yytext */
name|yyg
operator|->
name|yy_hold_char
operator|=
operator|*
operator|++
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
do|do
block|{
name|yylineno
operator|++
expr_stmt|;
name|yycolumn
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|c
return|;
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ifndef YY_NO_INPUT */
end_comment
begin_comment
comment|/** Immediately switch to a different input stream.  * @param input_file A readable stream.  * @param yyscanner The scanner object.  * @note This function does not reset the start condition to @c INITIAL .  */
end_comment
begin_function
DECL|function|_xkbcommon_restart
name|void
name|_xkbcommon_restart
parameter_list|(
name|FILE
modifier|*
name|input_file
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
block|{
name|_xkbcommon_ensure_buffer_stack
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|_xkbcommon__create_buffer
argument_list|(
name|yyin
argument_list|,
name|YY_BUF_SIZE
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
block|}
name|_xkbcommon__init_buffer
argument_list|(
name|YY_CURRENT_BUFFER
argument_list|,
name|input_file
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|_xkbcommon__load_buffer_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Switch to a different input buffer.  * @param new_buffer The new input buffer.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon__switch_to_buffer
name|void
name|_xkbcommon__switch_to_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
comment|/* TODO. We should be able to replace this entire function body 	 * with 	 *		_xkbcommon_pop_buffer_state(); 	 *		_xkbcommon_push_buffer_state(new_buffer);      */
name|_xkbcommon_ensure_buffer_stack
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER
operator|==
name|new_buffer
condition|)
return|return;
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
comment|/* Flush out information for old buffer. */
operator|*
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|yyg
operator|->
name|yy_hold_char
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_pos
operator|=
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
name|yyg
operator|->
name|yy_n_chars
expr_stmt|;
block|}
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|new_buffer
expr_stmt|;
name|_xkbcommon__load_buffer_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
comment|/* We don't actually know whether we did this switch during 	 * EOF (_xkbcommon_wrap()) processing, but the only time this flag 	 * is looked at is after _xkbcommon_wrap() is called, so it's safe 	 * to go ahead and always set it. 	 */
name|yyg
operator|->
name|yy_did_buffer_switch_on_eof
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_xkbcommon__load_buffer_state
specifier|static
name|void
name|_xkbcommon__load_buffer_state
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yyg
operator|->
name|yy_n_chars
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
expr_stmt|;
name|yyg
operator|->
name|yytext_ptr
operator|=
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_pos
expr_stmt|;
name|yyin
operator|=
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_input_file
expr_stmt|;
name|yyg
operator|->
name|yy_hold_char
operator|=
operator|*
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Allocate and initialize an input buffer state.  * @param file A readable stream.  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.  * @param yyscanner The scanner object.  * @return the allocated buffer state.  */
end_comment
begin_function
DECL|function|_xkbcommon__create_buffer
name|YY_BUFFER_STATE
name|_xkbcommon__create_buffer
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|YY_BUFFER_STATE
name|b
decl_stmt|;
name|b
operator|=
operator|(
name|YY_BUFFER_STATE
operator|)
name|_xkbcommon_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
argument_list|)
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in _xkbcommon__create_buffer()"
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_buf_size
operator|=
name|size
expr_stmt|;
comment|/* yy_ch_buf has to be 2 characters longer than the size given because 	 * we need to put in 2 end-of-buffer characters. 	 */
name|b
operator|->
name|yy_ch_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|_xkbcommon_alloc
argument_list|(
name|b
operator|->
name|yy_buf_size
operator|+
literal|2
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|yy_ch_buf
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in _xkbcommon__create_buffer()"
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_is_our_buffer
operator|=
literal|1
expr_stmt|;
name|_xkbcommon__init_buffer
argument_list|(
name|b
argument_list|,
name|file
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/** Destroy the buffer.  * @param b a buffer created with _xkbcommon__create_buffer()  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon__delete_buffer
name|void
name|_xkbcommon__delete_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return;
if|if
condition|(
name|b
operator|==
name|YY_CURRENT_BUFFER
condition|)
comment|/* Not sure if we should pop here. */
name|YY_CURRENT_BUFFER_LVALUE
operator|=
operator|(
name|YY_BUFFER_STATE
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|yy_is_our_buffer
condition|)
name|_xkbcommon_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|b
operator|->
name|yy_ch_buf
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|_xkbcommon_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|b
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Initializes or reinitializes a buffer.  * This function is sometimes called more than once on the same buffer,  * such as during a _xkbcommon_restart() or at EOF.  */
end_comment
begin_function
DECL|function|_xkbcommon__init_buffer
specifier|static
name|void
name|_xkbcommon__init_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|_xkbcommon__flush_buffer
argument_list|(
name|b
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_input_file
operator|=
name|file
expr_stmt|;
name|b
operator|->
name|yy_fill_buffer
operator|=
literal|1
expr_stmt|;
comment|/* If b is the current buffer, then _xkbcommon__init_buffer was _probably_      * called from _xkbcommon_restart() or through yy_get_next_buffer.      * In that case, we don't want to reset the lineno or column.      */
if|if
condition|(
name|b
operator|!=
name|YY_CURRENT_BUFFER
condition|)
block|{
name|b
operator|->
name|yy_bs_lineno
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|yy_bs_column
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|yy_is_interactive
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Discard all buffered characters. On the next scan, YY_INPUT will be called.  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon__flush_buffer
name|void
name|_xkbcommon__flush_buffer
parameter_list|(
name|YY_BUFFER_STATE
name|b
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return;
name|b
operator|->
name|yy_n_chars
operator|=
literal|0
expr_stmt|;
comment|/* We always need two end-of-buffer characters.  The first causes 	 * a transition to the end-of-buffer state.  The second causes 	 * a jam in that state. 	 */
name|b
operator|->
name|yy_ch_buf
index|[
literal|0
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|b
operator|->
name|yy_ch_buf
index|[
literal|1
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|b
operator|->
name|yy_buf_pos
operator|=
operator|&
name|b
operator|->
name|yy_ch_buf
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|->
name|yy_at_bol
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_NEW
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|YY_CURRENT_BUFFER
condition|)
name|_xkbcommon__load_buffer_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Pushes the new state onto the stack. The new state becomes  *  the current state. This function will allocate the stack  *  if necessary.  *  @param new_buffer The new state.  *  @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_push_buffer_state
name|void
name|_xkbcommon_push_buffer_state
parameter_list|(
name|YY_BUFFER_STATE
name|new_buffer
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
name|new_buffer
operator|==
name|NULL
condition|)
return|return;
name|_xkbcommon_ensure_buffer_stack
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
comment|/* This block is copied from _xkbcommon__switch_to_buffer. */
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
comment|/* Flush out information for old buffer. */
operator|*
name|yyg
operator|->
name|yy_c_buf_p
operator|=
name|yyg
operator|->
name|yy_hold_char
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_buf_pos
operator|=
name|yyg
operator|->
name|yy_c_buf_p
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|->
name|yy_n_chars
operator|=
name|yyg
operator|->
name|yy_n_chars
expr_stmt|;
block|}
comment|/* Only push if top exists. Otherwise, replace top. */
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
name|yyg
operator|->
name|yy_buffer_stack_top
operator|++
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|new_buffer
expr_stmt|;
comment|/* copied from _xkbcommon__switch_to_buffer. */
name|_xkbcommon__load_buffer_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
name|yyg
operator|->
name|yy_did_buffer_switch_on_eof
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Removes and deletes the top of the stack, if present.  *  The next element becomes the new top.  *  @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_pop_buffer_state
name|void
name|_xkbcommon_pop_buffer_state
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
return|return;
name|_xkbcommon__delete_buffer
argument_list|(
name|YY_CURRENT_BUFFER
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|yyg
operator|->
name|yy_buffer_stack_top
operator|>
literal|0
condition|)
operator|--
name|yyg
operator|->
name|yy_buffer_stack_top
expr_stmt|;
if|if
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
name|_xkbcommon__load_buffer_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
name|yyg
operator|->
name|yy_did_buffer_switch_on_eof
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Allocates the stack if it does not exist.  *  Guarantees space for at least one push.  */
end_comment
begin_function
DECL|function|_xkbcommon_ensure_buffer_stack
specifier|static
name|void
name|_xkbcommon_ensure_buffer_stack
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|int
name|num_to_alloc
decl_stmt|;
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
operator|!
name|yyg
operator|->
name|yy_buffer_stack
condition|)
block|{
comment|/* First allocation is just for 2 elements, since we don't know if this 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an 		 * immediate realloc on the next call.          */
name|num_to_alloc
operator|=
literal|1
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack
operator|=
operator|(
expr|struct
name|yy_buffer_state
operator|*
operator|*
operator|)
name|_xkbcommon_alloc
argument_list|(
name|num_to_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yyg
operator|->
name|yy_buffer_stack
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in _xkbcommon_ensure_buffer_stack()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|yyg
operator|->
name|yy_buffer_stack
argument_list|,
literal|0
argument_list|,
name|num_to_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack_max
operator|=
name|num_to_alloc
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack_top
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|yyg
operator|->
name|yy_buffer_stack_top
operator|>=
operator|(
name|yyg
operator|->
name|yy_buffer_stack_max
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Increase the buffer to prepare for a possible push. */
name|int
name|grow_size
init|=
literal|8
comment|/* arbitrary grow size */
decl_stmt|;
name|num_to_alloc
operator|=
name|yyg
operator|->
name|yy_buffer_stack_max
operator|+
name|grow_size
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack
operator|=
operator|(
expr|struct
name|yy_buffer_state
operator|*
operator|*
operator|)
name|_xkbcommon_realloc
argument_list|(
name|yyg
operator|->
name|yy_buffer_stack
argument_list|,
name|num_to_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yyg
operator|->
name|yy_buffer_stack
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in _xkbcommon_ensure_buffer_stack()"
argument_list|)
expr_stmt|;
comment|/* zero only the new slots.*/
name|memset
argument_list|(
name|yyg
operator|->
name|yy_buffer_stack
operator|+
name|yyg
operator|->
name|yy_buffer_stack_max
argument_list|,
literal|0
argument_list|,
name|grow_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack_max
operator|=
name|num_to_alloc
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/** Setup the input buffer state to scan directly from a user-specified character buffer.  * @param base the character buffer  * @param size the size in bytes of the character buffer  * @param yyscanner The scanner object.  * @return the newly allocated buffer state object.   */
end_comment
begin_function
DECL|function|_xkbcommon__scan_buffer
name|YY_BUFFER_STATE
name|_xkbcommon__scan_buffer
parameter_list|(
name|char
modifier|*
name|base
parameter_list|,
name|yy_size_t
name|size
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|YY_BUFFER_STATE
name|b
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
operator|||
name|base
index|[
name|size
operator|-
literal|2
index|]
operator|!=
name|YY_END_OF_BUFFER_CHAR
operator|||
name|base
index|[
name|size
operator|-
literal|1
index|]
operator|!=
name|YY_END_OF_BUFFER_CHAR
condition|)
comment|/* They forgot to leave room for the EOB's. */
return|return
literal|0
return|;
name|b
operator|=
operator|(
name|YY_BUFFER_STATE
operator|)
name|_xkbcommon_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|yy_buffer_state
argument_list|)
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in _xkbcommon__scan_buffer()"
argument_list|)
expr_stmt|;
name|b
operator|->
name|yy_buf_size
operator|=
name|size
operator|-
literal|2
expr_stmt|;
comment|/* "- 2" to take care of EOB's */
name|b
operator|->
name|yy_buf_pos
operator|=
name|b
operator|->
name|yy_ch_buf
operator|=
name|base
expr_stmt|;
name|b
operator|->
name|yy_is_our_buffer
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_input_file
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_n_chars
operator|=
name|b
operator|->
name|yy_buf_size
expr_stmt|;
name|b
operator|->
name|yy_is_interactive
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_at_bol
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|yy_fill_buffer
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|yy_buffer_status
operator|=
name|YY_BUFFER_NEW
expr_stmt|;
name|_xkbcommon__switch_to_buffer
argument_list|(
name|b
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/** Setup the input buffer state to scan a string. The next call to _xkbcommon_lex() will  * scan from a @e copy of @a str.  * @param yystr a NUL-terminated string to scan  * @param yyscanner The scanner object.  * @return the newly allocated buffer state object.  * @note If you want to scan bytes that may contain NUL values, then use  *       _xkbcommon__scan_bytes() instead.  */
end_comment
begin_function
DECL|function|_xkbcommon__scan_string
name|YY_BUFFER_STATE
name|_xkbcommon__scan_string
parameter_list|(
name|yyconst
name|char
modifier|*
name|yystr
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
return|return
name|_xkbcommon__scan_bytes
argument_list|(
name|yystr
argument_list|,
name|strlen
argument_list|(
name|yystr
argument_list|)
argument_list|,
name|yyscanner
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/** Setup the input buffer state to scan the given bytes. The next call to _xkbcommon_lex() will  * scan from a @e copy of @a bytes.  * @param yybytes the byte buffer to scan  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.  * @param yyscanner The scanner object.  * @return the newly allocated buffer state object.  */
end_comment
begin_function
DECL|function|_xkbcommon__scan_bytes
name|YY_BUFFER_STATE
name|_xkbcommon__scan_bytes
parameter_list|(
name|yyconst
name|char
modifier|*
name|yybytes
parameter_list|,
name|int
name|_yybytes_len
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|YY_BUFFER_STATE
name|b
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|yy_size_t
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get memory for full buffer, including space for trailing EOB's. */
name|n
operator|=
name|_yybytes_len
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|_xkbcommon_alloc
argument_list|(
name|n
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"out of dynamic memory in _xkbcommon__scan_bytes()"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_yybytes_len
condition|;
operator|++
name|i
control|)
name|buf
index|[
name|i
index|]
operator|=
name|yybytes
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|_yybytes_len
index|]
operator|=
name|buf
index|[
name|_yybytes_len
operator|+
literal|1
index|]
operator|=
name|YY_END_OF_BUFFER_CHAR
expr_stmt|;
name|b
operator|=
name|_xkbcommon__scan_buffer
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|YY_FATAL_ERROR
argument_list|(
literal|"bad buffer in _xkbcommon__scan_bytes()"
argument_list|)
expr_stmt|;
comment|/* It's okay to grow etc. this buffer, and we should throw it 	 * away when we're done. 	 */
name|b
operator|->
name|yy_is_our_buffer
operator|=
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|YY_EXIT_FAILURE
end_ifndef
begin_define
DECL|macro|YY_EXIT_FAILURE
define|#
directive|define
name|YY_EXIT_FAILURE
value|2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|yy_fatal_error
specifier|static
name|void
name|yy_fatal_error
parameter_list|(
name|yyconst
name|char
modifier|*
name|msg
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|YY_EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Redefine yyless() so it works in section 3 code. */
end_comment
begin_undef
DECL|macro|yyless
undef|#
directive|undef
name|yyless
end_undef
begin_define
DECL|macro|yyless
define|#
directive|define
name|yyless
parameter_list|(
name|n
parameter_list|)
define|\
value|do \ 		{ \
comment|/* Undo effects of setting up yytext. */
value|\         int yyless_macro_arg = (n); \         YY_LESS_LINENO(yyless_macro_arg);\ 		yytext[yyleng] = yyg->yy_hold_char; \ 		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \ 		yyg->yy_hold_char = *yyg->yy_c_buf_p; \ 		*yyg->yy_c_buf_p = '\0'; \ 		yyleng = yyless_macro_arg; \ 		} \ 	while ( 0 )
end_define
begin_comment
comment|/* Accessor  methods (get/set functions) to struct members. */
end_comment
begin_comment
comment|/** Get the user-defined data for this scanner.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_get_extra
name|YY_EXTRA_TYPE
name|_xkbcommon_get_extra
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yyextra
return|;
block|}
end_function
begin_comment
comment|/** Get the current line number.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_get_lineno
name|int
name|_xkbcommon_get_lineno
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
return|return
literal|0
return|;
return|return
name|yylineno
return|;
block|}
end_function
begin_comment
comment|/** Get the current column number.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_get_column
name|int
name|_xkbcommon_get_column
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
return|return
literal|0
return|;
return|return
name|yycolumn
return|;
block|}
end_function
begin_comment
comment|/** Get the input stream.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_get_in
name|FILE
modifier|*
name|_xkbcommon_get_in
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yyin
return|;
block|}
end_function
begin_comment
comment|/** Get the output stream.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_get_out
name|FILE
modifier|*
name|_xkbcommon_get_out
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yyout
return|;
block|}
end_function
begin_comment
comment|/** Get the length of the current token.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_get_leng
name|int
name|_xkbcommon_get_leng
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yyleng
return|;
block|}
end_function
begin_comment
comment|/** Get the current token.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_get_text
name|char
modifier|*
name|_xkbcommon_get_text
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yytext
return|;
block|}
end_function
begin_comment
comment|/** Set the user-defined data. This data is never touched by the scanner.  * @param user_defined The data to be associated with this scanner.  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_set_extra
name|void
name|_xkbcommon_set_extra
parameter_list|(
name|YY_EXTRA_TYPE
name|user_defined
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yyextra
operator|=
name|user_defined
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Set the current line number.  * @param line_number  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_set_lineno
name|void
name|_xkbcommon_set_lineno
parameter_list|(
name|int
name|line_number
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
comment|/* lineno is only valid if an input buffer exists. */
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
name|yy_fatal_error
argument_list|(
literal|"_xkbcommon_set_lineno called with no buffer"
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|yylineno
operator|=
name|line_number
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Set the current column.  * @param line_number  * @param yyscanner The scanner object.  */
end_comment
begin_function
DECL|function|_xkbcommon_set_column
name|void
name|_xkbcommon_set_column
parameter_list|(
name|int
name|column_no
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
comment|/* column is only valid if an input buffer exists. */
if|if
condition|(
operator|!
name|YY_CURRENT_BUFFER
condition|)
name|yy_fatal_error
argument_list|(
literal|"_xkbcommon_set_column called with no buffer"
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|yycolumn
operator|=
name|column_no
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Set the input stream. This does not discard the current  * input buffer.  * @param in_str A readable stream.  * @param yyscanner The scanner object.  * @see _xkbcommon__switch_to_buffer  */
end_comment
begin_function
DECL|function|_xkbcommon_set_in
name|void
name|_xkbcommon_set_in
parameter_list|(
name|FILE
modifier|*
name|in_str
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yyin
operator|=
name|in_str
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_set_out
name|void
name|_xkbcommon_set_out
parameter_list|(
name|FILE
modifier|*
name|out_str
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yyout
operator|=
name|out_str
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_get_debug
name|int
name|_xkbcommon_get_debug
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yy_flex_debug
return|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_set_debug
name|void
name|_xkbcommon_set_debug
parameter_list|(
name|int
name|bdebug
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yy_flex_debug
operator|=
name|bdebug
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Accessor methods for yylval and yylloc */
end_comment
begin_function
DECL|function|_xkbcommon_get_lval
name|YYSTYPE
modifier|*
name|_xkbcommon_get_lval
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yylval
return|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_set_lval
name|void
name|_xkbcommon_set_lval
parameter_list|(
name|YYSTYPE
modifier|*
name|yylval_param
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yylval
operator|=
name|yylval_param
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_get_lloc
name|YYLTYPE
modifier|*
name|_xkbcommon_get_lloc
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
return|return
name|yylloc
return|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_set_lloc
name|void
name|_xkbcommon_set_lloc
parameter_list|(
name|YYLTYPE
modifier|*
name|yylloc_param
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
name|yylloc
operator|=
name|yylloc_param
expr_stmt|;
block|}
end_function
begin_comment
comment|/* User-visible API */
end_comment
begin_comment
comment|/* _xkbcommon_lex_init is special because it creates the scanner itself, so it is  * the ONLY reentrant function that doesn't take the scanner as the last argument.  * That's why we explicitly handle the declaration, instead of using our macros.  */
end_comment
begin_function
DECL|function|_xkbcommon_lex_init
name|int
name|_xkbcommon_lex_init
parameter_list|(
name|yyscan_t
modifier|*
name|ptr_yy_globals
parameter_list|)
block|{
if|if
condition|(
name|ptr_yy_globals
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|ptr_yy_globals
operator|=
operator|(
name|yyscan_t
operator|)
name|_xkbcommon_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|yyguts_t
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr_yy_globals
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
name|memset
argument_list|(
operator|*
name|ptr_yy_globals
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yyguts_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|yy_init_globals
argument_list|(
operator|*
name|ptr_yy_globals
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* _xkbcommon_lex_init_extra has the same functionality as _xkbcommon_lex_init, but follows the  * convention of taking the scanner as the last argument. Note however, that  * this is a *pointer* to a scanner, as it will be allocated by this call (and  * is the reason, too, why this function also must handle its own declaration).  * The user defined value in the first argument will be available to _xkbcommon_alloc in  * the yyextra field.  */
end_comment
begin_function
DECL|function|_xkbcommon_lex_init_extra
name|int
name|_xkbcommon_lex_init_extra
parameter_list|(
name|YY_EXTRA_TYPE
name|yy_user_defined
parameter_list|,
name|yyscan_t
modifier|*
name|ptr_yy_globals
parameter_list|)
block|{
name|struct
name|yyguts_t
name|dummy_yyguts
decl_stmt|;
name|_xkbcommon_set_extra
argument_list|(
name|yy_user_defined
argument_list|,
operator|&
name|dummy_yyguts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_yy_globals
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|ptr_yy_globals
operator|=
operator|(
name|yyscan_t
operator|)
name|_xkbcommon_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|yyguts_t
argument_list|)
argument_list|,
operator|&
name|dummy_yyguts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr_yy_globals
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* By setting to 0xAA, we expose bugs in     yy_init_globals. Leave at 0x00 for releases. */
name|memset
argument_list|(
operator|*
name|ptr_yy_globals
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yyguts_t
argument_list|)
argument_list|)
expr_stmt|;
name|_xkbcommon_set_extra
argument_list|(
name|yy_user_defined
argument_list|,
operator|*
name|ptr_yy_globals
argument_list|)
expr_stmt|;
return|return
name|yy_init_globals
argument_list|(
operator|*
name|ptr_yy_globals
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|yy_init_globals
specifier|static
name|int
name|yy_init_globals
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
comment|/* Initialization is the same as for the non-reentrant scanner.      * This function is called from _xkbcommon_lex_destroy(), so don't allocate here.      */
name|yyg
operator|->
name|yy_buffer_stack
operator|=
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack_top
operator|=
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack_max
operator|=
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_c_buf_p
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_init
operator|=
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_start
operator|=
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_start_stack_ptr
operator|=
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_start_stack_depth
operator|=
literal|0
expr_stmt|;
name|yyg
operator|->
name|yy_start_stack
operator|=
name|NULL
expr_stmt|;
comment|/* Defined in main.c */
ifdef|#
directive|ifdef
name|YY_STDINIT
name|yyin
operator|=
name|stdin
expr_stmt|;
name|yyout
operator|=
name|stdout
expr_stmt|;
else|#
directive|else
name|yyin
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
name|yyout
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* For future reference: Set errno on error, since we are called by      * _xkbcommon_lex_init()      */
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* _xkbcommon_lex_destroy is for both reentrant and non-reentrant scanners. */
end_comment
begin_function
DECL|function|_xkbcommon_lex_destroy
name|int
name|_xkbcommon_lex_destroy
parameter_list|(
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|struct
name|yyguts_t
modifier|*
name|yyg
init|=
operator|(
expr|struct
name|yyguts_t
operator|*
operator|)
name|yyscanner
decl_stmt|;
comment|/* Pop the buffer stack, destroying each element. */
while|while
condition|(
name|YY_CURRENT_BUFFER
condition|)
block|{
name|_xkbcommon__delete_buffer
argument_list|(
name|YY_CURRENT_BUFFER
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|YY_CURRENT_BUFFER_LVALUE
operator|=
name|NULL
expr_stmt|;
name|_xkbcommon_pop_buffer_state
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy the stack itself. */
name|_xkbcommon_free
argument_list|(
name|yyg
operator|->
name|yy_buffer_stack
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|yyg
operator|->
name|yy_buffer_stack
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the start condition stack. */
name|_xkbcommon_free
argument_list|(
name|yyg
operator|->
name|yy_start_stack
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|yyg
operator|->
name|yy_start_stack
operator|=
name|NULL
expr_stmt|;
comment|/* Reset the globals. This is important in a non-reentrant scanner so the next time      * _xkbcommon_lex() is called, initialization will occur. */
name|yy_init_globals
argument_list|(
name|yyscanner
argument_list|)
expr_stmt|;
comment|/* Destroy the main struct (reentrant only). */
name|_xkbcommon_free
argument_list|(
name|yyscanner
argument_list|,
name|yyscanner
argument_list|)
expr_stmt|;
name|yyscanner
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Internal utility routines.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|yytext_ptr
end_ifndef
begin_function
DECL|function|yy_flex_strncpy
specifier|static
name|void
name|yy_flex_strncpy
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|yyconst
name|char
modifier|*
name|s2
parameter_list|,
name|int
name|n
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|s1
index|[
name|i
index|]
operator|=
name|s2
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|YY_NEED_STRLEN
end_ifdef
begin_function
DECL|function|yy_flex_strlen
specifier|static
name|int
name|yy_flex_strlen
parameter_list|(
name|yyconst
name|char
modifier|*
name|s
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|s
index|[
name|n
index|]
condition|;
operator|++
name|n
control|)
empty_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|_xkbcommon_alloc
name|void
modifier|*
name|_xkbcommon_alloc
parameter_list|(
name|yy_size_t
name|size
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_realloc
name|void
modifier|*
name|_xkbcommon_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|yy_size_t
name|size
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
comment|/* The cast to (char *) in the following accommodates both 	 * implementations that use char* generic pointers, and those 	 * that use void* generic pointers.  It works with the latter 	 * because both ANSI C and C++ allow castless assignment from 	 * any pointer type to void*, and deal with argument conversions 	 * as though doing an assignment. 	 */
return|return
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_xkbcommon_free
name|void
name|_xkbcommon_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|yyscan_t
name|yyscanner
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
comment|/* see _xkbcommon_realloc() for (char *) cast */
block|}
end_function
begin_define
DECL|macro|YYTABLES_NAME
define|#
directive|define
name|YYTABLES_NAME
value|"yytables"
end_define
begin_line
line|#
directive|line
number|207
file|"scanner.l"
end_line
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|pop
end_pragma
begin_function
specifier|static
name|void
DECL|function|scanner_error_extra
name|scanner_error_extra
parameter_list|(
name|struct
name|YYLTYPE
modifier|*
name|loc
parameter_list|,
name|struct
name|scanner_extra
modifier|*
name|extra
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|log_err
argument_list|(
name|extra
operator|->
name|ctx
argument_list|,
literal|"%s: line %d of %s\n"
argument_list|,
name|msg
argument_list|,
name|loc
operator|->
name|first_line
argument_list|,
name|extra
operator|->
name|file_name
condition|?
name|extra
operator|->
name|file_name
else|:
literal|"(unknown)"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|scanner_error
name|scanner_error
parameter_list|(
name|struct
name|YYLTYPE
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|scanner
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|scanner_extra
modifier|*
name|extra
init|=
name|_xkbcommon_get_extra
argument_list|(
name|scanner
argument_list|)
decl_stmt|;
name|scanner_error_extra
argument_list|(
name|loc
argument_list|,
name|extra
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|init_scanner
name|init_scanner
parameter_list|(
name|yyscan_t
modifier|*
name|scanner
parameter_list|,
name|struct
name|scanner_extra
modifier|*
name|extra
parameter_list|,
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|memset
argument_list|(
name|extra
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|extra
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_xkbcommon_lex_init_extra
argument_list|(
name|extra
argument_list|,
name|scanner
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|extra
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|extra
operator|->
name|file_name
operator|=
name|file_name
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|clear_scanner
name|clear_scanner
parameter_list|(
name|yyscan_t
name|scanner
parameter_list|)
block|{
name|_xkbcommon_lex_destroy
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|XkbFile
modifier|*
DECL|function|XkbParseString
name|XkbParseString
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|yyscan_t
name|scanner
decl_stmt|;
name|struct
name|scanner_extra
name|extra
decl_stmt|;
name|YY_BUFFER_STATE
name|state
decl_stmt|;
name|XkbFile
modifier|*
name|xkb_file
decl_stmt|;
if|if
condition|(
operator|!
name|init_scanner
argument_list|(
operator|&
name|scanner
argument_list|,
operator|&
name|extra
argument_list|,
name|ctx
argument_list|,
name|file_name
argument_list|)
condition|)
return|return
name|NULL
return|;
name|state
operator|=
name|_xkbcommon__scan_string
argument_list|(
name|string
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
name|xkb_file
operator|=
name|parse
argument_list|(
name|ctx
argument_list|,
name|scanner
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_xkbcommon__delete_buffer
argument_list|(
name|state
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
name|clear_scanner
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
return|return
name|xkb_file
return|;
block|}
end_function
begin_comment
comment|/*  * _xkbcommon__scan_buffer() requires the last two bytes of \buf to be 0. These two bytes  * are not scanned. Other zero bytes in the buffer are scanned normally, though.  * Due to these terminating zeroes, \length must be greater than 2.  * Furthermore, the buffer must be writable and you cannot make any assumptions  * about it after the scanner finished.  * All this must be guaranteed by the caller of this function!  */
end_comment
begin_function
name|XkbFile
modifier|*
DECL|function|XkbParseBuffer
name|XkbParseBuffer
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|yyscan_t
name|scanner
decl_stmt|;
name|struct
name|scanner_extra
name|extra
decl_stmt|;
name|YY_BUFFER_STATE
name|state
decl_stmt|;
name|XkbFile
modifier|*
name|xkb_file
decl_stmt|;
if|if
condition|(
operator|!
name|init_scanner
argument_list|(
operator|&
name|scanner
argument_list|,
operator|&
name|extra
argument_list|,
name|ctx
argument_list|,
name|file_name
argument_list|)
condition|)
return|return
name|NULL
return|;
name|xkb_file
operator|=
name|NULL
expr_stmt|;
name|state
operator|=
name|_xkbcommon__scan_buffer
argument_list|(
name|buf
argument_list|,
name|length
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|xkb_file
operator|=
name|parse
argument_list|(
name|ctx
argument_list|,
name|scanner
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_xkbcommon__delete_buffer
argument_list|(
name|state
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
block|}
name|clear_scanner
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
return|return
name|xkb_file
return|;
block|}
end_function
begin_function
name|XkbFile
modifier|*
DECL|function|XkbParseFile
name|XkbParseFile
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|yyscan_t
name|scanner
decl_stmt|;
name|struct
name|scanner_extra
name|extra
decl_stmt|;
name|YY_BUFFER_STATE
name|state
decl_stmt|;
name|XkbFile
modifier|*
name|xkb_file
decl_stmt|;
if|if
condition|(
operator|!
name|init_scanner
argument_list|(
operator|&
name|scanner
argument_list|,
operator|&
name|extra
argument_list|,
name|ctx
argument_list|,
name|file_name
argument_list|)
condition|)
return|return
name|NULL
return|;
name|state
operator|=
name|_xkbcommon__create_buffer
argument_list|(
name|file
argument_list|,
name|YY_BUF_SIZE
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
name|_xkbcommon__switch_to_buffer
argument_list|(
name|state
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
name|xkb_file
operator|=
name|parse
argument_list|(
name|ctx
argument_list|,
name|scanner
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|_xkbcommon__delete_buffer
argument_list|(
name|state
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
name|clear_scanner
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
return|return
name|xkb_file
return|;
block|}
end_function
end_unit
