begin_unit
begin_comment
comment|/*  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"parser-priv.h"
end_include
begin_function
specifier|static
name|bool
DECL|function|number
name|number
parameter_list|(
name|struct
name|scanner
modifier|*
name|s
parameter_list|,
name|int64_t
modifier|*
name|out
parameter_list|,
name|int
modifier|*
name|out_tok
parameter_list|)
block|{
name|bool
name|is_float
init|=
name|false
decl_stmt|,
name|is_hex
init|=
name|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|s
operator|->
name|s
operator|+
name|s
operator|->
name|pos
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|lit
argument_list|(
name|s
argument_list|,
literal|"0x"
argument_list|)
condition|)
block|{
while|while
condition|(
name|is_xdigit
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|is_hex
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|is_digit
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|is_float
operator|=
name|chr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_digit
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s
operator|+
name|s
operator|->
name|pos
operator|==
name|start
condition|)
return|return
name|false
return|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_hex
condition|)
operator|*
name|out
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_float
condition|)
operator|*
name|out
operator|=
name|strtod
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
else|else
operator|*
name|out
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|s
operator|->
name|s
operator|+
name|s
operator|->
name|pos
operator|!=
name|end
condition|)
operator|*
name|out_tok
operator|=
name|ERROR_TOK
expr_stmt|;
else|else
operator|*
name|out_tok
operator|=
operator|(
name|is_float
condition|?
name|FLOAT
else|:
name|INTEGER
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
name|int
DECL|function|_xkbcommon_lex
name|_xkbcommon_lex
parameter_list|(
name|YYSTYPE
modifier|*
name|yylval
parameter_list|,
name|struct
name|scanner
modifier|*
name|s
parameter_list|)
block|{
name|int
name|tok
decl_stmt|;
name|skip_more_whitespace_and_comments
label|:
comment|/* Skip spaces. */
while|while
condition|(
name|is_space
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Skip comments. */
if|if
condition|(
name|lit
argument_list|(
name|s
argument_list|,
literal|"//"
argument_list|)
operator|||
name|chr
argument_list|(
name|s
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|eof
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|eol
argument_list|(
name|s
argument_list|)
condition|)
name|next
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|skip_more_whitespace_and_comments
goto|;
block|}
comment|/* See if we're done. */
if|if
condition|(
name|eof
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|END_OF_FILE
return|;
comment|/* New token. */
name|s
operator|->
name|token_line
operator|=
name|s
operator|->
name|line
expr_stmt|;
name|s
operator|->
name|token_column
operator|=
name|s
operator|->
name|column
expr_stmt|;
name|s
operator|->
name|buf_pos
operator|=
literal|0
expr_stmt|;
comment|/* String literal. */
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'\"'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|eof
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|eol
argument_list|(
name|s
argument_list|)
operator|&&
name|peek
argument_list|(
name|s
argument_list|)
operator|!=
literal|'\"'
condition|)
block|{
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'\\'
argument_list|)
condition|)
block|{
name|uint8_t
name|o
decl_stmt|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'\\'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'n'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'t'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'r'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'b'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\b'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'f'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'v'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\v'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'e'
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\033'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oct
argument_list|(
name|s
argument_list|,
operator|&
name|o
argument_list|)
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|)
name|o
argument_list|)
expr_stmt|;
else|else
block|{
name|scanner_warn
argument_list|(
name|s
argument_list|,
literal|"unknown escape sequence in string literal"
argument_list|)
expr_stmt|;
comment|/* Ignore. */
block|}
block|}
else|else
block|{
name|buf_append
argument_list|(
name|s
argument_list|,
name|next
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|)
operator|||
operator|!
name|chr
argument_list|(
name|s
argument_list|,
literal|'\"'
argument_list|)
condition|)
block|{
name|scanner_err
argument_list|(
name|s
argument_list|,
literal|"unterminated string literal"
argument_list|)
expr_stmt|;
return|return
name|ERROR_TOK
return|;
block|}
name|yylval
operator|->
name|str
operator|=
name|strdup
argument_list|(
name|s
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yylval
operator|->
name|str
condition|)
return|return
name|ERROR_TOK
return|;
return|return
name|STRING
return|;
block|}
comment|/* Key name literal. */
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'<'
argument_list|)
condition|)
block|{
while|while
condition|(
name|is_graph
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
operator|&&
name|peek
argument_list|(
name|s
argument_list|)
operator|!=
literal|'>'
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
name|next
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|)
operator|||
operator|!
name|chr
argument_list|(
name|s
argument_list|,
literal|'>'
argument_list|)
condition|)
block|{
name|scanner_err
argument_list|(
name|s
argument_list|,
literal|"unterminated key name literal"
argument_list|)
expr_stmt|;
return|return
name|ERROR_TOK
return|;
block|}
comment|/* Empty key name literals are allowed. */
name|yylval
operator|->
name|sval
operator|=
name|xkb_atom_intern
argument_list|(
name|s
operator|->
name|ctx
argument_list|,
name|s
operator|->
name|buf
argument_list|,
name|s
operator|->
name|buf_pos
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|KEYNAME
return|;
block|}
comment|/* Operators and punctuation. */
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|';'
argument_list|)
condition|)
return|return
name|SEMI
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'{'
argument_list|)
condition|)
return|return
name|OBRACE
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'}'
argument_list|)
condition|)
return|return
name|CBRACE
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'='
argument_list|)
condition|)
return|return
name|EQUALS
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'['
argument_list|)
condition|)
return|return
name|OBRACKET
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
condition|)
return|return
name|CBRACKET
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
condition|)
return|return
name|OPAREN
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
condition|)
return|return
name|CPAREN
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
condition|)
return|return
name|DOT
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
condition|)
return|return
name|COMMA
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'+'
argument_list|)
condition|)
return|return
name|PLUS
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'-'
argument_list|)
condition|)
return|return
name|MINUS
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'*'
argument_list|)
condition|)
return|return
name|TIMES
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
name|DIVIDE
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'!'
argument_list|)
condition|)
return|return
name|EXCLAM
return|;
if|if
condition|(
name|chr
argument_list|(
name|s
argument_list|,
literal|'~'
argument_list|)
condition|)
return|return
name|INVERT
return|;
comment|/* Identifier. */
if|if
condition|(
name|is_alpha
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
operator|||
name|peek
argument_list|(
name|s
argument_list|)
operator|==
literal|'_'
condition|)
block|{
name|s
operator|->
name|buf_pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|is_alnum
argument_list|(
name|peek
argument_list|(
name|s
argument_list|)
argument_list|)
operator|||
name|peek
argument_list|(
name|s
argument_list|)
operator|==
literal|'_'
condition|)
name|buf_append
argument_list|(
name|s
argument_list|,
name|next
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf_append
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|)
condition|)
block|{
name|scanner_err
argument_list|(
name|s
argument_list|,
literal|"identifier too long"
argument_list|)
expr_stmt|;
return|return
name|ERROR_TOK
return|;
block|}
comment|/* Keyword. */
name|tok
operator|=
name|keyword_to_token
argument_list|(
name|s
operator|->
name|buf
argument_list|,
name|s
operator|->
name|buf_pos
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
operator|-
literal|1
condition|)
return|return
name|tok
return|;
name|yylval
operator|->
name|str
operator|=
name|strdup
argument_list|(
name|s
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yylval
operator|->
name|str
condition|)
return|return
name|ERROR_TOK
return|;
return|return
name|IDENT
return|;
block|}
comment|/* Number literal (hexadecimal / decimal / float). */
if|if
condition|(
name|number
argument_list|(
name|s
argument_list|,
operator|&
name|yylval
operator|->
name|num
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
if|if
condition|(
name|tok
operator|==
name|ERROR_TOK
condition|)
block|{
name|scanner_err
argument_list|(
name|s
argument_list|,
literal|"malformed number literal"
argument_list|)
expr_stmt|;
return|return
name|ERROR_TOK
return|;
block|}
return|return
name|tok
return|;
block|}
name|scanner_err
argument_list|(
name|s
argument_list|,
literal|"unrecognized token"
argument_list|)
expr_stmt|;
return|return
name|ERROR_TOK
return|;
block|}
end_function
begin_function
name|XkbFile
modifier|*
DECL|function|XkbParseString
name|XkbParseString
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|struct
name|scanner
name|scanner
decl_stmt|;
name|scanner_init
argument_list|(
operator|&
name|scanner
argument_list|,
name|ctx
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
name|parse
argument_list|(
name|ctx
argument_list|,
operator|&
name|scanner
argument_list|,
name|map
argument_list|)
return|;
block|}
end_function
begin_function
name|XkbFile
modifier|*
DECL|function|XkbParseFile
name|XkbParseFile
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|XkbFile
modifier|*
name|xkb_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ok
operator|=
name|map_file
argument_list|(
name|file
argument_list|,
operator|&
name|string
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Couldn't read XKB file %s: %s\n"
argument_list|,
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|xkb_file
operator|=
name|XkbParseString
argument_list|(
name|ctx
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|file_name
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|unmap_file
argument_list|(
name|string
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|xkb_file
return|;
block|}
end_function
end_unit
