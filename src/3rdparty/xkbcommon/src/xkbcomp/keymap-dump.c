begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  */
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_define
DECL|macro|BUF_CHUNK_SIZE
define|#
directive|define
name|BUF_CHUNK_SIZE
value|4096
end_define
begin_struct
DECL|struct|buf
struct|struct
name|buf
block|{
DECL|member|buf
name|char
modifier|*
name|buf
decl_stmt|;
DECL|member|size
name|size_t
name|size
decl_stmt|;
DECL|member|alloc
name|size_t
name|alloc
decl_stmt|;
block|}
struct|;
end_struct
begin_function
specifier|static
name|bool
DECL|function|do_realloc
name|do_realloc
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|size_t
name|at_least
parameter_list|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|buf
operator|->
name|alloc
operator|+=
name|BUF_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
name|at_least
operator|>=
name|BUF_CHUNK_SIZE
condition|)
name|buf
operator|->
name|alloc
operator|+=
name|at_least
expr_stmt|;
name|new
operator|=
name|realloc
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|false
return|;
name|buf
operator|->
name|buf
operator|=
name|new
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_macro
name|ATTR_PRINTF
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
end_macro
begin_function
specifier|static
name|bool
DECL|function|check_write_buf
name|check_write_buf
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|printed
decl_stmt|;
name|size_t
name|available
decl_stmt|;
name|available
operator|=
name|buf
operator|->
name|alloc
operator|-
name|buf
operator|->
name|size
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|printed
operator|=
name|vsnprintf
argument_list|(
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|size
argument_list|,
name|available
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|printed
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|printed
operator|>=
name|available
condition|)
if|if
condition|(
operator|!
name|do_realloc
argument_list|(
name|buf
argument_list|,
name|printed
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* The buffer has enough space now. */
name|available
operator|=
name|buf
operator|->
name|alloc
operator|-
name|buf
operator|->
name|size
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|printed
operator|=
name|vsnprintf
argument_list|(
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|size
argument_list|,
name|available
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|printed
operator|>=
name|available
operator|||
name|printed
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|buf
operator|->
name|size
operator|+=
name|printed
expr_stmt|;
return|return
name|true
return|;
name|err
label|:
name|free
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
begin_define
DECL|macro|write_buf
define|#
directive|define
name|write_buf
parameter_list|(
name|buf
parameter_list|,
modifier|...
parameter_list|)
value|do { \     if (!check_write_buf(buf, __VA_ARGS__)) \         return false; \ } while (0)
end_define
begin_function
specifier|static
name|bool
DECL|function|write_vmods
name|write_vmods
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_mod
modifier|*
name|mod
decl_stmt|;
name|xkb_mod_index_t
name|num_vmods
init|=
literal|0
decl_stmt|;
name|darray_foreach
argument_list|(
argument|mod
argument_list|,
argument|keymap->mods
argument_list|)
block|{
if|if
condition|(
name|mod
operator|->
name|type
operator|!=
name|MOD_VIRT
condition|)
continue|continue;
if|if
condition|(
name|num_vmods
operator|==
literal|0
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tvirtual_modifiers "
argument_list|)
expr_stmt|;
else|else
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|mod
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|num_vmods
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num_vmods
operator|>
literal|0
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|";\n\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_keycodes
name|write_keycodes
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|xkb_led_index_t
name|idx
decl_stmt|;
specifier|const
name|struct
name|xkb_led
modifier|*
name|led
decl_stmt|;
if|if
condition|(
name|keymap
operator|->
name|keycodes_section_name
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_keycodes \"%s\" {\n"
argument_list|,
name|keymap
operator|->
name|keycodes_section_name
argument_list|)
expr_stmt|;
else|else
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_keycodes {\n"
argument_list|)
expr_stmt|;
name|xkb_foreach_key
argument_list|(
argument|key
argument_list|,
argument|keymap
argument_list|)
block|{
if|if
condition|(
name|key
operator|->
name|name
operator|==
name|XKB_ATOM_NONE
condition|)
continue|continue;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t%-20s = %d;\n"
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|key
operator|->
name|name
argument_list|)
argument_list|,
name|key
operator|->
name|keycode
argument_list|)
expr_stmt|;
block|}
name|darray_enumerate
argument_list|(
argument|idx
argument_list|,
argument|led
argument_list|,
argument|keymap->leds
argument_list|)
if|if
condition|(
name|led
operator|->
name|name
operator|!=
name|XKB_ATOM_NONE
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tindicator %d = \"%s\";\n"
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|led
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keymap
operator|->
name|num_key_aliases
condition|;
name|i
operator|++
control|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\talias %-14s = %s;\n"
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|keymap
operator|->
name|key_aliases
index|[
name|i
index|]
operator|.
name|alias
argument_list|)
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|keymap
operator|->
name|key_aliases
index|[
name|i
index|]
operator|.
name|real
argument_list|)
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_types
name|write_types
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|keymap
operator|->
name|types_section_name
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_types \"%s\" {\n"
argument_list|,
name|keymap
operator|->
name|types_section_name
argument_list|)
expr_stmt|;
else|else
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_types {\n"
argument_list|)
expr_stmt|;
name|write_vmods
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keymap
operator|->
name|num_types
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|xkb_key_type
modifier|*
name|type
init|=
operator|&
name|keymap
operator|->
name|types
index|[
name|i
index|]
decl_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\ttype \"%s\" {\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tmodifiers= %s;\n"
argument_list|,
name|ModMaskText
argument_list|(
name|keymap
argument_list|,
name|type
operator|->
name|mods
operator|.
name|mods
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|type
operator|->
name|num_entries
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
init|=
operator|&
name|type
operator|->
name|entries
index|[
name|j
index|]
decl_stmt|;
comment|/*              * Printing level 1 entries is redundant, it's the default,              * unless there's preserve info.              */
if|if
condition|(
name|entry
operator|->
name|level
operator|==
literal|0
operator|&&
name|entry
operator|->
name|preserve
operator|.
name|mods
operator|==
literal|0
condition|)
continue|continue;
name|str
operator|=
name|ModMaskText
argument_list|(
name|keymap
argument_list|,
name|entry
operator|->
name|mods
operator|.
name|mods
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tmap[%s]= Level%d;\n"
argument_list|,
name|str
argument_list|,
name|entry
operator|->
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|preserve
operator|.
name|mods
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tpreserve[%s]= %s;\n"
argument_list|,
name|str
argument_list|,
name|ModMaskText
argument_list|(
name|keymap
argument_list|,
name|entry
operator|->
name|preserve
operator|.
name|mods
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|xkb_level_index_t
name|n
init|=
literal|0
init|;
name|n
operator|<
name|type
operator|->
name|num_levels
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|type
operator|->
name|level_names
index|[
name|n
index|]
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tlevel_name[Level%d]= \"%s\";\n"
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|type
operator|->
name|level_names
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_led_map
name|write_led_map
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|xkb_led
modifier|*
name|led
parameter_list|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tindicator \"%s\" {\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|led
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|which_groups
condition|)
block|{
if|if
condition|(
name|led
operator|->
name|which_groups
operator|!=
name|XKB_STATE_LAYOUT_EFFECTIVE
condition|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\twhichGroupState= %s;\n"
argument_list|,
name|LedStateMaskText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|led
operator|->
name|which_groups
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tgroups= 0x%02x;\n"
argument_list|,
name|led
operator|->
name|groups
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|led
operator|->
name|which_mods
condition|)
block|{
if|if
condition|(
name|led
operator|->
name|which_mods
operator|!=
name|XKB_STATE_MODS_EFFECTIVE
condition|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\twhichModState= %s;\n"
argument_list|,
name|LedStateMaskText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|led
operator|->
name|which_mods
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tmodifiers= %s;\n"
argument_list|,
name|ModMaskText
argument_list|(
name|keymap
argument_list|,
name|led
operator|->
name|mods
operator|.
name|mods
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|led
operator|->
name|ctrls
condition|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tcontrols= %s;\n"
argument_list|,
name|ControlMaskText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|led
operator|->
name|ctrls
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_action
name|write_action
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|union
name|xkb_action
modifier|*
name|action
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
name|prefix
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|suffix
condition|)
name|suffix
operator|=
literal|""
expr_stmt|;
name|type
operator|=
name|ActionTypeText
argument_list|(
name|action
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
operator|->
name|type
condition|)
block|{
case|case
name|ACTION_TYPE_MOD_SET
case|:
case|case
name|ACTION_TYPE_MOD_LATCH
case|:
case|case
name|ACTION_TYPE_MOD_LOCK
case|:
if|if
condition|(
name|action
operator|->
name|mods
operator|.
name|flags
operator|&
name|ACTION_MODS_LOOKUP_MODMAP
condition|)
name|args
operator|=
literal|"modMapMods"
expr_stmt|;
else|else
name|args
operator|=
name|ModMaskText
argument_list|(
name|keymap
argument_list|,
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mods
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(modifiers=%s%s%s)%s"
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|,
name|args
argument_list|,
operator|(
name|action
operator|->
name|type
operator|!=
name|ACTION_TYPE_MOD_LOCK
operator|&&
operator|(
name|action
operator|->
name|mods
operator|.
name|flags
operator|&
name|ACTION_LOCK_CLEAR
operator|)
operator|)
condition|?
literal|",clearLocks"
else|:
literal|""
argument_list|,
operator|(
name|action
operator|->
name|type
operator|!=
name|ACTION_TYPE_MOD_LOCK
operator|&&
operator|(
name|action
operator|->
name|mods
operator|.
name|flags
operator|&
name|ACTION_LATCH_TO_LOCK
operator|)
operator|)
condition|?
literal|",latchToLock"
else|:
literal|""
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_GROUP_SET
case|:
case|case
name|ACTION_TYPE_GROUP_LATCH
case|:
case|case
name|ACTION_TYPE_GROUP_LOCK
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(group=%s%d%s%s)%s"
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|,
operator|(
operator|!
operator|(
name|action
operator|->
name|group
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_SWITCH
operator|)
operator|&&
name|action
operator|->
name|group
operator|.
name|group
operator|>
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|""
argument_list|,
operator|(
name|action
operator|->
name|group
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_SWITCH
operator|)
condition|?
name|action
operator|->
name|group
operator|.
name|group
operator|+
literal|1
else|:
name|action
operator|->
name|group
operator|.
name|group
argument_list|,
operator|(
name|action
operator|->
name|type
operator|!=
name|ACTION_TYPE_GROUP_LOCK
operator|&&
operator|(
name|action
operator|->
name|group
operator|.
name|flags
operator|&
name|ACTION_LOCK_CLEAR
operator|)
operator|)
condition|?
literal|",clearLocks"
else|:
literal|""
argument_list|,
operator|(
name|action
operator|->
name|type
operator|!=
name|ACTION_TYPE_GROUP_LOCK
operator|&&
operator|(
name|action
operator|->
name|group
operator|.
name|flags
operator|&
name|ACTION_LATCH_TO_LOCK
operator|)
operator|)
condition|?
literal|",latchToLock"
else|:
literal|""
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_TERMINATE
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s()%s"
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_PTR_MOVE
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(x=%s%d,y=%s%d%s)%s"
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|,
operator|(
operator|!
operator|(
name|action
operator|->
name|ptr
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_X
operator|)
operator|&&
name|action
operator|->
name|ptr
operator|.
name|x
operator|>=
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|action
operator|->
name|ptr
operator|.
name|x
argument_list|,
operator|(
operator|!
operator|(
name|action
operator|->
name|ptr
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_Y
operator|)
operator|&&
name|action
operator|->
name|ptr
operator|.
name|y
operator|>=
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|action
operator|->
name|ptr
operator|.
name|y
argument_list|,
operator|(
name|action
operator|->
name|ptr
operator|.
name|flags
operator|&
name|ACTION_NO_ACCEL
operator|)
condition|?
literal|",!accel"
else|:
literal|""
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_PTR_LOCK
case|:
switch|switch
condition|(
name|action
operator|->
name|btn
operator|.
name|flags
operator|&
operator|(
name|ACTION_LOCK_NO_LOCK
operator||
name|ACTION_LOCK_NO_UNLOCK
operator|)
condition|)
block|{
case|case
name|ACTION_LOCK_NO_UNLOCK
case|:
name|args
operator|=
literal|",affect=lock"
expr_stmt|;
break|break;
case|case
name|ACTION_LOCK_NO_LOCK
case|:
name|args
operator|=
literal|",affect=unlock"
expr_stmt|;
break|break;
case|case
name|ACTION_LOCK_NO_LOCK
operator||
name|ACTION_LOCK_NO_UNLOCK
case|:
name|args
operator|=
literal|",affect=neither"
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|",affect=both"
expr_stmt|;
break|break;
block|}
case|case
name|ACTION_TYPE_PTR_BUTTON
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(button="
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|btn
operator|.
name|button
operator|>
literal|0
operator|&&
name|action
operator|->
name|btn
operator|.
name|button
operator|<=
literal|5
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|action
operator|->
name|btn
operator|.
name|button
argument_list|)
expr_stmt|;
else|else
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|btn
operator|.
name|count
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|",count=%d"
argument_list|,
name|action
operator|->
name|btn
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|")%s"
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_PTR_DEFAULT
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s("
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"affect=button,button=%s%d"
argument_list|,
operator|(
operator|!
operator|(
name|action
operator|->
name|dflt
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_SWITCH
operator|)
operator|&&
name|action
operator|->
name|dflt
operator|.
name|value
operator|>=
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|action
operator|->
name|dflt
operator|.
name|value
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|")%s"
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_SWITCH_VT
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(screen=%s%d,%ssame)%s"
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|,
operator|(
operator|!
operator|(
name|action
operator|->
name|screen
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_SWITCH
operator|)
operator|&&
name|action
operator|->
name|screen
operator|.
name|screen
operator|>=
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|action
operator|->
name|screen
operator|.
name|screen
argument_list|,
operator|(
name|action
operator|->
name|screen
operator|.
name|flags
operator|&
name|ACTION_SAME_SCREEN
operator|)
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_CTRL_SET
case|:
case|case
name|ACTION_TYPE_CTRL_LOCK
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(controls=%s)%s"
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|,
name|ControlMaskText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|action
operator|->
name|ctrls
operator|.
name|ctrls
argument_list|)
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TYPE_NONE
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%sNoAction()%s"
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
default|default:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s%s(type=0x%02x,data[0]=0x%02x,data[1]=0x%02x,data[2]=0x%02x,data[3]=0x%02x,data[4]=0x%02x,data[5]=0x%02x,data[6]=0x%02x)%s"
argument_list|,
name|prefix
argument_list|,
name|type
argument_list|,
name|action
operator|->
name|type
argument_list|,
name|action
operator|->
name|priv
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|action
operator|->
name|priv
operator|.
name|data
index|[
literal|1
index|]
argument_list|,
name|action
operator|->
name|priv
operator|.
name|data
index|[
literal|2
index|]
argument_list|,
name|action
operator|->
name|priv
operator|.
name|data
index|[
literal|3
index|]
argument_list|,
name|action
operator|->
name|priv
operator|.
name|data
index|[
literal|4
index|]
argument_list|,
name|action
operator|->
name|priv
operator|.
name|data
index|[
literal|5
index|]
argument_list|,
name|action
operator|->
name|priv
operator|.
name|data
index|[
literal|6
index|]
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_compat
name|write_compat
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_sym_interpret
modifier|*
name|si
decl_stmt|;
specifier|const
name|struct
name|xkb_led
modifier|*
name|led
decl_stmt|;
if|if
condition|(
name|keymap
operator|->
name|compat_section_name
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_compatibility \"%s\" {\n"
argument_list|,
name|keymap
operator|->
name|compat_section_name
argument_list|)
expr_stmt|;
else|else
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_compatibility {\n"
argument_list|)
expr_stmt|;
name|write_vmods
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tinterpret.useModMapMods= AnyLevel;\n"
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tinterpret.repeat= False;\n"
argument_list|)
expr_stmt|;
name|darray_foreach
argument_list|(
argument|si
argument_list|,
argument|keymap->sym_interprets
argument_list|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tinterpret %s+%s(%s) {\n"
argument_list|,
name|si
operator|->
name|sym
condition|?
name|KeysymText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|si
operator|->
name|sym
argument_list|)
else|:
literal|"Any"
argument_list|,
name|SIMatchText
argument_list|(
name|si
operator|->
name|match
argument_list|)
argument_list|,
name|ModMaskText
argument_list|(
name|keymap
argument_list|,
name|si
operator|->
name|mods
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|virtual_mod
operator|!=
name|XKB_MOD_INVALID
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tvirtualModifier= %s;\n"
argument_list|,
name|ModIndexText
argument_list|(
name|keymap
argument_list|,
name|si
operator|->
name|virtual_mod
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|level_one_only
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\tuseModMapMods=level1;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|repeat
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t\trepeat= True;\n"
argument_list|)
expr_stmt|;
name|write_action
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|,
operator|&
name|si
operator|->
name|action
argument_list|,
literal|"\t\taction= "
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
block|}
name|darray_foreach
argument_list|(
argument|led
argument_list|,
argument|keymap->leds
argument_list|)
if|if
condition|(
name|led
operator|->
name|which_groups
operator|||
name|led
operator|->
name|groups
operator|||
name|led
operator|->
name|which_mods
operator|||
name|led
operator|->
name|mods
operator|.
name|mods
operator|||
name|led
operator|->
name|ctrls
condition|)
name|write_led_map
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|,
name|led
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_keysyms
name|write_keysyms
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|xkb_layout_index_t
name|group
parameter_list|)
block|{
for|for
control|(
name|xkb_level_index_t
name|level
init|=
literal|0
init|;
name|level
operator|<
name|XkbKeyGroupWidth
argument_list|(
name|key
argument_list|,
name|group
argument_list|)
condition|;
name|level
operator|++
control|)
block|{
specifier|const
name|xkb_keysym_t
modifier|*
name|syms
decl_stmt|;
name|int
name|num_syms
decl_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|num_syms
operator|=
name|xkb_keymap_key_get_syms_by_level
argument_list|(
name|keymap
argument_list|,
name|key
operator|->
name|keycode
argument_list|,
name|group
argument_list|,
name|level
argument_list|,
operator|&
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_syms
operator|==
literal|0
condition|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%15s"
argument_list|,
literal|"NoSymbol"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_syms
operator|==
literal|1
condition|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%15s"
argument_list|,
name|KeysymText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|syms
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|num_syms
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|KeysymText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|syms
index|[
name|s
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|" }"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_key
name|write_key
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|)
block|{
name|xkb_layout_index_t
name|group
decl_stmt|;
name|bool
name|simple
init|=
name|true
decl_stmt|;
name|bool
name|explicit_types
init|=
name|false
decl_stmt|;
name|bool
name|multi_type
init|=
name|false
decl_stmt|;
name|bool
name|show_actions
decl_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tkey %-20s {"
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|key
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|group
operator|=
literal|0
init|;
name|group
operator|<
name|key
operator|->
name|num_groups
condition|;
name|group
operator|++
control|)
block|{
if|if
condition|(
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|explicit_type
condition|)
name|explicit_types
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|group
operator|!=
literal|0
operator|&&
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|type
operator|!=
name|key
operator|->
name|groups
index|[
literal|0
index|]
operator|.
name|type
condition|)
name|multi_type
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|explicit_types
condition|)
block|{
specifier|const
name|struct
name|xkb_key_type
modifier|*
name|type
decl_stmt|;
name|simple
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|multi_type
condition|)
block|{
for|for
control|(
name|group
operator|=
literal|0
init|;
name|group
operator|<
name|key
operator|->
name|num_groups
condition|;
name|group
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|explicit_type
condition|)
continue|continue;
name|type
operator|=
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|type
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\ttype[group%u]= \"%s\","
argument_list|,
name|group
operator|+
literal|1
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|key
operator|->
name|groups
index|[
literal|0
index|]
operator|.
name|type
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\ttype= \"%s\","
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|key
operator|->
name|explicit
operator|&
name|EXPLICIT_REPEAT
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|repeats
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\trepeat= Yes,"
argument_list|)
expr_stmt|;
else|else
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\trepeat= No,"
argument_list|)
expr_stmt|;
name|simple
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|vmodmap
operator|&&
operator|(
name|key
operator|->
name|explicit
operator|&
name|EXPLICIT_VMODMAP
operator|)
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\tvirtualMods= %s,"
argument_list|,
name|ModMaskText
argument_list|(
name|keymap
argument_list|,
name|key
operator|->
name|vmodmap
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|key
operator|->
name|out_of_range_group_action
condition|)
block|{
case|case
name|RANGE_SATURATE
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\tgroupsClamp,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RANGE_REDIRECT
case|:
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\tgroupsRedirect= Group%u,"
argument_list|,
name|key
operator|->
name|out_of_range_group_number
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|show_actions
operator|=
operator|!
operator|!
operator|(
name|key
operator|->
name|explicit
operator|&
name|EXPLICIT_INTERP
operator|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|num_groups
operator|>
literal|1
operator|||
name|show_actions
condition|)
name|simple
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|simple
condition|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\t[ "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_keysyms
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|" ] };\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xkb_level_index_t
name|level
decl_stmt|;
for|for
control|(
name|group
operator|=
literal|0
init|;
name|group
operator|<
name|key
operator|->
name|num_groups
condition|;
name|group
operator|++
control|)
block|{
if|if
condition|(
name|group
operator|!=
literal|0
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t\tsymbols[Group%u]= [ "
argument_list|,
name|group
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_keysyms
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|,
name|key
argument_list|,
name|group
argument_list|)
condition|)
return|return
name|false
return|;
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|" ]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_actions
condition|)
block|{
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|",\n\t\tactions[Group%u]= [ "
argument_list|,
name|group
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|XkbKeyGroupWidth
argument_list|(
name|key
argument_list|,
name|group
argument_list|)
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|write_action
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|,
operator|&
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|levels
index|[
name|level
index|]
operator|.
name|action
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|" ]"
argument_list|)
expr_stmt|;
block|}
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n\t};\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_symbols
name|write_symbols
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|xkb_layout_index_t
name|group
decl_stmt|;
if|if
condition|(
name|keymap
operator|->
name|symbols_section_name
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_symbols \"%s\" {\n"
argument_list|,
name|keymap
operator|->
name|symbols_section_name
argument_list|)
expr_stmt|;
else|else
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_symbols {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|group
operator|=
literal|0
init|;
name|group
operator|<
name|keymap
operator|->
name|num_group_names
condition|;
name|group
operator|++
control|)
if|if
condition|(
name|keymap
operator|->
name|group_names
index|[
name|group
index|]
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tname[group%d]=\"%s\";\n"
argument_list|,
name|group
operator|+
literal|1
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|keymap
operator|->
name|group_names
index|[
name|group
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|>
literal|0
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xkb_foreach_key
argument_list|(
argument|key
argument_list|,
argument|keymap
argument_list|)
if|if
condition|(
name|key
operator|->
name|num_groups
operator|>
literal|0
condition|)
name|write_key
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|xkb_foreach_key
argument_list|(
argument|key
argument_list|,
argument|keymap
argument_list|)
block|{
name|xkb_mod_index_t
name|i
decl_stmt|;
specifier|const
name|struct
name|xkb_mod
modifier|*
name|mod
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|modmap
operator|==
literal|0
condition|)
continue|continue;
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|mod
argument_list|,
argument|keymap->mods
argument_list|)
if|if
condition|(
name|key
operator|->
name|modmap
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"\tmodifier_map %s { %s };\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|mod
operator|->
name|name
argument_list|)
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|key
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_buf
argument_list|(
name|buf
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|write_keymap
name|write_keymap
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|check_write_buf
argument_list|(
name|buf
argument_list|,
literal|"xkb_keymap {\n"
argument_list|)
operator|&&
name|write_keycodes
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|)
operator|&&
name|write_types
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|)
operator|&&
name|write_compat
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|)
operator|&&
name|write_symbols
argument_list|(
name|keymap
argument_list|,
name|buf
argument_list|)
operator|&&
name|check_write_buf
argument_list|(
name|buf
argument_list|,
literal|"};\n"
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
name|char
modifier|*
DECL|function|text_v1_keymap_get_as_string
name|text_v1_keymap_get_as_string
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
block|{
name|struct
name|buf
name|buf
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|write_keymap
argument_list|(
name|keymap
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
operator|.
name|buf
return|;
block|}
end_function
end_unit
