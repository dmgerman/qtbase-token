begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  *         Ran Benita<ran234@gmail.com>  */
end_comment
begin_include
include|#
directive|include
file|"xkbcomp-priv.h"
end_include
begin_include
include|#
directive|include
file|"text.h"
end_include
begin_include
include|#
directive|include
file|"expr.h"
end_include
begin_include
include|#
directive|include
file|"action.h"
end_include
begin_include
include|#
directive|include
file|"vmod.h"
end_include
begin_include
include|#
directive|include
file|"include.h"
end_include
begin_include
include|#
directive|include
file|"keysym.h"
end_include
begin_enum
DECL|enum|key_repeat
enum|enum
name|key_repeat
block|{
DECL|enumerator|KEY_REPEAT_UNDEFINED
name|KEY_REPEAT_UNDEFINED
init|=
literal|0
block|,
DECL|enumerator|KEY_REPEAT_YES
name|KEY_REPEAT_YES
init|=
literal|1
block|,
DECL|enumerator|KEY_REPEAT_NO
name|KEY_REPEAT_NO
init|=
literal|2
block|, }
enum|;
end_enum
begin_enum
DECL|enum|group_field
enum|enum
name|group_field
block|{
DECL|enumerator|GROUP_FIELD_SYMS
name|GROUP_FIELD_SYMS
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|GROUP_FIELD_ACTS
name|GROUP_FIELD_ACTS
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|GROUP_FIELD_TYPE
name|GROUP_FIELD_TYPE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|, }
enum|;
end_enum
begin_enum
DECL|enum|key_field
enum|enum
name|key_field
block|{
DECL|enumerator|KEY_FIELD_REPEAT
name|KEY_FIELD_REPEAT
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|KEY_FIELD_DEFAULT_TYPE
name|KEY_FIELD_DEFAULT_TYPE
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|KEY_FIELD_GROUPINFO
name|KEY_FIELD_GROUPINFO
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
DECL|enumerator|KEY_FIELD_VMODMAP
name|KEY_FIELD_VMODMAP
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|, }
enum|;
end_enum
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|defined
name|enum
name|group_field
name|defined
decl_stmt|;
DECL|member|levels
name|darray
argument_list|(
argument|struct xkb_level
argument_list|)
name|levels
expr_stmt|;
DECL|member|type
name|xkb_atom_t
name|type
decl_stmt|;
block|}
DECL|typedef|GroupInfo
name|GroupInfo
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|defined
name|enum
name|key_field
name|defined
decl_stmt|;
DECL|member|merge
name|enum
name|merge_mode
name|merge
decl_stmt|;
DECL|member|name
name|xkb_atom_t
name|name
decl_stmt|;
name|darray
argument_list|(
argument|GroupInfo
argument_list|)
name|groups
expr_stmt|;
DECL|member|repeat
name|enum
name|key_repeat
name|repeat
decl_stmt|;
DECL|member|vmodmap
name|xkb_mod_mask_t
name|vmodmap
decl_stmt|;
DECL|member|default_type
name|xkb_atom_t
name|default_type
decl_stmt|;
DECL|member|out_of_range_group_action
name|enum
name|xkb_range_exceed_type
name|out_of_range_group_action
decl_stmt|;
DECL|member|out_of_range_group_number
name|xkb_layout_index_t
name|out_of_range_group_number
decl_stmt|;
block|}
DECL|typedef|KeyInfo
name|KeyInfo
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|ClearLevelInfo
name|ClearLevelInfo
parameter_list|(
name|struct
name|xkb_level
modifier|*
name|leveli
parameter_list|)
block|{
if|if
condition|(
name|leveli
operator|->
name|num_syms
operator|>
literal|1
condition|)
name|free
argument_list|(
name|leveli
operator|->
name|u
operator|.
name|syms
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|InitGroupInfo
name|InitGroupInfo
parameter_list|(
name|GroupInfo
modifier|*
name|groupi
parameter_list|)
block|{
name|memset
argument_list|(
name|groupi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|groupi
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ClearGroupInfo
name|ClearGroupInfo
parameter_list|(
name|GroupInfo
modifier|*
name|groupi
parameter_list|)
block|{
name|struct
name|xkb_level
modifier|*
name|leveli
decl_stmt|;
name|darray_foreach
argument_list|(
argument|leveli
argument_list|,
argument|groupi->levels
argument_list|)
name|ClearLevelInfo
argument_list|(
name|leveli
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|CopyGroupInfo
name|CopyGroupInfo
parameter_list|(
name|GroupInfo
modifier|*
name|to
parameter_list|,
specifier|const
name|GroupInfo
modifier|*
name|from
parameter_list|)
block|{
name|xkb_level_index_t
name|j
decl_stmt|;
name|to
operator|->
name|defined
operator|=
name|from
operator|->
name|defined
expr_stmt|;
name|to
operator|->
name|type
operator|=
name|from
operator|->
name|type
expr_stmt|;
name|darray_init
argument_list|(
name|to
operator|->
name|levels
argument_list|)
expr_stmt|;
name|darray_copy
argument_list|(
name|to
operator|->
name|levels
argument_list|,
name|from
operator|->
name|levels
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|darray_size
argument_list|(
name|to
operator|->
name|levels
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|darray_item
argument_list|(
name|from
operator|->
name|levels
argument_list|,
name|j
argument_list|)
operator|.
name|num_syms
operator|>
literal|1
condition|)
name|darray_item
argument_list|(
name|to
operator|->
name|levels
argument_list|,
name|j
argument_list|)
operator|.
name|u
operator|.
name|syms
operator|=
name|memdup
argument_list|(
name|darray_item
argument_list|(
name|from
operator|->
name|levels
argument_list|,
name|j
argument_list|)
operator|.
name|u
operator|.
name|syms
argument_list|,
name|darray_item
argument_list|(
name|from
operator|->
name|levels
argument_list|,
name|j
argument_list|)
operator|.
name|num_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|xkb_keysym_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|InitKeyInfo
name|InitKeyInfo
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|)
block|{
name|memset
argument_list|(
name|keyi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
name|keyi
operator|->
name|merge
operator|=
name|MERGE_OVERRIDE
expr_stmt|;
name|keyi
operator|->
name|name
operator|=
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|keyi
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_WRAP
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ClearKeyInfo
name|ClearKeyInfo
parameter_list|(
name|KeyInfo
modifier|*
name|keyi
parameter_list|)
block|{
name|GroupInfo
modifier|*
name|groupi
decl_stmt|;
name|darray_foreach
argument_list|(
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|)
name|ClearGroupInfo
argument_list|(
name|groupi
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|keyi
operator|->
name|groups
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|merge
name|enum
name|merge_mode
name|merge
decl_stmt|;
DECL|member|haveSymbol
name|bool
name|haveSymbol
decl_stmt|;
DECL|member|modifier
name|xkb_mod_index_t
name|modifier
decl_stmt|;
union|union
block|{
DECL|member|keyName
name|xkb_atom_t
name|keyName
decl_stmt|;
DECL|member|keySym
name|xkb_keysym_t
name|keySym
decl_stmt|;
block|}
DECL|member|u
name|u
union|;
block|}
DECL|typedef|ModMapEntry
name|ModMapEntry
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
comment|/* e.g. pc+us+inet(evdev) */
DECL|member|errorCount
name|int
name|errorCount
decl_stmt|;
DECL|member|merge
name|enum
name|merge_mode
name|merge
decl_stmt|;
DECL|member|explicit_group
name|xkb_layout_index_t
name|explicit_group
decl_stmt|;
name|darray
argument_list|(
argument|KeyInfo
argument_list|)
name|keys
expr_stmt|;
DECL|member|default_key
name|KeyInfo
name|default_key
decl_stmt|;
DECL|member|actions
name|ActionsInfo
modifier|*
name|actions
decl_stmt|;
name|darray
argument_list|(
argument|xkb_atom_t
argument_list|)
name|group_names
expr_stmt|;
name|darray
argument_list|(
argument|ModMapEntry
argument_list|)
name|modMaps
expr_stmt|;
DECL|member|keymap
name|struct
name|xkb_keymap
modifier|*
name|keymap
decl_stmt|;
block|}
DECL|typedef|SymbolsInfo
name|SymbolsInfo
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|InitSymbolsInfo
name|InitSymbolsInfo
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|ActionsInfo
modifier|*
name|actions
parameter_list|)
block|{
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|keymap
operator|=
name|keymap
expr_stmt|;
name|info
operator|->
name|merge
operator|=
name|MERGE_OVERRIDE
expr_stmt|;
name|InitKeyInfo
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
operator|&
name|info
operator|->
name|default_key
argument_list|)
expr_stmt|;
name|info
operator|->
name|actions
operator|=
name|actions
expr_stmt|;
name|info
operator|->
name|explicit_group
operator|=
name|XKB_LAYOUT_INVALID
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ClearSymbolsInfo
name|ClearSymbolsInfo
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|)
block|{
name|KeyInfo
modifier|*
name|keyi
decl_stmt|;
name|free
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|darray_foreach
argument_list|(
argument|keyi
argument_list|,
argument|info->keys
argument_list|)
name|ClearKeyInfo
argument_list|(
name|keyi
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|info
operator|->
name|keys
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|info
operator|->
name|group_names
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|info
operator|->
name|modMaps
argument_list|)
expr_stmt|;
name|ClearKeyInfo
argument_list|(
operator|&
name|info
operator|->
name|default_key
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|KeyInfoText
name|KeyInfoText
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|)
block|{
return|return
name|KeyNameText
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|keyi
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|MergeGroups
name|MergeGroups
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|GroupInfo
modifier|*
name|into
parameter_list|,
name|GroupInfo
modifier|*
name|from
parameter_list|,
name|bool
name|clobber
parameter_list|,
name|bool
name|report
parameter_list|,
name|xkb_layout_index_t
name|group
parameter_list|,
name|xkb_atom_t
name|key_name
parameter_list|)
block|{
name|xkb_level_index_t
name|i
decl_stmt|,
name|levels_in_both
decl_stmt|;
name|struct
name|xkb_context
modifier|*
name|ctx
init|=
name|info
operator|->
name|keymap
operator|->
name|ctx
decl_stmt|;
comment|/* First find the type of the merged group. */
if|if
condition|(
name|into
operator|->
name|type
operator|!=
name|from
operator|->
name|type
condition|)
block|{
if|if
condition|(
name|from
operator|->
name|type
operator|==
name|XKB_ATOM_NONE
condition|)
block|{         }
elseif|else
if|if
condition|(
name|into
operator|->
name|type
operator|==
name|XKB_ATOM_NONE
condition|)
block|{
name|into
operator|->
name|type
operator|=
name|from
operator|->
name|type
expr_stmt|;
block|}
else|else
block|{
name|xkb_atom_t
name|use
init|=
operator|(
name|clobber
condition|?
name|from
operator|->
name|type
else|:
name|into
operator|->
name|type
operator|)
decl_stmt|;
name|xkb_atom_t
name|ignore
init|=
operator|(
name|clobber
condition|?
name|into
operator|->
name|type
else|:
name|from
operator|->
name|type
operator|)
decl_stmt|;
if|if
condition|(
name|report
condition|)
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Multiple definitions for group %d type of key %s; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|group
operator|+
literal|1
argument_list|,
name|KeyNameText
argument_list|(
name|ctx
argument_list|,
name|key_name
argument_list|)
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|use
argument_list|)
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|ignore
argument_list|)
argument_list|)
expr_stmt|;
name|into
operator|->
name|type
operator|=
name|use
expr_stmt|;
block|}
block|}
name|into
operator|->
name|defined
operator||=
operator|(
name|from
operator|->
name|defined
operator|&
name|GROUP_FIELD_TYPE
operator|)
expr_stmt|;
comment|/* Now look at the levels. */
if|if
condition|(
name|darray_empty
argument_list|(
name|from
operator|->
name|levels
argument_list|)
condition|)
block|{
name|InitGroupInfo
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|darray_empty
argument_list|(
name|into
operator|->
name|levels
argument_list|)
condition|)
block|{
name|from
operator|->
name|type
operator|=
name|into
operator|->
name|type
expr_stmt|;
operator|*
name|into
operator|=
operator|*
name|from
expr_stmt|;
name|InitGroupInfo
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Merge the actions and syms. */
name|levels_in_both
operator|=
name|MIN
argument_list|(
name|darray_size
argument_list|(
name|into
operator|->
name|levels
argument_list|)
argument_list|,
name|darray_size
argument_list|(
name|from
operator|->
name|levels
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|levels_in_both
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|xkb_level
modifier|*
name|intoLevel
init|=
operator|&
name|darray_item
argument_list|(
name|into
operator|->
name|levels
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|xkb_level
modifier|*
name|fromLevel
init|=
operator|&
name|darray_item
argument_list|(
name|from
operator|->
name|levels
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fromLevel
operator|->
name|action
operator|.
name|type
operator|==
name|ACTION_TYPE_NONE
condition|)
block|{         }
elseif|else
if|if
condition|(
name|intoLevel
operator|->
name|action
operator|.
name|type
operator|==
name|ACTION_TYPE_NONE
condition|)
block|{
name|intoLevel
operator|->
name|action
operator|=
name|fromLevel
operator|->
name|action
expr_stmt|;
block|}
else|else
block|{
name|union
name|xkb_action
modifier|*
name|use
decl_stmt|,
modifier|*
name|ignore
decl_stmt|;
name|use
operator|=
operator|(
name|clobber
condition|?
operator|&
name|fromLevel
operator|->
name|action
else|:
operator|&
name|intoLevel
operator|->
name|action
operator|)
expr_stmt|;
name|ignore
operator|=
operator|(
name|clobber
condition|?
operator|&
name|intoLevel
operator|->
name|action
else|:
operator|&
name|fromLevel
operator|->
name|action
operator|)
expr_stmt|;
if|if
condition|(
name|report
condition|)
name|log_warn
argument_list|(
name|ctx
argument_list|,
literal|"Multiple actions for level %d/group %u on key %s; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|group
operator|+
literal|1
argument_list|,
name|KeyNameText
argument_list|(
name|ctx
argument_list|,
name|key_name
argument_list|)
argument_list|,
name|ActionTypeText
argument_list|(
name|use
operator|->
name|type
argument_list|)
argument_list|,
name|ActionTypeText
argument_list|(
name|ignore
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|intoLevel
operator|->
name|action
operator|=
operator|*
name|use
expr_stmt|;
block|}
if|if
condition|(
name|fromLevel
operator|->
name|num_syms
operator|==
literal|0
condition|)
block|{         }
elseif|else
if|if
condition|(
name|intoLevel
operator|->
name|num_syms
operator|==
literal|0
condition|)
block|{
name|intoLevel
operator|->
name|num_syms
operator|=
name|fromLevel
operator|->
name|num_syms
expr_stmt|;
if|if
condition|(
name|fromLevel
operator|->
name|num_syms
operator|>
literal|1
condition|)
name|intoLevel
operator|->
name|u
operator|.
name|syms
operator|=
name|fromLevel
operator|->
name|u
operator|.
name|syms
expr_stmt|;
else|else
name|intoLevel
operator|->
name|u
operator|.
name|sym
operator|=
name|fromLevel
operator|->
name|u
operator|.
name|sym
expr_stmt|;
name|fromLevel
operator|->
name|num_syms
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|report
condition|)
name|log_warn
argument_list|(
name|ctx
argument_list|,
literal|"Multiple symbols for level %d/group %u on key %s; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|group
operator|+
literal|1
argument_list|,
name|KeyNameText
argument_list|(
name|ctx
argument_list|,
name|key_name
argument_list|)
argument_list|,
operator|(
name|clobber
condition|?
literal|"from"
else|:
literal|"to"
operator|)
argument_list|,
operator|(
name|clobber
condition|?
literal|"to"
else|:
literal|"from"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber
condition|)
block|{
name|ClearLevelInfo
argument_list|(
name|intoLevel
argument_list|)
expr_stmt|;
name|intoLevel
operator|->
name|num_syms
operator|=
name|fromLevel
operator|->
name|num_syms
expr_stmt|;
if|if
condition|(
name|fromLevel
operator|->
name|num_syms
operator|>
literal|1
condition|)
name|intoLevel
operator|->
name|u
operator|.
name|syms
operator|=
name|fromLevel
operator|->
name|u
operator|.
name|syms
expr_stmt|;
else|else
name|intoLevel
operator|->
name|u
operator|.
name|sym
operator|=
name|fromLevel
operator|->
name|u
operator|.
name|sym
expr_stmt|;
name|fromLevel
operator|->
name|num_syms
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* If @from has extra levels, get them as well. */
for|for
control|(
name|i
operator|=
name|levels_in_both
init|;
name|i
operator|<
name|darray_size
argument_list|(
name|from
operator|->
name|levels
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|darray_append
argument_list|(
name|into
operator|->
name|levels
argument_list|,
name|darray_item
argument_list|(
name|from
operator|->
name|levels
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|darray_item
argument_list|(
name|from
operator|->
name|levels
argument_list|,
name|i
argument_list|)
operator|.
name|num_syms
operator|=
literal|0
expr_stmt|;
block|}
name|into
operator|->
name|defined
operator||=
operator|(
name|from
operator|->
name|defined
operator|&
name|GROUP_FIELD_ACTS
operator|)
expr_stmt|;
name|into
operator|->
name|defined
operator||=
operator|(
name|from
operator|->
name|defined
operator|&
name|GROUP_FIELD_SYMS
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|UseNewKeyField
name|UseNewKeyField
parameter_list|(
name|enum
name|key_field
name|field
parameter_list|,
name|enum
name|key_field
name|old
parameter_list|,
name|enum
name|key_field
name|new
parameter_list|,
name|bool
name|clobber
parameter_list|,
name|bool
name|report
parameter_list|,
name|enum
name|key_field
modifier|*
name|collide
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|old
operator|&
name|field
operator|)
condition|)
return|return
operator|(
name|new
operator|&
name|field
operator|)
return|;
if|if
condition|(
name|new
operator|&
name|field
condition|)
block|{
if|if
condition|(
name|report
condition|)
operator|*
name|collide
operator||=
name|field
expr_stmt|;
if|if
condition|(
name|clobber
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|MergeKeys
name|MergeKeys
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|into
parameter_list|,
name|KeyInfo
modifier|*
name|from
parameter_list|,
name|bool
name|same_file
parameter_list|)
block|{
name|xkb_layout_index_t
name|i
decl_stmt|;
name|xkb_layout_index_t
name|groups_in_both
decl_stmt|;
name|enum
name|key_field
name|collide
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|verbosity
init|=
name|xkb_context_get_log_verbosity
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|clobber
init|=
operator|(
name|from
operator|->
name|merge
operator|!=
name|MERGE_AUGMENT
operator|)
decl_stmt|;
specifier|const
name|bool
name|report
init|=
operator|(
name|same_file
operator|&&
name|verbosity
operator|>
literal|0
operator|)
operator|||
name|verbosity
operator|>
literal|9
decl_stmt|;
if|if
condition|(
name|from
operator|->
name|merge
operator|==
name|MERGE_REPLACE
condition|)
block|{
name|ClearKeyInfo
argument_list|(
name|into
argument_list|)
expr_stmt|;
operator|*
name|into
operator|=
operator|*
name|from
expr_stmt|;
name|InitKeyInfo
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|groups_in_both
operator|=
name|MIN
argument_list|(
name|darray_size
argument_list|(
name|into
operator|->
name|groups
argument_list|)
argument_list|,
name|darray_size
argument_list|(
name|from
operator|->
name|groups
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|groups_in_both
condition|;
name|i
operator|++
control|)
name|MergeGroups
argument_list|(
name|info
argument_list|,
operator|&
name|darray_item
argument_list|(
name|into
operator|->
name|groups
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|darray_item
argument_list|(
name|from
operator|->
name|groups
argument_list|,
name|i
argument_list|)
argument_list|,
name|clobber
argument_list|,
name|report
argument_list|,
name|i
argument_list|,
name|into
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If @from has extra groups, just move them to @into. */
for|for
control|(
name|i
operator|=
name|groups_in_both
init|;
name|i
operator|<
name|darray_size
argument_list|(
name|from
operator|->
name|groups
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|darray_append
argument_list|(
name|into
operator|->
name|groups
argument_list|,
name|darray_item
argument_list|(
name|from
operator|->
name|groups
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|InitGroupInfo
argument_list|(
operator|&
name|darray_item
argument_list|(
name|from
operator|->
name|groups
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|UseNewKeyField
argument_list|(
name|KEY_FIELD_VMODMAP
argument_list|,
name|into
operator|->
name|defined
argument_list|,
name|from
operator|->
name|defined
argument_list|,
name|clobber
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|into
operator|->
name|vmodmap
operator|=
name|from
operator|->
name|vmodmap
expr_stmt|;
name|into
operator|->
name|defined
operator||=
name|KEY_FIELD_VMODMAP
expr_stmt|;
block|}
if|if
condition|(
name|UseNewKeyField
argument_list|(
name|KEY_FIELD_REPEAT
argument_list|,
name|into
operator|->
name|defined
argument_list|,
name|from
operator|->
name|defined
argument_list|,
name|clobber
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|into
operator|->
name|repeat
operator|=
name|from
operator|->
name|repeat
expr_stmt|;
name|into
operator|->
name|defined
operator||=
name|KEY_FIELD_REPEAT
expr_stmt|;
block|}
if|if
condition|(
name|UseNewKeyField
argument_list|(
name|KEY_FIELD_DEFAULT_TYPE
argument_list|,
name|into
operator|->
name|defined
argument_list|,
name|from
operator|->
name|defined
argument_list|,
name|clobber
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|into
operator|->
name|default_type
operator|=
name|from
operator|->
name|default_type
expr_stmt|;
name|into
operator|->
name|defined
operator||=
name|KEY_FIELD_DEFAULT_TYPE
expr_stmt|;
block|}
if|if
condition|(
name|UseNewKeyField
argument_list|(
name|KEY_FIELD_GROUPINFO
argument_list|,
name|into
operator|->
name|defined
argument_list|,
name|from
operator|->
name|defined
argument_list|,
name|clobber
argument_list|,
name|report
argument_list|,
operator|&
name|collide
argument_list|)
condition|)
block|{
name|into
operator|->
name|out_of_range_group_action
operator|=
name|from
operator|->
name|out_of_range_group_action
expr_stmt|;
name|into
operator|->
name|out_of_range_group_number
operator|=
name|from
operator|->
name|out_of_range_group_number
expr_stmt|;
name|into
operator|->
name|defined
operator||=
name|KEY_FIELD_GROUPINFO
expr_stmt|;
block|}
if|if
condition|(
name|collide
condition|)
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Symbol map for key %s redefined; "
literal|"Using %s definition for conflicting fields\n"
argument_list|,
name|KeyNameText
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|into
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|clobber
condition|?
literal|"first"
else|:
literal|"last"
operator|)
argument_list|)
expr_stmt|;
name|ClearKeyInfo
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|InitKeyInfo
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddKeySymbols
name|AddKeySymbols
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|,
name|bool
name|same_file
parameter_list|)
block|{
name|xkb_atom_t
name|real_name
decl_stmt|;
name|KeyInfo
modifier|*
name|iter
decl_stmt|;
comment|/*      * Don't keep aliases in the keys array; this guarantees that      * searching for keys to merge with by straight comparison (see the      * following loop) is enough, and we won't get multiple KeyInfo's      * for the same key because of aliases.      */
name|real_name
operator|=
name|XkbResolveKeyAlias
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|keyi
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_name
operator|!=
name|XKB_ATOM_NONE
condition|)
name|keyi
operator|->
name|name
operator|=
name|real_name
expr_stmt|;
name|darray_foreach
argument_list|(
argument|iter
argument_list|,
argument|info->keys
argument_list|)
if|if
condition|(
name|iter
operator|->
name|name
operator|==
name|keyi
operator|->
name|name
condition|)
return|return
name|MergeKeys
argument_list|(
name|info
argument_list|,
name|iter
argument_list|,
name|keyi
argument_list|,
name|same_file
argument_list|)
return|;
name|darray_append
argument_list|(
name|info
operator|->
name|keys
argument_list|,
operator|*
name|keyi
argument_list|)
expr_stmt|;
name|InitKeyInfo
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|keyi
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddModMapEntry
name|AddModMapEntry
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|ModMapEntry
modifier|*
name|new
parameter_list|)
block|{
name|ModMapEntry
modifier|*
name|old
decl_stmt|;
name|bool
name|clobber
init|=
operator|(
name|new
operator|->
name|merge
operator|!=
name|MERGE_AUGMENT
operator|)
decl_stmt|;
name|darray_foreach
argument_list|(
argument|old
argument_list|,
argument|info->modMaps
argument_list|)
block|{
name|xkb_mod_index_t
name|use
decl_stmt|,
name|ignore
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|->
name|haveSymbol
operator|!=
name|old
operator|->
name|haveSymbol
operator|)
operator|||
operator|(
name|new
operator|->
name|haveSymbol
operator|&&
name|new
operator|->
name|u
operator|.
name|keySym
operator|!=
name|old
operator|->
name|u
operator|.
name|keySym
operator|)
operator|||
operator|(
operator|!
name|new
operator|->
name|haveSymbol
operator|&&
name|new
operator|->
name|u
operator|.
name|keyName
operator|!=
name|old
operator|->
name|u
operator|.
name|keyName
operator|)
condition|)
continue|continue;
if|if
condition|(
name|new
operator|->
name|modifier
operator|==
name|old
operator|->
name|modifier
condition|)
return|return
name|true
return|;
name|use
operator|=
operator|(
name|clobber
condition|?
name|new
operator|->
name|modifier
else|:
name|old
operator|->
name|modifier
operator|)
expr_stmt|;
name|ignore
operator|=
operator|(
name|clobber
condition|?
name|old
operator|->
name|modifier
else|:
name|new
operator|->
name|modifier
operator|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|haveSymbol
condition|)
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Symbol \"%s\" added to modifier map for multiple modifiers; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|KeysymText
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|new
operator|->
name|u
operator|.
name|keySym
argument_list|)
argument_list|,
name|ModIndexText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|use
argument_list|)
argument_list|,
name|ModIndexText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|ignore
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Key \"%s\" added to modifier map for multiple modifiers; "
literal|"Using %s, ignoring %s\n"
argument_list|,
name|KeyNameText
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|new
operator|->
name|u
operator|.
name|keyName
argument_list|)
argument_list|,
name|ModIndexText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|use
argument_list|)
argument_list|,
name|ModIndexText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|ignore
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|->
name|modifier
operator|=
name|use
expr_stmt|;
return|return
name|true
return|;
block|}
name|darray_append
argument_list|(
name|info
operator|->
name|modMaps
argument_list|,
operator|*
name|new
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|void
DECL|function|MergeIncludedSymbols
name|MergeIncludedSymbols
parameter_list|(
name|SymbolsInfo
modifier|*
name|into
parameter_list|,
name|SymbolsInfo
modifier|*
name|from
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|KeyInfo
modifier|*
name|keyi
decl_stmt|;
name|ModMapEntry
modifier|*
name|mm
decl_stmt|;
name|xkb_atom_t
modifier|*
name|group_name
decl_stmt|;
name|xkb_layout_index_t
name|group_names_in_both
decl_stmt|;
if|if
condition|(
name|from
operator|->
name|errorCount
operator|>
literal|0
condition|)
block|{
name|into
operator|->
name|errorCount
operator|+=
name|from
operator|->
name|errorCount
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|into
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|into
operator|->
name|name
operator|=
name|from
operator|->
name|name
expr_stmt|;
name|from
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
name|group_names_in_both
operator|=
name|MIN
argument_list|(
name|darray_size
argument_list|(
name|into
operator|->
name|group_names
argument_list|)
argument_list|,
name|darray_size
argument_list|(
name|from
operator|->
name|group_names
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|group_names_in_both
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|darray_item
argument_list|(
name|from
operator|->
name|group_names
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|merge
operator|==
name|MERGE_AUGMENT
operator|&&
name|darray_item
argument_list|(
name|into
operator|->
name|group_names
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|darray_item
argument_list|(
name|into
operator|->
name|group_names
argument_list|,
name|i
argument_list|)
operator|=
name|darray_item
argument_list|(
name|from
operator|->
name|group_names
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* If @from has more, get them as well. */
name|darray_foreach_from
argument_list|(
argument|group_name
argument_list|,
argument|from->group_names
argument_list|,
argument|group_names_in_both
argument_list|)
name|darray_append
argument_list|(
name|into
operator|->
name|group_names
argument_list|,
operator|*
name|group_name
argument_list|)
expr_stmt|;
name|darray_foreach
argument_list|(
argument|keyi
argument_list|,
argument|from->keys
argument_list|)
block|{
name|keyi
operator|->
name|merge
operator|=
operator|(
name|merge
operator|==
name|MERGE_DEFAULT
condition|?
name|keyi
operator|->
name|merge
else|:
name|merge
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|AddKeySymbols
argument_list|(
name|into
argument_list|,
name|keyi
argument_list|,
name|false
argument_list|)
condition|)
name|into
operator|->
name|errorCount
operator|++
expr_stmt|;
block|}
name|darray_foreach
argument_list|(
argument|mm
argument_list|,
argument|from->modMaps
argument_list|)
block|{
name|mm
operator|->
name|merge
operator|=
operator|(
name|merge
operator|==
name|MERGE_DEFAULT
condition|?
name|mm
operator|->
name|merge
else|:
name|merge
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|AddModMapEntry
argument_list|(
name|into
argument_list|,
name|mm
argument_list|)
condition|)
name|into
operator|->
name|errorCount
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|HandleSymbolsFile
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|XkbFile
modifier|*
name|file
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
name|bool
DECL|function|HandleIncludeSymbols
name|HandleIncludeSymbols
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|IncludeStmt
modifier|*
name|include
parameter_list|)
block|{
name|SymbolsInfo
name|included
decl_stmt|;
name|InitSymbolsInfo
argument_list|(
operator|&
name|included
argument_list|,
name|info
operator|->
name|keymap
argument_list|,
name|info
operator|->
name|actions
argument_list|)
expr_stmt|;
name|included
operator|.
name|name
operator|=
name|include
operator|->
name|stmt
expr_stmt|;
name|include
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|IncludeStmt
modifier|*
name|stmt
init|=
name|include
init|;
name|stmt
condition|;
name|stmt
operator|=
name|stmt
operator|->
name|next_incl
control|)
block|{
name|SymbolsInfo
name|next_incl
decl_stmt|;
name|XkbFile
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|ProcessIncludeFile
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|stmt
argument_list|,
name|FILE_TYPE_SYMBOLS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|info
operator|->
name|errorCount
operator|+=
literal|10
expr_stmt|;
name|ClearSymbolsInfo
argument_list|(
operator|&
name|included
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|InitSymbolsInfo
argument_list|(
operator|&
name|next_incl
argument_list|,
name|info
operator|->
name|keymap
argument_list|,
name|info
operator|->
name|actions
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|modifier
condition|)
block|{
name|next_incl
operator|.
name|explicit_group
operator|=
name|atoi
argument_list|(
name|stmt
operator|->
name|modifier
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|next_incl
operator|.
name|explicit_group
operator|>=
name|XKB_MAX_GROUPS
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot set explicit group to %d - must be between 1..%d; "
literal|"Ignoring group number\n"
argument_list|,
name|next_incl
operator|.
name|explicit_group
operator|+
literal|1
argument_list|,
name|XKB_MAX_GROUPS
argument_list|)
expr_stmt|;
name|next_incl
operator|.
name|explicit_group
operator|=
name|info
operator|->
name|explicit_group
expr_stmt|;
block|}
block|}
else|else
block|{
name|next_incl
operator|.
name|explicit_group
operator|=
name|info
operator|->
name|explicit_group
expr_stmt|;
block|}
name|HandleSymbolsFile
argument_list|(
operator|&
name|next_incl
argument_list|,
name|file
argument_list|,
name|MERGE_OVERRIDE
argument_list|)
expr_stmt|;
name|MergeIncludedSymbols
argument_list|(
operator|&
name|included
argument_list|,
operator|&
name|next_incl
argument_list|,
name|stmt
operator|->
name|merge
argument_list|)
expr_stmt|;
name|ClearSymbolsInfo
argument_list|(
operator|&
name|next_incl
argument_list|)
expr_stmt|;
name|FreeXkbFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|MergeIncludedSymbols
argument_list|(
name|info
argument_list|,
operator|&
name|included
argument_list|,
name|include
operator|->
name|merge
argument_list|)
expr_stmt|;
name|ClearSymbolsInfo
argument_list|(
operator|&
name|included
argument_list|)
expr_stmt|;
return|return
operator|(
name|info
operator|->
name|errorCount
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_define
DECL|macro|SYMBOLS
define|#
directive|define
name|SYMBOLS
value|1
end_define
begin_define
DECL|macro|ACTIONS
define|#
directive|define
name|ACTIONS
value|2
end_define
begin_function
specifier|static
name|bool
DECL|function|GetGroupIndex
name|GetGroupIndex
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|unsigned
name|what
parameter_list|,
name|xkb_layout_index_t
modifier|*
name|ndx_rtrn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
name|what
operator|==
name|SYMBOLS
condition|?
literal|"symbols"
else|:
literal|"actions"
operator|)
decl_stmt|;
if|if
condition|(
name|arrayNdx
operator|==
name|NULL
condition|)
block|{
name|xkb_layout_index_t
name|i
decl_stmt|;
name|GroupInfo
modifier|*
name|groupi
decl_stmt|;
name|enum
name|group_field
name|field
init|=
operator|(
name|what
operator|==
name|SYMBOLS
condition|?
name|GROUP_FIELD_SYMS
else|:
name|GROUP_FIELD_ACTS
operator|)
decl_stmt|;
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|groupi
operator|->
name|defined
operator|&
name|field
operator|)
condition|)
block|{
operator|*
name|ndx_rtrn
operator|=
name|i
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|XKB_MAX_GROUPS
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Too many groups of %s for key %s (max %u); "
literal|"Ignoring %s defined for extra groups\n"
argument_list|,
name|name
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|,
name|XKB_MAX_GROUPS
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|darray_resize0
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|darray_size
argument_list|(
name|keyi
operator|->
name|groups
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|ndx_rtrn
operator|=
name|darray_size
argument_list|(
name|keyi
operator|->
name|groups
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|ExprResolveGroup
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|arrayNdx
argument_list|,
name|ndx_rtrn
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal group index for %s of key %s\n"
literal|"Definition with non-integer array index ignored\n"
argument_list|,
name|name
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|(
operator|*
name|ndx_rtrn
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|ndx_rtrn
operator|>=
name|darray_size
argument_list|(
name|keyi
operator|->
name|groups
argument_list|)
condition|)
name|darray_resize0
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
operator|*
name|ndx_rtrn
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|LookupKeysym
name|LookupKeysym
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|xkb_keysym_t
modifier|*
name|sym_rtrn
parameter_list|)
block|{
name|xkb_keysym_t
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
name|istreq
argument_list|(
name|str
argument_list|,
literal|"any"
argument_list|)
operator|||
name|istreq
argument_list|(
name|str
argument_list|,
literal|"nosymbol"
argument_list|)
condition|)
block|{
operator|*
name|sym_rtrn
operator|=
name|XKB_KEY_NoSymbol
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|istreq
argument_list|(
name|str
argument_list|,
literal|"none"
argument_list|)
operator|||
name|istreq
argument_list|(
name|str
argument_list|,
literal|"voidsymbol"
argument_list|)
condition|)
block|{
operator|*
name|sym_rtrn
operator|=
name|XKB_KEY_VoidSymbol
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sym
operator|=
name|xkb_keysym_from_name
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|XKB_KEY_NoSymbol
condition|)
block|{
operator|*
name|sym_rtrn
operator|=
name|sym
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddSymbolsToKey
name|AddSymbolsToKey
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|xkb_layout_index_t
name|ndx
decl_stmt|;
name|GroupInfo
modifier|*
name|groupi
decl_stmt|;
name|xkb_level_index_t
name|nLevels
decl_stmt|;
name|xkb_level_index_t
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|GetGroupIndex
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|,
name|arrayNdx
argument_list|,
name|SYMBOLS
argument_list|,
operator|&
name|ndx
argument_list|)
condition|)
return|return
name|false
return|;
name|groupi
operator|=
operator|&
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|groupi
operator|->
name|defined
operator||=
name|GROUP_FIELD_SYMS
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|value
operator|->
name|op
operator|!=
name|EXPR_KEYSYM_LIST
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Expected a list of symbols, found %s; "
literal|"Ignoring symbols for group %u of %s\n"
argument_list|,
name|expr_op_type_to_string
argument_list|(
name|value
operator|->
name|op
argument_list|)
argument_list|,
name|ndx
operator|+
literal|1
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|groupi
operator|->
name|defined
operator|&
name|GROUP_FIELD_SYMS
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Symbols for key %s, group %u already defined; "
literal|"Ignoring duplicate definition\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|,
name|ndx
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|nLevels
operator|=
name|darray_size
argument_list|(
name|value
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|darray_size
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
operator|<
name|nLevels
condition|)
name|darray_resize0
argument_list|(
name|groupi
operator|->
name|levels
argument_list|,
name|nLevels
argument_list|)
expr_stmt|;
name|groupi
operator|->
name|defined
operator||=
name|GROUP_FIELD_SYMS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nLevels
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|sym_index
decl_stmt|;
name|struct
name|xkb_level
modifier|*
name|leveli
init|=
operator|&
name|darray_item
argument_list|(
name|groupi
operator|->
name|levels
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|sym_index
operator|=
name|darray_item
argument_list|(
name|value
operator|->
name|value
operator|.
name|list
operator|.
name|symsMapIndex
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|leveli
operator|->
name|num_syms
operator|=
name|darray_item
argument_list|(
name|value
operator|->
name|value
operator|.
name|list
operator|.
name|symsNumEntries
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|leveli
operator|->
name|num_syms
operator|>
literal|1
condition|)
name|leveli
operator|->
name|u
operator|.
name|syms
operator|=
name|calloc
argument_list|(
name|leveli
operator|->
name|num_syms
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|leveli
operator|->
name|u
operator|.
name|syms
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|leveli
operator|->
name|num_syms
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|sym_name
init|=
name|darray_item
argument_list|(
name|value
operator|->
name|value
operator|.
name|list
operator|.
name|syms
argument_list|,
name|sym_index
operator|+
name|j
argument_list|)
decl_stmt|;
name|xkb_keysym_t
name|keysym
decl_stmt|;
if|if
condition|(
operator|!
name|LookupKeysym
argument_list|(
name|sym_name
argument_list|,
operator|&
name|keysym
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|group_name
init|=
literal|"unnamed"
decl_stmt|;
if|if
condition|(
name|ndx
operator|<
name|darray_size
argument_list|(
name|info
operator|->
name|group_names
argument_list|)
operator|&&
name|darray_item
argument_list|(
name|info
operator|->
name|group_names
argument_list|,
name|ndx
argument_list|)
condition|)
name|group_name
operator|=
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|darray_item
argument_list|(
name|info
operator|->
name|group_names
argument_list|,
name|ndx
argument_list|)
argument_list|)
expr_stmt|;
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Could not resolve keysym %s for key %s, group %u (%s), level %u\n"
argument_list|,
name|sym_name
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|,
name|ndx
operator|+
literal|1
argument_list|,
name|group_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ClearLevelInfo
argument_list|(
name|leveli
argument_list|)
expr_stmt|;
name|leveli
operator|->
name|num_syms
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|leveli
operator|->
name|num_syms
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|keysym
operator|==
name|XKB_KEY_NoSymbol
condition|)
name|leveli
operator|->
name|num_syms
operator|=
literal|0
expr_stmt|;
else|else
name|leveli
operator|->
name|u
operator|.
name|sym
operator|=
name|keysym
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leveli
operator|->
name|num_syms
operator|>
literal|1
condition|)
block|{
name|leveli
operator|->
name|u
operator|.
name|syms
index|[
name|j
index|]
operator|=
name|keysym
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|AddActionsToKey
name|AddActionsToKey
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|xkb_layout_index_t
name|ndx
decl_stmt|;
name|GroupInfo
modifier|*
name|groupi
decl_stmt|;
name|unsigned
name|int
name|nActs
decl_stmt|;
name|ExprDef
modifier|*
name|act
decl_stmt|;
name|union
name|xkb_action
modifier|*
name|toAct
decl_stmt|;
if|if
condition|(
operator|!
name|GetGroupIndex
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|,
name|arrayNdx
argument_list|,
name|ACTIONS
argument_list|,
operator|&
name|ndx
argument_list|)
condition|)
return|return
name|false
return|;
name|groupi
operator|=
operator|&
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|groupi
operator|->
name|defined
operator||=
name|GROUP_FIELD_ACTS
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|value
operator|->
name|op
operator|!=
name|EXPR_ACTION_LIST
condition|)
block|{
name|log_wsgo
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Bad expression type (%d) for action list value; "
literal|"Ignoring actions for group %u of %s\n"
argument_list|,
name|value
operator|->
name|op
argument_list|,
name|ndx
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|groupi
operator|->
name|defined
operator|&
name|GROUP_FIELD_ACTS
condition|)
block|{
name|log_wsgo
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Actions for key %s, group %u already defined\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|nActs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|act
operator|=
name|value
operator|->
name|value
operator|.
name|child
init|;
name|act
condition|;
name|act
operator|=
operator|(
name|ExprDef
operator|*
operator|)
name|act
operator|->
name|common
operator|.
name|next
control|)
name|nActs
operator|++
expr_stmt|;
if|if
condition|(
name|darray_size
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
operator|<
name|nActs
condition|)
name|darray_resize0
argument_list|(
name|groupi
operator|->
name|levels
argument_list|,
name|nActs
argument_list|)
expr_stmt|;
name|groupi
operator|->
name|defined
operator||=
name|GROUP_FIELD_ACTS
expr_stmt|;
name|act
operator|=
name|value
operator|->
name|value
operator|.
name|child
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nActs
condition|;
name|i
operator|++
control|)
block|{
name|toAct
operator|=
operator|&
name|darray_item
argument_list|(
name|groupi
operator|->
name|levels
argument_list|,
name|i
argument_list|)
operator|.
name|action
expr_stmt|;
if|if
condition|(
operator|!
name|HandleActionDef
argument_list|(
name|act
argument_list|,
name|info
operator|->
name|keymap
argument_list|,
name|toAct
argument_list|,
name|info
operator|->
name|actions
argument_list|)
condition|)
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal action definition for %s; "
literal|"Action for group %u/level %u ignored\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|,
name|ndx
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|act
operator|=
operator|(
name|ExprDef
operator|*
operator|)
name|act
operator|->
name|common
operator|.
name|next
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|repeatEntries
specifier|static
specifier|const
name|LookupEntry
name|repeatEntries
index|[]
init|=
block|{
block|{
literal|"true"
block|,
name|KEY_REPEAT_YES
block|}
block|,
block|{
literal|"yes"
block|,
name|KEY_REPEAT_YES
block|}
block|,
block|{
literal|"on"
block|,
name|KEY_REPEAT_YES
block|}
block|,
block|{
literal|"false"
block|,
name|KEY_REPEAT_NO
block|}
block|,
block|{
literal|"no"
block|,
name|KEY_REPEAT_NO
block|}
block|,
block|{
literal|"off"
block|,
name|KEY_REPEAT_NO
block|}
block|,
block|{
literal|"default"
block|,
name|KEY_REPEAT_UNDEFINED
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|bool
DECL|function|SetSymbolsField
name|SetSymbolsField
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|bool
name|ok
init|=
name|true
decl_stmt|;
name|struct
name|xkb_context
modifier|*
name|ctx
init|=
name|info
operator|->
name|keymap
operator|->
name|ctx
decl_stmt|;
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"type"
argument_list|)
condition|)
block|{
name|xkb_layout_index_t
name|ndx
decl_stmt|;
name|xkb_atom_t
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveString
argument_list|(
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|)
condition|)
name|log_vrb
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"The type field of a key symbol map must be a string; "
literal|"Ignoring illegal type definition\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arrayNdx
operator|==
name|NULL
condition|)
block|{
name|keyi
operator|->
name|default_type
operator|=
name|val
expr_stmt|;
name|keyi
operator|->
name|defined
operator||=
name|KEY_FIELD_DEFAULT_TYPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ExprResolveGroup
argument_list|(
name|ctx
argument_list|,
name|arrayNdx
argument_list|,
operator|&
name|ndx
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"Illegal group index for type of key %s; "
literal|"Definition with non-integer array index ignored\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|ndx
operator|--
expr_stmt|;
if|if
condition|(
name|ndx
operator|>=
name|darray_size
argument_list|(
name|keyi
operator|->
name|groups
argument_list|)
condition|)
name|darray_resize0
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|ndx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|ndx
argument_list|)
operator|.
name|type
operator|=
name|val
expr_stmt|;
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|ndx
argument_list|)
operator|.
name|defined
operator||=
name|GROUP_FIELD_TYPE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"symbols"
argument_list|)
condition|)
return|return
name|AddSymbolsToKey
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|,
name|arrayNdx
argument_list|,
name|value
argument_list|)
return|;
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"actions"
argument_list|)
condition|)
return|return
name|AddActionsToKey
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|,
name|arrayNdx
argument_list|,
name|value
argument_list|)
return|;
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"vmods"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"virtualmods"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"virtualmodifiers"
argument_list|)
condition|)
block|{
name|xkb_mod_mask_t
name|mask
decl_stmt|;
name|ok
operator|=
name|ExprResolveModMask
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|value
argument_list|,
name|MOD_VIRT
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|keyi
operator|->
name|vmodmap
operator|=
name|mask
expr_stmt|;
name|keyi
operator|->
name|defined
operator||=
name|KEY_FIELD_VMODMAP
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Expected a virtual modifier mask, found %s; "
literal|"Ignoring virtual modifiers definition for key %s\n"
argument_list|,
name|expr_op_type_to_string
argument_list|(
name|value
operator|->
name|op
argument_list|)
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"locking"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"lock"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"locks"
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Key behaviors not supported; "
literal|"Ignoring locking specification for key %s\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"radiogroup"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"permanentradiogroup"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"allownone"
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Radio groups not supported; "
literal|"Ignoring radio group specification for key %s\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"overlay"
argument_list|,
name|field
argument_list|)
operator|||
name|istreq_prefix
argument_list|(
literal|"permanentoverlay"
argument_list|,
name|field
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Overlays not supported; "
literal|"Ignoring overlay specification for key %s\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"repeating"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"repeats"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"repeat"
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|ok
operator|=
name|ExprResolveEnum
argument_list|(
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|,
name|repeatEntries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal repeat setting for %s; "
literal|"Non-boolean repeat setting ignored\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|keyi
operator|->
name|repeat
operator|=
name|val
expr_stmt|;
name|keyi
operator|->
name|defined
operator||=
name|KEY_FIELD_REPEAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groupswrap"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"wrapgroups"
argument_list|)
condition|)
block|{
name|bool
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveBoolean
argument_list|(
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|set
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal groupsWrap setting for %s; "
literal|"Non-boolean value ignored\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|set
condition|)
name|keyi
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_WRAP
expr_stmt|;
else|else
name|keyi
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_SATURATE
expr_stmt|;
name|keyi
operator|->
name|defined
operator||=
name|KEY_FIELD_GROUPINFO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groupsclamp"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"clampgroups"
argument_list|)
condition|)
block|{
name|bool
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveBoolean
argument_list|(
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|set
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal groupsClamp setting for %s; "
literal|"Non-boolean value ignored\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|set
condition|)
name|keyi
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_SATURATE
expr_stmt|;
else|else
name|keyi
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_WRAP
expr_stmt|;
name|keyi
operator|->
name|defined
operator||=
name|KEY_FIELD_GROUPINFO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groupsredirect"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"redirectgroups"
argument_list|)
condition|)
block|{
name|xkb_layout_index_t
name|grp
decl_stmt|;
if|if
condition|(
operator|!
name|ExprResolveGroup
argument_list|(
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|grp
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal group index for redirect of key %s; "
literal|"Definition with non-integer group ignored\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|keyi
operator|->
name|out_of_range_group_action
operator|=
name|RANGE_REDIRECT
expr_stmt|;
name|keyi
operator|->
name|out_of_range_group_number
operator|=
name|grp
operator|-
literal|1
expr_stmt|;
name|keyi
operator|->
name|defined
operator||=
name|KEY_FIELD_GROUPINFO
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Unknown field %s in a symbol interpretation; "
literal|"Definition ignored\n"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|SetGroupName
name|SetGroupName
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|ExprDef
modifier|*
name|arrayNdx
parameter_list|,
name|ExprDef
modifier|*
name|value
parameter_list|)
block|{
name|xkb_layout_index_t
name|group
decl_stmt|,
name|group_to_use
decl_stmt|;
name|xkb_atom_t
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|arrayNdx
condition|)
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"You must specify an index when specifying a group name; "
literal|"Group name definition without array subscript ignored\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ExprResolveGroup
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|arrayNdx
argument_list|,
operator|&
name|group
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal index in group name definition; "
literal|"Definition with non-integer array index ignored\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ExprResolveString
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|value
argument_list|,
operator|&
name|name
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Group name must be a string; "
literal|"Illegal name for group %d ignored\n"
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|explicit_group
operator|==
name|XKB_LAYOUT_INVALID
condition|)
block|{
name|group_to_use
operator|=
name|group
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|group
operator|-
literal|1
operator|==
literal|0
condition|)
block|{
name|group_to_use
operator|=
name|info
operator|->
name|explicit_group
expr_stmt|;
block|}
else|else
block|{
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"An explicit group was specified for the '%s' map, "
literal|"but it provides a name for a group other than Group1 (%d); "
literal|"Ignoring group name '%s'\n"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|group
argument_list|,
name|xkb_atom_text
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|group_to_use
operator|>=
name|darray_size
argument_list|(
name|info
operator|->
name|group_names
argument_list|)
condition|)
name|darray_resize0
argument_list|(
name|info
operator|->
name|group_names
argument_list|,
name|group_to_use
operator|+
literal|1
argument_list|)
expr_stmt|;
name|darray_item
argument_list|(
name|info
operator|->
name|group_names
argument_list|,
name|group_to_use
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|HandleGlobalVar
name|HandleGlobalVar
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|VarDef
modifier|*
name|stmt
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|ExprDef
modifier|*
name|arrayNdx
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|ExprResolveLhs
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|stmt
operator|->
name|name
argument_list|,
operator|&
name|elem
argument_list|,
operator|&
name|field
argument_list|,
operator|&
name|arrayNdx
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* internal error, already reported */
if|if
condition|(
name|elem
operator|&&
name|istreq
argument_list|(
name|elem
argument_list|,
literal|"key"
argument_list|)
condition|)
block|{
name|ret
operator|=
name|SetSymbolsField
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|default_key
argument_list|,
name|field
argument_list|,
name|arrayNdx
argument_list|,
name|stmt
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|elem
operator|&&
operator|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"name"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groupname"
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|SetGroupName
argument_list|(
name|info
argument_list|,
name|arrayNdx
argument_list|,
name|stmt
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|elem
operator|&&
operator|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groupswrap"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"wrapgroups"
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Global \"groupswrap\" not supported; Ignored\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|elem
operator|&&
operator|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groupsclamp"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"clampgroups"
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Global \"groupsclamp\" not supported; Ignored\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|elem
operator|&&
operator|(
name|istreq
argument_list|(
name|field
argument_list|,
literal|"groupsredirect"
argument_list|)
operator|||
name|istreq
argument_list|(
name|field
argument_list|,
literal|"redirectgroups"
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Global \"groupsredirect\" not supported; Ignored\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|elem
operator|&&
name|istreq
argument_list|(
name|field
argument_list|,
literal|"allownone"
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Radio groups not supported; "
literal|"Ignoring \"allownone\" specification\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|SetActionField
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|elem
argument_list|,
name|field
argument_list|,
name|arrayNdx
argument_list|,
name|stmt
operator|->
name|value
argument_list|,
name|info
operator|->
name|actions
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleSymbolsBody
name|HandleSymbolsBody
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|VarDef
modifier|*
name|def
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|)
block|{
name|bool
name|ok
init|=
name|true
decl_stmt|;
specifier|const
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|ExprDef
modifier|*
name|arrayNdx
decl_stmt|;
for|for
control|(
init|;
name|def
condition|;
name|def
operator|=
operator|(
name|VarDef
operator|*
operator|)
name|def
operator|->
name|common
operator|.
name|next
control|)
block|{
if|if
condition|(
name|def
operator|->
name|name
operator|&&
name|def
operator|->
name|name
operator|->
name|op
operator|==
name|EXPR_FIELD_REF
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Cannot set a global default value from within a key statement; "
literal|"Move statements to the global file scope\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|def
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|def
operator|->
name|value
operator|||
name|def
operator|->
name|value
operator|->
name|op
operator|==
name|EXPR_KEYSYM_LIST
condition|)
name|field
operator|=
literal|"symbols"
expr_stmt|;
else|else
name|field
operator|=
literal|"actions"
expr_stmt|;
name|arrayNdx
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
name|ExprResolveLhs
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|def
operator|->
name|name
argument_list|,
operator|&
name|elem
argument_list|,
operator|&
name|field
argument_list|,
operator|&
name|arrayNdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
name|ok
operator|=
name|SetSymbolsField
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|,
name|field
argument_list|,
name|arrayNdx
argument_list|,
name|def
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|SetExplicitGroup
name|SetExplicitGroup
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|)
block|{
name|xkb_layout_index_t
name|i
decl_stmt|;
name|GroupInfo
modifier|*
name|groupi
decl_stmt|;
name|bool
name|warn
init|=
name|false
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|explicit_group
operator|==
name|XKB_LAYOUT_INVALID
condition|)
return|return
name|true
return|;
name|darray_enumerate_from
argument_list|(
argument|i
argument_list|,
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|,
literal|1
argument_list|)
block|{
if|if
condition|(
name|groupi
operator|->
name|defined
condition|)
block|{
name|warn
operator|=
name|true
expr_stmt|;
name|ClearGroupInfo
argument_list|(
name|groupi
argument_list|)
expr_stmt|;
name|InitGroupInfo
argument_list|(
name|groupi
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|warn
condition|)
name|log_warn
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"For the map %s an explicit group specified, "
literal|"but key %s has more than one group defined; "
literal|"All groups except first one will be ignored\n"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
name|darray_resize0
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|info
operator|->
name|explicit_group
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|explicit_group
operator|>
literal|0
condition|)
block|{
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|info
operator|->
name|explicit_group
argument_list|)
operator|=
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|InitGroupInfo
argument_list|(
operator|&
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|HandleSymbolsDef
name|HandleSymbolsDef
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|SymbolsDef
modifier|*
name|stmt
parameter_list|)
block|{
name|KeyInfo
name|keyi
decl_stmt|;
name|xkb_layout_index_t
name|i
decl_stmt|;
name|keyi
operator|=
name|info
operator|->
name|default_key
expr_stmt|;
name|darray_init
argument_list|(
name|keyi
operator|.
name|groups
argument_list|)
expr_stmt|;
name|darray_copy
argument_list|(
name|keyi
operator|.
name|groups
argument_list|,
name|info
operator|->
name|default_key
operator|.
name|groups
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|darray_size
argument_list|(
name|keyi
operator|.
name|groups
argument_list|)
condition|;
name|i
operator|++
control|)
name|CopyGroupInfo
argument_list|(
operator|&
name|darray_item
argument_list|(
name|keyi
operator|.
name|groups
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|darray_item
argument_list|(
name|info
operator|->
name|default_key
operator|.
name|groups
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|keyi
operator|.
name|merge
operator|=
name|stmt
operator|->
name|merge
expr_stmt|;
name|keyi
operator|.
name|name
operator|=
name|stmt
operator|->
name|keyName
expr_stmt|;
if|if
condition|(
operator|!
name|HandleSymbolsBody
argument_list|(
name|info
argument_list|,
operator|(
name|VarDef
operator|*
operator|)
name|stmt
operator|->
name|symbols
argument_list|,
operator|&
name|keyi
argument_list|)
condition|)
block|{
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|SetExplicitGroup
argument_list|(
name|info
argument_list|,
operator|&
name|keyi
argument_list|)
condition|)
block|{
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|AddKeySymbols
argument_list|(
name|info
argument_list|,
operator|&
name|keyi
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|HandleModMapDef
name|HandleModMapDef
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|ModMapDef
modifier|*
name|def
parameter_list|)
block|{
name|ExprDef
modifier|*
name|key
decl_stmt|;
name|ModMapEntry
name|tmp
decl_stmt|;
name|xkb_mod_index_t
name|ndx
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|struct
name|xkb_context
modifier|*
name|ctx
init|=
name|info
operator|->
name|keymap
operator|->
name|ctx
decl_stmt|;
name|ndx
operator|=
name|ModNameToIndex
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|def
operator|->
name|modifier
argument_list|,
name|MOD_REAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|==
name|XKB_MOD_INVALID
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Illegal modifier map definition; "
literal|"Ignoring map for non-modifier \"%s\"\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|ctx
argument_list|,
name|def
operator|->
name|modifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ok
operator|=
name|true
expr_stmt|;
name|tmp
operator|.
name|modifier
operator|=
name|ndx
expr_stmt|;
for|for
control|(
name|key
operator|=
name|def
operator|->
name|keys
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
operator|(
name|ExprDef
operator|*
operator|)
name|key
operator|->
name|common
operator|.
name|next
control|)
block|{
name|xkb_keysym_t
name|sym
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|op
operator|==
name|EXPR_VALUE
operator|&&
name|key
operator|->
name|value_type
operator|==
name|EXPR_TYPE_KEYNAME
condition|)
block|{
name|tmp
operator|.
name|haveSymbol
operator|=
name|false
expr_stmt|;
name|tmp
operator|.
name|u
operator|.
name|keyName
operator|=
name|key
operator|->
name|value
operator|.
name|keyName
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ExprResolveKeySym
argument_list|(
name|ctx
argument_list|,
name|key
argument_list|,
operator|&
name|sym
argument_list|)
condition|)
block|{
name|tmp
operator|.
name|haveSymbol
operator|=
name|true
expr_stmt|;
name|tmp
operator|.
name|u
operator|.
name|keySym
operator|=
name|sym
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Modmap entries may contain only key names or keysyms; "
literal|"Illegal definition for %s modifier ignored\n"
argument_list|,
name|ModIndexText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|tmp
operator|.
name|modifier
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ok
operator|=
name|AddModMapEntry
argument_list|(
name|info
argument_list|,
operator|&
name|tmp
argument_list|)
operator|&&
name|ok
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|HandleSymbolsFile
name|HandleSymbolsFile
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|XkbFile
modifier|*
name|file
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|free
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|strdup_safe
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ParseCommon
modifier|*
name|stmt
init|=
name|file
operator|->
name|defs
init|;
name|stmt
condition|;
name|stmt
operator|=
name|stmt
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|stmt
operator|->
name|type
condition|)
block|{
case|case
name|STMT_INCLUDE
case|:
name|ok
operator|=
name|HandleIncludeSymbols
argument_list|(
name|info
argument_list|,
operator|(
name|IncludeStmt
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_SYMBOLS
case|:
name|ok
operator|=
name|HandleSymbolsDef
argument_list|(
name|info
argument_list|,
operator|(
name|SymbolsDef
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_VAR
case|:
name|ok
operator|=
name|HandleGlobalVar
argument_list|(
name|info
argument_list|,
operator|(
name|VarDef
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_VMOD
case|:
name|ok
operator|=
name|HandleVModDef
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
operator|(
name|VModDef
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_MODMAP
case|:
name|ok
operator|=
name|HandleModMapDef
argument_list|(
name|info
argument_list|,
operator|(
name|ModMapDef
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Interpretation files may not include other types; "
literal|"Ignoring %s\n"
argument_list|,
name|stmt_type_to_string
argument_list|(
name|stmt
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|errorCount
operator|>
literal|10
condition|)
block|{
name|log_err
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Abandoning symbols file \"%s\"\n"
argument_list|,
name|file
operator|->
name|topName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/**  * Given a keysym @sym, return a key which generates it, or NULL.  * This is used for example in a modifier map definition, such as:  *      modifier_map Lock           { Caps_Lock };  * where we want to add the Lock modifier to the modmap of the key  * which matches the keysym Caps_Lock.  * Since there can be many keys which generates the keysym, the key  * is chosen first by lowest group in which the keysym appears, than  * by lowest level and than by lowest key code.  */
end_comment
begin_function
specifier|static
name|struct
name|xkb_key
modifier|*
DECL|function|FindKeyForSymbol
name|FindKeyForSymbol
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_keysym_t
name|sym
parameter_list|)
block|{
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|,
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|xkb_layout_index_t
name|group
decl_stmt|,
name|min_group
init|=
name|UINT32_MAX
decl_stmt|;
name|xkb_level_index_t
name|level
decl_stmt|,
name|min_level
init|=
name|UINT16_MAX
decl_stmt|;
name|xkb_foreach_key
argument_list|(
argument|key
argument_list|,
argument|keymap
argument_list|)
block|{
for|for
control|(
name|group
operator|=
literal|0
init|;
name|group
operator|<
name|key
operator|->
name|num_groups
condition|;
name|group
operator|++
control|)
block|{
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|XkbKeyGroupWidth
argument_list|(
name|key
argument_list|,
name|group
argument_list|)
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|levels
index|[
name|level
index|]
operator|.
name|num_syms
operator|!=
literal|1
operator|||
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|levels
index|[
name|level
index|]
operator|.
name|u
operator|.
name|sym
operator|!=
name|sym
condition|)
continue|continue;
comment|/*                  * If the keysym was found in a group or level> 0, we must                  * keep looking since we might find a key in which the keysym                  * is in a lower group or level.                  */
if|if
condition|(
name|group
operator|<
name|min_group
operator|||
operator|(
name|group
operator|==
name|min_group
operator|&&
name|level
operator|<
name|min_level
operator|)
condition|)
block|{
name|ret
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|group
operator|==
literal|0
operator|&&
name|level
operator|==
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
else|else
block|{
name|min_group
operator|=
name|group
expr_stmt|;
name|min_level
operator|=
name|level
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Find an appropriate type for a group and return its name.  *  * Simple recipe:  * - ONE_LEVEL for width 0/1  * - ALPHABETIC for 2 shift levels, with lower/upercase keysyms  * - KEYPAD for keypad keys.  * - TWO_LEVEL for other 2 shift level keys.  * and the same for four level keys.  *  * FIXME: Decide how to handle multiple-syms-per-level, and do it.  */
end_comment
begin_function
specifier|static
name|xkb_atom_t
DECL|function|FindAutomaticType
name|FindAutomaticType
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|GroupInfo
modifier|*
name|groupi
parameter_list|)
block|{
name|xkb_keysym_t
name|sym0
decl_stmt|,
name|sym1
decl_stmt|,
name|sym2
decl_stmt|,
name|sym3
decl_stmt|;
name|xkb_level_index_t
name|width
init|=
name|darray_size
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
decl_stmt|;
DECL|macro|GET_SYM
define|#
directive|define
name|GET_SYM
parameter_list|(
name|level
parameter_list|)
define|\
value|(darray_item(groupi->levels, level).num_syms == 0 ? \         XKB_KEY_NoSymbol : \      darray_item(groupi->levels, level).num_syms == 1 ? \         darray_item(groupi->levels, level).u.sym : \
comment|/* num_syms> 1 */
value|\         darray_item(groupi->levels, level).u.syms[0])
if|if
condition|(
name|width
operator|==
literal|1
operator|||
name|width
operator|<=
literal|0
condition|)
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"ONE_LEVEL"
argument_list|)
return|;
name|sym0
operator|=
name|GET_SYM
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sym1
operator|=
name|GET_SYM
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|xkb_keysym_is_lower
argument_list|(
name|sym0
argument_list|)
operator|&&
name|xkb_keysym_is_upper
argument_list|(
name|sym1
argument_list|)
condition|)
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"ALPHABETIC"
argument_list|)
return|;
if|if
condition|(
name|xkb_keysym_is_keypad
argument_list|(
name|sym0
argument_list|)
operator|||
name|xkb_keysym_is_keypad
argument_list|(
name|sym1
argument_list|)
condition|)
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"KEYPAD"
argument_list|)
return|;
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"TWO_LEVEL"
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|<=
literal|4
condition|)
block|{
if|if
condition|(
name|xkb_keysym_is_lower
argument_list|(
name|sym0
argument_list|)
operator|&&
name|xkb_keysym_is_upper
argument_list|(
name|sym1
argument_list|)
condition|)
block|{
name|sym2
operator|=
name|GET_SYM
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sym3
operator|=
operator|(
name|width
operator|==
literal|4
condition|?
name|GET_SYM
argument_list|(
literal|3
argument_list|)
else|:
name|XKB_KEY_NoSymbol
operator|)
expr_stmt|;
if|if
condition|(
name|xkb_keysym_is_lower
argument_list|(
name|sym2
argument_list|)
operator|&&
name|xkb_keysym_is_upper
argument_list|(
name|sym3
argument_list|)
condition|)
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"FOUR_LEVEL_ALPHABETIC"
argument_list|)
return|;
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"FOUR_LEVEL_SEMIALPHABETIC"
argument_list|)
return|;
block|}
if|if
condition|(
name|xkb_keysym_is_keypad
argument_list|(
name|sym0
argument_list|)
operator|||
name|xkb_keysym_is_keypad
argument_list|(
name|sym1
argument_list|)
condition|)
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"FOUR_LEVEL_KEYPAD"
argument_list|)
return|;
return|return
name|xkb_atom_intern
argument_list|(
name|ctx
argument_list|,
literal|"FOUR_LEVEL"
argument_list|)
return|;
block|}
return|return
name|XKB_ATOM_NONE
return|;
DECL|macro|GET_SYM
undef|#
directive|undef
name|GET_SYM
block|}
end_function
begin_function
specifier|static
specifier|const
name|struct
name|xkb_key_type
modifier|*
DECL|function|FindTypeForGroup
name|FindTypeForGroup
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|,
name|xkb_layout_index_t
name|group
parameter_list|,
name|bool
modifier|*
name|explicit_type
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|GroupInfo
modifier|*
name|groupi
init|=
operator|&
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|group
argument_list|)
decl_stmt|;
name|xkb_atom_t
name|type_name
init|=
name|groupi
operator|->
name|type
decl_stmt|;
operator|*
name|explicit_type
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|type_name
operator|==
name|XKB_ATOM_NONE
condition|)
block|{
if|if
condition|(
name|keyi
operator|->
name|default_type
operator|!=
name|XKB_ATOM_NONE
condition|)
block|{
name|type_name
operator|=
name|keyi
operator|->
name|default_type
expr_stmt|;
block|}
else|else
block|{
name|type_name
operator|=
name|FindAutomaticType
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|groupi
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
operator|!=
name|XKB_ATOM_NONE
condition|)
operator|*
name|explicit_type
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type_name
operator|==
name|XKB_ATOM_NONE
condition|)
block|{
name|log_warn
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"Couldn't find an automatic type for key '%s' group %d with %lu levels; "
literal|"Using the default type\n"
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|keyi
operator|->
name|name
argument_list|)
argument_list|,
name|group
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|darray_size
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|use_default
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keymap
operator|->
name|num_types
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|keymap
operator|->
name|types
index|[
name|i
index|]
operator|.
name|name
operator|==
name|type_name
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|keymap
operator|->
name|num_types
condition|)
block|{
name|log_warn
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"The type \"%s\" for key '%s' group %d was not previously defined; "
literal|"Using the default type\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|type_name
argument_list|)
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|keyi
operator|->
name|name
argument_list|)
argument_list|,
name|group
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|use_default
goto|;
block|}
return|return
operator|&
name|keymap
operator|->
name|types
index|[
name|i
index|]
return|;
name|use_default
label|:
comment|/*      * Index 0 is guaranteed to contain something, usually      * ONE_LEVEL or at least some default one-level type.      */
return|return
operator|&
name|keymap
operator|->
name|types
index|[
literal|0
index|]
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|CopySymbolsDef
name|CopySymbolsDef
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|KeyInfo
modifier|*
name|keyi
parameter_list|)
block|{
name|struct
name|xkb_keymap
modifier|*
name|keymap
init|=
name|info
operator|->
name|keymap
decl_stmt|;
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|GroupInfo
modifier|*
name|groupi
decl_stmt|;
specifier|const
name|GroupInfo
modifier|*
name|group0
decl_stmt|;
name|xkb_layout_index_t
name|i
decl_stmt|;
comment|/*      * The name is guaranteed to be real and not an alias (see      * AddKeySymbols), so 'false' is safe here.      */
name|key
operator|=
name|XkbKeyByName
argument_list|(
name|keymap
argument_list|,
name|keyi
operator|->
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Key %s not found in keycodes; Symbols ignored\n"
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Find the range of groups we need. */
name|key
operator|->
name|num_groups
operator|=
literal|0
expr_stmt|;
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|)
if|if
condition|(
name|groupi
operator|->
name|defined
condition|)
name|key
operator|->
name|num_groups
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|num_groups
operator|<=
literal|0
condition|)
return|return
name|false
return|;
comment|/* WSGO */
name|darray_resize
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
name|key
operator|->
name|num_groups
argument_list|)
expr_stmt|;
comment|/*      * If there are empty groups between non-empty ones, fill them with data      * from the first group.      * We can make a wrong assumption here. But leaving gaps is worse.      */
name|group0
operator|=
operator|&
name|darray_item
argument_list|(
name|keyi
operator|->
name|groups
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|darray_foreach_from
argument_list|(
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|,
literal|1
argument_list|)
block|{
if|if
condition|(
name|groupi
operator|->
name|defined
condition|)
continue|continue;
name|CopyGroupInfo
argument_list|(
name|groupi
argument_list|,
name|group0
argument_list|)
expr_stmt|;
block|}
name|key
operator|->
name|groups
operator|=
name|calloc
argument_list|(
name|key
operator|->
name|num_groups
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|key
operator|->
name|groups
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find and assign the groups' types in the keymap. */
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|)
block|{
specifier|const
name|struct
name|xkb_key_type
modifier|*
name|type
decl_stmt|;
name|bool
name|explicit_type
decl_stmt|;
name|type
operator|=
name|FindTypeForGroup
argument_list|(
name|keymap
argument_list|,
name|keyi
argument_list|,
name|i
argument_list|,
operator|&
name|explicit_type
argument_list|)
expr_stmt|;
comment|/* Always have as many levels as the type specifies. */
if|if
condition|(
name|type
operator|->
name|num_levels
operator|<
name|darray_size
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
condition|)
block|{
name|struct
name|xkb_level
modifier|*
name|leveli
decl_stmt|;
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"Type \"%s\" has %d levels, but %s has %d levels; "
literal|"Ignoring extra symbols\n"
argument_list|,
name|xkb_atom_text
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
argument_list|,
name|type
operator|->
name|num_levels
argument_list|,
name|KeyInfoText
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|darray_size
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
argument_list|)
expr_stmt|;
name|darray_foreach_from
argument_list|(
argument|leveli
argument_list|,
argument|groupi->levels
argument_list|,
argument|type->num_levels
argument_list|)
name|ClearLevelInfo
argument_list|(
name|leveli
argument_list|)
expr_stmt|;
block|}
name|darray_resize0
argument_list|(
name|groupi
operator|->
name|levels
argument_list|,
name|type
operator|->
name|num_levels
argument_list|)
expr_stmt|;
name|key
operator|->
name|groups
index|[
name|i
index|]
operator|.
name|explicit_type
operator|=
name|explicit_type
expr_stmt|;
name|key
operator|->
name|groups
index|[
name|i
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Copy levels. */
name|darray_enumerate
argument_list|(
argument|i
argument_list|,
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|)
block|{
name|key
operator|->
name|groups
index|[
name|i
index|]
operator|.
name|levels
operator|=
name|darray_mem
argument_list|(
name|groupi
operator|->
name|levels
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|groupi
operator|->
name|levels
argument_list|)
expr_stmt|;
block|}
name|key
operator|->
name|out_of_range_group_number
operator|=
name|keyi
operator|->
name|out_of_range_group_number
expr_stmt|;
name|key
operator|->
name|out_of_range_group_action
operator|=
name|keyi
operator|->
name|out_of_range_group_action
expr_stmt|;
if|if
condition|(
name|keyi
operator|->
name|defined
operator|&
name|KEY_FIELD_VMODMAP
condition|)
block|{
name|key
operator|->
name|vmodmap
operator|=
name|keyi
operator|->
name|vmodmap
expr_stmt|;
name|key
operator|->
name|explicit
operator||=
name|EXPLICIT_VMODMAP
expr_stmt|;
block|}
if|if
condition|(
name|keyi
operator|->
name|repeat
operator|!=
name|KEY_REPEAT_UNDEFINED
condition|)
block|{
name|key
operator|->
name|repeats
operator|=
operator|(
name|keyi
operator|->
name|repeat
operator|==
name|KEY_REPEAT_YES
operator|)
expr_stmt|;
name|key
operator|->
name|explicit
operator||=
name|EXPLICIT_REPEAT
expr_stmt|;
block|}
name|darray_foreach
argument_list|(
argument|groupi
argument_list|,
argument|keyi->groups
argument_list|)
block|{
if|if
condition|(
name|groupi
operator|->
name|defined
operator|&
name|GROUP_FIELD_ACTS
condition|)
block|{
name|key
operator|->
name|explicit
operator||=
name|EXPLICIT_INTERP
expr_stmt|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|CopyModMapDef
name|CopyModMapDef
parameter_list|(
name|SymbolsInfo
modifier|*
name|info
parameter_list|,
name|ModMapEntry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|struct
name|xkb_keymap
modifier|*
name|keymap
init|=
name|info
operator|->
name|keymap
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|haveSymbol
condition|)
block|{
name|key
operator|=
name|XkbKeyByName
argument_list|(
name|keymap
argument_list|,
name|entry
operator|->
name|u
operator|.
name|keyName
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Key %s not found in keycodes; "
literal|"Modifier map entry for %s not updated\n"
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|entry
operator|->
name|u
operator|.
name|keyName
argument_list|)
argument_list|,
name|ModIndexText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|entry
operator|->
name|modifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|key
operator|=
name|FindKeyForSymbol
argument_list|(
name|keymap
argument_list|,
name|entry
operator|->
name|u
operator|.
name|keySym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|log_vrb
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Key \"%s\" not found in symbol map; "
literal|"Modifier map entry for %s not updated\n"
argument_list|,
name|KeysymText
argument_list|(
name|info
operator|->
name|keymap
operator|->
name|ctx
argument_list|,
name|entry
operator|->
name|u
operator|.
name|keySym
argument_list|)
argument_list|,
name|ModIndexText
argument_list|(
name|info
operator|->
name|keymap
argument_list|,
name|entry
operator|->
name|modifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|key
operator|->
name|modmap
operator||=
operator|(
literal|1
operator|<<
name|entry
operator|->
name|modifier
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|CopySymbolsToKeymap
name|CopySymbolsToKeymap
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|SymbolsInfo
modifier|*
name|info
parameter_list|)
block|{
name|KeyInfo
modifier|*
name|keyi
decl_stmt|;
name|ModMapEntry
modifier|*
name|mm
decl_stmt|;
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
name|keymap
operator|->
name|symbols_section_name
operator|=
name|strdup_safe
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|num_group_names
operator|=
name|darray_size
argument_list|(
name|info
operator|->
name|group_names
argument_list|)
expr_stmt|;
name|keymap
operator|->
name|group_names
operator|=
name|darray_mem
argument_list|(
name|info
operator|->
name|group_names
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|darray_init
argument_list|(
name|info
operator|->
name|group_names
argument_list|)
expr_stmt|;
name|darray_foreach
argument_list|(
argument|keyi
argument_list|,
argument|info->keys
argument_list|)
if|if
condition|(
operator|!
name|CopySymbolsDef
argument_list|(
name|info
argument_list|,
name|keyi
argument_list|)
condition|)
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
if|if
condition|(
name|xkb_context_get_log_verbosity
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|)
operator|>
literal|3
condition|)
block|{
name|xkb_foreach_key
argument_list|(
argument|key
argument_list|,
argument|keymap
argument_list|)
block|{
if|if
condition|(
name|key
operator|->
name|name
operator|==
name|XKB_ATOM_NONE
condition|)
continue|continue;
if|if
condition|(
name|key
operator|->
name|num_groups
operator|<
literal|1
condition|)
name|log_info
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
literal|"No symbols defined for %s\n"
argument_list|,
name|KeyNameText
argument_list|(
name|keymap
operator|->
name|ctx
argument_list|,
name|key
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|darray_foreach
argument_list|(
argument|mm
argument_list|,
argument|info->modMaps
argument_list|)
if|if
condition|(
operator|!
name|CopyModMapDef
argument_list|(
name|info
argument_list|,
name|mm
argument_list|)
condition|)
name|info
operator|->
name|errorCount
operator|++
expr_stmt|;
comment|/* XXX: If we don't ignore errorCount, things break. */
return|return
name|true
return|;
block|}
end_function
begin_function
name|bool
DECL|function|CompileSymbols
name|CompileSymbols
parameter_list|(
name|XkbFile
modifier|*
name|file
parameter_list|,
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|merge_mode
name|merge
parameter_list|)
block|{
name|SymbolsInfo
name|info
decl_stmt|;
name|ActionsInfo
modifier|*
name|actions
decl_stmt|;
name|actions
operator|=
name|NewActionsInfo
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|actions
condition|)
return|return
name|false
return|;
name|InitSymbolsInfo
argument_list|(
operator|&
name|info
argument_list|,
name|keymap
argument_list|,
name|actions
argument_list|)
expr_stmt|;
name|info
operator|.
name|default_key
operator|.
name|merge
operator|=
name|merge
expr_stmt|;
name|HandleSymbolsFile
argument_list|(
operator|&
name|info
argument_list|,
name|file
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|darray_empty
argument_list|(
name|info
operator|.
name|keys
argument_list|)
condition|)
goto|goto
name|err_info
goto|;
if|if
condition|(
name|info
operator|.
name|errorCount
operator|!=
literal|0
condition|)
goto|goto
name|err_info
goto|;
if|if
condition|(
operator|!
name|CopySymbolsToKeymap
argument_list|(
name|keymap
argument_list|,
operator|&
name|info
argument_list|)
condition|)
goto|goto
name|err_info
goto|;
name|ClearSymbolsInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|FreeActionsInfo
argument_list|(
name|actions
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|err_info
label|:
name|FreeActionsInfo
argument_list|(
name|actions
argument_list|)
expr_stmt|;
name|ClearSymbolsInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function
end_unit
