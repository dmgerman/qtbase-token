begin_unit
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  */
end_comment
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|"xkbcommon/xkbcommon.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|"context.h"
end_include
begin_struct
DECL|struct|xkb_context
struct|struct
name|xkb_context
block|{
DECL|member|refcnt
name|int
name|refcnt
decl_stmt|;
DECL|member|log_fn
name|ATTR_PRINTF
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
name|void
function_decl|(
modifier|*
name|log_fn
function_decl|)
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
DECL|member|log_level
name|enum
name|xkb_log_level
name|log_level
decl_stmt|;
DECL|member|log_verbosity
name|int
name|log_verbosity
decl_stmt|;
DECL|member|user_data
name|void
modifier|*
name|user_data
decl_stmt|;
DECL|member|names_dflt
name|struct
name|xkb_rule_names
name|names_dflt
decl_stmt|;
DECL|member|includes
name|darray
argument_list|(
argument|char *
argument_list|)
name|includes
expr_stmt|;
DECL|member|failed_includes
name|darray
argument_list|(
argument|char *
argument_list|)
name|failed_includes
expr_stmt|;
DECL|member|atom_table
name|struct
name|atom_table
modifier|*
name|atom_table
decl_stmt|;
comment|/* Buffer for the *Text() functions. */
DECL|member|text_buffer
name|char
name|text_buffer
index|[
literal|2048
index|]
decl_stmt|;
DECL|member|text_next
name|size_t
name|text_next
decl_stmt|;
DECL|member|use_environment_names
name|unsigned
name|int
name|use_environment_names
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/**  * Append one directory to the context's include path.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_include_path_append
name|xkb_context_include_path_append
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|err
goto|;
name|err
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|stat_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EACCESS
argument_list|)
if|if
condition|(
name|eaccess
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EUIDACCESS
argument_list|)
if|if
condition|(
name|euidaccess
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
name|darray_append
argument_list|(
name|ctx
operator|->
name|includes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|darray_append
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Append the default include directories to the context.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_include_path_append_default
name|xkb_context_include_path_append_default
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|home
decl_stmt|;
name|char
modifier|*
name|user_path
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator||=
name|xkb_context_include_path_append
argument_list|(
name|ctx
argument_list|,
name|DFLT_XKB_CONFIG_ROOT
argument_list|)
expr_stmt|;
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|home
condition|)
return|return
name|ret
return|;
name|err
operator|=
name|asprintf
argument_list|(
operator|&
name|user_path
argument_list|,
literal|"%s/.xkb"
argument_list|,
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
return|return
name|ret
return|;
name|ret
operator||=
name|xkb_context_include_path_append
argument_list|(
name|ctx
argument_list|,
name|user_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|user_path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Remove all entries in the context's include path.  */
end_comment
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_include_path_clear
name|xkb_context_include_path_clear
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|path
decl_stmt|;
name|darray_foreach
argument_list|(
argument|path
argument_list|,
argument|ctx->includes
argument_list|)
name|free
argument_list|(
operator|*
name|path
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|ctx
operator|->
name|includes
argument_list|)
expr_stmt|;
name|darray_foreach
argument_list|(
argument|path
argument_list|,
argument|ctx->failed_includes
argument_list|)
name|free
argument_list|(
operator|*
name|path
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * xkb_context_include_path_clear() + xkb_context_include_path_append_default()  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_include_path_reset_defaults
name|xkb_context_include_path_reset_defaults
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
name|xkb_context_include_path_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|xkb_context_include_path_append_default
argument_list|(
name|ctx
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns the number of entries in the context's include path.  */
end_comment
begin_function
name|XKB_EXPORT
name|unsigned
name|int
DECL|function|xkb_context_num_include_paths
name|xkb_context_num_include_paths
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|darray_size
argument_list|(
name|ctx
operator|->
name|includes
argument_list|)
return|;
block|}
end_function
begin_function
name|unsigned
name|int
DECL|function|xkb_context_num_failed_include_paths
name|xkb_context_num_failed_include_paths
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|darray_size
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns the given entry in the context's include path, or NULL if an  * invalid index is passed.  */
end_comment
begin_function
name|XKB_EXPORT
specifier|const
name|char
modifier|*
DECL|function|xkb_context_include_path_get
name|xkb_context_include_path_get
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|xkb_context_num_include_paths
argument_list|(
name|ctx
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|darray_item
argument_list|(
name|ctx
operator|->
name|includes
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_context_failed_include_path_get
name|xkb_context_failed_include_path_get
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|xkb_context_num_failed_include_paths
argument_list|(
name|ctx
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|darray_item
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Take a new reference on the context.  */
end_comment
begin_function
name|XKB_EXPORT
name|struct
name|xkb_context
modifier|*
DECL|function|xkb_context_ref
name|xkb_context_ref
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function
begin_comment
comment|/**  * Drop an existing reference on the context, and free it if the refcnt is  * now 0.  */
end_comment
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_unref
name|xkb_context_unref
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ctx
operator|||
operator|--
name|ctx
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
name|xkb_context_include_path_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|atom_table_free
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|log_level_to_prefix
name|log_level_to_prefix
parameter_list|(
name|enum
name|xkb_log_level
name|level
parameter_list|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|XKB_LOG_LEVEL_DEBUG
case|:
return|return
literal|"Debug:"
return|;
case|case
name|XKB_LOG_LEVEL_INFO
case|:
return|return
literal|"Info:"
return|;
case|case
name|XKB_LOG_LEVEL_WARNING
case|:
return|return
literal|"Warning:"
return|;
case|case
name|XKB_LOG_LEVEL_ERROR
case|:
return|return
literal|"Error:"
return|;
case|case
name|XKB_LOG_LEVEL_CRITICAL
case|:
return|return
literal|"Critical:"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_macro
name|ATTR_PRINTF
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
end_macro
begin_function
specifier|static
name|void
DECL|function|default_log_fn
name|default_log_fn
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|log_level_to_prefix
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-10s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|enum
name|xkb_log_level
DECL|function|log_level
name|log_level
parameter_list|(
specifier|const
name|char
modifier|*
name|level
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|enum
name|xkb_log_level
name|lvl
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|lvl
operator|=
name|strtol
argument_list|(
name|level
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
operator|(
name|endptr
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|isspace
argument_list|(
name|endptr
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|lvl
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"crit"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_CRITICAL
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"err"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_ERROR
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"warn"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_WARNING
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"info"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_INFO
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"debug"
argument_list|,
name|level
argument_list|)
operator|||
name|istreq_prefix
argument_list|(
literal|"dbg"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_DEBUG
return|;
return|return
name|XKB_LOG_LEVEL_ERROR
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|log_verbosity
name|log_verbosity
parameter_list|(
specifier|const
name|char
modifier|*
name|verbosity
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|int
name|v
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|strtol
argument_list|(
name|verbosity
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|v
return|;
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_XKB_VARIANT
end_ifndef
begin_define
DECL|macro|DEFAULT_XKB_VARIANT
define|#
directive|define
name|DEFAULT_XKB_VARIANT
value|NULL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_XKB_OPTIONS
end_ifndef
begin_define
DECL|macro|DEFAULT_XKB_OPTIONS
define|#
directive|define
name|DEFAULT_XKB_OPTIONS
value|NULL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/**  * Create a new context.  */
end_comment
begin_function
name|XKB_EXPORT
name|struct
name|xkb_context
modifier|*
DECL|function|xkb_context_new
name|xkb_context_new
parameter_list|(
name|enum
name|xkb_context_flags
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|struct
name|xkb_context
modifier|*
name|ctx
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
name|NULL
return|;
name|ctx
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|log_fn
operator|=
name|default_log_fn
expr_stmt|;
name|ctx
operator|->
name|log_level
operator|=
name|XKB_LOG_LEVEL_ERROR
expr_stmt|;
name|ctx
operator|->
name|log_verbosity
operator|=
literal|0
expr_stmt|;
comment|/* Environment overwrites defaults. */
name|env
operator|=
name|getenv
argument_list|(
literal|"XKB_LOG_LEVEL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|xkb_context_set_log_level
argument_list|(
name|ctx
argument_list|,
name|log_level
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"XKB_LOG_VERBOSITY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|xkb_context_set_log_verbosity
argument_list|(
name|ctx
argument_list|,
name|log_verbosity
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XKB_CONTEXT_NO_DEFAULT_INCLUDES
operator|)
operator|&&
operator|!
name|xkb_context_include_path_append_default
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"failed to add default include path %s\n"
argument_list|,
name|DFLT_XKB_CONFIG_ROOT
argument_list|)
expr_stmt|;
name|xkb_context_unref
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|use_environment_names
operator|=
operator|!
operator|(
name|flags
operator|&
name|XKB_CONTEXT_NO_ENVIRONMENT_NAMES
operator|)
expr_stmt|;
name|ctx
operator|->
name|atom_table
operator|=
name|atom_table_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|atom_table
condition|)
block|{
name|xkb_context_unref
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ctx
return|;
block|}
end_function
begin_function
name|xkb_atom_t
DECL|function|xkb_atom_lookup
name|xkb_atom_lookup
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|atom_lookup
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function
begin_function
name|xkb_atom_t
DECL|function|xkb_atom_intern
name|xkb_atom_intern
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|atom_intern
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|string
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function
begin_function
name|xkb_atom_t
DECL|function|xkb_atom_steal
name|xkb_atom_steal
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|atom_intern
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|string
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function
begin_function
name|char
modifier|*
DECL|function|xkb_atom_strdup
name|xkb_atom_strdup
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|xkb_atom_t
name|atom
parameter_list|)
block|{
return|return
name|atom_strdup
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|atom
argument_list|)
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_atom_text
name|xkb_atom_text
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|xkb_atom_t
name|atom
parameter_list|)
block|{
return|return
name|atom_text
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|,
name|atom
argument_list|)
return|;
block|}
end_function
begin_function
name|void
DECL|function|xkb_log
name|xkb_log
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|log_fn
argument_list|(
name|ctx
argument_list|,
name|level
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_log_fn
name|xkb_context_set_log_fn
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|log_fn
function_decl|)
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|log_fn
operator|=
operator|(
name|log_fn
condition|?
name|log_fn
else|:
name|default_log_fn
operator|)
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|enum
name|xkb_log_level
DECL|function|xkb_context_get_log_level
name|xkb_context_get_log_level
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|->
name|log_level
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_log_level
name|xkb_context_set_log_level
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|)
block|{
name|ctx
operator|->
name|log_level
operator|=
name|level
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_get_log_verbosity
name|xkb_context_get_log_verbosity
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|->
name|log_verbosity
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_log_verbosity
name|xkb_context_set_log_verbosity
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|int
name|verbosity
parameter_list|)
block|{
name|ctx
operator|->
name|log_verbosity
operator|=
name|verbosity
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
modifier|*
DECL|function|xkb_context_get_user_data
name|xkb_context_get_user_data
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
condition|)
return|return
name|ctx
operator|->
name|user_data
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_user_data
name|xkb_context_set_user_data
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|ctx
operator|->
name|user_data
operator|=
name|user_data
expr_stmt|;
block|}
end_function
begin_function
name|char
modifier|*
DECL|function|xkb_context_get_buffer
name|xkb_context_get_buffer
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|rtrn
decl_stmt|;
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|text_buffer
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|text_buffer
argument_list|)
operator|-
name|ctx
operator|->
name|text_next
operator|<=
name|size
condition|)
name|ctx
operator|->
name|text_next
operator|=
literal|0
expr_stmt|;
name|rtrn
operator|=
operator|&
name|ctx
operator|->
name|text_buffer
index|[
name|ctx
operator|->
name|text_next
index|]
expr_stmt|;
name|ctx
operator|->
name|text_next
operator|+=
name|size
expr_stmt|;
return|return
name|rtrn
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_rules
name|xkb_context_get_default_rules
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|getenv
argument_list|(
literal|"XKB_DEFAULT_RULES"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_RULES
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_model
name|xkb_context_get_default_model
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|getenv
argument_list|(
literal|"XKB_DEFAULT_MODEL"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_MODEL
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_layout
name|xkb_context_get_default_layout
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|getenv
argument_list|(
literal|"XKB_DEFAULT_LAYOUT"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_LAYOUT
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_variant
name|xkb_context_get_default_variant
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|layout
init|=
name|getenv
argument_list|(
literal|"XKB_DEFAULT_VARIANT"
argument_list|)
decl_stmt|;
comment|/* We don't want to inherit the variant if they haven't also set a      * layout, since they're so closely paired. */
if|if
condition|(
name|layout
operator|&&
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|getenv
argument_list|(
literal|"XKB_DEFAULT_VARIANT"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_VARIANT
return|;
block|}
end_function
begin_function
specifier|const
name|char
modifier|*
DECL|function|xkb_context_get_default_options
name|xkb_context_get_default_options
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|use_environment_names
condition|)
name|env
operator|=
name|getenv
argument_list|(
literal|"XKB_DEFAULT_OPTIONS"
argument_list|)
expr_stmt|;
return|return
name|env
condition|?
name|env
else|:
name|DEFAULT_XKB_OPTIONS
return|;
block|}
end_function
end_unit
