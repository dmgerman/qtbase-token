begin_unit
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  */
end_comment
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|"xkbcommon/xkbcommon.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|"context.h"
end_include
begin_comment
comment|/**  * Append one directory to the context's include path.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_include_path_append
name|xkb_context_include_path_append
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|err
goto|;
name|err
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|stat_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EACCESS
argument_list|)
if|if
condition|(
name|eaccess
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EUIDACCESS
argument_list|)
if|if
condition|(
name|euidaccess
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
name|darray_append
argument_list|(
name|ctx
operator|->
name|includes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
name|darray_append
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Append the default include directories to the context.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_include_path_append_default
name|xkb_context_include_path_append_default
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|home
decl_stmt|;
name|char
modifier|*
name|user_path
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator||=
name|xkb_context_include_path_append
argument_list|(
name|ctx
argument_list|,
name|DFLT_XKB_CONFIG_ROOT
argument_list|)
expr_stmt|;
name|home
operator|=
name|secure_getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|home
condition|)
return|return
name|ret
return|;
name|err
operator|=
name|asprintf
argument_list|(
operator|&
name|user_path
argument_list|,
literal|"%s/.xkb"
argument_list|,
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
return|return
name|ret
return|;
name|ret
operator||=
name|xkb_context_include_path_append
argument_list|(
name|ctx
argument_list|,
name|user_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|user_path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Remove all entries in the context's include path.  */
end_comment
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_include_path_clear
name|xkb_context_include_path_clear
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|path
decl_stmt|;
name|darray_foreach
argument_list|(
argument|path
argument_list|,
argument|ctx->includes
argument_list|)
name|free
argument_list|(
operator|*
name|path
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|ctx
operator|->
name|includes
argument_list|)
expr_stmt|;
name|darray_foreach
argument_list|(
argument|path
argument_list|,
argument|ctx->failed_includes
argument_list|)
name|free
argument_list|(
operator|*
name|path
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|ctx
operator|->
name|failed_includes
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * xkb_context_include_path_clear() + xkb_context_include_path_append_default()  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_include_path_reset_defaults
name|xkb_context_include_path_reset_defaults
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
name|xkb_context_include_path_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|xkb_context_include_path_append_default
argument_list|(
name|ctx
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns the number of entries in the context's include path.  */
end_comment
begin_function
name|XKB_EXPORT
name|unsigned
name|int
DECL|function|xkb_context_num_include_paths
name|xkb_context_num_include_paths
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|darray_size
argument_list|(
name|ctx
operator|->
name|includes
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns the given entry in the context's include path, or NULL if an  * invalid index is passed.  */
end_comment
begin_function
name|XKB_EXPORT
specifier|const
name|char
modifier|*
DECL|function|xkb_context_include_path_get
name|xkb_context_include_path_get
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|xkb_context_num_include_paths
argument_list|(
name|ctx
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|darray_item
argument_list|(
name|ctx
operator|->
name|includes
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Take a new reference on the context.  */
end_comment
begin_function
name|XKB_EXPORT
name|struct
name|xkb_context
modifier|*
DECL|function|xkb_context_ref
name|xkb_context_ref
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function
begin_comment
comment|/**  * Drop an existing reference on the context, and free it if the refcnt is  * now 0.  */
end_comment
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_unref
name|xkb_context_unref
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ctx
operator|||
operator|--
name|ctx
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
name|xkb_context_include_path_clear
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|atom_table_free
argument_list|(
name|ctx
operator|->
name|atom_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|log_level_to_prefix
name|log_level_to_prefix
parameter_list|(
name|enum
name|xkb_log_level
name|level
parameter_list|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|XKB_LOG_LEVEL_DEBUG
case|:
return|return
literal|"xkbcommon: DEBUG: "
return|;
case|case
name|XKB_LOG_LEVEL_INFO
case|:
return|return
literal|"xkbcommon: INFO: "
return|;
case|case
name|XKB_LOG_LEVEL_WARNING
case|:
return|return
literal|"xkbcommon: WARNING: "
return|;
case|case
name|XKB_LOG_LEVEL_ERROR
case|:
return|return
literal|"xkbcommon: ERROR: "
return|;
case|case
name|XKB_LOG_LEVEL_CRITICAL
case|:
return|return
literal|"xkbcommon: CRITICAL: "
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_macro
name|ATTR_PRINTF
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
end_macro
begin_function
specifier|static
name|void
DECL|function|default_log_fn
name|default_log_fn
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|log_level_to_prefix
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|enum
name|xkb_log_level
DECL|function|log_level
name|log_level
parameter_list|(
specifier|const
name|char
modifier|*
name|level
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|enum
name|xkb_log_level
name|lvl
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|lvl
operator|=
name|strtol
argument_list|(
name|level
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
operator|(
name|endptr
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|is_space
argument_list|(
name|endptr
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|lvl
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"crit"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_CRITICAL
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"err"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_ERROR
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"warn"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_WARNING
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"info"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_INFO
return|;
if|if
condition|(
name|istreq_prefix
argument_list|(
literal|"debug"
argument_list|,
name|level
argument_list|)
operator|||
name|istreq_prefix
argument_list|(
literal|"dbg"
argument_list|,
name|level
argument_list|)
condition|)
return|return
name|XKB_LOG_LEVEL_DEBUG
return|;
return|return
name|XKB_LOG_LEVEL_ERROR
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|log_verbosity
name|log_verbosity
parameter_list|(
specifier|const
name|char
modifier|*
name|verbosity
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|int
name|v
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|strtol
argument_list|(
name|verbosity
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|v
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Create a new context.  */
end_comment
begin_function
name|XKB_EXPORT
name|struct
name|xkb_context
modifier|*
DECL|function|xkb_context_new
name|xkb_context_new
parameter_list|(
name|enum
name|xkb_context_flags
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|struct
name|xkb_context
modifier|*
name|ctx
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
name|NULL
return|;
name|ctx
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|log_fn
operator|=
name|default_log_fn
expr_stmt|;
name|ctx
operator|->
name|log_level
operator|=
name|XKB_LOG_LEVEL_ERROR
expr_stmt|;
name|ctx
operator|->
name|log_verbosity
operator|=
literal|0
expr_stmt|;
comment|/* Environment overwrites defaults. */
name|env
operator|=
name|secure_getenv
argument_list|(
literal|"XKB_LOG_LEVEL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|xkb_context_set_log_level
argument_list|(
name|ctx
argument_list|,
name|log_level
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|=
name|secure_getenv
argument_list|(
literal|"XKB_LOG_VERBOSITY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|xkb_context_set_log_verbosity
argument_list|(
name|ctx
argument_list|,
name|log_verbosity
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XKB_CONTEXT_NO_DEFAULT_INCLUDES
operator|)
operator|&&
operator|!
name|xkb_context_include_path_append_default
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
name|ctx
argument_list|,
literal|"failed to add default include path %s\n"
argument_list|,
name|DFLT_XKB_CONFIG_ROOT
argument_list|)
expr_stmt|;
name|xkb_context_unref
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|use_environment_names
operator|=
operator|!
operator|(
name|flags
operator|&
name|XKB_CONTEXT_NO_ENVIRONMENT_NAMES
operator|)
expr_stmt|;
name|ctx
operator|->
name|atom_table
operator|=
name|atom_table_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|atom_table
condition|)
block|{
name|xkb_context_unref
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ctx
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_log_fn
name|xkb_context_set_log_fn
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|log_fn
function_decl|)
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
parameter_list|)
block|{
name|ctx
operator|->
name|log_fn
operator|=
operator|(
name|log_fn
condition|?
name|log_fn
else|:
name|default_log_fn
operator|)
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|enum
name|xkb_log_level
DECL|function|xkb_context_get_log_level
name|xkb_context_get_log_level
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|->
name|log_level
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_log_level
name|xkb_context_set_log_level
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|)
block|{
name|ctx
operator|->
name|log_level
operator|=
name|level
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_context_get_log_verbosity
name|xkb_context_get_log_verbosity
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|->
name|log_verbosity
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_log_verbosity
name|xkb_context_set_log_verbosity
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|int
name|verbosity
parameter_list|)
block|{
name|ctx
operator|->
name|log_verbosity
operator|=
name|verbosity
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
modifier|*
DECL|function|xkb_context_get_user_data
name|xkb_context_get_user_data
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
condition|)
return|return
name|ctx
operator|->
name|user_data
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_context_set_user_data
name|xkb_context_set_user_data
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|ctx
operator|->
name|user_data
operator|=
name|user_data
expr_stmt|;
block|}
end_function
end_unit
