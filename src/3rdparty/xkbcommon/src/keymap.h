begin_unit
begin_comment
comment|/*  * Copyright 1985, 1987, 1990, 1998  The Open Group  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Except as contained in this notice, the names of the authors or their  * institutions shall not be used in advertising or otherwise to promote the  * sale, use or other dealings in this Software without prior written  * authorization from the authors.  */
end_comment
begin_comment
comment|/************************************************************  * Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2009 Dan Nicholson  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  *         Dan Nicholson<dbn.lists@gmail.com>  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|KEYMAP_H
end_ifndef
begin_define
DECL|macro|KEYMAP_H
define|#
directive|define
name|KEYMAP_H
end_define
begin_comment
comment|/* Don't use compat names in internal code. */
end_comment
begin_define
DECL|macro|_XKBCOMMON_COMPAT_H
define|#
directive|define
name|_XKBCOMMON_COMPAT_H
end_define
begin_include
include|#
directive|include
file|"xkbcommon/xkbcommon.h"
end_include
begin_include
include|#
directive|include
file|"utils.h"
end_include
begin_include
include|#
directive|include
file|"context.h"
end_include
begin_comment
comment|/* This limit is artificially enforced, we do not depend on it any where.  * The reason it's still here is that the rules file format does not  * support multiple groups very well, and the rules shipped with  * xkeyboard-config (see rules/evdev) depend on this limit extensively.  * So just lifting this limit would cause problems for people who will use  * more than 4 layouts.  * TODO: Fix the group index syntax in the rules format, preferably in a  *       backwards compatible way.  *       See e.g. https://bugs.freedesktop.org/show_bug.cgi?id=14372  * Note: A limit on the number of groups we *do* depend on is imposed by  * the size of the xkb_layout_mask_t type (32). This is more than enough  * though.  */
end_comment
begin_define
DECL|macro|XKB_MAX_GROUPS
define|#
directive|define
name|XKB_MAX_GROUPS
value|4
end_define
begin_comment
comment|/* Don't allow more modifiers than we can hold in xkb_mod_mask_t. */
end_comment
begin_define
DECL|macro|XKB_MAX_MODS
define|#
directive|define
name|XKB_MAX_MODS
value|((xkb_mod_index_t) (sizeof(xkb_mod_mask_t) * 8))
end_define
begin_comment
comment|/* Don't allow more leds than we can hold in xkb_led_mask_t. */
end_comment
begin_define
DECL|macro|XKB_MAX_LEDS
define|#
directive|define
name|XKB_MAX_LEDS
value|((xkb_led_index_t) (sizeof(xkb_led_mask_t) * 8))
end_define
begin_comment
comment|/* These should all go away. */
end_comment
begin_enum
DECL|enum|mod_type
enum|enum
name|mod_type
block|{
DECL|enumerator|MOD_REAL
name|MOD_REAL
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|MOD_VIRT
name|MOD_VIRT
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|MOD_BOTH
name|MOD_BOTH
init|=
operator|(
name|MOD_REAL
operator||
name|MOD_VIRT
operator|)
block|, }
enum|;
end_enum
begin_define
DECL|macro|MOD_REAL_MASK_ALL
define|#
directive|define
name|MOD_REAL_MASK_ALL
value|((xkb_mod_mask_t) 0x000000ff)
end_define
begin_enum
DECL|enum|xkb_action_type
enum|enum
name|xkb_action_type
block|{
DECL|enumerator|ACTION_TYPE_NONE
name|ACTION_TYPE_NONE
init|=
literal|0
block|,
DECL|enumerator|ACTION_TYPE_MOD_SET
name|ACTION_TYPE_MOD_SET
block|,
DECL|enumerator|ACTION_TYPE_MOD_LATCH
name|ACTION_TYPE_MOD_LATCH
block|,
DECL|enumerator|ACTION_TYPE_MOD_LOCK
name|ACTION_TYPE_MOD_LOCK
block|,
DECL|enumerator|ACTION_TYPE_GROUP_SET
name|ACTION_TYPE_GROUP_SET
block|,
DECL|enumerator|ACTION_TYPE_GROUP_LATCH
name|ACTION_TYPE_GROUP_LATCH
block|,
DECL|enumerator|ACTION_TYPE_GROUP_LOCK
name|ACTION_TYPE_GROUP_LOCK
block|,
DECL|enumerator|ACTION_TYPE_PTR_MOVE
name|ACTION_TYPE_PTR_MOVE
block|,
DECL|enumerator|ACTION_TYPE_PTR_BUTTON
name|ACTION_TYPE_PTR_BUTTON
block|,
DECL|enumerator|ACTION_TYPE_PTR_LOCK
name|ACTION_TYPE_PTR_LOCK
block|,
DECL|enumerator|ACTION_TYPE_PTR_DEFAULT
name|ACTION_TYPE_PTR_DEFAULT
block|,
DECL|enumerator|ACTION_TYPE_TERMINATE
name|ACTION_TYPE_TERMINATE
block|,
DECL|enumerator|ACTION_TYPE_SWITCH_VT
name|ACTION_TYPE_SWITCH_VT
block|,
DECL|enumerator|ACTION_TYPE_CTRL_SET
name|ACTION_TYPE_CTRL_SET
block|,
DECL|enumerator|ACTION_TYPE_CTRL_LOCK
name|ACTION_TYPE_CTRL_LOCK
block|,
DECL|enumerator|ACTION_TYPE_KEY_REDIRECT
name|ACTION_TYPE_KEY_REDIRECT
block|,
DECL|enumerator|ACTION_TYPE_PRIVATE
name|ACTION_TYPE_PRIVATE
block|,
DECL|enumerator|_ACTION_TYPE_NUM_ENTRIES
name|_ACTION_TYPE_NUM_ENTRIES
block|}
enum|;
end_enum
begin_enum
DECL|enum|xkb_action_flags
enum|enum
name|xkb_action_flags
block|{
DECL|enumerator|ACTION_LOCK_CLEAR
name|ACTION_LOCK_CLEAR
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|ACTION_LATCH_TO_LOCK
name|ACTION_LATCH_TO_LOCK
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|ACTION_LOCK_NO_LOCK
name|ACTION_LOCK_NO_LOCK
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
DECL|enumerator|ACTION_LOCK_NO_UNLOCK
name|ACTION_LOCK_NO_UNLOCK
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
DECL|enumerator|ACTION_MODS_LOOKUP_MODMAP
name|ACTION_MODS_LOOKUP_MODMAP
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
DECL|enumerator|ACTION_ABSOLUTE_SWITCH
name|ACTION_ABSOLUTE_SWITCH
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
DECL|enumerator|ACTION_ABSOLUTE_X
name|ACTION_ABSOLUTE_X
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
DECL|enumerator|ACTION_ABSOLUTE_Y
name|ACTION_ABSOLUTE_Y
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
DECL|enumerator|ACTION_NO_ACCEL
name|ACTION_NO_ACCEL
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
DECL|enumerator|ACTION_SAME_SCREEN
name|ACTION_SAME_SCREEN
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|, }
enum|;
end_enum
begin_enum
DECL|enum|xkb_action_controls
enum|enum
name|xkb_action_controls
block|{
DECL|enumerator|CONTROL_REPEAT
name|CONTROL_REPEAT
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|CONTROL_SLOW
name|CONTROL_SLOW
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|CONTROL_DEBOUNCE
name|CONTROL_DEBOUNCE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
DECL|enumerator|CONTROL_STICKY
name|CONTROL_STICKY
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
DECL|enumerator|CONTROL_MOUSEKEYS
name|CONTROL_MOUSEKEYS
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
DECL|enumerator|CONTROL_MOUSEKEYS_ACCEL
name|CONTROL_MOUSEKEYS_ACCEL
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
DECL|enumerator|CONTROL_AX
name|CONTROL_AX
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
DECL|enumerator|CONTROL_AX_TIMEOUT
name|CONTROL_AX_TIMEOUT
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
DECL|enumerator|CONTROL_AX_FEEDBACK
name|CONTROL_AX_FEEDBACK
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
DECL|enumerator|CONTROL_BELL
name|CONTROL_BELL
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
DECL|enumerator|CONTROL_IGNORE_GROUP_LOCK
name|CONTROL_IGNORE_GROUP_LOCK
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
DECL|enumerator|CONTROL_ALL
name|CONTROL_ALL
init|= \
operator|(
name|CONTROL_REPEAT
operator||
name|CONTROL_SLOW
operator||
name|CONTROL_DEBOUNCE
operator||
name|CONTROL_STICKY
operator||
expr|\
name|CONTROL_MOUSEKEYS
operator||
name|CONTROL_MOUSEKEYS_ACCEL
operator||
name|CONTROL_AX
operator||
expr|\
name|CONTROL_AX_TIMEOUT
operator||
name|CONTROL_AX_FEEDBACK
operator||
name|CONTROL_BELL
operator||
expr|\
name|CONTROL_IGNORE_GROUP_LOCK
operator|)
block|}
enum|;
end_enum
begin_enum
DECL|enum|xkb_match_operation
enum|enum
name|xkb_match_operation
block|{
DECL|enumerator|MATCH_NONE
name|MATCH_NONE
block|,
DECL|enumerator|MATCH_ANY_OR_NONE
name|MATCH_ANY_OR_NONE
block|,
DECL|enumerator|MATCH_ANY
name|MATCH_ANY
block|,
DECL|enumerator|MATCH_ALL
name|MATCH_ALL
block|,
DECL|enumerator|MATCH_EXACTLY
name|MATCH_EXACTLY
block|, }
enum|;
end_enum
begin_struct
DECL|struct|xkb_mods
struct|struct
name|xkb_mods
block|{
DECL|member|mods
name|xkb_mod_mask_t
name|mods
decl_stmt|;
comment|/* original real+virtual mods in definition */
DECL|member|mask
name|xkb_mod_mask_t
name|mask
decl_stmt|;
comment|/* computed effective mask */
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_mod_action
struct|struct
name|xkb_mod_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|mods
name|struct
name|xkb_mods
name|mods
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_group_action
struct|struct
name|xkb_group_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|group
name|int32_t
name|group
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_controls_action
struct|struct
name|xkb_controls_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|ctrls
name|enum
name|xkb_action_controls
name|ctrls
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_pointer_default_action
struct|struct
name|xkb_pointer_default_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|value
name|int8_t
name|value
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_switch_screen_action
struct|struct
name|xkb_switch_screen_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|screen
name|int8_t
name|screen
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_redirect_key_action
struct|struct
name|xkb_redirect_key_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|new_kc
name|xkb_keycode_t
name|new_kc
decl_stmt|;
DECL|member|mods_mask
name|uint8_t
name|mods_mask
decl_stmt|;
DECL|member|mods
name|uint8_t
name|mods
decl_stmt|;
DECL|member|vmods_mask
name|uint16_t
name|vmods_mask
decl_stmt|;
DECL|member|vmods
name|uint16_t
name|vmods
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_pointer_action
struct|struct
name|xkb_pointer_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|x
name|int16_t
name|x
decl_stmt|;
DECL|member|y
name|int16_t
name|y
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_pointer_button_action
struct|struct
name|xkb_pointer_button_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|count
name|uint8_t
name|count
decl_stmt|;
DECL|member|button
name|int8_t
name|button
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_private_action
struct|struct
name|xkb_private_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_action_flags
name|flags
decl_stmt|;
DECL|member|data
name|uint8_t
name|data
index|[
literal|7
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_union
DECL|union|xkb_action
union|union
name|xkb_action
block|{
DECL|member|type
name|enum
name|xkb_action_type
name|type
decl_stmt|;
DECL|member|mods
name|struct
name|xkb_mod_action
name|mods
decl_stmt|;
DECL|member|group
name|struct
name|xkb_group_action
name|group
decl_stmt|;
DECL|member|ctrls
name|struct
name|xkb_controls_action
name|ctrls
decl_stmt|;
DECL|member|dflt
name|struct
name|xkb_pointer_default_action
name|dflt
decl_stmt|;
DECL|member|screen
name|struct
name|xkb_switch_screen_action
name|screen
decl_stmt|;
DECL|member|redirect
name|struct
name|xkb_redirect_key_action
name|redirect
decl_stmt|;
comment|/* XXX wholly unnecessary? */
DECL|member|ptr
name|struct
name|xkb_pointer_action
name|ptr
decl_stmt|;
DECL|member|btn
name|struct
name|xkb_pointer_button_action
name|btn
decl_stmt|;
DECL|member|priv
name|struct
name|xkb_private_action
name|priv
decl_stmt|;
block|}
union|;
end_union
begin_struct
DECL|struct|xkb_key_type_entry
struct|struct
name|xkb_key_type_entry
block|{
DECL|member|level
name|xkb_level_index_t
name|level
decl_stmt|;
DECL|member|mods
name|struct
name|xkb_mods
name|mods
decl_stmt|;
DECL|member|preserve
name|struct
name|xkb_mods
name|preserve
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_key_type
struct|struct
name|xkb_key_type
block|{
DECL|member|name
name|xkb_atom_t
name|name
decl_stmt|;
DECL|member|mods
name|struct
name|xkb_mods
name|mods
decl_stmt|;
DECL|member|num_levels
name|xkb_level_index_t
name|num_levels
decl_stmt|;
DECL|member|level_names
name|xkb_atom_t
modifier|*
name|level_names
decl_stmt|;
DECL|member|num_entries
name|unsigned
name|int
name|num_entries
decl_stmt|;
DECL|member|entries
name|struct
name|xkb_key_type_entry
modifier|*
name|entries
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_sym_interpret
struct|struct
name|xkb_sym_interpret
block|{
DECL|member|sym
name|xkb_keysym_t
name|sym
decl_stmt|;
DECL|member|match
name|enum
name|xkb_match_operation
name|match
decl_stmt|;
DECL|member|level_one_only
name|bool
name|level_one_only
decl_stmt|;
DECL|member|mods
name|xkb_mod_mask_t
name|mods
decl_stmt|;
DECL|member|virtual_mod
name|xkb_mod_index_t
name|virtual_mod
decl_stmt|;
DECL|member|action
name|union
name|xkb_action
name|action
decl_stmt|;
DECL|member|repeat
name|bool
name|repeat
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_led
struct|struct
name|xkb_led
block|{
DECL|member|name
name|xkb_atom_t
name|name
decl_stmt|;
DECL|member|which_groups
name|enum
name|xkb_state_component
name|which_groups
decl_stmt|;
DECL|member|groups
name|xkb_layout_mask_t
name|groups
decl_stmt|;
DECL|member|which_mods
name|enum
name|xkb_state_component
name|which_mods
decl_stmt|;
DECL|member|mods
name|struct
name|xkb_mods
name|mods
decl_stmt|;
DECL|member|ctrls
name|enum
name|xkb_action_controls
name|ctrls
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_key_alias
struct|struct
name|xkb_key_alias
block|{
DECL|member|real
name|xkb_atom_t
name|real
decl_stmt|;
DECL|member|alias
name|xkb_atom_t
name|alias
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_controls
struct|struct
name|xkb_controls
block|{
DECL|member|groups_wrap
name|unsigned
name|char
name|groups_wrap
decl_stmt|;
DECL|member|internal
name|struct
name|xkb_mods
name|internal
decl_stmt|;
DECL|member|ignore_lock
name|struct
name|xkb_mods
name|ignore_lock
decl_stmt|;
DECL|member|repeat_delay
name|unsigned
name|short
name|repeat_delay
decl_stmt|;
DECL|member|repeat_interval
name|unsigned
name|short
name|repeat_interval
decl_stmt|;
DECL|member|slow_keys_delay
name|unsigned
name|short
name|slow_keys_delay
decl_stmt|;
DECL|member|debounce_delay
name|unsigned
name|short
name|debounce_delay
decl_stmt|;
DECL|member|ax_options
name|unsigned
name|short
name|ax_options
decl_stmt|;
DECL|member|ax_timeout
name|unsigned
name|short
name|ax_timeout
decl_stmt|;
DECL|member|axt_opts_mask
name|unsigned
name|short
name|axt_opts_mask
decl_stmt|;
DECL|member|axt_opts_values
name|unsigned
name|short
name|axt_opts_values
decl_stmt|;
DECL|member|axt_ctrls_mask
name|unsigned
name|int
name|axt_ctrls_mask
decl_stmt|;
DECL|member|axt_ctrls_values
name|unsigned
name|int
name|axt_ctrls_values
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Such an awkward name.  Oh well. */
end_comment
begin_enum
DECL|enum|xkb_range_exceed_type
enum|enum
name|xkb_range_exceed_type
block|{
DECL|enumerator|RANGE_SATURATE
name|RANGE_SATURATE
block|,
DECL|enumerator|RANGE_WRAP
name|RANGE_WRAP
block|,
DECL|enumerator|RANGE_REDIRECT
name|RANGE_REDIRECT
block|, }
enum|;
end_enum
begin_enum
DECL|enum|xkb_explicit_components
enum|enum
name|xkb_explicit_components
block|{
DECL|enumerator|EXPLICIT_INTERP
name|EXPLICIT_INTERP
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|EXPLICIT_VMODMAP
name|EXPLICIT_VMODMAP
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|EXPLICIT_REPEAT
name|EXPLICIT_REPEAT
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|, }
enum|;
end_enum
begin_struct
DECL|struct|xkb_level
struct|struct
name|xkb_level
block|{
DECL|member|action
name|union
name|xkb_action
name|action
decl_stmt|;
DECL|member|num_syms
name|unsigned
name|int
name|num_syms
decl_stmt|;
union|union
block|{
DECL|member|sym
name|xkb_keysym_t
name|sym
decl_stmt|;
comment|/* num_syms == 1 */
DECL|member|syms
name|xkb_keysym_t
modifier|*
name|syms
decl_stmt|;
comment|/* num_syms> 1  */
block|}
DECL|member|u
name|u
union|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_group
struct|struct
name|xkb_group
block|{
DECL|member|explicit_type
name|bool
name|explicit_type
decl_stmt|;
comment|/* Points to a type in keymap->types. */
DECL|member|type
specifier|const
name|struct
name|xkb_key_type
modifier|*
name|type
decl_stmt|;
comment|/* Use XkbKeyGroupWidth for the number of levels. */
DECL|member|levels
name|struct
name|xkb_level
modifier|*
name|levels
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_key
struct|struct
name|xkb_key
block|{
DECL|member|keycode
name|xkb_keycode_t
name|keycode
decl_stmt|;
DECL|member|name
name|xkb_atom_t
name|name
decl_stmt|;
DECL|member|explicit
name|enum
name|xkb_explicit_components
name|explicit
decl_stmt|;
DECL|member|modmap
name|xkb_mod_mask_t
name|modmap
decl_stmt|;
DECL|member|vmodmap
name|xkb_mod_mask_t
name|vmodmap
decl_stmt|;
DECL|member|repeats
name|bool
name|repeats
decl_stmt|;
DECL|member|out_of_range_group_action
name|enum
name|xkb_range_exceed_type
name|out_of_range_group_action
decl_stmt|;
DECL|member|out_of_range_group_number
name|xkb_layout_index_t
name|out_of_range_group_number
decl_stmt|;
DECL|member|num_groups
name|xkb_layout_index_t
name|num_groups
decl_stmt|;
DECL|member|groups
name|struct
name|xkb_group
modifier|*
name|groups
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_mod
struct|struct
name|xkb_mod
block|{
DECL|member|name
name|xkb_atom_t
name|name
decl_stmt|;
DECL|member|type
name|enum
name|mod_type
name|type
decl_stmt|;
DECL|member|mapping
name|xkb_mod_mask_t
name|mapping
decl_stmt|;
comment|/* vmod -> real mod mapping */
block|}
struct|;
end_struct
begin_comment
comment|/* Common keyboard description structure */
end_comment
begin_struct
DECL|struct|xkb_keymap
struct|struct
name|xkb_keymap
block|{
DECL|member|ctx
name|struct
name|xkb_context
modifier|*
name|ctx
decl_stmt|;
DECL|member|refcnt
name|int
name|refcnt
decl_stmt|;
DECL|member|flags
name|enum
name|xkb_keymap_compile_flags
name|flags
decl_stmt|;
DECL|member|format
name|enum
name|xkb_keymap_format
name|format
decl_stmt|;
DECL|member|enabled_ctrls
name|enum
name|xkb_action_controls
name|enabled_ctrls
decl_stmt|;
DECL|member|min_key_code
name|xkb_keycode_t
name|min_key_code
decl_stmt|;
DECL|member|max_key_code
name|xkb_keycode_t
name|max_key_code
decl_stmt|;
DECL|member|keys
name|struct
name|xkb_key
modifier|*
name|keys
decl_stmt|;
comment|/* aliases in no particular order */
DECL|member|num_key_aliases
name|unsigned
name|int
name|num_key_aliases
decl_stmt|;
DECL|member|key_aliases
name|struct
name|xkb_key_alias
modifier|*
name|key_aliases
decl_stmt|;
DECL|member|types
name|struct
name|xkb_key_type
modifier|*
name|types
decl_stmt|;
DECL|member|num_types
name|unsigned
name|int
name|num_types
decl_stmt|;
DECL|member|sym_interprets
name|darray
argument_list|(
argument|struct xkb_sym_interpret
argument_list|)
name|sym_interprets
expr_stmt|;
DECL|member|mods
name|darray
argument_list|(
argument|struct xkb_mod
argument_list|)
name|mods
expr_stmt|;
comment|/* Number of groups in the key with the most groups. */
DECL|member|num_groups
name|xkb_layout_index_t
name|num_groups
decl_stmt|;
comment|/* Not all groups must have names. */
DECL|member|num_group_names
name|xkb_layout_index_t
name|num_group_names
decl_stmt|;
DECL|member|group_names
name|xkb_atom_t
modifier|*
name|group_names
decl_stmt|;
DECL|member|leds
name|darray
argument_list|(
argument|struct xkb_led
argument_list|)
name|leds
expr_stmt|;
DECL|member|keycodes_section_name
name|char
modifier|*
name|keycodes_section_name
decl_stmt|;
DECL|member|symbols_section_name
name|char
modifier|*
name|symbols_section_name
decl_stmt|;
DECL|member|types_section_name
name|char
modifier|*
name|types_section_name
decl_stmt|;
DECL|member|compat_section_name
name|char
modifier|*
name|compat_section_name
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|xkb_foreach_key
define|#
directive|define
name|xkb_foreach_key
parameter_list|(
name|iter
parameter_list|,
name|keymap
parameter_list|)
define|\
value|for (iter = keymap->keys + keymap->min_key_code; \          iter<= keymap->keys + keymap->max_key_code; \          iter++)
end_define
begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|xkb_key
modifier|*
DECL|function|XkbKey
name|XkbKey
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
if|if
condition|(
name|kc
operator|<
name|keymap
operator|->
name|min_key_code
operator|||
name|kc
operator|>
name|keymap
operator|->
name|max_key_code
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|keymap
operator|->
name|keys
index|[
name|kc
index|]
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|xkb_level_index_t
DECL|function|XkbKeyGroupWidth
name|XkbKeyGroupWidth
parameter_list|(
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|xkb_layout_index_t
name|layout
parameter_list|)
block|{
return|return
name|key
operator|->
name|groups
index|[
name|layout
index|]
operator|.
name|type
operator|->
name|num_levels
return|;
block|}
end_function
begin_function_decl
name|struct
name|xkb_key
modifier|*
name|XkbKeyByName
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_atom_t
name|name
parameter_list|,
name|bool
name|use_aliases
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|xkb_atom_t
name|XkbResolveKeyAlias
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_atom_t
name|name
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|xkb_layout_index_t
name|wrap_group_into_range
parameter_list|(
name|int32_t
name|group
parameter_list|,
name|xkb_layout_index_t
name|num_groups
parameter_list|,
name|enum
name|xkb_range_exceed_type
name|out_of_range_group_action
parameter_list|,
name|xkb_layout_index_t
name|out_of_range_group_number
parameter_list|)
function_decl|;
end_function_decl
begin_struct
DECL|struct|xkb_keymap_format_ops
struct|struct
name|xkb_keymap_format_ops
block|{
DECL|member|keymap_new_from_names
name|bool
function_decl|(
modifier|*
name|keymap_new_from_names
function_decl|)
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|struct
name|xkb_rule_names
modifier|*
name|names
parameter_list|)
function_decl|;
DECL|member|keymap_new_from_string
name|bool
function_decl|(
modifier|*
name|keymap_new_from_string
function_decl|)
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
DECL|member|keymap_new_from_buffer
name|bool
function_decl|(
modifier|*
name|keymap_new_from_buffer
function_decl|)
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
DECL|member|keymap_new_from_file
name|bool
function_decl|(
modifier|*
name|keymap_new_from_file
function_decl|)
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
function_decl|;
DECL|member|keymap_get_as_string
name|char
modifier|*
function_decl|(
modifier|*
name|keymap_get_as_string
function_decl|)
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
function_decl|;
block|}
struct|;
end_struct
begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|xkb_keymap_format_ops
name|text_v1_keymap_format_ops
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
end_unit
