begin_unit
begin_comment
comment|/************************************************************  * Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita<ran234@gmail.com>  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  */
end_comment
begin_comment
comment|/*  * This is a bastardised version of xkbActions.c from the X server which  * does not support, for the moment:  *   - AccessX sticky/debounce/etc (will come later)  *   - pointer keys (may come later)  *   - key redirects (unlikely)  *   - messages (very unlikely)  */
end_comment
begin_include
include|#
directive|include
file|"keymap.h"
end_include
begin_include
include|#
directive|include
file|"keysym.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_struct
DECL|struct|xkb_filter
struct|struct
name|xkb_filter
block|{
DECL|member|action
name|union
name|xkb_action
name|action
decl_stmt|;
DECL|member|key
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
decl_stmt|;
DECL|member|priv
name|uint32_t
name|priv
decl_stmt|;
DECL|member|func
name|bool
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
function_decl|;
DECL|member|refcnt
name|int
name|refcnt
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|state_components
struct|struct
name|state_components
block|{
comment|/* These may be negative, because of -1 group actions. */
DECL|member|base_group
name|int32_t
name|base_group
decl_stmt|;
comment|/**< depressed */
DECL|member|latched_group
name|int32_t
name|latched_group
decl_stmt|;
DECL|member|locked_group
name|int32_t
name|locked_group
decl_stmt|;
DECL|member|group
name|xkb_layout_index_t
name|group
decl_stmt|;
comment|/**< effective */
DECL|member|base_mods
name|xkb_mod_mask_t
name|base_mods
decl_stmt|;
comment|/**< depressed */
DECL|member|latched_mods
name|xkb_mod_mask_t
name|latched_mods
decl_stmt|;
DECL|member|locked_mods
name|xkb_mod_mask_t
name|locked_mods
decl_stmt|;
DECL|member|mods
name|xkb_mod_mask_t
name|mods
decl_stmt|;
comment|/**< effective */
DECL|member|leds
name|xkb_led_mask_t
name|leds
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|xkb_state
struct|struct
name|xkb_state
block|{
comment|/*      * Before updating the state, we keep a copy of just this struct. This      * allows us to report which components of the state have changed.      */
DECL|member|components
name|struct
name|state_components
name|components
decl_stmt|;
comment|/*      * At each event, we accumulate all the needed modifications to the base      * modifiers, and apply them at the end. These keep track of this state.      */
DECL|member|set_mods
name|xkb_mod_mask_t
name|set_mods
decl_stmt|;
DECL|member|clear_mods
name|xkb_mod_mask_t
name|clear_mods
decl_stmt|;
comment|/*      * We mustn't clear a base modifier if there's another depressed key      * which affects it, e.g. given this sequence      *< Left Shift down, Right Shift down, Left Shift Up>      * the modifier should still be set. This keeps the count.      */
DECL|member|mod_key_count
name|int16_t
name|mod_key_count
index|[
name|XKB_MAX_MODS
index|]
decl_stmt|;
DECL|member|refcnt
name|int
name|refcnt
decl_stmt|;
DECL|member|filters
name|darray
argument_list|(
argument|struct xkb_filter
argument_list|)
name|filters
expr_stmt|;
DECL|member|keymap
name|struct
name|xkb_keymap
modifier|*
name|keymap
decl_stmt|;
block|}
struct|;
end_struct
begin_function
specifier|static
specifier|const
name|struct
name|xkb_key_type_entry
modifier|*
DECL|function|get_entry_for_key_state
name|get_entry_for_key_state
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|xkb_layout_index_t
name|group
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key_type
modifier|*
name|type
init|=
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|type
decl_stmt|;
name|xkb_mod_mask_t
name|active_mods
init|=
name|state
operator|->
name|components
operator|.
name|mods
operator|&
name|type
operator|->
name|mods
operator|.
name|mask
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|type
operator|->
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
comment|/*          * If the virtual modifiers are not bound to anything, we're          * supposed to skip the entry (xserver does this with cached          * entry->active field).          */
if|if
condition|(
operator|!
name|type
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|mods
operator|.
name|mask
condition|)
continue|continue;
if|if
condition|(
name|type
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|mods
operator|.
name|mask
operator|==
name|active_mods
condition|)
return|return
operator|&
name|type
operator|->
name|entries
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/**  * Returns the level to use for the given key and state, or  * XKB_LEVEL_INVALID.  */
end_comment
begin_function
name|XKB_EXPORT
name|xkb_level_index_t
DECL|function|xkb_state_key_get_level
name|xkb_state_key_get_level
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|,
name|xkb_layout_index_t
name|layout
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
init|=
name|XkbKey
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|key
operator|||
name|layout
operator|>=
name|key
operator|->
name|num_groups
condition|)
return|return
name|XKB_LEVEL_INVALID
return|;
comment|/* If we don't find an explicit match the default is 0. */
name|entry
operator|=
name|get_entry_for_key_state
argument_list|(
name|state
argument_list|,
name|key
argument_list|,
name|layout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
literal|0
return|;
return|return
name|entry
operator|->
name|level
return|;
block|}
end_function
begin_function
name|xkb_layout_index_t
DECL|function|wrap_group_into_range
name|wrap_group_into_range
parameter_list|(
name|int32_t
name|group
parameter_list|,
name|xkb_layout_index_t
name|num_groups
parameter_list|,
name|enum
name|xkb_range_exceed_type
name|out_of_range_group_action
parameter_list|,
name|xkb_layout_index_t
name|out_of_range_group_number
parameter_list|)
block|{
if|if
condition|(
name|num_groups
operator|==
literal|0
condition|)
return|return
name|XKB_LAYOUT_INVALID
return|;
if|if
condition|(
name|group
operator|>=
literal|0
operator|&&
operator|(
name|xkb_layout_index_t
operator|)
name|group
operator|<
name|num_groups
condition|)
return|return
name|group
return|;
switch|switch
condition|(
name|out_of_range_group_action
condition|)
block|{
case|case
name|RANGE_REDIRECT
case|:
if|if
condition|(
name|out_of_range_group_number
operator|>=
name|num_groups
condition|)
return|return
literal|0
return|;
return|return
name|out_of_range_group_number
return|;
case|case
name|RANGE_SATURATE
case|:
if|if
condition|(
name|group
operator|<
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
name|num_groups
operator|-
literal|1
return|;
case|case
name|RANGE_WRAP
case|:
default|default:
comment|/*          * C99 says a negative dividend in a modulo operation always          * gives a negative result.          */
if|if
condition|(
name|group
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|num_groups
operator|+
operator|(
name|group
operator|%
operator|(
name|int
operator|)
name|num_groups
operator|)
operator|)
return|;
else|else
return|return
name|group
operator|%
name|num_groups
return|;
block|}
block|}
end_function
begin_comment
comment|/**  * Returns the layout to use for the given key and state, taking  * wrapping/clamping/etc into account, or XKB_LAYOUT_INVALID.  */
end_comment
begin_function
name|XKB_EXPORT
name|xkb_layout_index_t
DECL|function|xkb_state_key_get_layout
name|xkb_state_key_get_layout
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
init|=
name|XkbKey
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
name|XKB_LAYOUT_INVALID
return|;
return|return
name|wrap_group_into_range
argument_list|(
name|state
operator|->
name|components
operator|.
name|group
argument_list|,
name|key
operator|->
name|num_groups
argument_list|,
name|key
operator|->
name|out_of_range_group_action
argument_list|,
name|key
operator|->
name|out_of_range_group_number
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|fake
specifier|static
specifier|const
name|union
name|xkb_action
name|fake
init|=
block|{
operator|.
name|type
operator|=
name|ACTION_TYPE_NONE
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
specifier|const
name|union
name|xkb_action
modifier|*
DECL|function|xkb_key_get_action
name|xkb_key_get_action
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|)
block|{
name|xkb_layout_index_t
name|layout
decl_stmt|;
name|xkb_level_index_t
name|level
decl_stmt|;
name|layout
operator|=
name|xkb_state_key_get_layout
argument_list|(
name|state
argument_list|,
name|key
operator|->
name|keycode
argument_list|)
expr_stmt|;
if|if
condition|(
name|layout
operator|==
name|XKB_LAYOUT_INVALID
condition|)
return|return
operator|&
name|fake
return|;
name|level
operator|=
name|xkb_state_key_get_level
argument_list|(
name|state
argument_list|,
name|key
operator|->
name|keycode
argument_list|,
name|layout
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|XKB_LEVEL_INVALID
condition|)
return|return
operator|&
name|fake
return|;
return|return
operator|&
name|key
operator|->
name|groups
index|[
name|layout
index|]
operator|.
name|levels
index|[
name|level
index|]
operator|.
name|action
return|;
block|}
end_function
begin_function
specifier|static
name|struct
name|xkb_filter
modifier|*
DECL|function|xkb_filter_new
name|xkb_filter_new
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|xkb_filter
modifier|*
name|filter
init|=
name|NULL
decl_stmt|,
modifier|*
name|iter
decl_stmt|;
name|darray_foreach
argument_list|(
argument|iter
argument_list|,
argument|state->filters
argument_list|)
block|{
if|if
condition|(
name|iter
operator|->
name|func
condition|)
continue|continue;
name|filter
operator|=
name|iter
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|darray_resize0
argument_list|(
name|state
operator|->
name|filters
argument_list|,
name|darray_size
argument_list|(
name|state
operator|->
name|filters
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|filter
operator|=
operator|&
name|darray_item
argument_list|(
name|state
operator|->
name|filters
argument_list|,
name|darray_size
argument_list|(
name|state
operator|->
name|filters
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|filter
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
return|return
name|filter
return|;
block|}
end_function
begin_comment
comment|/***====================================================================***/
end_comment
begin_function
specifier|static
name|bool
DECL|function|xkb_filter_group_set_func
name|xkb_filter_group_set_func
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|filter
operator|->
name|key
condition|)
block|{
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|flags
operator|&=
operator|~
name|ACTION_LOCK_CLEAR
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|direction
operator|==
name|XKB_KEY_DOWN
condition|)
block|{
name|filter
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|--
name|filter
operator|->
name|refcnt
operator|>
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
name|state
operator|->
name|components
operator|.
name|base_group
operator|=
name|filter
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|flags
operator|&
name|ACTION_LOCK_CLEAR
condition|)
name|state
operator|->
name|components
operator|.
name|locked_group
operator|=
literal|0
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xkb_filter_group_set_new
name|xkb_filter_group_set_new
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|)
block|{
name|filter
operator|->
name|priv
operator|=
name|state
operator|->
name|components
operator|.
name|base_group
expr_stmt|;
if|if
condition|(
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_SWITCH
condition|)
name|state
operator|->
name|components
operator|.
name|base_group
operator|=
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|group
expr_stmt|;
else|else
name|state
operator|->
name|components
operator|.
name|base_group
operator|+=
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|group
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|xkb_filter_group_lock_func
name|xkb_filter_group_lock_func
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|filter
operator|->
name|key
condition|)
return|return
name|true
return|;
if|if
condition|(
name|direction
operator|==
name|XKB_KEY_DOWN
condition|)
block|{
name|filter
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|--
name|filter
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return
name|false
return|;
name|filter
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xkb_filter_group_lock_new
name|xkb_filter_group_lock_new
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|flags
operator|&
name|ACTION_ABSOLUTE_SWITCH
condition|)
name|state
operator|->
name|components
operator|.
name|locked_group
operator|=
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|group
expr_stmt|;
else|else
name|state
operator|->
name|components
operator|.
name|locked_group
operator|+=
name|filter
operator|->
name|action
operator|.
name|group
operator|.
name|group
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|xkb_filter_mod_set_func
name|xkb_filter_mod_set_func
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|filter
operator|->
name|key
condition|)
block|{
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|flags
operator|&=
operator|~
name|ACTION_LOCK_CLEAR
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|direction
operator|==
name|XKB_KEY_DOWN
condition|)
block|{
name|filter
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|--
name|filter
operator|->
name|refcnt
operator|>
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
name|state
operator|->
name|clear_mods
operator|=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
if|if
condition|(
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|flags
operator|&
name|ACTION_LOCK_CLEAR
condition|)
name|state
operator|->
name|components
operator|.
name|locked_mods
operator|&=
operator|~
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xkb_filter_mod_set_new
name|xkb_filter_mod_set_new
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|)
block|{
name|state
operator|->
name|set_mods
operator|=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|xkb_filter_mod_lock_func
name|xkb_filter_mod_lock_func
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|filter
operator|->
name|key
condition|)
return|return
name|true
return|;
if|if
condition|(
name|direction
operator|==
name|XKB_KEY_DOWN
condition|)
block|{
name|filter
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|--
name|filter
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return
name|false
return|;
name|state
operator|->
name|clear_mods
operator||=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|flags
operator|&
name|ACTION_LOCK_NO_UNLOCK
operator|)
condition|)
name|state
operator|->
name|components
operator|.
name|locked_mods
operator|&=
operator|~
name|filter
operator|->
name|priv
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xkb_filter_mod_lock_new
name|xkb_filter_mod_lock_new
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|)
block|{
name|filter
operator|->
name|priv
operator|=
operator|(
name|state
operator|->
name|components
operator|.
name|locked_mods
operator|&
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
operator|)
expr_stmt|;
name|state
operator|->
name|set_mods
operator||=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|flags
operator|&
name|ACTION_LOCK_NO_LOCK
operator|)
condition|)
name|state
operator|->
name|components
operator|.
name|locked_mods
operator||=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
block|}
end_function
begin_enum
DECL|enum|xkb_key_latch_state
enum|enum
name|xkb_key_latch_state
block|{
DECL|enumerator|NO_LATCH
name|NO_LATCH
block|,
DECL|enumerator|LATCH_KEY_DOWN
name|LATCH_KEY_DOWN
block|,
DECL|enumerator|LATCH_PENDING
name|LATCH_PENDING
block|, }
enum|;
end_enum
begin_function
specifier|static
name|bool
DECL|function|xkb_action_breaks_latch
name|xkb_action_breaks_latch
parameter_list|(
specifier|const
name|union
name|xkb_action
modifier|*
name|action
parameter_list|)
block|{
switch|switch
condition|(
name|action
operator|->
name|type
condition|)
block|{
case|case
name|ACTION_TYPE_NONE
case|:
case|case
name|ACTION_TYPE_PTR_BUTTON
case|:
case|case
name|ACTION_TYPE_PTR_LOCK
case|:
case|case
name|ACTION_TYPE_CTRL_SET
case|:
case|case
name|ACTION_TYPE_CTRL_LOCK
case|:
case|case
name|ACTION_TYPE_SWITCH_VT
case|:
case|case
name|ACTION_TYPE_TERMINATE
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function
begin_function
specifier|static
name|bool
DECL|function|xkb_filter_mod_latch_func
name|xkb_filter_mod_latch_func
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
block|{
name|enum
name|xkb_key_latch_state
name|latch
init|=
name|filter
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|XKB_KEY_DOWN
operator|&&
name|latch
operator|==
name|LATCH_PENDING
condition|)
block|{
comment|/* If this is a new keypress and we're awaiting our single latched          * keypress, then either break the latch if any random key is pressed,          * or promote it to a lock or plain base set if it's the same          * modifier. */
specifier|const
name|union
name|xkb_action
modifier|*
name|action
init|=
name|xkb_key_get_action
argument_list|(
name|state
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|action
operator|->
name|type
operator|==
name|ACTION_TYPE_MOD_LATCH
operator|&&
name|action
operator|->
name|mods
operator|.
name|flags
operator|==
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|flags
operator|&&
name|action
operator|->
name|mods
operator|.
name|mods
operator|.
name|mask
operator|==
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
condition|)
block|{
name|filter
operator|->
name|action
operator|=
operator|*
name|action
expr_stmt|;
if|if
condition|(
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|flags
operator|&
name|ACTION_LATCH_TO_LOCK
condition|)
block|{
name|filter
operator|->
name|action
operator|.
name|type
operator|=
name|ACTION_TYPE_MOD_LOCK
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|xkb_filter_mod_lock_func
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|locked_mods
operator||=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
block|}
else|else
block|{
name|filter
operator|->
name|action
operator|.
name|type
operator|=
name|ACTION_TYPE_MOD_SET
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|xkb_filter_mod_set_func
expr_stmt|;
name|state
operator|->
name|set_mods
operator|=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
block|}
name|filter
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|latched_mods
operator|&=
operator|~
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
comment|/* XXX beep beep! */
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|xkb_action_breaks_latch
argument_list|(
name|action
argument_list|)
condition|)
block|{
comment|/* XXX: This may be totally broken, we might need to break the              *      latch in the next run after this press? */
name|state
operator|->
name|components
operator|.
name|latched_mods
operator|&=
operator|~
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|direction
operator|==
name|XKB_KEY_UP
operator|&&
name|key
operator|==
name|filter
operator|->
name|key
condition|)
block|{
comment|/* Our key got released.  If we've set it to clear locks, and we          * currently have the same modifiers locked, then release them and          * don't actually latch.  Else we've actually hit the latching          * stage, so set PENDING and move our modifier from base to          * latched. */
if|if
condition|(
name|latch
operator|==
name|NO_LATCH
operator|||
operator|(
operator|(
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|flags
operator|&
name|ACTION_LOCK_CLEAR
operator|)
operator|&&
operator|(
name|state
operator|->
name|components
operator|.
name|locked_mods
operator|&
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
operator|)
operator|==
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
operator|)
condition|)
block|{
comment|/* XXX: We might be a bit overenthusiastic about clearing              *      mods other filters have set here? */
if|if
condition|(
name|latch
operator|==
name|LATCH_PENDING
condition|)
name|state
operator|->
name|components
operator|.
name|latched_mods
operator|&=
operator|~
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
else|else
name|state
operator|->
name|clear_mods
operator|=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|locked_mods
operator|&=
operator|~
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|latch
operator|=
name|LATCH_PENDING
expr_stmt|;
name|state
operator|->
name|clear_mods
operator|=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|latched_mods
operator||=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
comment|/* XXX beep beep! */
block|}
block|}
elseif|else
if|if
condition|(
name|direction
operator|==
name|XKB_KEY_DOWN
operator|&&
name|latch
operator|==
name|LATCH_KEY_DOWN
condition|)
block|{
comment|/* Someone's pressed another key while we've still got the latching          * key held down, so keep the base modifier state active (from          * xkb_filter_mod_latch_new), but don't trip the latch, just clear          * it as soon as the modifier gets released. */
name|latch
operator|=
name|NO_LATCH
expr_stmt|;
block|}
name|filter
operator|->
name|priv
operator|=
name|latch
expr_stmt|;
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xkb_filter_mod_latch_new
name|xkb_filter_mod_latch_new
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|)
block|{
name|filter
operator|->
name|priv
operator|=
name|LATCH_KEY_DOWN
expr_stmt|;
name|state
operator|->
name|set_mods
operator|=
name|filter
operator|->
name|action
operator|.
name|mods
operator|.
name|mods
operator|.
name|mask
expr_stmt|;
block|}
end_function
begin_struct
specifier|static
specifier|const
struct|struct
block|{
DECL|member|new
name|void
function_decl|(
modifier|*
name|new
function_decl|)
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|)
function_decl|;
DECL|member|func
name|bool
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|struct
name|xkb_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
function_decl|;
block|}
DECL|variable|filter_action_funcs
name|filter_action_funcs
index|[
name|_ACTION_TYPE_NUM_ENTRIES
index|]
init|=
block|{
index|[
name|ACTION_TYPE_MOD_SET
index|]
operator|=
block|{
name|xkb_filter_mod_set_new
block|,
name|xkb_filter_mod_set_func
block|}
block|,
index|[
name|ACTION_TYPE_MOD_LATCH
index|]
operator|=
block|{
name|xkb_filter_mod_latch_new
block|,
name|xkb_filter_mod_latch_func
block|}
block|,
index|[
name|ACTION_TYPE_MOD_LOCK
index|]
operator|=
block|{
name|xkb_filter_mod_lock_new
block|,
name|xkb_filter_mod_lock_func
block|}
block|,
index|[
name|ACTION_TYPE_GROUP_SET
index|]
operator|=
block|{
name|xkb_filter_group_set_new
block|,
name|xkb_filter_group_set_func
block|}
block|,
index|[
name|ACTION_TYPE_GROUP_LOCK
index|]
operator|=
block|{
name|xkb_filter_group_lock_new
block|,
name|xkb_filter_group_lock_func
block|}
block|, }
struct|;
end_struct
begin_comment
comment|/**  * Applies any relevant filters to the key, first from the list of filters  * that are currently active, then if no filter has claimed the key, possibly  * apply a new filter from the key action.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|xkb_filter_apply_all
name|xkb_filter_apply_all
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
block|{
name|struct
name|xkb_filter
modifier|*
name|filter
decl_stmt|;
specifier|const
name|union
name|xkb_action
modifier|*
name|action
decl_stmt|;
name|bool
name|send
init|=
name|true
decl_stmt|;
comment|/* First run through all the currently active filters and see if any of      * them have claimed this event. */
name|darray_foreach
argument_list|(
argument|filter
argument_list|,
argument|state->filters
argument_list|)
block|{
if|if
condition|(
operator|!
name|filter
operator|->
name|func
condition|)
continue|continue;
name|send
operator|=
name|filter
operator|->
name|func
argument_list|(
name|state
argument_list|,
name|filter
argument_list|,
name|key
argument_list|,
name|direction
argument_list|)
operator|&&
name|send
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|send
operator|||
name|direction
operator|==
name|XKB_KEY_UP
condition|)
return|return;
name|action
operator|=
name|xkb_key_get_action
argument_list|(
name|state
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/*      * It's possible for the keymap to set action->type explicitly, like so:      *     interpret XF86_Next_VMode {      *         action = Private(type=0x86, data="+VMode");      *     };      * We don't handle those.      */
if|if
condition|(
name|action
operator|->
name|type
operator|>=
name|_ACTION_TYPE_NUM_ENTRIES
condition|)
return|return;
if|if
condition|(
operator|!
name|filter_action_funcs
index|[
name|action
operator|->
name|type
index|]
operator|.
name|new
condition|)
return|return;
name|filter
operator|=
name|xkb_filter_new
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filter
condition|)
return|return;
comment|/* WSGO */
name|filter
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|filter
operator|->
name|func
operator|=
name|filter_action_funcs
index|[
name|action
operator|->
name|type
index|]
operator|.
name|func
expr_stmt|;
name|filter
operator|->
name|action
operator|=
operator|*
name|action
expr_stmt|;
name|filter_action_funcs
index|[
name|action
operator|->
name|type
index|]
operator|.
name|new
argument_list|(
name|state
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|struct
name|xkb_state
modifier|*
DECL|function|xkb_state_new
name|xkb_state_new
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
block|{
name|struct
name|xkb_state
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|ret
operator|->
name|keymap
operator|=
name|xkb_keymap_ref
argument_list|(
name|keymap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|struct
name|xkb_state
modifier|*
DECL|function|xkb_state_ref
name|xkb_state_ref
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
block|{
name|state
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|state
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|void
DECL|function|xkb_state_unref
name|xkb_state_unref
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|||
operator|--
name|state
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
name|xkb_keymap_unref
argument_list|(
name|state
operator|->
name|keymap
argument_list|)
expr_stmt|;
name|darray_free
argument_list|(
name|state
operator|->
name|filters
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|struct
name|xkb_keymap
modifier|*
DECL|function|xkb_state_get_keymap
name|xkb_state_get_keymap
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
block|{
return|return
name|state
operator|->
name|keymap
return|;
block|}
end_function
begin_comment
comment|/**  * Update the LED state to match the rest of the xkb_state.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|xkb_state_led_update_all
name|xkb_state_led_update_all
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
block|{
name|xkb_led_index_t
name|idx
decl_stmt|;
specifier|const
name|struct
name|xkb_led
modifier|*
name|led
decl_stmt|;
name|state
operator|->
name|components
operator|.
name|leds
operator|=
literal|0
expr_stmt|;
name|darray_enumerate
argument_list|(
argument|idx
argument_list|,
argument|led
argument_list|,
argument|state->keymap->leds
argument_list|)
block|{
name|xkb_mod_mask_t
name|mod_mask
init|=
literal|0
decl_stmt|;
name|xkb_layout_mask_t
name|group_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|led
operator|->
name|which_mods
operator|!=
literal|0
operator|&&
name|led
operator|->
name|mods
operator|.
name|mask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|led
operator|->
name|which_mods
operator|&
name|XKB_STATE_MODS_EFFECTIVE
condition|)
name|mod_mask
operator||=
name|state
operator|->
name|components
operator|.
name|mods
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|which_mods
operator|&
name|XKB_STATE_MODS_DEPRESSED
condition|)
name|mod_mask
operator||=
name|state
operator|->
name|components
operator|.
name|base_mods
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|which_mods
operator|&
name|XKB_STATE_MODS_LATCHED
condition|)
name|mod_mask
operator||=
name|state
operator|->
name|components
operator|.
name|latched_mods
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|which_mods
operator|&
name|XKB_STATE_MODS_LOCKED
condition|)
name|mod_mask
operator||=
name|state
operator|->
name|components
operator|.
name|locked_mods
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|mods
operator|.
name|mask
operator|&
name|mod_mask
condition|)
block|{
name|state
operator|->
name|components
operator|.
name|leds
operator||=
operator|(
literal|1u
operator|<<
name|idx
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|led
operator|->
name|which_groups
operator|!=
literal|0
operator|&&
name|led
operator|->
name|groups
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|led
operator|->
name|which_groups
operator|&
name|XKB_STATE_LAYOUT_EFFECTIVE
condition|)
name|group_mask
operator||=
operator|(
literal|1u
operator|<<
name|state
operator|->
name|components
operator|.
name|group
operator|)
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|which_groups
operator|&
name|XKB_STATE_LAYOUT_DEPRESSED
condition|)
name|group_mask
operator||=
operator|(
literal|1u
operator|<<
name|state
operator|->
name|components
operator|.
name|base_group
operator|)
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|which_groups
operator|&
name|XKB_STATE_LAYOUT_LATCHED
condition|)
name|group_mask
operator||=
operator|(
literal|1u
operator|<<
name|state
operator|->
name|components
operator|.
name|latched_group
operator|)
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|which_groups
operator|&
name|XKB_STATE_LAYOUT_LOCKED
condition|)
name|group_mask
operator||=
operator|(
literal|1u
operator|<<
name|state
operator|->
name|components
operator|.
name|locked_group
operator|)
expr_stmt|;
if|if
condition|(
name|led
operator|->
name|groups
operator|&
name|group_mask
condition|)
block|{
name|state
operator|->
name|components
operator|.
name|leds
operator||=
operator|(
literal|1u
operator|<<
name|idx
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|led
operator|->
name|ctrls
operator|&
name|state
operator|->
name|keymap
operator|->
name|enabled_ctrls
condition|)
block|{
name|state
operator|->
name|components
operator|.
name|leds
operator||=
operator|(
literal|1u
operator|<<
name|idx
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function
begin_comment
comment|/**  * Calculates the derived state (effective mods/group and LEDs) from an  * up-to-date xkb_state.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|xkb_state_update_derived
name|xkb_state_update_derived
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
block|{
name|xkb_layout_index_t
name|wrapped
decl_stmt|;
name|state
operator|->
name|components
operator|.
name|mods
operator|=
operator|(
name|state
operator|->
name|components
operator|.
name|base_mods
operator||
name|state
operator|->
name|components
operator|.
name|latched_mods
operator||
name|state
operator|->
name|components
operator|.
name|locked_mods
operator|)
expr_stmt|;
comment|/* TODO: Use groups_wrap control instead of always RANGE_WRAP. */
name|wrapped
operator|=
name|wrap_group_into_range
argument_list|(
name|state
operator|->
name|components
operator|.
name|locked_group
argument_list|,
name|state
operator|->
name|keymap
operator|->
name|num_groups
argument_list|,
name|RANGE_WRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|locked_group
operator|=
operator|(
name|wrapped
operator|==
name|XKB_LAYOUT_INVALID
condition|?
literal|0
else|:
name|wrapped
operator|)
expr_stmt|;
name|wrapped
operator|=
name|wrap_group_into_range
argument_list|(
name|state
operator|->
name|components
operator|.
name|base_group
operator|+
name|state
operator|->
name|components
operator|.
name|latched_group
operator|+
name|state
operator|->
name|components
operator|.
name|locked_group
argument_list|,
name|state
operator|->
name|keymap
operator|->
name|num_groups
argument_list|,
name|RANGE_WRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|group
operator|=
operator|(
name|wrapped
operator|==
name|XKB_LAYOUT_INVALID
condition|?
literal|0
else|:
name|wrapped
operator|)
expr_stmt|;
name|xkb_state_led_update_all
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|enum
name|xkb_state_component
DECL|function|get_state_component_changes
name|get_state_component_changes
parameter_list|(
specifier|const
name|struct
name|state_components
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|state_components
modifier|*
name|b
parameter_list|)
block|{
name|xkb_mod_mask_t
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|group
operator|!=
name|b
operator|->
name|group
condition|)
name|mask
operator||=
name|XKB_STATE_LAYOUT_EFFECTIVE
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|base_group
operator|!=
name|b
operator|->
name|base_group
condition|)
name|mask
operator||=
name|XKB_STATE_LAYOUT_DEPRESSED
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|latched_group
operator|!=
name|b
operator|->
name|latched_group
condition|)
name|mask
operator||=
name|XKB_STATE_LAYOUT_LATCHED
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|locked_group
operator|!=
name|b
operator|->
name|locked_group
condition|)
name|mask
operator||=
name|XKB_STATE_LAYOUT_LOCKED
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mods
operator|!=
name|b
operator|->
name|mods
condition|)
name|mask
operator||=
name|XKB_STATE_MODS_EFFECTIVE
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|base_mods
operator|!=
name|b
operator|->
name|base_mods
condition|)
name|mask
operator||=
name|XKB_STATE_MODS_DEPRESSED
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|latched_mods
operator|!=
name|b
operator|->
name|latched_mods
condition|)
name|mask
operator||=
name|XKB_STATE_MODS_LATCHED
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|locked_mods
operator|!=
name|b
operator|->
name|locked_mods
condition|)
name|mask
operator||=
name|XKB_STATE_MODS_LOCKED
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|leds
operator|!=
name|b
operator|->
name|leds
condition|)
name|mask
operator||=
name|XKB_STATE_LEDS
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function
begin_comment
comment|/**  * Given a particular key event, updates the state structure to reflect the  * new modifiers.  */
end_comment
begin_function
name|XKB_EXPORT
name|enum
name|xkb_state_component
DECL|function|xkb_state_update_key
name|xkb_state_update_key
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
block|{
name|xkb_mod_index_t
name|i
decl_stmt|;
name|xkb_mod_mask_t
name|bit
decl_stmt|;
name|struct
name|state_components
name|prev_components
decl_stmt|;
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
init|=
name|XkbKey
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
literal|0
return|;
name|prev_components
operator|=
name|state
operator|->
name|components
expr_stmt|;
name|state
operator|->
name|set_mods
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|clear_mods
operator|=
literal|0
expr_stmt|;
name|xkb_filter_apply_all
argument_list|(
name|state
argument_list|,
name|key
argument_list|,
name|direction
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit
operator|=
literal|1
init|;
name|state
operator|->
name|set_mods
condition|;
name|i
operator|++
operator|,
name|bit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|state
operator|->
name|set_mods
operator|&
name|bit
condition|)
block|{
name|state
operator|->
name|mod_key_count
index|[
name|i
index|]
operator|++
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|base_mods
operator||=
name|bit
expr_stmt|;
name|state
operator|->
name|set_mods
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit
operator|=
literal|1
init|;
name|state
operator|->
name|clear_mods
condition|;
name|i
operator|++
operator|,
name|bit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|state
operator|->
name|clear_mods
operator|&
name|bit
condition|)
block|{
name|state
operator|->
name|mod_key_count
index|[
name|i
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|mod_key_count
index|[
name|i
index|]
operator|<=
literal|0
condition|)
block|{
name|state
operator|->
name|components
operator|.
name|base_mods
operator|&=
operator|~
name|bit
expr_stmt|;
name|state
operator|->
name|mod_key_count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|state
operator|->
name|clear_mods
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
block|}
name|xkb_state_update_derived
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|get_state_component_changes
argument_list|(
operator|&
name|prev_components
argument_list|,
operator|&
name|state
operator|->
name|components
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Updates the state from a set of explicit masks as gained from  * xkb_state_serialize_mods and xkb_state_serialize_groups.  As noted in the  * documentation for these functions in xkbcommon.h, this round-trip is  * lossy, and should only be used to update a slave state mirroring the  * master, e.g. in a client/server window system.  */
end_comment
begin_function
name|XKB_EXPORT
name|enum
name|xkb_state_component
DECL|function|xkb_state_update_mask
name|xkb_state_update_mask
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_mod_mask_t
name|base_mods
parameter_list|,
name|xkb_mod_mask_t
name|latched_mods
parameter_list|,
name|xkb_mod_mask_t
name|locked_mods
parameter_list|,
name|xkb_layout_index_t
name|base_group
parameter_list|,
name|xkb_layout_index_t
name|latched_group
parameter_list|,
name|xkb_layout_index_t
name|locked_group
parameter_list|)
block|{
name|struct
name|state_components
name|prev_components
decl_stmt|;
name|xkb_mod_index_t
name|num_mods
decl_stmt|;
name|xkb_mod_index_t
name|idx
decl_stmt|;
name|prev_components
operator|=
name|state
operator|->
name|components
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|base_mods
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|latched_mods
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|locked_mods
operator|=
literal|0
expr_stmt|;
name|num_mods
operator|=
name|xkb_keymap_num_mods
argument_list|(
name|state
operator|->
name|keymap
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|num_mods
condition|;
name|idx
operator|++
control|)
block|{
name|xkb_mod_mask_t
name|mod
init|=
operator|(
literal|1u
operator|<<
name|idx
operator|)
decl_stmt|;
if|if
condition|(
name|base_mods
operator|&
name|mod
condition|)
name|state
operator|->
name|components
operator|.
name|base_mods
operator||=
name|mod
expr_stmt|;
if|if
condition|(
name|latched_mods
operator|&
name|mod
condition|)
name|state
operator|->
name|components
operator|.
name|latched_mods
operator||=
name|mod
expr_stmt|;
if|if
condition|(
name|locked_mods
operator|&
name|mod
condition|)
name|state
operator|->
name|components
operator|.
name|locked_mods
operator||=
name|mod
expr_stmt|;
block|}
name|state
operator|->
name|components
operator|.
name|base_group
operator|=
name|base_group
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|latched_group
operator|=
name|latched_group
expr_stmt|;
name|state
operator|->
name|components
operator|.
name|locked_group
operator|=
name|locked_group
expr_stmt|;
name|xkb_state_update_derived
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|get_state_component_changes
argument_list|(
operator|&
name|prev_components
argument_list|,
operator|&
name|state
operator|->
name|components
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Provides the symbols to use for the given key and state.  Returns the  * number of symbols pointed to in syms_out.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_key_get_syms
name|xkb_state_key_get_syms
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|,
specifier|const
name|xkb_keysym_t
modifier|*
modifier|*
name|syms_out
parameter_list|)
block|{
name|xkb_layout_index_t
name|layout
decl_stmt|;
name|xkb_level_index_t
name|level
decl_stmt|;
name|layout
operator|=
name|xkb_state_key_get_layout
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
expr_stmt|;
if|if
condition|(
name|layout
operator|==
name|XKB_LAYOUT_INVALID
condition|)
goto|goto
name|err
goto|;
name|level
operator|=
name|xkb_state_key_get_level
argument_list|(
name|state
argument_list|,
name|kc
argument_list|,
name|layout
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|XKB_LEVEL_INVALID
condition|)
goto|goto
name|err
goto|;
return|return
name|xkb_keymap_key_get_syms_by_level
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|,
name|layout
argument_list|,
name|level
argument_list|,
name|syms_out
argument_list|)
return|;
name|err
label|:
operator|*
name|syms_out
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * http://www.x.org/releases/current/doc/kbproto/xkbproto.html#Interpreting_the_Lock_Modifier  */
end_comment
begin_function
specifier|static
name|bool
DECL|function|should_do_caps_transformation
name|should_do_caps_transformation
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
name|xkb_mod_index_t
name|caps
init|=
name|xkb_keymap_mod_get_index
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|XKB_MOD_NAME_CAPS
argument_list|)
decl_stmt|;
return|return
name|xkb_state_mod_index_is_active
argument_list|(
name|state
argument_list|,
name|caps
argument_list|,
name|XKB_STATE_MODS_EFFECTIVE
argument_list|)
operator|>
literal|0
operator|&&
name|xkb_state_mod_index_is_consumed
argument_list|(
name|state
argument_list|,
name|kc
argument_list|,
name|caps
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * http://www.x.org/releases/current/doc/kbproto/xkbproto.html#Interpreting_the_Control_Modifier  */
end_comment
begin_function
specifier|static
name|bool
DECL|function|should_do_ctrl_transformation
name|should_do_ctrl_transformation
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
name|xkb_mod_index_t
name|ctrl
init|=
name|xkb_keymap_mod_get_index
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|XKB_MOD_NAME_CTRL
argument_list|)
decl_stmt|;
return|return
name|xkb_state_mod_index_is_active
argument_list|(
name|state
argument_list|,
name|ctrl
argument_list|,
name|XKB_STATE_MODS_EFFECTIVE
argument_list|)
operator|>
literal|0
operator|&&
name|xkb_state_mod_index_is_consumed
argument_list|(
name|state
argument_list|,
name|kc
argument_list|,
name|ctrl
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Verbatim from libX11:src/xkb/XKBBind.c */
end_comment
begin_function
specifier|static
name|char
DECL|function|XkbToControl
name|XkbToControl
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
name|char
name|c
init|=
name|ch
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'@'
operator|&&
name|c
operator|<
literal|'\177'
operator|)
operator|||
name|c
operator|==
literal|' '
condition|)
name|c
operator|&=
literal|0x1F
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'2'
condition|)
name|c
operator|=
literal|'\000'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'3'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
name|c
operator|-=
operator|(
literal|'3'
operator|-
literal|'\033'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'8'
condition|)
name|c
operator|=
literal|'\177'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|c
operator|=
literal|'_'
operator|&
literal|0x1F
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/**  * Provides either exactly one symbol, or XKB_KEY_NoSymbol.  */
end_comment
begin_function
name|XKB_EXPORT
name|xkb_keysym_t
DECL|function|xkb_state_key_get_one_sym
name|xkb_state_key_get_one_sym
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
specifier|const
name|xkb_keysym_t
modifier|*
name|syms
decl_stmt|;
name|xkb_keysym_t
name|sym
decl_stmt|;
name|int
name|num_syms
decl_stmt|;
name|num_syms
operator|=
name|xkb_state_key_get_syms
argument_list|(
name|state
argument_list|,
name|kc
argument_list|,
operator|&
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_syms
operator|!=
literal|1
condition|)
return|return
name|XKB_KEY_NoSymbol
return|;
name|sym
operator|=
name|syms
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|should_do_caps_transformation
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
condition|)
name|sym
operator|=
name|xkb_keysym_to_upper
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function
begin_comment
comment|/*  * The caps and ctrl transformations require some special handling,  * so we cannot simply use xkb_state_get_one_sym() for them.  * In particular, if Control is set, we must try very hard to find  * some layout in which the keysym is ASCII and thus can be (maybe)  * converted to a control character. libX11 allows to disable this  * behavior with the XkbLC_ControlFallback (see XkbSetXlibControls(3)),  * but it is enabled by default, yippee.  */
end_comment
begin_function
specifier|static
name|xkb_keysym_t
DECL|function|get_one_sym_for_string
name|get_one_sym_for_string
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
name|xkb_level_index_t
name|level
decl_stmt|;
name|xkb_layout_index_t
name|layout
decl_stmt|,
name|num_layouts
decl_stmt|;
specifier|const
name|xkb_keysym_t
modifier|*
name|syms
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|xkb_keysym_t
name|sym
decl_stmt|;
name|layout
operator|=
name|xkb_state_key_get_layout
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
expr_stmt|;
name|num_layouts
operator|=
name|xkb_keymap_num_layouts_for_key
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|)
expr_stmt|;
name|level
operator|=
name|xkb_state_key_get_level
argument_list|(
name|state
argument_list|,
name|kc
argument_list|,
name|layout
argument_list|)
expr_stmt|;
if|if
condition|(
name|layout
operator|==
name|XKB_LAYOUT_INVALID
operator|||
name|num_layouts
operator|==
literal|0
operator|||
name|level
operator|==
name|XKB_LEVEL_INVALID
condition|)
return|return
name|XKB_KEY_NoSymbol
return|;
name|nsyms
operator|=
name|xkb_keymap_key_get_syms_by_level
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|,
name|layout
argument_list|,
name|level
argument_list|,
operator|&
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsyms
operator|!=
literal|1
condition|)
return|return
name|XKB_KEY_NoSymbol
return|;
name|sym
operator|=
name|syms
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|should_do_ctrl_transformation
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
operator|&&
name|sym
operator|>
literal|127u
condition|)
block|{
for|for
control|(
name|xkb_layout_index_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_layouts
condition|;
name|i
operator|++
control|)
block|{
name|level
operator|=
name|xkb_state_key_get_level
argument_list|(
name|state
argument_list|,
name|kc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|XKB_LEVEL_INVALID
condition|)
continue|continue;
name|nsyms
operator|=
name|xkb_keymap_key_get_syms_by_level
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|,
name|i
argument_list|,
name|level
argument_list|,
operator|&
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsyms
operator|==
literal|1
operator|&&
name|syms
index|[
literal|0
index|]
operator|<=
literal|127u
condition|)
block|{
name|sym
operator|=
name|syms
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|should_do_caps_transformation
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
condition|)
block|{
name|sym
operator|=
name|xkb_keysym_to_upper
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_key_get_utf8
name|xkb_state_key_get_utf8
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|xkb_keysym_t
name|sym
decl_stmt|;
specifier|const
name|xkb_keysym_t
modifier|*
name|syms
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
name|tmp
index|[
literal|7
index|]
decl_stmt|;
name|sym
operator|=
name|get_one_sym_for_string
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|XKB_KEY_NoSymbol
condition|)
block|{
name|nsyms
operator|=
literal|1
expr_stmt|;
name|syms
operator|=
operator|&
name|sym
expr_stmt|;
block|}
else|else
block|{
name|nsyms
operator|=
name|xkb_state_key_get_syms
argument_list|(
name|state
argument_list|,
name|kc
argument_list|,
operator|&
name|syms
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure not to truncate in the middle of a UTF-8 sequence. */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ret
init|=
name|xkb_keysym_to_utf8
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
goto|goto
name|err_bad
goto|;
name|ret
operator|--
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|offset
operator|+
name|ret
argument_list|)
operator|<=
name|size
condition|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|offset
argument_list|,
name|tmp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ret
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|offset
operator|>=
name|size
condition|)
goto|goto
name|err_trunc
goto|;
name|buffer
index|[
name|offset
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_utf8
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|)
condition|)
goto|goto
name|err_bad
goto|;
if|if
condition|(
name|offset
operator|==
literal|1
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|buffer
index|[
literal|0
index|]
operator|<=
literal|127u
operator|&&
name|should_do_ctrl_transformation
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
name|XkbToControl
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
name|err_trunc
label|:
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|buffer
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|offset
return|;
name|err_bad
label|:
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|uint32_t
DECL|function|xkb_state_key_get_utf32
name|xkb_state_key_get_utf32
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
name|xkb_keysym_t
name|sym
decl_stmt|;
name|uint32_t
name|cp
decl_stmt|;
name|sym
operator|=
name|get_one_sym_for_string
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xkb_keysym_to_utf32
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|<=
literal|127u
operator|&&
name|should_do_ctrl_transformation
argument_list|(
name|state
argument_list|,
name|kc
argument_list|)
condition|)
name|cp
operator|=
operator|(
name|uint32_t
operator|)
name|XkbToControl
argument_list|(
operator|(
name|char
operator|)
name|cp
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function
begin_comment
comment|/**  * Serialises the requested modifier state into an xkb_mod_mask_t, with all  * the same disclaimers as in xkb_state_update_mask.  */
end_comment
begin_function
name|XKB_EXPORT
name|xkb_mod_mask_t
DECL|function|xkb_state_serialize_mods
name|xkb_state_serialize_mods
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
block|{
name|xkb_mod_mask_t
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_MODS_EFFECTIVE
condition|)
return|return
name|state
operator|->
name|components
operator|.
name|mods
return|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_MODS_DEPRESSED
condition|)
name|ret
operator||=
name|state
operator|->
name|components
operator|.
name|base_mods
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_MODS_LATCHED
condition|)
name|ret
operator||=
name|state
operator|->
name|components
operator|.
name|latched_mods
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_MODS_LOCKED
condition|)
name|ret
operator||=
name|state
operator|->
name|components
operator|.
name|locked_mods
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Serialises the requested group state, with all the same disclaimers as  * in xkb_state_update_mask.  */
end_comment
begin_function
name|XKB_EXPORT
name|xkb_layout_index_t
DECL|function|xkb_state_serialize_layout
name|xkb_state_serialize_layout
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
block|{
name|xkb_layout_index_t
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_EFFECTIVE
condition|)
return|return
name|state
operator|->
name|components
operator|.
name|group
return|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_DEPRESSED
condition|)
name|ret
operator|+=
name|state
operator|->
name|components
operator|.
name|base_group
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_LATCHED
condition|)
name|ret
operator|+=
name|state
operator|->
name|components
operator|.
name|latched_group
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_LOCKED
condition|)
name|ret
operator|+=
name|state
operator|->
name|components
operator|.
name|locked_group
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the given modifier is active with the specified type(s), 0 if  * not, or -1 if the modifier is invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_mod_index_is_active
name|xkb_state_mod_index_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_mod_index_t
name|idx
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|xkb_keymap_num_mods
argument_list|(
name|state
operator|->
name|keymap
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|!
operator|!
operator|(
name|xkb_state_serialize_mods
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
operator|&
operator|(
literal|1u
operator|<<
name|idx
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/**  * Helper function for xkb_state_mod_indices_are_active and  * xkb_state_mod_names_are_active.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|match_mod_masks
name|match_mod_masks
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|,
name|enum
name|xkb_state_match
name|match
parameter_list|,
name|xkb_mod_mask_t
name|wanted
parameter_list|)
block|{
name|xkb_mod_mask_t
name|active
init|=
name|xkb_state_serialize_mods
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|match
operator|&
name|XKB_STATE_MATCH_NON_EXCLUSIVE
operator|)
operator|&&
operator|(
name|active
operator|&
operator|~
name|wanted
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|match
operator|&
name|XKB_STATE_MATCH_ANY
condition|)
return|return
operator|!
operator|!
operator|(
name|active
operator|&
name|wanted
operator|)
return|;
else|else
return|return
operator|(
name|active
operator|&
name|wanted
operator|)
operator|==
name|wanted
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the modifiers are active with the specified type(s), 0 if  * not, or -1 if any of the modifiers are invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_mod_indices_are_active
name|xkb_state_mod_indices_are_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|,
name|enum
name|xkb_state_match
name|match
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|xkb_mod_index_t
name|idx
init|=
literal|0
decl_stmt|;
name|xkb_mod_mask_t
name|wanted
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|xkb_mod_index_t
name|num_mods
init|=
name|xkb_keymap_num_mods
argument_list|(
name|state
operator|->
name|keymap
argument_list|)
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|match
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|idx
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|xkb_mod_index_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|XKB_MOD_INVALID
condition|)
break|break;
if|if
condition|(
name|idx
operator|>=
name|num_mods
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|wanted
operator||=
operator|(
literal|1u
operator|<<
name|idx
operator|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|ret
return|;
return|return
name|match_mod_masks
argument_list|(
name|state
argument_list|,
name|type
argument_list|,
name|match
argument_list|,
name|wanted
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the given modifier is active with the specified type(s), 0 if  * not, or -1 if the modifier is invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_mod_name_is_active
name|xkb_state_mod_name_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
block|{
name|xkb_mod_index_t
name|idx
init|=
name|xkb_keymap_mod_get_index
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
name|XKB_MOD_INVALID
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|xkb_state_mod_index_is_active
argument_list|(
name|state
argument_list|,
name|idx
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the modifiers are active with the specified type(s), 0 if  * not, or -1 if any of the modifiers are invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|ATTR_NULL_SENTINEL
name|int
DECL|function|xkb_state_mod_names_are_active
name|xkb_state_mod_names_are_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|,
name|enum
name|xkb_state_match
name|match
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|xkb_mod_index_t
name|idx
init|=
literal|0
decl_stmt|;
name|xkb_mod_mask_t
name|wanted
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|match
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
break|break;
name|idx
operator|=
name|xkb_keymap_mod_get_index
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|XKB_MOD_INVALID
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|wanted
operator||=
operator|(
literal|1u
operator|<<
name|idx
operator|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|ret
return|;
return|return
name|match_mod_masks
argument_list|(
name|state
argument_list|,
name|type
argument_list|,
name|match
argument_list|,
name|wanted
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the given group is active with the specified type(s), 0 if  * not, or -1 if the group is invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_layout_index_is_active
name|xkb_state_layout_index_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_layout_index_t
name|idx
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|state
operator|->
name|keymap
operator|->
name|num_groups
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_EFFECTIVE
condition|)
name|ret
operator||=
operator|(
name|state
operator|->
name|components
operator|.
name|group
operator|==
name|idx
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_DEPRESSED
condition|)
name|ret
operator||=
operator|(
name|state
operator|->
name|components
operator|.
name|base_group
operator|==
operator|(
name|int32_t
operator|)
name|idx
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_LATCHED
condition|)
name|ret
operator||=
operator|(
name|state
operator|->
name|components
operator|.
name|latched_group
operator|==
operator|(
name|int32_t
operator|)
name|idx
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|XKB_STATE_LAYOUT_LOCKED
condition|)
name|ret
operator||=
operator|(
name|state
operator|->
name|components
operator|.
name|locked_group
operator|==
operator|(
name|int32_t
operator|)
name|idx
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the given modifier is active with the specified type(s), 0 if  * not, or -1 if the modifier is invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_layout_name_is_active
name|xkb_state_layout_name_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
block|{
name|xkb_layout_index_t
name|idx
init|=
name|xkb_keymap_layout_get_index
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
name|XKB_LAYOUT_INVALID
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|xkb_state_layout_index_is_active
argument_list|(
name|state
argument_list|,
name|idx
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the given LED is active, 0 if not, or -1 if the LED is invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_led_index_is_active
name|xkb_state_led_index_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_led_index_t
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|>=
name|darray_size
argument_list|(
name|state
operator|->
name|keymap
operator|->
name|leds
argument_list|)
operator|||
name|darray_item
argument_list|(
name|state
operator|->
name|keymap
operator|->
name|leds
argument_list|,
name|idx
argument_list|)
operator|.
name|name
operator|==
name|XKB_ATOM_NONE
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|!
operator|!
operator|(
name|state
operator|->
name|components
operator|.
name|leds
operator|&
operator|(
literal|1u
operator|<<
name|idx
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the given LED is active, 0 if not, or -1 if the LED is invalid.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_led_name_is_active
name|xkb_state_led_name_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xkb_led_index_t
name|idx
init|=
name|xkb_keymap_led_get_index
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
name|XKB_LED_INVALID
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|xkb_state_led_index_is_active
argument_list|(
name|state
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|xkb_mod_mask_t
DECL|function|key_get_consumed
name|key_get_consumed
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key_type
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|xkb_key_type_entry
modifier|*
name|entry
decl_stmt|;
name|xkb_mod_mask_t
name|preserve
decl_stmt|;
name|xkb_layout_index_t
name|group
decl_stmt|;
name|group
operator|=
name|xkb_state_key_get_layout
argument_list|(
name|state
argument_list|,
name|key
operator|->
name|keycode
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
name|XKB_LAYOUT_INVALID
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|key
operator|->
name|groups
index|[
name|group
index|]
operator|.
name|type
expr_stmt|;
name|entry
operator|=
name|get_entry_for_key_state
argument_list|(
name|state
argument_list|,
name|key
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|preserve
operator|=
name|entry
operator|->
name|preserve
operator|.
name|mask
expr_stmt|;
else|else
name|preserve
operator|=
literal|0
expr_stmt|;
return|return
name|type
operator|->
name|mods
operator|.
name|mask
operator|&
operator|~
name|preserve
return|;
block|}
end_function
begin_comment
comment|/**  * Tests to see if a modifier is used up by our translation of a  * keycode to keysyms, taking note of the current modifier state and  * the appropriate key type's preserve information, if any. This allows  * the user to mask out the modifier in later processing of the  * modifiers, e.g. when implementing hot keys or accelerators.  *  * See also, for example:  * - XkbTranslateKeyCode(3), mod_rtrn return value, from libX11.  * - gdk_keymap_translate_keyboard_state, consumed_modifiers return value,  *   from gtk+.  */
end_comment
begin_function
name|XKB_EXPORT
name|int
DECL|function|xkb_state_mod_index_is_consumed
name|xkb_state_mod_index_is_consumed
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|,
name|xkb_mod_index_t
name|idx
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
init|=
name|XkbKey
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|key
operator|||
name|idx
operator|>=
name|xkb_keymap_num_mods
argument_list|(
name|state
operator|->
name|keymap
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|!
operator|!
operator|(
operator|(
literal|1u
operator|<<
name|idx
operator|)
operator|&
name|key_get_consumed
argument_list|(
name|state
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/**  * Calculates which modifiers should be consumed during key processing,  * and returns the mask with all these modifiers removed.  e.g. if  * given a state of Alt and Shift active for a two-level alphabetic  * key containing plus and equal on the first and second level  * respectively, will return a mask of only Alt, as Shift has been  * consumed by the type handling.  */
end_comment
begin_function
name|XKB_EXPORT
name|xkb_mod_mask_t
DECL|function|xkb_state_mod_mask_remove_consumed
name|xkb_state_mod_mask_remove_consumed
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|,
name|xkb_mod_mask_t
name|mask
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
init|=
name|XkbKey
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
literal|0
return|;
return|return
name|mask
operator|&
operator|~
name|key_get_consumed
argument_list|(
name|state
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function
begin_function
name|XKB_EXPORT
name|xkb_mod_mask_t
DECL|function|xkb_state_key_get_consumed_mods
name|xkb_state_key_get_consumed_mods
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|kc
parameter_list|)
block|{
specifier|const
name|struct
name|xkb_key
modifier|*
name|key
init|=
name|XkbKey
argument_list|(
name|state
operator|->
name|keymap
argument_list|,
name|kc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
literal|0
return|;
return|return
name|key_get_consumed
argument_list|(
name|state
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function
end_unit
