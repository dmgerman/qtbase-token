begin_unit
begin_comment
comment|/*  * Copyright 1985, 1987, 1990, 1998  The Open Group  * Copyright 2008  Dan Nicholson  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * Except as contained in this notice, the names of the authors or their  * institutions shall not be used in advertising or otherwise to promote the  * sale, use or other dealings in this Software without prior written  * authorization from the authors.  */
end_comment
begin_comment
comment|/************************************************************  * Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of Silicon Graphics not be  * used in advertising or publicity pertaining to distribution  * of the software without specific prior written permission.  * Silicon Graphics makes no representation about the suitability  * of this software for any purpose. It is provided "as is"  * without any express or implied warranty.  *  * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON  * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH  * THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  ********************************************************/
end_comment
begin_comment
comment|/*  * Copyright Â© 2009-2012 Daniel Stone  * Copyright Â© 2012 Intel Corporation  * Copyright Â© 2012 Ran Benita  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author: Daniel Stone<daniel@fooishbar.org>  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_XKBCOMMON_H_
end_ifndef
begin_define
DECL|macro|_XKBCOMMON_H_
define|#
directive|define
name|_XKBCOMMON_H_
end_define
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<xkbcommon/xkbcommon-names.h>
end_include
begin_include
include|#
directive|include
file|<xkbcommon/xkbcommon-keysyms.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/**  * @file  * Main libxkbcommon API.  */
comment|/**  * @struct xkb_context  * Opaque top level library context object.  *  * The context contains various general library data and state, like  * logging level and include paths.  *  * Objects are created in a specific context, and multiple contexts may  * coexist simultaneously.  Objects from different contexts are completely  * separated and do not share any memory or state.  */
struct_decl|struct
name|xkb_context
struct_decl|;
comment|/**  * @struct xkb_keymap  * Opaque compiled keymap object.  *  * The keymap object holds all of the static keyboard information obtained  * from compiling XKB files.  *  * A keymap is immutable after it is created (besides reference counts, etc.);  * if you need to change it, you must create a new one.  */
struct_decl|struct
name|xkb_keymap
struct_decl|;
comment|/**  * @struct xkb_state  * Opaque keyboard state object.  *  * State objects contain the active state of a keyboard (or keyboards), such  * as the currently effective layout and the active modifiers.  It acts as a  * simple state machine, wherein key presses and releases are the input, and  * key symbols (keysyms) are the output.  */
struct_decl|struct
name|xkb_state
struct_decl|;
comment|/**  * A number used to represent a physical key on a keyboard.  *  * A standard PC-compatible keyboard might have 102 keys.  An appropriate  * keymap would assign each of them a keycode, by which the user should  * refer to the key throughout the library.  *  * Historically, the X11 protocol, and consequentially the XKB protocol,  * assign only 8 bits for keycodes.  This limits the number of different  * keys that can be used simultaneously in a single keymap to 256  * (disregarding other limitations).  This library does not share this limit;  * keycodes beyond 255 ('extended keycodes') are not treated specially.  * Keymaps and applications which are compatible with X11 should not use  * these keycodes.  *  * The values of specific keycodes are determined by the keymap and the  * underlying input system.  For example, with an X11-compatible keymap  * and Linux evdev scan codes (see linux/input.h), a fixed offset is used:  *  * @code  * xkb_keycode_t keycode_A = KEY_A + 8;  * @endcode  *  * @sa xkb_keycode_is_legal_ext() xkb_keycode_is_legal_x11()  */
DECL|typedef|xkb_keycode_t
typedef|typedef
name|uint32_t
name|xkb_keycode_t
typedef|;
comment|/**  * A number used to represent the symbols generated from a key on a keyboard.  *  * A key, represented by a keycode, may generate different symbols according  * to keyboard state.  For example, on a QWERTY keyboard, pressing the key  * labled \<A\> generates the symbol 'a'.  If the Shift key is held, it  * generates the symbol 'A'.  If a different layout is used, say Greek,  * it generates the symbol 'Î±'.  And so on.  *  * Each such symbol is represented by a keysym.  Note that keysyms are  * somewhat more general, in that they can also represent some "function",  * such as "Left" or "Right" for the arrow keys.  For more information,  * see:  * http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#keysym_encoding  *  * Specifically named keysyms can be found in the  * xkbcommon/xkbcommon-keysyms.h header file.  Their name does not include  * the XKB_KEY_ prefix.  *  * Besides those, any Unicode/ISO 10646 character in the range U0100 to  * U10FFFF can be represented by a keysym value in the range 0x01000100 to  * 0x0110FFFF.  The name of Unicode keysyms is "U<codepoint>", e.g. "UA1B2".  *  * The name of other unnamed keysyms is the hexadecimal representation of  * their value, e.g. "0xabcd1234".  *  * Keysym names are case-sensitive.  */
DECL|typedef|xkb_keysym_t
typedef|typedef
name|uint32_t
name|xkb_keysym_t
typedef|;
comment|/**  * Index of a keyboard layout.  *  * The layout index is a state component which detemines which<em>keyboard  * layout</em> is active.  These may be different alphabets, different key  * arrangements, etc.  *  * Layout indexes are consecutive.  The first layout has index 0.  *  * Each layout is not required to have a name, and the names are not  * guaranteed to be unique (though they are usually provided and unique).  * Therefore, it is not safe to use the name as a unique identifier for a  * layout.  Layout names are case-sensitive.  *  * Layouts are also called "groups" by XKB.  *  * @sa xkb_keymap_num_layouts() xkb_keymap_num_layouts_for_key()  */
DECL|typedef|xkb_layout_index_t
typedef|typedef
name|uint32_t
name|xkb_layout_index_t
typedef|;
comment|/** A mask of layout indexes. */
DECL|typedef|xkb_layout_mask_t
typedef|typedef
name|uint32_t
name|xkb_layout_mask_t
typedef|;
comment|/**  * Index of a shift level.  *  * @todo Explain what are shift levels.  */
DECL|typedef|xkb_level_index_t
typedef|typedef
name|uint32_t
name|xkb_level_index_t
typedef|;
comment|/**  * Index of a modifier.  *  * A @e modifier is a state component which changes the way keys are  * interpreted.  A keymap defines a set of modifiers, such as Alt, Shift,  * Num Lock or Meta, and specifies which keys may @e activate which  * modifiers (in a many-to-many relationship, i.e. a key can activate  * several modifiers, and a modifier may be activated by several keys.  * Different keymaps do this differently).  *  * When retrieving the keysyms for a key, the active modifier set is  * consulted; this detemines the correct shift level to use within the  * currently active layout (see xkb_level_index_t).  *  * Modifier indexes are consecutive.  The first modifier has index 0.  *  * Each modifier must have a name, and the names are unique.  Therefore, it  * is safe to use the name as a unique identifier for a modifier.  The names  * of some common modifiers are provided in the xkbcommon/xkbcommon-names.h  * header file.  Modifier names are case-sensitive.  *  * @sa xkb_keymap_num_mods()  */
DECL|typedef|xkb_mod_index_t
typedef|typedef
name|uint32_t
name|xkb_mod_index_t
typedef|;
comment|/** A mask of modifier indexes. */
DECL|typedef|xkb_mod_mask_t
typedef|typedef
name|uint32_t
name|xkb_mod_mask_t
typedef|;
comment|/**  * Index of a keyboard LED.  *  * @todo Explain what are LEDs.  *  * LED indexes are non-consecutive.  The first LED has index 0.  *  * Each LED must have a name, and the names are unique. Therefore,  * it is safe to use the name as a unique identifier for a LED.  The names  * of some common LEDs are provided in the xkbcommon/xkbcommon-names.h  * header file.  LED names are case-sensitive.  *  * @warning A given keymap may specify an exact index for a given LED.  * Therefore, LED indexing is not necessarily sequential, as opposed to  * modifiers and layouts.  This means that when iterating over the LEDs  * in a keymap using e.g. xkb_keymap_num_leds(), some indexes might be  * invalid.  Given such an index, functions like xkb_keymap_led_get_name()  * will return NULL, and xkb_state_led_index_is_active() will return -1.  *  * LEDs are also called "indicators" by XKB.  *  * @sa xkb_keymap_num_leds()  */
DECL|typedef|xkb_led_index_t
typedef|typedef
name|uint32_t
name|xkb_led_index_t
typedef|;
comment|/** A mask of LED indexes. */
DECL|typedef|xkb_led_mask_t
typedef|typedef
name|uint32_t
name|xkb_led_mask_t
typedef|;
DECL|macro|XKB_KEYCODE_INVALID
define|#
directive|define
name|XKB_KEYCODE_INVALID
value|(0xffffffff)
DECL|macro|XKB_LAYOUT_INVALID
define|#
directive|define
name|XKB_LAYOUT_INVALID
value|(0xffffffff)
DECL|macro|XKB_LEVEL_INVALID
define|#
directive|define
name|XKB_LEVEL_INVALID
value|(0xffffffff)
DECL|macro|XKB_MOD_INVALID
define|#
directive|define
name|XKB_MOD_INVALID
value|(0xffffffff)
DECL|macro|XKB_LED_INVALID
define|#
directive|define
name|XKB_LED_INVALID
value|(0xffffffff)
DECL|macro|XKB_KEYCODE_MAX
define|#
directive|define
name|XKB_KEYCODE_MAX
value|(0xffffffff - 1)
comment|/**  * Test whether a value is a valid extended keycode.  * @sa xkb_keycode_t  **/
DECL|macro|xkb_keycode_is_legal_ext
define|#
directive|define
name|xkb_keycode_is_legal_ext
parameter_list|(
name|key
parameter_list|)
value|(key<= XKB_KEYCODE_MAX)
comment|/**  * Test whether a value is a valid X11 keycode.  * @sa xkb_keycode_t  */
DECL|macro|xkb_keycode_is_legal_x11
define|#
directive|define
name|xkb_keycode_is_legal_x11
parameter_list|(
name|key
parameter_list|)
value|(key>= 8&& key<= 255)
comment|/**  * Names to compile a keymap with, also known as RMLVO.  *  * These names together are the primary identifier for a keymap.  * If any of the members is NULL or an empty string (""), a default value is  * used.  It is recommended to use the system default by passing NULL for  * unspecified values, instead of providing your own defaults.  */
DECL|struct|xkb_rule_names
struct|struct
name|xkb_rule_names
block|{
comment|/** The rules file to use. The rules file describes how to interpret      *  the values of the model, layout, variant and options fields. */
DECL|member|rules
specifier|const
name|char
modifier|*
name|rules
decl_stmt|;
comment|/** The keyboard model by which to interpret keycodes and LEDs. */
DECL|member|model
specifier|const
name|char
modifier|*
name|model
decl_stmt|;
comment|/** A comma separated list of layouts (languages) to include in the      *  keymap. */
DECL|member|layout
specifier|const
name|char
modifier|*
name|layout
decl_stmt|;
comment|/** A comma separated list of variants, one per layout, which may      *  modify or augment the respective layout in various ways. */
DECL|member|variant
specifier|const
name|char
modifier|*
name|variant
decl_stmt|;
comment|/** A comma separated list of options, through which the user specifies      *  non-layout related preferences, like which key combinations are used      *  for switching layouts, or which key is the Compose key. */
DECL|member|options
specifier|const
name|char
modifier|*
name|options
decl_stmt|;
block|}
struct|;
comment|/**  * @defgroup keysyms Keysyms  * Utility functions related to keysyms.  *  * @{  */
comment|/**  * Get the name of a keysym.  *  * For a description of how keysyms are named, see @ref xkb_keysym_t.  *  * @param[in]  keysym The keysym.  * @param[out] buffer A string buffer to write the name into.  * @param[in]  size   Size of the buffer.  *  * @warning If the buffer passed is too small, the string is truncated  * (though still NUL-terminated); a size of at least 64 bytes is recommended.  *  * @returns The number of bytes in the name, excluding the NUL byte. If  * the keysym is invalid, returns -1.  *  * You may check if truncation has occurred by comparing the return value  * with the length of buffer, similarly to the snprintf(3) function.  *  * @sa xkb_keysym_t  */
name|int
name|xkb_keysym_get_name
parameter_list|(
name|xkb_keysym_t
name|keysym
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/** Flags for xkb_keysym_from_name(). */
DECL|enum|xkb_keysym_flags
enum|enum
name|xkb_keysym_flags
block|{
comment|/** Find keysym by case-insensitive search. */
DECL|enumerator|XKB_KEYSYM_CASE_INSENSITIVE
name|XKB_KEYSYM_CASE_INSENSITIVE
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|}
enum|;
comment|/**  * Get a keysym from its name.  *  * @param name The name of a keysym. See remarks in xkb_keysym_get_name();  * this function will accept any name returned by that function.  * @param flags A set of flags controlling how the search is done. If  * invalid flags are passed, this will fail with XKB_KEY_NoSymbol.  *  * If you use the XKB_KEYSYM_CASE_INSENSITIVE flag and two keysym names  * differ only by case, then the lower-case keysym is returned.  For  * instance, for KEY_a and KEY_A, this function would return KEY_a for the  * case-insensitive search.  If this functionality is needed, it is  * recommended to first call this function without this flag; and if that  * fails, only then to try with this flag, while possibly warning the user  * he had misspelled the name, and might get wrong results.  *  * @returns The keysym. If the name is invalid, returns XKB_KEY_NoSymbol.  *  * @sa xkb_keysym_t  */
name|xkb_keysym_t
name|xkb_keysym_from_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|xkb_keysym_flags
name|flags
parameter_list|)
function_decl|;
comment|/**  * Get the Unicode/UTF-8 representation of a keysym.  *  * @param[in]  keysym The keysym.  * @param[out] buffer A buffer to write the UTF-8 string into.  * @param[in]  size   The size of buffer.  Must be at least 7.  *  * @returns The number of bytes written to the buffer (including the  * terminating byte).  If the keysym does not have a Unicode  * representation, returns 0.  If the buffer is too small, returns -1.  */
name|int
name|xkb_keysym_to_utf8
parameter_list|(
name|xkb_keysym_t
name|keysym
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/**  * Get the Unicode/UTF-32 representation of a keysym.  *  * @returns The Unicode/UTF-32 representation of keysym, which is also  * compatible with UCS-4.  If the keysym does not have a Unicode  * representation, returns 0.  */
name|uint32_t
name|xkb_keysym_to_utf32
parameter_list|(
name|xkb_keysym_t
name|keysym
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup context Library Context  * Creating, destroying and using library contexts.  *  * Every keymap compilation request must have a context associated with  * it.  The context keeps around state such as the include path.  *  * @{  */
comment|/** Flags for context creation. */
DECL|enum|xkb_context_flags
enum|enum
name|xkb_context_flags
block|{
comment|/** Create this context with an empty include path. */
DECL|enumerator|XKB_CONTEXT_NO_DEFAULT_INCLUDES
name|XKB_CONTEXT_NO_DEFAULT_INCLUDES
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
comment|/** Don't take RMLVO names from the environment. */
DECL|enumerator|XKB_CONTEXT_NO_ENVIRONMENT_NAMES
name|XKB_CONTEXT_NO_ENVIRONMENT_NAMES
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|, }
enum|;
comment|/**  * Create a new context.  *  * @param flags Optional flags for the context, or 0.  *  * @returns A new context, or NULL on failure.  *  * The user may set some environment variables to affect default values in  * the context. See e.g. xkb_context_set_log_level() and  * xkb_context_set_log_verbosity().  *  * @memberof xkb_context  */
name|struct
name|xkb_context
modifier|*
name|xkb_context_new
parameter_list|(
name|enum
name|xkb_context_flags
name|flags
parameter_list|)
function_decl|;
comment|/**  * Take a new reference on a context.  *  * @returns The passed in context.  *  * @memberof xkb_context  */
name|struct
name|xkb_context
modifier|*
name|xkb_context_ref
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Release a reference on a context, and possibly free it.  *  * @param context The context.  If it is NULL, this function does nothing.  *  * @memberof xkb_context  */
name|void
name|xkb_context_unref
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Store custom user data in the context.  *  * This may be useful in conjunction with xkb_context_set_log_fn() or other  * callbacks.  *  * @memberof xkb_context  */
name|void
name|xkb_context_set_user_data
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
function_decl|;
comment|/**  * Retrieves stored user data from the context.  *  * @returns The stored user data.  If the user data wasn't set, or the  * passed in context is NULL, returns NULL.  *  * This may be useful to access private user data from callbacks like a  * custom logging function.  *  * @memberof xkb_context  **/
name|void
modifier|*
name|xkb_context_get_user_data
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup include-path Include Paths  * Manipulating the include paths in a context.  *  * The include paths are the file-system paths that are searched when an  * include statement is encountered during keymap compilation.  * In most cases, the default include paths are sufficient.  *  * @{  */
comment|/**  * Append a new entry to the context's include path.  *  * @returns 1 on success, or 0 if the include path could not be added or is  * inaccessible.  *  * @memberof xkb_context  */
name|int
name|xkb_context_include_path_append
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
comment|/**  * Append the default include paths to the context's include path.  *  * @returns 1 on success, or 0 if the primary include path could not be added.  *  * @memberof xkb_context  */
name|int
name|xkb_context_include_path_append_default
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Reset the context's include path to the default.  *  * Removes all entries from the context's include path, and inserts the  * default paths.  *  * @returns 1 on success, or 0 if the primary include path could not be added.  *  * @memberof xkb_context  */
name|int
name|xkb_context_include_path_reset_defaults
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Remove all entries from the context's include path.  *  * @memberof xkb_context  */
name|void
name|xkb_context_include_path_clear
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Get the number of paths in the context's include path.  *  * @memberof xkb_context  */
name|unsigned
name|int
name|xkb_context_num_include_paths
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Get a specific include path from the context's include path.  *  * @returns The include path at the specified index.  If the index is  * invalid, returns NULL.  *  * @memberof xkb_context  */
specifier|const
name|char
modifier|*
name|xkb_context_include_path_get
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup logging Logging Handling  * Manipulating how logging from this library is handled.  *  * @{  */
comment|/** Specifies a logging level. */
DECL|enum|xkb_log_level
enum|enum
name|xkb_log_level
block|{
DECL|enumerator|XKB_LOG_LEVEL_CRITICAL
name|XKB_LOG_LEVEL_CRITICAL
init|=
literal|10
block|,
comment|/**< Log critical internal errors only. */
DECL|enumerator|XKB_LOG_LEVEL_ERROR
name|XKB_LOG_LEVEL_ERROR
init|=
literal|20
block|,
comment|/**< Log all errors. */
DECL|enumerator|XKB_LOG_LEVEL_WARNING
name|XKB_LOG_LEVEL_WARNING
init|=
literal|30
block|,
comment|/**< Log warnings and errors. */
DECL|enumerator|XKB_LOG_LEVEL_INFO
name|XKB_LOG_LEVEL_INFO
init|=
literal|40
block|,
comment|/**< Log information, warnings, and errors. */
DECL|enumerator|XKB_LOG_LEVEL_DEBUG
name|XKB_LOG_LEVEL_DEBUG
init|=
literal|50
comment|/**< Log everything. */
block|}
enum|;
comment|/**  * Set the current logging level.  *  * @param context The context in which to set the logging level.  * @param level   The logging level to use.  Only messages from this level  * and below will be logged.  *  * The default level is XKB_LOG_LEVEL_ERROR.  The environment variable  * XKB_LOG_LEVEL, if set in the time the context was created, overrides the  * default value.  It may be specified as a level number or name.  *  * @memberof xkb_context  */
name|void
name|xkb_context_set_log_level
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|)
function_decl|;
comment|/**  * Get the current logging level.  *  * @memberof xkb_context  */
name|enum
name|xkb_log_level
name|xkb_context_get_log_level
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Sets the current logging verbosity.  *  * The library can generate a number of warnings which are not helpful to  * ordinary users of the library.  The verbosity may be increased if more  * information is desired (e.g. when developing a new keymap).  *  * The default verbosity is 0.  The environment variable XKB_LOG_VERBOSITY,  * if set in the time the context was created, overrides the default value.  *  * @param context   The context in which to use the set verbosity.  * @param verbosity The verbosity to use.  Currently used values are  * 1 to 10, higher values being more verbose.  0 would result in no verbose  * messages being logged.  *  * Most verbose messages are of level XKB_LOG_LEVEL_WARNING or lower.  *  * @memberof xkb_context  */
name|void
name|xkb_context_set_log_verbosity
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
name|int
name|verbosity
parameter_list|)
function_decl|;
comment|/**  * Get the current logging verbosity of the context.  *  * @memberof xkb_context  */
name|int
name|xkb_context_get_log_verbosity
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/**  * Set a custom function to handle logging messages.  *  * @param context The context in which to use the set logging function.  * @param log_fn  The function that will be called for logging messages.  * Passing NULL restores the default function, which logs to stderr.  *  * By default, log messages from this library are printed to stderr.  This  * function allows you to replace the default behavior with a custom  * handler.  The handler is only called with messages which match the  * current logging level and verbosity settings for the context.  * level is the logging level of the message.  @a format and @a args are  * the same as in the vprintf(3) function.  *  * You may use xkb_context_set_user_data() on the context, and then call  * xkb_context_get_user_data() from within the logging function to provide  * it with additional private context.  *  * @memberof xkb_context  */
name|void
name|xkb_context_set_log_fn
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
name|void
function_decl|(
modifier|*
name|log_fn
function_decl|)
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
name|enum
name|xkb_log_level
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup keymap Keymap Creation  * Creating and destroying keymaps.  *  * @{  */
comment|/** Flags for keymap compilation. */
DECL|enum|xkb_keymap_compile_flags
enum|enum
name|xkb_keymap_compile_flags
block|{
comment|/** Apparently you can't have empty enums.  What a drag. */
DECL|enumerator|XKB_MAP_COMPILE_PLACEHOLDER
name|XKB_MAP_COMPILE_PLACEHOLDER
init|=
literal|0
block|}
enum|;
comment|/**  * Create a keymap from RMLVO names.  *  * The primary keymap entry point: creates a new XKB keymap from a set of  * RMLVO (Rules + Model + Layouts + Variants + Options) names.  *  * You should almost certainly be using this and nothing else to create  * keymaps.  *  * @param context The context in which to create the keymap.  * @param names   The RMLVO names to use.  In xkbcommon versions prior  *                to 0.2.1, this field must be non-NULL.  In later  *                versions, passing NULL will use the default keymap.  * @param flags   Optional flags for the keymap, or 0.  *  * @returns A keymap compiled according to the RMLVO names, or NULL if  * the compilation failed.  *  * @sa xkb_rule_names  * @memberof xkb_keymap  */
name|struct
name|xkb_keymap
modifier|*
name|xkb_keymap_new_from_names
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
specifier|const
name|struct
name|xkb_rule_names
modifier|*
name|names
parameter_list|,
name|enum
name|xkb_keymap_compile_flags
name|flags
parameter_list|)
function_decl|;
comment|/** The possible keymap formats. */
DECL|enum|xkb_keymap_format
enum|enum
name|xkb_keymap_format
block|{
comment|/** The current/classic XKB text format, as generated by xkbcomp -xkb. */
DECL|enumerator|XKB_KEYMAP_FORMAT_TEXT_V1
name|XKB_KEYMAP_FORMAT_TEXT_V1
init|=
literal|1
block|}
enum|;
comment|/**  * Create a keymap from a keymap file.  *  * @param context The context in which to create the keymap.  * @param file    The keymap file to compile.  * @param format  The text format of the keymap file to compile.  * @param flags   Optional flags for the keymap, or 0.  *  * @returns A keymap compiled from the given XKB keymap file, or NULL if  * the compilation failed.  *  * The file must contain a complete keymap.  For example, in the  * XKB_KEYMAP_FORMAT_TEXT_V1 format, this means the file must contain one  * top level '%xkb_keymap' section, which in turn contains other required  * sections.  *  * @memberof xkb_keymap  */
name|struct
name|xkb_keymap
modifier|*
name|xkb_keymap_new_from_file
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|enum
name|xkb_keymap_format
name|format
parameter_list|,
name|enum
name|xkb_keymap_compile_flags
name|flags
parameter_list|)
function_decl|;
comment|/**  * Create a keymap from a keymap string.  *  * This is just like xkb_keymap_new_from_file(), but instead of a file, gets  * the keymap as one enormous string.  *  * @see xkb_keymap_new_from_string()  * @memberof xkb_keymap  */
name|struct
name|xkb_keymap
modifier|*
name|xkb_keymap_new_from_string
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|enum
name|xkb_keymap_format
name|format
parameter_list|,
name|enum
name|xkb_keymap_compile_flags
name|flags
parameter_list|)
function_decl|;
comment|/**  * Create a keymap from a memory buffer.  *  * This is just like xkb_keymap_new_from_string(), but takes a length argument  * so the input string does not have to be zero-terminated.  *  * @see xkb_keymap_new_from_string()  * @memberof xkb_keymap  */
name|struct
name|xkb_keymap
modifier|*
name|xkb_keymap_new_from_buffer
parameter_list|(
name|struct
name|xkb_context
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|,
name|enum
name|xkb_keymap_format
name|format
parameter_list|,
name|enum
name|xkb_keymap_compile_flags
name|flags
parameter_list|)
function_decl|;
comment|/**  * Take a new reference on a keymap.  *  * @returns The passed in keymap.  *  * @memberof xkb_keymap  */
name|struct
name|xkb_keymap
modifier|*
name|xkb_keymap_ref
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
function_decl|;
comment|/**  * Release a reference on a keymap, and possibly free it.  *  * @param keymap The keymap.  If it is NULL, this function does nothing.  *  * @memberof xkb_keymap  */
name|void
name|xkb_keymap_unref
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
function_decl|;
comment|/**  * Get the keymap as a string in the format from which it was created.  * @sa xkb_keymap_get_as_string()  **/
DECL|macro|XKB_KEYMAP_USE_ORIGINAL_FORMAT
define|#
directive|define
name|XKB_KEYMAP_USE_ORIGINAL_FORMAT
value|((enum xkb_keymap_format) -1)
comment|/**  * Get the compiled keymap as a string.  *  * @param keymap The keymap to get as a string.  * @param format The keymap format to use for the string.  You can pass  * in the special value XKB_KEYMAP_USE_ORIGINAL_FORMAT to use the format  * from which the keymap was originally created.  *  * @returns The keymap as a NUL-terminated string, or NULL if unsuccessful.  *  * The returned string may be fed back into xkb_map_new_from_string() to get  * the exact same keymap (possibly in another process, etc.).  *  * The returned string is dynamically allocated and should be freed by the  * caller.  *  * @memberof xkb_keymap  */
name|char
modifier|*
name|xkb_keymap_get_as_string
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|enum
name|xkb_keymap_format
name|format
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup components Keymap Components  * Enumeration of state components in a keymap.  *  * @{  */
comment|/**  * Get the number of modifiers in the keymap.  *  * @sa xkb_mod_index_t  * @memberof xkb_keymap  */
name|xkb_mod_index_t
name|xkb_keymap_num_mods
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
function_decl|;
comment|/**  * Get the name of a modifier by index.  *  * @returns The name.  If the index is invalid, returns NULL.  *  * @sa xkb_mod_index_t  * @memberof xkb_keymap  */
specifier|const
name|char
modifier|*
name|xkb_keymap_mod_get_name
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_mod_index_t
name|idx
parameter_list|)
function_decl|;
comment|/**  * Get the index of a modifier by name.  *  * @returns The index.  If no modifier with this name exists, returns  * XKB_MOD_INVALID.  *  * @sa xkb_mod_index_t  * @memberof xkb_keymap  */
name|xkb_mod_index_t
name|xkb_keymap_mod_get_index
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/**  * Get the number of layouts in the keymap.  *  * @sa xkb_layout_index_t xkb_rule_names xkb_keymap_num_layouts_for_key()  * @memberof xkb_keymap  */
name|xkb_layout_index_t
name|xkb_keymap_num_layouts
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
function_decl|;
comment|/**  * Get the name of a layout by index.  *  * @returns The name.  If the index is invalid, or the layout does not have  * a name, returns NULL.  *  * @sa xkb_layout_index_t  * @memberof xkb_keymap  */
specifier|const
name|char
modifier|*
name|xkb_keymap_layout_get_name
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_layout_index_t
name|idx
parameter_list|)
function_decl|;
comment|/**  * Get the index of a layout by name.  *  * @returns The index.  If no layout exists with this name, returns  * XKB_LAYOUT_INVALID.  If more than one layout in the keymap has this name,  * returns the lowest index among them.  *  * @memberof xkb_keymap  */
name|xkb_layout_index_t
name|xkb_keymap_layout_get_index
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/**  * Get the number of layouts for a specific key.  *  * This number can be different from xkb_keymap_num_layouts(), but is always  * smaller.  It is the appropriate value to use when iterating over the  * layouts of a key.  *  * @sa xkb_layout_index_t  * @memberof xkb_keymap  */
name|xkb_layout_index_t
name|xkb_keymap_num_layouts_for_key
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|)
function_decl|;
comment|/**  * Get the number of shift levels for a specific key and layout.  *  * If @c layout is out of range for this key (that is, larger or equal to  * the value returned by xkb_keymap_num_layouts_for_key()), it is brought  * back into range in a manner consistent with xkb_state_key_get_layout().  *  * @sa xkb_level_index_t  * @memberof xkb_keymap  */
name|xkb_level_index_t
name|xkb_keymap_num_levels_for_key
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|,
name|xkb_layout_index_t
name|layout
parameter_list|)
function_decl|;
comment|/**  * Get the keysyms obtained from pressing a key in a given layout and  * shift level.  *  * This function is like xkb_state_key_get_syms(), only the layout and  * shift level are not derived from the keyboard state but are instead  * specified explicitly.  *  * @param[in] keymap    The keymap.  * @param[in] key       The keycode of the key.  * @param[in] layout    The layout for which to get the keysyms.  * @param[in] level     The shift level in the layout for which to get the  * keysyms. This must be smaller than:  * @code xkb_keymap_num_layouts_for_key(keymap, key) @endcode  * @param[out] syms_out An immutible array of keysyms corresponding to the  * key in the given layout and shift level.  *  * If @c layout is out of range for this key (that is, larger or equal to  * the value returned by xkb_keymap_num_layouts_for_key()), it is brought  * back into range in a manner consistent with xkb_state_key_get_layout().  *  * @returns The number of keysyms in the syms_out array.  If no keysyms  * are produced by the key in the given layout and shift level, returns 0  * and sets syms_out to NULL.  *  * @sa xkb_state_key_get_syms()  * @memberof xkb_keymap  */
name|int
name|xkb_keymap_key_get_syms_by_level
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|,
name|xkb_layout_index_t
name|layout
parameter_list|,
name|xkb_level_index_t
name|level
parameter_list|,
specifier|const
name|xkb_keysym_t
modifier|*
modifier|*
name|syms_out
parameter_list|)
function_decl|;
comment|/**  * Get the number of LEDs in the keymap.  *  * @warning The range [ 0...xkb_keymap_num_leds() ) includes all of the LEDs  * in the keymap, but may also contain inactive LEDs.  When iterating over  * this range, you need the handle this case when calling functions such as  * xkb_keymap_led_get_name() or xkb_state_led_index_is_active().  *  * @sa xkb_led_index_t  * @memberof xkb_keymap  */
name|xkb_led_index_t
name|xkb_keymap_num_leds
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
function_decl|;
comment|/**  * Get the name of a LED by index.  *  * @returns The name.  If the index is invalid, returns NULL.  *  * @memberof xkb_keymap  */
specifier|const
name|char
modifier|*
name|xkb_keymap_led_get_name
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_led_index_t
name|idx
parameter_list|)
function_decl|;
comment|/**  * Get the index of a LED by name.  *  * @returns The index.  If no LED with this name exists, returns  * XKB_LED_INVALID.  *  * @memberof xkb_keymap  */
name|xkb_led_index_t
name|xkb_keymap_led_get_index
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/**  * Determine whether a key should repeat or not.  *  * A keymap may specify different repeat behaviors for different keys.  * Most keys should generally exhibit repeat behavior; for example, holding  * the 'a' key down in a text editor should normally insert a single 'a'  * character every few milliseconds, until the key is released.  However,  * there are keys which should not or do not need to be repeated.  For  * example, repeating modifier keys such as Left/Right Shift or Caps Lock  * is not generally useful or desired.  *  * @returns 1 if the key should repeat, 0 otherwise.  *  * @memberof xkb_keymap  */
name|int
name|xkb_keymap_key_repeats
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup state Keyboard State  * Creating, destroying and manipulating keyboard state objects.  *  * @{  */
comment|/**  * Create a new keyboard state object for a keymap.  *  * @param keymap The keymap for which to create the state.  *  * @returns A new keyboard state object, or NULL on failure.  *  * @memberof xkb_state  */
name|struct
name|xkb_state
modifier|*
name|xkb_state_new
parameter_list|(
name|struct
name|xkb_keymap
modifier|*
name|keymap
parameter_list|)
function_decl|;
comment|/**  * Take a new reference on a keyboard state object.  *  * @returns The passed in object.  *  * @memberof xkb_state  */
name|struct
name|xkb_state
modifier|*
name|xkb_state_ref
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
function_decl|;
comment|/**  * Release a reference on a keybaord state object, and possibly free it.  *  * @param state The state.  If it is NULL, this function does nothing.  *  * @memberof xkb_state  */
name|void
name|xkb_state_unref
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
function_decl|;
comment|/**  * Get the keymap from which a keyboard state object was created.  *  * @returns The keymap which was used in xkb_state_new() to create this  * state object.  *  * This function does not take a new reference on the keymap; you must  * explicitly reference it yourself if you plan to use it beyond the  * lifetime of the state.  *  * @memberof xkb_state  */
name|struct
name|xkb_keymap
modifier|*
name|xkb_state_get_keymap
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|)
function_decl|;
comment|/** Specifies the direction of the key (press / release). */
DECL|enum|xkb_key_direction
enum|enum
name|xkb_key_direction
block|{
DECL|enumerator|XKB_KEY_UP
name|XKB_KEY_UP
block|,
comment|/**< The key was released. */
DECL|enumerator|XKB_KEY_DOWN
name|XKB_KEY_DOWN
comment|/**< The key was pressed. */
block|}
enum|;
comment|/**  * Modifier and layout types for state objects.  This enum is bitmaskable,  * e.g. (XKB_STATE_MODS_DEPRESSED | XKB_STATE_MODS_LATCHED) is valid to  * exclude locked modifiers.  *  * In XKB, the DEPRESSED components are also known as 'base'.  */
DECL|enum|xkb_state_component
enum|enum
name|xkb_state_component
block|{
comment|/** Depressed modifiers, i.e. a key is physically holding them. */
DECL|enumerator|XKB_STATE_MODS_DEPRESSED
name|XKB_STATE_MODS_DEPRESSED
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
comment|/** Latched modifiers, i.e. will be unset after the next non-modifier      *  key press. */
DECL|enumerator|XKB_STATE_MODS_LATCHED
name|XKB_STATE_MODS_LATCHED
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
comment|/** Locked modifiers, i.e. will be unset after the key provoking the      *  lock has been pressed again. */
DECL|enumerator|XKB_STATE_MODS_LOCKED
name|XKB_STATE_MODS_LOCKED
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
comment|/** Effective modifiers, i.e. currently active and affect key      *  processing (derived from the other state components). */
DECL|enumerator|XKB_STATE_MODS_EFFECTIVE
name|XKB_STATE_MODS_EFFECTIVE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
comment|/** Depressed layout, i.e. a key is physically holding it. */
DECL|enumerator|XKB_STATE_LAYOUT_DEPRESSED
name|XKB_STATE_LAYOUT_DEPRESSED
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
comment|/** Latched layout, i.e. will be unset after the next non-modifier      *  key press. */
DECL|enumerator|XKB_STATE_LAYOUT_LATCHED
name|XKB_STATE_LAYOUT_LATCHED
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
comment|/** Locked layout, i.e. will be unset after the key provoking the lock      *  has been pressed again. */
DECL|enumerator|XKB_STATE_LAYOUT_LOCKED
name|XKB_STATE_LAYOUT_LOCKED
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
comment|/** Effective layout, i.e. currently active and affects key processing      *  (derived from the other state components). */
DECL|enumerator|XKB_STATE_LAYOUT_EFFECTIVE
name|XKB_STATE_LAYOUT_EFFECTIVE
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
comment|/** LEDs (derived from the other state components). */
DECL|enumerator|XKB_STATE_LEDS
name|XKB_STATE_LEDS
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|}
enum|;
comment|/**  * Update the keyboard state to reflect a given key being pressed or  * released.  *  * @returns A mask of state components that have changed as a result of  * the update.  If nothing in the state has changed, returns 0.  *  * @memberof xkb_state  */
name|enum
name|xkb_state_component
name|xkb_state_update_key
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|,
name|enum
name|xkb_key_direction
name|direction
parameter_list|)
function_decl|;
comment|/**  * Get the keysyms obtained from pressing a particular key in a given  * keyboard state.  *  * Get the keysyms for a key according to the current active layout,  * modifiers and shift level for the key, as determined by a keyboard  * state.  *  * @param[in]  state    The keyboard state object.  * @param[in]  key      The keycode of the key.  * @param[out] syms_out An immutable array of keysyms corresponding the  * key in the given keyboard state.  *  * As an extension to XKB, this function can return more than one keysym.  * If you do not want to handle this case, you can use  * xkb_state_key_get_one_sym().  *  * @returns The number of keysyms in the syms_out array.  If no keysyms  * are produced by the key in the given keyboard state, returns 0 and sets  * syms_out to NULL.  *  * @memberof xkb_state  */
name|int
name|xkb_state_key_get_syms
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|,
specifier|const
name|xkb_keysym_t
modifier|*
modifier|*
name|syms_out
parameter_list|)
function_decl|;
comment|/**  * Get the single keysym obtained from pressing a particular key in a  * given keyboard state.  *  * This function is similar to xkb_state_key_get_syms(), but with a  * simplified interface for users which cannot or do not want to handle  * the case where multiple keysyms are returned.  *  * @returns The keysym.  If the key does not have exactly one keysym,  * returns XKB_KEY_NoSymbol  *  * @sa xkb_state_key_get_syms()  * @memberof xkb_state  */
name|xkb_keysym_t
name|xkb_state_key_get_one_sym
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|)
function_decl|;
comment|/**  * Get the effective layout index for a key in a given keyboard state.  *  * @returns The layout index for the key in the given keyboard state.  If  * the given keycode is invalid, or if the key is not included in any  * layout at all, returns XKB_LAYOUT_INVALID.  *  * @invariant If the returned layout is valid, the following always holds:  * @code  * xkb_state_key_get_layout(state, key)< xkb_keymap_num_layouts_for_key(keymap, key)  * @endcode  *  * @memberof xkb_state  */
name|xkb_layout_index_t
name|xkb_state_key_get_layout
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|)
function_decl|;
comment|/**  * Get the effective shift level for a key in a given keyboard state and  * layout.  *  * @param state The keyboard state.  * @param key The keycode of the key.  * @param layout The layout for which to get the shift level.  This must be  * smaller than:  * @code xkb_keymap_num_layouts_for_key(keymap, key) @endcode  * usually it would be:  * @code xkb_state_key_get_layout(state, key) @endcode  *  * @return The shift level index.  If the key or layout are invalid,  * returns XKB_LEVEL_INVALID.  *  * @invariant If the returned level is valid, the following always holds:  * @code  * xkb_state_key_get_level(state, key, layout)< xkb_keymap_num_levels_for_key(keymap, key, layout)  * @endcode  *  * @memberof xkb_state  */
name|xkb_level_index_t
name|xkb_state_key_get_level
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|,
name|xkb_layout_index_t
name|layout
parameter_list|)
function_decl|;
comment|/**  * Match flags for xkb_state_mod_indices_are_active and  * xkb_state_mod_names_are_active, specifying how the conditions for a  * successful match.  XKB_STATE_MATCH_NON_EXCLUSIVE is bitmaskable with  * the other modes.  */
DECL|enum|xkb_state_match
enum|enum
name|xkb_state_match
block|{
comment|/** Returns true if any of the modifiers are active. */
DECL|enumerator|XKB_STATE_MATCH_ANY
name|XKB_STATE_MATCH_ANY
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
comment|/** Returns true if all of the modifiers are active. */
DECL|enumerator|XKB_STATE_MATCH_ALL
name|XKB_STATE_MATCH_ALL
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
comment|/** Makes matching non-exclusive, i.e. will not return false if a      *  modifier not specified in the arguments is active. */
DECL|enumerator|XKB_STATE_MATCH_NON_EXCLUSIVE
name|XKB_STATE_MATCH_NON_EXCLUSIVE
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
block|}
enum|;
comment|/**  * Update a keyboard state from a set of explicit masks.  *  * This entry point is really only for window systems and the like, where a  * master process holds an xkb_state, then serializes it over a wire  * protocol, and clients then use the serialization to feed in to their own  * xkb_state.  *  * All parameters must always be passed, or the resulting state may be  * incoherent.  *  * The serialization is lossy and will not survive round trips; it must only  * be used to feed slave state objects, and must not be used to update the  * master state.  *  * Please do not use this unless you fit the description above.  *  * @returns A mask of state components that have changed as a result of  * the update.  If nothing in the state has changed, returns 0.  *  * @memberof xkb_state  *  * @sa xkb_state_component  */
name|enum
name|xkb_state_component
name|xkb_state_update_mask
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_mod_mask_t
name|depressed_mods
parameter_list|,
name|xkb_mod_mask_t
name|latched_mods
parameter_list|,
name|xkb_mod_mask_t
name|locked_mods
parameter_list|,
name|xkb_layout_index_t
name|depressed_layout
parameter_list|,
name|xkb_layout_index_t
name|latched_layout
parameter_list|,
name|xkb_layout_index_t
name|locked_layout
parameter_list|)
function_decl|;
comment|/**  * The counterpart to xkb_state_update_mask for modifiers, to be used on  * the server side of serialization.  *  * @param state      The keyboard state.  * @param components A mask of the modifier state components to serialize.  * State components other than XKB_STATE_MODS_* are ignored.  * If XKB_STATE_MODS_EFFECTIVE is included, all other state components are  * ignored.  *  * @returns A xkb_mod_mask_t representing the given components of the  * modifier state.  *  * This function should not be used in regular clients; please use the  * xkb_state_mod_*_is_active API instead.  *  * @memberof xkb_state  */
name|xkb_mod_mask_t
name|xkb_state_serialize_mods
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|components
parameter_list|)
function_decl|;
comment|/**  * The counterpart to xkb_state_update_mask for layouts, to be used on  * the server side of serialization.  *  * @param state      The keyboard state.  * @param components A mask of the layout state components to serialize.  * State components other than XKB_STATE_LAYOUT_* are ignored.  * If XKB_STATE_LAYOUT_EFFECTIVE is included, all other state components are  * ignored.  *  * @returns A layout index representing the given components of the  * layout state.  *  * This function should not be used in regular clients; please use the  * xkb_state_layout_*_is_active API instead.  *  * @memberof xkb_state  */
name|xkb_layout_index_t
name|xkb_state_serialize_layout
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|components
parameter_list|)
function_decl|;
comment|/**  * Test whether a modifier is active in a given keyboard state by name.  *  * @returns 1 if the modifier is active, 0 if it is not.  If the modifier  * name does not exist in the keymap, returns -1.  *  * @memberof xkb_state  */
name|int
name|xkb_state_mod_name_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
function_decl|;
comment|/**  * Test whether a set of modifiers are active in a given keyboard state by  * name.  *  * @param state The keyboard state.  * @param type  The component of the state against which to match the  * given modifiers.  * @param match The manner by which to match the state against the  * given modifiers.  * @param ...   The set of of modifier names to test, terminated by a NULL  * argument (sentinel).  *  * @returns 1 if the modifiers are active, 0 if they are not.  If any of  * the modifier names do not exist in the keymap, returns -1.  *  * @memberof xkb_state  */
name|int
name|xkb_state_mod_names_are_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|,
name|enum
name|xkb_state_match
name|match
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/**  * Test whether a modifier is active in a given keyboard state by index.  *  * @returns 1 if the modifier is active, 0 if it is not.  If the modifier  * index is invalid in the keymap, returns -1.  *  * @memberof xkb_state  */
name|int
name|xkb_state_mod_index_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_mod_index_t
name|idx
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
function_decl|;
comment|/**  * Test whether a set of modifiers are active in a given keyboard state by  * index.  *  * @param state The keyboard state.  * @param type  The component of the state against which to match the  * given modifiers.  * @param match The manner by which to match the state against the  * given modifiers.  * @param ...   The set of of modifier indexes to test, terminated by a  * XKB_MOD_INVALID argument (sentinel).  *  * @returns 1 if the modifiers are active, 0 if they are not.  If any of  * the modifier indexes are invalid in the keymap, returns -1.  *  * @memberof xkb_state  */
name|int
name|xkb_state_mod_indices_are_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|,
name|enum
name|xkb_state_match
name|match
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/**  * Test whether a modifier is consumed by keyboard state translation for  * a key.  *  * Some functions, like xkb_state_key_get_syms(), look at the state of  * the modifiers in the keymap and derive from it the correct shift level  * to use for the key.  For example, in a US layout, pressing the key  * labeled \<A\> while the Shift modifier is active, generates the keysym 'A'.  * In this case, the Shift modifier is said to be consumed.  However, the  * Num Lock modifier does not affect this translation at all, even if it  * active, so it is not consumed by this translation.  *  * It may be desirable for some application to not reuse consumed modifiers  * for further processing, e.g. for hotkeys or keyboard shortcuts. To  * understand why, consider some requirements from a standard shortcut  * mechanism, and how they are implemented:  *  * 1. The shortcut's modifiers must match exactly to the state. For example,  *    it is possible to bind separate actions to \<Alt\>\<Tab\> and to  *    \<Alt\>\<Shift\>\<Tab\>. Further, if only \<Alt\>\<Tab\> is bound to  *    an action, pressing \<Alt\>\<Shift\>\<Tab\> should not trigger the  *    shortcut.  *    Effectively, this means that the modifiers are compared using the  *    equality operator (==).  * 2. Only relevant modifiers are considered for the matching. For example,  *    Caps Lock and Num Lock should not generally affect the matching, e.g.  *    when matching \<Alt\>\<Tab\> against the state, it does not matter  *    whether Num Lock is active or not. These relevant, or significant,  *    modifiers usually include Alt, Control, Shift, Super and similar.  *    Effectively, this means that non-significant modifiers are masked out,  *    before doing the comparison as described above.  * 3. The matching must be independent of the layout/keymap. For example,  *    the \<Plus\> (+) symbol is found on the first level on some layouts,  *    and requires holding Shift on others. If you simply bind the action  *    to the \<Plus\> keysym, it would work for the unshifted kind, but  *    not for the others, because the match against Shift would fail. If  *    you bind the action to \<Shift\>\<Plus\>, only the shifted kind would  *    work. So what is needed is to recognize that Shift is used up in the  *    translation of the keysym itself, and therefore should not be included  *    in the matching.  *    Effectively, this means that consumed modifiers (Shift in this example)  *    are masked out as well, before doing the comparison.  *  * To summarize, this is how the matching would be performed:  * @code  *   (keysym == shortcut_keysym)&&  *   ((state_modifiers& ~consumed_modifiers& significant_modifiers) == shortcut_modifiers)  * @endcode  *  * @c state_modifiers are the modifiers reported by  * xkb_state_mod_index_is_active() and similar functions.  * @c consumed_modifiers are the modifiers reported by  * xkb_state_mod_index_is_consumed().  * @c significant_modifiers are decided upon by the application/toolkit/user;  * it is up to them to decide whether these are configurable or hard-coded.  *  * @returns 1 if the modifier is consumed, 0 if it is not.  If the modifier  * index is not valid in the keymap, returns -1.  *  * @sa xkb_state_mod_mask_remove_consumed()  * @memberof xkb_state  */
name|int
name|xkb_state_mod_index_is_consumed
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|,
name|xkb_mod_index_t
name|idx
parameter_list|)
function_decl|;
comment|/**  * Remove consumed modifiers from a modifier mask for a key.  *  * Takes the given modifier mask, and removes all modifiers which are  * consumed for that particular key (as in xkb_state_mod_index_is_consumed()).  *  * @sa xkb_state_mod_index_is_consumed()  * @memberof xkb_state  */
name|xkb_mod_mask_t
name|xkb_state_mod_mask_remove_consumed
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_keycode_t
name|key
parameter_list|,
name|xkb_mod_mask_t
name|mask
parameter_list|)
function_decl|;
comment|/**  * Test whether a layout is active in a given keyboard state by name.  *  * @returns 1 if the layout is active, 0 if it is not.  If no layout with  * this name exists in the keymap, return -1.  *  * If multiple layouts in the keymap have this name, the one with the lowest  * index is tested.  *  * @sa xkb_layout_index_t  * @memberof xkb_state  */
name|int
name|xkb_state_layout_name_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
function_decl|;
comment|/**  * Test whether a layout is active in a given keyboard state by index.  *  * @returns 1 if the layout is active, 0 if it is not.  If the layout index  * is not valid in the keymap, returns -1.  *  * @sa xkb_layout_index_t  * @memberof xkb_state  */
name|int
name|xkb_state_layout_index_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_layout_index_t
name|idx
parameter_list|,
name|enum
name|xkb_state_component
name|type
parameter_list|)
function_decl|;
comment|/**  * Test whether a LED is active in a given keyboard state by name.  *  * @returns 1 if the LED is active, 0 if it not.  If no LED with this name  * exists in the keymap, returns -1.  *  * @sa xkb_led_index_t  * @memberof xkb_state  */
name|int
name|xkb_state_led_name_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/**  * Test whether a LED is active in a given keyboard state by index.  *  * @returns 1 if the LED is active, 0 if it not.  If the LED index is not  * valid in the keymap, returns -1.  *  * @sa xkb_led_index_t  * @memberof xkb_state  */
name|int
name|xkb_state_led_index_is_active
parameter_list|(
name|struct
name|xkb_state
modifier|*
name|state
parameter_list|,
name|xkb_led_index_t
name|idx
parameter_list|)
function_decl|;
comment|/** @} */
comment|/* Leave this include last, so it can pick up our types, etc. */
include|#
directive|include
file|<xkbcommon/xkbcommon-compat.h>
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_comment
comment|/* extern "C" */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _XKBCOMMON_H_ */
end_comment
end_unit
