begin_unit
begin_comment
comment|/* The Keccak sponge function, designed by Guido Bertoni, Joan Daemen, MichaÃ«l Peeters and Gilles Van Assche. For more information, feedback or questions, please refer to our website: http://keccak.noekeon.org/  Implementation by the designers, hereby denoted as "the implementer".  To the extent possible under law, the implementer has waived all copyright and related or neighboring rights to the source code in this file. http://creativecommons.org/publicdomain/zero/1.0/ */
end_comment
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|//#include "KeccakNISTInterface.h"
end_comment
begin_include
include|#
directive|include
file|"KeccakF-1600-interface.h"
end_include
begin_function
DECL|function|Init
specifier|static
name|HashReturn
name|Init
parameter_list|(
name|hashState
modifier|*
name|state
parameter_list|,
name|int
name|hashbitlen
parameter_list|)
block|{
switch|switch
condition|(
name|hashbitlen
condition|)
block|{
case|case
literal|0
case|:
comment|// Default parameters, arbitrary length output
name|InitSponge
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
literal|1024
argument_list|,
literal|576
argument_list|)
expr_stmt|;
break|break;
case|case
literal|224
case|:
name|InitSponge
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
literal|1152
argument_list|,
literal|448
argument_list|)
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|InitSponge
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
literal|1088
argument_list|,
literal|512
argument_list|)
expr_stmt|;
break|break;
case|case
literal|384
case|:
name|InitSponge
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
literal|832
argument_list|,
literal|768
argument_list|)
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|InitSponge
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
literal|576
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|BAD_HASHLEN
return|;
block|}
name|state
operator|->
name|fixedOutputLength
operator|=
name|hashbitlen
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|Update
specifier|static
name|HashReturn
name|Update
parameter_list|(
name|hashState
modifier|*
name|state
parameter_list|,
specifier|const
name|BitSequence
modifier|*
name|data
parameter_list|,
name|DataLength
name|databitlen
parameter_list|)
block|{
if|if
condition|(
operator|(
name|databitlen
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|HashReturn
operator|)
name|Absorb
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
name|data
argument_list|,
name|databitlen
argument_list|)
return|;
else|else
block|{
name|HashReturn
name|ret
init|=
operator|(
name|HashReturn
operator|)
name|Absorb
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
name|data
argument_list|,
name|databitlen
operator|-
operator|(
name|databitlen
operator|%
literal|8
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|SUCCESS
condition|)
block|{
name|unsigned
name|char
name|lastByte
decl_stmt|;
comment|// Align the last partial byte to the least significant bits
name|lastByte
operator|=
name|data
index|[
name|databitlen
operator|/
literal|8
index|]
operator|>>
operator|(
literal|8
operator|-
operator|(
name|databitlen
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|HashReturn
operator|)
name|Absorb
argument_list|(
operator|(
name|spongeState
operator|*
operator|)
name|state
argument_list|,
operator|&
name|lastByte
argument_list|,
name|databitlen
operator|%
literal|8
argument_list|)
return|;
block|}
else|else
return|return
name|ret
return|;
block|}
block|}
end_function
begin_function
DECL|function|Final
specifier|static
name|HashReturn
name|Final
parameter_list|(
name|hashState
modifier|*
name|state
parameter_list|,
name|BitSequence
modifier|*
name|hashval
parameter_list|)
block|{
return|return
operator|(
name|HashReturn
operator|)
name|Squeeze
argument_list|(
name|state
argument_list|,
name|hashval
argument_list|,
name|state
operator|->
name|fixedOutputLength
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Hash
specifier|static
name|HashReturn
name|Hash
parameter_list|(
name|int
name|hashbitlen
parameter_list|,
specifier|const
name|BitSequence
modifier|*
name|data
parameter_list|,
name|DataLength
name|databitlen
parameter_list|,
name|BitSequence
modifier|*
name|hashval
parameter_list|)
block|{
name|hashState
name|state
decl_stmt|;
name|HashReturn
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|hashbitlen
operator|!=
literal|224
operator|)
operator|&&
operator|(
name|hashbitlen
operator|!=
literal|256
operator|)
operator|&&
operator|(
name|hashbitlen
operator|!=
literal|384
operator|)
operator|&&
operator|(
name|hashbitlen
operator|!=
literal|512
operator|)
condition|)
return|return
name|BAD_HASHLEN
return|;
comment|// Only the four fixed output lengths available through this API
name|result
operator|=
name|Init
argument_list|(
operator|&
name|state
argument_list|,
name|hashbitlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
return|return
name|result
return|;
name|result
operator|=
name|Update
argument_list|(
operator|&
name|state
argument_list|,
name|data
argument_list|,
name|databitlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
return|return
name|result
return|;
name|result
operator|=
name|Final
argument_list|(
operator|&
name|state
argument_list|,
name|hashval
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
end_unit
