begin_unit
begin_comment
comment|/* The Keccak sponge function, designed by Guido Bertoni, Joan Daemen, MichaÃ«l Peeters and Gilles Van Assche. For more information, feedback or questions, please refer to our website: http://keccak.noekeon.org/  Implementation by the designers, hereby denoted as "the implementer".  To the extent possible under law, the implementer has waived all copyright and related or neighboring rights to the source code in this file. http://creativecommons.org/publicdomain/zero/1.0/ */
end_comment
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|"KeccakSponge.h"
end_include
begin_include
include|#
directive|include
file|"KeccakF-1600-interface.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|KeccakReference
end_ifdef
begin_include
include|#
directive|include
file|"displayIntermediateValues.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|InitSponge
specifier|static
name|int
name|InitSponge
parameter_list|(
name|spongeState
modifier|*
name|state
parameter_list|,
name|unsigned
name|int
name|rate
parameter_list|,
name|unsigned
name|int
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|rate
operator|+
name|capacity
operator|!=
literal|1600
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|rate
operator|<=
literal|0
operator|)
operator|||
operator|(
name|rate
operator|>=
literal|1600
operator|)
operator|||
operator|(
operator|(
name|rate
operator|%
literal|64
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|1
return|;
name|KeccakInitialize
argument_list|()
expr_stmt|;
name|state
operator|->
name|rate
operator|=
name|rate
expr_stmt|;
name|state
operator|->
name|capacity
operator|=
name|capacity
expr_stmt|;
name|state
operator|->
name|fixedOutputLength
operator|=
literal|0
expr_stmt|;
name|KeccakInitializeState
argument_list|(
name|state
operator|->
name|state
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|state
operator|->
name|dataQueue
argument_list|,
literal|0
argument_list|,
name|KeccakMaximumRateInBytes
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsInQueue
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|squeezing
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|bitsAvailableForSqueezing
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|AbsorbQueue
specifier|static
name|void
name|AbsorbQueue
parameter_list|(
name|spongeState
modifier|*
name|state
parameter_list|)
block|{
comment|// state->bitsInQueue is assumed to be equal to state->rate
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast576
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|576
condition|)
name|KeccakAbsorb576bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast832
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|832
condition|)
name|KeccakAbsorb832bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1024
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1024
condition|)
name|KeccakAbsorb1024bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1088
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1088
condition|)
name|KeccakAbsorb1088bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1152
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1152
condition|)
name|KeccakAbsorb1152bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1344
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1344
condition|)
name|KeccakAbsorb1344bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|KeccakAbsorb
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|64
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsInQueue
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Absorb
specifier|static
name|int
name|Absorb
parameter_list|(
name|spongeState
modifier|*
name|state
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|long
name|databitlen
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|i
decl_stmt|,
name|j
decl_stmt|,
name|wholeBlocks
decl_stmt|;
name|unsigned
name|int
name|partialBlock
decl_stmt|,
name|partialByte
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|curData
decl_stmt|;
if|if
condition|(
operator|(
name|state
operator|->
name|bitsInQueue
operator|%
literal|8
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|// Only the last call may contain a partial byte
if|if
condition|(
name|state
operator|->
name|squeezing
condition|)
return|return
literal|1
return|;
comment|// Too late for additional input
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|databitlen
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|->
name|bitsInQueue
operator|==
literal|0
operator|)
operator|&&
operator|(
name|databitlen
operator|>=
name|state
operator|->
name|rate
operator|)
operator|&&
operator|(
name|i
operator|<=
operator|(
name|databitlen
operator|-
name|state
operator|->
name|rate
operator|)
operator|)
condition|)
block|{
name|wholeBlocks
operator|=
operator|(
name|databitlen
operator|-
name|i
operator|)
operator|/
name|state
operator|->
name|rate
expr_stmt|;
name|curData
operator|=
name|data
operator|+
name|i
operator|/
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|ProvideFast576
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|576
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wholeBlocks
condition|;
name|j
operator|++
operator|,
name|curData
operator|+=
literal|576
operator|/
literal|8
control|)
block|{
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KeccakAbsorb576bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|curData
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast832
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|832
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wholeBlocks
condition|;
name|j
operator|++
operator|,
name|curData
operator|+=
literal|832
operator|/
literal|8
control|)
block|{
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KeccakAbsorb832bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|curData
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1024
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1024
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wholeBlocks
condition|;
name|j
operator|++
operator|,
name|curData
operator|+=
literal|1024
operator|/
literal|8
control|)
block|{
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KeccakAbsorb1024bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|curData
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1088
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1088
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wholeBlocks
condition|;
name|j
operator|++
operator|,
name|curData
operator|+=
literal|1088
operator|/
literal|8
control|)
block|{
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KeccakAbsorb1088bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|curData
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1152
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1152
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wholeBlocks
condition|;
name|j
operator|++
operator|,
name|curData
operator|+=
literal|1152
operator|/
literal|8
control|)
block|{
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KeccakAbsorb1152bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|curData
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1344
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1344
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wholeBlocks
condition|;
name|j
operator|++
operator|,
name|curData
operator|+=
literal|1344
operator|/
literal|8
control|)
block|{
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KeccakAbsorb1344bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|curData
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wholeBlocks
condition|;
name|j
operator|++
operator|,
name|curData
operator|+=
name|state
operator|->
name|rate
operator|/
literal|8
control|)
block|{
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block to be absorbed"
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KeccakAbsorb
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|curData
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|+=
name|wholeBlocks
operator|*
name|state
operator|->
name|rate
expr_stmt|;
block|}
else|else
block|{
name|partialBlock
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|databitlen
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|partialBlock
operator|+
name|state
operator|->
name|bitsInQueue
operator|>
name|state
operator|->
name|rate
condition|)
name|partialBlock
operator|=
name|state
operator|->
name|rate
operator|-
name|state
operator|->
name|bitsInQueue
expr_stmt|;
name|partialByte
operator|=
name|partialBlock
operator|%
literal|8
expr_stmt|;
name|partialBlock
operator|-=
name|partialByte
expr_stmt|;
name|memcpy
argument_list|(
name|state
operator|->
name|dataQueue
operator|+
name|state
operator|->
name|bitsInQueue
operator|/
literal|8
argument_list|,
name|data
operator|+
name|i
operator|/
literal|8
argument_list|,
name|partialBlock
operator|/
literal|8
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsInQueue
operator|+=
name|partialBlock
expr_stmt|;
name|i
operator|+=
name|partialBlock
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|bitsInQueue
operator|==
name|state
operator|->
name|rate
condition|)
name|AbsorbQueue
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|partialByte
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|mask
init|=
operator|(
literal|1
operator|<<
name|partialByte
operator|)
operator|-
literal|1
decl_stmt|;
name|state
operator|->
name|dataQueue
index|[
name|state
operator|->
name|bitsInQueue
operator|/
literal|8
index|]
operator|=
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|&
name|mask
expr_stmt|;
name|state
operator|->
name|bitsInQueue
operator|+=
name|partialByte
expr_stmt|;
name|i
operator|+=
name|partialByte
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|PadAndSwitchToSqueezingPhase
specifier|static
name|void
name|PadAndSwitchToSqueezingPhase
parameter_list|(
name|spongeState
modifier|*
name|state
parameter_list|)
block|{
comment|// Note: the bits are numbered from 0=LSB to 7=MSB
if|if
condition|(
name|state
operator|->
name|bitsInQueue
operator|+
literal|1
operator|==
name|state
operator|->
name|rate
condition|)
block|{
name|state
operator|->
name|dataQueue
index|[
name|state
operator|->
name|bitsInQueue
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|state
operator|->
name|bitsInQueue
operator|%
literal|8
operator|)
expr_stmt|;
name|AbsorbQueue
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|state
operator|->
name|dataQueue
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|state
operator|->
name|dataQueue
operator|+
operator|(
name|state
operator|->
name|bitsInQueue
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|8
operator|-
operator|(
name|state
operator|->
name|bitsInQueue
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|state
operator|->
name|dataQueue
index|[
name|state
operator|->
name|bitsInQueue
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|state
operator|->
name|bitsInQueue
operator|%
literal|8
operator|)
expr_stmt|;
block|}
name|state
operator|->
name|dataQueue
index|[
operator|(
name|state
operator|->
name|rate
operator|-
literal|1
operator|)
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|state
operator|->
name|rate
operator|-
literal|1
operator|)
operator|%
literal|8
operator|)
expr_stmt|;
name|AbsorbQueue
argument_list|(
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KeccakReference
name|displayText
argument_list|(
literal|1
argument_list|,
literal|"--- Switching to squeezing phase ---"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ProvideFast1024
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1024
condition|)
block|{
name|KeccakExtract1024bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsAvailableForSqueezing
operator|=
literal|1024
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|KeccakExtract
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|64
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsAvailableForSqueezing
operator|=
name|state
operator|->
name|rate
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block available for squeezing"
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|,
name|state
operator|->
name|bitsAvailableForSqueezing
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|->
name|squeezing
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Squeeze
specifier|static
name|int
name|Squeeze
parameter_list|(
name|spongeState
modifier|*
name|state
parameter_list|,
name|unsigned
name|char
modifier|*
name|output
parameter_list|,
name|unsigned
name|long
name|long
name|outputLength
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|i
decl_stmt|;
name|unsigned
name|int
name|partialBlock
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|squeezing
condition|)
name|PadAndSwitchToSqueezingPhase
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outputLength
operator|%
literal|8
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|// Only multiple of 8 bits are allowed, truncation can be done at user level
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|outputLength
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|bitsAvailableForSqueezing
operator|==
literal|0
condition|)
block|{
name|KeccakPermutation
argument_list|(
name|state
operator|->
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ProvideFast1024
if|if
condition|(
name|state
operator|->
name|rate
operator|==
literal|1024
condition|)
block|{
name|KeccakExtract1024bits
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsAvailableForSqueezing
operator|=
literal|1024
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|KeccakExtract
argument_list|(
name|state
operator|->
name|state
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|,
name|state
operator|->
name|rate
operator|/
literal|64
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsAvailableForSqueezing
operator|=
name|state
operator|->
name|rate
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KeccakReference
name|displayBytes
argument_list|(
literal|1
argument_list|,
literal|"Block available for squeezing"
argument_list|,
name|state
operator|->
name|dataQueue
argument_list|,
name|state
operator|->
name|bitsAvailableForSqueezing
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|partialBlock
operator|=
name|state
operator|->
name|bitsAvailableForSqueezing
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
name|long
operator|)
name|partialBlock
operator|>
name|outputLength
operator|-
name|i
condition|)
name|partialBlock
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|outputLength
operator|-
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|output
operator|+
name|i
operator|/
literal|8
argument_list|,
name|state
operator|->
name|dataQueue
operator|+
operator|(
name|state
operator|->
name|rate
operator|-
name|state
operator|->
name|bitsAvailableForSqueezing
operator|)
operator|/
literal|8
argument_list|,
name|partialBlock
operator|/
literal|8
argument_list|)
expr_stmt|;
name|state
operator|->
name|bitsAvailableForSqueezing
operator|-=
name|partialBlock
expr_stmt|;
name|i
operator|+=
name|partialBlock
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
