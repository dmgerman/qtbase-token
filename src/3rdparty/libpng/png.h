begin_unit
begin_comment
comment|/* png.h - header file for PNG reference library  *  * libpng version 1.5.1 - February 3, 2011  * Copyright (c) 1998-2011 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license (See LICENSE, below)  *  * Authors and maintainers:  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat  *   libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger  *   libpng versions 0.97, January 1998, through 1.5.1 - February 3, 2011: Glenn  *   See also "Contributing Authors", below.  *  * Note about libpng version numbers:  *  *   Due to various miscommunications, unforeseen code incompatibilities  *   and occasional factors outside the authors' control, version numbering  *   on the library has not always been consistent and straightforward.  *   The following table summarizes matters since version 0.89c, which was  *   the first widely used release:  *  *    source                 png.h  png.h  shared-lib  *    version                string   int  version  *    -------                ------ -----  ----------  *    0.89c "1.0 beta 3"     0.89      89  1.0.89  *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]  *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]  *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]  *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]  *    0.97c                  0.97      97  2.0.97  *    0.98                   0.98      98  2.0.98  *    0.99                   0.99      98  2.0.99  *    0.99a-m                0.99      99  2.0.99  *    1.00                   1.00     100  2.1.0 [100 should be 10000]  *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]  *    1.0.1       png.h string is   10001  2.1.0  *    1.0.1a-e    identical to the  10002  from here on, the shared library  *    1.0.2       source version)   10002  is 2.V where V is the source code  *    1.0.2a-b                      10003  version, except as noted.  *    1.0.3                         10003  *    1.0.3a-d                      10004  *    1.0.4                         10004  *    1.0.4a-f                      10005  *    1.0.5 (+ 2 patches)           10005  *    1.0.5a-d                      10006  *    1.0.5e-r                      10100 (not source compatible)  *    1.0.5s-v                      10006 (not binary compatible)  *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)  *    1.0.6d-f                      10007 (still binary incompatible)  *    1.0.6g                        10007  *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)  *    1.0.6i                        10007  10.6i  *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)  *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)  *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)  *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)  *    1.0.7                    1    10007  (still compatible)  *    1.0.8beta1-4             1    10008  2.1.0.8beta1-4  *    1.0.8rc1                 1    10008  2.1.0.8rc1  *    1.0.8                    1    10008  2.1.0.8  *    1.0.9beta1-6             1    10009  2.1.0.9beta1-6  *    1.0.9rc1                 1    10009  2.1.0.9rc1  *    1.0.9beta7-10            1    10009  2.1.0.9beta7-10  *    1.0.9rc2                 1    10009  2.1.0.9rc2  *    1.0.9                    1    10009  2.1.0.9  *    1.0.10beta1              1    10010  2.1.0.10beta1  *    1.0.10rc1                1    10010  2.1.0.10rc1  *    1.0.10                   1    10010  2.1.0.10  *    1.0.11beta1-3            1    10011  2.1.0.11beta1-3  *    1.0.11rc1                1    10011  2.1.0.11rc1  *    1.0.11                   1    10011  2.1.0.11  *    1.0.12beta1-2            2    10012  2.1.0.12beta1-2  *    1.0.12rc1                2    10012  2.1.0.12rc1  *    1.0.12                   2    10012  2.1.0.12  *    1.1.0a-f                 -    10100  2.1.1.0a-f (branch abandoned)  *    1.2.0beta1-2             2    10200  2.1.2.0beta1-2  *    1.2.0beta3-5             3    10200  3.1.2.0beta3-5  *    1.2.0rc1                 3    10200  3.1.2.0rc1  *    1.2.0                    3    10200  3.1.2.0  *    1.2.1beta1-4             3    10201  3.1.2.1beta1-4  *    1.2.1rc1-2               3    10201  3.1.2.1rc1-2  *    1.2.1                    3    10201  3.1.2.1  *    1.2.2beta1-6            12    10202  12.so.0.1.2.2beta1-6  *    1.0.13beta1             10    10013  10.so.0.1.0.13beta1  *    1.0.13rc1               10    10013  10.so.0.1.0.13rc1  *    1.2.2rc1                12    10202  12.so.0.1.2.2rc1  *    1.0.13                  10    10013  10.so.0.1.0.13  *    1.2.2                   12    10202  12.so.0.1.2.2  *    1.2.3rc1-6              12    10203  12.so.0.1.2.3rc1-6  *    1.2.3                   12    10203  12.so.0.1.2.3  *    1.2.4beta1-3            13    10204  12.so.0.1.2.4beta1-3  *    1.0.14rc1               13    10014  10.so.0.1.0.14rc1  *    1.2.4rc1                13    10204  12.so.0.1.2.4rc1  *    1.0.14                  10    10014  10.so.0.1.0.14  *    1.2.4                   13    10204  12.so.0.1.2.4  *    1.2.5beta1-2            13    10205  12.so.0.1.2.5beta1-2  *    1.0.15rc1-3             10    10015  10.so.0.1.0.15rc1-3  *    1.2.5rc1-3              13    10205  12.so.0.1.2.5rc1-3  *    1.0.15                  10    10015  10.so.0.1.0.15  *    1.2.5                   13    10205  12.so.0.1.2.5  *    1.2.6beta1-4            13    10206  12.so.0.1.2.6beta1-4  *    1.0.16                  10    10016  10.so.0.1.0.16  *    1.2.6                   13    10206  12.so.0.1.2.6  *    1.2.7beta1-2            13    10207  12.so.0.1.2.7beta1-2  *    1.0.17rc1               10    10017  12.so.0.1.0.17rc1  *    1.2.7rc1                13    10207  12.so.0.1.2.7rc1  *    1.0.17                  10    10017  12.so.0.1.0.17  *    1.2.7                   13    10207  12.so.0.1.2.7  *    1.2.8beta1-5            13    10208  12.so.0.1.2.8beta1-5  *    1.0.18rc1-5             10    10018  12.so.0.1.0.18rc1-5  *    1.2.8rc1-5              13    10208  12.so.0.1.2.8rc1-5  *    1.0.18                  10    10018  12.so.0.1.0.18  *    1.2.8                   13    10208  12.so.0.1.2.8  *    1.2.9beta1-3            13    10209  12.so.0.1.2.9beta1-3  *    1.2.9beta4-11           13    10209  12.so.0.9[.0]  *    1.2.9rc1                13    10209  12.so.0.9[.0]  *    1.2.9                   13    10209  12.so.0.9[.0]  *    1.2.10beta1-7           13    10210  12.so.0.10[.0]  *    1.2.10rc1-2             13    10210  12.so.0.10[.0]  *    1.2.10                  13    10210  12.so.0.10[.0]  *    1.4.0beta1-5            14    10400  14.so.0.0[.0]  *    1.2.11beta1-4           13    10211  12.so.0.11[.0]  *    1.4.0beta7-8            14    10400  14.so.0.0[.0]  *    1.2.11                  13    10211  12.so.0.11[.0]  *    1.2.12                  13    10212  12.so.0.12[.0]  *    1.4.0beta9-14           14    10400  14.so.0.0[.0]  *    1.2.13                  13    10213  12.so.0.13[.0]  *    1.4.0beta15-36          14    10400  14.so.0.0[.0]  *    1.4.0beta37-87          14    10400  14.so.14.0[.0]  *    1.4.0rc01               14    10400  14.so.14.0[.0]  *    1.4.0beta88-109         14    10400  14.so.14.0[.0]  *    1.4.0rc02-08            14    10400  14.so.14.0[.0]  *    1.4.0                   14    10400  14.so.14.0[.0]  *    1.4.1beta01-03          14    10401  14.so.14.1[.0]  *    1.4.1rc01               14    10401  14.so.14.1[.0]  *    1.4.1beta04-12          14    10401  14.so.14.1[.0]  *    1.4.1                   14    10401  14.so.14.1[.0]  *    1.4.2                   14    10402  14.so.14.2[.0]  *    1.4.3                   14    10403  14.so.14.3[.0]  *    1.4.4                   14    10404  14.so.14.4[.0]  *    1.5.0beta01-58          15    10500  15.so.15.0[.0]  *    1.5.0rc01-07            15    10500  15.so.15.0[.0]  *    1.5.0                   15    10500  15.so.15.0[.0]  *    1.5.1beta01-11          15    10501  15.so.15.1[.0]  *    1.5.1rc01-02            15    10501  15.so.15.1[.0]  *    1.5.1                   15    10501  15.so.15.1[.0]  *  *   Henceforth the source version will match the shared-library major  *   and minor numbers; the shared-library major version number will be  *   used for changes in backward compatibility, as it is intended.  The  *   PNG_LIBPNG_VER macro, which is not used within libpng but is available  *   for applications, is an unsigned integer of the form xyyzz corresponding  *   to the source version x.y.z (leading zeros in y and z).  Beta versions  *   were given the previous public release number plus a letter, until  *   version 1.0.6j; from then on they were given the upcoming public  *   release number plus "betaNN" or "rcN".  *  *   Binary incompatibility exists only when applications make direct access  *   to the info_ptr or png_ptr members through png.h, and the compiled  *   application is loaded with a different version of the library.  *  *   DLLNUM will change each time there are forward or backward changes  *   in binary compatibility (e.g., when a new feature is added).  *  * See libpng-manual.txt or libpng.3 for more information.  The PNG  * specification is available as a W3C Recommendation and as an ISO  * Specification,<http://www.w3.org/TR/2003/REC-PNG-20031110/  */
end_comment
begin_comment
comment|/*  * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:  *  * If you modify libpng you may insert additional notices immediately following  * this sentence.  *  * This code is released under the libpng license.  *  * libpng versions 1.2.6, August 15, 2004, through 1.5.1, February 3, 2011, are  * Copyright (c) 2004, 2006-2011 Glenn Randers-Pehrson, and are  * distributed according to the same disclaimer and license as libpng-1.2.5  * with the following individual added to the list of Contributing Authors:  *  *    Cosmin Truta  *  * libpng versions 1.0.7, July 1, 2000, through 1.2.5, October 3, 2002, are  * Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are  * distributed according to the same disclaimer and license as libpng-1.0.6  * with the following individuals added to the list of Contributing Authors:  *  *    Simon-Pierre Cadieux  *    Eric S. Raymond  *    Gilles Vollant  *  * and with the following additions to the disclaimer:  *  *    There is no warranty against interference with your enjoyment of the  *    library or against infringement.  There is no warranty that our  *    efforts or the library will fulfill any of your particular purposes  *    or needs.  This library is provided with all faults, and the entire  *    risk of satisfactory quality, performance, accuracy, and effort is with  *    the user.  *  * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are  * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson, and are  * distributed according to the same disclaimer and license as libpng-0.96,   * with the following individuals added to the list of Contributing Authors:  *  *    Tom Lane  *    Glenn Randers-Pehrson  *    Willem van Schaik  *  * libpng versions 0.89, June 1996, through 0.96, May 1997, are  * Copyright (c) 1996, 1997 Andreas Dilger  * Distributed according to the same disclaimer and license as libpng-0.88,   * with the following individuals added to the list of Contributing Authors:  *  *    John Bowler  *    Kevin Bracey  *    Sam Bushell  *    Magnus Holmgren  *    Greg Roelofs  *    Tom Tanner  *  * libpng versions 0.5, May 1995, through 0.88, January 1996, are  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.  *  * For the purposes of this copyright and license, "Contributing Authors"  * is defined as the following set of individuals:  *  *    Andreas Dilger  *    Dave Martindale  *    Guy Eric Schalnat  *    Paul Schmidt  *    Tim Wegner  *  * The PNG Reference Library is supplied "AS IS".  The Contributing Authors  * and Group 42, Inc. disclaim all warranties, expressed or implied,   * including, without limitation, the warranties of merchantability and of  * fitness for any purpose.  The Contributing Authors and Group 42, Inc.  * assume no liability for direct, indirect, incidental, special, exemplary,   * or consequential damages, which may result from the use of the PNG  * Reference Library, even if advised of the possibility of such damage.  *  * Permission is hereby granted to use, copy, modify, and distribute this  * source code, or portions hereof, for any purpose, without fee, subject  * to the following restrictions:  *  *   1. The origin of this source code must not be misrepresented.  *  *   2. Altered versions must be plainly marked as such and must not  *      be misrepresented as being the original source.  *  *   3. This Copyright notice may not be removed or altered from  *      any source or altered source distribution.  *  * The Contributing Authors and Group 42, Inc. specifically permit, without  * fee, and encourage the use of this source code as a component to  * supporting the PNG file format in commercial products.  If you use this  * source code in a product, acknowledgment is not required but would be  * appreciated.  */
end_comment
begin_comment
comment|/*  * A "png_get_copyright" function is available, for convenient use in "about"  * boxes and the like:  *  *     printf("%s", png_get_copyright(NULL));  *  * Also, the PNG logo (in PNG format, of course) is supplied in the  * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).  */
end_comment
begin_comment
comment|/*  * Libpng is OSI Certified Open Source Software.  OSI Certified is a  * certification mark of the Open Source Initiative.  */
end_comment
begin_comment
comment|/*  * The contributing authors would like to thank all those who helped  * with testing, bug fixes, and patience.  This wouldn't have been  * possible without all of you.  *  * Thanks to Frank J. T. Wojcik for helping with the documentation.  */
end_comment
begin_comment
comment|/*  * Y2K compliance in libpng:  * =========================  *  *    February 3, 2011  *  *    Since the PNG Development group is an ad-hoc body, we can't make  *    an official declaration.  *  *    This is your unofficial assurance that libpng from version 0.71 and  *    upward through 1.5.1 are Y2K compliant.  It is my belief that  *    earlier versions were also Y2K compliant.  *  *    Libpng only has three year fields.  One is a 2-byte unsigned integer  *    that will hold years up to 65535.  The other two hold the date in text  *    format, and will hold years up to 9999.  *  *    The integer is  *        "png_uint_16 year" in png_time_struct.  *  *    The strings are  *        "png_charp time_buffer" in png_struct and  *        "near_time_buffer", which is a local character string in png.c.  *  *    There are seven time-related functions:  *        png.c: png_convert_to_rfc_1123() in png.c  *          (formerly png_convert_to_rfc_1152() in error)  *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c  *        png_convert_from_time_t() in pngwrite.c  *        png_get_tIME() in pngget.c  *        png_handle_tIME() in pngrutil.c, called in pngread.c  *        png_set_tIME() in pngset.c  *        png_write_tIME() in pngwutil.c, called in pngwrite.c  *  *    All handle dates properly in a Y2K environment.  The  *    png_convert_from_time_t() function calls gmtime() to convert from system  *    clock time, which returns (year - 1900), which we properly convert to  *    the full 4-digit year.  There is a possibility that applications using  *    libpng are not passing 4-digit years into the png_convert_to_rfc_1123()  *    function, or that they are incorrectly passing only a 2-digit year  *    instead of "year - 1900" into the png_convert_from_struct_tm() function,   *    but this is not under our control.  The libpng documentation has always  *    stated that it works with 4-digit years, and the APIs have been  *    documented as such.  *  *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned  *    integer to hold the year, and can hold years as large as 65535.  *  *    zlib, upon which libpng depends, is also Y2K compliant.  It contains  *    no date-related code.  *  *       Glenn Randers-Pehrson  *       libpng maintainer  *       PNG Development Group  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_H
end_ifndef
begin_define
DECL|macro|PNG_H
define|#
directive|define
name|PNG_H
end_define
begin_comment
comment|/* This is not the place to learn how to use libpng. The file libpng-manual.txt  * describes how to use libpng, and the file example.c summarizes it  * with some code on which to build.  This file is useful for looking  * at the actual function definitions and structure components.  */
end_comment
begin_comment
comment|/* Version information for png.h - this should match the version in png.c */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER_STRING
define|#
directive|define
name|PNG_LIBPNG_VER_STRING
value|"1.5.1"
end_define
begin_define
DECL|macro|PNG_HEADER_VERSION_STRING
define|#
directive|define
name|PNG_HEADER_VERSION_STRING
define|\
value|" libpng version 1.5.1 - February 3, 2011\n"
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_SONUM
define|#
directive|define
name|PNG_LIBPNG_VER_SONUM
value|15
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_DLLNUM
define|#
directive|define
name|PNG_LIBPNG_VER_DLLNUM
value|15
end_define
begin_comment
comment|/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER_MAJOR
define|#
directive|define
name|PNG_LIBPNG_VER_MAJOR
value|1
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_MINOR
define|#
directive|define
name|PNG_LIBPNG_VER_MINOR
value|5
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_RELEASE
define|#
directive|define
name|PNG_LIBPNG_VER_RELEASE
value|1
end_define
begin_comment
comment|/* This should match the numeric part of the final component of  * PNG_LIBPNG_VER_STRING, omitting any leading zero:  */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER_BUILD
define|#
directive|define
name|PNG_LIBPNG_VER_BUILD
value|0
end_define
begin_comment
comment|/* Release Status */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_ALPHA
define|#
directive|define
name|PNG_LIBPNG_BUILD_ALPHA
value|1
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_BETA
define|#
directive|define
name|PNG_LIBPNG_BUILD_BETA
value|2
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_RC
define|#
directive|define
name|PNG_LIBPNG_BUILD_RC
value|3
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_STABLE
define|#
directive|define
name|PNG_LIBPNG_BUILD_STABLE
value|4
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK
define|#
directive|define
name|PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK
value|7
end_define
begin_comment
comment|/* Release-Specific Flags */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_PATCH
define|#
directive|define
name|PNG_LIBPNG_BUILD_PATCH
value|8
end_define
begin_comment
DECL|macro|PNG_LIBPNG_BUILD_PATCH
comment|/* Can be OR'ed with                                        PNG_LIBPNG_BUILD_STABLE only */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_PRIVATE
define|#
directive|define
name|PNG_LIBPNG_BUILD_PRIVATE
value|16
end_define
begin_comment
DECL|macro|PNG_LIBPNG_BUILD_PRIVATE
comment|/* Cannot be OR'ed with                                        PNG_LIBPNG_BUILD_SPECIAL */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_SPECIAL
define|#
directive|define
name|PNG_LIBPNG_BUILD_SPECIAL
value|32
end_define
begin_comment
DECL|macro|PNG_LIBPNG_BUILD_SPECIAL
comment|/* Cannot be OR'ed with                                        PNG_LIBPNG_BUILD_PRIVATE */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_BASE_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_BASE_TYPE
value|PNG_LIBPNG_BUILD_BETA
end_define
begin_comment
comment|/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.  * We must not include leading zeros.  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only  * version 1.0.0 was mis-numbered 100 instead of 10000).  From  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release  */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER
define|#
directive|define
name|PNG_LIBPNG_VER
value|10501
end_define
begin_comment
DECL|macro|PNG_LIBPNG_VER
comment|/* 1.5.1 */
end_comment
begin_comment
comment|/* Library configuration: these options cannot be changed after  * the library has been built.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNGLCONF_H
end_ifndef
begin_comment
comment|/* If pnglibconf.h is missing, you can      * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h      */
end_comment
begin_include
include|#
directive|include
file|"pnglibconf.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_comment
comment|/* Standard header files (not needed for the version info) */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
end_ifdef
begin_include
include|#
directive|include
file|<setjmp.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Need the time information for converting tIME chunks, it  * defines struct tm:  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CONVERT_tIME_SUPPORTED
end_ifdef
begin_comment
comment|/* "time.h" functions are not supported on all operating systems */
end_comment
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Machine specific configuration. */
end_comment
begin_include
include|#
directive|include
file|"pngconf.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Added at libpng-1.2.8  *  * Ref MSDN: Private as priority over Special  * VS_FF_PRIVATEBUILD File *was not* built using standard release  * procedures. If this value is given, the StringFileInfo block must  * contain a PrivateBuild string.  *  * VS_FF_SPECIALBUILD File *was* built by the original company using  * standard release procedures but is a variation of the standard  * file of the same version number. If this value is given, the  * StringFileInfo block must contain a SpecialBuild string.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_USER_PRIVATEBUILD
end_ifdef
begin_comment
comment|/* From pnglibconf.h */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_TYPE
define|\
value|(PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_PRIVATE)
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_LIBPNG_SPECIALBUILD
end_ifdef
begin_define
DECL|macro|PNG_LIBPNG_BUILD_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_TYPE
define|\
value|(PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_SPECIAL)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PNG_LIBPNG_BUILD_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_TYPE
value|(PNG_LIBPNG_BUILD_BASE_TYPE)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_comment
comment|/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* Version information for C files, stored in png.c.  This had better match  * the version above.  */
DECL|macro|png_libpng_ver
define|#
directive|define
name|png_libpng_ver
value|png_get_header_ver(NULL)
comment|/* This file is arranged in several sections:  *  * 1. Any configuration options that can be specified by for the application  *    code when it is built.  (Build time configuration is in pnglibconf.h)  * 2. Type definitions (base types are defined in pngconf.h), structure  *    definitions.  * 3. Exported library functions.  *  * The library source code has additional files (principally pngpriv.h) that  * allow configuration of the library.  */
comment|/* Section 1: run time configuration  * See pnglibconf.h for build time configuration  *  * Run time configuration allows the application to choose between  * implementations of certain arithmetic APIs.  The default is set  * at build time and recorded in pnglibconf.h, but it is safe to  * override these (and only these) settings.  Note that this won't  * change what the library does, only application code, and the  * settings can (and probably should) be made on a per-file basis  * by setting the #defines before including png.h  *  * Use macros to read integers from PNG data or use the exported  * functions?  *   PNG_USE_READ_MACROS: use the macros (see below)  Note that  *     the macros evaluate their argument multiple times.  *   PNG_NO_USE_READ_MACROS: call the relevant library function.  *  * Use the alternative algorithm for compositing alpha samples that  * does not use division?  *   PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'  *      algorithm.  *   PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.  *  * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is  * false?  *   PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error  *      APIs to png_warning.  * Otherwise the calls are mapped to png_error.  */
comment|/* Section 2: type definitions, including structures and compile time  * constants.  * See pngconf.h for base types that vary by machine/system  */
comment|/* This triggers a compiler error in png.c, if png.c and png.h  * do not agree upon the version number.  */
DECL|typedef|png_libpng_version_1_5_1
typedef|typedef
name|char
modifier|*
name|png_libpng_version_1_5_1
typedef|;
comment|/* Three color definitions.  The order of the red, green, and blue, (and the  * exact size) is not important, although the size of the fields need to  * be png_byte or png_uint_16 (as defined below).  */
DECL|struct|png_color_struct
typedef|typedef
struct|struct
name|png_color_struct
block|{
DECL|member|red
name|png_byte
name|red
decl_stmt|;
DECL|member|green
name|png_byte
name|green
decl_stmt|;
DECL|member|blue
name|png_byte
name|blue
decl_stmt|;
block|}
DECL|typedef|png_color
name|png_color
typedef|;
DECL|typedef|png_colorp
typedef|typedef
name|png_color
name|FAR
modifier|*
name|png_colorp
typedef|;
DECL|typedef|png_const_colorp
typedef|typedef
name|PNG_CONST
name|png_color
name|FAR
modifier|*
name|png_const_colorp
typedef|;
DECL|typedef|png_colorpp
typedef|typedef
name|png_color
name|FAR
modifier|*
name|FAR
modifier|*
name|png_colorpp
typedef|;
DECL|struct|png_color_16_struct
typedef|typedef
struct|struct
name|png_color_16_struct
block|{
DECL|member|index
name|png_byte
name|index
decl_stmt|;
comment|/* used for palette files */
DECL|member|red
name|png_uint_16
name|red
decl_stmt|;
comment|/* for use in red green blue files */
DECL|member|green
name|png_uint_16
name|green
decl_stmt|;
DECL|member|blue
name|png_uint_16
name|blue
decl_stmt|;
DECL|member|gray
name|png_uint_16
name|gray
decl_stmt|;
comment|/* for use in grayscale files */
block|}
DECL|typedef|png_color_16
name|png_color_16
typedef|;
DECL|typedef|png_color_16p
typedef|typedef
name|png_color_16
name|FAR
modifier|*
name|png_color_16p
typedef|;
DECL|typedef|png_const_color_16p
typedef|typedef
name|PNG_CONST
name|png_color_16
name|FAR
modifier|*
name|png_const_color_16p
typedef|;
DECL|typedef|png_color_16pp
typedef|typedef
name|png_color_16
name|FAR
modifier|*
name|FAR
modifier|*
name|png_color_16pp
typedef|;
DECL|struct|png_color_8_struct
typedef|typedef
struct|struct
name|png_color_8_struct
block|{
DECL|member|red
name|png_byte
name|red
decl_stmt|;
comment|/* for use in red green blue files */
DECL|member|green
name|png_byte
name|green
decl_stmt|;
DECL|member|blue
name|png_byte
name|blue
decl_stmt|;
DECL|member|gray
name|png_byte
name|gray
decl_stmt|;
comment|/* for use in grayscale files */
DECL|member|alpha
name|png_byte
name|alpha
decl_stmt|;
comment|/* for alpha channel files */
block|}
DECL|typedef|png_color_8
name|png_color_8
typedef|;
DECL|typedef|png_color_8p
typedef|typedef
name|png_color_8
name|FAR
modifier|*
name|png_color_8p
typedef|;
DECL|typedef|png_const_color_8p
typedef|typedef
name|PNG_CONST
name|png_color_8
name|FAR
modifier|*
name|png_const_color_8p
typedef|;
DECL|typedef|png_color_8pp
typedef|typedef
name|png_color_8
name|FAR
modifier|*
name|FAR
modifier|*
name|png_color_8pp
typedef|;
comment|/*  * The following two structures are used for the in-core representation  * of sPLT chunks.  */
DECL|struct|png_sPLT_entry_struct
typedef|typedef
struct|struct
name|png_sPLT_entry_struct
block|{
DECL|member|red
name|png_uint_16
name|red
decl_stmt|;
DECL|member|green
name|png_uint_16
name|green
decl_stmt|;
DECL|member|blue
name|png_uint_16
name|blue
decl_stmt|;
DECL|member|alpha
name|png_uint_16
name|alpha
decl_stmt|;
DECL|member|frequency
name|png_uint_16
name|frequency
decl_stmt|;
block|}
DECL|typedef|png_sPLT_entry
name|png_sPLT_entry
typedef|;
DECL|typedef|png_sPLT_entryp
typedef|typedef
name|png_sPLT_entry
name|FAR
modifier|*
name|png_sPLT_entryp
typedef|;
DECL|typedef|png_const_sPLT_entryp
typedef|typedef
name|PNG_CONST
name|png_sPLT_entry
name|FAR
modifier|*
name|png_const_sPLT_entryp
typedef|;
DECL|typedef|png_sPLT_entrypp
typedef|typedef
name|png_sPLT_entry
name|FAR
modifier|*
name|FAR
modifier|*
name|png_sPLT_entrypp
typedef|;
comment|/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples  *  occupy the LSB of their respective members, and the MSB of each member  *  is zero-filled.  The frequency member always occupies the full 16 bits.  */
DECL|struct|png_sPLT_struct
typedef|typedef
struct|struct
name|png_sPLT_struct
block|{
DECL|member|name
name|png_charp
name|name
decl_stmt|;
comment|/* palette name */
DECL|member|depth
name|png_byte
name|depth
decl_stmt|;
comment|/* depth of palette samples */
DECL|member|entries
name|png_sPLT_entryp
name|entries
decl_stmt|;
comment|/* palette entries */
DECL|member|nentries
name|png_int_32
name|nentries
decl_stmt|;
comment|/* number of palette entries */
block|}
DECL|typedef|png_sPLT_t
name|png_sPLT_t
typedef|;
DECL|typedef|png_sPLT_tp
typedef|typedef
name|png_sPLT_t
name|FAR
modifier|*
name|png_sPLT_tp
typedef|;
DECL|typedef|png_const_sPLT_tp
typedef|typedef
name|PNG_CONST
name|png_sPLT_t
name|FAR
modifier|*
name|png_const_sPLT_tp
typedef|;
DECL|typedef|png_sPLT_tpp
typedef|typedef
name|png_sPLT_t
name|FAR
modifier|*
name|FAR
modifier|*
name|png_sPLT_tpp
typedef|;
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,   * and whether that contents is compressed or not.  The "key" field  * points to a regular zero-terminated C string.  The "text", "lang", and  * "lang_key" fields can be regular C strings, empty strings, or NULL pointers.  * However, the * structure returned by png_get_text() will always contain  * regular zero-terminated C strings (possibly empty), never NULL pointers,   * so they can be safely used in printf() and other string-handling functions.  */
DECL|struct|png_text_struct
typedef|typedef
struct|struct
name|png_text_struct
block|{
DECL|member|compression
name|int
name|compression
decl_stmt|;
comment|/* compression value:                              -1: tEXt, none                               0: zTXt, deflate                               1: iTXt, none                               2: iTXt, deflate  */
DECL|member|key
name|png_charp
name|key
decl_stmt|;
comment|/* keyword, 1-79 character description of "text" */
DECL|member|text
name|png_charp
name|text
decl_stmt|;
comment|/* comment, may be an empty string (ie "")                               or a NULL pointer */
DECL|member|text_length
name|png_size_t
name|text_length
decl_stmt|;
comment|/* length of the text string */
DECL|member|itxt_length
name|png_size_t
name|itxt_length
decl_stmt|;
comment|/* length of the itxt string */
DECL|member|lang
name|png_charp
name|lang
decl_stmt|;
comment|/* language code, 0-79 characters                               or a NULL pointer */
DECL|member|lang_key
name|png_charp
name|lang_key
decl_stmt|;
comment|/* keyword translated UTF-8 string, 0 or more                               chars or a NULL pointer */
block|}
DECL|typedef|png_text
name|png_text
typedef|;
DECL|typedef|png_textp
typedef|typedef
name|png_text
name|FAR
modifier|*
name|png_textp
typedef|;
DECL|typedef|png_const_textp
typedef|typedef
name|PNG_CONST
name|png_text
name|FAR
modifier|*
name|png_const_textp
typedef|;
DECL|typedef|png_textpp
typedef|typedef
name|png_text
name|FAR
modifier|*
name|FAR
modifier|*
name|png_textpp
typedef|;
endif|#
directive|endif
comment|/* Supported compression types for text in PNG files (tEXt, and zTXt).  * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
DECL|macro|PNG_TEXT_COMPRESSION_NONE_WR
define|#
directive|define
name|PNG_TEXT_COMPRESSION_NONE_WR
value|-3
DECL|macro|PNG_TEXT_COMPRESSION_zTXt_WR
define|#
directive|define
name|PNG_TEXT_COMPRESSION_zTXt_WR
value|-2
DECL|macro|PNG_TEXT_COMPRESSION_NONE
define|#
directive|define
name|PNG_TEXT_COMPRESSION_NONE
value|-1
DECL|macro|PNG_TEXT_COMPRESSION_zTXt
define|#
directive|define
name|PNG_TEXT_COMPRESSION_zTXt
value|0
DECL|macro|PNG_ITXT_COMPRESSION_NONE
define|#
directive|define
name|PNG_ITXT_COMPRESSION_NONE
value|1
DECL|macro|PNG_ITXT_COMPRESSION_zTXt
define|#
directive|define
name|PNG_ITXT_COMPRESSION_zTXt
value|2
DECL|macro|PNG_TEXT_COMPRESSION_LAST
define|#
directive|define
name|PNG_TEXT_COMPRESSION_LAST
value|3
comment|/* Not a valid value */
comment|/* png_time is a way to hold the time in an machine independent way.  * Two conversions are provided, both from time_t and struct tm.  There  * is no portable way to convert to either of these structures, as far  * as I know.  If you know of a portable way, send it to me.  As a side  * note - PNG has always been Year 2000 compliant!  */
DECL|struct|png_time_struct
typedef|typedef
struct|struct
name|png_time_struct
block|{
DECL|member|year
name|png_uint_16
name|year
decl_stmt|;
comment|/* full year, as in, 1995 */
DECL|member|month
name|png_byte
name|month
decl_stmt|;
comment|/* month of year, 1 - 12 */
DECL|member|day
name|png_byte
name|day
decl_stmt|;
comment|/* day of month, 1 - 31 */
DECL|member|hour
name|png_byte
name|hour
decl_stmt|;
comment|/* hour of day, 0 - 23 */
DECL|member|minute
name|png_byte
name|minute
decl_stmt|;
comment|/* minute of hour, 0 - 59 */
DECL|member|second
name|png_byte
name|second
decl_stmt|;
comment|/* second of minute, 0 - 60 (for leap seconds) */
block|}
DECL|typedef|png_time
name|png_time
typedef|;
DECL|typedef|png_timep
typedef|typedef
name|png_time
name|FAR
modifier|*
name|png_timep
typedef|;
DECL|typedef|png_const_timep
typedef|typedef
name|PNG_CONST
name|png_time
name|FAR
modifier|*
name|png_const_timep
typedef|;
DECL|typedef|png_timepp
typedef|typedef
name|png_time
name|FAR
modifier|*
name|FAR
modifier|*
name|png_timepp
typedef|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
argument_list|)
comment|/* png_unknown_chunk is a structure to hold queued chunks for which there is  * no specific support.  The idea is that we can use this to queue  * up private chunks for output even though the library doesn't actually  * know about their semantics.  */
DECL|struct|png_unknown_chunk_t
typedef|typedef
struct|struct
name|png_unknown_chunk_t
block|{
DECL|member|name
name|png_byte
name|name
index|[
literal|5
index|]
decl_stmt|;
DECL|member|data
name|png_byte
modifier|*
name|data
decl_stmt|;
DECL|member|size
name|png_size_t
name|size
decl_stmt|;
comment|/* libpng-using applications should NOT directly modify this byte. */
DECL|member|location
name|png_byte
name|location
decl_stmt|;
comment|/* mode of operation at read time */
block|}
DECL|typedef|png_unknown_chunk
name|png_unknown_chunk
typedef|;
DECL|typedef|png_unknown_chunkp
typedef|typedef
name|png_unknown_chunk
name|FAR
modifier|*
name|png_unknown_chunkp
typedef|;
DECL|typedef|png_const_unknown_chunkp
typedef|typedef
name|PNG_CONST
name|png_unknown_chunk
name|FAR
modifier|*
name|png_const_unknown_chunkp
typedef|;
DECL|typedef|png_unknown_chunkpp
typedef|typedef
name|png_unknown_chunk
name|FAR
modifier|*
name|FAR
modifier|*
name|png_unknown_chunkpp
typedef|;
endif|#
directive|endif
DECL|typedef|png_info
typedef|typedef
name|struct
name|png_info_def
name|png_info
typedef|;
DECL|typedef|png_infop
typedef|typedef
name|png_info
name|FAR
modifier|*
name|png_infop
typedef|;
DECL|typedef|png_const_infop
typedef|typedef
name|PNG_CONST
name|png_info
name|FAR
modifier|*
name|png_const_infop
typedef|;
DECL|typedef|png_infopp
typedef|typedef
name|png_info
name|FAR
modifier|*
name|FAR
modifier|*
name|png_infopp
typedef|;
comment|/* Maximum positive integer used in PNG is (2^31)-1 */
DECL|macro|PNG_UINT_31_MAX
define|#
directive|define
name|PNG_UINT_31_MAX
value|((png_uint_32)0x7fffffffL)
DECL|macro|PNG_UINT_32_MAX
define|#
directive|define
name|PNG_UINT_32_MAX
value|((png_uint_32)(-1))
DECL|macro|PNG_SIZE_MAX
define|#
directive|define
name|PNG_SIZE_MAX
value|((png_size_t)(-1))
comment|/* These are constants for fixed point values encoded in the  * PNG specification manner (x100000)  */
DECL|macro|PNG_FP_1
define|#
directive|define
name|PNG_FP_1
value|100000
DECL|macro|PNG_FP_HALF
define|#
directive|define
name|PNG_FP_HALF
value|50000
comment|/* These describe the color_type field in png_info. */
comment|/* color type masks */
DECL|macro|PNG_COLOR_MASK_PALETTE
define|#
directive|define
name|PNG_COLOR_MASK_PALETTE
value|1
DECL|macro|PNG_COLOR_MASK_COLOR
define|#
directive|define
name|PNG_COLOR_MASK_COLOR
value|2
DECL|macro|PNG_COLOR_MASK_ALPHA
define|#
directive|define
name|PNG_COLOR_MASK_ALPHA
value|4
comment|/* color types.  Note that not all combinations are legal */
DECL|macro|PNG_COLOR_TYPE_GRAY
define|#
directive|define
name|PNG_COLOR_TYPE_GRAY
value|0
DECL|macro|PNG_COLOR_TYPE_PALETTE
define|#
directive|define
name|PNG_COLOR_TYPE_PALETTE
value|(PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
DECL|macro|PNG_COLOR_TYPE_RGB
define|#
directive|define
name|PNG_COLOR_TYPE_RGB
value|(PNG_COLOR_MASK_COLOR)
DECL|macro|PNG_COLOR_TYPE_RGB_ALPHA
define|#
directive|define
name|PNG_COLOR_TYPE_RGB_ALPHA
value|(PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
DECL|macro|PNG_COLOR_TYPE_GRAY_ALPHA
define|#
directive|define
name|PNG_COLOR_TYPE_GRAY_ALPHA
value|(PNG_COLOR_MASK_ALPHA)
comment|/* aliases */
DECL|macro|PNG_COLOR_TYPE_RGBA
define|#
directive|define
name|PNG_COLOR_TYPE_RGBA
value|PNG_COLOR_TYPE_RGB_ALPHA
DECL|macro|PNG_COLOR_TYPE_GA
define|#
directive|define
name|PNG_COLOR_TYPE_GA
value|PNG_COLOR_TYPE_GRAY_ALPHA
comment|/* This is for compression type. PNG 1.0-1.2 only define the single type. */
DECL|macro|PNG_COMPRESSION_TYPE_BASE
define|#
directive|define
name|PNG_COMPRESSION_TYPE_BASE
value|0
comment|/* Deflate method 8, 32K window */
DECL|macro|PNG_COMPRESSION_TYPE_DEFAULT
define|#
directive|define
name|PNG_COMPRESSION_TYPE_DEFAULT
value|PNG_COMPRESSION_TYPE_BASE
comment|/* This is for filter type. PNG 1.0-1.2 only define the single type. */
DECL|macro|PNG_FILTER_TYPE_BASE
define|#
directive|define
name|PNG_FILTER_TYPE_BASE
value|0
comment|/* Single row per-byte filtering */
DECL|macro|PNG_INTRAPIXEL_DIFFERENCING
define|#
directive|define
name|PNG_INTRAPIXEL_DIFFERENCING
value|64
comment|/* Used only in MNG datastreams */
DECL|macro|PNG_FILTER_TYPE_DEFAULT
define|#
directive|define
name|PNG_FILTER_TYPE_DEFAULT
value|PNG_FILTER_TYPE_BASE
comment|/* These are for the interlacing type.  These values should NOT be changed. */
DECL|macro|PNG_INTERLACE_NONE
define|#
directive|define
name|PNG_INTERLACE_NONE
value|0
comment|/* Non-interlaced image */
DECL|macro|PNG_INTERLACE_ADAM7
define|#
directive|define
name|PNG_INTERLACE_ADAM7
value|1
comment|/* Adam7 interlacing */
DECL|macro|PNG_INTERLACE_LAST
define|#
directive|define
name|PNG_INTERLACE_LAST
value|2
comment|/* Not a valid value */
comment|/* These are for the oFFs chunk.  These values should NOT be changed. */
DECL|macro|PNG_OFFSET_PIXEL
define|#
directive|define
name|PNG_OFFSET_PIXEL
value|0
comment|/* Offset in pixels */
DECL|macro|PNG_OFFSET_MICROMETER
define|#
directive|define
name|PNG_OFFSET_MICROMETER
value|1
comment|/* Offset in micrometers (1/10^6 meter) */
DECL|macro|PNG_OFFSET_LAST
define|#
directive|define
name|PNG_OFFSET_LAST
value|2
comment|/* Not a valid value */
comment|/* These are for the pCAL chunk.  These values should NOT be changed. */
DECL|macro|PNG_EQUATION_LINEAR
define|#
directive|define
name|PNG_EQUATION_LINEAR
value|0
comment|/* Linear transformation */
DECL|macro|PNG_EQUATION_BASE_E
define|#
directive|define
name|PNG_EQUATION_BASE_E
value|1
comment|/* Exponential base e transform */
DECL|macro|PNG_EQUATION_ARBITRARY
define|#
directive|define
name|PNG_EQUATION_ARBITRARY
value|2
comment|/* Arbitrary base exponential transform */
DECL|macro|PNG_EQUATION_HYPERBOLIC
define|#
directive|define
name|PNG_EQUATION_HYPERBOLIC
value|3
comment|/* Hyperbolic sine transformation */
DECL|macro|PNG_EQUATION_LAST
define|#
directive|define
name|PNG_EQUATION_LAST
value|4
comment|/* Not a valid value */
comment|/* These are for the sCAL chunk.  These values should NOT be changed. */
DECL|macro|PNG_SCALE_UNKNOWN
define|#
directive|define
name|PNG_SCALE_UNKNOWN
value|0
comment|/* unknown unit (image scale) */
DECL|macro|PNG_SCALE_METER
define|#
directive|define
name|PNG_SCALE_METER
value|1
comment|/* meters per pixel */
DECL|macro|PNG_SCALE_RADIAN
define|#
directive|define
name|PNG_SCALE_RADIAN
value|2
comment|/* radians per pixel */
DECL|macro|PNG_SCALE_LAST
define|#
directive|define
name|PNG_SCALE_LAST
value|3
comment|/* Not a valid value */
comment|/* These are for the pHYs chunk.  These values should NOT be changed. */
DECL|macro|PNG_RESOLUTION_UNKNOWN
define|#
directive|define
name|PNG_RESOLUTION_UNKNOWN
value|0
comment|/* pixels/unknown unit (aspect ratio) */
DECL|macro|PNG_RESOLUTION_METER
define|#
directive|define
name|PNG_RESOLUTION_METER
value|1
comment|/* pixels/meter */
DECL|macro|PNG_RESOLUTION_LAST
define|#
directive|define
name|PNG_RESOLUTION_LAST
value|2
comment|/* Not a valid value */
comment|/* These are for the sRGB chunk.  These values should NOT be changed. */
DECL|macro|PNG_sRGB_INTENT_PERCEPTUAL
define|#
directive|define
name|PNG_sRGB_INTENT_PERCEPTUAL
value|0
DECL|macro|PNG_sRGB_INTENT_RELATIVE
define|#
directive|define
name|PNG_sRGB_INTENT_RELATIVE
value|1
DECL|macro|PNG_sRGB_INTENT_SATURATION
define|#
directive|define
name|PNG_sRGB_INTENT_SATURATION
value|2
DECL|macro|PNG_sRGB_INTENT_ABSOLUTE
define|#
directive|define
name|PNG_sRGB_INTENT_ABSOLUTE
value|3
DECL|macro|PNG_sRGB_INTENT_LAST
define|#
directive|define
name|PNG_sRGB_INTENT_LAST
value|4
comment|/* Not a valid value */
comment|/* This is for text chunks */
DECL|macro|PNG_KEYWORD_MAX_LENGTH
define|#
directive|define
name|PNG_KEYWORD_MAX_LENGTH
value|79
comment|/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
DECL|macro|PNG_MAX_PALETTE_LENGTH
define|#
directive|define
name|PNG_MAX_PALETTE_LENGTH
value|256
comment|/* These determine if an ancillary chunk's data has been successfully read  * from the PNG header, or if the application has filled in the corresponding  * data in the info_struct to be written into the output file.  The values  * of the PNG_INFO_<chunk> defines should NOT be changed.  */
DECL|macro|PNG_INFO_gAMA
define|#
directive|define
name|PNG_INFO_gAMA
value|0x0001
DECL|macro|PNG_INFO_sBIT
define|#
directive|define
name|PNG_INFO_sBIT
value|0x0002
DECL|macro|PNG_INFO_cHRM
define|#
directive|define
name|PNG_INFO_cHRM
value|0x0004
DECL|macro|PNG_INFO_PLTE
define|#
directive|define
name|PNG_INFO_PLTE
value|0x0008
DECL|macro|PNG_INFO_tRNS
define|#
directive|define
name|PNG_INFO_tRNS
value|0x0010
DECL|macro|PNG_INFO_bKGD
define|#
directive|define
name|PNG_INFO_bKGD
value|0x0020
DECL|macro|PNG_INFO_hIST
define|#
directive|define
name|PNG_INFO_hIST
value|0x0040
DECL|macro|PNG_INFO_pHYs
define|#
directive|define
name|PNG_INFO_pHYs
value|0x0080
DECL|macro|PNG_INFO_oFFs
define|#
directive|define
name|PNG_INFO_oFFs
value|0x0100
DECL|macro|PNG_INFO_tIME
define|#
directive|define
name|PNG_INFO_tIME
value|0x0200
DECL|macro|PNG_INFO_pCAL
define|#
directive|define
name|PNG_INFO_pCAL
value|0x0400
DECL|macro|PNG_INFO_sRGB
define|#
directive|define
name|PNG_INFO_sRGB
value|0x0800
comment|/* GR-P, 0.96a */
DECL|macro|PNG_INFO_iCCP
define|#
directive|define
name|PNG_INFO_iCCP
value|0x1000
comment|/* ESR, 1.0.6 */
DECL|macro|PNG_INFO_sPLT
define|#
directive|define
name|PNG_INFO_sPLT
value|0x2000
comment|/* ESR, 1.0.6 */
DECL|macro|PNG_INFO_sCAL
define|#
directive|define
name|PNG_INFO_sCAL
value|0x4000
comment|/* ESR, 1.0.6 */
DECL|macro|PNG_INFO_IDAT
define|#
directive|define
name|PNG_INFO_IDAT
value|0x8000L
comment|/* ESR, 1.0.6 */
comment|/* This is used for the transformation routines, as some of them  * change these values for the row.  It also should enable using  * the routines for other purposes.  */
DECL|struct|png_row_info_struct
typedef|typedef
struct|struct
name|png_row_info_struct
block|{
DECL|member|width
name|png_uint_32
name|width
decl_stmt|;
comment|/* width of row */
DECL|member|rowbytes
name|png_size_t
name|rowbytes
decl_stmt|;
comment|/* number of bytes in row */
DECL|member|color_type
name|png_byte
name|color_type
decl_stmt|;
comment|/* color type of row */
DECL|member|bit_depth
name|png_byte
name|bit_depth
decl_stmt|;
comment|/* bit depth of row */
DECL|member|channels
name|png_byte
name|channels
decl_stmt|;
comment|/* number of channels (1, 2, 3, or 4) */
DECL|member|pixel_depth
name|png_byte
name|pixel_depth
decl_stmt|;
comment|/* bits per pixel (depth * channels) */
block|}
DECL|typedef|png_row_info
name|png_row_info
typedef|;
DECL|typedef|png_row_infop
typedef|typedef
name|png_row_info
name|FAR
modifier|*
name|png_row_infop
typedef|;
DECL|typedef|png_row_infopp
typedef|typedef
name|png_row_info
name|FAR
modifier|*
name|FAR
modifier|*
name|png_row_infopp
typedef|;
comment|/* These are the function types for the I/O functions and for the functions  * that allow the user to override the default I/O functions with his or her  * own.  The png_error_ptr type should match that of user-supplied warning  * and error functions, while the png_rw_ptr type should match that of the  * user read/write data functions.  Note that the 'write' function must not  * modify the buffer it is passed. The 'read' function, on the other hand, is  * expected to return the read data in the buffer.  */
DECL|typedef|png_struct
typedef|typedef
name|struct
name|png_struct_def
name|png_struct
typedef|;
DECL|typedef|png_const_structp
typedef|typedef
name|PNG_CONST
name|png_struct
name|FAR
modifier|*
name|png_const_structp
typedef|;
DECL|typedef|png_structp
typedef|typedef
name|png_struct
name|FAR
modifier|*
name|png_structp
typedef|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_error_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_const_charp
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_rw_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_bytep
operator|,
name|png_size_t
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_flush_ptr
argument_list|,
operator|(
name|png_structp
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_read_status_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_uint_32
operator|,
name|int
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_write_status_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_uint_32
operator|,
name|int
operator|)
argument_list|, )
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_progressive_info_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_infop
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_progressive_end_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_infop
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_progressive_row_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_bytep
operator|,
name|png_uint_32
operator|,
name|int
operator|)
argument_list|, )
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_USER_TRANSFORM_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
argument_list|)
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_user_transform_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_row_infop
operator|,
name|png_bytep
operator|)
argument_list|, )
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_CHUNKS_SUPPORTED
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|int
argument_list|,
operator|*
name|png_user_chunk_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_unknown_chunkp
operator|)
argument_list|, )
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_unknown_chunk_ptr
argument_list|,
operator|(
name|png_structp
operator|)
argument_list|, )
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* This must match the function definition in<setjmp.h>, and the  * application must include this before png.h to obtain the definition  * of jmp_buf.  The function is required to be PNG_NORETURN.  (Note that  * PNG_PTR_NORETURN is used here because current versions of the Microsoft  * C compiler do not support the PNG_NORETURN attribute on a pointer.)  *  * If you get a type warning from the compiler when linking against this line  * then your compiler has 'longjmp' that does not match the requirements of the  * compiler that built libpng.  You will have to write a wrapper function for  * your compiler's longjmp and call png_set_longjmp_fn directly (not via the  * png_jmpbuf macro.)  *  * If you get a warning here while building the library you will need to make  * changes to ensure that pnglibconf.h records the calling convention used by  * your compiler.  This may be very difficult - try using a different compiler  * to build the library!  */
DECL|typedef|PNG_FUNCTION
typedef|typedef
name|PNG_FUNCTION
argument_list|(
name|void
argument_list|,
operator|(
name|PNGCAPI
operator|*
name|png_longjmp_ptr
operator|)
argument_list|,
name|PNGARG
argument_list|(
operator|(
name|jmp_buf
operator|,
name|int
operator|)
argument_list|)
argument_list|,
name|PNG_PTR_NORETURN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Transform masks for the high-level interface */
DECL|macro|PNG_TRANSFORM_IDENTITY
define|#
directive|define
name|PNG_TRANSFORM_IDENTITY
value|0x0000
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_STRIP_16
define|#
directive|define
name|PNG_TRANSFORM_STRIP_16
value|0x0001
comment|/* read only */
DECL|macro|PNG_TRANSFORM_STRIP_ALPHA
define|#
directive|define
name|PNG_TRANSFORM_STRIP_ALPHA
value|0x0002
comment|/* read only */
DECL|macro|PNG_TRANSFORM_PACKING
define|#
directive|define
name|PNG_TRANSFORM_PACKING
value|0x0004
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_PACKSWAP
define|#
directive|define
name|PNG_TRANSFORM_PACKSWAP
value|0x0008
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_EXPAND
define|#
directive|define
name|PNG_TRANSFORM_EXPAND
value|0x0010
comment|/* read only */
DECL|macro|PNG_TRANSFORM_INVERT_MONO
define|#
directive|define
name|PNG_TRANSFORM_INVERT_MONO
value|0x0020
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_SHIFT
define|#
directive|define
name|PNG_TRANSFORM_SHIFT
value|0x0040
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_BGR
define|#
directive|define
name|PNG_TRANSFORM_BGR
value|0x0080
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_SWAP_ALPHA
define|#
directive|define
name|PNG_TRANSFORM_SWAP_ALPHA
value|0x0100
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_SWAP_ENDIAN
define|#
directive|define
name|PNG_TRANSFORM_SWAP_ENDIAN
value|0x0200
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_INVERT_ALPHA
define|#
directive|define
name|PNG_TRANSFORM_INVERT_ALPHA
value|0x0400
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_STRIP_FILLER
define|#
directive|define
name|PNG_TRANSFORM_STRIP_FILLER
value|0x0800
comment|/* write only */
comment|/* Added to libpng-1.2.34 */
DECL|macro|PNG_TRANSFORM_STRIP_FILLER_BEFORE
define|#
directive|define
name|PNG_TRANSFORM_STRIP_FILLER_BEFORE
value|PNG_TRANSFORM_STRIP_FILLER
DECL|macro|PNG_TRANSFORM_STRIP_FILLER_AFTER
define|#
directive|define
name|PNG_TRANSFORM_STRIP_FILLER_AFTER
value|0x1000
comment|/* write only */
comment|/* Added to libpng-1.4.0 */
DECL|macro|PNG_TRANSFORM_GRAY_TO_RGB
define|#
directive|define
name|PNG_TRANSFORM_GRAY_TO_RGB
value|0x2000
comment|/* read only */
comment|/* Flags for MNG supported features */
DECL|macro|PNG_FLAG_MNG_EMPTY_PLTE
define|#
directive|define
name|PNG_FLAG_MNG_EMPTY_PLTE
value|0x01
DECL|macro|PNG_FLAG_MNG_FILTER_64
define|#
directive|define
name|PNG_FLAG_MNG_FILTER_64
value|0x04
DECL|macro|PNG_ALL_MNG_FEATURES
define|#
directive|define
name|PNG_ALL_MNG_FEATURES
value|0x05
comment|/* NOTE: prior to 1.5 these functions had no 'API' style declaration,   * this allowed the zlib default functions to be used on Windows  * platforms.  In 1.5 the zlib default malloc (which just calls malloc and  * ignores the first argument) should be completely compatible with the  * following.  */
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|png_voidp
argument_list|,
operator|*
name|png_malloc_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_alloc_size_t
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_free_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_voidp
operator|)
argument_list|, )
expr_stmt|;
DECL|typedef|png_structpp
typedef|typedef
name|png_struct
name|FAR
modifier|*
name|FAR
modifier|*
name|png_structpp
typedef|;
comment|/* Section 3: exported functions  * Here are the function definitions most commonly used.  This is not  * the place to find out how to use libpng.  See libpng-manual.txt for the  * full explanation, see example.c for the summary.  This just provides  * a simple one line description of the use of each function.  *  * The PNG_EXPORT() and PNG_EXPORTA() macros used below are defined in  * pngconf.h and in the *.dfn files in the scripts directory.  *  *   PNG_EXPORT(ordinal, type, name, (args));  *  *       ordinal:    ordinal that is used while building  *                   *.def files. The ordinal value is only  *                   relevant when preprocessing png.h with  *                   the *.dfn files for building symbol table  *                   entries, and are removed by pngconf.h.  *       type:       return type of the function  *       name:       function name  *       args:       function arguments, with types  *  * When we wish to append attributes to a function prototype we use  * the PNG_EXPORTA() macro instead.  *  *   PNG_EXPORTA(ordinal, type, name, (args), attributes);  *  *       ordinal, type, name, and args: same as in PNG_EXPORT().  *       attributes: function attributes  */
comment|/* Returns the version number of the library */
name|PNG_EXPORT
argument_list|(
literal|1
argument_list|,
name|png_uint_32
argument_list|,
name|png_access_version_number
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Tell lib we have already handled the first<num_bytes> magic bytes.  * Handling more than 8 bytes from the beginning of the file is an error.  */
name|PNG_EXPORT
argument_list|(
literal|2
argument_list|,
name|void
argument_list|,
name|png_set_sig_bytes
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|num_bytes
operator|)
argument_list|)
expr_stmt|;
comment|/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a  * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG  * signature, and non-zero otherwise.  Having num_to_check == 0 or  * start> 7 will always fail (ie return non-zero).  */
name|PNG_EXPORT
argument_list|(
literal|3
argument_list|,
name|int
argument_list|,
name|png_sig_cmp
argument_list|,
operator|(
name|png_const_bytep
name|sig
operator|,
name|png_size_t
name|start
operator|,
name|png_size_t
name|num_to_check
operator|)
argument_list|)
expr_stmt|;
comment|/* Simple signature checking function.  This is the same as calling  * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).  */
DECL|macro|png_check_sig
define|#
directive|define
name|png_check_sig
parameter_list|(
name|sig
parameter_list|,
name|n
parameter_list|)
value|!png_sig_cmp((sig), 0, (n))
comment|/* Allocate and initialize png_ptr struct for reading, and any other memory. */
name|PNG_EXPORTA
argument_list|(
literal|4
argument_list|,
name|png_structp
argument_list|,
name|png_create_read_struct
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize png_ptr struct for writing, and any other memory */
name|PNG_EXPORTA
argument_list|(
literal|5
argument_list|,
name|png_structp
argument_list|,
name|png_create_write_struct
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|6
argument_list|,
name|png_size_t
argument_list|,
name|png_get_compression_buffer_size
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|7
argument_list|,
name|void
argument_list|,
name|png_set_compression_buffer_size
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_size_t
name|size
operator|)
argument_list|)
expr_stmt|;
comment|/* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp  * match up.  */
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* This function returns the jmp_buf built in to *png_ptr.  It must be  * supplied with an appropriate 'longjmp' function to use on that jmp_buf  * unless the default error function is overridden in which case NULL is  * acceptable.  The size of the jmp_buf is checked against the actual size  * allocated by the library - the call will return NULL on a mismatch  * indicating an ABI mismatch.  */
name|PNG_EXPORT
argument_list|(
literal|8
argument_list|,
name|jmp_buf
operator|*
argument_list|,
name|png_set_longjmp_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_longjmp_ptr
name|longjmp_fn
operator|,
name|size_t
name|jmp_buf_size
operator|)
argument_list|)
expr_stmt|;
DECL|macro|png_jmpbuf
define|#
directive|define
name|png_jmpbuf
parameter_list|(
name|png_ptr
parameter_list|)
define|\
value|(*png_set_longjmp_fn((png_ptr), longjmp, sizeof (jmp_buf)))
else|#
directive|else
DECL|macro|png_jmpbuf
define|#
directive|define
name|png_jmpbuf
parameter_list|(
name|png_ptr
parameter_list|)
define|\
value|(LIBPNG_WAS_COMPILED_WITH__PNG_NO_SETJMP)
endif|#
directive|endif
comment|/* This function should be used by libpng applications in place of  * longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it  * will use it; otherwise it will call PNG_ABORT().  This function was  * added in libpng-1.5.0.  */
name|PNG_EXPORTA
argument_list|(
literal|9
argument_list|,
name|void
argument_list|,
name|png_longjmp
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|val
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
comment|/* Reset the compression stream */
name|PNG_EXPORT
argument_list|(
literal|10
argument_list|,
name|int
argument_list|,
name|png_reset_zstream
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) */
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|PNG_EXPORTA
argument_list|(
literal|11
argument_list|,
name|png_structp
argument_list|,
name|png_create_read_struct_2
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|,
name|png_voidp
name|mem_ptr
operator|,
name|png_malloc_ptr
name|malloc_fn
operator|,
name|png_free_ptr
name|free_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
name|PNG_EXPORTA
argument_list|(
literal|12
argument_list|,
name|png_structp
argument_list|,
name|png_create_write_struct_2
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|,
name|png_voidp
name|mem_ptr
operator|,
name|png_malloc_ptr
name|malloc_fn
operator|,
name|png_free_ptr
name|free_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write the PNG file signature. */
name|PNG_EXPORT
argument_list|(
literal|13
argument_list|,
name|void
argument_list|,
name|png_write_sig
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Write a PNG chunk - size, type, (optional) data, CRC. */
name|PNG_EXPORT
argument_list|(
literal|14
argument_list|,
name|void
argument_list|,
name|png_write_chunk
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_bytep
name|chunk_name
operator|,
name|png_const_bytep
name|data
operator|,
name|png_size_t
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the start of a PNG chunk - length and chunk name. */
name|PNG_EXPORT
argument_list|(
literal|15
argument_list|,
name|void
argument_list|,
name|png_write_chunk_start
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_bytep
name|chunk_name
operator|,
name|png_uint_32
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the data of a PNG chunk started with png_write_chunk_start(). */
name|PNG_EXPORT
argument_list|(
literal|16
argument_list|,
name|void
argument_list|,
name|png_write_chunk_data
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_bytep
name|data
operator|,
name|png_size_t
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* Finish a chunk started with png_write_chunk_start() (includes CRC). */
name|PNG_EXPORT
argument_list|(
literal|17
argument_list|,
name|void
argument_list|,
name|png_write_chunk_end
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize the info structure */
name|PNG_EXPORTA
argument_list|(
literal|18
argument_list|,
name|png_infop
argument_list|,
name|png_create_info_struct
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|19
argument_list|,
name|void
argument_list|,
name|png_info_init_3
argument_list|,
operator|(
name|png_infopp
name|info_ptr
operator|,
name|png_size_t
name|png_info_struct_size
operator|)
argument_list|)
expr_stmt|;
comment|/* Writes all the PNG information before the image. */
name|PNG_EXPORT
argument_list|(
literal|20
argument_list|,
name|void
argument_list|,
name|png_write_info_before_PLTE
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|21
argument_list|,
name|void
argument_list|,
name|png_write_info
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read the information before the actual image data. */
name|PNG_EXPORT
argument_list|(
literal|22
argument_list|,
name|void
argument_list|,
name|png_read_info
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|23
argument_list|,
name|png_const_charp
argument_list|,
name|png_convert_to_rfc1123
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_timep
name|ptime
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_CONVERT_tIME_SUPPORTED
comment|/* Convert from a struct tm to png_time */
name|PNG_EXPORT
argument_list|(
literal|24
argument_list|,
name|void
argument_list|,
name|png_convert_from_struct_tm
argument_list|,
operator|(
name|png_timep
name|ptime
operator|,
name|PNG_CONST
expr|struct
name|tm
name|FAR
operator|*
name|ttime
operator|)
argument_list|)
expr_stmt|;
comment|/* Convert from time_t to png_time.  Uses gmtime() */
name|PNG_EXPORT
argument_list|(
literal|25
argument_list|,
name|void
argument_list|,
name|png_convert_from_time_t
argument_list|,
operator|(
name|png_timep
name|ptime
operator|,
name|time_t
name|ttime
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_CONVERT_tIME_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
comment|/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
name|PNG_EXPORT
argument_list|(
literal|26
argument_list|,
name|void
argument_list|,
name|png_set_expand
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|27
argument_list|,
name|void
argument_list|,
name|png_set_expand_gray_1_2_4_to_8
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|28
argument_list|,
name|void
argument_list|,
name|png_set_palette_to_rgb
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|29
argument_list|,
name|void
argument_list|,
name|png_set_tRNS_to_alpha
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BGR_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_BGR_SUPPORTED
argument_list|)
comment|/* Use blue, green, red order for pixels. */
name|PNG_EXPORT
argument_list|(
literal|30
argument_list|,
name|void
argument_list|,
name|png_set_bgr
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
comment|/* Expand the grayscale to 24-bit RGB if necessary. */
name|PNG_EXPORT
argument_list|(
literal|31
argument_list|,
name|void
argument_list|,
name|png_set_gray_to_rgb
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
comment|/* Reduce RGB to grayscale. */
name|PNG_FP_EXPORT
argument_list|(
literal|32
argument_list|,
name|void
argument_list|,
name|png_set_rgb_to_gray
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|error_action
operator|,
name|double
name|red
operator|,
name|double
name|green
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|33
argument_list|,
name|void
argument_list|,
name|png_set_rgb_to_gray_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|error_action
operator|,
name|png_fixed_point
name|red
operator|,
name|png_fixed_point
name|green
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|34
argument_list|,
name|png_byte
argument_list|,
name|png_get_rgb_to_gray_status
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|35
argument_list|,
name|void
argument_list|,
name|png_build_grayscale_palette
argument_list|,
operator|(
name|int
name|bit_depth
operator|,
name|png_colorp
name|palette
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|36
argument_list|,
name|void
argument_list|,
name|png_set_strip_alpha
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SWAP_ALPHA_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_SWAP_ALPHA_SUPPORTED
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|37
argument_list|,
name|void
argument_list|,
name|png_set_swap_alpha
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INVERT_ALPHA_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_INVERT_ALPHA_SUPPORTED
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|38
argument_list|,
name|void
argument_list|,
name|png_set_invert_alpha
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_FILLER_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_FILLER_SUPPORTED
argument_list|)
comment|/* Add a filler byte to 8-bit Gray or 24-bit RGB images. */
name|PNG_EXPORT
argument_list|(
literal|39
argument_list|,
name|void
argument_list|,
name|png_set_filler
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_uint_32
name|filler
operator|,
name|int
name|flags
operator|)
argument_list|)
expr_stmt|;
comment|/* The values of the PNG_FILLER_ defines should NOT be changed */
DECL|macro|PNG_FILLER_BEFORE
define|#
directive|define
name|PNG_FILLER_BEFORE
value|0
DECL|macro|PNG_FILLER_AFTER
define|#
directive|define
name|PNG_FILLER_AFTER
value|1
comment|/* Add an alpha byte to 8-bit Gray or 24-bit RGB images. */
name|PNG_EXPORT
argument_list|(
literal|40
argument_list|,
name|void
argument_list|,
name|png_set_add_alpha
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_uint_32
name|filler
operator|,
name|int
name|flags
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_READ_FILLER_SUPPORTED || PNG_WRITE_FILLER_SUPPORTED */
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SWAP_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SWAP_SUPPORTED
argument_list|)
comment|/* Swap bytes in 16-bit depth files. */
name|PNG_EXPORT
argument_list|(
literal|41
argument_list|,
name|void
argument_list|,
name|png_set_swap
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_PACK_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_PACK_SUPPORTED
argument_list|)
comment|/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
name|PNG_EXPORT
argument_list|(
literal|42
argument_list|,
name|void
argument_list|,
name|png_set_packing
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_PACKSWAP_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_PACKSWAP_SUPPORTED
argument_list|)
comment|/* Swap packing order of pixels in bytes. */
name|PNG_EXPORT
argument_list|(
literal|43
argument_list|,
name|void
argument_list|,
name|png_set_packswap
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SHIFT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SHIFT_SUPPORTED
argument_list|)
comment|/* Converts files to legal bit depths. */
name|PNG_EXPORT
argument_list|(
literal|44
argument_list|,
name|void
argument_list|,
name|png_set_shift
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_color_8p
name|true_bits
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INTERLACING_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_INTERLACING_SUPPORTED
argument_list|)
comment|/* Have the code handle the interlacing.  Returns the number of passes.  * MUST be called before png_read_update_info or png_start_read_image,  * otherwise it will not have the desired effect.  Note that it is still  * necessary to call png_read_row or png_read_rows png_get_image_height  * times for each pass. */
name|PNG_EXPORT
argument_list|(
literal|45
argument_list|,
name|int
argument_list|,
name|png_set_interlace_handling
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INVERT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_INVERT_SUPPORTED
argument_list|)
comment|/* Invert monochrome files */
name|PNG_EXPORT
argument_list|(
literal|46
argument_list|,
name|void
argument_list|,
name|png_set_invert_mono
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
comment|/* Handle alpha and tRNS by replacing with a background color. */
name|PNG_FP_EXPORT
argument_list|(
literal|47
argument_list|,
name|void
argument_list|,
name|png_set_background
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_color_16p
name|background_color
operator|,
name|int
name|background_gamma_code
operator|,
name|int
name|need_expand
operator|,
name|double
name|background_gamma
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|215
argument_list|,
name|void
argument_list|,
name|png_set_background_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_color_16p
name|background_color
operator|,
name|int
name|background_gamma_code
operator|,
name|int
name|need_expand
operator|,
name|png_fixed_point
name|background_gamma
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
DECL|macro|PNG_BACKGROUND_GAMMA_UNKNOWN
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_UNKNOWN
value|0
DECL|macro|PNG_BACKGROUND_GAMMA_SCREEN
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_SCREEN
value|1
DECL|macro|PNG_BACKGROUND_GAMMA_FILE
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_FILE
value|2
DECL|macro|PNG_BACKGROUND_GAMMA_UNIQUE
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_UNIQUE
value|3
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_16_TO_8_SUPPORTED
comment|/* Strip the second byte of information from a 16-bit depth file. */
name|PNG_EXPORT
argument_list|(
literal|48
argument_list|,
name|void
argument_list|,
name|png_set_strip_16
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
comment|/* Turn on quantizing, and reduce the palette to the number of colors  * available.  */
name|PNG_EXPORT
argument_list|(
literal|49
argument_list|,
name|void
argument_list|,
name|png_set_quantize
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_colorp
name|palette
operator|,
name|int
name|num_palette
operator|,
name|int
name|maximum_colors
operator|,
name|png_const_uint_16p
name|histogram
operator|,
name|int
name|full_quantize
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* The threshold on gamma processing is configurable but hard-wired into the  * library.  The following is the floating point variant.  */
DECL|macro|PNG_GAMMA_THRESHOLD
define|#
directive|define
name|PNG_GAMMA_THRESHOLD
value|(PNG_GAMMA_THRESHOLD_FIXED*.00001)
comment|/* Handle gamma correction. Screen_gamma=(display_exponent) */
name|PNG_FP_EXPORT
argument_list|(
literal|50
argument_list|,
name|void
argument_list|,
name|png_set_gamma
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|double
name|screen_gamma
operator|,
name|double
name|default_file_gamma
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|208
argument_list|,
name|void
argument_list|,
name|png_set_gamma_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_fixed_point
name|screen_gamma
operator|,
name|png_fixed_point
name|default_file_gamma
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
comment|/* Set how many lines between output flushes - 0 for no flushing */
name|PNG_EXPORT
argument_list|(
literal|51
argument_list|,
name|void
argument_list|,
name|png_set_flush
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|nrows
operator|)
argument_list|)
expr_stmt|;
comment|/* Flush the current PNG output buffer */
name|PNG_EXPORT
argument_list|(
literal|52
argument_list|,
name|void
argument_list|,
name|png_write_flush
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Optional update palette with requested transformations */
name|PNG_EXPORT
argument_list|(
literal|53
argument_list|,
name|void
argument_list|,
name|png_start_read_image
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Optional call to update the users info structure */
name|PNG_EXPORT
argument_list|(
literal|54
argument_list|,
name|void
argument_list|,
name|png_read_update_info
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read one or more rows of image data. */
name|PNG_EXPORT
argument_list|(
literal|55
argument_list|,
name|void
argument_list|,
name|png_read_rows
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_bytepp
name|row
operator|,
name|png_bytepp
name|display_row
operator|,
name|png_uint_32
name|num_rows
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read a row of data. */
name|PNG_EXPORT
argument_list|(
literal|56
argument_list|,
name|void
argument_list|,
name|png_read_row
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_bytep
name|row
operator|,
name|png_bytep
name|display_row
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read the whole image into memory at once. */
name|PNG_EXPORT
argument_list|(
literal|57
argument_list|,
name|void
argument_list|,
name|png_read_image
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_bytepp
name|image
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write a row of image data */
name|PNG_EXPORT
argument_list|(
literal|58
argument_list|,
name|void
argument_list|,
name|png_write_row
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_bytep
name|row
operator|)
argument_list|)
expr_stmt|;
comment|/* Write a few rows of image data: (*row) is not written; however, the type  * is declared as writeable to maintain compatibility with previous versions  * of libpng and to allow the 'display_row' array from read_rows to be passed  * unchanged to write_rows.  */
name|PNG_EXPORT
argument_list|(
literal|59
argument_list|,
name|void
argument_list|,
name|png_write_rows
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_bytepp
name|row
operator|,
name|png_uint_32
name|num_rows
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the image data */
name|PNG_EXPORT
argument_list|(
literal|60
argument_list|,
name|void
argument_list|,
name|png_write_image
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_bytepp
name|image
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the end of the PNG file. */
name|PNG_EXPORT
argument_list|(
literal|61
argument_list|,
name|void
argument_list|,
name|png_write_end
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read the end of the PNG file. */
name|PNG_EXPORT
argument_list|(
literal|62
argument_list|,
name|void
argument_list|,
name|png_read_end
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Free any memory associated with the png_info_struct */
name|PNG_EXPORT
argument_list|(
literal|63
argument_list|,
name|void
argument_list|,
name|png_destroy_info_struct
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infopp
name|info_ptr_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Free any memory associated with the png_struct and the png_info_structs */
name|PNG_EXPORT
argument_list|(
literal|64
argument_list|,
name|void
argument_list|,
name|png_destroy_read_struct
argument_list|,
operator|(
name|png_structpp
name|png_ptr_ptr
operator|,
name|png_infopp
name|info_ptr_ptr
operator|,
name|png_infopp
name|end_info_ptr_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Free any memory associated with the png_struct and the png_info_structs */
name|PNG_EXPORT
argument_list|(
literal|65
argument_list|,
name|void
argument_list|,
name|png_destroy_write_struct
argument_list|,
operator|(
name|png_structpp
name|png_ptr_ptr
operator|,
name|png_infopp
name|info_ptr_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the libpng method of handling chunk CRC errors */
name|PNG_EXPORT
argument_list|(
literal|66
argument_list|,
name|void
argument_list|,
name|png_set_crc_action
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|crit_action
operator|,
name|int
name|ancil_action
operator|)
argument_list|)
expr_stmt|;
comment|/* Values for png_set_crc_action() say how to handle CRC errors in  * ancillary and critical chunks, and whether to use the data contained  * therein.  Note that it is impossible to "discard" data in a critical  * chunk.  For versions prior to 0.90, the action was always error/quit,   * whereas in version 0.90 and later, the action for CRC errors in ancillary  * chunks is warn/discard.  These values should NOT be changed.  *  *      value                       action:critical     action:ancillary  */
DECL|macro|PNG_CRC_DEFAULT
define|#
directive|define
name|PNG_CRC_DEFAULT
value|0
comment|/* error/quit          warn/discard data */
DECL|macro|PNG_CRC_ERROR_QUIT
define|#
directive|define
name|PNG_CRC_ERROR_QUIT
value|1
comment|/* error/quit          error/quit        */
DECL|macro|PNG_CRC_WARN_DISCARD
define|#
directive|define
name|PNG_CRC_WARN_DISCARD
value|2
comment|/* (INVALID)           warn/discard data */
DECL|macro|PNG_CRC_WARN_USE
define|#
directive|define
name|PNG_CRC_WARN_USE
value|3
comment|/* warn/use data       warn/use data     */
DECL|macro|PNG_CRC_QUIET_USE
define|#
directive|define
name|PNG_CRC_QUIET_USE
value|4
comment|/* quiet/use data      quiet/use data    */
DECL|macro|PNG_CRC_NO_CHANGE
define|#
directive|define
name|PNG_CRC_NO_CHANGE
value|5
comment|/* use current value   use current value */
comment|/* These functions give the user control over the scan-line filtering in  * libpng and the compression methods used by zlib.  These functions are  * mainly useful for testing, as the defaults should work with most users.  * Those users who are tight on memory or want faster performance at the  * expense of compression can modify them.  See the compression library  * header file (zlib.h) for an explination of the compression functions.  */
comment|/* Set the filtering method(s) used by libpng.  Currently, the only valid  * value for "method" is 0.  */
name|PNG_EXPORT
argument_list|(
literal|67
argument_list|,
name|void
argument_list|,
name|png_set_filter
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|method
operator|,
name|int
name|filters
operator|)
argument_list|)
expr_stmt|;
comment|/* Flags for png_set_filter() to say which filters to use.  The flags  * are chosen so that they don't conflict with real filter types  * below, in case they are supplied instead of the #defined constants.  * These values should NOT be changed.  */
DECL|macro|PNG_NO_FILTERS
define|#
directive|define
name|PNG_NO_FILTERS
value|0x00
DECL|macro|PNG_FILTER_NONE
define|#
directive|define
name|PNG_FILTER_NONE
value|0x08
DECL|macro|PNG_FILTER_SUB
define|#
directive|define
name|PNG_FILTER_SUB
value|0x10
DECL|macro|PNG_FILTER_UP
define|#
directive|define
name|PNG_FILTER_UP
value|0x20
DECL|macro|PNG_FILTER_AVG
define|#
directive|define
name|PNG_FILTER_AVG
value|0x40
DECL|macro|PNG_FILTER_PAETH
define|#
directive|define
name|PNG_FILTER_PAETH
value|0x80
DECL|macro|PNG_ALL_FILTERS
define|#
directive|define
name|PNG_ALL_FILTERS
value|(PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP | \                          PNG_FILTER_AVG | PNG_FILTER_PAETH)
comment|/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.  * These defines should NOT be changed.  */
DECL|macro|PNG_FILTER_VALUE_NONE
define|#
directive|define
name|PNG_FILTER_VALUE_NONE
value|0
DECL|macro|PNG_FILTER_VALUE_SUB
define|#
directive|define
name|PNG_FILTER_VALUE_SUB
value|1
DECL|macro|PNG_FILTER_VALUE_UP
define|#
directive|define
name|PNG_FILTER_VALUE_UP
value|2
DECL|macro|PNG_FILTER_VALUE_AVG
define|#
directive|define
name|PNG_FILTER_VALUE_AVG
value|3
DECL|macro|PNG_FILTER_VALUE_PAETH
define|#
directive|define
name|PNG_FILTER_VALUE_PAETH
value|4
DECL|macro|PNG_FILTER_VALUE_LAST
define|#
directive|define
name|PNG_FILTER_VALUE_LAST
value|5
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* EXPERIMENTAL */
comment|/* The "heuristic_method" is given by one of the PNG_FILTER_HEURISTIC_  * defines, either the default (minimum-sum-of-absolute-differences), or  * the experimental method (weighted-minimum-sum-of-absolute-differences).  *  * Weights are factors>= 1.0, indicating how important it is to keep the  * filter type consistent between rows.  Larger numbers mean the current  * filter is that many times as likely to be the same as the "num_weights"  * previous filters.  This is cumulative for each previous row with a weight.  * There needs to be "num_weights" values in "filter_weights", or it can be  * NULL if the weights aren't being specified.  Weights have no influence on  * the selection of the first row filter.  Well chosen weights can (in theory)  * improve the compression for a given image.  *  * Costs are factors>= 1.0 indicating the relative decoding costs of a  * filter type.  Higher costs indicate more decoding expense, and are  * therefore less likely to be selected over a filter with lower computational  * costs.  There needs to be a value in "filter_costs" for each valid filter  * type (given by PNG_FILTER_VALUE_LAST), or it can be NULL if you aren't  * setting the costs.  Costs try to improve the speed of decompression without  * unduly increasing the compressed image size.  *  * A negative weight or cost indicates the default value is to be used, and  * values in the range [0.0, 1.0) indicate the value is to remain unchanged.  * The default values for both weights and costs are currently 1.0, but may  * change if good general weighting/cost heuristics can be found.  If both  * the weights and costs are set to 1.0, this degenerates the WEIGHTED method  * to the UNWEIGHTED method, but with added encoding time/computation.  */
name|PNG_FP_EXPORT
argument_list|(
literal|68
argument_list|,
name|void
argument_list|,
name|png_set_filter_heuristics
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|heuristic_method
operator|,
name|int
name|num_weights
operator|,
name|png_const_doublep
name|filter_weights
operator|,
name|png_const_doublep
name|filter_costs
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|209
argument_list|,
name|void
argument_list|,
name|png_set_filter_heuristics_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|heuristic_method
operator|,
name|int
name|num_weights
operator|,
name|png_const_fixed_point_p
name|filter_weights
operator|,
name|png_const_fixed_point_p
name|filter_costs
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
comment|/* Heuristic used for row filter selection.  These defines should NOT be  * changed.  */
DECL|macro|PNG_FILTER_HEURISTIC_DEFAULT
define|#
directive|define
name|PNG_FILTER_HEURISTIC_DEFAULT
value|0
comment|/* Currently "UNWEIGHTED" */
DECL|macro|PNG_FILTER_HEURISTIC_UNWEIGHTED
define|#
directive|define
name|PNG_FILTER_HEURISTIC_UNWEIGHTED
value|1
comment|/* Used by libpng< 0.95 */
DECL|macro|PNG_FILTER_HEURISTIC_WEIGHTED
define|#
directive|define
name|PNG_FILTER_HEURISTIC_WEIGHTED
value|2
comment|/* Experimental feature */
DECL|macro|PNG_FILTER_HEURISTIC_LAST
define|#
directive|define
name|PNG_FILTER_HEURISTIC_LAST
value|3
comment|/* Not a valid value */
comment|/* Set the library compression level.  Currently, valid values range from  * 0 - 9, corresponding directly to the zlib compression levels 0 - 9  * (0 - no compression, 9 - "maximal" compression).  Note that tests have  * shown that zlib compression levels 3-6 usually perform as well as level 9  * for PNG images, and do considerably fewer caclulations.  In the future,   * these values may not correspond directly to the zlib compression levels.  */
name|PNG_EXPORT
argument_list|(
literal|69
argument_list|,
name|void
argument_list|,
name|png_set_compression_level
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|level
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|70
argument_list|,
name|void
argument_list|,
name|png_set_compression_mem_level
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|mem_level
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|71
argument_list|,
name|void
argument_list|,
name|png_set_compression_strategy
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|strategy
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|72
argument_list|,
name|void
argument_list|,
name|png_set_compression_window_bits
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|window_bits
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|73
argument_list|,
name|void
argument_list|,
name|png_set_compression_method
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|method
operator|)
argument_list|)
expr_stmt|;
comment|/* These next functions are called for input/output, memory, and error  * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,   * and call standard C I/O routines such as fread(), fwrite(), and  * fprintf().  These functions can be made to use other I/O routines  * at run time for those applications that need to handle I/O in a  * different manner by calling png_set_???_fn().  See libpng-manual.txt for  * more information.  */
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
comment|/* Initialize the input/output for the PNG file to the default functions. */
name|PNG_EXPORT
argument_list|(
literal|74
argument_list|,
name|void
argument_list|,
name|png_init_io
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_FILE_p
name|fp
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Replace the (error and abort), and warning functions with user  * supplied functions.  If no messages are to be printed you must still  * write and use replacement functions. The replacement error_fn should  * still do a longjmp to the last setjmp location if you are using this  * method of error handling.  If error_fn or warning_fn is NULL, the  * default function will be used.  */
name|PNG_EXPORT
argument_list|(
literal|75
argument_list|,
name|void
argument_list|,
name|png_set_error_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warning_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the error functions */
name|PNG_EXPORT
argument_list|(
literal|76
argument_list|,
name|png_voidp
argument_list|,
name|png_get_error_ptr
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Replace the default data output functions with a user supplied one(s).  * If buffered output is not used, then output_flush_fn can be set to NULL.  * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time  * output_flush_fn will be ignored (and thus can be NULL).  * It is probably a mistake to use NULL for output_flush_fn if  * write_data_fn is not also NULL unless you have built libpng with  * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's  * default flush function, which uses the standard *FILE structure, will  * be used.  */
name|PNG_EXPORT
argument_list|(
literal|77
argument_list|,
name|void
argument_list|,
name|png_set_write_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|io_ptr
operator|,
name|png_rw_ptr
name|write_data_fn
operator|,
name|png_flush_ptr
name|output_flush_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Replace the default data input function with a user supplied one. */
name|PNG_EXPORT
argument_list|(
literal|78
argument_list|,
name|void
argument_list|,
name|png_set_read_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|io_ptr
operator|,
name|png_rw_ptr
name|read_data_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the I/O functions */
name|PNG_EXPORT
argument_list|(
literal|79
argument_list|,
name|png_voidp
argument_list|,
name|png_get_io_ptr
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|80
argument_list|,
name|void
argument_list|,
name|png_set_read_status_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_read_status_ptr
name|read_row_fn
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|81
argument_list|,
name|void
argument_list|,
name|png_set_write_status_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_write_status_ptr
name|write_row_fn
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
comment|/* Replace the default memory allocation functions with user supplied one(s). */
name|PNG_EXPORT
argument_list|(
literal|82
argument_list|,
name|void
argument_list|,
name|png_set_mem_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|mem_ptr
operator|,
name|png_malloc_ptr
name|malloc_fn
operator|,
name|png_free_ptr
name|free_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the memory functions */
name|PNG_EXPORT
argument_list|(
literal|83
argument_list|,
name|png_voidp
argument_list|,
name|png_get_mem_ptr
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|84
argument_list|,
name|void
argument_list|,
name|png_set_read_user_transform_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_user_transform_ptr
name|read_user_transform_fn
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|85
argument_list|,
name|void
argument_list|,
name|png_set_write_user_transform_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_user_transform_ptr
name|write_user_transform_fn
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_TRANSFORM_PTR_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|86
argument_list|,
name|void
argument_list|,
name|png_set_user_transform_info
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|user_transform_ptr
operator|,
name|int
name|user_transform_depth
operator|,
name|int
name|user_transform_channels
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the user transform functions */
name|PNG_EXPORT
argument_list|(
literal|87
argument_list|,
name|png_voidp
argument_list|,
name|png_get_user_transform_ptr
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_TRANSFORM_INFO_SUPPORTED
comment|/* Return information about the row currently being processed.  Note that these  * APIs do not fail but will return unexpected results if called outside a user  * transform callback.  Also note that when transforming an interlaced image the  * row number is still the row in the final, de-interlaced, image but the row  * only contains the data of the current pass - consult png_row_info for the  * actual width of the row!  */
name|PNG_EXPORT
argument_list|(
literal|217
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_current_row_number
argument_list|,
operator|(
name|png_const_structp
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|218
argument_list|,
name|png_byte
argument_list|,
name|png_get_current_pass_number
argument_list|,
operator|(
name|png_const_structp
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_CHUNKS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|88
argument_list|,
name|void
argument_list|,
name|png_set_read_user_chunk_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|user_chunk_ptr
operator|,
name|png_user_chunk_ptr
name|read_user_chunk_fn
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|89
argument_list|,
name|png_voidp
argument_list|,
name|png_get_user_chunk_ptr
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
comment|/* Sets the function callbacks for the push reader, and a pointer to a  * user-defined structure available to the callback functions.  */
name|PNG_EXPORT
argument_list|(
literal|90
argument_list|,
name|void
argument_list|,
name|png_set_progressive_read_fn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|progressive_ptr
operator|,
name|png_progressive_info_ptr
name|info_fn
operator|,
name|png_progressive_row_ptr
name|row_fn
operator|,
name|png_progressive_end_ptr
name|end_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns the user pointer associated with the push read functions */
name|PNG_EXPORT
argument_list|(
literal|91
argument_list|,
name|png_voidp
argument_list|,
name|png_get_progressive_ptr
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Function to be called when data becomes available */
name|PNG_EXPORT
argument_list|(
literal|92
argument_list|,
name|void
argument_list|,
name|png_process_data
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_bytep
name|buffer
operator|,
name|png_size_t
name|buffer_size
operator|)
argument_list|)
expr_stmt|;
comment|/* A function which may be called *only* within png_process_data to stop the  * processing of any more data.  The function returns the number of bytes  * remaining, excluding any that libpng has cached internally.  A subsequent  * call to png_process_data must supply these bytes again.  If the argument  * 'save' is set to true the routine will first save all the pending data and  * will always return 0.  */
name|PNG_EXPORT
argument_list|(
literal|219
argument_list|,
name|png_size_t
argument_list|,
name|png_process_data_pause
argument_list|,
operator|(
name|png_structp
operator|,
name|int
name|save
operator|)
argument_list|)
expr_stmt|;
comment|/* A function which may be called *only* outside (after) a call to  * png_process_data.  It returns the number of bytes of data to skip in the  * input.  Normally it will return 0, but if it returns a non-zero value the  * application must skip than number of bytes of input data and pass the  * following data to the next call to png_process_data.  */
name|PNG_EXPORT
argument_list|(
literal|220
argument_list|,
name|png_uint_32
argument_list|,
name|png_process_data_skip
argument_list|,
operator|(
name|png_structp
operator|)
argument_list|)
expr_stmt|;
comment|/* Function that combines rows.  'new_row' is a flag that should come from  * the callback and be non-NULL if anything needs to be done; the library  * stores its own version of the new data internally and ignores the passed  * in value.  */
name|PNG_EXPORT
argument_list|(
literal|93
argument_list|,
name|void
argument_list|,
name|png_progressive_combine_row
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_bytep
name|old_row
operator|,
name|png_const_bytep
name|new_row
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_PROGRESSIVE_READ_SUPPORTED */
name|PNG_EXPORTA
argument_list|(
literal|94
argument_list|,
name|png_voidp
argument_list|,
name|png_malloc
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Added at libpng version 1.4.0 */
name|PNG_EXPORTA
argument_list|(
literal|95
argument_list|,
name|png_voidp
argument_list|,
name|png_calloc
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Added at libpng version 1.2.4 */
name|PNG_EXPORTA
argument_list|(
literal|96
argument_list|,
name|png_voidp
argument_list|,
name|png_malloc_warn
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Frees a pointer allocated by png_malloc() */
name|PNG_EXPORT
argument_list|(
literal|97
argument_list|,
name|void
argument_list|,
name|png_free
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Free data that was allocated internally */
name|PNG_EXPORT
argument_list|(
literal|98
argument_list|,
name|void
argument_list|,
name|png_free_data
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_uint_32
name|free_me
operator|,
name|int
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* Reassign responsibility for freeing existing data, whether allocated  * by libpng or by the application */
name|PNG_EXPORT
argument_list|(
literal|99
argument_list|,
name|void
argument_list|,
name|png_data_freer
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|freer
operator|,
name|png_uint_32
name|mask
operator|)
argument_list|)
expr_stmt|;
comment|/* Assignments for png_data_freer */
DECL|macro|PNG_DESTROY_WILL_FREE_DATA
define|#
directive|define
name|PNG_DESTROY_WILL_FREE_DATA
value|1
DECL|macro|PNG_SET_WILL_FREE_DATA
define|#
directive|define
name|PNG_SET_WILL_FREE_DATA
value|1
DECL|macro|PNG_USER_WILL_FREE_DATA
define|#
directive|define
name|PNG_USER_WILL_FREE_DATA
value|2
comment|/* Flags for png_ptr->free_me and info_ptr->free_me */
DECL|macro|PNG_FREE_HIST
define|#
directive|define
name|PNG_FREE_HIST
value|0x0008
DECL|macro|PNG_FREE_ICCP
define|#
directive|define
name|PNG_FREE_ICCP
value|0x0010
DECL|macro|PNG_FREE_SPLT
define|#
directive|define
name|PNG_FREE_SPLT
value|0x0020
DECL|macro|PNG_FREE_ROWS
define|#
directive|define
name|PNG_FREE_ROWS
value|0x0040
DECL|macro|PNG_FREE_PCAL
define|#
directive|define
name|PNG_FREE_PCAL
value|0x0080
DECL|macro|PNG_FREE_SCAL
define|#
directive|define
name|PNG_FREE_SCAL
value|0x0100
DECL|macro|PNG_FREE_UNKN
define|#
directive|define
name|PNG_FREE_UNKN
value|0x0200
DECL|macro|PNG_FREE_LIST
define|#
directive|define
name|PNG_FREE_LIST
value|0x0400
DECL|macro|PNG_FREE_PLTE
define|#
directive|define
name|PNG_FREE_PLTE
value|0x1000
DECL|macro|PNG_FREE_TRNS
define|#
directive|define
name|PNG_FREE_TRNS
value|0x2000
DECL|macro|PNG_FREE_TEXT
define|#
directive|define
name|PNG_FREE_TEXT
value|0x4000
DECL|macro|PNG_FREE_ALL
define|#
directive|define
name|PNG_FREE_ALL
value|0x7fff
DECL|macro|PNG_FREE_MUL
define|#
directive|define
name|PNG_FREE_MUL
value|0x4220
comment|/* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|PNG_EXPORTA
argument_list|(
literal|100
argument_list|,
name|png_voidp
argument_list|,
name|png_malloc_default
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|101
argument_list|,
name|void
argument_list|,
name|png_free_default
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_ERROR_TEXT_SUPPORTED
comment|/* Fatal error in PNG image of libpng - can't continue */
name|PNG_EXPORTA
argument_list|(
literal|102
argument_list|,
name|void
argument_list|,
name|png_error
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|error_message
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
comment|/* The same, but the chunk name is prepended to the error string. */
name|PNG_EXPORTA
argument_list|(
literal|103
argument_list|,
name|void
argument_list|,
name|png_chunk_error
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|error_message
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Fatal error in PNG image of libpng - can't continue */
name|PNG_EXPORTA
argument_list|(
literal|104
argument_list|,
name|void
argument_list|,
name|png_err
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Non-fatal error in libpng.  Can continue, but may have a problem. */
name|PNG_EXPORT
argument_list|(
literal|105
argument_list|,
name|void
argument_list|,
name|png_warning
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
comment|/* Non-fatal error in libpng, chunk name is prepended to message. */
name|PNG_EXPORT
argument_list|(
literal|106
argument_list|,
name|void
argument_list|,
name|png_chunk_warning
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
comment|/* Benign error in libpng.  Can continue, but may have a problem.  * User can choose whether to handle as a fatal error or as a warning. */
DECL|macro|png_benign_error
undef|#
directive|undef
name|png_benign_error
name|PNG_EXPORT
argument_list|(
literal|107
argument_list|,
name|void
argument_list|,
name|png_benign_error
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
comment|/* Same, chunk name is prepended to message. */
DECL|macro|png_chunk_benign_error
undef|#
directive|undef
name|png_chunk_benign_error
name|PNG_EXPORT
argument_list|(
literal|108
argument_list|,
name|void
argument_list|,
name|png_chunk_benign_error
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|109
argument_list|,
name|void
argument_list|,
name|png_set_benign_errors
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|allowed
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PNG_ALLOW_BENIGN_ERRORS
DECL|macro|png_benign_error
define|#
directive|define
name|png_benign_error
value|png_warning
DECL|macro|png_chunk_benign_error
define|#
directive|define
name|png_chunk_benign_error
value|png_chunk_warning
else|#
directive|else
DECL|macro|png_benign_error
define|#
directive|define
name|png_benign_error
value|png_error
DECL|macro|png_chunk_benign_error
define|#
directive|define
name|png_chunk_benign_error
value|png_chunk_error
endif|#
directive|endif
endif|#
directive|endif
comment|/* The png_set_<chunk> functions are for storing values in the png_info_struct.  * Similarly, the png_get_<chunk> calls are used to read values from the  * png_info_struct, either storing the parameters in the passed variables, or  * setting pointers into the png_info_struct where the data is stored.  The  * png_get_<chunk> functions return a non-zero value if the data was available  * in info_ptr, or return zero and do not change any of the parameters if the  * data was not available.  *  * These functions should be used instead of directly accessing png_info  * to avoid problems with future changes in the size and internal layout of  * png_info_struct.  */
comment|/* Returns "flag" if chunk data is valid in info_ptr. */
name|PNG_EXPORT
argument_list|(
literal|110
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_valid
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_uint_32
name|flag
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns number of bytes needed to hold a transformed row. */
name|PNG_EXPORT
argument_list|(
literal|111
argument_list|,
name|png_size_t
argument_list|,
name|png_get_rowbytes
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
comment|/* Returns row_pointers, which is an array of pointers to scanlines that was  * returned from png_read_png().  */
name|PNG_EXPORT
argument_list|(
literal|112
argument_list|,
name|png_bytepp
argument_list|,
name|png_get_rows
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Set row_pointers, which is an array of pointers to scanlines for use  * by png_write_png().  */
name|PNG_EXPORT
argument_list|(
literal|113
argument_list|,
name|void
argument_list|,
name|png_set_rows
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_bytepp
name|row_pointers
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Returns number of color channels in image. */
name|PNG_EXPORT
argument_list|(
literal|114
argument_list|,
name|png_byte
argument_list|,
name|png_get_channels
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_EASY_ACCESS_SUPPORTED
comment|/* Returns image width in pixels. */
name|PNG_EXPORT
argument_list|(
literal|115
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_image_width
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image height in pixels. */
name|PNG_EXPORT
argument_list|(
literal|116
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_image_height
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image bit_depth. */
name|PNG_EXPORT
argument_list|(
literal|117
argument_list|,
name|png_byte
argument_list|,
name|png_get_bit_depth
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image color_type. */
name|PNG_EXPORT
argument_list|(
literal|118
argument_list|,
name|png_byte
argument_list|,
name|png_get_color_type
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image filter_type. */
name|PNG_EXPORT
argument_list|(
literal|119
argument_list|,
name|png_byte
argument_list|,
name|png_get_filter_type
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image interlace_type. */
name|PNG_EXPORT
argument_list|(
literal|120
argument_list|,
name|png_byte
argument_list|,
name|png_get_interlace_type
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image compression_type. */
name|PNG_EXPORT
argument_list|(
literal|121
argument_list|,
name|png_byte
argument_list|,
name|png_get_compression_type
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image resolution in pixels per meter, from pHYs chunk data. */
name|PNG_EXPORT
argument_list|(
literal|122
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pixels_per_meter
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|123
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_x_pixels_per_meter
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|124
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_y_pixels_per_meter
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
name|PNG_FP_EXPORT
argument_list|(
literal|125
argument_list|,
name|float
argument_list|,
name|png_get_pixel_aspect_ratio
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|210
argument_list|,
name|png_fixed_point
argument_list|,
name|png_get_pixel_aspect_ratio_fixed
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
name|PNG_EXPORT
argument_list|(
literal|126
argument_list|,
name|png_int_32
argument_list|,
name|png_get_x_offset_pixels
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|127
argument_list|,
name|png_int_32
argument_list|,
name|png_get_y_offset_pixels
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|128
argument_list|,
name|png_int_32
argument_list|,
name|png_get_x_offset_microns
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|129
argument_list|,
name|png_int_32
argument_list|,
name|png_get_y_offset_microns
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_EASY_ACCESS_SUPPORTED */
comment|/* Returns pointer to signature string read from PNG header */
name|PNG_EXPORT
argument_list|(
literal|130
argument_list|,
name|png_const_bytep
argument_list|,
name|png_get_signature
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_bKGD_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|131
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_bKGD
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_color_16p
operator|*
name|background
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_bKGD_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|132
argument_list|,
name|void
argument_list|,
name|png_set_bKGD
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_color_16p
name|background
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|133
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_cHRM
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|double
operator|*
name|white_x
operator|,
name|double
operator|*
name|white_y
operator|,
name|double
operator|*
name|red_x
operator|,
name|double
operator|*
name|red_y
operator|,
name|double
operator|*
name|green_x
operator|,
name|double
operator|*
name|green_y
operator|,
name|double
operator|*
name|blue_x
operator|,
name|double
operator|*
name|blue_y
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
comment|/* Otherwise not implemented */
name|PNG_FIXED_EXPORT
argument_list|(
literal|134
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_cHRM_fixed
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_fixed_point
operator|*
name|int_white_x
operator|,
name|png_fixed_point
operator|*
name|int_white_y
operator|,
name|png_fixed_point
operator|*
name|int_red_x
operator|,
name|png_fixed_point
operator|*
name|int_red_y
operator|,
name|png_fixed_point
operator|*
name|int_green_x
operator|,
name|png_fixed_point
operator|*
name|int_green_y
operator|,
name|png_fixed_point
operator|*
name|int_blue_x
operator|,
name|png_fixed_point
operator|*
name|int_blue_y
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|135
argument_list|,
name|void
argument_list|,
name|png_set_cHRM
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|double
name|white_x
operator|,
name|double
name|white_y
operator|,
name|double
name|red_x
operator|,
name|double
name|red_y
operator|,
name|double
name|green_x
operator|,
name|double
name|green_y
operator|,
name|double
name|blue_x
operator|,
name|double
name|blue_y
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|136
argument_list|,
name|void
argument_list|,
name|png_set_cHRM_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_fixed_point
name|int_white_x
operator|,
name|png_fixed_point
name|int_white_y
operator|,
name|png_fixed_point
name|int_red_x
operator|,
name|png_fixed_point
name|int_red_y
operator|,
name|png_fixed_point
name|int_green_x
operator|,
name|png_fixed_point
name|int_green_y
operator|,
name|png_fixed_point
name|int_blue_x
operator|,
name|png_fixed_point
name|int_blue_y
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|137
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_gAMA
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|double
operator|*
name|file_gamma
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|138
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_gAMA_fixed
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_fixed_point
operator|*
name|int_file_gamma
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|139
argument_list|,
name|void
argument_list|,
name|png_set_gAMA
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|double
name|file_gamma
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|140
argument_list|,
name|void
argument_list|,
name|png_set_gAMA_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_fixed_point
name|int_file_gamma
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|141
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_hIST
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_uint_16p
operator|*
name|hist
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|142
argument_list|,
name|void
argument_list|,
name|png_set_hIST
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_uint_16p
name|hist
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|143
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_IHDR
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_uint_32
operator|*
name|width
operator|,
name|png_uint_32
operator|*
name|height
operator|,
name|int
operator|*
name|bit_depth
operator|,
name|int
operator|*
name|color_type
operator|,
name|int
operator|*
name|interlace_method
operator|,
name|int
operator|*
name|compression_method
operator|,
name|int
operator|*
name|filter_method
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|144
argument_list|,
name|void
argument_list|,
name|png_set_IHDR
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_uint_32
name|width
operator|,
name|png_uint_32
name|height
operator|,
name|int
name|bit_depth
operator|,
name|int
name|color_type
operator|,
name|int
name|interlace_method
operator|,
name|int
name|compression_method
operator|,
name|int
name|filter_method
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_oFFs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|145
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_oFFs
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_int_32
operator|*
name|offset_x
operator|,
name|png_int_32
operator|*
name|offset_y
operator|,
name|int
operator|*
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_oFFs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|146
argument_list|,
name|void
argument_list|,
name|png_set_oFFs
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_int_32
name|offset_x
operator|,
name|png_int_32
name|offset_y
operator|,
name|int
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|147
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pCAL
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_charp
operator|*
name|purpose
operator|,
name|png_int_32
operator|*
name|X0
operator|,
name|png_int_32
operator|*
name|X1
operator|,
name|int
operator|*
name|type
operator|,
name|int
operator|*
name|nparams
operator|,
name|png_charp
operator|*
name|units
operator|,
name|png_charpp
operator|*
name|params
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|148
argument_list|,
name|void
argument_list|,
name|png_set_pCAL
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_charp
name|purpose
operator|,
name|png_int_32
name|X0
operator|,
name|png_int_32
name|X1
operator|,
name|int
name|type
operator|,
name|int
name|nparams
operator|,
name|png_const_charp
name|units
operator|,
name|png_charpp
name|params
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|149
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pHYs
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_uint_32
operator|*
name|res_x
operator|,
name|png_uint_32
operator|*
name|res_y
operator|,
name|int
operator|*
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|150
argument_list|,
name|void
argument_list|,
name|png_set_pHYs
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_uint_32
name|res_x
operator|,
name|png_uint_32
name|res_y
operator|,
name|int
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|151
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_PLTE
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_colorp
operator|*
name|palette
operator|,
name|int
operator|*
name|num_palette
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|152
argument_list|,
name|void
argument_list|,
name|png_set_PLTE
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_colorp
name|palette
operator|,
name|int
name|num_palette
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_sBIT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|153
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sBIT
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_color_8p
operator|*
name|sig_bit
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sBIT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|154
argument_list|,
name|void
argument_list|,
name|png_set_sBIT
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_color_8p
name|sig_bit
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|155
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sRGB
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|int
operator|*
name|file_srgb_intent
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|156
argument_list|,
name|void
argument_list|,
name|png_set_sRGB
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|srgb_intent
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|157
argument_list|,
name|void
argument_list|,
name|png_set_sRGB_gAMA_and_cHRM
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|srgb_intent
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|158
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_iCCP
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_charpp
name|name
operator|,
name|int
operator|*
name|compression_type
operator|,
name|png_bytepp
name|profile
operator|,
name|png_uint_32
operator|*
name|proflen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|159
argument_list|,
name|void
argument_list|,
name|png_set_iCCP
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_charp
name|name
operator|,
name|int
name|compression_type
operator|,
name|png_const_bytep
name|profile
operator|,
name|png_uint_32
name|proflen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|160
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sPLT
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_sPLT_tpp
name|entries
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|161
argument_list|,
name|void
argument_list|,
name|png_set_sPLT
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_sPLT_tp
name|entries
operator|,
name|int
name|nentries
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* png_get_text also returns the number of text chunks in *num_text */
name|PNG_EXPORT
argument_list|(
literal|162
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_text
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_textp
operator|*
name|text_ptr
operator|,
name|int
operator|*
name|num_text
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note while png_set_text() will accept a structure whose text,   * language, and  translated keywords are NULL pointers, the structure  * returned by png_get_text will always contain regular  * zero-terminated C strings.  They might be empty strings but  * they will never be NULL pointers.  */
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|163
argument_list|,
name|void
argument_list|,
name|png_set_text
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_textp
name|text_ptr
operator|,
name|int
name|num_text
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|164
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_tIME
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_timep
operator|*
name|mod_time
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|165
argument_list|,
name|void
argument_list|,
name|png_set_tIME
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_timep
name|mod_time
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|166
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_tRNS
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_bytep
operator|*
name|trans_alpha
operator|,
name|int
operator|*
name|num_trans
operator|,
name|png_color_16p
operator|*
name|trans_color
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|167
argument_list|,
name|void
argument_list|,
name|png_set_tRNS
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_bytep
name|trans_alpha
operator|,
name|int
name|num_trans
operator|,
name|png_const_color_16p
name|trans_color
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|168
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sCAL
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|int
operator|*
name|unit
operator|,
name|double
operator|*
name|width
operator|,
name|double
operator|*
name|height
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
comment|/* NOTE: this API is currently implemented using floating point arithmetic,   * consequently it can only be used on systems with floating point support.  * In any case the range of values supported by png_fixed_point is small and it  * is highly recommended that png_get_sCAL_s be used instead.  */
name|PNG_FIXED_EXPORT
argument_list|(
literal|214
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sCAL_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|int
operator|*
name|unit
operator|,
name|png_fixed_point
operator|*
name|width
operator|,
name|png_fixed_point
operator|*
name|height
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|169
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sCAL_s
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|int
operator|*
name|unit
operator|,
name|png_charpp
name|swidth
operator|,
name|png_charpp
name|sheight
operator|)
argument_list|)
expr_stmt|;
name|PNG_FP_EXPORT
argument_list|(
literal|170
argument_list|,
name|void
argument_list|,
name|png_set_sCAL
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|unit
operator|,
name|double
name|width
operator|,
name|double
name|height
operator|)
argument_list|)
expr_stmt|;
name|PNG_FIXED_EXPORT
argument_list|(
literal|213
argument_list|,
name|void
argument_list|,
name|png_set_sCAL_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|unit
operator|,
name|png_fixed_point
name|width
operator|,
name|png_fixed_point
name|height
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|171
argument_list|,
name|void
argument_list|,
name|png_set_sCAL_s
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|unit
operator|,
name|png_const_charp
name|swidth
operator|,
name|png_const_charp
name|sheight
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_sCAL_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
comment|/* Provide a list of chunks and how they are to be handled, if the built-in    handling or default unknown chunk handling is not desired.  Any chunks not    listed will be handled in the default manner.  The IHDR and IEND chunks    must not be listed.       keep = 0: follow default behaviour            = 1: do not keep            = 2: keep only if safe-to-copy            = 3: keep even if unsafe-to-copy */
name|PNG_EXPORT
argument_list|(
literal|172
argument_list|,
name|void
argument_list|,
name|png_set_keep_unknown_chunks
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|int
name|keep
operator|,
name|png_const_bytep
name|chunk_list
operator|,
name|int
name|num_chunks
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|173
argument_list|,
name|int
argument_list|,
name|png_handle_as_unknown
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_bytep
name|chunk_name
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|174
argument_list|,
name|void
argument_list|,
name|png_set_unknown_chunks
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|png_const_unknown_chunkp
name|unknowns
operator|,
name|int
name|num_unknowns
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|175
argument_list|,
name|void
argument_list|,
name|png_set_unknown_chunk_location
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|chunk
operator|,
name|int
name|location
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|176
argument_list|,
name|int
argument_list|,
name|png_get_unknown_chunks
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_unknown_chunkpp
name|entries
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Png_free_data() will turn off the "valid" flag for anything it frees.  * If you need to turn it off for a chunk that your application has freed,   * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);  */
name|PNG_EXPORT
argument_list|(
literal|177
argument_list|,
name|void
argument_list|,
name|png_set_invalid
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|mask
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
comment|/* The "params" pointer is currently not used and is for future expansion. */
name|PNG_EXPORT
argument_list|(
literal|178
argument_list|,
name|void
argument_list|,
name|png_read_png
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|transforms
operator|,
name|png_voidp
name|params
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|179
argument_list|,
name|void
argument_list|,
name|png_write_png
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_infop
name|info_ptr
operator|,
name|int
name|transforms
operator|,
name|png_voidp
name|params
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|180
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_copyright
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|181
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_header_ver
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|182
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_header_version
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|183
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_libpng_ver
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|184
argument_list|,
name|png_uint_32
argument_list|,
name|png_permit_mng_features
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_uint_32
name|mng_features_permitted
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* For use in png_set_keep_unknown, added to version 1.2.6 */
DECL|macro|PNG_HANDLE_CHUNK_AS_DEFAULT
define|#
directive|define
name|PNG_HANDLE_CHUNK_AS_DEFAULT
value|0
DECL|macro|PNG_HANDLE_CHUNK_NEVER
define|#
directive|define
name|PNG_HANDLE_CHUNK_NEVER
value|1
DECL|macro|PNG_HANDLE_CHUNK_IF_SAFE
define|#
directive|define
name|PNG_HANDLE_CHUNK_IF_SAFE
value|2
DECL|macro|PNG_HANDLE_CHUNK_ALWAYS
define|#
directive|define
name|PNG_HANDLE_CHUNK_ALWAYS
value|3
comment|/* Strip the prepended error numbers ("#nnn ") from error and warning  * messages before passing them to the error or warning handler.  */
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|185
argument_list|,
name|void
argument_list|,
name|png_set_strip_error_numbers
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_uint_32
name|strip_mode
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added in libpng-1.2.6 */
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|186
argument_list|,
name|void
argument_list|,
name|png_set_user_limits
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_uint_32
name|user_width_max
operator|,
name|png_uint_32
name|user_height_max
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|187
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_user_width_max
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|188
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_user_height_max
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Added in libpng-1.4.0 */
name|PNG_EXPORT
argument_list|(
literal|189
argument_list|,
name|void
argument_list|,
name|png_set_chunk_cache_max
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_uint_32
name|user_chunk_cache_max
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|190
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_chunk_cache_max
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Added in libpng-1.4.1 */
name|PNG_EXPORT
argument_list|(
literal|191
argument_list|,
name|void
argument_list|,
name|png_set_chunk_malloc_max
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_alloc_size_t
name|user_chunk_cache_max
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|192
argument_list|,
name|png_alloc_size_t
argument_list|,
name|png_get_chunk_malloc_max
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|193
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pixels_per_inch
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|194
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_x_pixels_per_inch
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|195
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_y_pixels_per_inch
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_FP_EXPORT
argument_list|(
literal|196
argument_list|,
name|float
argument_list|,
name|png_get_x_offset_inches
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
comment|/* otherwise not implemented. */
name|PNG_FIXED_EXPORT
argument_list|(
literal|211
argument_list|,
name|png_fixed_point
argument_list|,
name|png_get_x_offset_inches_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_FP_EXPORT
argument_list|(
literal|197
argument_list|,
name|float
argument_list|,
name|png_get_y_offset_inches
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
comment|/* otherwise not implemented. */
name|PNG_FIXED_EXPORT
argument_list|(
literal|212
argument_list|,
name|png_fixed_point
argument_list|,
name|png_get_y_offset_inches_fixed
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|198
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pHYs_dpi
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|,
name|png_uint_32
operator|*
name|res_x
operator|,
name|png_uint_32
operator|*
name|res_y
operator|,
name|int
operator|*
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_pHYs_SUPPORTED */
endif|#
directive|endif
comment|/* PNG_INCH_CONVERSIONS_SUPPORTED */
comment|/* Added in libpng-1.4.0 */
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|199
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_io_state
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORTA
argument_list|(
literal|200
argument_list|,
name|png_const_bytep
argument_list|,
name|png_get_io_chunk_name
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|)
argument_list|,
name|PNG_DEPRECATED
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|216
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_io_chunk_type
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* The flags returned by png_get_io_state() are the following: */
DECL|macro|PNG_IO_NONE
define|#
directive|define
name|PNG_IO_NONE
value|0x0000
comment|/* no I/O at this moment */
DECL|macro|PNG_IO_READING
define|#
directive|define
name|PNG_IO_READING
value|0x0001
comment|/* currently reading */
DECL|macro|PNG_IO_WRITING
define|#
directive|define
name|PNG_IO_WRITING
value|0x0002
comment|/* currently writing */
DECL|macro|PNG_IO_SIGNATURE
define|#
directive|define
name|PNG_IO_SIGNATURE
value|0x0010
comment|/* currently at the file signature */
DECL|macro|PNG_IO_CHUNK_HDR
define|#
directive|define
name|PNG_IO_CHUNK_HDR
value|0x0020
comment|/* currently at the chunk header */
DECL|macro|PNG_IO_CHUNK_DATA
define|#
directive|define
name|PNG_IO_CHUNK_DATA
value|0x0040
comment|/* currently at the chunk data */
DECL|macro|PNG_IO_CHUNK_CRC
define|#
directive|define
name|PNG_IO_CHUNK_CRC
value|0x0080
comment|/* currently at the chunk crc */
DECL|macro|PNG_IO_MASK_OP
define|#
directive|define
name|PNG_IO_MASK_OP
value|0x000f
comment|/* current operation: reading/writing */
DECL|macro|PNG_IO_MASK_LOC
define|#
directive|define
name|PNG_IO_MASK_LOC
value|0x00f0
comment|/* current location: sig/hdr/data/crc */
endif|#
directive|endif
comment|/* ?PNG_IO_STATE_SUPPORTED */
comment|/* Interlace support.  The following macros are always defined so that if  * libpng interlace handling is turned off the macros may be used to handle  * interlaced images within the application.  */
DECL|macro|PNG_INTERLACE_ADAM7_PASSES
define|#
directive|define
name|PNG_INTERLACE_ADAM7_PASSES
value|7
comment|/* Two macros to return the first row and first column of the original,  * full, image which appears in a given pass.  'pass' is in the range 0  * to 6 and the result is in the range 0 to 7.  */
DECL|macro|PNG_PASS_START_ROW
define|#
directive|define
name|PNG_PASS_START_ROW
parameter_list|(
name|pass
parameter_list|)
value|(((1U&~(pass))<<(3-((pass)>>1)))&7)
DECL|macro|PNG_PASS_START_COL
define|#
directive|define
name|PNG_PASS_START_COL
parameter_list|(
name|pass
parameter_list|)
value|(((1U& (pass))<<(3-(((pass)+1)>>1)))&7)
comment|/* Two macros to help evaluate the number of rows or columns in each  * pass.  This is expressed as a shift - effectively log2 of the number or  * rows or columns in each 8x8 tile of the original image.  */
DECL|macro|PNG_PASS_ROW_SHIFT
define|#
directive|define
name|PNG_PASS_ROW_SHIFT
parameter_list|(
name|pass
parameter_list|)
value|((pass)>2?(8-(pass))>>1:3)
DECL|macro|PNG_PASS_COL_SHIFT
define|#
directive|define
name|PNG_PASS_COL_SHIFT
parameter_list|(
name|pass
parameter_list|)
value|((pass)>1?(7-(pass))>>1:3)
comment|/* Hence two macros to determine the number of rows or columns in a given  * pass of an image given its height or width.  In fact these macros may  * return non-zero even though the sub-image is empty, because the other  * dimension may be empty for a small image.  */
DECL|macro|PNG_PASS_ROWS
define|#
directive|define
name|PNG_PASS_ROWS
parameter_list|(
name|height
parameter_list|,
name|pass
parameter_list|)
value|(((height)+(((1<<PNG_PASS_ROW_SHIFT(pass))\    -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))
DECL|macro|PNG_PASS_COLS
define|#
directive|define
name|PNG_PASS_COLS
parameter_list|(
name|width
parameter_list|,
name|pass
parameter_list|)
value|(((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\    -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))
comment|/* For the progressive reader it is necessary to find the row in the output  * image given a row in an interlaced image, so two more macros:  */
DECL|macro|PNG_ROW_FROM_PASS_ROW
define|#
directive|define
name|PNG_ROW_FROM_PASS_ROW
parameter_list|(
name|yIn
parameter_list|,
name|pass
parameter_list|)
define|\
value|(((yIn)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
DECL|macro|PNG_COL_FROM_PASS_COL
define|#
directive|define
name|PNG_COL_FROM_PASS_COL
parameter_list|(
name|xIn
parameter_list|,
name|pass
parameter_list|)
define|\
value|(((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
comment|/* Two macros which return a boolean (0 or 1) saying whether the given row  * or column is in a particular pass.  These use a common utility macro that  * returns a mask for a given pass - the offset 'off' selects the row or  * column version.  The mask has the appropriate bit set for each column in  * the tile.  */
DECL|macro|PNG_PASS_MASK
define|#
directive|define
name|PNG_PASS_MASK
parameter_list|(
name|pass
parameter_list|,
name|off
parameter_list|)
value|( \    ((0x110145AFU>>(((7-(off))-(pass))<<2))& 0xFU) | \    ((0x01145AF0U>>(((7-(off))-(pass))<<2))& 0xF0U))
DECL|macro|PNG_ROW_IN_INTERLACE_PASS
define|#
directive|define
name|PNG_ROW_IN_INTERLACE_PASS
parameter_list|(
name|y
parameter_list|,
name|pass
parameter_list|)
define|\
value|((PNG_PASS_MASK(pass,0)>> ((y)&7))& 1)
DECL|macro|PNG_COL_IN_INTERLACE_PASS
define|#
directive|define
name|PNG_COL_IN_INTERLACE_PASS
parameter_list|(
name|x
parameter_list|,
name|pass
parameter_list|)
define|\
value|((PNG_PASS_MASK(pass,1)>> ((x)&7))& 1)
ifdef|#
directive|ifdef
name|PNG_READ_COMPOSITE_NODIV_SUPPORTED
comment|/* With these routines we avoid an integer divide, which will be slower on  * most machines.  However, it does take more operations than the corresponding  * divide method, so it may be slower on a few RISC systems.  There are two  * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.  *  * Note that the rounding factors are NOT supposed to be the same!  128 and  * 32768 are correct for the NODIV code; 127 and 32767 are correct for the  * standard method.  *  * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]  */
comment|/* fg and bg should be in `gamma 1.0' space; alpha is the opacity */
DECL|macro|png_composite
define|#
directive|define
name|png_composite
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|{ png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \            * (png_uint_16)(alpha)                         \            + (png_uint_16)(bg)*(png_uint_16)(255          \            - (png_uint_16)(alpha)) + (png_uint_16)128);   \        (composite) = (png_byte)((temp + (temp>> 8))>> 8); }
DECL|macro|png_composite_16
define|#
directive|define
name|png_composite_16
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|{ png_uint_32 temp = (png_uint_32)((png_uint_32)(fg)  \            * (png_uint_32)(alpha)                          \            + (png_uint_32)(bg)*(png_uint_32)(65535L        \            - (png_uint_32)(alpha)) + (png_uint_32)32768L); \        (composite) = (png_uint_16)((temp + (temp>> 16))>> 16); }
else|#
directive|else
comment|/* Standard method using integer division */
DECL|macro|png_composite
define|#
directive|define
name|png_composite
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|(composite) = (png_byte)(((png_uint_16)(fg) * (png_uint_16)(alpha) +  \      (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) +       \      (png_uint_16)127) / 255)
DECL|macro|png_composite_16
define|#
directive|define
name|png_composite_16
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|(composite) = (png_uint_16)(((png_uint_32)(fg) * (png_uint_32)(alpha) + \      (png_uint_32)(bg)*(png_uint_32)(65535L - (png_uint_32)(alpha)) +        \      (png_uint_32)32767) / (png_uint_32)65535L)
endif|#
directive|endif
comment|/* PNG_READ_COMPOSITE_NODIV_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_READ_INT_FUNCTIONS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|201
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_uint_32
argument_list|,
operator|(
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|202
argument_list|,
name|png_uint_16
argument_list|,
name|png_get_uint_16
argument_list|,
operator|(
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|203
argument_list|,
name|png_int_32
argument_list|,
name|png_get_int_32
argument_list|,
operator|(
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|204
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_uint_31
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
comment|/* No png_get_int_16 -- may be added if there's a real need for it. */
comment|/* Place a 32-bit number into a buffer in PNG byte order (big-endian). */
ifdef|#
directive|ifdef
name|PNG_WRITE_INT_FUNCTIONS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|205
argument_list|,
name|void
argument_list|,
name|png_save_uint_32
argument_list|,
operator|(
name|png_bytep
name|buf
operator|,
name|png_uint_32
name|i
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SAVE_INT_32_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|206
argument_list|,
name|void
argument_list|,
name|png_save_int_32
argument_list|,
operator|(
name|png_bytep
name|buf
operator|,
name|png_int_32
name|i
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Place a 16-bit number into a buffer in PNG byte order.  * The parameter is declared unsigned int, not png_uint_16,   * just to avoid potential problems on pre-ANSI C compilers.  */
ifdef|#
directive|ifdef
name|PNG_WRITE_INT_FUNCTIONS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|207
argument_list|,
name|void
argument_list|,
name|png_save_uint_16
argument_list|,
operator|(
name|png_bytep
name|buf
operator|,
name|unsigned
name|int
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* No png_save_int_16 -- may be added if there's a real need for it. */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USE_READ_MACROS
comment|/* Inline macros to do direct reads of bytes from the input buffer.  * The png_get_int_32() routine assumes we are using two's complement  * format for negative values, which is almost certainly true.  */
DECL|macro|png_get_uint_32
define|#
directive|define
name|png_get_uint_32
parameter_list|(
name|buf
parameter_list|)
define|\
value|(((png_uint_32)(*(buf))<< 24) + \       ((png_uint_32)(*((buf) + 1))<< 16) + \       ((png_uint_32)(*((buf) + 2))<< 8) + \       ((png_uint_32)(*((buf) + 3))))
comment|/* From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the     * function) incorrectly returned a value of type png_uint_32.     */
DECL|macro|png_get_uint_16
define|#
directive|define
name|png_get_uint_16
parameter_list|(
name|buf
parameter_list|)
define|\
value|((png_uint_16) \       (((unsigned int)(*(buf))<< 8) + \        ((unsigned int)(*((buf) + 1)))))
DECL|macro|png_get_int_32
define|#
directive|define
name|png_get_int_32
parameter_list|(
name|buf
parameter_list|)
define|\
value|((png_int_32)((*(buf)& 0x80) \       ? -((png_int_32)((png_get_uint_32(buf) ^ 0xffffffffL) + 1)) \       : (png_int_32)png_get_uint_32(buf)))
endif|#
directive|endif
comment|/* Maintainer: Put new public prototypes here ^, in libpng.3, and project  * defs  */
comment|/* The last ordinal number (this is the *last* one already used; the next  * one to use is one more than this.)  Maintainer, remember to add an entry to  * scripts/symbols.def as well.  */
ifdef|#
directive|ifdef
name|PNG_EXPORT_LAST_ORDINAL
name|PNG_EXPORT_LAST_ORDINAL
argument_list|(
literal|220
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_VERSION_INFO_ONLY */
end_comment
begin_comment
comment|/* Do not put anything past this line */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_H */
end_comment
end_unit
