begin_unit
begin_comment
comment|/* png.h - header file for PNG reference library  *  * libpng version 1.6.17, March 26, 2015  *  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license (See LICENSE, below)  *  * Authors and maintainers:  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat  *   libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger  *   libpng versions 0.97, January 1998, through 1.6.17, March 26, 2015: Glenn  *   See also "Contributing Authors", below.  *  * Note about libpng version numbers:  *  *   Due to various miscommunications, unforeseen code incompatibilities  *   and occasional factors outside the authors' control, version numbering  *   on the library has not always been consistent and straightforward.  *   The following table summarizes matters since version 0.89c, which was  *   the first widely used release:  *  *    source                 png.h  png.h  shared-lib  *    version                string   int  version  *    -------                ------ -----  ----------  *    0.89c "1.0 beta 3"     0.89      89  1.0.89  *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]  *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]  *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]  *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]  *    0.97c                  0.97      97  2.0.97  *    0.98                   0.98      98  2.0.98  *    0.99                   0.99      98  2.0.99  *    0.99a-m                0.99      99  2.0.99  *    1.00                   1.00     100  2.1.0 [100 should be 10000]  *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]  *    1.0.1       png.h string is   10001  2.1.0  *    1.0.1a-e    identical to the  10002  from here on, the shared library  *    1.0.2       source version)   10002  is 2.V where V is the source code  *    1.0.2a-b                      10003  version, except as noted.  *    1.0.3                         10003  *    1.0.3a-d                      10004  *    1.0.4                         10004  *    1.0.4a-f                      10005  *    1.0.5 (+ 2 patches)           10005  *    1.0.5a-d                      10006  *    1.0.5e-r                      10100 (not source compatible)  *    1.0.5s-v                      10006 (not binary compatible)  *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)  *    1.0.6d-f                      10007 (still binary incompatible)  *    1.0.6g                        10007  *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)  *    1.0.6i                        10007  10.6i  *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)  *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)  *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)  *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)  *    1.0.7                    1    10007  (still compatible)  *    1.0.8beta1-4             1    10008  2.1.0.8beta1-4  *    1.0.8rc1                 1    10008  2.1.0.8rc1  *    1.0.8                    1    10008  2.1.0.8  *    1.0.9beta1-6             1    10009  2.1.0.9beta1-6  *    1.0.9rc1                 1    10009  2.1.0.9rc1  *    1.0.9beta7-10            1    10009  2.1.0.9beta7-10  *    1.0.9rc2                 1    10009  2.1.0.9rc2  *    1.0.9                    1    10009  2.1.0.9  *    1.0.10beta1              1    10010  2.1.0.10beta1  *    1.0.10rc1                1    10010  2.1.0.10rc1  *    1.0.10                   1    10010  2.1.0.10  *    1.0.11beta1-3            1    10011  2.1.0.11beta1-3  *    1.0.11rc1                1    10011  2.1.0.11rc1  *    1.0.11                   1    10011  2.1.0.11  *    1.0.12beta1-2            2    10012  2.1.0.12beta1-2  *    1.0.12rc1                2    10012  2.1.0.12rc1  *    1.0.12                   2    10012  2.1.0.12  *    1.1.0a-f                 -    10100  2.1.1.0a-f (branch abandoned)  *    1.2.0beta1-2             2    10200  2.1.2.0beta1-2  *    1.2.0beta3-5             3    10200  3.1.2.0beta3-5  *    1.2.0rc1                 3    10200  3.1.2.0rc1  *    1.2.0                    3    10200  3.1.2.0  *    1.2.1beta1-4             3    10201  3.1.2.1beta1-4  *    1.2.1rc1-2               3    10201  3.1.2.1rc1-2  *    1.2.1                    3    10201  3.1.2.1  *    1.2.2beta1-6            12    10202  12.so.0.1.2.2beta1-6  *    1.0.13beta1             10    10013  10.so.0.1.0.13beta1  *    1.0.13rc1               10    10013  10.so.0.1.0.13rc1  *    1.2.2rc1                12    10202  12.so.0.1.2.2rc1  *    1.0.13                  10    10013  10.so.0.1.0.13  *    1.2.2                   12    10202  12.so.0.1.2.2  *    1.2.3rc1-6              12    10203  12.so.0.1.2.3rc1-6  *    1.2.3                   12    10203  12.so.0.1.2.3  *    1.2.4beta1-3            13    10204  12.so.0.1.2.4beta1-3  *    1.0.14rc1               13    10014  10.so.0.1.0.14rc1  *    1.2.4rc1                13    10204  12.so.0.1.2.4rc1  *    1.0.14                  10    10014  10.so.0.1.0.14  *    1.2.4                   13    10204  12.so.0.1.2.4  *    1.2.5beta1-2            13    10205  12.so.0.1.2.5beta1-2  *    1.0.15rc1-3             10    10015  10.so.0.1.0.15rc1-3  *    1.2.5rc1-3              13    10205  12.so.0.1.2.5rc1-3  *    1.0.15                  10    10015  10.so.0.1.0.15  *    1.2.5                   13    10205  12.so.0.1.2.5  *    1.2.6beta1-4            13    10206  12.so.0.1.2.6beta1-4  *    1.0.16                  10    10016  10.so.0.1.0.16  *    1.2.6                   13    10206  12.so.0.1.2.6  *    1.2.7beta1-2            13    10207  12.so.0.1.2.7beta1-2  *    1.0.17rc1               10    10017  12.so.0.1.0.17rc1  *    1.2.7rc1                13    10207  12.so.0.1.2.7rc1  *    1.0.17                  10    10017  12.so.0.1.0.17  *    1.2.7                   13    10207  12.so.0.1.2.7  *    1.2.8beta1-5            13    10208  12.so.0.1.2.8beta1-5  *    1.0.18rc1-5             10    10018  12.so.0.1.0.18rc1-5  *    1.2.8rc1-5              13    10208  12.so.0.1.2.8rc1-5  *    1.0.18                  10    10018  12.so.0.1.0.18  *    1.2.8                   13    10208  12.so.0.1.2.8  *    1.2.9beta1-3            13    10209  12.so.0.1.2.9beta1-3  *    1.2.9beta4-11           13    10209  12.so.0.9[.0]  *    1.2.9rc1                13    10209  12.so.0.9[.0]  *    1.2.9                   13    10209  12.so.0.9[.0]  *    1.2.10beta1-7           13    10210  12.so.0.10[.0]  *    1.2.10rc1-2             13    10210  12.so.0.10[.0]  *    1.2.10                  13    10210  12.so.0.10[.0]  *    1.4.0beta1-5            14    10400  14.so.0.0[.0]  *    1.2.11beta1-4           13    10211  12.so.0.11[.0]  *    1.4.0beta7-8            14    10400  14.so.0.0[.0]  *    1.2.11                  13    10211  12.so.0.11[.0]  *    1.2.12                  13    10212  12.so.0.12[.0]  *    1.4.0beta9-14           14    10400  14.so.0.0[.0]  *    1.2.13                  13    10213  12.so.0.13[.0]  *    1.4.0beta15-36          14    10400  14.so.0.0[.0]  *    1.4.0beta37-87          14    10400  14.so.14.0[.0]  *    1.4.0rc01               14    10400  14.so.14.0[.0]  *    1.4.0beta88-109         14    10400  14.so.14.0[.0]  *    1.4.0rc02-08            14    10400  14.so.14.0[.0]  *    1.4.0                   14    10400  14.so.14.0[.0]  *    1.4.1beta01-03          14    10401  14.so.14.1[.0]  *    1.4.1rc01               14    10401  14.so.14.1[.0]  *    1.4.1beta04-12          14    10401  14.so.14.1[.0]  *    1.4.1                   14    10401  14.so.14.1[.0]  *    1.4.2                   14    10402  14.so.14.2[.0]  *    1.4.3                   14    10403  14.so.14.3[.0]  *    1.4.4                   14    10404  14.so.14.4[.0]  *    1.5.0beta01-58          15    10500  15.so.15.0[.0]  *    1.5.0rc01-07            15    10500  15.so.15.0[.0]  *    1.5.0                   15    10500  15.so.15.0[.0]  *    1.5.1beta01-11          15    10501  15.so.15.1[.0]  *    1.5.1rc01-02            15    10501  15.so.15.1[.0]  *    1.5.1                   15    10501  15.so.15.1[.0]  *    1.5.2beta01-03          15    10502  15.so.15.2[.0]  *    1.5.2rc01-03            15    10502  15.so.15.2[.0]  *    1.5.2                   15    10502  15.so.15.2[.0]  *    1.5.3beta01-10          15    10503  15.so.15.3[.0]  *    1.5.3rc01-02            15    10503  15.so.15.3[.0]  *    1.5.3beta11             15    10503  15.so.15.3[.0]  *    1.5.3 [omitted]  *    1.5.4beta01-08          15    10504  15.so.15.4[.0]  *    1.5.4rc01               15    10504  15.so.15.4[.0]  *    1.5.4                   15    10504  15.so.15.4[.0]  *    1.5.5beta01-08          15    10505  15.so.15.5[.0]  *    1.5.5rc01               15    10505  15.so.15.5[.0]  *    1.5.5                   15    10505  15.so.15.5[.0]  *    1.5.6beta01-07          15    10506  15.so.15.6[.0]  *    1.5.6rc01-03            15    10506  15.so.15.6[.0]  *    1.5.6                   15    10506  15.so.15.6[.0]  *    1.5.7beta01-05          15    10507  15.so.15.7[.0]  *    1.5.7rc01-03            15    10507  15.so.15.7[.0]  *    1.5.7                   15    10507  15.so.15.7[.0]  *    1.6.0beta01-40          16    10600  16.so.16.0[.0]  *    1.6.0rc01-08            16    10600  16.so.16.0[.0]  *    1.6.0                   16    10600  16.so.16.0[.0]  *    1.6.1beta01-09          16    10601  16.so.16.1[.0]  *    1.6.1rc01               16    10601  16.so.16.1[.0]  *    1.6.1                   16    10601  16.so.16.1[.0]  *    1.6.2beta01             16    10602  16.so.16.2[.0]  *    1.6.2rc01-06            16    10602  16.so.16.2[.0]  *    1.6.2                   16    10602  16.so.16.2[.0]  *    1.6.3beta01-11          16    10603  16.so.16.3[.0]  *    1.6.3rc01               16    10603  16.so.16.3[.0]  *    1.6.3                   16    10603  16.so.16.3[.0]  *    1.6.4beta01-02          16    10604  16.so.16.4[.0]  *    1.6.4rc01               16    10604  16.so.16.4[.0]  *    1.6.4                   16    10604  16.so.16.4[.0]  *    1.6.5                   16    10605  16.so.16.5[.0]  *    1.6.6                   16    10606  16.so.16.6[.0]  *    1.6.7beta01-04          16    10607  16.so.16.7[.0]  *    1.6.7rc01-03            16    10607  16.so.16.7[.0]  *    1.6.7                   16    10607  16.so.16.7[.0]  *    1.6.8beta01-02          16    10608  16.so.16.8[.0]  *    1.6.8rc01-02            16    10608  16.so.16.8[.0]  *    1.6.8                   16    10608  16.so.16.8[.0]  *    1.6.9beta01-04          16    10609  16.so.16.9[.0]  *    1.6.9rc01-02            16    10609  16.so.16.9[.0]  *    1.6.9                   16    10609  16.so.16.9[.0]  *    1.6.10beta01-03         16    10610  16.so.16.10[.0]  *    1.6.10rc01-03           16    10610  16.so.16.10[.0]  *    1.6.10                  16    10610  16.so.16.10[.0]  *    1.6.11beta01-06         16    10611  16.so.16.11[.0]  *    1.6.11rc01-02           16    10611  16.so.16.11[.0]  *    1.6.11                  16    10611  16.so.16.11[.0]  *    1.6.12rc01-03           16    10612  16.so.16.12[.0]  *    1.6.12                  16    10612  16.so.16.12[.0]  *    1.6.13beta01-04         16    10613  16.so.16.13[.0]  *    1.6.13rc01-02           16    10613  16.so.16.13[.0]  *    1.6.13                  16    10613  16.so.16.13[.0]  *    1.6.14beta01-07         16    10614  16.so.16.14[.0]  *    1.6.14rc01-02           16    10614  16.so.16.14[.0]  *    1.6.14                  16    10614  16.so.16.14[.0]  *    1.6.15beta01-08         16    10615  16.so.16.15[.0]  *    1.6.15rc01-03           16    10615  16.so.16.15[.0]  *    1.6.15                  16    10615  16.so.16.15[.0]  *    1.6.16beta01-03         16    10616  16.so.16.16[.0]  *    1.6.16rc01-02           16    10616  16.so.16.16[.0]  *    1.6.16                  16    10616  16.so.16.16[.0]  *    1.6.17beta01-06         16    10617  16.so.16.17[.0]  *    1.6.17rc01-06           16    10617  16.so.16.17[.0]  *    1.6.17                  16    10617  16.so.16.17[.0]  *  *   Henceforth the source version will match the shared-library major  *   and minor numbers; the shared-library major version number will be  *   used for changes in backward compatibility, as it is intended.  The  *   PNG_LIBPNG_VER macro, which is not used within libpng but is available  *   for applications, is an unsigned integer of the form xyyzz corresponding  *   to the source version x.y.z (leading zeros in y and z).  Beta versions  *   were given the previous public release number plus a letter, until  *   version 1.0.6j; from then on they were given the upcoming public  *   release number plus "betaNN" or "rcNN".  *  *   Binary incompatibility exists only when applications make direct access  *   to the info_ptr or png_ptr members through png.h, and the compiled  *   application is loaded with a different version of the library.  *  *   DLLNUM will change each time there are forward or backward changes  *   in binary compatibility (e.g., when a new feature is added).  *  * See libpng-manual.txt or libpng.3 for more information.  The PNG  * specification is available as a W3C Recommendation and as an ISO  * Specification,<http://www.w3.org/TR/2003/REC-PNG-20031110/  */
end_comment
begin_comment
comment|/*  * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:  *  * If you modify libpng you may insert additional notices immediately following  * this sentence.  *  * This code is released under the libpng license.  *  * libpng versions 1.2.6, August 15, 2004, through 1.6.17, March 26, 2015, are  * Copyright (c) 2004, 2006-2015 Glenn Randers-Pehrson, and are  * distributed according to the same disclaimer and license as libpng-1.2.5  * with the following individual added to the list of Contributing Authors:  *  *    Cosmin Truta  *  * libpng versions 1.0.7, July 1, 2000, through 1.2.5, October 3, 2002, are  * Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are  * distributed according to the same disclaimer and license as libpng-1.0.6  * with the following individuals added to the list of Contributing Authors:  *  *    Simon-Pierre Cadieux  *    Eric S. Raymond  *    Gilles Vollant  *  * and with the following additions to the disclaimer:  *  *    There is no warranty against interference with your enjoyment of the  *    library or against infringement.  There is no warranty that our  *    efforts or the library will fulfill any of your particular purposes  *    or needs.  This library is provided with all faults, and the entire  *    risk of satisfactory quality, performance, accuracy, and effort is with  *    the user.  *  * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are  * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson, and are  * distributed according to the same disclaimer and license as libpng-0.96,  * with the following individuals added to the list of Contributing Authors:  *  *    Tom Lane  *    Glenn Randers-Pehrson  *    Willem van Schaik  *  * libpng versions 0.89, June 1996, through 0.96, May 1997, are  * Copyright (c) 1996, 1997 Andreas Dilger  * Distributed according to the same disclaimer and license as libpng-0.88,  * with the following individuals added to the list of Contributing Authors:  *  *    John Bowler  *    Kevin Bracey  *    Sam Bushell  *    Magnus Holmgren  *    Greg Roelofs  *    Tom Tanner  *  * libpng versions 0.5, May 1995, through 0.88, January 1996, are  * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.  *  * For the purposes of this copyright and license, "Contributing Authors"  * is defined as the following set of individuals:  *  *    Andreas Dilger  *    Dave Martindale  *    Guy Eric Schalnat  *    Paul Schmidt  *    Tim Wegner  *  * The PNG Reference Library is supplied "AS IS".  The Contributing Authors  * and Group 42, Inc. disclaim all warranties, expressed or implied,  * including, without limitation, the warranties of merchantability and of  * fitness for any purpose.  The Contributing Authors and Group 42, Inc.  * assume no liability for direct, indirect, incidental, special, exemplary,  * or consequential damages, which may result from the use of the PNG  * Reference Library, even if advised of the possibility of such damage.  *  * Permission is hereby granted to use, copy, modify, and distribute this  * source code, or portions hereof, for any purpose, without fee, subject  * to the following restrictions:  *  *   1. The origin of this source code must not be misrepresented.  *  *   2. Altered versions must be plainly marked as such and must not  *      be misrepresented as being the original source.  *  *   3. This Copyright notice may not be removed or altered from  *      any source or altered source distribution.  *  * The Contributing Authors and Group 42, Inc. specifically permit, without  * fee, and encourage the use of this source code as a component to  * supporting the PNG file format in commercial products.  If you use this  * source code in a product, acknowledgment is not required but would be  * appreciated.  */
end_comment
begin_comment
comment|/*  * A "png_get_copyright" function is available, for convenient use in "about"  * boxes and the like:  *  *     printf("%s", png_get_copyright(NULL));  *  * Also, the PNG logo (in PNG format, of course) is supplied in the  * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).  */
end_comment
begin_comment
comment|/*  * Libpng is OSI Certified Open Source Software.  OSI Certified is a  * certification mark of the Open Source Initiative.  */
end_comment
begin_comment
comment|/*  * The contributing authors would like to thank all those who helped  * with testing, bug fixes, and patience.  This wouldn't have been  * possible without all of you.  *  * Thanks to Frank J. T. Wojcik for helping with the documentation.  */
end_comment
begin_comment
comment|/*  * Y2K compliance in libpng:  * =========================  *  *    March 26, 2015  *  *    Since the PNG Development group is an ad-hoc body, we can't make  *    an official declaration.  *  *    This is your unofficial assurance that libpng from version 0.71 and  *    upward through 1.6.17 are Y2K compliant.  It is my belief that  *    earlier versions were also Y2K compliant.  *  *    Libpng only has two year fields.  One is a 2-byte unsigned integer  *    that will hold years up to 65535.  The other, which is deprecated,  *    holds the date in text format, and will hold years up to 9999.  *  *    The integer is  *        "png_uint_16 year" in png_time_struct.  *  *    The string is  *        "char time_buffer[29]" in png_struct.  This is no longer used  *    in libpng-1.6.x and will be removed from libpng-1.7.0.  *  *    There are seven time-related functions:  *        png.c: png_convert_to_rfc_1123_buffer() in png.c  *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and  *          png_convert_to_rfc_1152() in error prior to libpng-0.98)  *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c  *        png_convert_from_time_t() in pngwrite.c  *        png_get_tIME() in pngget.c  *        png_handle_tIME() in pngrutil.c, called in pngread.c  *        png_set_tIME() in pngset.c  *        png_write_tIME() in pngwutil.c, called in pngwrite.c  *  *    All handle dates properly in a Y2K environment.  The  *    png_convert_from_time_t() function calls gmtime() to convert from system  *    clock time, which returns (year - 1900), which we properly convert to  *    the full 4-digit year.  There is a possibility that libpng applications  *    are not passing 4-digit years into the png_convert_to_rfc_1123_buffer()  *    function, or that they are incorrectly passing only a 2-digit year  *    instead of "year - 1900" into the png_convert_from_struct_tm() function,  *    but this is not under our control.  The libpng documentation has always  *    stated that it works with 4-digit years, and the APIs have been  *    documented as such.  *  *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned  *    integer to hold the year, and can hold years as large as 65535.  *  *    zlib, upon which libpng depends, is also Y2K compliant.  It contains  *    no date-related code.  *  *       Glenn Randers-Pehrson  *       libpng maintainer  *       PNG Development Group  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_H
end_ifndef
begin_define
DECL|macro|PNG_H
define|#
directive|define
name|PNG_H
end_define
begin_comment
comment|/* This is not the place to learn how to use libpng. The file libpng-manual.txt  * describes how to use libpng, and the file example.c summarizes it  * with some code on which to build.  This file is useful for looking  * at the actual function definitions and structure components.  If that  * file has been stripped from your copy of libpng, you can find it at  *<http://www.libpng.org/pub/png/libpng-manual.txt>  *  * If you just need to read a PNG file and don't want to read the documentation  * skip to the end of this file and read the section entitled 'simplified API'.  */
end_comment
begin_comment
comment|/* Version information for png.h - this should match the version in png.c */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER_STRING
define|#
directive|define
name|PNG_LIBPNG_VER_STRING
value|"1.6.17"
end_define
begin_define
DECL|macro|PNG_HEADER_VERSION_STRING
define|#
directive|define
name|PNG_HEADER_VERSION_STRING
define|\
value|" libpng version 1.6.17 - March 26, 2015\n"
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_SONUM
define|#
directive|define
name|PNG_LIBPNG_VER_SONUM
value|16
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_DLLNUM
define|#
directive|define
name|PNG_LIBPNG_VER_DLLNUM
value|16
end_define
begin_comment
comment|/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER_MAJOR
define|#
directive|define
name|PNG_LIBPNG_VER_MAJOR
value|1
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_MINOR
define|#
directive|define
name|PNG_LIBPNG_VER_MINOR
value|6
end_define
begin_define
DECL|macro|PNG_LIBPNG_VER_RELEASE
define|#
directive|define
name|PNG_LIBPNG_VER_RELEASE
value|17
end_define
begin_comment
comment|/* This should match the numeric part of the final component of  * PNG_LIBPNG_VER_STRING, omitting any leading zero:  */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER_BUILD
define|#
directive|define
name|PNG_LIBPNG_VER_BUILD
value|0
end_define
begin_comment
comment|/* Release Status */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_ALPHA
define|#
directive|define
name|PNG_LIBPNG_BUILD_ALPHA
value|1
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_BETA
define|#
directive|define
name|PNG_LIBPNG_BUILD_BETA
value|2
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_RC
define|#
directive|define
name|PNG_LIBPNG_BUILD_RC
value|3
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_STABLE
define|#
directive|define
name|PNG_LIBPNG_BUILD_STABLE
value|4
end_define
begin_define
DECL|macro|PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK
define|#
directive|define
name|PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK
value|7
end_define
begin_comment
comment|/* Release-Specific Flags */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_PATCH
define|#
directive|define
name|PNG_LIBPNG_BUILD_PATCH
value|8
end_define
begin_comment
DECL|macro|PNG_LIBPNG_BUILD_PATCH
comment|/* Can be OR'ed with                                        PNG_LIBPNG_BUILD_STABLE only */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_PRIVATE
define|#
directive|define
name|PNG_LIBPNG_BUILD_PRIVATE
value|16
end_define
begin_comment
DECL|macro|PNG_LIBPNG_BUILD_PRIVATE
comment|/* Cannot be OR'ed with                                        PNG_LIBPNG_BUILD_SPECIAL */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_SPECIAL
define|#
directive|define
name|PNG_LIBPNG_BUILD_SPECIAL
value|32
end_define
begin_comment
DECL|macro|PNG_LIBPNG_BUILD_SPECIAL
comment|/* Cannot be OR'ed with                                        PNG_LIBPNG_BUILD_PRIVATE */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_BASE_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_BASE_TYPE
value|PNG_LIBPNG_BUILD_STABLE
end_define
begin_comment
comment|/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.  * We must not include leading zeros.  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only  * version 1.0.0 was mis-numbered 100 instead of 10000).  From  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release  */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_VER
define|#
directive|define
name|PNG_LIBPNG_VER
value|10617
end_define
begin_comment
DECL|macro|PNG_LIBPNG_VER
comment|/* 1.6.17 */
end_comment
begin_comment
comment|/* Library configuration: these options cannot be changed after  * the library has been built.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNGLCONF_H
end_ifndef
begin_comment
comment|/* If pnglibconf.h is missing, you can      * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h      */
end_comment
begin_include
include|#
directive|include
file|"pnglibconf.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_comment
comment|/* Machine specific configuration. */
end_comment
begin_include
include|#
directive|include
file|"pngconf.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Added at libpng-1.2.8  *  * Ref MSDN: Private as priority over Special  * VS_FF_PRIVATEBUILD File *was not* built using standard release  * procedures. If this value is given, the StringFileInfo block must  * contain a PrivateBuild string.  *  * VS_FF_SPECIALBUILD File *was* built by the original company using  * standard release procedures but is a variation of the standard  * file of the same version number. If this value is given, the  * StringFileInfo block must contain a SpecialBuild string.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_USER_PRIVATEBUILD
end_ifdef
begin_comment
comment|/* From pnglibconf.h */
end_comment
begin_define
DECL|macro|PNG_LIBPNG_BUILD_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_TYPE
define|\
value|(PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_PRIVATE)
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_LIBPNG_SPECIALBUILD
end_ifdef
begin_define
DECL|macro|PNG_LIBPNG_BUILD_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_TYPE
define|\
value|(PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_SPECIAL)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PNG_LIBPNG_BUILD_TYPE
define|#
directive|define
name|PNG_LIBPNG_BUILD_TYPE
value|(PNG_LIBPNG_BUILD_BASE_TYPE)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_comment
comment|/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* Version information for C files, stored in png.c.  This had better match  * the version above.  */
DECL|macro|png_libpng_ver
define|#
directive|define
name|png_libpng_ver
value|png_get_header_ver(NULL)
comment|/* This file is arranged in several sections:  *  * 1. Any configuration options that can be specified by for the application  *    code when it is built.  (Build time configuration is in pnglibconf.h)  * 2. Type definitions (base types are defined in pngconf.h), structure  *    definitions.  * 3. Exported library functions.  * 4. Simplified API.  *  * The library source code has additional files (principally pngpriv.h) that  * allow configuration of the library.  */
comment|/* Section 1: run time configuration  * See pnglibconf.h for build time configuration  *  * Run time configuration allows the application to choose between  * implementations of certain arithmetic APIs.  The default is set  * at build time and recorded in pnglibconf.h, but it is safe to  * override these (and only these) settings.  Note that this won't  * change what the library does, only application code, and the  * settings can (and probably should) be made on a per-file basis  * by setting the #defines before including png.h  *  * Use macros to read integers from PNG data or use the exported  * functions?  *   PNG_USE_READ_MACROS: use the macros (see below)  Note that  *     the macros evaluate their argument multiple times.  *   PNG_NO_USE_READ_MACROS: call the relevant library function.  *  * Use the alternative algorithm for compositing alpha samples that  * does not use division?  *   PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'  *      algorithm.  *   PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.  *  * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is  * false?  *   PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error  *      APIs to png_warning.  * Otherwise the calls are mapped to png_error.  */
comment|/* Section 2: type definitions, including structures and compile time  * constants.  * See pngconf.h for base types that vary by machine/system  */
comment|/* This triggers a compiler error in png.c, if png.c and png.h  * do not agree upon the version number.  */
DECL|typedef|png_libpng_version_1_6_17
typedef|typedef
name|char
modifier|*
name|png_libpng_version_1_6_17
typedef|;
comment|/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.  *  * png_struct is the cache of information used while reading or writing a single  * PNG file.  One of these is always required, although the simplified API  * (below) hides the creation and destruction of it.  */
DECL|typedef|png_struct
typedef|typedef
name|struct
name|png_struct_def
name|png_struct
typedef|;
DECL|typedef|png_const_structp
typedef|typedef
specifier|const
name|png_struct
modifier|*
name|png_const_structp
typedef|;
DECL|typedef|png_structp
typedef|typedef
name|png_struct
modifier|*
name|png_structp
typedef|;
DECL|typedef|png_structpp
typedef|typedef
name|png_struct
modifier|*
modifier|*
name|png_structpp
typedef|;
comment|/* png_info contains information read from or to be written to a PNG file.  One  * or more of these must exist while reading or creating a PNG file.  The  * information is not used by libpng during read but is used to control what  * gets written when a PNG file is created.  "png_get_" function calls read  * information during read and "png_set_" functions calls write information  * when creating a PNG.  * been moved into a separate header file that is not accessible to  * applications.  Read libpng-manual.txt or libpng.3 for more info.  */
DECL|typedef|png_info
typedef|typedef
name|struct
name|png_info_def
name|png_info
typedef|;
DECL|typedef|png_infop
typedef|typedef
name|png_info
modifier|*
name|png_infop
typedef|;
DECL|typedef|png_const_infop
typedef|typedef
specifier|const
name|png_info
modifier|*
name|png_const_infop
typedef|;
DECL|typedef|png_infopp
typedef|typedef
name|png_info
modifier|*
modifier|*
name|png_infopp
typedef|;
comment|/* Types with names ending 'p' are pointer types.  The corresponding types with  * names ending 'rp' are identical pointer types except that the pointer is  * marked 'restrict', which means that it is the only pointer to the object  * passed to the function.  Applications should not use the 'restrict' types;  * it is always valid to pass 'p' to a pointer with a function argument of the  * corresponding 'rp' type.  Different compilers have different rules with  * regard to type matching in the presence of 'restrict'.  For backward  * compatibility libpng callbacks never have 'restrict' in their parameters and,  * consequentially, writing portable application code is extremely difficult if  * an attempt is made to use 'restrict'.  */
DECL|typedef|png_structrp
typedef|typedef
name|png_struct
modifier|*
name|PNG_RESTRICT
name|png_structrp
typedef|;
DECL|typedef|png_const_structrp
typedef|typedef
specifier|const
name|png_struct
modifier|*
name|PNG_RESTRICT
name|png_const_structrp
typedef|;
DECL|typedef|png_inforp
typedef|typedef
name|png_info
modifier|*
name|PNG_RESTRICT
name|png_inforp
typedef|;
DECL|typedef|png_const_inforp
typedef|typedef
specifier|const
name|png_info
modifier|*
name|PNG_RESTRICT
name|png_const_inforp
typedef|;
comment|/* Three color definitions.  The order of the red, green, and blue, (and the  * exact size) is not important, although the size of the fields need to  * be png_byte or png_uint_16 (as defined below).  */
DECL|struct|png_color_struct
typedef|typedef
struct|struct
name|png_color_struct
block|{
DECL|member|red
name|png_byte
name|red
decl_stmt|;
DECL|member|green
name|png_byte
name|green
decl_stmt|;
DECL|member|blue
name|png_byte
name|blue
decl_stmt|;
block|}
DECL|typedef|png_color
name|png_color
typedef|;
DECL|typedef|png_colorp
typedef|typedef
name|png_color
modifier|*
name|png_colorp
typedef|;
DECL|typedef|png_const_colorp
typedef|typedef
specifier|const
name|png_color
modifier|*
name|png_const_colorp
typedef|;
DECL|typedef|png_colorpp
typedef|typedef
name|png_color
modifier|*
modifier|*
name|png_colorpp
typedef|;
DECL|struct|png_color_16_struct
typedef|typedef
struct|struct
name|png_color_16_struct
block|{
DECL|member|index
name|png_byte
name|index
decl_stmt|;
comment|/* used for palette files */
DECL|member|red
name|png_uint_16
name|red
decl_stmt|;
comment|/* for use in red green blue files */
DECL|member|green
name|png_uint_16
name|green
decl_stmt|;
DECL|member|blue
name|png_uint_16
name|blue
decl_stmt|;
DECL|member|gray
name|png_uint_16
name|gray
decl_stmt|;
comment|/* for use in grayscale files */
block|}
DECL|typedef|png_color_16
name|png_color_16
typedef|;
DECL|typedef|png_color_16p
typedef|typedef
name|png_color_16
modifier|*
name|png_color_16p
typedef|;
DECL|typedef|png_const_color_16p
typedef|typedef
specifier|const
name|png_color_16
modifier|*
name|png_const_color_16p
typedef|;
DECL|typedef|png_color_16pp
typedef|typedef
name|png_color_16
modifier|*
modifier|*
name|png_color_16pp
typedef|;
DECL|struct|png_color_8_struct
typedef|typedef
struct|struct
name|png_color_8_struct
block|{
DECL|member|red
name|png_byte
name|red
decl_stmt|;
comment|/* for use in red green blue files */
DECL|member|green
name|png_byte
name|green
decl_stmt|;
DECL|member|blue
name|png_byte
name|blue
decl_stmt|;
DECL|member|gray
name|png_byte
name|gray
decl_stmt|;
comment|/* for use in grayscale files */
DECL|member|alpha
name|png_byte
name|alpha
decl_stmt|;
comment|/* for alpha channel files */
block|}
DECL|typedef|png_color_8
name|png_color_8
typedef|;
DECL|typedef|png_color_8p
typedef|typedef
name|png_color_8
modifier|*
name|png_color_8p
typedef|;
DECL|typedef|png_const_color_8p
typedef|typedef
specifier|const
name|png_color_8
modifier|*
name|png_const_color_8p
typedef|;
DECL|typedef|png_color_8pp
typedef|typedef
name|png_color_8
modifier|*
modifier|*
name|png_color_8pp
typedef|;
comment|/*  * The following two structures are used for the in-core representation  * of sPLT chunks.  */
DECL|struct|png_sPLT_entry_struct
typedef|typedef
struct|struct
name|png_sPLT_entry_struct
block|{
DECL|member|red
name|png_uint_16
name|red
decl_stmt|;
DECL|member|green
name|png_uint_16
name|green
decl_stmt|;
DECL|member|blue
name|png_uint_16
name|blue
decl_stmt|;
DECL|member|alpha
name|png_uint_16
name|alpha
decl_stmt|;
DECL|member|frequency
name|png_uint_16
name|frequency
decl_stmt|;
block|}
DECL|typedef|png_sPLT_entry
name|png_sPLT_entry
typedef|;
DECL|typedef|png_sPLT_entryp
typedef|typedef
name|png_sPLT_entry
modifier|*
name|png_sPLT_entryp
typedef|;
DECL|typedef|png_const_sPLT_entryp
typedef|typedef
specifier|const
name|png_sPLT_entry
modifier|*
name|png_const_sPLT_entryp
typedef|;
DECL|typedef|png_sPLT_entrypp
typedef|typedef
name|png_sPLT_entry
modifier|*
modifier|*
name|png_sPLT_entrypp
typedef|;
comment|/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples  *  occupy the LSB of their respective members, and the MSB of each member  *  is zero-filled.  The frequency member always occupies the full 16 bits.  */
DECL|struct|png_sPLT_struct
typedef|typedef
struct|struct
name|png_sPLT_struct
block|{
DECL|member|name
name|png_charp
name|name
decl_stmt|;
comment|/* palette name */
DECL|member|depth
name|png_byte
name|depth
decl_stmt|;
comment|/* depth of palette samples */
DECL|member|entries
name|png_sPLT_entryp
name|entries
decl_stmt|;
comment|/* palette entries */
DECL|member|nentries
name|png_int_32
name|nentries
decl_stmt|;
comment|/* number of palette entries */
block|}
DECL|typedef|png_sPLT_t
name|png_sPLT_t
typedef|;
DECL|typedef|png_sPLT_tp
typedef|typedef
name|png_sPLT_t
modifier|*
name|png_sPLT_tp
typedef|;
DECL|typedef|png_const_sPLT_tp
typedef|typedef
specifier|const
name|png_sPLT_t
modifier|*
name|png_const_sPLT_tp
typedef|;
DECL|typedef|png_sPLT_tpp
typedef|typedef
name|png_sPLT_t
modifier|*
modifier|*
name|png_sPLT_tpp
typedef|;
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,  * and whether that contents is compressed or not.  The "key" field  * points to a regular zero-terminated C string.  The "text" fields can be a  * regular C string, an empty string, or a NULL pointer.  * However, the structure returned by png_get_text() will always contain  * the "text" field as a regular zero-terminated C string (possibly  * empty), never a NULL pointer, so it can be safely used in printf() and  * other string-handling functions.  Note that the "itxt_length", "lang", and  * "lang_key" members of the structure only exist when the library is built  * with iTXt chunk support.  Prior to libpng-1.4.0 the library was built by  * default without iTXt support. Also note that when iTXt *is* supported,  * the "lang" and "lang_key" fields contain NULL pointers when the  * "compression" field contains * PNG_TEXT_COMPRESSION_NONE or  * PNG_TEXT_COMPRESSION_zTXt. Note that the "compression value" is not the  * same as what appears in the PNG tEXt/zTXt/iTXt chunk's "compression flag"  * which is always 0 or 1, or its "compression method" which is always 0.  */
DECL|struct|png_text_struct
typedef|typedef
struct|struct
name|png_text_struct
block|{
DECL|member|compression
name|int
name|compression
decl_stmt|;
comment|/* compression value:                              -1: tEXt, none                               0: zTXt, deflate                               1: iTXt, none                               2: iTXt, deflate  */
DECL|member|key
name|png_charp
name|key
decl_stmt|;
comment|/* keyword, 1-79 character description of "text" */
DECL|member|text
name|png_charp
name|text
decl_stmt|;
comment|/* comment, may be an empty string (ie "")                               or a NULL pointer */
DECL|member|text_length
name|png_size_t
name|text_length
decl_stmt|;
comment|/* length of the text string */
DECL|member|itxt_length
name|png_size_t
name|itxt_length
decl_stmt|;
comment|/* length of the itxt string */
DECL|member|lang
name|png_charp
name|lang
decl_stmt|;
comment|/* language code, 0-79 characters                               or a NULL pointer */
DECL|member|lang_key
name|png_charp
name|lang_key
decl_stmt|;
comment|/* keyword translated UTF-8 string, 0 or more                               chars or a NULL pointer */
block|}
DECL|typedef|png_text
name|png_text
typedef|;
DECL|typedef|png_textp
typedef|typedef
name|png_text
modifier|*
name|png_textp
typedef|;
DECL|typedef|png_const_textp
typedef|typedef
specifier|const
name|png_text
modifier|*
name|png_const_textp
typedef|;
DECL|typedef|png_textpp
typedef|typedef
name|png_text
modifier|*
modifier|*
name|png_textpp
typedef|;
endif|#
directive|endif
comment|/* Supported compression types for text in PNG files (tEXt, and zTXt).  * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
DECL|macro|PNG_TEXT_COMPRESSION_NONE_WR
define|#
directive|define
name|PNG_TEXT_COMPRESSION_NONE_WR
value|-3
DECL|macro|PNG_TEXT_COMPRESSION_zTXt_WR
define|#
directive|define
name|PNG_TEXT_COMPRESSION_zTXt_WR
value|-2
DECL|macro|PNG_TEXT_COMPRESSION_NONE
define|#
directive|define
name|PNG_TEXT_COMPRESSION_NONE
value|-1
DECL|macro|PNG_TEXT_COMPRESSION_zTXt
define|#
directive|define
name|PNG_TEXT_COMPRESSION_zTXt
value|0
DECL|macro|PNG_ITXT_COMPRESSION_NONE
define|#
directive|define
name|PNG_ITXT_COMPRESSION_NONE
value|1
DECL|macro|PNG_ITXT_COMPRESSION_zTXt
define|#
directive|define
name|PNG_ITXT_COMPRESSION_zTXt
value|2
DECL|macro|PNG_TEXT_COMPRESSION_LAST
define|#
directive|define
name|PNG_TEXT_COMPRESSION_LAST
value|3
comment|/* Not a valid value */
comment|/* png_time is a way to hold the time in an machine independent way.  * Two conversions are provided, both from time_t and struct tm.  There  * is no portable way to convert to either of these structures, as far  * as I know.  If you know of a portable way, send it to me.  As a side  * note - PNG has always been Year 2000 compliant!  */
DECL|struct|png_time_struct
typedef|typedef
struct|struct
name|png_time_struct
block|{
DECL|member|year
name|png_uint_16
name|year
decl_stmt|;
comment|/* full year, as in, 1995 */
DECL|member|month
name|png_byte
name|month
decl_stmt|;
comment|/* month of year, 1 - 12 */
DECL|member|day
name|png_byte
name|day
decl_stmt|;
comment|/* day of month, 1 - 31 */
DECL|member|hour
name|png_byte
name|hour
decl_stmt|;
comment|/* hour of day, 0 - 23 */
DECL|member|minute
name|png_byte
name|minute
decl_stmt|;
comment|/* minute of hour, 0 - 59 */
DECL|member|second
name|png_byte
name|second
decl_stmt|;
comment|/* second of minute, 0 - 60 (for leap seconds) */
block|}
DECL|typedef|png_time
name|png_time
typedef|;
DECL|typedef|png_timep
typedef|typedef
name|png_time
modifier|*
name|png_timep
typedef|;
DECL|typedef|png_const_timep
typedef|typedef
specifier|const
name|png_time
modifier|*
name|png_const_timep
typedef|;
DECL|typedef|png_timepp
typedef|typedef
name|png_time
modifier|*
modifier|*
name|png_timepp
typedef|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_USER_CHUNKS_SUPPORTED
argument_list|)
comment|/* png_unknown_chunk is a structure to hold queued chunks for which there is  * no specific support.  The idea is that we can use this to queue  * up private chunks for output even though the library doesn't actually  * know about their semantics.  *  * The data in the structure is set by libpng on read and used on write.  */
DECL|struct|png_unknown_chunk_t
typedef|typedef
struct|struct
name|png_unknown_chunk_t
block|{
DECL|member|name
name|png_byte
name|name
index|[
literal|5
index|]
decl_stmt|;
comment|/* Textual chunk name with '\0' terminator */
DECL|member|data
name|png_byte
modifier|*
name|data
decl_stmt|;
comment|/* Data, should not be modified on read! */
DECL|member|size
name|png_size_t
name|size
decl_stmt|;
comment|/* On write 'location' must be set using the flag values listed below.      * Notice that on read it is set by libpng however the values stored have      * more bits set than are listed below.  Always treat the value as a      * bitmask.  On write set only one bit - setting multiple bits may cause the      * chunk to be written in multiple places.      */
DECL|member|location
name|png_byte
name|location
decl_stmt|;
comment|/* mode of operation at read time */
block|}
DECL|typedef|png_unknown_chunk
name|png_unknown_chunk
typedef|;
DECL|typedef|png_unknown_chunkp
typedef|typedef
name|png_unknown_chunk
modifier|*
name|png_unknown_chunkp
typedef|;
DECL|typedef|png_const_unknown_chunkp
typedef|typedef
specifier|const
name|png_unknown_chunk
modifier|*
name|png_const_unknown_chunkp
typedef|;
DECL|typedef|png_unknown_chunkpp
typedef|typedef
name|png_unknown_chunk
modifier|*
modifier|*
name|png_unknown_chunkpp
typedef|;
endif|#
directive|endif
comment|/* Flag values for the unknown chunk location byte. */
DECL|macro|PNG_HAVE_IHDR
define|#
directive|define
name|PNG_HAVE_IHDR
value|0x01
DECL|macro|PNG_HAVE_PLTE
define|#
directive|define
name|PNG_HAVE_PLTE
value|0x02
DECL|macro|PNG_AFTER_IDAT
define|#
directive|define
name|PNG_AFTER_IDAT
value|0x08
comment|/* Maximum positive integer used in PNG is (2^31)-1 */
DECL|macro|PNG_UINT_31_MAX
define|#
directive|define
name|PNG_UINT_31_MAX
value|((png_uint_32)0x7fffffffL)
DECL|macro|PNG_UINT_32_MAX
define|#
directive|define
name|PNG_UINT_32_MAX
value|((png_uint_32)(-1))
DECL|macro|PNG_SIZE_MAX
define|#
directive|define
name|PNG_SIZE_MAX
value|((png_size_t)(-1))
comment|/* These are constants for fixed point values encoded in the  * PNG specification manner (x100000)  */
DECL|macro|PNG_FP_1
define|#
directive|define
name|PNG_FP_1
value|100000
DECL|macro|PNG_FP_HALF
define|#
directive|define
name|PNG_FP_HALF
value|50000
DECL|macro|PNG_FP_MAX
define|#
directive|define
name|PNG_FP_MAX
value|((png_fixed_point)0x7fffffffL)
DECL|macro|PNG_FP_MIN
define|#
directive|define
name|PNG_FP_MIN
value|(-PNG_FP_MAX)
comment|/* These describe the color_type field in png_info. */
comment|/* color type masks */
DECL|macro|PNG_COLOR_MASK_PALETTE
define|#
directive|define
name|PNG_COLOR_MASK_PALETTE
value|1
DECL|macro|PNG_COLOR_MASK_COLOR
define|#
directive|define
name|PNG_COLOR_MASK_COLOR
value|2
DECL|macro|PNG_COLOR_MASK_ALPHA
define|#
directive|define
name|PNG_COLOR_MASK_ALPHA
value|4
comment|/* color types.  Note that not all combinations are legal */
DECL|macro|PNG_COLOR_TYPE_GRAY
define|#
directive|define
name|PNG_COLOR_TYPE_GRAY
value|0
DECL|macro|PNG_COLOR_TYPE_PALETTE
define|#
directive|define
name|PNG_COLOR_TYPE_PALETTE
value|(PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
DECL|macro|PNG_COLOR_TYPE_RGB
define|#
directive|define
name|PNG_COLOR_TYPE_RGB
value|(PNG_COLOR_MASK_COLOR)
DECL|macro|PNG_COLOR_TYPE_RGB_ALPHA
define|#
directive|define
name|PNG_COLOR_TYPE_RGB_ALPHA
value|(PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
DECL|macro|PNG_COLOR_TYPE_GRAY_ALPHA
define|#
directive|define
name|PNG_COLOR_TYPE_GRAY_ALPHA
value|(PNG_COLOR_MASK_ALPHA)
comment|/* aliases */
DECL|macro|PNG_COLOR_TYPE_RGBA
define|#
directive|define
name|PNG_COLOR_TYPE_RGBA
value|PNG_COLOR_TYPE_RGB_ALPHA
DECL|macro|PNG_COLOR_TYPE_GA
define|#
directive|define
name|PNG_COLOR_TYPE_GA
value|PNG_COLOR_TYPE_GRAY_ALPHA
comment|/* This is for compression type. PNG 1.0-1.2 only define the single type. */
DECL|macro|PNG_COMPRESSION_TYPE_BASE
define|#
directive|define
name|PNG_COMPRESSION_TYPE_BASE
value|0
comment|/* Deflate method 8, 32K window */
DECL|macro|PNG_COMPRESSION_TYPE_DEFAULT
define|#
directive|define
name|PNG_COMPRESSION_TYPE_DEFAULT
value|PNG_COMPRESSION_TYPE_BASE
comment|/* This is for filter type. PNG 1.0-1.2 only define the single type. */
DECL|macro|PNG_FILTER_TYPE_BASE
define|#
directive|define
name|PNG_FILTER_TYPE_BASE
value|0
comment|/* Single row per-byte filtering */
DECL|macro|PNG_INTRAPIXEL_DIFFERENCING
define|#
directive|define
name|PNG_INTRAPIXEL_DIFFERENCING
value|64
comment|/* Used only in MNG datastreams */
DECL|macro|PNG_FILTER_TYPE_DEFAULT
define|#
directive|define
name|PNG_FILTER_TYPE_DEFAULT
value|PNG_FILTER_TYPE_BASE
comment|/* These are for the interlacing type.  These values should NOT be changed. */
DECL|macro|PNG_INTERLACE_NONE
define|#
directive|define
name|PNG_INTERLACE_NONE
value|0
comment|/* Non-interlaced image */
DECL|macro|PNG_INTERLACE_ADAM7
define|#
directive|define
name|PNG_INTERLACE_ADAM7
value|1
comment|/* Adam7 interlacing */
DECL|macro|PNG_INTERLACE_LAST
define|#
directive|define
name|PNG_INTERLACE_LAST
value|2
comment|/* Not a valid value */
comment|/* These are for the oFFs chunk.  These values should NOT be changed. */
DECL|macro|PNG_OFFSET_PIXEL
define|#
directive|define
name|PNG_OFFSET_PIXEL
value|0
comment|/* Offset in pixels */
DECL|macro|PNG_OFFSET_MICROMETER
define|#
directive|define
name|PNG_OFFSET_MICROMETER
value|1
comment|/* Offset in micrometers (1/10^6 meter) */
DECL|macro|PNG_OFFSET_LAST
define|#
directive|define
name|PNG_OFFSET_LAST
value|2
comment|/* Not a valid value */
comment|/* These are for the pCAL chunk.  These values should NOT be changed. */
DECL|macro|PNG_EQUATION_LINEAR
define|#
directive|define
name|PNG_EQUATION_LINEAR
value|0
comment|/* Linear transformation */
DECL|macro|PNG_EQUATION_BASE_E
define|#
directive|define
name|PNG_EQUATION_BASE_E
value|1
comment|/* Exponential base e transform */
DECL|macro|PNG_EQUATION_ARBITRARY
define|#
directive|define
name|PNG_EQUATION_ARBITRARY
value|2
comment|/* Arbitrary base exponential transform */
DECL|macro|PNG_EQUATION_HYPERBOLIC
define|#
directive|define
name|PNG_EQUATION_HYPERBOLIC
value|3
comment|/* Hyperbolic sine transformation */
DECL|macro|PNG_EQUATION_LAST
define|#
directive|define
name|PNG_EQUATION_LAST
value|4
comment|/* Not a valid value */
comment|/* These are for the sCAL chunk.  These values should NOT be changed. */
DECL|macro|PNG_SCALE_UNKNOWN
define|#
directive|define
name|PNG_SCALE_UNKNOWN
value|0
comment|/* unknown unit (image scale) */
DECL|macro|PNG_SCALE_METER
define|#
directive|define
name|PNG_SCALE_METER
value|1
comment|/* meters per pixel */
DECL|macro|PNG_SCALE_RADIAN
define|#
directive|define
name|PNG_SCALE_RADIAN
value|2
comment|/* radians per pixel */
DECL|macro|PNG_SCALE_LAST
define|#
directive|define
name|PNG_SCALE_LAST
value|3
comment|/* Not a valid value */
comment|/* These are for the pHYs chunk.  These values should NOT be changed. */
DECL|macro|PNG_RESOLUTION_UNKNOWN
define|#
directive|define
name|PNG_RESOLUTION_UNKNOWN
value|0
comment|/* pixels/unknown unit (aspect ratio) */
DECL|macro|PNG_RESOLUTION_METER
define|#
directive|define
name|PNG_RESOLUTION_METER
value|1
comment|/* pixels/meter */
DECL|macro|PNG_RESOLUTION_LAST
define|#
directive|define
name|PNG_RESOLUTION_LAST
value|2
comment|/* Not a valid value */
comment|/* These are for the sRGB chunk.  These values should NOT be changed. */
DECL|macro|PNG_sRGB_INTENT_PERCEPTUAL
define|#
directive|define
name|PNG_sRGB_INTENT_PERCEPTUAL
value|0
DECL|macro|PNG_sRGB_INTENT_RELATIVE
define|#
directive|define
name|PNG_sRGB_INTENT_RELATIVE
value|1
DECL|macro|PNG_sRGB_INTENT_SATURATION
define|#
directive|define
name|PNG_sRGB_INTENT_SATURATION
value|2
DECL|macro|PNG_sRGB_INTENT_ABSOLUTE
define|#
directive|define
name|PNG_sRGB_INTENT_ABSOLUTE
value|3
DECL|macro|PNG_sRGB_INTENT_LAST
define|#
directive|define
name|PNG_sRGB_INTENT_LAST
value|4
comment|/* Not a valid value */
comment|/* This is for text chunks */
DECL|macro|PNG_KEYWORD_MAX_LENGTH
define|#
directive|define
name|PNG_KEYWORD_MAX_LENGTH
value|79
comment|/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
DECL|macro|PNG_MAX_PALETTE_LENGTH
define|#
directive|define
name|PNG_MAX_PALETTE_LENGTH
value|256
comment|/* These determine if an ancillary chunk's data has been successfully read  * from the PNG header, or if the application has filled in the corresponding  * data in the info_struct to be written into the output file.  The values  * of the PNG_INFO_<chunk> defines should NOT be changed.  */
DECL|macro|PNG_INFO_gAMA
define|#
directive|define
name|PNG_INFO_gAMA
value|0x0001
DECL|macro|PNG_INFO_sBIT
define|#
directive|define
name|PNG_INFO_sBIT
value|0x0002
DECL|macro|PNG_INFO_cHRM
define|#
directive|define
name|PNG_INFO_cHRM
value|0x0004
DECL|macro|PNG_INFO_PLTE
define|#
directive|define
name|PNG_INFO_PLTE
value|0x0008
DECL|macro|PNG_INFO_tRNS
define|#
directive|define
name|PNG_INFO_tRNS
value|0x0010
DECL|macro|PNG_INFO_bKGD
define|#
directive|define
name|PNG_INFO_bKGD
value|0x0020
DECL|macro|PNG_INFO_hIST
define|#
directive|define
name|PNG_INFO_hIST
value|0x0040
DECL|macro|PNG_INFO_pHYs
define|#
directive|define
name|PNG_INFO_pHYs
value|0x0080
DECL|macro|PNG_INFO_oFFs
define|#
directive|define
name|PNG_INFO_oFFs
value|0x0100
DECL|macro|PNG_INFO_tIME
define|#
directive|define
name|PNG_INFO_tIME
value|0x0200
DECL|macro|PNG_INFO_pCAL
define|#
directive|define
name|PNG_INFO_pCAL
value|0x0400
DECL|macro|PNG_INFO_sRGB
define|#
directive|define
name|PNG_INFO_sRGB
value|0x0800
comment|/* GR-P, 0.96a */
DECL|macro|PNG_INFO_iCCP
define|#
directive|define
name|PNG_INFO_iCCP
value|0x1000
comment|/* ESR, 1.0.6 */
DECL|macro|PNG_INFO_sPLT
define|#
directive|define
name|PNG_INFO_sPLT
value|0x2000
comment|/* ESR, 1.0.6 */
DECL|macro|PNG_INFO_sCAL
define|#
directive|define
name|PNG_INFO_sCAL
value|0x4000
comment|/* ESR, 1.0.6 */
DECL|macro|PNG_INFO_IDAT
define|#
directive|define
name|PNG_INFO_IDAT
value|0x8000
comment|/* ESR, 1.0.6 */
comment|/* This is used for the transformation routines, as some of them  * change these values for the row.  It also should enable using  * the routines for other purposes.  */
DECL|struct|png_row_info_struct
typedef|typedef
struct|struct
name|png_row_info_struct
block|{
DECL|member|width
name|png_uint_32
name|width
decl_stmt|;
comment|/* width of row */
DECL|member|rowbytes
name|png_size_t
name|rowbytes
decl_stmt|;
comment|/* number of bytes in row */
DECL|member|color_type
name|png_byte
name|color_type
decl_stmt|;
comment|/* color type of row */
DECL|member|bit_depth
name|png_byte
name|bit_depth
decl_stmt|;
comment|/* bit depth of row */
DECL|member|channels
name|png_byte
name|channels
decl_stmt|;
comment|/* number of channels (1, 2, 3, or 4) */
DECL|member|pixel_depth
name|png_byte
name|pixel_depth
decl_stmt|;
comment|/* bits per pixel (depth * channels) */
block|}
DECL|typedef|png_row_info
name|png_row_info
typedef|;
DECL|typedef|png_row_infop
typedef|typedef
name|png_row_info
modifier|*
name|png_row_infop
typedef|;
DECL|typedef|png_row_infopp
typedef|typedef
name|png_row_info
modifier|*
modifier|*
name|png_row_infopp
typedef|;
comment|/* These are the function types for the I/O functions and for the functions  * that allow the user to override the default I/O functions with his or her  * own.  The png_error_ptr type should match that of user-supplied warning  * and error functions, while the png_rw_ptr type should match that of the  * user read/write data functions.  Note that the 'write' function must not  * modify the buffer it is passed. The 'read' function, on the other hand, is  * expected to return the read data in the buffer.  */
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_error_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_const_charp
operator|)
argument_list|)
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_rw_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_bytep
operator|,
name|png_size_t
operator|)
argument_list|)
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_flush_ptr
argument_list|,
operator|(
name|png_structp
operator|)
argument_list|)
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_read_status_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_uint_32
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_write_status_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_uint_32
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_progressive_info_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_infop
operator|)
argument_list|)
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_progressive_end_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_infop
operator|)
argument_list|)
expr_stmt|;
comment|/* The following callback receives png_uint_32 row_number, int pass for the  * png_bytep data of the row.  When transforming an interlaced image the  * row number is the row number within the sub-image of the interlace pass, so  * the value will increase to the height of the sub-image (not the full image)  * then reset to 0 for the next pass.  *  * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to  * find the output pixel (x,y) given an interlaced sub-image pixel  * (row,col,pass).  (See below for these macros.)  */
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_progressive_row_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_bytep
operator|,
name|png_uint_32
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_USER_TRANSFORM_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
argument_list|)
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_user_transform_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_row_infop
operator|,
name|png_bytep
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_CHUNKS_SUPPORTED
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|int
argument_list|,
operator|*
name|png_user_chunk_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_unknown_chunkp
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
comment|/* not used anywhere */
comment|/* typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_structp)); */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* This must match the function definition in<setjmp.h>, and the application  * must include this before png.h to obtain the definition of jmp_buf.  The  * function is required to be PNG_NORETURN, but this is not checked.  If the  * function does return the application will crash via an abort() or similar  * system level call.  *  * If you get a warning here while building the library you may need to make  * changes to ensure that pnglibconf.h records the calling convention used by  * your compiler.  This may be very difficult - try using a different compiler  * to build the library!  */
name|PNG_FUNCTION
argument_list|(
argument|void
argument_list|,
argument|(PNGCAPI *png_longjmp_ptr)
argument_list|,
argument|PNGARG((jmp_buf, int))
argument_list|,
argument|typedef
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/* Transform masks for the high-level interface */
DECL|macro|PNG_TRANSFORM_IDENTITY
define|#
directive|define
name|PNG_TRANSFORM_IDENTITY
value|0x0000
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_STRIP_16
define|#
directive|define
name|PNG_TRANSFORM_STRIP_16
value|0x0001
comment|/* read only */
DECL|macro|PNG_TRANSFORM_STRIP_ALPHA
define|#
directive|define
name|PNG_TRANSFORM_STRIP_ALPHA
value|0x0002
comment|/* read only */
DECL|macro|PNG_TRANSFORM_PACKING
define|#
directive|define
name|PNG_TRANSFORM_PACKING
value|0x0004
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_PACKSWAP
define|#
directive|define
name|PNG_TRANSFORM_PACKSWAP
value|0x0008
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_EXPAND
define|#
directive|define
name|PNG_TRANSFORM_EXPAND
value|0x0010
comment|/* read only */
DECL|macro|PNG_TRANSFORM_INVERT_MONO
define|#
directive|define
name|PNG_TRANSFORM_INVERT_MONO
value|0x0020
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_SHIFT
define|#
directive|define
name|PNG_TRANSFORM_SHIFT
value|0x0040
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_BGR
define|#
directive|define
name|PNG_TRANSFORM_BGR
value|0x0080
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_SWAP_ALPHA
define|#
directive|define
name|PNG_TRANSFORM_SWAP_ALPHA
value|0x0100
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_SWAP_ENDIAN
define|#
directive|define
name|PNG_TRANSFORM_SWAP_ENDIAN
value|0x0200
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_INVERT_ALPHA
define|#
directive|define
name|PNG_TRANSFORM_INVERT_ALPHA
value|0x0400
comment|/* read and write */
DECL|macro|PNG_TRANSFORM_STRIP_FILLER
define|#
directive|define
name|PNG_TRANSFORM_STRIP_FILLER
value|0x0800
comment|/* write only */
comment|/* Added to libpng-1.2.34 */
DECL|macro|PNG_TRANSFORM_STRIP_FILLER_BEFORE
define|#
directive|define
name|PNG_TRANSFORM_STRIP_FILLER_BEFORE
value|PNG_TRANSFORM_STRIP_FILLER
DECL|macro|PNG_TRANSFORM_STRIP_FILLER_AFTER
define|#
directive|define
name|PNG_TRANSFORM_STRIP_FILLER_AFTER
value|0x1000
comment|/* write only */
comment|/* Added to libpng-1.4.0 */
DECL|macro|PNG_TRANSFORM_GRAY_TO_RGB
define|#
directive|define
name|PNG_TRANSFORM_GRAY_TO_RGB
value|0x2000
comment|/* read only */
comment|/* Added to libpng-1.5.4 */
DECL|macro|PNG_TRANSFORM_EXPAND_16
define|#
directive|define
name|PNG_TRANSFORM_EXPAND_16
value|0x4000
comment|/* read only */
DECL|macro|PNG_TRANSFORM_SCALE_16
define|#
directive|define
name|PNG_TRANSFORM_SCALE_16
value|0x8000
comment|/* read only */
comment|/* Flags for MNG supported features */
DECL|macro|PNG_FLAG_MNG_EMPTY_PLTE
define|#
directive|define
name|PNG_FLAG_MNG_EMPTY_PLTE
value|0x01
DECL|macro|PNG_FLAG_MNG_FILTER_64
define|#
directive|define
name|PNG_FLAG_MNG_FILTER_64
value|0x04
DECL|macro|PNG_ALL_MNG_FEATURES
define|#
directive|define
name|PNG_ALL_MNG_FEATURES
value|0x05
comment|/* NOTE: prior to 1.5 these functions had no 'API' style declaration,  * this allowed the zlib default functions to be used on Windows  * platforms.  In 1.5 the zlib default malloc (which just calls malloc and  * ignores the first argument) should be completely compatible with the  * following.  */
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|png_voidp
argument_list|,
operator|*
name|png_malloc_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_alloc_size_t
operator|)
argument_list|)
expr_stmt|;
DECL|typedef|PNG_CALLBACK
typedef|typedef
name|PNG_CALLBACK
argument_list|(
name|void
argument_list|,
operator|*
name|png_free_ptr
argument_list|,
operator|(
name|png_structp
operator|,
name|png_voidp
operator|)
argument_list|)
expr_stmt|;
comment|/* Section 3: exported functions  * Here are the function definitions most commonly used.  This is not  * the place to find out how to use libpng.  See libpng-manual.txt for the  * full explanation, see example.c for the summary.  This just provides  * a simple one line description of the use of each function.  *  * The PNG_EXPORT() and PNG_EXPORTA() macros used below are defined in  * pngconf.h and in the *.dfn files in the scripts directory.  *  *   PNG_EXPORT(ordinal, type, name, (args));  *  *       ordinal:    ordinal that is used while building  *                   *.def files. The ordinal value is only  *                   relevant when preprocessing png.h with  *                   the *.dfn files for building symbol table  *                   entries, and are removed by pngconf.h.  *       type:       return type of the function  *       name:       function name  *       args:       function arguments, with types  *  * When we wish to append attributes to a function prototype we use  * the PNG_EXPORTA() macro instead.  *  *   PNG_EXPORTA(ordinal, type, name, (args), attributes);  *  *       ordinal, type, name, and args: same as in PNG_EXPORT().  *       attributes: function attributes  */
comment|/* Returns the version number of the library */
name|PNG_EXPORT
argument_list|(
literal|1
argument_list|,
name|png_uint_32
argument_list|,
name|png_access_version_number
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Tell lib we have already handled the first<num_bytes> magic bytes.  * Handling more than 8 bytes from the beginning of the file is an error.  */
name|PNG_EXPORT
argument_list|(
literal|2
argument_list|,
name|void
argument_list|,
name|png_set_sig_bytes
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|num_bytes
operator|)
argument_list|)
expr_stmt|;
comment|/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a  * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG  * signature, and non-zero otherwise.  Having num_to_check == 0 or  * start> 7 will always fail (ie return non-zero).  */
name|PNG_EXPORT
argument_list|(
literal|3
argument_list|,
name|int
argument_list|,
name|png_sig_cmp
argument_list|,
operator|(
name|png_const_bytep
name|sig
operator|,
name|png_size_t
name|start
operator|,
name|png_size_t
name|num_to_check
operator|)
argument_list|)
expr_stmt|;
comment|/* Simple signature checking function.  This is the same as calling  * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).  */
DECL|macro|png_check_sig
define|#
directive|define
name|png_check_sig
parameter_list|(
name|sig
parameter_list|,
name|n
parameter_list|)
value|!png_sig_cmp((sig), 0, (n))
comment|/* Allocate and initialize png_ptr struct for reading, and any other memory. */
name|PNG_EXPORTA
argument_list|(
literal|4
argument_list|,
name|png_structp
argument_list|,
name|png_create_read_struct
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize png_ptr struct for writing, and any other memory */
name|PNG_EXPORTA
argument_list|(
literal|5
argument_list|,
name|png_structp
argument_list|,
name|png_create_write_struct
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|6
argument_list|,
name|png_size_t
argument_list|,
name|png_get_compression_buffer_size
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|7
argument_list|,
name|void
argument_list|,
name|png_set_compression_buffer_size
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_size_t
name|size
operator|)
argument_list|)
expr_stmt|;
comment|/* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp  * match up.  */
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* This function returns the jmp_buf built in to *png_ptr.  It must be  * supplied with an appropriate 'longjmp' function to use on that jmp_buf  * unless the default error function is overridden in which case NULL is  * acceptable.  The size of the jmp_buf is checked against the actual size  * allocated by the library - the call will return NULL on a mismatch  * indicating an ABI mismatch.  */
name|PNG_EXPORT
argument_list|(
literal|8
argument_list|,
name|jmp_buf
operator|*
argument_list|,
name|png_set_longjmp_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_longjmp_ptr
name|longjmp_fn
operator|,
name|size_t
name|jmp_buf_size
operator|)
argument_list|)
expr_stmt|;
DECL|macro|png_jmpbuf
define|#
directive|define
name|png_jmpbuf
parameter_list|(
name|png_ptr
parameter_list|)
define|\
value|(*png_set_longjmp_fn((png_ptr), longjmp, (sizeof (jmp_buf))))
else|#
directive|else
DECL|macro|png_jmpbuf
define|#
directive|define
name|png_jmpbuf
parameter_list|(
name|png_ptr
parameter_list|)
define|\
value|(LIBPNG_WAS_COMPILED_WITH__PNG_NO_SETJMP)
endif|#
directive|endif
comment|/* This function should be used by libpng applications in place of  * longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it  * will use it; otherwise it will call PNG_ABORT().  This function was  * added in libpng-1.5.0.  */
name|PNG_EXPORTA
argument_list|(
literal|9
argument_list|,
name|void
argument_list|,
name|png_longjmp
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|int
name|val
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
comment|/* Reset the compression stream */
name|PNG_EXPORTA
argument_list|(
literal|10
argument_list|,
name|int
argument_list|,
name|png_reset_zstream
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_DEPRECATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) */
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|PNG_EXPORTA
argument_list|(
literal|11
argument_list|,
name|png_structp
argument_list|,
name|png_create_read_struct_2
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|,
name|png_voidp
name|mem_ptr
operator|,
name|png_malloc_ptr
name|malloc_fn
operator|,
name|png_free_ptr
name|free_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
name|PNG_EXPORTA
argument_list|(
literal|12
argument_list|,
name|png_structp
argument_list|,
name|png_create_write_struct_2
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|,
name|png_voidp
name|mem_ptr
operator|,
name|png_malloc_ptr
name|malloc_fn
operator|,
name|png_free_ptr
name|free_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write the PNG file signature. */
name|PNG_EXPORT
argument_list|(
literal|13
argument_list|,
name|void
argument_list|,
name|png_write_sig
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Write a PNG chunk - size, type, (optional) data, CRC. */
name|PNG_EXPORT
argument_list|(
literal|14
argument_list|,
name|void
argument_list|,
name|png_write_chunk
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|chunk_name
operator|,
name|png_const_bytep
name|data
operator|,
name|png_size_t
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the start of a PNG chunk - length and chunk name. */
name|PNG_EXPORT
argument_list|(
literal|15
argument_list|,
name|void
argument_list|,
name|png_write_chunk_start
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|chunk_name
operator|,
name|png_uint_32
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the data of a PNG chunk started with png_write_chunk_start(). */
name|PNG_EXPORT
argument_list|(
literal|16
argument_list|,
name|void
argument_list|,
name|png_write_chunk_data
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|data
operator|,
name|png_size_t
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* Finish a chunk started with png_write_chunk_start() (includes CRC). */
name|PNG_EXPORT
argument_list|(
literal|17
argument_list|,
name|void
argument_list|,
name|png_write_chunk_end
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize the info structure */
name|PNG_EXPORTA
argument_list|(
literal|18
argument_list|,
name|png_infop
argument_list|,
name|png_create_info_struct
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* DEPRECATED: this function allowed init structures to be created using the  * default allocation method (typically malloc).  Use is deprecated in 1.6.0 and  * the API will be removed in the future.  */
name|PNG_EXPORTA
argument_list|(
literal|19
argument_list|,
name|void
argument_list|,
name|png_info_init_3
argument_list|,
operator|(
name|png_infopp
name|info_ptr
operator|,
name|png_size_t
name|png_info_struct_size
operator|)
argument_list|,
name|PNG_DEPRECATED
argument_list|)
expr_stmt|;
comment|/* Writes all the PNG information before the image. */
name|PNG_EXPORT
argument_list|(
literal|20
argument_list|,
name|void
argument_list|,
name|png_write_info_before_PLTE
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|21
argument_list|,
name|void
argument_list|,
name|png_write_info
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read the information before the actual image data. */
name|PNG_EXPORT
argument_list|(
literal|22
argument_list|,
name|void
argument_list|,
name|png_read_info
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
comment|/* Convert to a US string format: there is no localization support in this     * routine.  The original implementation used a 29 character buffer in     * png_struct, this will be removed in future versions.     */
if|#
directive|if
name|PNG_LIBPNG_VER
operator|<
literal|10700
comment|/* To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) */
name|PNG_EXPORTA
argument_list|(
literal|23
argument_list|,
name|png_const_charp
argument_list|,
name|png_convert_to_rfc1123
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_timep
name|ptime
operator|)
argument_list|,
name|PNG_DEPRECATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|241
argument_list|,
name|int
argument_list|,
name|png_convert_to_rfc1123_buffer
argument_list|,
operator|(
name|char
name|out
index|[
literal|29
index|]
operator|,
name|png_const_timep
name|ptime
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_CONVERT_tIME_SUPPORTED
comment|/* Convert from a struct tm to png_time */
name|PNG_EXPORT
argument_list|(
literal|24
argument_list|,
name|void
argument_list|,
name|png_convert_from_struct_tm
argument_list|,
operator|(
name|png_timep
name|ptime
operator|,
specifier|const
expr|struct
name|tm
operator|*
name|ttime
operator|)
argument_list|)
expr_stmt|;
comment|/* Convert from time_t to png_time.  Uses gmtime() */
name|PNG_EXPORT
argument_list|(
literal|25
argument_list|,
name|void
argument_list|,
name|png_convert_from_time_t
argument_list|,
operator|(
name|png_timep
name|ptime
operator|,
name|time_t
name|ttime
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONVERT_tIME */
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
comment|/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
name|PNG_EXPORT
argument_list|(
literal|26
argument_list|,
name|void
argument_list|,
name|png_set_expand
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|27
argument_list|,
name|void
argument_list|,
name|png_set_expand_gray_1_2_4_to_8
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|28
argument_list|,
name|void
argument_list|,
name|png_set_palette_to_rgb
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|29
argument_list|,
name|void
argument_list|,
name|png_set_tRNS_to_alpha
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
comment|/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion  * of a tRNS chunk if present.  */
name|PNG_EXPORT
argument_list|(
literal|221
argument_list|,
name|void
argument_list|,
name|png_set_expand_16
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BGR_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_BGR_SUPPORTED
argument_list|)
comment|/* Use blue, green, red order for pixels. */
name|PNG_EXPORT
argument_list|(
literal|30
argument_list|,
name|void
argument_list|,
name|png_set_bgr
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
comment|/* Expand the grayscale to 24-bit RGB if necessary. */
name|PNG_EXPORT
argument_list|(
literal|31
argument_list|,
name|void
argument_list|,
name|png_set_gray_to_rgb
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
comment|/* Reduce RGB to grayscale. */
DECL|macro|PNG_ERROR_ACTION_NONE
define|#
directive|define
name|PNG_ERROR_ACTION_NONE
value|1
DECL|macro|PNG_ERROR_ACTION_WARN
define|#
directive|define
name|PNG_ERROR_ACTION_WARN
value|2
DECL|macro|PNG_ERROR_ACTION_ERROR
define|#
directive|define
name|PNG_ERROR_ACTION_ERROR
value|3
DECL|macro|PNG_RGB_TO_GRAY_DEFAULT
define|#
directive|define
name|PNG_RGB_TO_GRAY_DEFAULT
value|(-1)
comment|/*for red/green coefficients*/
name|PNG_FP_EXPORT
argument_list|(
literal|32
argument_list|,
argument|void
argument_list|,
argument|png_set_rgb_to_gray
argument_list|,
argument|(png_structrp png_ptr,     int error_action, double red, double green)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|33
argument_list|,
argument|void
argument_list|,
argument|png_set_rgb_to_gray_fixed
argument_list|,
argument|(png_structrp png_ptr,     int error_action, png_fixed_point red, png_fixed_point green)
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|34
argument_list|,
name|png_byte
argument_list|,
name|png_get_rgb_to_gray_status
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|35
argument_list|,
name|void
argument_list|,
name|png_build_grayscale_palette
argument_list|,
operator|(
name|int
name|bit_depth
operator|,
name|png_colorp
name|palette
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_ALPHA_MODE_SUPPORTED
comment|/* How the alpha channel is interpreted - this affects how the color channels  * of a PNG file are returned to the calling application when an alpha channel,  * or a tRNS chunk in a palette file, is present.  *  * This has no effect on the way pixels are written into a PNG output  * datastream. The color samples in a PNG datastream are never premultiplied  * with the alpha samples.  *  * The default is to return data according to the PNG specification: the alpha  * channel is a linear measure of the contribution of the pixel to the  * corresponding composited pixel, and the color channels are unassociated  * (not premultiplied).  The gamma encoded color channels must be scaled  * according to the contribution and to do this it is necessary to undo  * the encoding, scale the color values, perform the composition and reencode  * the values.  This is the 'PNG' mode.  *  * The alternative is to 'associate' the alpha with the color information by  * storing color channel values that have been scaled by the alpha.  * image.  These are the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' modes  * (the latter being the two common names for associated alpha color channels).  *  * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha  * value is equal to the maximum value.  *  * The final choice is to gamma encode the alpha channel as well.  This is  * broken because, in practice, no implementation that uses this choice  * correctly undoes the encoding before handling alpha composition.  Use this  * choice only if other serious errors in the software or hardware you use  * mandate it; the typical serious error is for dark halos to appear around  * opaque areas of the composited PNG image because of arithmetic overflow.  *  * The API function png_set_alpha_mode specifies which of these choices to use  * with an enumerated 'mode' value and the gamma of the required output:  */
DECL|macro|PNG_ALPHA_PNG
define|#
directive|define
name|PNG_ALPHA_PNG
value|0
comment|/* according to the PNG standard */
DECL|macro|PNG_ALPHA_STANDARD
define|#
directive|define
name|PNG_ALPHA_STANDARD
value|1
comment|/* according to Porter/Duff */
DECL|macro|PNG_ALPHA_ASSOCIATED
define|#
directive|define
name|PNG_ALPHA_ASSOCIATED
value|1
comment|/* as above; this is the normal practice */
DECL|macro|PNG_ALPHA_PREMULTIPLIED
define|#
directive|define
name|PNG_ALPHA_PREMULTIPLIED
value|1
comment|/* as above */
DECL|macro|PNG_ALPHA_OPTIMIZED
define|#
directive|define
name|PNG_ALPHA_OPTIMIZED
value|2
comment|/* 'PNG' for opaque pixels, else 'STANDARD' */
DECL|macro|PNG_ALPHA_BROKEN
define|#
directive|define
name|PNG_ALPHA_BROKEN
value|3
comment|/* the alpha channel is gamma encoded */
name|PNG_FP_EXPORT
argument_list|(
literal|227
argument_list|,
argument|void
argument_list|,
argument|png_set_alpha_mode
argument_list|,
argument|(png_structrp png_ptr, int mode,     double output_gamma)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|228
argument_list|,
argument|void
argument_list|,
argument|png_set_alpha_mode_fixed
argument_list|,
argument|(png_structrp png_ptr,     int mode, png_fixed_point output_gamma)
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_GAMMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
comment|/* The output_gamma value is a screen gamma in libpng terminology: it expresses  * how to decode the output values, not how they are encoded.  */
DECL|macro|PNG_DEFAULT_sRGB
define|#
directive|define
name|PNG_DEFAULT_sRGB
value|-1
comment|/* sRGB gamma and color space */
DECL|macro|PNG_GAMMA_MAC_18
define|#
directive|define
name|PNG_GAMMA_MAC_18
value|-2
comment|/* Old Mac '1.8' gamma and color space */
DECL|macro|PNG_GAMMA_sRGB
define|#
directive|define
name|PNG_GAMMA_sRGB
value|220000
comment|/* Television standards--matches sRGB gamma */
DECL|macro|PNG_GAMMA_LINEAR
define|#
directive|define
name|PNG_GAMMA_LINEAR
value|PNG_FP_1
comment|/* Linear */
endif|#
directive|endif
comment|/* The following are examples of calls to png_set_alpha_mode to achieve the  * required overall gamma correction and, where necessary, alpha  * premultiplication.  *  * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);  *    This is the default libpng handling of the alpha channel - it is not  *    pre-multiplied into the color components.  In addition the call states  *    that the output is for a sRGB system and causes all PNG files without gAMA  *    chunks to be assumed to be encoded using sRGB.  *  * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);  *    In this case the output is assumed to be something like an sRGB conformant  *    display preceeded by a power-law lookup table of power 1.45.  This is how  *    early Mac systems behaved.  *  * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);  *    This is the classic Jim Blinn approach and will work in academic  *    environments where everything is done by the book.  It has the shortcoming  *    of assuming that input PNG data with no gamma information is linear - this  *    is unlikely to be correct unless the PNG files where generated locally.  *    Most of the time the output precision will be so low as to show  *    significant banding in dark areas of the image.  *  * png_set_expand_16(pp);  * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);  *    This is a somewhat more realistic Jim Blinn inspired approach.  PNG files  *    are assumed to have the sRGB encoding if not marked with a gamma value and  *    the output is always 16 bits per component.  This permits accurate scaling  *    and processing of the data.  If you know that your input PNG files were  *    generated locally you might need to replace PNG_DEFAULT_sRGB with the  *    correct value for your system.  *  * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);  *    If you just need to composite the PNG image onto an existing background  *    and if you control the code that does this you can use the optimization  *    setting.  In this case you just copy completely opaque pixels to the  *    output.  For pixels that are not completely transparent (you just skip  *    those) you do the composition math using png_composite or png_composite_16  *    below then encode the resultant 8-bit or 16-bit values to match the output  *    encoding.  *  * Other cases  *    If neither the PNG nor the standard linear encoding work for you because  *    of the software or hardware you use then you have a big problem.  The PNG  *    case will probably result in halos around the image.  The linear encoding  *    will probably result in a washed out, too bright, image (it's actually too  *    contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably  *    substantially reduce the halos.  Alternatively try:  *  * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);  *    This option will also reduce the halos, but there will be slight dark  *    halos round the opaque parts of the image where the background is light.  *    In the OPTIMIZED mode the halos will be light halos where the background  *    is dark.  Take your pick - the halos are unavoidable unless you can get  *    your hardware/software fixed!  (The OPTIMIZED approach is slightly  *    faster.)  *  * When the default gamma of PNG files doesn't match the output gamma.  *    If you have PNG files with no gamma information png_set_alpha_mode allows  *    you to provide a default gamma, but it also sets the ouput gamma to the  *    matching value.  If you know your PNG files have a gamma that doesn't  *    match the output you can take advantage of the fact that  *    png_set_alpha_mode always sets the output gamma but only sets the PNG  *    default if it is not already set:  *  * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);  * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);  *    The first call sets both the default and the output gamma values, the  *    second call overrides the output gamma without changing the default.  This  *    is easier than achieving the same effect with png_set_gamma.  You must use  *    PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will  *    fire if more than one call to png_set_alpha_mode and png_set_background is  *    made in the same read operation, however multiple calls with PNG_ALPHA_PNG  *    are ignored.  */
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|36
argument_list|,
name|void
argument_list|,
name|png_set_strip_alpha
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SWAP_ALPHA_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_SWAP_ALPHA_SUPPORTED
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|37
argument_list|,
name|void
argument_list|,
name|png_set_swap_alpha
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INVERT_ALPHA_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_INVERT_ALPHA_SUPPORTED
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|38
argument_list|,
name|void
argument_list|,
name|png_set_invert_alpha
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_FILLER_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_FILLER_SUPPORTED
argument_list|)
comment|/* Add a filler byte to 8-bit Gray or 24-bit RGB images. */
name|PNG_EXPORT
argument_list|(
literal|39
argument_list|,
name|void
argument_list|,
name|png_set_filler
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|filler
operator|,
name|int
name|flags
operator|)
argument_list|)
expr_stmt|;
comment|/* The values of the PNG_FILLER_ defines should NOT be changed */
DECL|macro|PNG_FILLER_BEFORE
define|#
directive|define
name|PNG_FILLER_BEFORE
value|0
DECL|macro|PNG_FILLER_AFTER
define|#
directive|define
name|PNG_FILLER_AFTER
value|1
comment|/* Add an alpha byte to 8-bit Gray or 24-bit RGB images. */
name|PNG_EXPORT
argument_list|(
literal|40
argument_list|,
name|void
argument_list|,
name|png_set_add_alpha
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|filler
operator|,
name|int
name|flags
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* READ_FILLER || WRITE_FILLER */
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SWAP_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SWAP_SUPPORTED
argument_list|)
comment|/* Swap bytes in 16-bit depth files. */
name|PNG_EXPORT
argument_list|(
literal|41
argument_list|,
name|void
argument_list|,
name|png_set_swap
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_PACK_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_PACK_SUPPORTED
argument_list|)
comment|/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
name|PNG_EXPORT
argument_list|(
literal|42
argument_list|,
name|void
argument_list|,
name|png_set_packing
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_PACKSWAP_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_PACKSWAP_SUPPORTED
argument_list|)
comment|/* Swap packing order of pixels in bytes. */
name|PNG_EXPORT
argument_list|(
literal|43
argument_list|,
name|void
argument_list|,
name|png_set_packswap
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SHIFT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SHIFT_SUPPORTED
argument_list|)
comment|/* Converts files to legal bit depths. */
name|PNG_EXPORT
argument_list|(
literal|44
argument_list|,
name|void
argument_list|,
name|png_set_shift
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_color_8p
name|true_bits
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INTERLACING_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_INTERLACING_SUPPORTED
argument_list|)
comment|/* Have the code handle the interlacing.  Returns the number of passes.  * MUST be called before png_read_update_info or png_start_read_image,  * otherwise it will not have the desired effect.  Note that it is still  * necessary to call png_read_row or png_read_rows png_get_image_height  * times for each pass. */
name|PNG_EXPORT
argument_list|(
literal|45
argument_list|,
name|int
argument_list|,
name|png_set_interlace_handling
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INVERT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_INVERT_SUPPORTED
argument_list|)
comment|/* Invert monochrome files */
name|PNG_EXPORT
argument_list|(
literal|46
argument_list|,
name|void
argument_list|,
name|png_set_invert_mono
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
comment|/* Handle alpha and tRNS by replacing with a background color.  Prior to  * libpng-1.5.4 this API must not be called before the PNG file header has been  * read.  Doing so will result in unexpected behavior and possible warnings or  * errors if the PNG file contains a bKGD chunk.  */
name|PNG_FP_EXPORT
argument_list|(
literal|47
argument_list|,
argument|void
argument_list|,
argument|png_set_background
argument_list|,
argument|(png_structrp png_ptr,     png_const_color_16p background_color, int background_gamma_code,     int need_expand, double background_gamma)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|215
argument_list|,
argument|void
argument_list|,
argument|png_set_background_fixed
argument_list|,
argument|(png_structrp png_ptr,     png_const_color_16p background_color, int background_gamma_code,     int need_expand, png_fixed_point background_gamma)
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
DECL|macro|PNG_BACKGROUND_GAMMA_UNKNOWN
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_UNKNOWN
value|0
DECL|macro|PNG_BACKGROUND_GAMMA_SCREEN
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_SCREEN
value|1
DECL|macro|PNG_BACKGROUND_GAMMA_FILE
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_FILE
value|2
DECL|macro|PNG_BACKGROUND_GAMMA_UNIQUE
define|#
directive|define
name|PNG_BACKGROUND_GAMMA_UNIQUE
value|3
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
comment|/* Scale a 16-bit depth file down to 8-bit, accurately. */
name|PNG_EXPORT
argument_list|(
literal|229
argument_list|,
name|void
argument_list|,
name|png_set_scale_16
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
DECL|macro|PNG_READ_16_TO_8
define|#
directive|define
name|PNG_READ_16_TO_8
value|SUPPORTED
comment|/* Name prior to 1.5.4 */
comment|/* Strip the second byte of information from a 16-bit depth file. */
name|PNG_EXPORT
argument_list|(
literal|48
argument_list|,
name|void
argument_list|,
name|png_set_strip_16
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
comment|/* Turn on quantizing, and reduce the palette to the number of colors  * available.  */
name|PNG_EXPORT
argument_list|(
literal|49
argument_list|,
name|void
argument_list|,
name|png_set_quantize
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_colorp
name|palette
operator|,
name|int
name|num_palette
operator|,
name|int
name|maximum_colors
operator|,
name|png_const_uint_16p
name|histogram
operator|,
name|int
name|full_quantize
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* The threshold on gamma processing is configurable but hard-wired into the  * library.  The following is the floating point variant.  */
DECL|macro|PNG_GAMMA_THRESHOLD
define|#
directive|define
name|PNG_GAMMA_THRESHOLD
value|(PNG_GAMMA_THRESHOLD_FIXED*.00001)
comment|/* Handle gamma correction. Screen_gamma=(display_exponent).  * NOTE: this API simply sets the screen and file gamma values. It will  * therefore override the value for gamma in a PNG file if it is called after  * the file header has been read - use with care  - call before reading the PNG  * file for best results!  *  * These routines accept the same gamma values as png_set_alpha_mode (described  * above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either  * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value  * is the inverse of a 'screen gamma' value.  */
name|PNG_FP_EXPORT
argument_list|(
literal|50
argument_list|,
argument|void
argument_list|,
argument|png_set_gamma
argument_list|,
argument|(png_structrp png_ptr,     double screen_gamma, double override_file_gamma)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|208
argument_list|,
argument|void
argument_list|,
argument|png_set_gamma_fixed
argument_list|,
argument|(png_structrp png_ptr,     png_fixed_point screen_gamma, png_fixed_point override_file_gamma)
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
comment|/* Set how many lines between output flushes - 0 for no flushing */
name|PNG_EXPORT
argument_list|(
literal|51
argument_list|,
name|void
argument_list|,
name|png_set_flush
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|nrows
operator|)
argument_list|)
expr_stmt|;
comment|/* Flush the current PNG output buffer */
name|PNG_EXPORT
argument_list|(
literal|52
argument_list|,
name|void
argument_list|,
name|png_write_flush
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Optional update palette with requested transformations */
name|PNG_EXPORT
argument_list|(
literal|53
argument_list|,
name|void
argument_list|,
name|png_start_read_image
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Optional call to update the users info structure */
name|PNG_EXPORT
argument_list|(
literal|54
argument_list|,
name|void
argument_list|,
name|png_read_update_info
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read one or more rows of image data. */
name|PNG_EXPORT
argument_list|(
literal|55
argument_list|,
name|void
argument_list|,
name|png_read_rows
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytepp
name|row
operator|,
name|png_bytepp
name|display_row
operator|,
name|png_uint_32
name|num_rows
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read a row of data. */
name|PNG_EXPORT
argument_list|(
literal|56
argument_list|,
name|void
argument_list|,
name|png_read_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytep
name|row
operator|,
name|png_bytep
name|display_row
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read the whole image into memory at once. */
name|PNG_EXPORT
argument_list|(
literal|57
argument_list|,
name|void
argument_list|,
name|png_read_image
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytepp
name|image
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write a row of image data */
name|PNG_EXPORT
argument_list|(
literal|58
argument_list|,
name|void
argument_list|,
name|png_write_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|row
operator|)
argument_list|)
expr_stmt|;
comment|/* Write a few rows of image data: (*row) is not written; however, the type  * is declared as writeable to maintain compatibility with previous versions  * of libpng and to allow the 'display_row' array from read_rows to be passed  * unchanged to write_rows.  */
name|PNG_EXPORT
argument_list|(
literal|59
argument_list|,
name|void
argument_list|,
name|png_write_rows
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytepp
name|row
operator|,
name|png_uint_32
name|num_rows
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the image data */
name|PNG_EXPORT
argument_list|(
literal|60
argument_list|,
name|void
argument_list|,
name|png_write_image
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytepp
name|image
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the end of the PNG file. */
name|PNG_EXPORT
argument_list|(
literal|61
argument_list|,
name|void
argument_list|,
name|png_write_end
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
comment|/* Read the end of the PNG file. */
name|PNG_EXPORT
argument_list|(
literal|62
argument_list|,
name|void
argument_list|,
name|png_read_end
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Free any memory associated with the png_info_struct */
name|PNG_EXPORT
argument_list|(
literal|63
argument_list|,
name|void
argument_list|,
name|png_destroy_info_struct
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_infopp
name|info_ptr_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Free any memory associated with the png_struct and the png_info_structs */
name|PNG_EXPORT
argument_list|(
literal|64
argument_list|,
name|void
argument_list|,
name|png_destroy_read_struct
argument_list|,
operator|(
name|png_structpp
name|png_ptr_ptr
operator|,
name|png_infopp
name|info_ptr_ptr
operator|,
name|png_infopp
name|end_info_ptr_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Free any memory associated with the png_struct and the png_info_structs */
name|PNG_EXPORT
argument_list|(
literal|65
argument_list|,
name|void
argument_list|,
name|png_destroy_write_struct
argument_list|,
operator|(
name|png_structpp
name|png_ptr_ptr
operator|,
name|png_infopp
name|info_ptr_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the libpng method of handling chunk CRC errors */
name|PNG_EXPORT
argument_list|(
literal|66
argument_list|,
name|void
argument_list|,
name|png_set_crc_action
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|crit_action
operator|,
name|int
name|ancil_action
operator|)
argument_list|)
expr_stmt|;
comment|/* Values for png_set_crc_action() say how to handle CRC errors in  * ancillary and critical chunks, and whether to use the data contained  * therein.  Note that it is impossible to "discard" data in a critical  * chunk.  For versions prior to 0.90, the action was always error/quit,  * whereas in version 0.90 and later, the action for CRC errors in ancillary  * chunks is warn/discard.  These values should NOT be changed.  *  *      value                       action:critical     action:ancillary  */
DECL|macro|PNG_CRC_DEFAULT
define|#
directive|define
name|PNG_CRC_DEFAULT
value|0
comment|/* error/quit          warn/discard data */
DECL|macro|PNG_CRC_ERROR_QUIT
define|#
directive|define
name|PNG_CRC_ERROR_QUIT
value|1
comment|/* error/quit          error/quit        */
DECL|macro|PNG_CRC_WARN_DISCARD
define|#
directive|define
name|PNG_CRC_WARN_DISCARD
value|2
comment|/* (INVALID)           warn/discard data */
DECL|macro|PNG_CRC_WARN_USE
define|#
directive|define
name|PNG_CRC_WARN_USE
value|3
comment|/* warn/use data       warn/use data     */
DECL|macro|PNG_CRC_QUIET_USE
define|#
directive|define
name|PNG_CRC_QUIET_USE
value|4
comment|/* quiet/use data      quiet/use data    */
DECL|macro|PNG_CRC_NO_CHANGE
define|#
directive|define
name|PNG_CRC_NO_CHANGE
value|5
comment|/* use current value   use current value */
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
comment|/* These functions give the user control over the scan-line filtering in  * libpng and the compression methods used by zlib.  These functions are  * mainly useful for testing, as the defaults should work with most users.  * Those users who are tight on memory or want faster performance at the  * expense of compression can modify them.  See the compression library  * header file (zlib.h) for an explination of the compression functions.  */
comment|/* Set the filtering method(s) used by libpng.  Currently, the only valid  * value for "method" is 0.  */
name|PNG_EXPORT
argument_list|(
literal|67
argument_list|,
name|void
argument_list|,
name|png_set_filter
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|method
operator|,
name|int
name|filters
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WRITE */
comment|/* Flags for png_set_filter() to say which filters to use.  The flags  * are chosen so that they don't conflict with real filter types  * below, in case they are supplied instead of the #defined constants.  * These values should NOT be changed.  */
DECL|macro|PNG_NO_FILTERS
define|#
directive|define
name|PNG_NO_FILTERS
value|0x00
DECL|macro|PNG_FILTER_NONE
define|#
directive|define
name|PNG_FILTER_NONE
value|0x08
DECL|macro|PNG_FILTER_SUB
define|#
directive|define
name|PNG_FILTER_SUB
value|0x10
DECL|macro|PNG_FILTER_UP
define|#
directive|define
name|PNG_FILTER_UP
value|0x20
DECL|macro|PNG_FILTER_AVG
define|#
directive|define
name|PNG_FILTER_AVG
value|0x40
DECL|macro|PNG_FILTER_PAETH
define|#
directive|define
name|PNG_FILTER_PAETH
value|0x80
DECL|macro|PNG_ALL_FILTERS
define|#
directive|define
name|PNG_ALL_FILTERS
value|(PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP | \                          PNG_FILTER_AVG | PNG_FILTER_PAETH)
comment|/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.  * These defines should NOT be changed.  */
DECL|macro|PNG_FILTER_VALUE_NONE
define|#
directive|define
name|PNG_FILTER_VALUE_NONE
value|0
DECL|macro|PNG_FILTER_VALUE_SUB
define|#
directive|define
name|PNG_FILTER_VALUE_SUB
value|1
DECL|macro|PNG_FILTER_VALUE_UP
define|#
directive|define
name|PNG_FILTER_VALUE_UP
value|2
DECL|macro|PNG_FILTER_VALUE_AVG
define|#
directive|define
name|PNG_FILTER_VALUE_AVG
value|3
DECL|macro|PNG_FILTER_VALUE_PAETH
define|#
directive|define
name|PNG_FILTER_VALUE_PAETH
value|4
DECL|macro|PNG_FILTER_VALUE_LAST
define|#
directive|define
name|PNG_FILTER_VALUE_LAST
value|5
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* EXPERIMENTAL */
comment|/* The "heuristic_method" is given by one of the PNG_FILTER_HEURISTIC_  * defines, either the default (minimum-sum-of-absolute-differences), or  * the experimental method (weighted-minimum-sum-of-absolute-differences).  *  * Weights are factors>= 1.0, indicating how important it is to keep the  * filter type consistent between rows.  Larger numbers mean the current  * filter is that many times as likely to be the same as the "num_weights"  * previous filters.  This is cumulative for each previous row with a weight.  * There needs to be "num_weights" values in "filter_weights", or it can be  * NULL if the weights aren't being specified.  Weights have no influence on  * the selection of the first row filter.  Well chosen weights can (in theory)  * improve the compression for a given image.  *  * Costs are factors>= 1.0 indicating the relative decoding costs of a  * filter type.  Higher costs indicate more decoding expense, and are  * therefore less likely to be selected over a filter with lower computational  * costs.  There needs to be a value in "filter_costs" for each valid filter  * type (given by PNG_FILTER_VALUE_LAST), or it can be NULL if you aren't  * setting the costs.  Costs try to improve the speed of decompression without  * unduly increasing the compressed image size.  *  * A negative weight or cost indicates the default value is to be used, and  * values in the range [0.0, 1.0) indicate the value is to remain unchanged.  * The default values for both weights and costs are currently 1.0, but may  * change if good general weighting/cost heuristics can be found.  If both  * the weights and costs are set to 1.0, this degenerates the WEIGHTED method  * to the UNWEIGHTED method, but with added encoding time/computation.  */
name|PNG_FP_EXPORT
argument_list|(
literal|68
argument_list|,
argument|void
argument_list|,
argument|png_set_filter_heuristics
argument_list|,
argument|(png_structrp png_ptr,     int heuristic_method, int num_weights, png_const_doublep filter_weights,     png_const_doublep filter_costs)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|209
argument_list|,
argument|void
argument_list|,
argument|png_set_filter_heuristics_fixed
argument_list|,
argument|(png_structrp png_ptr, int heuristic_method, int num_weights,     png_const_fixed_point_p filter_weights,     png_const_fixed_point_p filter_costs)
argument_list|)
endif|#
directive|endif
comment|/* WRITE_WEIGHTED_FILTER */
comment|/* Heuristic used for row filter selection.  These defines should NOT be  * changed.  */
DECL|macro|PNG_FILTER_HEURISTIC_DEFAULT
define|#
directive|define
name|PNG_FILTER_HEURISTIC_DEFAULT
value|0
comment|/* Currently "UNWEIGHTED" */
DECL|macro|PNG_FILTER_HEURISTIC_UNWEIGHTED
define|#
directive|define
name|PNG_FILTER_HEURISTIC_UNWEIGHTED
value|1
comment|/* Used by libpng< 0.95 */
DECL|macro|PNG_FILTER_HEURISTIC_WEIGHTED
define|#
directive|define
name|PNG_FILTER_HEURISTIC_WEIGHTED
value|2
comment|/* Experimental feature */
DECL|macro|PNG_FILTER_HEURISTIC_LAST
define|#
directive|define
name|PNG_FILTER_HEURISTIC_LAST
value|3
comment|/* Not a valid value */
comment|/* Set the library compression level.  Currently, valid values range from  * 0 - 9, corresponding directly to the zlib compression levels 0 - 9  * (0 - no compression, 9 - "maximal" compression).  Note that tests have  * shown that zlib compression levels 3-6 usually perform as well as level 9  * for PNG images, and do considerably fewer caclulations.  In the future,  * these values may not correspond directly to the zlib compression levels.  */
ifdef|#
directive|ifdef
name|PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|69
argument_list|,
name|void
argument_list|,
name|png_set_compression_level
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|level
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|70
argument_list|,
name|void
argument_list|,
name|png_set_compression_mem_level
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|mem_level
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|71
argument_list|,
name|void
argument_list|,
name|png_set_compression_strategy
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|strategy
operator|)
argument_list|)
expr_stmt|;
comment|/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a  * smaller value of window_bits if it can do so safely.  */
name|PNG_EXPORT
argument_list|(
literal|72
argument_list|,
name|void
argument_list|,
name|png_set_compression_window_bits
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|window_bits
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|73
argument_list|,
name|void
argument_list|,
name|png_set_compression_method
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|method
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WRITE_CUSTOMIZE_COMPRESSION */
ifdef|#
directive|ifdef
name|PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
comment|/* Also set zlib parameters for compressing non-IDAT chunks */
name|PNG_EXPORT
argument_list|(
literal|222
argument_list|,
name|void
argument_list|,
name|png_set_text_compression_level
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|level
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|223
argument_list|,
name|void
argument_list|,
name|png_set_text_compression_mem_level
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|mem_level
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|224
argument_list|,
name|void
argument_list|,
name|png_set_text_compression_strategy
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|strategy
operator|)
argument_list|)
expr_stmt|;
comment|/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a  * smaller value of window_bits if it can do so safely.  */
name|PNG_EXPORT
argument_list|(
literal|225
argument_list|,
name|void
argument_list|,
name|png_set_text_compression_window_bits
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|window_bits
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|226
argument_list|,
name|void
argument_list|,
name|png_set_text_compression_method
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|method
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
endif|#
directive|endif
comment|/* WRITE */
comment|/* These next functions are called for input/output, memory, and error  * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,  * and call standard C I/O routines such as fread(), fwrite(), and  * fprintf().  These functions can be made to use other I/O routines  * at run time for those applications that need to handle I/O in a  * different manner by calling png_set_???_fn().  See libpng-manual.txt for  * more information.  */
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
comment|/* Initialize the input/output for the PNG file to the default functions. */
name|PNG_EXPORT
argument_list|(
literal|74
argument_list|,
name|void
argument_list|,
name|png_init_io
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_FILE_p
name|fp
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Replace the (error and abort), and warning functions with user  * supplied functions.  If no messages are to be printed you must still  * write and use replacement functions. The replacement error_fn should  * still do a longjmp to the last setjmp location if you are using this  * method of error handling.  If error_fn or warning_fn is NULL, the  * default function will be used.  */
name|PNG_EXPORT
argument_list|(
literal|75
argument_list|,
name|void
argument_list|,
name|png_set_error_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warning_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the error functions */
name|PNG_EXPORT
argument_list|(
literal|76
argument_list|,
name|png_voidp
argument_list|,
name|png_get_error_ptr
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Replace the default data output functions with a user supplied one(s).  * If buffered output is not used, then output_flush_fn can be set to NULL.  * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time  * output_flush_fn will be ignored (and thus can be NULL).  * It is probably a mistake to use NULL for output_flush_fn if  * write_data_fn is not also NULL unless you have built libpng with  * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's  * default flush function, which uses the standard *FILE structure, will  * be used.  */
name|PNG_EXPORT
argument_list|(
literal|77
argument_list|,
name|void
argument_list|,
name|png_set_write_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_voidp
name|io_ptr
operator|,
name|png_rw_ptr
name|write_data_fn
operator|,
name|png_flush_ptr
name|output_flush_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Replace the default data input function with a user supplied one. */
name|PNG_EXPORT
argument_list|(
literal|78
argument_list|,
name|void
argument_list|,
name|png_set_read_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_voidp
name|io_ptr
operator|,
name|png_rw_ptr
name|read_data_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the I/O functions */
name|PNG_EXPORT
argument_list|(
literal|79
argument_list|,
name|png_voidp
argument_list|,
name|png_get_io_ptr
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|80
argument_list|,
name|void
argument_list|,
name|png_set_read_status_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_read_status_ptr
name|read_row_fn
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|81
argument_list|,
name|void
argument_list|,
name|png_set_write_status_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_write_status_ptr
name|write_row_fn
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
comment|/* Replace the default memory allocation functions with user supplied one(s). */
name|PNG_EXPORT
argument_list|(
literal|82
argument_list|,
name|void
argument_list|,
name|png_set_mem_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_voidp
name|mem_ptr
operator|,
name|png_malloc_ptr
name|malloc_fn
operator|,
name|png_free_ptr
name|free_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the memory functions */
name|PNG_EXPORT
argument_list|(
literal|83
argument_list|,
name|png_voidp
argument_list|,
name|png_get_mem_ptr
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|84
argument_list|,
name|void
argument_list|,
name|png_set_read_user_transform_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_user_transform_ptr
name|read_user_transform_fn
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|85
argument_list|,
name|void
argument_list|,
name|png_set_write_user_transform_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_user_transform_ptr
name|write_user_transform_fn
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_TRANSFORM_PTR_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|86
argument_list|,
name|void
argument_list|,
name|png_set_user_transform_info
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_voidp
name|user_transform_ptr
operator|,
name|int
name|user_transform_depth
operator|,
name|int
name|user_transform_channels
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the user pointer associated with the user transform functions */
name|PNG_EXPORT
argument_list|(
literal|87
argument_list|,
name|png_voidp
argument_list|,
name|png_get_user_transform_ptr
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_TRANSFORM_INFO_SUPPORTED
comment|/* Return information about the row currently being processed.  Note that these  * APIs do not fail but will return unexpected results if called outside a user  * transform callback.  Also note that when transforming an interlaced image the  * row number is the row number within the sub-image of the interlace pass, so  * the value will increase to the height of the sub-image (not the full image)  * then reset to 0 for the next pass.  *  * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to  * find the output pixel (x,y) given an interlaced sub-image pixel  * (row,col,pass).  (See below for these macros.)  */
name|PNG_EXPORT
argument_list|(
literal|217
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_current_row_number
argument_list|,
operator|(
name|png_const_structrp
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|218
argument_list|,
name|png_byte
argument_list|,
name|png_get_current_pass_number
argument_list|,
operator|(
name|png_const_structrp
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
comment|/* This callback is called only for *unknown* chunks.  If  * PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known  * chunks to be treated as unknown, however in this case the callback must do  * any processing required by the chunk (e.g. by calling the appropriate  * png_set_ APIs.)  *  * There is no write support - on write, by default, all the chunks in the  * 'unknown' list are written in the specified position.  *  * The integer return from the callback function is interpreted thus:  *  * negative: An error occurred; png_chunk_error will be called.  *     zero: The chunk was not handled, the chunk will be saved. A critical  *           chunk will cause an error at this point unless it is to be saved.  * positive: The chunk was handled, libpng will ignore/discard it.  *  * See "INTERACTION WTIH USER CHUNK CALLBACKS" below for important notes about  * how this behavior will change in libpng 1.7  */
name|PNG_EXPORT
argument_list|(
literal|88
argument_list|,
name|void
argument_list|,
name|png_set_read_user_chunk_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_voidp
name|user_chunk_ptr
operator|,
name|png_user_chunk_ptr
name|read_user_chunk_fn
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_CHUNKS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|89
argument_list|,
name|png_voidp
argument_list|,
name|png_get_user_chunk_ptr
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
comment|/* Sets the function callbacks for the push reader, and a pointer to a  * user-defined structure available to the callback functions.  */
name|PNG_EXPORT
argument_list|(
literal|90
argument_list|,
name|void
argument_list|,
name|png_set_progressive_read_fn
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_voidp
name|progressive_ptr
operator|,
name|png_progressive_info_ptr
name|info_fn
operator|,
name|png_progressive_row_ptr
name|row_fn
operator|,
name|png_progressive_end_ptr
name|end_fn
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns the user pointer associated with the push read functions */
name|PNG_EXPORT
argument_list|(
literal|91
argument_list|,
name|png_voidp
argument_list|,
name|png_get_progressive_ptr
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Function to be called when data becomes available */
name|PNG_EXPORT
argument_list|(
literal|92
argument_list|,
name|void
argument_list|,
name|png_process_data
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_bytep
name|buffer
operator|,
name|png_size_t
name|buffer_size
operator|)
argument_list|)
expr_stmt|;
comment|/* A function which may be called *only* within png_process_data to stop the  * processing of any more data.  The function returns the number of bytes  * remaining, excluding any that libpng has cached internally.  A subsequent  * call to png_process_data must supply these bytes again.  If the argument  * 'save' is set to true the routine will first save all the pending data and  * will always return 0.  */
name|PNG_EXPORT
argument_list|(
literal|219
argument_list|,
name|png_size_t
argument_list|,
name|png_process_data_pause
argument_list|,
operator|(
name|png_structrp
operator|,
name|int
name|save
operator|)
argument_list|)
expr_stmt|;
comment|/* A function which may be called *only* outside (after) a call to  * png_process_data.  It returns the number of bytes of data to skip in the  * input.  Normally it will return 0, but if it returns a non-zero value the  * application must skip than number of bytes of input data and pass the  * following data to the next call to png_process_data.  */
name|PNG_EXPORT
argument_list|(
literal|220
argument_list|,
name|png_uint_32
argument_list|,
name|png_process_data_skip
argument_list|,
operator|(
name|png_structrp
operator|)
argument_list|)
expr_stmt|;
comment|/* Function that combines rows.  'new_row' is a flag that should come from  * the callback and be non-NULL if anything needs to be done; the library  * stores its own version of the new data internally and ignores the passed  * in value.  */
name|PNG_EXPORT
argument_list|(
literal|93
argument_list|,
name|void
argument_list|,
name|png_progressive_combine_row
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_bytep
name|old_row
operator|,
name|png_const_bytep
name|new_row
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROGRESSIVE_READ */
name|PNG_EXPORTA
argument_list|(
literal|94
argument_list|,
name|png_voidp
argument_list|,
name|png_malloc
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Added at libpng version 1.4.0 */
name|PNG_EXPORTA
argument_list|(
literal|95
argument_list|,
name|png_voidp
argument_list|,
name|png_calloc
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Added at libpng version 1.2.4 */
name|PNG_EXPORTA
argument_list|(
literal|96
argument_list|,
name|png_voidp
argument_list|,
name|png_malloc_warn
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Frees a pointer allocated by png_malloc() */
name|PNG_EXPORT
argument_list|(
literal|97
argument_list|,
name|void
argument_list|,
name|png_free
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_voidp
name|ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Free data that was allocated internally */
name|PNG_EXPORT
argument_list|(
literal|98
argument_list|,
name|void
argument_list|,
name|png_free_data
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|free_me
operator|,
name|int
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* Reassign responsibility for freeing existing data, whether allocated  * by libpng or by the application; this works on the png_info structure passed  * in, it does not change the state for other png_info structures.  *  * It is unlikely that this function works correctly as of 1.6.0 and using it  * may result either in memory leaks or double free of allocated data.  */
name|PNG_EXPORT
argument_list|(
literal|99
argument_list|,
name|void
argument_list|,
name|png_data_freer
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|freer
operator|,
name|png_uint_32
name|mask
operator|)
argument_list|)
expr_stmt|;
comment|/* Assignments for png_data_freer */
DECL|macro|PNG_DESTROY_WILL_FREE_DATA
define|#
directive|define
name|PNG_DESTROY_WILL_FREE_DATA
value|1
DECL|macro|PNG_SET_WILL_FREE_DATA
define|#
directive|define
name|PNG_SET_WILL_FREE_DATA
value|1
DECL|macro|PNG_USER_WILL_FREE_DATA
define|#
directive|define
name|PNG_USER_WILL_FREE_DATA
value|2
comment|/* Flags for png_ptr->free_me and info_ptr->free_me */
DECL|macro|PNG_FREE_HIST
define|#
directive|define
name|PNG_FREE_HIST
value|0x0008
DECL|macro|PNG_FREE_ICCP
define|#
directive|define
name|PNG_FREE_ICCP
value|0x0010
DECL|macro|PNG_FREE_SPLT
define|#
directive|define
name|PNG_FREE_SPLT
value|0x0020
DECL|macro|PNG_FREE_ROWS
define|#
directive|define
name|PNG_FREE_ROWS
value|0x0040
DECL|macro|PNG_FREE_PCAL
define|#
directive|define
name|PNG_FREE_PCAL
value|0x0080
DECL|macro|PNG_FREE_SCAL
define|#
directive|define
name|PNG_FREE_SCAL
value|0x0100
ifdef|#
directive|ifdef
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
DECL|macro|PNG_FREE_UNKN
define|#
directive|define
name|PNG_FREE_UNKN
value|0x0200
endif|#
directive|endif
comment|/*      PNG_FREE_LIST 0x0400    removed in 1.6.0 because it is ignored */
DECL|macro|PNG_FREE_PLTE
define|#
directive|define
name|PNG_FREE_PLTE
value|0x1000
DECL|macro|PNG_FREE_TRNS
define|#
directive|define
name|PNG_FREE_TRNS
value|0x2000
DECL|macro|PNG_FREE_TEXT
define|#
directive|define
name|PNG_FREE_TEXT
value|0x4000
DECL|macro|PNG_FREE_ALL
define|#
directive|define
name|PNG_FREE_ALL
value|0x7fff
DECL|macro|PNG_FREE_MUL
define|#
directive|define
name|PNG_FREE_MUL
value|0x4220
comment|/* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|PNG_EXPORTA
argument_list|(
literal|100
argument_list|,
argument|png_voidp
argument_list|,
argument|png_malloc_default
argument_list|,
argument|(png_const_structrp png_ptr,     png_alloc_size_t size)
argument_list|,
argument|PNG_ALLOCATED PNG_DEPRECATED
argument_list|)
empty_stmt|;
name|PNG_EXPORTA
argument_list|(
literal|101
argument_list|,
name|void
argument_list|,
name|png_free_default
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_voidp
name|ptr
operator|)
argument_list|,
name|PNG_DEPRECATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_ERROR_TEXT_SUPPORTED
comment|/* Fatal error in PNG image of libpng - can't continue */
name|PNG_EXPORTA
argument_list|(
literal|102
argument_list|,
name|void
argument_list|,
name|png_error
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|error_message
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
comment|/* The same, but the chunk name is prepended to the error string. */
name|PNG_EXPORTA
argument_list|(
literal|103
argument_list|,
name|void
argument_list|,
name|png_chunk_error
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|error_message
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Fatal error in PNG image of libpng - can't continue */
name|PNG_EXPORTA
argument_list|(
literal|104
argument_list|,
name|void
argument_list|,
name|png_err
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
DECL|macro|png_error
define|#
directive|define
name|png_error
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|png_err(s1)
DECL|macro|png_chunk_error
define|#
directive|define
name|png_chunk_error
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|png_err(s1)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
comment|/* Non-fatal error in libpng.  Can continue, but may have a problem. */
name|PNG_EXPORT
argument_list|(
literal|105
argument_list|,
name|void
argument_list|,
name|png_warning
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
comment|/* Non-fatal error in libpng, chunk name is prepended to message. */
name|PNG_EXPORT
argument_list|(
literal|106
argument_list|,
name|void
argument_list|,
name|png_chunk_warning
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
DECL|macro|png_warning
define|#
directive|define
name|png_warning
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|((void)(s1))
DECL|macro|png_chunk_warning
define|#
directive|define
name|png_chunk_warning
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|((void)(s1))
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
comment|/* Benign error in libpng.  Can continue, but may have a problem.  * User can choose whether to handle as a fatal error or as a warning. */
name|PNG_EXPORT
argument_list|(
literal|107
argument_list|,
name|void
argument_list|,
name|png_benign_error
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
comment|/* Same, chunk name is prepended to message (only during read) */
name|PNG_EXPORT
argument_list|(
literal|108
argument_list|,
name|void
argument_list|,
name|png_chunk_benign_error
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|109
argument_list|,
name|void
argument_list|,
name|png_set_benign_errors
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|allowed
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PNG_ALLOW_BENIGN_ERRORS
DECL|macro|png_benign_error
define|#
directive|define
name|png_benign_error
value|png_warning
DECL|macro|png_chunk_benign_error
define|#
directive|define
name|png_chunk_benign_error
value|png_chunk_warning
else|#
directive|else
DECL|macro|png_benign_error
define|#
directive|define
name|png_benign_error
value|png_error
DECL|macro|png_chunk_benign_error
define|#
directive|define
name|png_chunk_benign_error
value|png_chunk_error
endif|#
directive|endif
endif|#
directive|endif
comment|/* The png_set_<chunk> functions are for storing values in the png_info_struct.  * Similarly, the png_get_<chunk> calls are used to read values from the  * png_info_struct, either storing the parameters in the passed variables, or  * setting pointers into the png_info_struct where the data is stored.  The  * png_get_<chunk> functions return a non-zero value if the data was available  * in info_ptr, or return zero and do not change any of the parameters if the  * data was not available.  *  * These functions should be used instead of directly accessing png_info  * to avoid problems with future changes in the size and internal layout of  * png_info_struct.  */
comment|/* Returns "flag" if chunk data is valid in info_ptr. */
name|PNG_EXPORT
argument_list|(
literal|110
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_valid
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|,
name|png_uint_32
name|flag
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns number of bytes needed to hold a transformed row. */
name|PNG_EXPORT
argument_list|(
literal|111
argument_list|,
name|png_size_t
argument_list|,
name|png_get_rowbytes
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
comment|/* Returns row_pointers, which is an array of pointers to scanlines that was  * returned from png_read_png().  */
name|PNG_EXPORT
argument_list|(
literal|112
argument_list|,
name|png_bytepp
argument_list|,
name|png_get_rows
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Set row_pointers, which is an array of pointers to scanlines for use  * by png_write_png().  */
name|PNG_EXPORT
argument_list|(
literal|113
argument_list|,
name|void
argument_list|,
name|png_set_rows
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_bytepp
name|row_pointers
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Returns number of color channels in image. */
name|PNG_EXPORT
argument_list|(
literal|114
argument_list|,
name|png_byte
argument_list|,
name|png_get_channels
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_EASY_ACCESS_SUPPORTED
comment|/* Returns image width in pixels. */
name|PNG_EXPORT
argument_list|(
literal|115
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_image_width
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image height in pixels. */
name|PNG_EXPORT
argument_list|(
literal|116
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_image_height
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image bit_depth. */
name|PNG_EXPORT
argument_list|(
literal|117
argument_list|,
name|png_byte
argument_list|,
name|png_get_bit_depth
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image color_type. */
name|PNG_EXPORT
argument_list|(
literal|118
argument_list|,
name|png_byte
argument_list|,
name|png_get_color_type
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image filter_type. */
name|PNG_EXPORT
argument_list|(
literal|119
argument_list|,
name|png_byte
argument_list|,
name|png_get_filter_type
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image interlace_type. */
name|PNG_EXPORT
argument_list|(
literal|120
argument_list|,
name|png_byte
argument_list|,
name|png_get_interlace_type
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image compression_type. */
name|PNG_EXPORT
argument_list|(
literal|121
argument_list|,
name|png_byte
argument_list|,
name|png_get_compression_type
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns image resolution in pixels per meter, from pHYs chunk data. */
name|PNG_EXPORT
argument_list|(
literal|122
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pixels_per_meter
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|123
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_x_pixels_per_meter
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|124
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_y_pixels_per_meter
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
name|PNG_FP_EXPORT
argument_list|(
literal|125
argument_list|,
argument|float
argument_list|,
argument|png_get_pixel_aspect_ratio
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|210
argument_list|,
argument|png_fixed_point
argument_list|,
argument|png_get_pixel_aspect_ratio_fixed
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr)
argument_list|)
comment|/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
name|PNG_EXPORT
argument_list|(
literal|126
argument_list|,
name|png_int_32
argument_list|,
name|png_get_x_offset_pixels
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|127
argument_list|,
name|png_int_32
argument_list|,
name|png_get_y_offset_pixels
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|128
argument_list|,
name|png_int_32
argument_list|,
name|png_get_x_offset_microns
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|129
argument_list|,
name|png_int_32
argument_list|,
name|png_get_y_offset_microns
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EASY_ACCESS */
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
comment|/* Returns pointer to signature string read from PNG header */
name|PNG_EXPORT
argument_list|(
literal|130
argument_list|,
name|png_const_bytep
argument_list|,
name|png_get_signature
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_bKGD_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|131
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_bKGD
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_color_16p
operator|*
name|background
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_bKGD_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|132
argument_list|,
name|void
argument_list|,
name|png_set_bKGD
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_color_16p
name|background
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|133
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_cHRM
argument_list|,
argument|(png_const_structrp png_ptr,     png_const_inforp info_ptr, double *white_x, double *white_y, double *red_x,     double *red_y, double *green_x, double *green_y, double *blue_x,     double *blue_y)
argument_list|)
name|PNG_FP_EXPORT
argument_list|(
literal|230
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_cHRM_XYZ
argument_list|,
argument|(png_const_structrp png_ptr,     png_const_inforp info_ptr, double *red_X, double *red_Y, double *red_Z,     double *green_X, double *green_Y, double *green_Z, double *blue_X,     double *blue_Y, double *blue_Z)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|134
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_cHRM_fixed
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr,     png_fixed_point *int_white_x, png_fixed_point *int_white_y,     png_fixed_point *int_red_x, png_fixed_point *int_red_y,     png_fixed_point *int_green_x, png_fixed_point *int_green_y,     png_fixed_point *int_blue_x, png_fixed_point *int_blue_y)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|231
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_cHRM_XYZ_fixed
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr,     png_fixed_point *int_red_X, png_fixed_point *int_red_Y,     png_fixed_point *int_red_Z, png_fixed_point *int_green_X,     png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,     png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,     png_fixed_point *int_blue_Z)
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|135
argument_list|,
argument|void
argument_list|,
argument|png_set_cHRM
argument_list|,
argument|(png_const_structrp png_ptr,     png_inforp info_ptr,     double white_x, double white_y, double red_x, double red_y, double green_x,     double green_y, double blue_x, double blue_y)
argument_list|)
name|PNG_FP_EXPORT
argument_list|(
literal|232
argument_list|,
argument|void
argument_list|,
argument|png_set_cHRM_XYZ
argument_list|,
argument|(png_const_structrp png_ptr,     png_inforp info_ptr, double red_X, double red_Y, double red_Z,     double green_X, double green_Y, double green_Z, double blue_X,     double blue_Y, double blue_Z)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|136
argument_list|,
argument|void
argument_list|,
argument|png_set_cHRM_fixed
argument_list|,
argument|(png_const_structrp png_ptr,     png_inforp info_ptr, png_fixed_point int_white_x,     png_fixed_point int_white_y, png_fixed_point int_red_x,     png_fixed_point int_red_y, png_fixed_point int_green_x,     png_fixed_point int_green_y, png_fixed_point int_blue_x,     png_fixed_point int_blue_y)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|233
argument_list|,
argument|void
argument_list|,
argument|png_set_cHRM_XYZ_fixed
argument_list|,
argument|(png_const_structrp png_ptr,     png_inforp info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,     png_fixed_point int_red_Z, png_fixed_point int_green_X,     png_fixed_point int_green_Y, png_fixed_point int_green_Z,     png_fixed_point int_blue_X, png_fixed_point int_blue_Y,     png_fixed_point int_blue_Z)
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|137
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_gAMA
argument_list|,
argument|(png_const_structrp png_ptr,     png_const_inforp info_ptr, double *file_gamma)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|138
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_gAMA_fixed
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr,     png_fixed_point *int_file_gamma)
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|139
argument_list|,
argument|void
argument_list|,
argument|png_set_gAMA
argument_list|,
argument|(png_const_structrp png_ptr,     png_inforp info_ptr, double file_gamma)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|140
argument_list|,
argument|void
argument_list|,
argument|png_set_gAMA_fixed
argument_list|,
argument|(png_const_structrp png_ptr,     png_inforp info_ptr, png_fixed_point int_file_gamma)
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|141
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_hIST
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_16p
operator|*
name|hist
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|142
argument_list|,
name|void
argument_list|,
name|png_set_hIST
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_uint_16p
name|hist
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|143
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_IHDR
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|,
name|png_uint_32
operator|*
name|width
operator|,
name|png_uint_32
operator|*
name|height
operator|,
name|int
operator|*
name|bit_depth
operator|,
name|int
operator|*
name|color_type
operator|,
name|int
operator|*
name|interlace_method
operator|,
name|int
operator|*
name|compression_method
operator|,
name|int
operator|*
name|filter_method
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|144
argument_list|,
name|void
argument_list|,
name|png_set_IHDR
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|width
operator|,
name|png_uint_32
name|height
operator|,
name|int
name|bit_depth
operator|,
name|int
name|color_type
operator|,
name|int
name|interlace_method
operator|,
name|int
name|compression_method
operator|,
name|int
name|filter_method
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_oFFs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|145
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_oFFs
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|,
name|png_int_32
operator|*
name|offset_x
operator|,
name|png_int_32
operator|*
name|offset_y
operator|,
name|int
operator|*
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_oFFs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|146
argument_list|,
name|void
argument_list|,
name|png_set_oFFs
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_int_32
name|offset_x
operator|,
name|png_int_32
name|offset_y
operator|,
name|int
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|147
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pCAL
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_charp
operator|*
name|purpose
operator|,
name|png_int_32
operator|*
name|X0
operator|,
name|png_int_32
operator|*
name|X1
operator|,
name|int
operator|*
name|type
operator|,
name|int
operator|*
name|nparams
operator|,
name|png_charp
operator|*
name|units
operator|,
name|png_charpp
operator|*
name|params
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|148
argument_list|,
name|void
argument_list|,
name|png_set_pCAL
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_charp
name|purpose
operator|,
name|png_int_32
name|X0
operator|,
name|png_int_32
name|X1
operator|,
name|int
name|type
operator|,
name|int
name|nparams
operator|,
name|png_const_charp
name|units
operator|,
name|png_charpp
name|params
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|149
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pHYs
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|,
name|png_uint_32
operator|*
name|res_x
operator|,
name|png_uint_32
operator|*
name|res_y
operator|,
name|int
operator|*
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|150
argument_list|,
name|void
argument_list|,
name|png_set_pHYs
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|res_x
operator|,
name|png_uint_32
name|res_y
operator|,
name|int
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|151
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_PLTE
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_colorp
operator|*
name|palette
operator|,
name|int
operator|*
name|num_palette
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|152
argument_list|,
name|void
argument_list|,
name|png_set_PLTE
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_colorp
name|palette
operator|,
name|int
name|num_palette
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_sBIT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|153
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sBIT
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_color_8p
operator|*
name|sig_bit
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sBIT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|154
argument_list|,
name|void
argument_list|,
name|png_set_sBIT
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_color_8p
name|sig_bit
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|155
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sRGB
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|,
name|int
operator|*
name|file_srgb_intent
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|156
argument_list|,
name|void
argument_list|,
name|png_set_sRGB
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|srgb_intent
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|157
argument_list|,
name|void
argument_list|,
name|png_set_sRGB_gAMA_and_cHRM
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|srgb_intent
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|158
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_iCCP
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_charpp
name|name
operator|,
name|int
operator|*
name|compression_type
operator|,
name|png_bytepp
name|profile
operator|,
name|png_uint_32
operator|*
name|proflen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|159
argument_list|,
name|void
argument_list|,
name|png_set_iCCP
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_charp
name|name
operator|,
name|int
name|compression_type
operator|,
name|png_const_bytep
name|profile
operator|,
name|png_uint_32
name|proflen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|160
argument_list|,
name|int
argument_list|,
name|png_get_sPLT
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_sPLT_tpp
name|entries
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|161
argument_list|,
name|void
argument_list|,
name|png_set_sPLT
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_sPLT_tp
name|entries
operator|,
name|int
name|nentries
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* png_get_text also returns the number of text chunks in *num_text */
name|PNG_EXPORT
argument_list|(
literal|162
argument_list|,
name|int
argument_list|,
name|png_get_text
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_textp
operator|*
name|text_ptr
operator|,
name|int
operator|*
name|num_text
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note while png_set_text() will accept a structure whose text,  * language, and  translated keywords are NULL pointers, the structure  * returned by png_get_text will always contain regular  * zero-terminated C strings.  They might be empty strings but  * they will never be NULL pointers.  */
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|163
argument_list|,
name|void
argument_list|,
name|png_set_text
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_textp
name|text_ptr
operator|,
name|int
name|num_text
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|164
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_tIME
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_timep
operator|*
name|mod_time
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|165
argument_list|,
name|void
argument_list|,
name|png_set_tIME
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_timep
name|mod_time
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|166
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_tRNS
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_bytep
operator|*
name|trans_alpha
operator|,
name|int
operator|*
name|num_trans
operator|,
name|png_color_16p
operator|*
name|trans_color
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|167
argument_list|,
name|void
argument_list|,
name|png_set_tRNS
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_bytep
name|trans_alpha
operator|,
name|int
name|num_trans
operator|,
name|png_const_color_16p
name|trans_color
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
name|PNG_FP_EXPORT
argument_list|(
literal|168
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_sCAL
argument_list|,
argument|(png_const_structrp png_ptr,     png_const_inforp info_ptr, int *unit, double *width, double *height)
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
comment|/* NOTE: this API is currently implemented using floating point arithmetic,  * consequently it can only be used on systems with floating point support.  * In any case the range of values supported by png_fixed_point is small and it  * is highly recommended that png_get_sCAL_s be used instead.  */
name|PNG_FIXED_EXPORT
argument_list|(
literal|214
argument_list|,
argument|png_uint_32
argument_list|,
argument|png_get_sCAL_fixed
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr, int *unit,     png_fixed_point *width, png_fixed_point *height)
argument_list|)
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|169
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_sCAL_s
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|,
name|int
operator|*
name|unit
operator|,
name|png_charpp
name|swidth
operator|,
name|png_charpp
name|sheight
operator|)
argument_list|)
expr_stmt|;
name|PNG_FP_EXPORT
argument_list|(
literal|170
argument_list|,
argument|void
argument_list|,
argument|png_set_sCAL
argument_list|,
argument|(png_const_structrp png_ptr,     png_inforp info_ptr, int unit, double width, double height)
argument_list|)
name|PNG_FIXED_EXPORT
argument_list|(
literal|213
argument_list|,
argument|void
argument_list|,
argument|png_set_sCAL_fixed
argument_list|,
argument|(png_const_structrp png_ptr,    png_inforp info_ptr, int unit, png_fixed_point width,    png_fixed_point height)
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|171
argument_list|,
name|void
argument_list|,
name|png_set_sCAL_s
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|unit
operator|,
name|png_const_charp
name|swidth
operator|,
name|png_const_charp
name|sheight
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sCAL */
ifdef|#
directive|ifdef
name|PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
comment|/* Provide the default handling for all unknown chunks or, optionally, for  * specific unknown chunks.  *  * NOTE: prior to 1.6.0 the handling specified for particular chunks on read was  * ignored and the default was used, the per-chunk setting only had an effect on  * write.  If you wish to have chunk-specific handling on read in code that must  * work on earlier versions you must use a user chunk callback to specify the  * desired handling (keep or discard.)  *  * The 'keep' parameter is a PNG_HANDLE_CHUNK_ value as listed below.  The  * parameter is interpreted as follows:  *  * READ:  *    PNG_HANDLE_CHUNK_AS_DEFAULT:  *       Known chunks: do normal libpng processing, do not keep the chunk (but  *          see the comments below about PNG_HANDLE_AS_UNKNOWN_SUPPORTED)  *       Unknown chunks: for a specific chunk use the global default, when used  *          as the default discard the chunk data.  *    PNG_HANDLE_CHUNK_NEVER:  *       Discard the chunk data.  *    PNG_HANDLE_CHUNK_IF_SAFE:  *       Keep the chunk data if the chunk is not critical else raise a chunk  *       error.  *    PNG_HANDLE_CHUNK_ALWAYS:  *       Keep the chunk data.  *  * If the chunk data is saved it can be retrieved using png_get_unknown_chunks,  * below.  Notice that specifying "AS_DEFAULT" as a global default is equivalent  * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks  * it simply resets the behavior to the libpng default.  *  * INTERACTION WTIH USER CHUNK CALLBACKS:  * The per-chunk handling is always used when there is a png_user_chunk_ptr  * callback and the callback returns 0; the chunk is then always stored *unless*  * it is critical and the per-chunk setting is other than ALWAYS.  Notice that  * the global default is *not* used in this case.  (In effect the per-chunk  * value is incremented to at least IF_SAFE.)  *  * IMPORTANT NOTE: this behavior will change in libpng 1.7 - the global and  * per-chunk defaults will be honored.  If you want to preserve the current  * behavior when your callback returns 0 you must set PNG_HANDLE_CHUNK_IF_SAFE  * as the default - if you don't do this libpng 1.6 will issue a warning.  *  * If you want unhandled unknown chunks to be discarded in libpng 1.6 and  * earlier simply return '1' (handled).  *  * PNG_HANDLE_AS_UNKNOWN_SUPPORTED:  *    If this is *not* set known chunks will always be handled by libpng and  *    will never be stored in the unknown chunk list.  Known chunks listed to  *    png_set_keep_unknown_chunks will have no effect.  If it is set then known  *    chunks listed with a keep other than AS_DEFAULT will *never* be processed  *    by libpng, in addition critical chunks must either be processed by the  *    callback or saved.  *  *    The IHDR and IEND chunks must not be listed.  Because this turns off the  *    default handling for chunks that would otherwise be recognized the  *    behavior of libpng transformations may well become incorrect!  *  * WRITE:  *    When writing chunks the options only apply to the chunks specified by  *    png_set_unknown_chunks (below), libpng will *always* write known chunks  *    required by png_set_ calls and will always write the core critical chunks  *    (as required for PLTE).  *  *    Each chunk in the png_set_unknown_chunks list is looked up in the  *    png_set_keep_unknown_chunks list to find the keep setting, this is then  *    interpreted as follows:  *  *    PNG_HANDLE_CHUNK_AS_DEFAULT:  *       Write safe-to-copy chunks and write other chunks if the global  *       default is set to _ALWAYS, otherwise don't write this chunk.  *    PNG_HANDLE_CHUNK_NEVER:  *       Do not write the chunk.  *    PNG_HANDLE_CHUNK_IF_SAFE:  *       Write the chunk if it is safe-to-copy, otherwise do not write it.  *    PNG_HANDLE_CHUNK_ALWAYS:  *       Write the chunk.  *  * Note that the default behavior is effectively the opposite of the read case -  * in read unknown chunks are not stored by default, in write they are written  * by default.  Also the behavior of PNG_HANDLE_CHUNK_IF_SAFE is very different  * - on write the safe-to-copy bit is checked, on read the critical bit is  * checked and on read if the chunk is critical an error will be raised.  *  * num_chunks:  * ===========  *    If num_chunks is positive, then the "keep" parameter specifies the manner  *    for handling only those chunks appearing in the chunk_list array,  *    otherwise the chunk list array is ignored.  *  *    If num_chunks is 0 the "keep" parameter specifies the default behavior for  *    unknown chunks, as described above.  *  *    If num_chunks is negative, then the "keep" parameter specifies the manner  *    for handling all unknown chunks plus all chunks recognized by libpng  *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to  *    be processed by libpng.  */
name|PNG_EXPORT
argument_list|(
literal|172
argument_list|,
name|void
argument_list|,
name|png_set_keep_unknown_chunks
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|keep
operator|,
name|png_const_bytep
name|chunk_list
operator|,
name|int
name|num_chunks
operator|)
argument_list|)
expr_stmt|;
comment|/* The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;  * the result is therefore true (non-zero) if special handling is required,  * false for the default handling.  */
name|PNG_EXPORT
argument_list|(
literal|173
argument_list|,
name|int
argument_list|,
name|png_handle_as_unknown
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|chunk_name
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|174
argument_list|,
name|void
argument_list|,
name|png_set_unknown_chunks
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_unknown_chunkp
name|unknowns
operator|,
name|int
name|num_unknowns
operator|)
argument_list|)
expr_stmt|;
comment|/* NOTE: prior to 1.6.0 this routine set the 'location' field of the added     * unknowns to the location currently stored in the png_struct.  This is     * invariably the wrong value on write.  To fix this call the following API     * for each chunk in the list with the correct location.  If you know your     * code won't be compiled on earlier versions you can rely on     * png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing     * the correct thing.     */
name|PNG_EXPORT
argument_list|(
literal|175
argument_list|,
name|void
argument_list|,
name|png_set_unknown_chunk_location
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|chunk
operator|,
name|int
name|location
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|176
argument_list|,
name|int
argument_list|,
name|png_get_unknown_chunks
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_unknown_chunkpp
name|entries
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Png_free_data() will turn off the "valid" flag for anything it frees.  * If you need to turn it off for a chunk that your application has freed,  * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);  */
name|PNG_EXPORT
argument_list|(
literal|177
argument_list|,
name|void
argument_list|,
name|png_set_invalid
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|mask
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
comment|/* The "params" pointer is currently not used and is for future expansion. */
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|178
argument_list|,
name|void
argument_list|,
name|png_read_png
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|transforms
operator|,
name|png_voidp
name|params
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|179
argument_list|,
name|void
argument_list|,
name|png_write_png
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|int
name|transforms
operator|,
name|png_voidp
name|params
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|180
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_copyright
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|181
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_header_ver
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|182
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_header_version
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|183
argument_list|,
name|png_const_charp
argument_list|,
name|png_get_libpng_ver
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|184
argument_list|,
name|png_uint_32
argument_list|,
name|png_permit_mng_features
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|mng_features_permitted
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* For use in png_set_keep_unknown, added to version 1.2.6 */
DECL|macro|PNG_HANDLE_CHUNK_AS_DEFAULT
define|#
directive|define
name|PNG_HANDLE_CHUNK_AS_DEFAULT
value|0
DECL|macro|PNG_HANDLE_CHUNK_NEVER
define|#
directive|define
name|PNG_HANDLE_CHUNK_NEVER
value|1
DECL|macro|PNG_HANDLE_CHUNK_IF_SAFE
define|#
directive|define
name|PNG_HANDLE_CHUNK_IF_SAFE
value|2
DECL|macro|PNG_HANDLE_CHUNK_ALWAYS
define|#
directive|define
name|PNG_HANDLE_CHUNK_ALWAYS
value|3
DECL|macro|PNG_HANDLE_CHUNK_LAST
define|#
directive|define
name|PNG_HANDLE_CHUNK_LAST
value|4
comment|/* Strip the prepended error numbers ("#nnn ") from error and warning  * messages before passing them to the error or warning handler.  */
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|185
argument_list|,
name|void
argument_list|,
name|png_set_strip_error_numbers
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|strip_mode
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added in libpng-1.2.6 */
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|186
argument_list|,
name|void
argument_list|,
name|png_set_user_limits
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|user_width_max
operator|,
name|png_uint_32
name|user_height_max
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|187
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_user_width_max
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|188
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_user_height_max
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Added in libpng-1.4.0 */
name|PNG_EXPORT
argument_list|(
literal|189
argument_list|,
name|void
argument_list|,
name|png_set_chunk_cache_max
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|user_chunk_cache_max
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|190
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_chunk_cache_max
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Added in libpng-1.4.1 */
name|PNG_EXPORT
argument_list|(
literal|191
argument_list|,
name|void
argument_list|,
name|png_set_chunk_malloc_max
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_alloc_size_t
name|user_chunk_cache_max
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|192
argument_list|,
name|png_alloc_size_t
argument_list|,
name|png_get_chunk_malloc_max
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|193
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pixels_per_inch
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|194
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_x_pixels_per_inch
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|195
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_y_pixels_per_inch
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|PNG_FP_EXPORT
argument_list|(
literal|196
argument_list|,
argument|float
argument_list|,
argument|png_get_x_offset_inches
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr)
argument_list|)
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
comment|/* otherwise not implemented. */
name|PNG_FIXED_EXPORT
argument_list|(
literal|211
argument_list|,
argument|png_fixed_point
argument_list|,
argument|png_get_x_offset_inches_fixed
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr)
argument_list|)
endif|#
directive|endif
name|PNG_FP_EXPORT
argument_list|(
literal|197
argument_list|,
argument|float
argument_list|,
argument|png_get_y_offset_inches
argument_list|,
argument|(png_const_structrp png_ptr,     png_const_inforp info_ptr)
argument_list|)
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
comment|/* otherwise not implemented. */
name|PNG_FIXED_EXPORT
argument_list|(
literal|212
argument_list|,
argument|png_fixed_point
argument_list|,
argument|png_get_y_offset_inches_fixed
argument_list|,
argument|(png_const_structrp png_ptr, png_const_inforp info_ptr)
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|198
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_pHYs_dpi
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_inforp
name|info_ptr
operator|,
name|png_uint_32
operator|*
name|res_x
operator|,
name|png_uint_32
operator|*
name|res_y
operator|,
name|int
operator|*
name|unit_type
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pHYs */
endif|#
directive|endif
comment|/* INCH_CONVERSIONS */
comment|/* Added in libpng-1.4.0 */
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|199
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_io_state
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* Removed from libpng 1.6; use png_get_io_chunk_type. */
name|PNG_REMOVED
argument_list|(
literal|200
argument_list|,
argument|png_const_bytep
argument_list|,
argument|png_get_io_chunk_name
argument_list|,
argument|(png_structrp png_ptr)
argument_list|,
argument|PNG_DEPRECATED
argument_list|)
name|PNG_EXPORT
argument_list|(
literal|216
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_io_chunk_type
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|)
argument_list|)
expr_stmt|;
comment|/* The flags returned by png_get_io_state() are the following: */
DECL|macro|PNG_IO_NONE
define|#
directive|define
name|PNG_IO_NONE
value|0x0000
comment|/* no I/O at this moment */
DECL|macro|PNG_IO_READING
define|#
directive|define
name|PNG_IO_READING
value|0x0001
comment|/* currently reading */
DECL|macro|PNG_IO_WRITING
define|#
directive|define
name|PNG_IO_WRITING
value|0x0002
comment|/* currently writing */
DECL|macro|PNG_IO_SIGNATURE
define|#
directive|define
name|PNG_IO_SIGNATURE
value|0x0010
comment|/* currently at the file signature */
DECL|macro|PNG_IO_CHUNK_HDR
define|#
directive|define
name|PNG_IO_CHUNK_HDR
value|0x0020
comment|/* currently at the chunk header */
DECL|macro|PNG_IO_CHUNK_DATA
define|#
directive|define
name|PNG_IO_CHUNK_DATA
value|0x0040
comment|/* currently at the chunk data */
DECL|macro|PNG_IO_CHUNK_CRC
define|#
directive|define
name|PNG_IO_CHUNK_CRC
value|0x0080
comment|/* currently at the chunk crc */
DECL|macro|PNG_IO_MASK_OP
define|#
directive|define
name|PNG_IO_MASK_OP
value|0x000f
comment|/* current operation: reading/writing */
DECL|macro|PNG_IO_MASK_LOC
define|#
directive|define
name|PNG_IO_MASK_LOC
value|0x00f0
comment|/* current location: sig/hdr/data/crc */
endif|#
directive|endif
comment|/* IO_STATE */
comment|/* Interlace support.  The following macros are always defined so that if  * libpng interlace handling is turned off the macros may be used to handle  * interlaced images within the application.  */
DECL|macro|PNG_INTERLACE_ADAM7_PASSES
define|#
directive|define
name|PNG_INTERLACE_ADAM7_PASSES
value|7
comment|/* Two macros to return the first row and first column of the original,  * full, image which appears in a given pass.  'pass' is in the range 0  * to 6 and the result is in the range 0 to 7.  */
DECL|macro|PNG_PASS_START_ROW
define|#
directive|define
name|PNG_PASS_START_ROW
parameter_list|(
name|pass
parameter_list|)
value|(((1&~(pass))<<(3-((pass)>>1)))&7)
DECL|macro|PNG_PASS_START_COL
define|#
directive|define
name|PNG_PASS_START_COL
parameter_list|(
name|pass
parameter_list|)
value|(((1& (pass))<<(3-(((pass)+1)>>1)))&7)
comment|/* A macro to return the offset between pixels in the output row for a pair of  * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that  * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas  * COL_OFFSET is from one column to the next, within a row.  */
DECL|macro|PNG_PASS_ROW_OFFSET
define|#
directive|define
name|PNG_PASS_ROW_OFFSET
parameter_list|(
name|pass
parameter_list|)
value|((pass)>2?(8>>(((pass)-1)>>1)):8)
DECL|macro|PNG_PASS_COL_OFFSET
define|#
directive|define
name|PNG_PASS_COL_OFFSET
parameter_list|(
name|pass
parameter_list|)
value|(1<<((7-(pass))>>1))
comment|/* Two macros to help evaluate the number of rows or columns in each  * pass.  This is expressed as a shift - effectively log2 of the number or  * rows or columns in each 8x8 tile of the original image.  */
DECL|macro|PNG_PASS_ROW_SHIFT
define|#
directive|define
name|PNG_PASS_ROW_SHIFT
parameter_list|(
name|pass
parameter_list|)
value|((pass)>2?(8-(pass))>>1:3)
DECL|macro|PNG_PASS_COL_SHIFT
define|#
directive|define
name|PNG_PASS_COL_SHIFT
parameter_list|(
name|pass
parameter_list|)
value|((pass)>1?(7-(pass))>>1:3)
comment|/* Hence two macros to determine the number of rows or columns in a given  * pass of an image given its height or width.  In fact these macros may  * return non-zero even though the sub-image is empty, because the other  * dimension may be empty for a small image.  */
DECL|macro|PNG_PASS_ROWS
define|#
directive|define
name|PNG_PASS_ROWS
parameter_list|(
name|height
parameter_list|,
name|pass
parameter_list|)
value|(((height)+(((1<<PNG_PASS_ROW_SHIFT(pass))\    -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))
DECL|macro|PNG_PASS_COLS
define|#
directive|define
name|PNG_PASS_COLS
parameter_list|(
name|width
parameter_list|,
name|pass
parameter_list|)
value|(((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\    -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))
comment|/* For the reader row callbacks (both progressive and sequential) it is  * necessary to find the row in the output image given a row in an interlaced  * image, so two more macros:  */
DECL|macro|PNG_ROW_FROM_PASS_ROW
define|#
directive|define
name|PNG_ROW_FROM_PASS_ROW
parameter_list|(
name|y_in
parameter_list|,
name|pass
parameter_list|)
define|\
value|(((y_in)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
DECL|macro|PNG_COL_FROM_PASS_COL
define|#
directive|define
name|PNG_COL_FROM_PASS_COL
parameter_list|(
name|x_in
parameter_list|,
name|pass
parameter_list|)
define|\
value|(((x_in)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
comment|/* Two macros which return a boolean (0 or 1) saying whether the given row  * or column is in a particular pass.  These use a common utility macro that  * returns a mask for a given pass - the offset 'off' selects the row or  * column version.  The mask has the appropriate bit set for each column in  * the tile.  */
DECL|macro|PNG_PASS_MASK
define|#
directive|define
name|PNG_PASS_MASK
parameter_list|(
name|pass
parameter_list|,
name|off
parameter_list|)
value|( \    ((0x110145AF>>(((7-(off))-(pass))<<2))& 0xF) | \    ((0x01145AF0>>(((7-(off))-(pass))<<2))& 0xF0))
DECL|macro|PNG_ROW_IN_INTERLACE_PASS
define|#
directive|define
name|PNG_ROW_IN_INTERLACE_PASS
parameter_list|(
name|y
parameter_list|,
name|pass
parameter_list|)
define|\
value|((PNG_PASS_MASK(pass,0)>> ((y)&7))& 1)
DECL|macro|PNG_COL_IN_INTERLACE_PASS
define|#
directive|define
name|PNG_COL_IN_INTERLACE_PASS
parameter_list|(
name|x
parameter_list|,
name|pass
parameter_list|)
define|\
value|((PNG_PASS_MASK(pass,1)>> ((x)&7))& 1)
ifdef|#
directive|ifdef
name|PNG_READ_COMPOSITE_NODIV_SUPPORTED
comment|/* With these routines we avoid an integer divide, which will be slower on  * most machines.  However, it does take more operations than the corresponding  * divide method, so it may be slower on a few RISC systems.  There are two  * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.  *  * Note that the rounding factors are NOT supposed to be the same!  128 and  * 32768 are correct for the NODIV code; 127 and 32767 are correct for the  * standard method.  *  * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]  */
comment|/* fg and bg should be in `gamma 1.0' space; alpha is the opacity */
DECL|macro|png_composite
define|#
directive|define
name|png_composite
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|{ png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \            * (png_uint_16)(alpha)                         \            + (png_uint_16)(bg)*(png_uint_16)(255          \            - (png_uint_16)(alpha)) + 128);                \        (composite) = (png_byte)(((temp + (temp>> 8))>> 8)& 0xff); }
DECL|macro|png_composite_16
define|#
directive|define
name|png_composite_16
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|{ png_uint_32 temp = (png_uint_32)((png_uint_32)(fg)  \            * (png_uint_32)(alpha)                          \            + (png_uint_32)(bg)*(65535                      \            - (png_uint_32)(alpha)) + 32768);               \        (composite) = (png_uint_16)(0xffff& ((temp + (temp>> 16))>> 16)); }
else|#
directive|else
comment|/* Standard method using integer division */
DECL|macro|png_composite
define|#
directive|define
name|png_composite
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|(composite) =                                                       \          (png_byte)(0xff& (((png_uint_16)(fg) * (png_uint_16)(alpha) +  \          (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) + \          127) / 255))
DECL|macro|png_composite_16
define|#
directive|define
name|png_composite_16
parameter_list|(
name|composite
parameter_list|,
name|fg
parameter_list|,
name|alpha
parameter_list|,
name|bg
parameter_list|)
define|\
value|(composite) =                                                           \          (png_uint_16)(0xffff& (((png_uint_32)(fg) * (png_uint_32)(alpha) + \          (png_uint_32)(bg)*(png_uint_32)(65535 - (png_uint_32)(alpha)) +     \          32767) / 65535))
endif|#
directive|endif
comment|/* READ_COMPOSITE_NODIV */
ifdef|#
directive|ifdef
name|PNG_READ_INT_FUNCTIONS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|201
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_uint_32
argument_list|,
operator|(
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|202
argument_list|,
name|png_uint_16
argument_list|,
name|png_get_uint_16
argument_list|,
operator|(
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
name|PNG_EXPORT
argument_list|(
literal|203
argument_list|,
name|png_int_32
argument_list|,
name|png_get_int_32
argument_list|,
operator|(
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_EXPORT
argument_list|(
literal|204
argument_list|,
name|png_uint_32
argument_list|,
name|png_get_uint_31
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|buf
operator|)
argument_list|)
expr_stmt|;
comment|/* No png_get_int_16 -- may be added if there's a real need for it. */
comment|/* Place a 32-bit number into a buffer in PNG byte order (big-endian). */
ifdef|#
directive|ifdef
name|PNG_WRITE_INT_FUNCTIONS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|205
argument_list|,
name|void
argument_list|,
name|png_save_uint_32
argument_list|,
operator|(
name|png_bytep
name|buf
operator|,
name|png_uint_32
name|i
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SAVE_INT_32_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|206
argument_list|,
name|void
argument_list|,
name|png_save_int_32
argument_list|,
operator|(
name|png_bytep
name|buf
operator|,
name|png_int_32
name|i
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Place a 16-bit number into a buffer in PNG byte order.  * The parameter is declared unsigned int, not png_uint_16,  * just to avoid potential problems on pre-ANSI C compilers.  */
ifdef|#
directive|ifdef
name|PNG_WRITE_INT_FUNCTIONS_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|207
argument_list|,
name|void
argument_list|,
name|png_save_uint_16
argument_list|,
operator|(
name|png_bytep
name|buf
operator|,
name|unsigned
name|int
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* No png_save_int_16 -- may be added if there's a real need for it. */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USE_READ_MACROS
comment|/* Inline macros to do direct reads of bytes from the input buffer.  * The png_get_int_32() routine assumes we are using two's complement  * format for negative values, which is almost certainly true.  */
DECL|macro|PNG_get_uint_32
define|#
directive|define
name|PNG_get_uint_32
parameter_list|(
name|buf
parameter_list|)
define|\
value|(((png_uint_32)(*(buf))<< 24) + \       ((png_uint_32)(*((buf) + 1))<< 16) + \       ((png_uint_32)(*((buf) + 2))<< 8) + \       ((png_uint_32)(*((buf) + 3))))
comment|/* From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the     * function) incorrectly returned a value of type png_uint_32.     */
DECL|macro|PNG_get_uint_16
define|#
directive|define
name|PNG_get_uint_16
parameter_list|(
name|buf
parameter_list|)
define|\
value|((png_uint_16) \       (((unsigned int)(*(buf))<< 8) + \        ((unsigned int)(*((buf) + 1)))))
DECL|macro|PNG_get_int_32
define|#
directive|define
name|PNG_get_int_32
parameter_list|(
name|buf
parameter_list|)
define|\
value|((png_int_32)((*(buf)& 0x80) \       ? -((png_int_32)((png_get_uint_32(buf) ^ 0xffffffffL) + 1)) \       : (png_int_32)png_get_uint_32(buf)))
comment|/* If PNG_PREFIX is defined the same thing as below happens in pnglibconf.h,     * but defining a macro name prefixed with PNG_PREFIX.     */
ifndef|#
directive|ifndef
name|PNG_PREFIX
DECL|macro|png_get_uint_32
define|#
directive|define
name|png_get_uint_32
parameter_list|(
name|buf
parameter_list|)
value|PNG_get_uint_32(buf)
DECL|macro|png_get_uint_16
define|#
directive|define
name|png_get_uint_16
parameter_list|(
name|buf
parameter_list|)
value|PNG_get_uint_16(buf)
DECL|macro|png_get_int_32
define|#
directive|define
name|png_get_int_32
parameter_list|(
name|buf
parameter_list|)
value|PNG_get_int_32(buf)
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|PNG_PREFIX
comment|/* No macros; revert to the (redefined) function */
DECL|macro|PNG_get_uint_32
define|#
directive|define
name|PNG_get_uint_32
value|(png_get_uint_32)
DECL|macro|PNG_get_uint_16
define|#
directive|define
name|PNG_get_uint_16
value|(png_get_uint_16)
DECL|macro|PNG_get_int_32
define|#
directive|define
name|PNG_get_int_32
value|(png_get_int_32)
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_READ_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
argument_list|)
comment|/*******************************************************************************  *  SIMPLIFIED API  *******************************************************************************  *  * Please read the documentation in libpng-manual.txt (TODO: write said  * documentation) if you don't understand what follows.  *  * The simplified API hides the details of both libpng and the PNG file format  * itself.  It allows PNG files to be read into a very limited number of  * in-memory bitmap formats or to be written from the same formats.  If these  * formats do not accomodate your needs then you can, and should, use the more  * sophisticated APIs above - these support a wide variety of in-memory formats  * and a wide variety of sophisticated transformations to those formats as well  * as a wide variety of APIs to manipulate ancillary information.  *  * To read a PNG file using the simplified API:  *  * 1) Declare a 'png_image' structure (see below) on the stack and set the  *    version field to PNG_IMAGE_VERSION.  * 2) Call the appropriate png_image_begin_read... function.  * 3) Set the png_image 'format' member to the required sample format.  * 4) Allocate a buffer for the image and, if required, the color-map.  * 5) Call png_image_finish_read to read the image and, if required, the  *    color-map into your buffers.  *  * There are no restrictions on the format of the PNG input itself; all valid  * color types, bit depths, and interlace methods are acceptable, and the  * input image is transformed as necessary to the requested in-memory format  * during the png_image_finish_read() step.  The only caveat is that if you  * request a color-mapped image from a PNG that is full-color or makes  * complex use of an alpha channel the transformation is extremely lossy and the  * result may look terrible.  *  * To write a PNG file using the simplified API:  *  * 1) Declare a 'png_image' structure on the stack and memset() it to all zero.  * 2) Initialize the members of the structure that describe the image, setting  *    the 'format' member to the format of the image samples.  * 3) Call the appropriate png_image_write... function with a pointer to the  *    image and, if necessary, the color-map to write the PNG data.  *  * png_image is a structure that describes the in-memory format of an image  * when it is being read or defines the in-memory format of an image that you  * need to write:  */
DECL|macro|PNG_IMAGE_VERSION
define|#
directive|define
name|PNG_IMAGE_VERSION
value|1
DECL|typedef|png_controlp
typedef|typedef
name|struct
name|png_control
modifier|*
name|png_controlp
typedef|;
typedef|typedef
struct|struct
block|{
DECL|member|opaque
name|png_controlp
name|opaque
decl_stmt|;
comment|/* Initialize to NULL, free with png_image_free */
DECL|member|version
name|png_uint_32
name|version
decl_stmt|;
comment|/* Set to PNG_IMAGE_VERSION */
DECL|member|width
name|png_uint_32
name|width
decl_stmt|;
comment|/* Image width in pixels (columns) */
DECL|member|height
name|png_uint_32
name|height
decl_stmt|;
comment|/* Image height in pixels (rows) */
DECL|member|format
name|png_uint_32
name|format
decl_stmt|;
comment|/* Image format as defined below */
DECL|member|flags
name|png_uint_32
name|flags
decl_stmt|;
comment|/* A bit mask containing informational flags */
DECL|member|colormap_entries
name|png_uint_32
name|colormap_entries
decl_stmt|;
comment|/* Number of entries in the color-map */
comment|/* In the event of an error or warning the following field will be set to a     * non-zero value and the 'message' field will contain a '\0' terminated     * string with the libpng error or warning message.  If both warnings and     * an error were encountered, only the error is recorded.  If there     * are multiple warnings, only the first one is recorded.     *     * The upper 30 bits of this value are reserved, the low two bits contain     * a value as follows:     */
DECL|macro|PNG_IMAGE_WARNING
define|#
directive|define
name|PNG_IMAGE_WARNING
value|1
DECL|macro|PNG_IMAGE_ERROR
define|#
directive|define
name|PNG_IMAGE_ERROR
value|2
comment|/*     * The result is a two-bit code such that a value more than 1 indicates     * a failure in the API just called:     *     *    0 - no warning or error     *    1 - warning     *    2 - error     *    3 - error preceded by warning     */
DECL|macro|PNG_IMAGE_FAILED
define|#
directive|define
name|PNG_IMAGE_FAILED
parameter_list|(
name|png_cntrl
parameter_list|)
value|((((png_cntrl).warning_or_error)&0x03)>1)
DECL|member|warning_or_error
name|png_uint_32
name|warning_or_error
decl_stmt|;
DECL|member|message
name|char
name|message
index|[
literal|64
index|]
decl_stmt|;
block|}
DECL|typedef|png_image
DECL|typedef|png_imagep
name|png_image
operator|,
typedef|*
name|png_imagep
typedef|;
comment|/* The samples of the image have one to four channels whose components have  * original values in the range 0 to 1.0:  *  * 1: A single gray or luminance channel (G).  * 2: A gray/luminance channel and an alpha channel (GA).  * 3: Three red, green, blue color channels (RGB).  * 4: Three color channels and an alpha channel (RGBA).  *  * The components are encoded in one of two ways:  *  * a) As a small integer, value 0..255, contained in a single byte.  For the  * alpha channel the original value is simply value/255.  For the color or  * luminance channels the value is encoded according to the sRGB specification  * and matches the 8-bit format expected by typical display devices.  *  * The color/gray channels are not scaled (pre-multiplied) by the alpha  * channel and are suitable for passing to color management software.  *  * b) As a value in the range 0..65535, contained in a 2-byte integer.  All  * channels can be converted to the original value by dividing by 65535; all  * channels are linear.  Color channels use the RGB encoding (RGB end-points) of  * the sRGB specification.  This encoding is identified by the  * PNG_FORMAT_FLAG_LINEAR flag below.  *  * When the simplified API needs to convert between sRGB and linear colorspaces,  * the actual sRGB transfer curve defined in the sRGB specification (see the  * article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2  * approximation used elsewhere in libpng.  *  * When an alpha channel is present it is expected to denote pixel coverage  * of the color or luminance channels and is returned as an associated alpha  * channel: the color/gray channels are scaled (pre-multiplied) by the alpha  * value.  *  * The samples are either contained directly in the image data, between 1 and 8  * bytes per pixel according to the encoding, or are held in a color-map indexed  * by bytes in the image data.  In the case of a color-map the color-map entries  * are individual samples, encoded as above, and the image data has one byte per  * pixel to select the relevant sample from the color-map.  */
comment|/* PNG_FORMAT_*  *  * #defines to be used in png_image::format.  Each #define identifies a  * particular layout of sample data and, if present, alpha values.  There are  * separate defines for each of the two component encodings.  *  * A format is built up using single bit flag values.  All combinations are  * valid.  Formats can be built up from the flag values or you can use one of  * the predefined values below.  When testing formats always use the FORMAT_FLAG  * macros to test for individual features - future versions of the library may  * add new flags.  *  * When reading or writing color-mapped images the format should be set to the  * format of the entries in the color-map then png_image_{read,write}_colormap  * called to read or write the color-map and set the format correctly for the  * image data.  Do not set the PNG_FORMAT_FLAG_COLORMAP bit directly!  *  * NOTE: libpng can be built with particular features disabled, if you see  * compiler errors because the definition of one of the following flags has been  * compiled out it is because libpng does not have the required support.  It is  * possible, however, for the libpng configuration to enable the format on just  * read or just write; in that case you may see an error at run time.  You can  * guard against this by checking for the definition of the appropriate  * "_SUPPORTED" macro, one of:  *  *    PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED  */
DECL|macro|PNG_FORMAT_FLAG_ALPHA
define|#
directive|define
name|PNG_FORMAT_FLAG_ALPHA
value|0x01U
comment|/* format with an alpha channel */
DECL|macro|PNG_FORMAT_FLAG_COLOR
define|#
directive|define
name|PNG_FORMAT_FLAG_COLOR
value|0x02U
comment|/* color format: otherwise grayscale */
DECL|macro|PNG_FORMAT_FLAG_LINEAR
define|#
directive|define
name|PNG_FORMAT_FLAG_LINEAR
value|0x04U
comment|/* 2 byte channels else 1 byte */
DECL|macro|PNG_FORMAT_FLAG_COLORMAP
define|#
directive|define
name|PNG_FORMAT_FLAG_COLORMAP
value|0x08U
comment|/* image data is color-mapped */
ifdef|#
directive|ifdef
name|PNG_FORMAT_BGR_SUPPORTED
DECL|macro|PNG_FORMAT_FLAG_BGR
define|#
directive|define
name|PNG_FORMAT_FLAG_BGR
value|0x10U
comment|/* BGR colors, else order is RGB */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_FORMAT_AFIRST_SUPPORTED
DECL|macro|PNG_FORMAT_FLAG_AFIRST
define|#
directive|define
name|PNG_FORMAT_FLAG_AFIRST
value|0x20U
comment|/* alpha channel comes first */
endif|#
directive|endif
comment|/* Commonly used formats have predefined macros.  *  * First the single byte (sRGB) formats:  */
DECL|macro|PNG_FORMAT_GRAY
define|#
directive|define
name|PNG_FORMAT_GRAY
value|0
DECL|macro|PNG_FORMAT_GA
define|#
directive|define
name|PNG_FORMAT_GA
value|PNG_FORMAT_FLAG_ALPHA
DECL|macro|PNG_FORMAT_AG
define|#
directive|define
name|PNG_FORMAT_AG
value|(PNG_FORMAT_GA|PNG_FORMAT_FLAG_AFIRST)
DECL|macro|PNG_FORMAT_RGB
define|#
directive|define
name|PNG_FORMAT_RGB
value|PNG_FORMAT_FLAG_COLOR
DECL|macro|PNG_FORMAT_BGR
define|#
directive|define
name|PNG_FORMAT_BGR
value|(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_BGR)
DECL|macro|PNG_FORMAT_RGBA
define|#
directive|define
name|PNG_FORMAT_RGBA
value|(PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)
DECL|macro|PNG_FORMAT_ARGB
define|#
directive|define
name|PNG_FORMAT_ARGB
value|(PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_AFIRST)
DECL|macro|PNG_FORMAT_BGRA
define|#
directive|define
name|PNG_FORMAT_BGRA
value|(PNG_FORMAT_BGR|PNG_FORMAT_FLAG_ALPHA)
DECL|macro|PNG_FORMAT_ABGR
define|#
directive|define
name|PNG_FORMAT_ABGR
value|(PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_AFIRST)
comment|/* Then the linear 2-byte formats.  When naming these "Y" is used to  * indicate a luminance (gray) channel.  */
DECL|macro|PNG_FORMAT_LINEAR_Y
define|#
directive|define
name|PNG_FORMAT_LINEAR_Y
value|PNG_FORMAT_FLAG_LINEAR
DECL|macro|PNG_FORMAT_LINEAR_Y_ALPHA
define|#
directive|define
name|PNG_FORMAT_LINEAR_Y_ALPHA
value|(PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_ALPHA)
DECL|macro|PNG_FORMAT_LINEAR_RGB
define|#
directive|define
name|PNG_FORMAT_LINEAR_RGB
value|(PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR)
DECL|macro|PNG_FORMAT_LINEAR_RGB_ALPHA
define|#
directive|define
name|PNG_FORMAT_LINEAR_RGB_ALPHA
define|\
value|(PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA)
comment|/* With color-mapped formats the image data is one byte for each pixel, the byte  * is an index into the color-map which is formatted as above.  To obtain a  * color-mapped format it is sufficient just to add the PNG_FOMAT_FLAG_COLORMAP  * to one of the above definitions, or you can use one of the definitions below.  */
DECL|macro|PNG_FORMAT_RGB_COLORMAP
define|#
directive|define
name|PNG_FORMAT_RGB_COLORMAP
value|(PNG_FORMAT_RGB|PNG_FORMAT_FLAG_COLORMAP)
DECL|macro|PNG_FORMAT_BGR_COLORMAP
define|#
directive|define
name|PNG_FORMAT_BGR_COLORMAP
value|(PNG_FORMAT_BGR|PNG_FORMAT_FLAG_COLORMAP)
DECL|macro|PNG_FORMAT_RGBA_COLORMAP
define|#
directive|define
name|PNG_FORMAT_RGBA_COLORMAP
value|(PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_COLORMAP)
DECL|macro|PNG_FORMAT_ARGB_COLORMAP
define|#
directive|define
name|PNG_FORMAT_ARGB_COLORMAP
value|(PNG_FORMAT_ARGB|PNG_FORMAT_FLAG_COLORMAP)
DECL|macro|PNG_FORMAT_BGRA_COLORMAP
define|#
directive|define
name|PNG_FORMAT_BGRA_COLORMAP
value|(PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_COLORMAP)
DECL|macro|PNG_FORMAT_ABGR_COLORMAP
define|#
directive|define
name|PNG_FORMAT_ABGR_COLORMAP
value|(PNG_FORMAT_ABGR|PNG_FORMAT_FLAG_COLORMAP)
comment|/* PNG_IMAGE macros  *  * These are convenience macros to derive information from a png_image  * structure.  The PNG_IMAGE_SAMPLE_ macros return values appropriate to the  * actual image sample values - either the entries in the color-map or the  * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values  * for the pixels and will always return 1 for color-mapped formats.  The  * remaining macros return information about the rows in the image and the  * complete image.  *  * NOTE: All the macros that take a png_image::format parameter are compile time  * constants if the format parameter is, itself, a constant.  Therefore these  * macros can be used in array declarations and case labels where required.  * Similarly the macros are also pre-processor constants (sizeof is not used) so  * they can be used in #if tests.  *  * First the information about the samples.  */
DECL|macro|PNG_IMAGE_SAMPLE_CHANNELS
define|#
directive|define
name|PNG_IMAGE_SAMPLE_CHANNELS
parameter_list|(
name|fmt
parameter_list|)
define|\
value|(((fmt)&(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA))+1)
comment|/* Return the total number of channels in a given format: 1..4 */
DECL|macro|PNG_IMAGE_SAMPLE_COMPONENT_SIZE
define|#
directive|define
name|PNG_IMAGE_SAMPLE_COMPONENT_SIZE
parameter_list|(
name|fmt
parameter_list|)
define|\
value|((((fmt)& PNG_FORMAT_FLAG_LINEAR)>> 2)+1)
comment|/* Return the size in bytes of a single component of a pixel or color-map     * entry (as appropriate) in the image: 1 or 2.     */
DECL|macro|PNG_IMAGE_SAMPLE_SIZE
define|#
directive|define
name|PNG_IMAGE_SAMPLE_SIZE
parameter_list|(
name|fmt
parameter_list|)
define|\
value|(PNG_IMAGE_SAMPLE_CHANNELS(fmt) * PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt))
comment|/* This is the size of the sample data for one sample.  If the image is     * color-mapped it is the size of one color-map entry (and image pixels are     * one byte in size), otherwise it is the size of one image pixel.     */
DECL|macro|PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS
define|#
directive|define
name|PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS
parameter_list|(
name|fmt
parameter_list|)
define|\
value|(PNG_IMAGE_SAMPLE_CHANNELS(fmt) * 256)
comment|/* The maximum size of the color-map required by the format expressed in a     * count of components.  This can be used to compile-time allocate a     * color-map:     *     * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];     *     * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];     *     * Alternatively use the PNG_IMAGE_COLORMAP_SIZE macro below to use the     * information from one of the png_image_begin_read_ APIs and dynamically     * allocate the required memory.     */
comment|/* Corresponding information about the pixels */
DECL|macro|PNG_IMAGE_PIXEL_
define|#
directive|define
name|PNG_IMAGE_PIXEL_
parameter_list|(
name|test
parameter_list|,
name|fmt
parameter_list|)
define|\
value|(((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))
DECL|macro|PNG_IMAGE_PIXEL_CHANNELS
define|#
directive|define
name|PNG_IMAGE_PIXEL_CHANNELS
parameter_list|(
name|fmt
parameter_list|)
define|\
value|PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_CHANNELS,fmt)
comment|/* The number of separate channels (components) in a pixel; 1 for a     * color-mapped image.     */
DECL|macro|PNG_IMAGE_PIXEL_COMPONENT_SIZE
define|#
directive|define
name|PNG_IMAGE_PIXEL_COMPONENT_SIZE
parameter_list|(
name|fmt
parameter_list|)
define|\
value|PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
comment|/* The size, in bytes, of each component in a pixel; 1 for a color-mapped     * image.     */
DECL|macro|PNG_IMAGE_PIXEL_SIZE
define|#
directive|define
name|PNG_IMAGE_PIXEL_SIZE
parameter_list|(
name|fmt
parameter_list|)
value|PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_SIZE,fmt)
comment|/* The size, in bytes, of a complete pixel; 1 for a color-mapped image. */
comment|/* Information about the whole row, or whole image */
DECL|macro|PNG_IMAGE_ROW_STRIDE
define|#
directive|define
name|PNG_IMAGE_ROW_STRIDE
parameter_list|(
name|image
parameter_list|)
define|\
value|(PNG_IMAGE_PIXEL_CHANNELS((image).format) * (image).width)
comment|/* Return the total number of components in a single row of the image; this     * is the minimum 'row stride', the minimum count of components between each     * row.  For a color-mapped image this is the minimum number of bytes in a     * row.     */
DECL|macro|PNG_IMAGE_BUFFER_SIZE
define|#
directive|define
name|PNG_IMAGE_BUFFER_SIZE
parameter_list|(
name|image
parameter_list|,
name|row_stride
parameter_list|)
define|\
value|(PNG_IMAGE_PIXEL_COMPONENT_SIZE((image).format)*(image).height*(row_stride))
comment|/* Return the size, in bytes, of an image buffer given a png_image and a row     * stride - the number of components to leave space for in each row.     */
DECL|macro|PNG_IMAGE_SIZE
define|#
directive|define
name|PNG_IMAGE_SIZE
parameter_list|(
name|image
parameter_list|)
define|\
value|PNG_IMAGE_BUFFER_SIZE(image, PNG_IMAGE_ROW_STRIDE(image))
comment|/* Return the size, in bytes, of the image in memory given just a png_image;     * the row stride is the minimum stride required for the image.     */
DECL|macro|PNG_IMAGE_COLORMAP_SIZE
define|#
directive|define
name|PNG_IMAGE_COLORMAP_SIZE
parameter_list|(
name|image
parameter_list|)
define|\
value|(PNG_IMAGE_SAMPLE_SIZE((image).format) * (image).colormap_entries)
comment|/* Return the size, in bytes, of the color-map of this image.  If the image     * format is not a color-map format this will return a size sufficient for     * 256 entries in the given format; check PNG_FORMAT_FLAG_COLORMAP if     * you don't want to allocate a color-map in this case.     */
comment|/* PNG_IMAGE_FLAG_*  *  * Flags containing additional information about the image are held in the  * 'flags' field of png_image.  */
DECL|macro|PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB
define|#
directive|define
name|PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB
value|0x01
comment|/* This indicates the the RGB values of the in-memory bitmap do not     * correspond to the red, green and blue end-points defined by sRGB.     */
DECL|macro|PNG_IMAGE_FLAG_FAST
define|#
directive|define
name|PNG_IMAGE_FLAG_FAST
value|0x02
comment|/* On write emphasise speed over compression; the resultant PNG file will be     * larger but will be produced significantly faster, particular for large     * images.  Do not use this option for images which will be distributed, only     * used it when producing intermediate files that will be read back in     * repeatedly.  For a typical 24-bit image the option will double the read     * speed at the cost of increasing the image size by 25%, however for many     * more compressible images the PNG file can be 10 times larger with only a     * slight speed gain.     */
DECL|macro|PNG_IMAGE_FLAG_16BIT_sRGB
define|#
directive|define
name|PNG_IMAGE_FLAG_16BIT_sRGB
value|0x04
comment|/* On read if the image is a 16-bit per component image and there is no gAMA     * or sRGB chunk assume that the components are sRGB encoded.  Notice that     * images output by the simplified API always have gamma information; setting     * this flag only affects the interpretation of 16-bit images from an     * external source.  It is recommended that the application expose this flag     * to the user; the user can normally easily recognize the difference between     * linear and sRGB encoding.  This flag has no effect on write - the data     * passed to the write APIs must have the correct encoding (as defined     * above.)     *     * If the flag is not set (the default) input 16-bit per component data is     * assumed to be linear.     *     * NOTE: the flag can only be set after the png_image_begin_read_ call,     * because that call initializes the 'flags' field.     */
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_READ_SUPPORTED
comment|/* READ APIs  * ---------  *  * The png_image passed to the read APIs must have been initialized by setting  * the png_controlp field 'opaque' to NULL (or, safer, memset the whole thing.)  */
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|234
argument_list|,
name|int
argument_list|,
name|png_image_begin_read_from_file
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
specifier|const
name|char
operator|*
name|file_name
operator|)
argument_list|)
expr_stmt|;
comment|/* The named file is opened for read and the image header is filled in     * from the PNG header in the file.     */
name|PNG_EXPORT
argument_list|(
literal|235
argument_list|,
name|int
argument_list|,
name|png_image_begin_read_from_stdio
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
name|FILE
operator|*
name|file
operator|)
argument_list|)
expr_stmt|;
comment|/* The PNG header is read from the stdio FILE object. */
endif|#
directive|endif
comment|/* STDIO */
name|PNG_EXPORT
argument_list|(
literal|236
argument_list|,
name|int
argument_list|,
name|png_image_begin_read_from_memory
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
name|png_const_voidp
name|memory
operator|,
name|png_size_t
name|size
operator|)
argument_list|)
expr_stmt|;
comment|/* The PNG header is read from the given memory buffer. */
name|PNG_EXPORT
argument_list|(
literal|237
argument_list|,
name|int
argument_list|,
name|png_image_finish_read
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
name|png_const_colorp
name|background
operator|,
name|void
operator|*
name|buffer
operator|,
name|png_int_32
name|row_stride
operator|,
name|void
operator|*
name|colormap
operator|)
argument_list|)
expr_stmt|;
comment|/* Finish reading the image into the supplied buffer and clean up the     * png_image structure.     *     * row_stride is the step, in byte or 2-byte units as appropriate,     * between adjacent rows.  A positive stride indicates that the top-most row     * is first in the buffer - the normal top-down arrangement.  A negative     * stride indicates that the bottom-most row is first in the buffer.     *     * background need only be supplied if an alpha channel must be removed from     * a png_byte format and the removal is to be done by compositing on a solid     * color; otherwise it may be NULL and any composition will be done directly     * onto the buffer.  The value is an sRGB color to use for the background,     * for grayscale output the green channel is used.     *     * background must be supplied when an alpha channel must be removed from a     * single byte color-mapped output format, in other words if:     *     * 1) The original format from png_image_begin_read_from_* had     *    PNG_FORMAT_FLAG_ALPHA set.     * 2) The format set by the application does not.     * 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and     *    PNG_FORMAT_FLAG_LINEAR *not* set.     *     * For linear output removing the alpha channel is always done by compositing     * on black and background is ignored.     *     * colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must     * be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.     * image->colormap_entries will be updated to the actual number of entries     * written to the colormap; this may be less than the original value.     */
name|PNG_EXPORT
argument_list|(
literal|238
argument_list|,
name|void
argument_list|,
name|png_image_free
argument_list|,
operator|(
name|png_imagep
name|image
operator|)
argument_list|)
expr_stmt|;
comment|/* Free any data allocated by libpng in image->opaque, setting the pointer to     * NULL.  May be called at any time after the structure is initialized.     */
endif|#
directive|endif
comment|/* SIMPLIFIED_READ */
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
comment|/* WRITE APIS  * ----------  * For write you must initialize a png_image structure to describe the image to  * be written.  To do this use memset to set the whole structure to 0 then  * initialize fields describing your image.  *  * version: must be set to PNG_IMAGE_VERSION  * opaque: must be initialized to NULL  * width: image width in pixels  * height: image height in rows  * format: the format of the data (image and color-map) you wish to write  * flags: set to 0 unless one of the defined flags applies; set  *    PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB for color format images where the RGB  *    values do not correspond to the colors in sRGB.  * colormap_entries: set to the number of entries in the color-map (0 to 256)  */
name|PNG_EXPORT
argument_list|(
literal|239
argument_list|,
name|int
argument_list|,
name|png_image_write_to_file
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|convert_to_8bit
operator|,
specifier|const
name|void
operator|*
name|buffer
operator|,
name|png_int_32
name|row_stride
operator|,
specifier|const
name|void
operator|*
name|colormap
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the image to the named file. */
name|PNG_EXPORT
argument_list|(
literal|240
argument_list|,
name|int
argument_list|,
name|png_image_write_to_stdio
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
name|FILE
operator|*
name|file
operator|,
name|int
name|convert_to_8_bit
operator|,
specifier|const
name|void
operator|*
name|buffer
operator|,
name|png_int_32
name|row_stride
operator|,
specifier|const
name|void
operator|*
name|colormap
operator|)
argument_list|)
expr_stmt|;
comment|/* Write the image to the given (FILE*). */
comment|/* With both write APIs if image is in one of the linear formats with 16-bit  * data then setting convert_to_8_bit will cause the output to be an 8-bit PNG  * gamma encoded according to the sRGB specification, otherwise a 16-bit linear  * encoded PNG file is written.  *  * With color-mapped data formats the colormap parameter point to a color-map  * with at least image->colormap_entries encoded in the specified format.  If  * the format is linear the written PNG color-map will be converted to sRGB  * regardless of the convert_to_8_bit flag.  *  * With all APIs row_stride is handled as in the read APIs - it is the spacing  * from one row to the next in component sized units (1 or 2 bytes) and if  * negative indicates a bottom-up row layout in the buffer.  *  * Note that the write API does not support interlacing or sub-8-bit pixels.  */
endif|#
directive|endif
comment|/* STDIO */
endif|#
directive|endif
comment|/* SIMPLIFIED_WRITE */
comment|/*******************************************************************************  *  END OF SIMPLIFIED API  ******************************************************************************/
endif|#
directive|endif
comment|/* SIMPLIFIED_{READ|WRITE} */
ifdef|#
directive|ifdef
name|PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|242
argument_list|,
name|void
argument_list|,
name|png_set_check_for_invalid_index
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|allowed
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_GET_PALETTE_MAX_SUPPORTED
name|PNG_EXPORT
argument_list|(
literal|243
argument_list|,
name|int
argument_list|,
name|png_get_palette_max
argument_list|,
operator|(
name|png_const_structp
name|png_ptr
operator|,
name|png_const_infop
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* CHECK_FOR_INVALID_INDEX */
comment|/*******************************************************************************  *  IMPLEMENTATION OPTIONS  *******************************************************************************  *  * Support for arbitrary implementation-specific optimizations.  The API allows  * particular options to be turned on or off.  'Option' is the number of the  * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given  * by the PNG_OPTION_ defines below.  *  * HARDWARE: normally hardware capabilites, such as the Intel SSE instructions,  *           are detected at run time, however sometimes it may be impossible  *           to do this in user mode, in which case it is necessary to discover  *           the capabilities in an OS specific way.  Such capabilities are  *           listed here when libpng has support for them and must be turned  *           ON by the application if present.  *  * SOFTWARE: sometimes software optimizations actually result in performance  *           decrease on some architectures or systems, or with some sets of  *           PNG images.  'Software' options allow such optimizations to be  *           selected at run time.  */
ifdef|#
directive|ifdef
name|PNG_SET_OPTION_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_ARM_NEON_API_SUPPORTED
DECL|macro|PNG_ARM_NEON
define|#
directive|define
name|PNG_ARM_NEON
value|0
comment|/* HARDWARE: ARM Neon SIMD instructions supported */
endif|#
directive|endif
DECL|macro|PNG_MAXIMUM_INFLATE_WINDOW
define|#
directive|define
name|PNG_MAXIMUM_INFLATE_WINDOW
value|2
comment|/* SOFTWARE: force maximum window */
DECL|macro|PNG_SKIP_sRGB_CHECK_PROFILE
define|#
directive|define
name|PNG_SKIP_sRGB_CHECK_PROFILE
value|4
comment|/* SOFTWARE: Check ICC profile for sRGB */
DECL|macro|PNG_OPTION_NEXT
define|#
directive|define
name|PNG_OPTION_NEXT
value|6
comment|/* Next option - numbers must be even */
comment|/* Return values: NOTE: there are four values and 'off' is *not* zero */
DECL|macro|PNG_OPTION_UNSET
define|#
directive|define
name|PNG_OPTION_UNSET
value|0
comment|/* Unset - defaults to off */
DECL|macro|PNG_OPTION_INVALID
define|#
directive|define
name|PNG_OPTION_INVALID
value|1
comment|/* Option number out of range */
DECL|macro|PNG_OPTION_OFF
define|#
directive|define
name|PNG_OPTION_OFF
value|2
DECL|macro|PNG_OPTION_ON
define|#
directive|define
name|PNG_OPTION_ON
value|3
name|PNG_EXPORT
argument_list|(
literal|244
argument_list|,
name|int
argument_list|,
name|png_set_option
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|option
operator|,
name|int
name|onoff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SET_OPTION */
comment|/*******************************************************************************  *  END OF HARDWARE AND SOFTWARE OPTIONS  ******************************************************************************/
comment|/* Maintainer: Put new public prototypes here ^, in libpng.3, in project  * defs, and in scripts/symbols.def.  */
comment|/* The last ordinal number (this is the *last* one already used; the next  * one to use is one more than this.)  */
ifdef|#
directive|ifdef
name|PNG_EXPORT_LAST_ORDINAL
name|PNG_EXPORT_LAST_ORDINAL
argument_list|(
literal|244
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_VERSION_INFO_ONLY */
end_comment
begin_comment
comment|/* Do not put anything past this line */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_H */
end_comment
end_unit
