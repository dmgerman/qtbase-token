begin_unit
begin_comment
comment|/* pngpriv.h - private declarations for use inside libpng  *  * Last changed in libpng 1.6.17 [March 26, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_comment
comment|/* The symbols declared in this file (including the functions declared  * as extern) are PRIVATE.  They are not part of the libpng public  * interface, and are not recommended for use by regular applications.  * Some of them may become public in the future; others may stay private,  * change in an incompatible way, or even disappear.  * Although the libpng users are not forbidden to include this header,  * they should be well aware of the issues that may arise from doing so.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNGPRIV_H
end_ifndef
begin_define
DECL|macro|PNGPRIV_H
define|#
directive|define
name|PNGPRIV_H
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|_CRT_SECURE_NO_DEPRECATE
end_ifndef
begin_define
DECL|macro|_CRT_SECURE_NO_DEPRECATE
define|#
directive|define
name|_CRT_SECURE_NO_DEPRECATE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Feature Test Macros.  The following are defined here to ensure that correctly  * implemented libraries reveal the APIs libpng needs to build and hide those  * that are not needed and potentially damaging to the compilation.  *  * Feature Test Macros must be defined before any system header is included (see  * POSIX 1003.1 2.8.2 "POSIX Symbols."  *  * These macros only have an effect if the operating system supports either  * POSIX 1003.1 or C99, or both.  On other operating systems (particularly  * Windows/Visual Studio) there is no effect; the OS specific tests below are  * still required (as of 2011-05-02.)  */
end_comment
begin_define
DECL|macro|_POSIX_SOURCE
define|#
directive|define
name|_POSIX_SOURCE
value|1
end_define
begin_comment
DECL|macro|_POSIX_SOURCE
comment|/* Just the POSIX 1003.1 and C89 APIs */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_comment
comment|/* Standard library headers not required by png.h: */
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|PNGLIB_BUILD
define|#
directive|define
name|PNGLIB_BUILD
end_define
begin_comment
DECL|macro|PNGLIB_BUILD
comment|/*libpng is being built, not used*/
end_comment
begin_comment
comment|/* If HAVE_CONFIG_H is defined during the build then the build system must  * provide an appropriate "config.h" file on the include path.  The header file  * must provide definitions as required below (search for "HAVE_CONFIG_H");  * see configure.ac for more details of the requirements.  The macro  * "PNG_NO_CONFIG_H" is provided for maintainers to test for dependencies on  * 'configure'; define this macro to prevent the configure build including the  * configure generated config.h.  Libpng is expected to compile without *any*  * special build system support on a reasonably ANSI-C compliant system.  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_NO_CONFIG_H
argument_list|)
end_if
begin_include
include|#
directive|include
file|<config.h>
end_include
begin_comment
comment|/* Pick up the definition of 'restrict' from config.h if it was read: */
end_comment
begin_define
DECL|macro|PNG_RESTRICT
define|#
directive|define
name|PNG_RESTRICT
value|restrict
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* To support symbol prefixing it is necessary to know *before* including png.h  * whether the fixed point (and maybe other) APIs are exported, because if they  * are not internal definitions may be required.  This is handled below just  * before png.h is included, but load the configuration now if it is available.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNGLCONF_H
end_ifndef
begin_include
include|#
directive|include
file|"pnglibconf.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Local renames may change non-exported API functions from png.h */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_PREFIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNGPREFIX_H
argument_list|)
end_if
begin_include
include|#
directive|include
file|"pngprefix.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_USER_CONFIG
end_ifdef
begin_include
include|#
directive|include
file|"pngusr.h"
end_include
begin_comment
comment|/* These should have been defined in pngusr.h */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_USER_PRIVATEBUILD
end_ifndef
begin_define
DECL|macro|PNG_USER_PRIVATEBUILD
define|#
directive|define
name|PNG_USER_PRIVATEBUILD
value|"Custom libpng build"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_USER_DLLFNAME_POSTFIX
end_ifndef
begin_define
DECL|macro|PNG_USER_DLLFNAME_POSTFIX
define|#
directive|define
name|PNG_USER_DLLFNAME_POSTFIX
value|"Cb"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Compile time options.  * =====================  * In a multi-arch build the compiler may compile the code several times for the  * same object module, producing different binaries for different architectures.  * When this happens configure-time setting of the target host options cannot be  * done and this interferes with the handling of the ARM NEON optimizations, and  * possibly other similar optimizations.  Put additional tests here; in general  * this is needed when the same option can be changed at both compile time and  * run time depending on the target OS (i.e. iOS vs Android.)  *  * NOTE: symbol prefixing does not pass $(CFLAGS) to the preprocessor, because  * this is not possible with certain compilers (Oracle SUN OS CC), as a result  * it is necessary to ensure that all extern functions that *might* be used  * regardless of $(CFLAGS) get declared in this file.  The test on __ARM_NEON__  * below is one example of this behavior because it is controlled by the  * presence or not of -mfpu=neon on the GCC command line, it is possible to do  * this in $(CC), e.g. "CC=gcc -mfpu=neon", but people who build libpng rarely  * do this.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_ARM_NEON_OPT
end_ifndef
begin_comment
comment|/* ARM NEON optimizations are being controlled by the compiler settings,     * typically the target FPU.  If the FPU has been set to NEON (-mfpu=neon     * with GCC) then the compiler will define __ARM_NEON__ and we can rely     * unconditionally on NEON instructions not crashing, otherwise we must     * disable use of NEON instructions.     *     * NOTE: at present these optimizations depend on 'ALIGNED_MEMORY', so they     * can only be turned on automatically if that is supported too.  If     * PNG_ARM_NEON_OPT is set in CPPFLAGS (to>0) then arm/arm_init.c will fail     * to compile with an appropriate #error if ALIGNED_MEMORY has been turned     * off.     *     * Note that gcc-4.9 defines __ARM_NEON instead of __ARM_NEON__, so we     * check both variants.     */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__ARM_NEON__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_NEON
argument_list|)
operator|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_ALIGNED_MEMORY_SUPPORTED
argument_list|)
end_if
begin_define
DECL|macro|PNG_ARM_NEON_OPT
define|#
directive|define
name|PNG_ARM_NEON_OPT
value|2
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PNG_ARM_NEON_OPT
define|#
directive|define
name|PNG_ARM_NEON_OPT
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|PNG_ARM_NEON_OPT
operator|>
literal|0
end_if
begin_comment
comment|/* NEON optimizations are to be at least considered by libpng, so enable the     * callbacks to do this.     */
end_comment
begin_define
DECL|macro|PNG_FILTER_OPTIMIZATIONS
define|#
directive|define
name|PNG_FILTER_OPTIMIZATIONS
value|png_init_filter_functions_neon
end_define
begin_comment
comment|/* By default the 'intrinsics' code in arm/filter_neon_intrinsics.c is used     * if possible - if __ARM_NEON__ is set and the compiler version is not known     * to be broken.  This is controlled by PNG_ARM_NEON_IMPLEMENTATION which can     * be:     *     *    1  The intrinsics code (the default with __ARM_NEON__)     *    2  The hand coded assembler (the default without __ARM_NEON__)     *     * It is possible to set PNG_ARM_NEON_IMPLEMENTATION in CPPFLAGS, however     * this is *NOT* supported and may cease to work even after a minor revision     * to libpng.  It *is* valid to do this for testing purposes, e.g. speed     * testing or a new compiler, but the results should be communicated to the     * libpng implementation list for incorporation in the next minor release.     */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_ARM_NEON_IMPLEMENTATION
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ARM_NEON__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_NEON
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__clang__
argument_list|)
end_if
begin_comment
comment|/* At present it is unknown by the libpng developers which versions              * of clang support the intrinsics, however some or perhaps all              * versions do not work with the assembler so this may be              * irrelevant, so just use the default (do nothing here.)              */
end_comment
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_elif
begin_comment
comment|/* GCC 4.5.4 NEON support is known to be broken.  4.6.3 is known to              * work, so if this *is* GCC, or G++, look for a version>4.5              */
end_comment
begin_if
if|#
directive|if
name|__GNUC__
operator|<
literal|4
operator|||
operator|(
name|__GNUC__
operator|==
literal|4
operator|&&
name|__GNUC_MINOR__
operator|<
literal|6
operator|)
end_if
begin_define
DECL|macro|PNG_ARM_NEON_IMPLEMENTATION
define|#
directive|define
name|PNG_ARM_NEON_IMPLEMENTATION
value|2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* no GNUC support */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __GNUC__ */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !defined __ARM_NEON__ */
end_comment
begin_comment
comment|/* The 'intrinsics' code simply won't compile without this -mfpu=neon:           */
end_comment
begin_define
DECL|macro|PNG_ARM_NEON_IMPLEMENTATION
define|#
directive|define
name|PNG_ARM_NEON_IMPLEMENTATION
value|2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __ARM_NEON__ */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !PNG_ARM_NEON_IMPLEMENTATION */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_ARM_NEON_IMPLEMENTATION
end_ifndef
begin_comment
comment|/* Use the intrinsics code by default. */
end_comment
begin_define
DECL|macro|PNG_ARM_NEON_IMPLEMENTATION
define|#
directive|define
name|PNG_ARM_NEON_IMPLEMENTATION
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_ARM_NEON_OPT> 0 */
end_comment
begin_comment
comment|/* Is this a build of a DLL where compilation of the object modules requires  * different preprocessor settings to those required for a simple library?  If  * so PNG_BUILD_DLL must be set.  *  * If libpng is used inside a DLL but that DLL does not export the libpng APIs  * PNG_BUILD_DLL must not be set.  To avoid the code below kicking in build a  * static library of libpng then link the DLL against that.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_BUILD_DLL
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|DLL_EXPORT
end_ifdef
begin_comment
comment|/* This is set by libtool when files are compiled for a DLL; libtool        * always compiles twice, even on systems where it isn't necessary.  Set        * PNG_BUILD_DLL in case it is necessary:        */
end_comment
begin_define
DECL|macro|PNG_BUILD_DLL
define|#
directive|define
name|PNG_BUILD_DLL
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|_WINDLL
end_ifdef
begin_comment
comment|/* This is set by the Microsoft Visual Studio IDE in projects that           * build a DLL.  It can't easily be removed from those projects (it           * isn't visible in the Visual Studio UI) so it is a fairly reliable           * indication that PNG_IMPEXP needs to be set to the DLL export           * attributes.           */
end_comment
begin_define
DECL|macro|PNG_BUILD_DLL
define|#
directive|define
name|PNG_BUILD_DLL
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|__DLL__
end_ifdef
begin_comment
comment|/* This is set by the Borland C system when compiling for a DLL              * (as above.)              */
end_comment
begin_define
DECL|macro|PNG_BUILD_DLL
define|#
directive|define
name|PNG_BUILD_DLL
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Add additional compiler cases here. */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Setting PNG_BUILD_DLL if required */
end_comment
begin_comment
comment|/* Modfied for usage in Qt: Do not export the libpng APIs */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_BUILD_DLL
end_ifdef
begin_undef
DECL|macro|PNG_BUILD_DLL
undef|#
directive|undef
name|PNG_BUILD_DLL
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* See pngconf.h for more details: the builder of the library may set this on  * the command line to the right thing for the specific compilation system or it  * may be automagically set above (at present we know of no system where it does  * need to be set on the command line.)  *  * PNG_IMPEXP must be set here when building the library to prevent pngconf.h  * setting it to the "import" setting for a DLL build.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_IMPEXP
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_BUILD_DLL
end_ifdef
begin_define
DECL|macro|PNG_IMPEXP
define|#
directive|define
name|PNG_IMPEXP
value|PNG_DLL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Not building a DLL, or the DLL doesn't require specific export        * definitions.        */
end_comment
begin_define
DECL|macro|PNG_IMPEXP
define|#
directive|define
name|PNG_IMPEXP
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* No warnings for private or deprecated functions in the build: */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_DEPRECATED
end_ifndef
begin_define
DECL|macro|PNG_DEPRECATED
define|#
directive|define
name|PNG_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_PRIVATE
end_ifndef
begin_define
DECL|macro|PNG_PRIVATE
define|#
directive|define
name|PNG_PRIVATE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Symbol preprocessing support.  *  * To enable listing global, but internal, symbols the following macros should  * always be used to declare an extern data or function object in this file.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_INTERNAL_DATA
end_ifndef
begin_define
DECL|macro|PNG_INTERNAL_DATA
define|#
directive|define
name|PNG_INTERNAL_DATA
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|array
parameter_list|)
value|extern type name array
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_INTERNAL_FUNCTION
end_ifndef
begin_define
DECL|macro|PNG_INTERNAL_FUNCTION
define|#
directive|define
name|PNG_INTERNAL_FUNCTION
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|attributes
parameter_list|)
define|\
value|extern PNG_FUNCTION(type, name, args, PNG_EMPTY attributes)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_INTERNAL_CALLBACK
end_ifndef
begin_define
DECL|macro|PNG_INTERNAL_CALLBACK
define|#
directive|define
name|PNG_INTERNAL_CALLBACK
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|attributes
parameter_list|)
define|\
value|extern PNG_FUNCTION(type, (PNGCBAPI name), args, PNG_EMPTY attributes)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* If floating or fixed point APIs are disabled they may still be compiled  * internally.  To handle this make sure they are declared as the appropriate  * internal extern function (otherwise the symbol prefixing stuff won't work and  * the functions will be used without definitions.)  *  * NOTE: although all the API functions are declared here they are not all  * actually built!  Because the declarations are still made it is necessary to  * fake out types that they depend on.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FP_EXPORT
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifndef
begin_define
DECL|macro|PNG_FP_EXPORT
define|#
directive|define
name|PNG_FP_EXPORT
parameter_list|(
name|ordinal
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|)
define|\
value|PNG_INTERNAL_FUNCTION(type, name, args, PNG_EMPTY);
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_typedef
DECL|typedef|png_double
typedef|typedef
name|struct
name|png_incomplete
name|png_double
typedef|;
end_typedef
begin_typedef
DECL|typedef|png_doublep
typedef|typedef
name|png_double
modifier|*
name|png_doublep
typedef|;
end_typedef
begin_typedef
DECL|typedef|png_const_doublep
typedef|typedef
specifier|const
name|png_double
modifier|*
name|png_const_doublep
typedef|;
end_typedef
begin_typedef
DECL|typedef|png_doublepp
typedef|typedef
name|png_double
modifier|*
modifier|*
name|png_doublepp
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FIXED_EXPORT
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FIXED_POINT_SUPPORTED
end_ifndef
begin_define
DECL|macro|PNG_FIXED_EXPORT
define|#
directive|define
name|PNG_FIXED_EXPORT
parameter_list|(
name|ordinal
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|)
define|\
value|PNG_INTERNAL_FUNCTION(type, name, args, PNG_EMPTY);
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"png.h"
end_include
begin_comment
comment|/* pngconf.h does not set PNG_DLL_EXPORT unless it is required, so: */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_DLL_EXPORT
end_ifndef
begin_define
DECL|macro|PNG_DLL_EXPORT
define|#
directive|define
name|PNG_DLL_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SECURITY and SAFETY:  *  * libpng is built with support for internal limits on image dimensions and  * memory usage.  These are documented in scripts/pnglibconf.dfa of the  * source and recorded in the machine generated header file pnglibconf.h.  */
end_comment
begin_comment
comment|/* If you are running on a machine where you cannot allocate more  * than 64K of memory at once, uncomment this.  While libpng will not  * normally need that much memory in a chunk (unless you load up a very  * large file), zlib needs to know how big of a chunk it can use, and  * libpng thus makes sure to check any memory allocation to verify it  * will fit into memory.  *  * zlib provides 'MAXSEG_64K' which, if defined, indicates the  * same limit and pngconf.h (already included) sets the limit  * if certain operating systems are detected.  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAXSEG_64K
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_MAX_MALLOC_64K
argument_list|)
end_if
begin_define
DECL|macro|PNG_MAX_MALLOC_64K
define|#
directive|define
name|PNG_MAX_MALLOC_64K
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_UNUSED
end_ifndef
begin_comment
comment|/* Unused formal parameter warnings are silenced using the following macro  * which is expected to have no bad effects on performance (optimizing  * compilers will probably remove it entirely).  Note that if you replace  * it with something other than whitespace, you must include the terminating  * semicolon.  */
end_comment
begin_define
DECL|macro|PNG_UNUSED
define|#
directive|define
name|PNG_UNUSED
parameter_list|(
name|param
parameter_list|)
value|(void)param;
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Just a little check that someone hasn't tried to define something  * contradictory.  */
end_comment
begin_if
if|#
directive|if
operator|(
name|PNG_ZBUF_SIZE
operator|>
literal|65536L
operator|)
operator|&&
name|defined
argument_list|(
name|PNG_MAX_MALLOC_64K
argument_list|)
end_if
begin_undef
DECL|macro|PNG_ZBUF_SIZE
undef|#
directive|undef
name|PNG_ZBUF_SIZE
end_undef
begin_define
DECL|macro|PNG_ZBUF_SIZE
define|#
directive|define
name|PNG_ZBUF_SIZE
value|65536L
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* If warnings or errors are turned off the code is disabled or redirected here.  * From 1.5.4 functions have been added to allow very limited formatting of  * error and warning messages - this code will also be disabled here.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
end_ifdef
begin_define
DECL|macro|PNG_WARNING_PARAMETERS
define|#
directive|define
name|PNG_WARNING_PARAMETERS
parameter_list|(
name|p
parameter_list|)
value|png_warning_parameters p;
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|png_warning_parameter
define|#
directive|define
name|png_warning_parameter
parameter_list|(
name|p
parameter_list|,
name|number
parameter_list|,
name|string
parameter_list|)
value|((void)0)
end_define
begin_define
DECL|macro|png_warning_parameter_unsigned
define|#
directive|define
name|png_warning_parameter_unsigned
parameter_list|(
name|p
parameter_list|,
name|number
parameter_list|,
name|format
parameter_list|,
name|value
parameter_list|)
value|((void)0)
end_define
begin_define
DECL|macro|png_warning_parameter_signed
define|#
directive|define
name|png_warning_parameter_signed
parameter_list|(
name|p
parameter_list|,
name|number
parameter_list|,
name|format
parameter_list|,
name|value
parameter_list|)
value|((void)0)
end_define
begin_define
DECL|macro|png_formatted_warning
define|#
directive|define
name|png_formatted_warning
parameter_list|(
name|pp
parameter_list|,
name|p
parameter_list|,
name|message
parameter_list|)
value|((void)(pp))
end_define
begin_define
DECL|macro|PNG_WARNING_PARAMETERS
define|#
directive|define
name|PNG_WARNING_PARAMETERS
parameter_list|(
name|p
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_ERROR_TEXT_SUPPORTED
end_ifndef
begin_define
DECL|macro|png_fixed_error
define|#
directive|define
name|png_fixed_error
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|png_err(s1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* C allows up-casts from (void*) to any pointer and (const void*) to any  * pointer to a const object.  C++ regards this as a type error and requires an  * explicit, static, cast and provides the static_cast<> rune to ensure that  * const is not cast away.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_define
DECL|macro|png_voidcast
define|#
directive|define
name|png_voidcast
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
value|static_cast<type>(value)
end_define
begin_define
DECL|macro|png_constcast
define|#
directive|define
name|png_constcast
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
value|const_cast<type>(value)
end_define
begin_define
DECL|macro|png_aligncast
define|#
directive|define
name|png_aligncast
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
define|\
value|static_cast<type>(static_cast<void*>(value))
end_define
begin_define
DECL|macro|png_aligncastconst
define|#
directive|define
name|png_aligncastconst
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
define|\
value|static_cast<type>(static_cast<const void*>(value))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|png_voidcast
define|#
directive|define
name|png_voidcast
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
value|(value)
end_define
begin_define
DECL|macro|png_constcast
define|#
directive|define
name|png_constcast
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
value|((type)(value))
end_define
begin_define
DECL|macro|png_aligncast
define|#
directive|define
name|png_aligncast
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
value|((void*)(value))
end_define
begin_define
DECL|macro|png_aligncastconst
define|#
directive|define
name|png_aligncastconst
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
value|((const void*)(value))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __cplusplus */
end_comment
begin_comment
comment|/* Some fixed point APIs are still required even if not exported because  * they get used by the corresponding floating point APIs.  This magic  * deals with this:  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_define
DECL|macro|PNGFAPI
define|#
directive|define
name|PNGFAPI
value|PNGAPI
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PNGFAPI
define|#
directive|define
name|PNGFAPI
end_define
begin_comment
DECL|macro|PNGFAPI
comment|/* PRIVATE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_comment
comment|/* Other defines specific to compilers can go here.  Try to keep  * them inside an appropriate ifdef/endif pair for portability.  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* png.c requires the following ANSI-C constants if the conversion of     * floating point to ASCII is implemented therein:     *     *  DBL_DIG  Maximum number of decimal digits (can be set to any constant)     *  DBL_MIN  Smallest normalized fp number (can be set to an arbitrary value)     *  DBL_MAX  Maximum floating point number (can be set to an arbitrary value)     */
end_comment
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__MWERKS__
argument_list|)
operator|&&
name|defined
argument_list|(
name|macintosh
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|applec
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|THINK_C
argument_list|)
operator|||
name|defined
argument_list|(
name|__SC__
argument_list|)
operator|||
name|defined
argument_list|(
name|TARGET_OS_MAC
argument_list|)
end_if
begin_comment
comment|/* We need to check that<math.h> hasn't already been included earlier       * as it seems it doesn't agree with<fp.h>, yet we should really use       *<fp.h> if possible.       */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__MATH_H__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MATH_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__cmath__
argument_list|)
end_if
begin_include
include|#
directive|include
file|<fp.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AMIGA
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SASC
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M68881
argument_list|)
end_if
begin_comment
comment|/* Amiga SAS/C: We must include builtin FPU functions when compiling using       * MATH=68881       */
end_comment
begin_include
include|#
directive|include
file|<m68881.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This provides the non-ANSI (far) memory allocation routines. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__TURBOC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
end_if
begin_include
include|#
directive|include
file|<mem.h>
end_include
begin_include
include|#
directive|include
file|<alloc.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_Windows
argument_list|)
operator|||
name|defined
argument_list|(
name|_WINDOWS
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
end_if
begin_include
include|#
directive|include
file|<windows.h>
end_include
begin_comment
comment|/* defines _WINDOWS_ macro */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|WINAPI_FAMILY
argument_list|)
operator|&&
operator|(
name|WINAPI_FAMILY
operator|==
name|WINAPI_FAMILY_APP
operator|||
name|WINAPI_FAMILY
operator|==
name|WINAPI_FAMILY_PHONE_APP
operator|)
end_if
begin_define
DECL|macro|_WINRT_
define|#
directive|define
name|_WINRT_
end_define
begin_comment
DECL|macro|_WINRT_
comment|/* Define a macro for Windows Runtime builds */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_VERSION_INFO_ONLY */
end_comment
begin_comment
comment|/* Moved here around 1.5.0beta36 from pngconf.h */
end_comment
begin_comment
comment|/* Users may want to use these so they are not private.  Any library  * functions that are passed far data must be model-independent.  */
end_comment
begin_comment
comment|/* Memory model/platform independent fns */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_ABORT
end_ifndef
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WINDOWS_
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WINRT_
argument_list|)
end_if
begin_define
DECL|macro|PNG_ABORT
define|#
directive|define
name|PNG_ABORT
parameter_list|()
value|ExitProcess(0)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PNG_ABORT
define|#
directive|define
name|PNG_ABORT
parameter_list|()
value|abort()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* These macros may need to be architecture dependent. */
end_comment
begin_define
DECL|macro|PNG_ALIGN_NONE
define|#
directive|define
name|PNG_ALIGN_NONE
value|0
end_define
begin_comment
DECL|macro|PNG_ALIGN_NONE
comment|/* do not use data alignment */
end_comment
begin_define
DECL|macro|PNG_ALIGN_ALWAYS
define|#
directive|define
name|PNG_ALIGN_ALWAYS
value|1
end_define
begin_comment
DECL|macro|PNG_ALIGN_ALWAYS
comment|/* assume unaligned accesses are OK */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|offsetof
end_ifdef
begin_define
DECL|macro|PNG_ALIGN_OFFSET
define|#
directive|define
name|PNG_ALIGN_OFFSET
value|2
end_define
begin_comment
DECL|macro|PNG_ALIGN_OFFSET
comment|/* use offsetof to determine alignment */
end_comment
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PNG_ALIGN_OFFSET
define|#
directive|define
name|PNG_ALIGN_OFFSET
value|-1
end_define
begin_comment
DECL|macro|PNG_ALIGN_OFFSET
comment|/* prevent the use of this */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|PNG_ALIGN_SIZE
define|#
directive|define
name|PNG_ALIGN_SIZE
value|3
end_define
begin_comment
DECL|macro|PNG_ALIGN_SIZE
comment|/* use sizeof to determine alignment */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_ALIGN_TYPE
end_ifndef
begin_comment
comment|/* Default to using aligned access optimizations and requiring alignment to a     * multiple of the data type size.  Override in a compiler specific fashion     * if necessary by inserting tests here:     */
end_comment
begin_define
DECL|macro|PNG_ALIGN_TYPE
define|#
directive|define
name|PNG_ALIGN_TYPE
value|PNG_ALIGN_SIZE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|PNG_ALIGN_TYPE
operator|==
name|PNG_ALIGN_SIZE
end_if
begin_comment
comment|/* This is used because in some compiler implementations non-aligned     * structure members are supported, so the offsetof approach below fails.     * Set PNG_ALIGN_SIZE=0 for compiler combinations where unaligned access     * is good for performance.  Do not do this unless you have tested the result     * and understand it.     */
end_comment
begin_define
DECL|macro|png_alignof
define|#
directive|define
name|png_alignof
parameter_list|(
name|type
parameter_list|)
value|(sizeof (type))
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|PNG_ALIGN_TYPE
operator|==
name|PNG_ALIGN_OFFSET
end_if
begin_define
DECL|macro|png_alignof
define|#
directive|define
name|png_alignof
parameter_list|(
name|type
parameter_list|)
value|offsetof(struct{char c; type t;}, t)
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|PNG_ALIGN_TYPE
operator|==
name|PNG_ALIGN_ALWAYS
end_if
begin_define
DECL|macro|png_alignof
define|#
directive|define
name|png_alignof
parameter_list|(
name|type
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Else leave png_alignof undefined to prevent use thereof */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This implicitly assumes alignment is always to a power of 2. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|png_alignof
end_ifdef
begin_define
DECL|macro|png_isaligned
define|#
directive|define
name|png_isaligned
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|)
define|\
value|((((const char*)ptr-(const char*)0)& (png_alignof(type)-1)) == 0)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|png_isaligned
define|#
directive|define
name|png_isaligned
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|)
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* End of memory model/platform independent support */
end_comment
begin_comment
comment|/* End of 1.5.0beta36 move from pngconf.h */
end_comment
begin_comment
comment|/* CONSTANTS and UTILITY MACROS  * These are used internally by libpng and not exposed in the API  */
end_comment
begin_comment
comment|/* Various modes of operation.  Note that after an init, mode is set to  * zero automatically when the structure is created.  Three of these  * are defined in png.h because they need to be visible to applications  * that call png_set_unknown_chunk().  */
end_comment
begin_comment
comment|/* #define PNG_HAVE_IHDR            0x01 (defined in png.h) */
end_comment
begin_comment
comment|/* #define PNG_HAVE_PLTE            0x02 (defined in png.h) */
end_comment
begin_define
DECL|macro|PNG_HAVE_IDAT
define|#
directive|define
name|PNG_HAVE_IDAT
value|0x04
end_define
begin_comment
comment|/* #define PNG_AFTER_IDAT           0x08 (defined in png.h) */
end_comment
begin_define
DECL|macro|PNG_HAVE_IEND
define|#
directive|define
name|PNG_HAVE_IEND
value|0x10
end_define
begin_comment
comment|/*               0x20 (unused) */
end_comment
begin_comment
comment|/*               0x40 (unused) */
end_comment
begin_comment
comment|/*               0x80 (unused) */
end_comment
begin_define
DECL|macro|PNG_HAVE_CHUNK_HEADER
define|#
directive|define
name|PNG_HAVE_CHUNK_HEADER
value|0x100
end_define
begin_define
DECL|macro|PNG_WROTE_tIME
define|#
directive|define
name|PNG_WROTE_tIME
value|0x200
end_define
begin_define
DECL|macro|PNG_WROTE_INFO_BEFORE_PLTE
define|#
directive|define
name|PNG_WROTE_INFO_BEFORE_PLTE
value|0x400
end_define
begin_define
DECL|macro|PNG_BACKGROUND_IS_GRAY
define|#
directive|define
name|PNG_BACKGROUND_IS_GRAY
value|0x800
end_define
begin_define
DECL|macro|PNG_HAVE_PNG_SIGNATURE
define|#
directive|define
name|PNG_HAVE_PNG_SIGNATURE
value|0x1000
end_define
begin_define
DECL|macro|PNG_HAVE_CHUNK_AFTER_IDAT
define|#
directive|define
name|PNG_HAVE_CHUNK_AFTER_IDAT
value|0x2000
end_define
begin_comment
DECL|macro|PNG_HAVE_CHUNK_AFTER_IDAT
comment|/* Have another chunk after IDAT */
end_comment
begin_comment
comment|/*             0x4000 (unused) */
end_comment
begin_define
DECL|macro|PNG_IS_READ_STRUCT
define|#
directive|define
name|PNG_IS_READ_STRUCT
value|0x8000
end_define
begin_comment
DECL|macro|PNG_IS_READ_STRUCT
comment|/* Else is a write struct */
end_comment
begin_comment
comment|/* Flags for the transformations the PNG library does on the image data */
end_comment
begin_define
DECL|macro|PNG_BGR
define|#
directive|define
name|PNG_BGR
value|0x0001
end_define
begin_define
DECL|macro|PNG_INTERLACE
define|#
directive|define
name|PNG_INTERLACE
value|0x0002
end_define
begin_define
DECL|macro|PNG_PACK
define|#
directive|define
name|PNG_PACK
value|0x0004
end_define
begin_define
DECL|macro|PNG_SHIFT
define|#
directive|define
name|PNG_SHIFT
value|0x0008
end_define
begin_define
DECL|macro|PNG_SWAP_BYTES
define|#
directive|define
name|PNG_SWAP_BYTES
value|0x0010
end_define
begin_define
DECL|macro|PNG_INVERT_MONO
define|#
directive|define
name|PNG_INVERT_MONO
value|0x0020
end_define
begin_define
DECL|macro|PNG_QUANTIZE
define|#
directive|define
name|PNG_QUANTIZE
value|0x0040
end_define
begin_define
DECL|macro|PNG_COMPOSE
define|#
directive|define
name|PNG_COMPOSE
value|0x0080
end_define
begin_comment
DECL|macro|PNG_COMPOSE
comment|/* Was PNG_BACKGROUND */
end_comment
begin_define
DECL|macro|PNG_BACKGROUND_EXPAND
define|#
directive|define
name|PNG_BACKGROUND_EXPAND
value|0x0100
end_define
begin_define
DECL|macro|PNG_EXPAND_16
define|#
directive|define
name|PNG_EXPAND_16
value|0x0200
end_define
begin_comment
DECL|macro|PNG_EXPAND_16
comment|/* Added to libpng 1.5.2 */
end_comment
begin_define
DECL|macro|PNG_16_TO_8
define|#
directive|define
name|PNG_16_TO_8
value|0x0400
end_define
begin_comment
DECL|macro|PNG_16_TO_8
comment|/* Becomes 'chop' in 1.5.4 */
end_comment
begin_define
DECL|macro|PNG_RGBA
define|#
directive|define
name|PNG_RGBA
value|0x0800
end_define
begin_define
DECL|macro|PNG_EXPAND
define|#
directive|define
name|PNG_EXPAND
value|0x1000
end_define
begin_define
DECL|macro|PNG_GAMMA
define|#
directive|define
name|PNG_GAMMA
value|0x2000
end_define
begin_define
DECL|macro|PNG_GRAY_TO_RGB
define|#
directive|define
name|PNG_GRAY_TO_RGB
value|0x4000
end_define
begin_define
DECL|macro|PNG_FILLER
define|#
directive|define
name|PNG_FILLER
value|0x8000
end_define
begin_define
DECL|macro|PNG_PACKSWAP
define|#
directive|define
name|PNG_PACKSWAP
value|0x10000
end_define
begin_define
DECL|macro|PNG_SWAP_ALPHA
define|#
directive|define
name|PNG_SWAP_ALPHA
value|0x20000
end_define
begin_define
DECL|macro|PNG_STRIP_ALPHA
define|#
directive|define
name|PNG_STRIP_ALPHA
value|0x40000
end_define
begin_define
DECL|macro|PNG_INVERT_ALPHA
define|#
directive|define
name|PNG_INVERT_ALPHA
value|0x80000
end_define
begin_define
DECL|macro|PNG_USER_TRANSFORM
define|#
directive|define
name|PNG_USER_TRANSFORM
value|0x100000
end_define
begin_define
DECL|macro|PNG_RGB_TO_GRAY_ERR
define|#
directive|define
name|PNG_RGB_TO_GRAY_ERR
value|0x200000
end_define
begin_define
DECL|macro|PNG_RGB_TO_GRAY_WARN
define|#
directive|define
name|PNG_RGB_TO_GRAY_WARN
value|0x400000
end_define
begin_define
DECL|macro|PNG_RGB_TO_GRAY
define|#
directive|define
name|PNG_RGB_TO_GRAY
value|0x600000
end_define
begin_comment
DECL|macro|PNG_RGB_TO_GRAY
comment|/* two bits, RGB_TO_GRAY_ERR|WARN */
end_comment
begin_define
DECL|macro|PNG_ENCODE_ALPHA
define|#
directive|define
name|PNG_ENCODE_ALPHA
value|0x800000
end_define
begin_comment
DECL|macro|PNG_ENCODE_ALPHA
comment|/* Added to libpng-1.5.4 */
end_comment
begin_define
DECL|macro|PNG_ADD_ALPHA
define|#
directive|define
name|PNG_ADD_ALPHA
value|0x1000000
end_define
begin_comment
DECL|macro|PNG_ADD_ALPHA
comment|/* Added to libpng-1.2.7 */
end_comment
begin_define
DECL|macro|PNG_EXPAND_tRNS
define|#
directive|define
name|PNG_EXPAND_tRNS
value|0x2000000
end_define
begin_comment
DECL|macro|PNG_EXPAND_tRNS
comment|/* Added to libpng-1.2.9 */
end_comment
begin_define
DECL|macro|PNG_SCALE_16_TO_8
define|#
directive|define
name|PNG_SCALE_16_TO_8
value|0x4000000
end_define
begin_comment
DECL|macro|PNG_SCALE_16_TO_8
comment|/* Added to libpng-1.5.4 */
end_comment
begin_comment
comment|/*    0x8000000 unused */
end_comment
begin_comment
comment|/*   0x10000000 unused */
end_comment
begin_comment
comment|/*   0x20000000 unused */
end_comment
begin_comment
comment|/*   0x40000000 unused */
end_comment
begin_comment
comment|/* Flags for png_create_struct */
end_comment
begin_define
DECL|macro|PNG_STRUCT_PNG
define|#
directive|define
name|PNG_STRUCT_PNG
value|0x0001
end_define
begin_define
DECL|macro|PNG_STRUCT_INFO
define|#
directive|define
name|PNG_STRUCT_INFO
value|0x0002
end_define
begin_comment
comment|/* Scaling factor for filter heuristic weighting calculations */
end_comment
begin_define
DECL|macro|PNG_WEIGHT_FACTOR
define|#
directive|define
name|PNG_WEIGHT_FACTOR
value|(1<<(PNG_WEIGHT_SHIFT))
end_define
begin_define
DECL|macro|PNG_COST_FACTOR
define|#
directive|define
name|PNG_COST_FACTOR
value|(1<<(PNG_COST_SHIFT))
end_define
begin_comment
comment|/* Flags for the png_ptr->flags rather than declaring a byte for each one */
end_comment
begin_define
DECL|macro|PNG_FLAG_ZLIB_CUSTOM_STRATEGY
define|#
directive|define
name|PNG_FLAG_ZLIB_CUSTOM_STRATEGY
value|0x0001
end_define
begin_define
DECL|macro|PNG_FLAG_ZSTREAM_INITIALIZED
define|#
directive|define
name|PNG_FLAG_ZSTREAM_INITIALIZED
value|0x0002
end_define
begin_comment
DECL|macro|PNG_FLAG_ZSTREAM_INITIALIZED
comment|/* Added to libpng-1.6.0 */
end_comment
begin_comment
comment|/*      0x0004    unused */
end_comment
begin_define
DECL|macro|PNG_FLAG_ZSTREAM_ENDED
define|#
directive|define
name|PNG_FLAG_ZSTREAM_ENDED
value|0x0008
end_define
begin_comment
DECL|macro|PNG_FLAG_ZSTREAM_ENDED
comment|/* Added to libpng-1.6.0 */
end_comment
begin_comment
comment|/*      0x0010    unused */
end_comment
begin_comment
comment|/*      0x0020    unused */
end_comment
begin_define
DECL|macro|PNG_FLAG_ROW_INIT
define|#
directive|define
name|PNG_FLAG_ROW_INIT
value|0x0040
end_define
begin_define
DECL|macro|PNG_FLAG_FILLER_AFTER
define|#
directive|define
name|PNG_FLAG_FILLER_AFTER
value|0x0080
end_define
begin_define
DECL|macro|PNG_FLAG_CRC_ANCILLARY_USE
define|#
directive|define
name|PNG_FLAG_CRC_ANCILLARY_USE
value|0x0100
end_define
begin_define
DECL|macro|PNG_FLAG_CRC_ANCILLARY_NOWARN
define|#
directive|define
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
value|0x0200
end_define
begin_define
DECL|macro|PNG_FLAG_CRC_CRITICAL_USE
define|#
directive|define
name|PNG_FLAG_CRC_CRITICAL_USE
value|0x0400
end_define
begin_define
DECL|macro|PNG_FLAG_CRC_CRITICAL_IGNORE
define|#
directive|define
name|PNG_FLAG_CRC_CRITICAL_IGNORE
value|0x0800
end_define
begin_define
DECL|macro|PNG_FLAG_ASSUME_sRGB
define|#
directive|define
name|PNG_FLAG_ASSUME_sRGB
value|0x1000
end_define
begin_comment
DECL|macro|PNG_FLAG_ASSUME_sRGB
comment|/* Added to libpng-1.5.4 */
end_comment
begin_define
DECL|macro|PNG_FLAG_OPTIMIZE_ALPHA
define|#
directive|define
name|PNG_FLAG_OPTIMIZE_ALPHA
value|0x2000
end_define
begin_comment
DECL|macro|PNG_FLAG_OPTIMIZE_ALPHA
comment|/* Added to libpng-1.5.4 */
end_comment
begin_define
DECL|macro|PNG_FLAG_DETECT_UNINITIALIZED
define|#
directive|define
name|PNG_FLAG_DETECT_UNINITIALIZED
value|0x4000
end_define
begin_comment
DECL|macro|PNG_FLAG_DETECT_UNINITIALIZED
comment|/* Added to libpng-1.5.4 */
end_comment
begin_comment
comment|/* #define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000 */
end_comment
begin_comment
comment|/* #define PNG_FLAG_KEEP_UNSAFE_CHUNKS      0x10000 */
end_comment
begin_define
DECL|macro|PNG_FLAG_LIBRARY_MISMATCH
define|#
directive|define
name|PNG_FLAG_LIBRARY_MISMATCH
value|0x20000
end_define
begin_define
DECL|macro|PNG_FLAG_STRIP_ERROR_NUMBERS
define|#
directive|define
name|PNG_FLAG_STRIP_ERROR_NUMBERS
value|0x40000
end_define
begin_define
DECL|macro|PNG_FLAG_STRIP_ERROR_TEXT
define|#
directive|define
name|PNG_FLAG_STRIP_ERROR_TEXT
value|0x80000
end_define
begin_define
DECL|macro|PNG_FLAG_BENIGN_ERRORS_WARN
define|#
directive|define
name|PNG_FLAG_BENIGN_ERRORS_WARN
value|0x100000
end_define
begin_comment
DECL|macro|PNG_FLAG_BENIGN_ERRORS_WARN
comment|/* Added to libpng-1.4.0 */
end_comment
begin_define
DECL|macro|PNG_FLAG_APP_WARNINGS_WARN
define|#
directive|define
name|PNG_FLAG_APP_WARNINGS_WARN
value|0x200000
end_define
begin_comment
DECL|macro|PNG_FLAG_APP_WARNINGS_WARN
comment|/* Added to libpng-1.6.0 */
end_comment
begin_define
DECL|macro|PNG_FLAG_APP_ERRORS_WARN
define|#
directive|define
name|PNG_FLAG_APP_ERRORS_WARN
value|0x400000
end_define
begin_comment
DECL|macro|PNG_FLAG_APP_ERRORS_WARN
comment|/* Added to libpng-1.6.0 */
end_comment
begin_comment
comment|/*    0x800000    unused */
end_comment
begin_comment
comment|/*   0x1000000    unused */
end_comment
begin_comment
comment|/*   0x2000000    unused */
end_comment
begin_comment
comment|/*   0x4000000    unused */
end_comment
begin_comment
comment|/*   0x8000000    unused */
end_comment
begin_comment
comment|/*  0x10000000    unused */
end_comment
begin_comment
comment|/*  0x20000000    unused */
end_comment
begin_comment
comment|/*  0x40000000    unused */
end_comment
begin_define
DECL|macro|PNG_FLAG_CRC_ANCILLARY_MASK
define|#
directive|define
name|PNG_FLAG_CRC_ANCILLARY_MASK
value|(PNG_FLAG_CRC_ANCILLARY_USE | \                                      PNG_FLAG_CRC_ANCILLARY_NOWARN)
end_define
begin_define
DECL|macro|PNG_FLAG_CRC_CRITICAL_MASK
define|#
directive|define
name|PNG_FLAG_CRC_CRITICAL_MASK
value|(PNG_FLAG_CRC_CRITICAL_USE | \                                      PNG_FLAG_CRC_CRITICAL_IGNORE)
end_define
begin_define
DECL|macro|PNG_FLAG_CRC_MASK
define|#
directive|define
name|PNG_FLAG_CRC_MASK
value|(PNG_FLAG_CRC_ANCILLARY_MASK | \                                      PNG_FLAG_CRC_CRITICAL_MASK)
end_define
begin_comment
comment|/* Save typing and make code easier to understand */
end_comment
begin_define
DECL|macro|PNG_COLOR_DIST
define|#
directive|define
name|PNG_COLOR_DIST
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
value|(abs((int)((c1).red) - (int)((c2).red)) + \    abs((int)((c1).green) - (int)((c2).green)) + \    abs((int)((c1).blue) - (int)((c2).blue)))
end_define
begin_comment
comment|/* Added to libpng-1.6.0: scale a 16-bit value in the range 0..65535 to 0..255  * by dividing by 257 *with rounding*.  This macro is exact for the given range.  * See the discourse in pngrtran.c png_do_scale_16_to_8.  The values in the  * macro were established by experiment (modifying the added value).  The macro  * has a second variant that takes a value already scaled by 255 and divides by  * 65535 - this has a maximum error of .502.  Over the range 0..65535*65535 it  * only gives off-by-one errors and only for 0.5% (1 in 200) of the values.  */
end_comment
begin_define
DECL|macro|PNG_DIV65535
define|#
directive|define
name|PNG_DIV65535
parameter_list|(
name|v24
parameter_list|)
value|(((v24) + 32895)>> 16)
end_define
begin_define
DECL|macro|PNG_DIV257
define|#
directive|define
name|PNG_DIV257
parameter_list|(
name|v16
parameter_list|)
value|PNG_DIV65535((png_uint_32)(v16) * 255)
end_define
begin_comment
comment|/* Added to libpng-1.2.6 JB */
end_comment
begin_define
DECL|macro|PNG_ROWBYTES
define|#
directive|define
name|PNG_ROWBYTES
parameter_list|(
name|pixel_bits
parameter_list|,
name|width
parameter_list|)
define|\
value|((pixel_bits)>= 8 ? \     ((png_size_t)(width) * (((png_size_t)(pixel_bits))>> 3)) : \     (( ((png_size_t)(width) * ((png_size_t)(pixel_bits))) + 7)>> 3) )
end_define
begin_comment
comment|/* PNG_OUT_OF_RANGE returns true if value is outside the range  * ideal-delta..ideal+delta.  Each argument is evaluated twice.  * "ideal" and "delta" should be constants, normally simple  * integers, "value" a variable. Added to libpng-1.2.6 JB  */
end_comment
begin_define
DECL|macro|PNG_OUT_OF_RANGE
define|#
directive|define
name|PNG_OUT_OF_RANGE
parameter_list|(
name|value
parameter_list|,
name|ideal
parameter_list|,
name|delta
parameter_list|)
define|\
value|( (value)< (ideal)-(delta) || (value)> (ideal)+(delta) )
end_define
begin_comment
comment|/* Conversions between fixed and floating point, only defined if  * required (to make sure the code doesn't accidentally use float  * when it is supposedly disabled.)  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* The floating point conversion can't overflow, though it can and  * does lose accuracy relative to the original fixed point value.  * In practice this doesn't matter because png_fixed_point only  * stores numbers with very low precision.  The png_ptr and s  * arguments are unused by default but are there in case error  * checking becomes a requirement.  */
end_comment
begin_define
DECL|macro|png_float
define|#
directive|define
name|png_float
parameter_list|(
name|png_ptr
parameter_list|,
name|fixed
parameter_list|,
name|s
parameter_list|)
value|(.00001 * (fixed))
end_define
begin_comment
comment|/* The fixed point conversion performs range checking and evaluates  * its argument multiple times, so must be used with care.  The  * range checking uses the PNG specification values for a signed  * 32 bit fixed point value except that the values are deliberately  * rounded-to-zero to an integral value - 21474 (21474.83 is roughly  * (2^31-1) * 100000). 's' is a string that describes the value being  * converted.  *  * NOTE: this macro will raise a png_error if the range check fails,  * therefore it is normally only appropriate to use this on values  * that come from API calls or other sources where an out of range  * error indicates a programming error, not a data error!  *  * NOTE: by default this is off - the macro is not used - because the  * function call saves a lot of code.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_MACRO_SUPPORTED
end_ifdef
begin_define
DECL|macro|png_fixed
define|#
directive|define
name|png_fixed
parameter_list|(
name|png_ptr
parameter_list|,
name|fp
parameter_list|,
name|s
parameter_list|)
value|((fp)<= 21474&& (fp)>= -21474 ?\     ((png_fixed_point)(100000 * (fp))) : (png_fixed_error(png_ptr, s),0))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* else the corresponding function is defined below, inside the scope of the  * cplusplus test.  */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Constants for known chunk types.  If you need to add a chunk, define the name  * here.  For historical reasons these constants have the form png_<name>; i.e.  * the prefix is lower case.  Please use decimal values as the parameters to  * match the ISO PNG specification and to avoid relying on the C locale  * interpretation of character values.  *  * Prior to 1.5.6 these constants were strings, as of 1.5.6 png_uint_32 values  * are computed and a new macro (PNG_STRING_FROM_CHUNK) added to allow a string  * to be generated if required.  *  * PNG_32b correctly produces a value shifted by up to 24 bits, even on  * architectures where (int) is only 16 bits.  */
end_comment
begin_define
DECL|macro|PNG_32b
define|#
directive|define
name|PNG_32b
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
value|((png_uint_32)(b)<< (s))
end_define
begin_define
DECL|macro|PNG_U32
define|#
directive|define
name|PNG_U32
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|b3
parameter_list|,
name|b4
parameter_list|)
define|\
value|(PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
end_define
begin_comment
comment|/* Constants for known chunk types.  *  * MAINTAINERS: If you need to add a chunk, define the name here.  * For historical reasons these constants have the form png_<name>; i.e.  * the prefix is lower case.  Please use decimal values as the parameters to  * match the ISO PNG specification and to avoid relying on the C locale  * interpretation of character values.  Please keep the list sorted.  *  * Notice that PNG_U32 is used to define a 32-bit value for the 4 byte chunk  * type.  In fact the specification does not express chunk types this way,  * however using a 32-bit value means that the chunk type can be read from the  * stream using exactly the same code as used for a 32-bit unsigned value and  * can be examined far more efficiently (using one arithmetic compare).  *  * Prior to 1.5.6 the chunk type constants were expressed as C strings.  The  * libpng API still uses strings for 'unknown' chunks and a macro,  * PNG_STRING_FROM_CHUNK, allows a string to be generated if required.  Notice  * that for portable code numeric values must still be used; the string "IHDR"  * is not portable and neither is PNG_U32('I', 'H', 'D', 'R').  *  * In 1.7.0 the definitions will be made public in png.h to avoid having to  * duplicate the same definitions in application code.  */
end_comment
begin_define
DECL|macro|png_IDAT
define|#
directive|define
name|png_IDAT
value|PNG_U32( 73,  68,  65,  84)
end_define
begin_define
DECL|macro|png_IEND
define|#
directive|define
name|png_IEND
value|PNG_U32( 73,  69,  78,  68)
end_define
begin_define
DECL|macro|png_IHDR
define|#
directive|define
name|png_IHDR
value|PNG_U32( 73,  72,  68,  82)
end_define
begin_define
DECL|macro|png_PLTE
define|#
directive|define
name|png_PLTE
value|PNG_U32( 80,  76,  84,  69)
end_define
begin_define
DECL|macro|png_bKGD
define|#
directive|define
name|png_bKGD
value|PNG_U32( 98,  75,  71,  68)
end_define
begin_define
DECL|macro|png_cHRM
define|#
directive|define
name|png_cHRM
value|PNG_U32( 99,  72,  82,  77)
end_define
begin_define
DECL|macro|png_fRAc
define|#
directive|define
name|png_fRAc
value|PNG_U32(102,  82,  65,  99)
end_define
begin_comment
DECL|macro|png_fRAc
comment|/* registered, not defined */
end_comment
begin_define
DECL|macro|png_gAMA
define|#
directive|define
name|png_gAMA
value|PNG_U32(103,  65,  77,  65)
end_define
begin_define
DECL|macro|png_gIFg
define|#
directive|define
name|png_gIFg
value|PNG_U32(103,  73,  70, 103)
end_define
begin_define
DECL|macro|png_gIFt
define|#
directive|define
name|png_gIFt
value|PNG_U32(103,  73,  70, 116)
end_define
begin_comment
DECL|macro|png_gIFt
comment|/* deprecated */
end_comment
begin_define
DECL|macro|png_gIFx
define|#
directive|define
name|png_gIFx
value|PNG_U32(103,  73,  70, 120)
end_define
begin_define
DECL|macro|png_hIST
define|#
directive|define
name|png_hIST
value|PNG_U32(104,  73,  83,  84)
end_define
begin_define
DECL|macro|png_iCCP
define|#
directive|define
name|png_iCCP
value|PNG_U32(105,  67,  67,  80)
end_define
begin_define
DECL|macro|png_iTXt
define|#
directive|define
name|png_iTXt
value|PNG_U32(105,  84,  88, 116)
end_define
begin_define
DECL|macro|png_oFFs
define|#
directive|define
name|png_oFFs
value|PNG_U32(111,  70,  70, 115)
end_define
begin_define
DECL|macro|png_pCAL
define|#
directive|define
name|png_pCAL
value|PNG_U32(112,  67,  65,  76)
end_define
begin_define
DECL|macro|png_pHYs
define|#
directive|define
name|png_pHYs
value|PNG_U32(112,  72,  89, 115)
end_define
begin_define
DECL|macro|png_sBIT
define|#
directive|define
name|png_sBIT
value|PNG_U32(115,  66,  73,  84)
end_define
begin_define
DECL|macro|png_sCAL
define|#
directive|define
name|png_sCAL
value|PNG_U32(115,  67,  65,  76)
end_define
begin_define
DECL|macro|png_sPLT
define|#
directive|define
name|png_sPLT
value|PNG_U32(115,  80,  76,  84)
end_define
begin_define
DECL|macro|png_sRGB
define|#
directive|define
name|png_sRGB
value|PNG_U32(115,  82,  71,  66)
end_define
begin_define
DECL|macro|png_sTER
define|#
directive|define
name|png_sTER
value|PNG_U32(115,  84,  69,  82)
end_define
begin_define
DECL|macro|png_tEXt
define|#
directive|define
name|png_tEXt
value|PNG_U32(116,  69,  88, 116)
end_define
begin_define
DECL|macro|png_tIME
define|#
directive|define
name|png_tIME
value|PNG_U32(116,  73,  77,  69)
end_define
begin_define
DECL|macro|png_tRNS
define|#
directive|define
name|png_tRNS
value|PNG_U32(116,  82,  78,  83)
end_define
begin_define
DECL|macro|png_zTXt
define|#
directive|define
name|png_zTXt
value|PNG_U32(122,  84,  88, 116)
end_define
begin_comment
comment|/* The following will work on (signed char*) strings, whereas the get_uint_32  * macro will fail on top-bit-set values because of the sign extension.  */
end_comment
begin_define
DECL|macro|PNG_CHUNK_FROM_STRING
define|#
directive|define
name|PNG_CHUNK_FROM_STRING
parameter_list|(
name|s
parameter_list|)
define|\
value|PNG_U32(0xff& (s)[0], 0xff& (s)[1], 0xff& (s)[2], 0xff& (s)[3])
end_define
begin_comment
comment|/* This uses (char), not (png_byte) to avoid warnings on systems where (char) is  * signed and the argument is a (char[])  This macro will fail miserably on  * systems where (char) is more than 8 bits.  */
end_comment
begin_define
DECL|macro|PNG_STRING_FROM_CHUNK
define|#
directive|define
name|PNG_STRING_FROM_CHUNK
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
define|\
value|(void)(((char*)(s))[0]=(char)(((c)>>24)& 0xff), \    ((char*)(s))[1]=(char)(((c)>>16)& 0xff),\    ((char*)(s))[2]=(char)(((c)>>8)& 0xff), \    ((char*)(s))[3]=(char)((c& 0xff)))
end_define
begin_comment
comment|/* Do the same but terminate with a null character. */
end_comment
begin_define
DECL|macro|PNG_CSTRING_FROM_CHUNK
define|#
directive|define
name|PNG_CSTRING_FROM_CHUNK
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
define|\
value|(void)(PNG_STRING_FROM_CHUNK(s,c), ((char*)(s))[4] = 0)
end_define
begin_comment
comment|/* Test on flag values as defined in the spec (section 5.4): */
end_comment
begin_define
DECL|macro|PNG_CHUNK_ANCILLARY
define|#
directive|define
name|PNG_CHUNK_ANCILLARY
parameter_list|(
name|c
parameter_list|)
value|(1& ((c)>> 29))
end_define
begin_define
DECL|macro|PNG_CHUNK_CRITICAL
define|#
directive|define
name|PNG_CHUNK_CRITICAL
parameter_list|(
name|c
parameter_list|)
value|(!PNG_CHUNK_ANCILLARY(c))
end_define
begin_define
DECL|macro|PNG_CHUNK_PRIVATE
define|#
directive|define
name|PNG_CHUNK_PRIVATE
parameter_list|(
name|c
parameter_list|)
value|(1& ((c)>> 21))
end_define
begin_define
DECL|macro|PNG_CHUNK_RESERVED
define|#
directive|define
name|PNG_CHUNK_RESERVED
parameter_list|(
name|c
parameter_list|)
value|(1& ((c)>> 13))
end_define
begin_define
DECL|macro|PNG_CHUNK_SAFE_TO_COPY
define|#
directive|define
name|PNG_CHUNK_SAFE_TO_COPY
parameter_list|(
name|c
parameter_list|)
value|(1& ((c)>>  5))
end_define
begin_comment
comment|/* Gamma values (new at libpng-1.5.4): */
end_comment
begin_define
DECL|macro|PNG_GAMMA_MAC_OLD
define|#
directive|define
name|PNG_GAMMA_MAC_OLD
value|151724
end_define
begin_comment
DECL|macro|PNG_GAMMA_MAC_OLD
comment|/* Assume '1.8' is really 2.2/1.45! */
end_comment
begin_define
DECL|macro|PNG_GAMMA_MAC_INVERSE
define|#
directive|define
name|PNG_GAMMA_MAC_INVERSE
value|65909
end_define
begin_define
DECL|macro|PNG_GAMMA_sRGB_INVERSE
define|#
directive|define
name|PNG_GAMMA_sRGB_INVERSE
value|45455
end_define
begin_comment
comment|/* Almost everything below is C specific; the #defines above can be used in  * non-C code (so long as it is C-preprocessed) the rest of this stuff cannot.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_VERSION_INFO_ONLY
end_ifndef
begin_include
include|#
directive|include
file|"pngstruct.h"
end_include
begin_include
include|#
directive|include
file|"pnginfo.h"
end_include
begin_comment
comment|/* Validate the include paths - the include path used to generate pnglibconf.h  * must match that used in the build, or we must be using pnglibconf.h.prebuilt:  */
end_comment
begin_if
if|#
directive|if
name|PNG_ZLIB_VERNUM
operator|!=
literal|0
operator|&&
name|PNG_ZLIB_VERNUM
operator|!=
name|ZLIB_VERNUM
end_if
begin_error
error|#
directive|error
error|ZLIB_VERNUM != PNG_ZLIB_VERNUM \       "-I (include path) error: see the notes in pngpriv.h"
end_error
begin_comment
comment|/* This means that when pnglibconf.h was built the copy of zlib.h that it     * used is not the same as the one being used here.  Because the build of     * libpng makes decisions to use inflateInit2 and inflateReset2 based on the     * zlib version number and because this affects handling of certain broken     * PNG files the -I directives must match.     *     * The most likely explanation is that you passed a -I in CFLAGS. This will     * not work; all the preprocessor directories and in particular all the -I     * directives must be in CPPFLAGS.     */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This is used for 16 bit gamma tables -- only the top level pointers are  * const; this could be changed:  */
end_comment
begin_typedef
DECL|typedef|png_const_uint_16pp
typedef|typedef
specifier|const
name|png_uint_16p
modifier|*
name|png_const_uint_16pp
typedef|;
end_typedef
begin_comment
comment|/* Added to libpng-1.5.7: sRGB conversion tables */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_READ_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_READ_SUPPORTED
end_ifdef
begin_expr_stmt
name|PNG_INTERNAL_DATA
argument_list|(
specifier|const
name|png_uint_16
argument_list|,
name|png_sRGB_table
argument_list|,
index|[
literal|256
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* Convert from an sRGB encoded value 0..255 to a 16-bit linear value,     * 0..65535.  This table gives the closest 16-bit answers (no errors).     */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|PNG_INTERNAL_DATA
argument_list|(
specifier|const
name|png_uint_16
argument_list|,
name|png_sRGB_base
argument_list|,
index|[
literal|512
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|PNG_INTERNAL_DATA
argument_list|(
specifier|const
name|png_byte
argument_list|,
name|png_sRGB_delta
argument_list|,
index|[
literal|512
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|PNG_sRGB_FROM_LINEAR
define|#
directive|define
name|PNG_sRGB_FROM_LINEAR
parameter_list|(
name|linear
parameter_list|)
define|\
value|((png_byte)(0xff& ((png_sRGB_base[(linear)>>15] \    + ((((linear)& 0x7fff)*png_sRGB_delta[(linear)>>15])>>12))>> 8)))
end_define
begin_comment
comment|/* Given a value 'linear' in the range 0..255*65535 calculate the 8-bit sRGB     * encoded value with maximum error 0.646365.  Note that the input is not a     * 16-bit value; it has been multiplied by 255! */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SIMPLIFIED_READ/WRITE */
end_comment
begin_comment
comment|/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* Internal functions; these are not exported from a DLL however because they  * are used within several of the C source files they have to be C extern.  *  * All of these functions must be declared with PNG_INTERNAL_FUNCTION.  */
comment|/* Zlib support */
DECL|macro|PNG_UNEXPECTED_ZLIB_RETURN
define|#
directive|define
name|PNG_UNEXPECTED_ZLIB_RETURN
value|(-7)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_zstream_error
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|ret
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Used by the zlib handling functions to ensure that z_stream::msg is always     * set before they return.     */
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_free_buffer_list
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_compression_bufferp
operator|*
name|list
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Free the buffer list used by the compressed write code. */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|PNG_FIXED_POINT_MACRO_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|PNG_gAMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_cHRM_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
argument_list|)
operator|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_fixed_point
argument_list|,
name|png_fixed
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|double
name|fp
operator|,
name|png_const_charp
name|text
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check the user version string for compatibility, returns false if the version  * numbers aren't compatible.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_user_version_check
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_charp
name|user_png_ver
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Internal base allocator - no messages, NULL on failure to allocate.  This  * does, however, call the application provided allocator and that could call  * png_error (although that would be a bug in the application implementation.)  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_voidp
argument_list|,
name|png_malloc_base
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_TEXT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_sPLT_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
comment|/* Internal array allocator, outputs no error or warning messages on failure,  * just returns NULL.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_voidp
argument_list|,
name|png_malloc_array
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|int
name|nelements
operator|,
name|size_t
name|element_size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* The same but an existing array is extended by add_elements.  This function  * also memsets the new elements to 0 and copies the old elements.  The old  * array is not freed or altered.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_voidp
argument_list|,
name|png_realloc_array
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_voidp
name|array
operator|,
name|int
name|old_elements
operator|,
name|int
name|add_elements
operator|,
name|size_t
name|element_size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* text, sPLT or unknown chunks */
comment|/* Magic to create a struct when there is no struct to call the user supplied  * memory allocators.  Because error handling has not been set up the memory  * handlers can't safely call png_error, but this is an obscure and undocumented  * restriction so libpng has to assume that the 'free' handler, at least, might  * call png_error.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_structp
argument_list|,
name|png_create_png_struct
argument_list|,
operator|(
name|png_const_charp
name|user_png_ver
operator|,
name|png_voidp
name|error_ptr
operator|,
name|png_error_ptr
name|error_fn
operator|,
name|png_error_ptr
name|warn_fn
operator|,
name|png_voidp
name|mem_ptr
operator|,
name|png_malloc_ptr
name|malloc_fn
operator|,
name|png_free_ptr
name|free_fn
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Free memory from internal libpng struct */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_destroy_png_struct
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Free an allocated jmp_buf (always succeeds) */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_free_jmpbuf
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Function to allocate memory for zlib.  PNGAPI is disallowed. */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|voidpf
argument_list|,
name|png_zalloc
argument_list|,
operator|(
name|voidpf
name|png_ptr
operator|,
name|uInt
name|items
operator|,
name|uInt
name|size
operator|)
argument_list|,
name|PNG_ALLOCATED
argument_list|)
expr_stmt|;
comment|/* Function to free memory for zlib.  PNGAPI is disallowed. */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_zfree
argument_list|,
operator|(
name|voidpf
name|png_ptr
operator|,
name|voidpf
name|ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Next four functions are used internally as callbacks.  PNGCBAPI is required  * but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3, changed to  * PNGCBAPI at 1.5.0  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
argument|void PNGCBAPI
argument_list|,
argument|png_default_read_data
argument_list|,
argument|(png_structp png_ptr,     png_bytep data, png_size_t length)
argument_list|,
argument|PNG_EMPTY
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
argument|void PNGCBAPI
argument_list|,
argument|png_push_fill_buffer
argument_list|,
argument|(png_structp png_ptr,     png_bytep buffer, png_size_t length)
argument_list|,
argument|PNG_EMPTY
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|PNG_INTERNAL_FUNCTION
argument_list|(
argument|void PNGCBAPI
argument_list|,
argument|png_default_write_data
argument_list|,
argument|(png_structp png_ptr,     png_bytep data, png_size_t length)
argument_list|,
argument|PNG_EMPTY
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
argument|void PNGCBAPI
argument_list|,
argument|png_default_flush
argument_list|,
argument|(png_structp png_ptr)
argument_list|,
argument|PNG_EMPTY
argument_list|)
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Reset the CRC variable */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_reset_crc
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Write the "data" buffer to whatever output you are using */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_data
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|data
operator|,
name|png_size_t
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Read and check the PNG file signature */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_sig
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Read the chunk header (length + type name) */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_uint_32
argument_list|,
name|png_read_chunk_header
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Read data from whatever input you are using into the "data" buffer */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_data
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytep
name|data
operator|,
name|png_size_t
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Read bytes into buf, and update png_ptr->crc */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_crc_read
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytep
name|buf
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Read "skip" bytes, read the file crc, and (optionally) verify png_ptr->crc */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_crc_finish
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|skip
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Read the CRC from the file and compare it to the libpng calculated CRC */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_crc_error
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Calculate the CRC over a section of data.  Note that we are only  * passing a maximum of 64K on systems that have this as a memory limit,  * since this is the maximum buffer size we can specify.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_calculate_crc
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|ptr
operator|,
name|png_size_t
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_flush
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write various chunks */
comment|/* Write the IHDR chunk, and update the png_struct with the necessary  * information.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_IHDR
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|width
operator|,
name|png_uint_32
name|height
operator|,
name|int
name|bit_depth
operator|,
name|int
name|color_type
operator|,
name|int
name|compression_method
operator|,
name|int
name|filter_method
operator|,
name|int
name|interlace_method
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_PLTE
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_colorp
name|palette
operator|,
name|png_uint_32
name|num_pal
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_compress_IDAT
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|row_data
operator|,
name|png_alloc_size_t
name|row_data_length
operator|,
name|int
name|flush
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_IEND
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_gAMA_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_gAMA_fixed
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_fixed_point
name|file_gamma
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sBIT_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_sBIT
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_color_8p
name|sbit
operator|,
name|int
name|color_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_cHRM_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_cHRM_fixed
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
specifier|const
name|png_xy
operator|*
name|xy
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* The xy value must have been previously validated */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sRGB_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_sRGB
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|intent
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_iCCP_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_iCCP
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_charp
name|name
operator|,
name|png_const_bytep
name|profile
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* The profile must have been previously validated for correctness, the     * length comes from the first four bytes.  Only the base, deflate,     * compression is supported.     */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sPLT_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_sPLT
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_sPLT_tp
name|palette
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_tRNS_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_tRNS
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_bytep
name|trans
operator|,
name|png_const_color_16p
name|values
operator|,
name|int
name|number
operator|,
name|int
name|color_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_bKGD_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_bKGD
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_color_16p
name|values
operator|,
name|int
name|color_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_hIST_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_hIST
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_uint_16p
name|hist
operator|,
name|int
name|num_hist
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Chunks that have keywords */
ifdef|#
directive|ifdef
name|PNG_WRITE_tEXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_tEXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_charp
name|key
operator|,
name|png_const_charp
name|text
operator|,
name|png_size_t
name|text_len
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_zTXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_zTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_charp
name|key
operator|,
name|png_const_charp
name|text
operator|,
name|int
name|compression
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_iTXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_iTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|compression
operator|,
name|png_const_charp
name|key
operator|,
name|png_const_charp
name|lang
operator|,
name|png_const_charp
name|lang_key
operator|,
name|png_const_charp
name|text
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* Added at version 1.0.14 and 1.2.4 */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_set_text_2
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_const_textp
name|text_ptr
operator|,
name|int
name|num_text
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_oFFs_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_oFFs
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_int_32
name|x_offset
operator|,
name|png_int_32
name|y_offset
operator|,
name|int
name|unit_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_pCAL_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_pCAL
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_charp
name|purpose
operator|,
name|png_int_32
name|X0
operator|,
name|png_int_32
name|X1
operator|,
name|int
name|type
operator|,
name|int
name|nparams
operator|,
name|png_const_charp
name|units
operator|,
name|png_charpp
name|params
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_pHYs_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_pHYs
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|x_pixels_per_unit
operator|,
name|png_uint_32
name|y_pixels_per_unit
operator|,
name|int
name|unit_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_tIME_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_tIME
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_const_timep
name|mod_time
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sCAL_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_sCAL_s
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|unit
operator|,
name|png_const_charp
name|width
operator|,
name|png_const_charp
name|height
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Called when finished processing a row of data */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_finish_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Internal use only.   Called before first row of data */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_start_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Combine a row of data, dealing with alpha, etc. if requested.  'row' is an  * array of png_ptr->width pixels.  If the image is not interlaced or this  * is the final pass this just does a memcpy, otherwise the "display" flag  * is used to determine whether to copy pixels that are not in the current pass.  *  * Because 'png_do_read_interlace' (below) replicates pixels this allows this  * function to achieve the documented 'blocky' appearance during interlaced read  * if display is 1 and the 'sparkle' appearance, where existing pixels in 'row'  * are not changed if they are not in the current pass, when display is 0.  *  * 'display' must be 0 or 1, otherwise the memcpy will be done regardless.  *  * The API always reads from the png_struct row buffer and always assumes that  * it is full width (png_do_read_interlace has already been called.)  *  * This function is only ever used to write to row buffers provided by the  * caller of the relevant libpng API and the row must have already been  * transformed by the read transformations.  *  * The PNG_USE_COMPILE_TIME_MASKS option causes generation of pre-computed  * bitmasks for use within the code, otherwise runtime generated masks are used.  * The default is compile time masks.  */
ifndef|#
directive|ifndef
name|PNG_USE_COMPILE_TIME_MASKS
DECL|macro|PNG_USE_COMPILE_TIME_MASKS
define|#
directive|define
name|PNG_USE_COMPILE_TIME_MASKS
value|1
endif|#
directive|endif
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_combine_row
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_bytep
name|row
operator|,
name|int
name|display
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Expand an interlaced row: the 'row_info' describes the pass data that has  * been read in and must correspond to the pixels in 'row', the pixels are  * expanded (moved apart) in 'row' to match the final layout, when doing this  * the pixels are *replicated* to the intervening space.  This is essential for  * the correct operation of png_combine_row, above.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_read_interlace
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|int
name|pass
operator|,
name|png_uint_32
name|transformations
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GRR TO DO (2.0 or whenever):  simplify other internal calling interfaces */
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Grab pixels out of a row for an interlaced pass */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_write_interlace
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|int
name|pass
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Unfilter a row: check the filter value before calling this, there is no point  * calling it for PNG_FILTER_VALUE_NONE.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row
argument_list|,
operator|(
name|png_structrp
name|pp
operator|,
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|,
name|int
name|filter
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row_up_neon
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row_sub3_neon
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row_sub4_neon
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row_avg3_neon
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row_avg4_neon
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row_paeth3_neon
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_filter_row_paeth4_neon
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|png_const_bytep
name|prev_row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Choose the best filter to use and filter the row data */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_write_find_filter
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_row_infop
name|row_info
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_IDAT_data
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytep
name|output
operator|,
name|png_alloc_size_t
name|avail_out
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Read 'avail_out' bytes of data from the IDAT stream.  If the output buffer     * is NULL the function checks, instead, for the end of the stream.  In this     * case a benign error will be issued if the stream end is not found or if     * extra data has to be consumed.     */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_finish_IDAT
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* This cleans up when the IDAT LZ stream does not end when the last image     * byte is read; there is still some pending input.     */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_finish_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Finish a row while reading, dealing with interlacing passes, etc. */
endif|#
directive|endif
comment|/* SEQUENTIAL_READ */
comment|/* Initialize the row buffers, etc. */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_start_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
comment|/* Optional call to update the users info structure */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_transform_info
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Shared transform functions, defined in pngtran.c */
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_FILLER_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_STRIP_ALPHA_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_strip_channel
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|,
name|int
name|at_start
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SWAP_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SWAP_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_swap
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_PACKSWAP_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_PACKSWAP_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_packswap
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INVERT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_INVERT_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_invert
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BGR_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_BGR_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_bgr
argument_list|,
operator|(
name|png_row_infop
name|row_info
operator|,
name|png_bytep
name|row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The following decodes the appropriate chunks, and does error correction,  * then calls the appropriate callback for the chunk if it is valid.  */
comment|/* Decode the IHDR chunk */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_IHDR
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_PLTE
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_IEND
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_bKGD
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_cHRM
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_gAMA
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_hIST
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_iCCP
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* READ_iCCP */
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_iTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_oFFs
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_pCAL
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_pHYs
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_sBIT
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_sCAL
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_sPLT
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* READ_sPLT */
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_sRGB
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_tEXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_tIME
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_tRNS
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_zTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_check_chunk_name
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|chunk_name
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_handle_unknown
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|,
name|int
name|keep
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* This is the function that gets called for unknown chunks.  The 'keep'     * argument is either non-zero for a known chunk that has been set to be     * handled as unknown or zero for an unknown chunk.  By default the function     * just skips the chunk or errors out if it is critical.     */
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_chunk_unknown_handling
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_uint_32
name|chunk_name
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Exactly as the API png_handle_as_unknown() except that the argument is a     * 32-bit chunk name, not a string.     */
endif|#
directive|endif
comment|/* READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN */
comment|/* Handle the transformations for reading and writing */
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_read_transformations
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_row_infop
name|row_info
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_TRANSFORMS_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_write_transformations
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_row_infop
name|row_info
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_init_read_transformations
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_read_chunk
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_read_sig
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_check_crc
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_crc_skip
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_crc_finish
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_save_buffer
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_restore_buffer
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytep
name|buffer
operator|,
name|png_size_t
name|buffer_length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_read_IDAT
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_process_IDAT_data
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytep
name|buffer
operator|,
name|png_size_t
name|buffer_length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_process_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_handle_unknown
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_have_info
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_have_end
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_have_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_bytep
name|row
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_read_end
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_process_some_data
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_read_push_finish_row
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_handle_tEXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_read_tEXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_handle_zTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_read_zTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_handle_iTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|,
name|png_uint_32
name|length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_push_read_iTXt
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PROGRESSIVE_READ */
comment|/* Added at libpng version 1.6.0 */
ifdef|#
directive|ifdef
name|PNG_GAMMA_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_colorspace_set_gamma
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
name|png_fixed_point
name|gAMA
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Set the colorspace gamma with a value provided by the application or by     * the gAMA chunk on read.  The value will override anything set by an ICC     * profile.     */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_colorspace_sync_info
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Synchronize the info 'valid' flags with the colorspace */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_colorspace_sync
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_inforp
name|info_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Copy the png_struct colorspace to the info_struct and call the above to      * synchronize the flags.  Checks for NULL info_ptr and does nothing.      */
endif|#
directive|endif
comment|/* Added at libpng version 1.4.0 */
ifdef|#
directive|ifdef
name|PNG_COLORSPACE_SUPPORTED
comment|/* These internal functions are for maintaining the colorspace structure within  * a png_info or png_struct (or, indeed, both).  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_colorspace_set_chromaticities
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
specifier|const
name|png_xy
operator|*
name|xy
operator|,
name|int
name|preferred
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_colorspace_set_endpoints
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
specifier|const
name|png_XYZ
operator|*
name|XYZ
operator|,
name|int
name|preferred
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_colorspace_set_sRGB
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
name|int
name|intent
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* This does set the colorspace gAMA and cHRM values too, but doesn't set the     * flags to write them, if it returns false there was a problem and an error     * message has already been output (but the colorspace may still need to be     * synced to record the invalid flag).     */
endif|#
directive|endif
comment|/* sRGB */
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_colorspace_set_ICC
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
name|png_const_charp
name|name
operator|,
name|png_uint_32
name|profile_length
operator|,
name|png_const_bytep
name|profile
operator|,
name|int
name|color_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* The 'name' is used for information only */
comment|/* Routines for checking parts of an ICC profile. */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_icc_check_length
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
name|png_const_charp
name|name
operator|,
name|png_uint_32
name|profile_length
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_icc_check_header
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
name|png_const_charp
name|name
operator|,
name|png_uint_32
name|profile_length
operator|,
name|png_const_bytep
name|profile
comment|/* first 132 bytes only */
operator|,
name|int
name|color_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_icc_check_tag_table
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
name|png_const_charp
name|name
operator|,
name|png_uint_32
name|profile_length
operator|,
name|png_const_bytep
name|profile
comment|/* header plus whole tag table */
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_icc_set_sRGB
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_colorspacerp
name|colorspace
operator|,
name|png_const_bytep
name|profile
operator|,
name|uLong
name|adler
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* 'adler' is the Adler32 checksum of the uncompressed profile data. It may     * be zero to indicate that it is not available.  It is used, if provided,     * as a fast check on the profile when checking to see if it is sRGB.     */
endif|#
directive|endif
endif|#
directive|endif
comment|/* iCCP */
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_colorspace_set_rgb_coefficients
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Set the rgb_to_gray coefficients from the colorspace Y values */
endif|#
directive|endif
comment|/* READ_RGB_TO_GRAY */
endif|#
directive|endif
comment|/* COLORSPACE */
comment|/* Added at libpng version 1.4.0 */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_check_IHDR
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_uint_32
name|width
operator|,
name|png_uint_32
name|height
operator|,
name|int
name|bit_depth
operator|,
name|int
name|color_type
operator|,
name|int
name|interlace_type
operator|,
name|int
name|compression_type
operator|,
name|int
name|filter_type
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Added at libpng version 1.5.10 */
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_do_check_palette_indexes
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|png_row_infop
name|row_info
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_ERROR_TEXT_SUPPORTED
argument_list|)
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_fixed_error
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|name
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite  * the end.  Always leaves the buffer nul terminated.  Never errors out (and  * there is no error code.)  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|size_t
argument_list|,
name|png_safecat
argument_list|,
operator|(
name|png_charp
name|buffer
operator|,
name|size_t
name|bufsize
operator|,
name|size_t
name|pos
operator|,
name|png_const_charp
name|string
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Various internal functions to handle formatted warning messages, currently  * only implemented for warnings.  */
if|#
directive|if
name|defined
argument_list|(
name|PNG_WARNINGS_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_TIME_RFC1123_SUPPORTED
argument_list|)
comment|/* Utility to dump an unsigned value into a buffer, given a start pointer and  * and end pointer (which should point just *beyond* the end of the buffer!)  * Returns the pointer to the start of the formatted string.  This utility only  * does unsigned values.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_charp
argument_list|,
name|png_format_number
argument_list|,
operator|(
name|png_const_charp
name|start
operator|,
name|png_charp
name|end
operator|,
name|int
name|format
operator|,
name|png_alloc_size_t
name|number
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Convenience macro that takes an array: */
DECL|macro|PNG_FORMAT_NUMBER
define|#
directive|define
name|PNG_FORMAT_NUMBER
parameter_list|(
name|buffer
parameter_list|,
name|format
parameter_list|,
name|number
parameter_list|)
define|\
value|png_format_number(buffer, buffer + (sizeof buffer), format, number)
comment|/* Suggested size for a number buffer (enough for 64 bits and a sign!) */
DECL|macro|PNG_NUMBER_BUFFER_SIZE
define|#
directive|define
name|PNG_NUMBER_BUFFER_SIZE
value|24
comment|/* These are the integer formats currently supported, the name is formed from  * the standard printf(3) format string.  */
DECL|macro|PNG_NUMBER_FORMAT_u
define|#
directive|define
name|PNG_NUMBER_FORMAT_u
value|1
comment|/* chose unsigned API! */
DECL|macro|PNG_NUMBER_FORMAT_02u
define|#
directive|define
name|PNG_NUMBER_FORMAT_02u
value|2
DECL|macro|PNG_NUMBER_FORMAT_d
define|#
directive|define
name|PNG_NUMBER_FORMAT_d
value|1
comment|/* chose signed API! */
DECL|macro|PNG_NUMBER_FORMAT_02d
define|#
directive|define
name|PNG_NUMBER_FORMAT_02d
value|2
DECL|macro|PNG_NUMBER_FORMAT_x
define|#
directive|define
name|PNG_NUMBER_FORMAT_x
value|3
DECL|macro|PNG_NUMBER_FORMAT_02x
define|#
directive|define
name|PNG_NUMBER_FORMAT_02x
value|4
DECL|macro|PNG_NUMBER_FORMAT_fixed
define|#
directive|define
name|PNG_NUMBER_FORMAT_fixed
value|5
comment|/* choose the signed API */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
comment|/* New defines and members adding in libpng-1.5.4 */
DECL|macro|PNG_WARNING_PARAMETER_SIZE
define|#
directive|define
name|PNG_WARNING_PARAMETER_SIZE
value|32
DECL|macro|PNG_WARNING_PARAMETER_COUNT
define|#
directive|define
name|PNG_WARNING_PARAMETER_COUNT
value|8
comment|/* Maximum 9; see pngerror.c */
comment|/* An l-value of this type has to be passed to the APIs below to cache the  * values of the parameters to a formatted warning message.  */
DECL|typedef|png_warning_parameters
typedef|typedef
name|char
name|png_warning_parameters
index|[
name|PNG_WARNING_PARAMETER_COUNT
index|]
index|[
name|PNG_WARNING_PARAMETER_SIZE
index|]
typedef|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_warning_parameter
argument_list|,
operator|(
name|png_warning_parameters
name|p
operator|,
name|int
name|number
operator|,
name|png_const_charp
name|string
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Parameters are limited in size to PNG_WARNING_PARAMETER_SIZE characters,     * including the trailing '\0'.     */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_warning_parameter_unsigned
argument_list|,
operator|(
name|png_warning_parameters
name|p
operator|,
name|int
name|number
operator|,
name|int
name|format
operator|,
name|png_alloc_size_t
name|value
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Use png_alloc_size_t because it is an unsigned type as big as any we     * need to output.  Use the following for a signed value.     */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_warning_parameter_signed
argument_list|,
operator|(
name|png_warning_parameters
name|p
operator|,
name|int
name|number
operator|,
name|int
name|format
operator|,
name|png_int_32
name|value
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_formatted_warning
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_warning_parameters
name|p
operator|,
name|png_const_charp
name|message
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* 'message' follows the X/Open approach of using @1, @2 to insert     * parameters previously supplied using the above functions.  Errors in     * specifying the parameters will simply result in garbage substitutions.     */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
comment|/* Application errors (new in 1.6); use these functions (declared below) for  * errors in the parameters or order of API function calls on read.  The  * 'warning' should be used for an error that can be handled completely; the  * 'error' for one which can be handled safely but which may lose application  * information or settings.  *  * By default these both result in a png_error call prior to release, while in a  * released version the 'warning' is just a warning.  However if the application  * explicitly disables benign errors (explicitly permitting the code to lose  * information) they both turn into warnings.  *  * If benign errors aren't supported they end up as the corresponding base call  * (png_warning or png_error.)  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_app_warning
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|message
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* The application provided invalid parameters to an API function or called     * an API function at the wrong time, libpng can completely recover.     */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_app_error
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|message
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* As above but libpng will ignore the call, or attempt some other partial     * recovery from the error.     */
else|#
directive|else
DECL|macro|png_app_warning
define|#
directive|define
name|png_app_warning
parameter_list|(
name|pp
parameter_list|,
name|s
parameter_list|)
value|png_warning(pp,s)
DECL|macro|png_app_error
define|#
directive|define
name|png_app_error
parameter_list|(
name|pp
parameter_list|,
name|s
parameter_list|)
value|png_error(pp,s)
endif|#
directive|endif
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_chunk_report
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|message
operator|,
name|int
name|error
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Report a recoverable issue in chunk data.  On read this is used to report     * a problem found while reading a particular chunk and the     * png_chunk_benign_error or png_chunk_warning function is used as     * appropriate.  On write this is used to report an error that comes from     * data set via an application call to a png_set_ API and png_app_error or     * png_app_warning is used as appropriate.     *     * The 'error' parameter must have one of the following values:     */
DECL|macro|PNG_CHUNK_WARNING
define|#
directive|define
name|PNG_CHUNK_WARNING
value|0
comment|/* never an error */
DECL|macro|PNG_CHUNK_WRITE_ERROR
define|#
directive|define
name|PNG_CHUNK_WRITE_ERROR
value|1
comment|/* an error only on write */
DECL|macro|PNG_CHUNK_ERROR
define|#
directive|define
name|PNG_CHUNK_ERROR
value|2
comment|/* always an error */
comment|/* ASCII to FP interfaces, currently only implemented if sCAL  * support is required.  */
if|#
directive|if
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
comment|/* MAX_DIGITS is actually the maximum number of characters in an sCAL  * width or height, derived from the precision (number of significant  * digits - a build time settable option) and assumptions about the  * maximum ridiculous exponent.  */
DECL|macro|PNG_sCAL_MAX_DIGITS
define|#
directive|define
name|PNG_sCAL_MAX_DIGITS
value|(PNG_sCAL_PRECISION+1
comment|/*.*/
value|+1
comment|/*E*/
value|+10
comment|/*exponent*/
value|)
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_ascii_from_fp
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_charp
name|ascii
operator|,
name|png_size_t
name|size
operator|,
name|double
name|fp
operator|,
name|unsigned
name|int
name|precision
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FLOATING_POINT */
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_ascii_from_fixed
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_charp
name|ascii
operator|,
name|png_size_t
name|size
operator|,
name|png_fixed_point
name|fp
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FIXED_POINT */
endif|#
directive|endif
comment|/* sCAL */
if|#
directive|if
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_pCAL_SUPPORTED
argument_list|)
comment|/* An internal API to validate the format of a floating point number.  * The result is the index of the next character.  If the number is  * not valid it will be the index of a character in the supposed number.  *  * The format of a number is defined in the PNG extensions specification  * and this API is strictly conformant to that spec, not anyone elses!  *  * The format as a regular expression is:  *  * [+-]?[0-9]+.?([Ee][+-]?[0-9]+)?  *  * or:  *  * [+-]?.[0-9]+(.[0-9]+)?([Ee][+-]?[0-9]+)?  *  * The complexity is that either integer or fraction must be present and the  * fraction is permitted to have no digits only if the integer is present.  *  * NOTE: The dangling E problem.  *   There is a PNG valid floating point number in the following:  *  *       PNG floating point numbers are not greedy.  *  *   Working this out requires *TWO* character lookahead (because of the  *   sign), the parser does not do this - it will fail at the 'r' - this  *   doesn't matter for PNG sCAL chunk values, but it requires more care  *   if the value were ever to be embedded in something more complex.  Use  *   ANSI-C strtod if you need the lookahead.  */
comment|/* State table for the parser. */
DECL|macro|PNG_FP_INTEGER
define|#
directive|define
name|PNG_FP_INTEGER
value|0
comment|/* before or in integer */
DECL|macro|PNG_FP_FRACTION
define|#
directive|define
name|PNG_FP_FRACTION
value|1
comment|/* before or in fraction */
DECL|macro|PNG_FP_EXPONENT
define|#
directive|define
name|PNG_FP_EXPONENT
value|2
comment|/* before or in exponent */
DECL|macro|PNG_FP_STATE
define|#
directive|define
name|PNG_FP_STATE
value|3
comment|/* mask for the above */
DECL|macro|PNG_FP_SAW_SIGN
define|#
directive|define
name|PNG_FP_SAW_SIGN
value|4
comment|/* Saw +/- in current state */
DECL|macro|PNG_FP_SAW_DIGIT
define|#
directive|define
name|PNG_FP_SAW_DIGIT
value|8
comment|/* Saw a digit in current state */
DECL|macro|PNG_FP_SAW_DOT
define|#
directive|define
name|PNG_FP_SAW_DOT
value|16
comment|/* Saw a dot in current state */
DECL|macro|PNG_FP_SAW_E
define|#
directive|define
name|PNG_FP_SAW_E
value|32
comment|/* Saw an E (or e) in current state */
DECL|macro|PNG_FP_SAW_ANY
define|#
directive|define
name|PNG_FP_SAW_ANY
value|60
comment|/* Saw any of the above 4 */
comment|/* These three values don't affect the parser.  They are set but not used.  */
DECL|macro|PNG_FP_WAS_VALID
define|#
directive|define
name|PNG_FP_WAS_VALID
value|64
comment|/* Preceding substring is a valid fp number */
DECL|macro|PNG_FP_NEGATIVE
define|#
directive|define
name|PNG_FP_NEGATIVE
value|128
comment|/* A negative number, including "-0" */
DECL|macro|PNG_FP_NONZERO
define|#
directive|define
name|PNG_FP_NONZERO
value|256
comment|/* A non-zero value */
DECL|macro|PNG_FP_STICKY
define|#
directive|define
name|PNG_FP_STICKY
value|448
comment|/* The above three flags */
comment|/* This is available for the caller to store in 'state' if required.  Do not  * call the parser after setting it (the parser sometimes clears it.)  */
DECL|macro|PNG_FP_INVALID
define|#
directive|define
name|PNG_FP_INVALID
value|512
comment|/* Available for callers as a distinct value */
comment|/* Result codes for the parser (boolean - true meants ok, false means  * not ok yet.)  */
DECL|macro|PNG_FP_MAYBE
define|#
directive|define
name|PNG_FP_MAYBE
value|0
comment|/* The number may be valid in the future */
DECL|macro|PNG_FP_OK
define|#
directive|define
name|PNG_FP_OK
value|1
comment|/* The number is valid */
comment|/* Tests on the sticky non-zero and negative flags.  To pass these checks  * the state must also indicate that the whole number is valid - this is  * achieved by testing PNG_FP_SAW_DIGIT (see the implementation for why this  * is equivalent to PNG_FP_OK above.)  */
DECL|macro|PNG_FP_NZ_MASK
define|#
directive|define
name|PNG_FP_NZ_MASK
value|(PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
comment|/* NZ_MASK: the string is valid and a non-zero negative value */
DECL|macro|PNG_FP_Z_MASK
define|#
directive|define
name|PNG_FP_Z_MASK
value|(PNG_FP_SAW_DIGIT | PNG_FP_NONZERO)
comment|/* Z MASK: the string is valid and a non-zero value. */
comment|/* PNG_FP_SAW_DIGIT: the string is valid. */
DECL|macro|PNG_FP_IS_ZERO
define|#
directive|define
name|PNG_FP_IS_ZERO
parameter_list|(
name|state
parameter_list|)
value|(((state)& PNG_FP_Z_MASK) == PNG_FP_SAW_DIGIT)
DECL|macro|PNG_FP_IS_POSITIVE
define|#
directive|define
name|PNG_FP_IS_POSITIVE
parameter_list|(
name|state
parameter_list|)
value|(((state)& PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
DECL|macro|PNG_FP_IS_NEGATIVE
define|#
directive|define
name|PNG_FP_IS_NEGATIVE
parameter_list|(
name|state
parameter_list|)
value|(((state)& PNG_FP_NZ_MASK) == PNG_FP_NZ_MASK)
comment|/* The actual parser.  This can be called repeatedly. It updates  * the index into the string and the state variable (which must  * be initialized to 0).  It returns a result code, as above.  There  * is no point calling the parser any more if it fails to advance to  * the end of the string - it is stuck on an invalid character (or  * terminated by '\0').  *  * Note that the pointer will consume an E or even an E+ and then leave  * a 'maybe' state even though a preceding integer.fraction is valid.  * The PNG_FP_WAS_VALID flag indicates that a preceding substring was  * a valid number.  It's possible to recover from this by calling  * the parser again (from the start, with state 0) but with a string  * that omits the last character (i.e. set the size to the index of  * the problem character.)  This has not been tested within libpng.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_check_fp_number
argument_list|,
operator|(
name|png_const_charp
name|string
operator|,
name|png_size_t
name|size
operator|,
name|int
operator|*
name|statep
operator|,
name|png_size_tp
name|whereami
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* This is the same but it checks a complete string and returns true  * only if it just contains a floating point number.  As of 1.5.4 this  * function also returns the state at the end of parsing the number if  * it was valid (otherwise it returns 0.)  This can be used for testing  * for negative or zero values using the sticky flag.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_check_fp_string
argument_list|,
operator|(
name|png_const_charp
name|string
operator|,
name|png_size_t
name|size
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pCAL || sCAL */
if|#
directive|if
name|defined
argument_list|(
name|PNG_GAMMA_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_pHYs_SUPPORTED
argument_list|)
comment|/* Added at libpng version 1.5.0 */
comment|/* This is a utility to provide a*times/div (rounded) and indicate  * if there is an overflow.  The result is a boolean - false (0)  * for overflow, true (1) if no overflow, in which case *res  * holds the result.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_muldiv
argument_list|,
operator|(
name|png_fixed_point_p
name|res
operator|,
name|png_fixed_point
name|a
operator|,
name|png_int_32
name|multiplied_by
operator|,
name|png_int_32
name|divided_by
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
comment|/* Same deal, but issue a warning on overflow and return 0. */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_fixed_point
argument_list|,
name|png_muldiv_warn
argument_list|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_fixed_point
name|a
operator|,
name|png_int_32
name|multiplied_by
operator|,
name|png_int_32
name|divided_by
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_GAMMA_SUPPORTED
comment|/* Calculate a reciprocal - used for gamma values.  This returns  * 0 if the argument is 0 in order to maintain an undefined value;  * there are no warnings.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_fixed_point
argument_list|,
name|png_reciprocal
argument_list|,
operator|(
name|png_fixed_point
name|a
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* The same but gives a reciprocal of the product of two fixed point  * values.  Accuracy is suitable for gamma calculations but this is  * not exact - use png_muldiv for that.  Only required at present on read.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_fixed_point
argument_list|,
name|png_reciprocal2
argument_list|,
operator|(
name|png_fixed_point
name|a
operator|,
name|png_fixed_point
name|b
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Return true if the gamma value is significantly different from 1.0 */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_gamma_significant
argument_list|,
operator|(
name|png_fixed_point
name|gamma_value
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* Internal fixed point gamma correction.  These APIs are called as  * required to convert single values - they don't need to be fast,  * they are not used when processing image pixel values.  *  * While the input is an 'unsigned' value it must actually be the  * correct bit value - 0..255 or 0..65535 as required.  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_uint_16
argument_list|,
name|png_gamma_correct
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|unsigned
name|int
name|value
operator|,
name|png_fixed_point
name|gamma_value
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_uint_16
argument_list|,
name|png_gamma_16bit_correct
argument_list|,
operator|(
name|unsigned
name|int
name|value
operator|,
name|png_fixed_point
name|gamma_value
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|png_byte
argument_list|,
name|png_gamma_8bit_correct
argument_list|,
operator|(
name|unsigned
name|int
name|value
operator|,
name|png_fixed_point
name|gamma_value
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_destroy_gamma_table
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_build_gamma_table
argument_list|,
operator|(
name|png_structrp
name|png_ptr
operator|,
name|int
name|bit_depth
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIMPLIFIED READ/WRITE SUPPORT */
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_READ_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
argument_list|)
comment|/* The internal structure that png_image::opaque points to. */
DECL|struct|png_control
typedef|typedef
struct|struct
name|png_control
block|{
DECL|member|png_ptr
name|png_structp
name|png_ptr
decl_stmt|;
DECL|member|info_ptr
name|png_infop
name|info_ptr
decl_stmt|;
DECL|member|error_buf
name|png_voidp
name|error_buf
decl_stmt|;
comment|/* Always a jmp_buf at present. */
DECL|member|memory
name|png_const_bytep
name|memory
decl_stmt|;
comment|/* Memory buffer. */
DECL|member|size
name|png_size_t
name|size
decl_stmt|;
comment|/* Size of the memory buffer. */
DECL|member|for_write
name|unsigned
name|int
name|for_write
range|:
literal|1
decl_stmt|;
comment|/* Otherwise it is a read structure */
DECL|member|owned_file
name|unsigned
name|int
name|owned_file
range|:
literal|1
decl_stmt|;
comment|/* We own the file in io_ptr */
block|}
DECL|typedef|png_control
name|png_control
typedef|;
comment|/* Return the pointer to the jmp_buf from a png_control: necessary because C  * does not reveal the type of the elements of jmp_buf.  */
ifdef|#
directive|ifdef
name|__cplusplus
DECL|macro|png_control_jmp_buf
define|#
directive|define
name|png_control_jmp_buf
parameter_list|(
name|pc
parameter_list|)
value|(((jmp_buf*)((pc)->error_buf))[0])
else|#
directive|else
DECL|macro|png_control_jmp_buf
define|#
directive|define
name|png_control_jmp_buf
parameter_list|(
name|pc
parameter_list|)
value|((pc)->error_buf)
endif|#
directive|endif
comment|/* Utility to safely execute a piece of libpng code catching and logging any  * errors that might occur.  Returns true on success, false on failure (either  * of the function or as a result of a png_error.)  */
name|PNG_INTERNAL_CALLBACK
argument_list|(
name|void
argument_list|,
name|png_safe_error
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|error_message
operator|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
name|PNG_INTERNAL_CALLBACK
argument_list|(
name|void
argument_list|,
name|png_safe_warning
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
else|#
directive|else
DECL|macro|png_safe_warning
define|#
directive|define
name|png_safe_warning
value|0
comment|/*dummy argument*/
endif|#
directive|endif
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_safe_execute
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
name|int
argument_list|(
operator|*
name|function
argument_list|)
argument_list|(
name|png_voidp
argument_list|)
operator|,
name|png_voidp
name|arg
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Utility to log an error; this also cleans up the png_image; the function  * always returns 0 (false).  */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|int
argument_list|,
name|png_image_error
argument_list|,
operator|(
name|png_imagep
name|image
operator|,
name|png_const_charp
name|error_message
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_SIMPLIFIED_READ_SUPPORTED
comment|/* png_image_free is used by the write code but not exported */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_image_free
argument_list|,
operator|(
name|png_imagep
name|image
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SIMPLIFIED_READ */
endif|#
directive|endif
comment|/* SIMPLIFIED READ/WRITE */
comment|/* These are initialization functions for hardware specific PNG filter  * optimizations; list these here then select the appropriate one at compile  * time using the macro PNG_FILTER_OPTIMIZATIONS.  If the macro is not defined  * the generic code is used.  */
ifdef|#
directive|ifdef
name|PNG_FILTER_OPTIMIZATIONS
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|PNG_FILTER_OPTIMIZATIONS
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|unsigned
name|int
name|bpp
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
comment|/* Just declare the optimization that will be used */
else|#
directive|else
comment|/* List *all* the possible optimizations here - this branch is required if     * the builder of libpng passes the definition of PNG_FILTER_OPTIMIZATIONS in     * CFLAGS in place of CPPFLAGS *and* uses symbol prefixing.     */
name|PNG_INTERNAL_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_init_filter_functions_neon
argument_list|,
operator|(
name|png_structp
name|png_ptr
operator|,
name|unsigned
name|int
name|bpp
operator|)
argument_list|,
name|PNG_EMPTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Maintainer: Put new private prototypes here ^ */
include|#
directive|include
file|"pngdebug.h"
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_VERSION_INFO_ONLY */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNGPRIV_H */
end_comment
end_unit
