begin_unit
begin_comment
comment|/* pngread.c - read a PNG file  *  * Last changed in libpng 1.5.10 [March 8, 2012]  * Copyright (c) 1998-2012 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * This file contains routines that an application calls directly to  * read a PNG file or stream.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Create a PNG structure for reading, and allocate any memory needed. */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_read_struct
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
return|return
operator|(
name|png_create_read_struct_2
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_block
begin_comment
comment|/* Alternate create PNG structure for reading, and allocate any memory  * needed.  */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_read_struct_2
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,     png_malloc_ptr malloc_fn, png_free_ptr free_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
endif|#
directive|endif
comment|/* PNG_USER_MEM_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
specifier|volatile
endif|#
directive|endif
name|png_structp
name|png_ptr
decl_stmt|;
specifier|volatile
name|int
name|png_cleanup_needed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
name|jmp_buf
name|tmp_jmpbuf
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_create_read_struct"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_ptr
operator|=
operator|(
name|png_structp
operator|)
name|png_create_struct_2
argument_list|(
name|PNG_STRUCT_PNG
argument_list|,
name|malloc_fn
argument_list|,
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_ptr
operator|=
operator|(
name|png_structp
operator|)
name|png_create_struct
argument_list|(
name|PNG_STRUCT_PNG
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Added at libpng-1.2.6 */
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
name|png_ptr
operator|->
name|user_width_max
operator|=
name|PNG_USER_WIDTH_MAX
expr_stmt|;
name|png_ptr
operator|->
name|user_height_max
operator|=
name|PNG_USER_HEIGHT_MAX
expr_stmt|;
comment|/* Added at libpng-1.2.43 and 1.4.0 */
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|=
name|PNG_USER_CHUNK_CACHE_MAX
expr_stmt|;
comment|/* Added at libpng-1.2.43 and 1.4.1 */
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|=
name|PNG_USER_CHUNK_MALLOC_MAX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* Applications that neglect to set up their own setjmp() and then  * encounter a png_error() will longjmp here.  Since the jmpbuf is  * then meaningless we abort instead of returning.  */
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
if|if
condition|(
name|setjmp
argument_list|(
name|tmp_jmpbuf
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
condition|)
comment|/* Sets longjmp to match setjmp */
endif|#
directive|endif
name|PNG_ABORT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
name|png_memcpy
argument_list|(
name|png_jmpbuf
argument_list|(
name|png_ptr
argument_list|)
argument_list|,
name|tmp_jmpbuf
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PNG_SETJMP_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_set_mem_fn
argument_list|(
name|png_ptr
argument_list|,
name|mem_ptr
argument_list|,
name|malloc_fn
argument_list|,
name|free_fn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_set_error_fn
argument_list|(
name|png_ptr
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|)
expr_stmt|;
comment|/* Call the general version checker (shared with read and write code): */
if|if
condition|(
operator|!
name|png_user_version_check
argument_list|(
name|png_ptr
argument_list|,
name|user_png_ver
argument_list|)
condition|)
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|png_cleanup_needed
condition|)
block|{
comment|/* Initialize zbuf - compression buffer */
name|png_ptr
operator|->
name|zbuf_size
operator|=
name|PNG_ZBUF_SIZE
expr_stmt|;
name|png_ptr
operator|->
name|zbuf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zbuf
operator|==
name|NULL
condition|)
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
block|}
name|png_ptr
operator|->
name|zstream
operator|.
name|zalloc
operator|=
name|png_zalloc
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|zfree
operator|=
name|png_zfree
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
name|png_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|png_cleanup_needed
condition|)
block|{
switch|switch
condition|(
name|inflateInit
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
comment|/* Do nothing */
case|case
name|Z_MEM_ERROR
case|:
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib memory error"
argument_list|)
expr_stmt|;
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_STREAM_ERROR
case|:
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib stream error"
argument_list|)
expr_stmt|;
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_VERSION_ERROR
case|:
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib version error"
argument_list|)
expr_stmt|;
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown zlib error"
argument_list|)
expr_stmt|;
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_cleanup_needed
condition|)
block|{
comment|/* Clean up PNG structure and deallocate any memory. */
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zbuf
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|,
operator|(
name|png_free_ptr
operator|)
name|free_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|png_set_read_fn
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|png_ptr
operator|)
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the information before the actual image data.  This has been  * changed in v0.90 to allow reading a file that already has the magic  * bytes read from the stream.  You can tell libpng how many bytes have  * been read from the beginning of the stream (up to the maximum of 8)  * via png_set_sig_bytes(), and we will only check the remaining bytes  * here.  The application can then have access to the signature bytes we  * read if it is determined that this isn't a valid PNG file.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_info
name|png_read_info
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Read and check the PNG file signature. */
name|png_read_sig
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|png_uint_32
name|length
init|=
name|png_read_chunk_header
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|png_uint_32
name|chunk_name
init|=
name|png_ptr
operator|->
name|chunk_name
decl_stmt|;
comment|/* This should be a binary subdivision search or a hash for        * matching the chunk name rather than a linear search.        */
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_AFTER_IDAT
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_CHUNK_AFTER_IDAT
expr_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_IHDR
condition|)
name|png_handle_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IEND
condition|)
name|png_handle_IEND
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
elseif|else
if|if
condition|(
name|png_chunk_unknown_handling
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|)
operator|!=
name|PNG_HANDLE_CHUNK_AS_DEFAULT
condition|)
block|{
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before IDAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before IDAT"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_handle_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before IDAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before IDAT"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|=
name|length
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_bKGD
condition|)
name|png_handle_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_cHRM
condition|)
name|png_handle_cHRM
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_gAMA
condition|)
name|png_handle_gAMA
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_hIST
condition|)
name|png_handle_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_oFFs
condition|)
name|png_handle_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pCAL
condition|)
name|png_handle_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sCAL
condition|)
name|png_handle_sCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pHYs
condition|)
name|png_handle_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sBIT
condition|)
name|png_handle_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sRGB
condition|)
name|png_handle_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iCCP
condition|)
name|png_handle_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sPLT
condition|)
name|png_handle_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tEXt
condition|)
name|png_handle_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tIME
condition|)
name|png_handle_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tRNS
condition|)
name|png_handle_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_zTXt
condition|)
name|png_handle_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iTXt
condition|)
name|png_handle_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_comment
comment|/* Optional call to update the users info_ptr structure */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_update_info
name|png_read_update_info
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_update_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_read_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
name|png_read_transform_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Initialize palette, background, etc, after transformations  * are set, but before any reading takes place.  This allows  * the user to obtain a gamma-corrected palette, for example.  * If the user doesn't call this, we will do it ourselves.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_start_read_image
name|png_start_read_image
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_start_read_image"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
name|png_read_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_read_row
name|png_read_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_bytep
name|dsp_row
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|png_row_info
name|row_info
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_debug2
argument_list|(
literal|1
argument_list|,
literal|"in png_read_row (row %lu, pass %d)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|row_number
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|)
expr_stmt|;
comment|/* png_read_start_row sets the information (in particular iwidth) for this     * interlace pass.     */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
condition|)
name|png_read_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* 1.5.6: row_info moved out of png_struct to a local here. */
name|row_info
operator|.
name|width
operator|=
name|png_ptr
operator|->
name|iwidth
expr_stmt|;
comment|/* NOTE: width of current interlaced row */
name|row_info
operator|.
name|color_type
operator|=
name|png_ptr
operator|->
name|color_type
expr_stmt|;
name|row_info
operator|.
name|bit_depth
operator|=
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
name|row_info
operator|.
name|channels
operator|=
name|png_ptr
operator|->
name|channels
expr_stmt|;
name|row_info
operator|.
name|pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
name|row_info
operator|.
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|.
name|pixel_depth
argument_list|,
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* Check for transforms that have been set but were defined out */
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_INVERT_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_INVERT_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_MONO
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_INVERT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_FILLER_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_FILLER_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_FILLER
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_FILLER_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_PACKSWAP_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|PNG_READ_PACKSWAP_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_PACKSWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_PACK_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_PACK_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_PACK_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_SHIFT_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_SHIFT_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SHIFT
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_SHIFT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_BGR_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_BGR_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BGR
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_BGR_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_SWAP_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_SWAP_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SWAP_BYTES
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_SWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* If interlaced and we do not need a new row, combine row and return.     * Notice that the pixels we have from previous rows have been transformed     * already; we can only combine like with like (transformed or     * untransformed) and, because of the libpng API for interlaced images, this     * means we must transform before de-interlacing.     */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
switch|switch
condition|(
name|png_ptr
operator|->
name|pass
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|5
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
operator|&&
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|4
operator|)
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|3
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|3
operator|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
operator|&&
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|2
operator|)
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|5
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|1
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
case|case
literal|6
case|:
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|1
operator|)
condition|)
block|{
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid attempt to read row data"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
call|(
name|uInt
call|)
argument_list|(
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|png_ptr
operator|->
name|idat_size
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|=
name|png_read_chunk_header
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
operator|!=
name|png_IDAT
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough image data"
argument_list|)
expr_stmt|;
block|}
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zbuf_size
operator|>
name|png_ptr
operator|->
name|idat_size
condition|)
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|idat_size
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
operator|(
name|png_size_t
operator|)
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|-=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
expr_stmt|;
block|}
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|||
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|||
name|png_ptr
operator|->
name|idat_size
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compressed data"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_FINISHED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
condition|?
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
else|:
literal|"Decompression error"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
condition|)
do|;
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|>
name|PNG_FILTER_VALUE_NONE
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|<
name|PNG_FILTER_VALUE_LAST
condition|)
name|png_read_filter_row
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|prev_row
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad adaptive filter value"
argument_list|)
expr_stmt|;
block|}
comment|/* libpng 1.5.6: the following line was copying png_ptr->rowbytes before     * 1.5.6, while the buffer really is this big in current versions of libpng     * it may not be in the future, so this was changed just to copy the     * interlaced count:     */
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
name|png_ptr
operator|->
name|row_buf
argument_list|,
name|row_info
operator|.
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|&&
operator|(
name|png_ptr
operator|->
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
condition|)
block|{
comment|/* Intrapixel differencing */
name|png_do_read_intrapixel
argument_list|(
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
condition|)
name|png_do_read_transformations
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The transformed pixel depth should match the depth now in row_info. */
if|if
condition|(
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|=
name|row_info
operator|.
name|pixel_depth
expr_stmt|;
if|if
condition|(
name|row_info
operator|.
name|pixel_depth
operator|>
name|png_ptr
operator|->
name|maximum_pixel_depth
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"sequential row overflow"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|!=
name|row_info
operator|.
name|pixel_depth
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal sequential row size calculation error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Blow up interlaced rows to full size */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|6
condition|)
name|png_do_read_interlace
argument_list|(
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|,
name|png_ptr
operator|->
name|transformations
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|,
literal|0
comment|/*row*/
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|,
operator|-
literal|1
comment|/*ignored*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
operator|-
literal|1
comment|/*ignored*/
argument_list|)
expr_stmt|;
block|}
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|read_row_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|read_row_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|png_ptr
operator|->
name|row_number
operator|,
name|png_ptr
operator|->
name|pass
operator|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read one or more rows of image data.  If the image is interlaced,  * and png_set_interlace_handling() has been called, the rows need to  * contain the contents of the rows from the previous pass.  If the  * image has alpha or transparency, and png_handle_alpha()[*] has been  * called, the rows contents must be initialized to the contents of the  * screen.  *  * "row" holds the actual image, and pixels are placed in it  * as they arrive.  If the image is displayed after each pass, it will  * appear to "sparkle" in.  "display_row" can be used to display a  * "chunky" progressive image, with finer detail added as it becomes  * available.  If you do not want this "chunky" display, you may pass  * NULL for display_row.  If you do not want the sparkle display, and  * you have not called png_handle_alpha(), you may pass NULL for rows.  * If you have called png_handle_alpha(), and the image has either an  * alpha channel or a transparency chunk, you must provide a buffer for  * rows.  In this case, you do not have to provide a display_row buffer  * also, but you may.  If the image is not interlaced, or if you have  * not called png_set_interlace_handling(), the display_row buffer will  * be ignored, so pass NULL to it.  *  * [*] png_handle_alpha() does not exist yet, as of this version of libpng  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_rows
name|png_read_rows
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytepp
name|row
parameter_list|,
name|png_bytepp
name|display_row
parameter_list|,
name|png_uint_32
name|num_rows
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
name|png_bytepp
name|rp
decl_stmt|;
name|png_bytepp
name|dp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_rows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|rp
operator|=
name|row
expr_stmt|;
name|dp
operator|=
name|display_row
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|dp
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
control|)
block|{
name|png_bytep
name|rptr
init|=
operator|*
name|rp
operator|++
decl_stmt|;
name|png_bytep
name|dptr
init|=
operator|*
name|dp
operator|++
decl_stmt|;
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|rptr
argument_list|,
name|dptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
control|)
block|{
name|png_bytep
name|rptr
init|=
operator|*
name|rp
decl_stmt|;
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|rptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
control|)
block|{
name|png_bytep
name|dptr
init|=
operator|*
name|dp
decl_stmt|;
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|dptr
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the entire image.  If the image has an alpha channel or a tRNS  * chunk, and you have called png_handle_alpha()[*], you will need to  * initialize the image to the current image that PNG will be overlaying.  * We set the num_rows again here, in case it was incorrectly set in  * png_read_start_row() by a call to png_read_update_info() or  * png_start_read_image() if png_set_interlace_handling() wasn't called  * prior to either of these functions like it should have been.  You can  * only call this function once.  If you desire to have an image for  * each pass of a interlaced image, use png_read_rows() instead.  *  * [*] png_handle_alpha() does not exist yet, as of this version of libpng  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_image
name|png_read_image
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytepp
name|image
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|,
name|image_height
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|j
decl_stmt|;
name|png_bytepp
name|rp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_image"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
condition|)
block|{
name|pass
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* And make sure transforms are initialized. */
name|png_start_read_image
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
comment|/* Caller called png_start_read_image or png_read_update_info without           * first turning on the PNG_INTERLACE transform.  We can fix this here,           * but the caller should do it!           */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Interlace handling should be turned on when "
literal|"using png_read_image"
argument_list|)
expr_stmt|;
comment|/* Make sure this is set correctly */
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
block|}
comment|/* Obtain the pass number, which also turns on the PNG_INTERLACE flag in        * the above error case.        */
name|pass
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Cannot read interlaced image -- interlace handler disabled"
argument_list|)
expr_stmt|;
name|pass
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|image_height
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pass
condition|;
name|j
operator|++
control|)
block|{
name|rp
operator|=
name|image
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|image_height
condition|;
name|i
operator|++
control|)
block|{
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|rp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the end of the PNG file.  Will not read past the end of the  * file, will verify the end is accurate, and will read any comments  * or time information at the end of the file, if info is not NULL.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_end
name|png_read_end
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Finish off CRC from last IDAT chunk */
ifdef|#
directive|ifdef
name|PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
comment|/* Report invalid palette index; added at libng-1.5.10 */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|png_ptr
operator|->
name|num_palette_max
operator|>
name|png_ptr
operator|->
name|num_palette
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Read palette index exceeding num_palette"
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|png_uint_32
name|length
init|=
name|png_read_chunk_header
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|png_uint_32
name|chunk_name
init|=
name|png_ptr
operator|->
name|chunk_name
decl_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_IHDR
condition|)
name|png_handle_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IEND
condition|)
name|png_handle_IEND
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
elseif|else
if|if
condition|(
name|png_chunk_unknown_handling
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|)
operator|!=
name|PNG_HANDLE_CHUNK_AS_DEFAULT
condition|)
block|{
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_AFTER_IDAT
operator|)
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many IDATs found"
argument_list|)
expr_stmt|;
block|}
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
comment|/* Zero length IDATs are legal after the last IDAT has been           * read, but not after other chunks have been read.           */
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_AFTER_IDAT
operator|)
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many IDATs found"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_handle_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_bKGD
condition|)
name|png_handle_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_cHRM
condition|)
name|png_handle_cHRM
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_gAMA
condition|)
name|png_handle_gAMA
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_hIST
condition|)
name|png_handle_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_oFFs
condition|)
name|png_handle_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pCAL
condition|)
name|png_handle_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sCAL
condition|)
name|png_handle_sCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pHYs
condition|)
name|png_handle_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sBIT
condition|)
name|png_handle_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sRGB
condition|)
name|png_handle_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iCCP
condition|)
name|png_handle_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sPLT
condition|)
name|png_handle_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tEXt
condition|)
name|png_handle_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tIME
condition|)
name|png_handle_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tRNS
condition|)
name|png_handle_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_zTXt
condition|)
name|png_handle_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iTXt
condition|)
name|png_handle_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IEND
operator|)
condition|)
do|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_comment
comment|/* Free all memory used by the read */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_destroy_read_struct
name|png_destroy_read_struct
parameter_list|(
name|png_structpp
name|png_ptr_ptr
parameter_list|,
name|png_infopp
name|info_ptr_ptr
parameter_list|,
name|png_infopp
name|end_info_ptr_ptr
parameter_list|)
block|{
name|png_structp
name|png_ptr
init|=
name|NULL
decl_stmt|;
name|png_infop
name|info_ptr
init|=
name|NULL
decl_stmt|,
name|end_info_ptr
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_free_ptr
name|free_fn
init|=
name|NULL
decl_stmt|;
name|png_voidp
name|mem_ptr
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_destroy_read_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr_ptr
operator|!=
name|NULL
condition|)
name|png_ptr
operator|=
operator|*
name|png_ptr_ptr
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|free_fn
operator|=
name|png_ptr
operator|->
name|free_fn
expr_stmt|;
name|mem_ptr
operator|=
name|png_ptr
operator|->
name|mem_ptr
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info_ptr_ptr
operator|!=
name|NULL
condition|)
name|info_ptr
operator|=
operator|*
name|info_ptr_ptr
expr_stmt|;
if|if
condition|(
name|end_info_ptr_ptr
operator|!=
name|NULL
condition|)
name|end_info_ptr
operator|=
operator|*
name|end_info_ptr_ptr
expr_stmt|;
name|png_read_destroy
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|end_info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_TEXT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|,
operator|(
name|png_free_ptr
operator|)
name|free_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|info_ptr_ptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|end_info_ptr
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_TEXT_SUPPORTED
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|end_info_ptr
argument_list|,
name|PNG_FREE_TEXT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|end_info_ptr
argument_list|,
operator|(
name|png_free_ptr
operator|)
name|free_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|end_info_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|end_info_ptr_ptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|,
operator|(
name|png_free_ptr
operator|)
name|free_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|png_ptr_ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Free all memory used by the read (old method) */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_destroy
name|png_read_destroy
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_infop
name|end_info_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|jmp_buf
name|tmp_jmp
decl_stmt|;
endif|#
directive|endif
name|png_error_ptr
name|error_fn
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
name|png_error_ptr
name|warning_fn
decl_stmt|;
endif|#
directive|endif
name|png_voidp
name|error_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_free_ptr
name|free_fn
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_destroy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
name|png_info_destroy
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_info_ptr
operator|!=
name|NULL
condition|)
name|png_info_destroy
argument_list|(
name|png_ptr
argument_list|,
name|end_info_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
name|png_destroy_gamma_table
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|big_row_buf
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|big_prev_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|palette_lookup
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|quantize_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|->
name|free_me
operator|&
name|PNG_FREE_PLTE
condition|)
name|png_zfree
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|palette
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|free_me
operator|&=
operator|~
name|PNG_FREE_PLTE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_tRNS_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_EXPAND_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|free_me
operator|&
name|PNG_FREE_TRNS
condition|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|free_me
operator|&=
operator|~
name|PNG_FREE_TRNS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|free_me
operator|&
name|PNG_FREE_HIST
condition|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|hist
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|free_me
operator|&=
operator|~
name|PNG_FREE_HIST
expr_stmt|;
endif|#
directive|endif
name|inflateEnd
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Save the important info out of the png_struct, in case it is     * being used again.     */
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|png_memcpy
argument_list|(
name|tmp_jmp
argument_list|,
name|png_ptr
operator|->
name|longjmp_buffer
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error_fn
operator|=
name|png_ptr
operator|->
name|error_fn
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
name|warning_fn
operator|=
name|png_ptr
operator|->
name|warning_fn
expr_stmt|;
endif|#
directive|endif
name|error_ptr
operator|=
name|png_ptr
operator|->
name|error_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|free_fn
operator|=
name|png_ptr
operator|->
name|free_fn
expr_stmt|;
endif|#
directive|endif
name|png_memset
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|,
name|png_sizeof
argument_list|(
name|png_struct
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|error_fn
operator|=
name|error_fn
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
name|png_ptr
operator|->
name|warning_fn
operator|=
name|warning_fn
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|error_ptr
operator|=
name|error_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_ptr
operator|->
name|free_fn
operator|=
name|free_fn
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|longjmp_buffer
argument_list|,
name|tmp_jmp
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_read_status_fn
name|png_set_read_status_fn
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_read_status_ptr
name|read_row_fn
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|read_row_fn
operator|=
name|read_row_fn
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_read_png
name|png_read_png
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|transforms
parameter_list|,
name|voidp
name|params
parameter_list|)
block|{
name|int
name|row
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* png_read_info() gives us all of the information from the     * PNG file before the first IDAT (image data chunk).     */
name|png_read_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|height
operator|>
name|PNG_UINT_32_MAX
operator|/
name|png_sizeof
argument_list|(
name|png_bytep
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Image is too high to process with png_read_png()"
argument_list|)
expr_stmt|;
comment|/* -------------- image transformations start here ------------------- */
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
comment|/* Tell libpng to strip 16-bit/color files down to 8 bits per color.     */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_SCALE_16
condition|)
block|{
comment|/* Added at libpng-1.5.4. "strip_16" produces the same result that it       * did in earlier versions, while "scale_16" is now more accurate.       */
name|png_set_scale_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
comment|/* If both SCALE and STRIP are required pngrtran will effectively cancel the     * latter by doing SCALE first.  This is ok and allows apps not to check for     * which is supported to get the right answer.     */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_16
condition|)
name|png_set_strip_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
comment|/* Strip alpha bytes from the input data without combining with     * the background (not recommended).     */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_ALPHA
condition|)
name|png_set_strip_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_PACK_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_EXPAND_SUPPORTED
argument_list|)
comment|/* Extract multiple pixels with bit depths of 1, 2, or 4 from a single     * byte into separate bytes (useful for paletted and grayscale images).     */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKING
condition|)
name|png_set_packing
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
comment|/* Change the order of packed pixels to least significant bit first     * (not useful if you are using png_set_packing).     */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKSWAP
condition|)
name|png_set_packswap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
comment|/* Expand paletted colors into true RGB triplets     * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel     * Expand paletted or RGB images with transparency to full alpha     * channels so the data will be available as RGBA quartets.     */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_EXPAND
condition|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
operator|||
operator|(
name|png_get_valid
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
operator|)
condition|)
name|png_set_expand
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We don't handle background color or gamma transformation or quantizing.     */
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_SUPPORTED
comment|/* Invert monochrome files to have 0 as white and 1 as black     */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_MONO
condition|)
name|png_set_invert_mono
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SHIFT_SUPPORTED
comment|/* If you want to shift the pixel values from the range [0,255] or     * [0,65535] to the original [0,7] or [0,31], or whatever range the     * colors were originally in:     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SHIFT
operator|)
operator|&&
name|png_get_valid
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_INFO_sBIT
argument_list|)
condition|)
block|{
name|png_color_8p
name|sig_bit
decl_stmt|;
name|png_get_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|sig_bit
argument_list|)
expr_stmt|;
name|png_set_shift
argument_list|(
name|png_ptr
argument_list|,
name|sig_bit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_BGR_SUPPORTED
comment|/* Flip the RGB pixels to BGR (or RGBA to BGRA) */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_BGR
condition|)
name|png_set_bgr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SWAP_ALPHA_SUPPORTED
comment|/* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ALPHA
condition|)
name|png_set_swap_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SWAP_SUPPORTED
comment|/* Swap bytes of 16-bit files to least significant byte first */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ENDIAN
condition|)
name|png_set_swap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added at libpng-1.2.41 */
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_ALPHA_SUPPORTED
comment|/* Invert the alpha channel from opacity to transparency */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_ALPHA
condition|)
name|png_set_invert_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added at libpng-1.2.41 */
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
comment|/* Expand grayscale image to RGB */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_GRAY_TO_RGB
condition|)
name|png_set_gray_to_rgb
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added at libpng-1.5.4 */
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_EXPAND_16
condition|)
name|png_set_expand_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We don't handle adding filler bytes */
comment|/* We use png_read_image and rely on that for interlace handling, but we also     * call png_read_update_info therefore must turn on interlace handling now:     */
operator|(
name|void
operator|)
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Optional call to gamma correct and add the background to the palette     * and update info structure.  REQUIRED if you are expecting libpng to     * update the palette for you (i.e., you selected such a transform above).     */
name|png_read_update_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* -------------- image transformations end here ------------------- */
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|row_pointers
operator|==
name|NULL
condition|)
block|{
name|png_uint_32
name|iptr
decl_stmt|;
name|info_ptr
operator|->
name|row_pointers
operator|=
operator|(
name|png_bytepp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|height
operator|*
name|png_sizeof
argument_list|(
name|png_bytep
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iptr
operator|=
literal|0
init|;
name|iptr
operator|<
name|info_ptr
operator|->
name|height
condition|;
name|iptr
operator|++
control|)
name|info_ptr
operator|->
name|row_pointers
index|[
name|iptr
index|]
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_ROWS
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|height
condition|;
name|row
operator|++
control|)
name|info_ptr
operator|->
name|row_pointers
index|[
name|row
index|]
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_get_rowbytes
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|png_read_image
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_IDAT
expr_stmt|;
comment|/* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
name|png_read_end
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|transforms
argument_list|)
comment|/* Quiet compiler warnings */
name|PNG_UNUSED
argument_list|(
argument|params
argument_list|)
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_INFO_IMAGE_SUPPORTED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_SUPPORTED */
end_comment
end_unit
