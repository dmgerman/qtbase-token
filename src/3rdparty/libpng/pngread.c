begin_unit
begin_comment
comment|/* pngread.c - read a PNG file  *  * Last changed in libpng 1.6.17 [March 26, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * This file contains routines that an application calls directly to  * read a PNG file or stream.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_READ_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_STDIO_SUPPORTED
argument_list|)
end_if
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Create a PNG structure for reading, and allocate any memory needed. */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_read_struct
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
ifndef|#
directive|ifndef
name|PNG_USER_MEM_SUPPORTED
name|png_structp
name|png_ptr
init|=
name|png_create_png_struct
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
else|#
directive|else
return|return
name|png_create_read_struct_2
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* Alternate create PNG structure for reading, and allocate any memory  * needed.  */
end_comment
begin_macro
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_read_struct_2
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,     png_malloc_ptr malloc_fn, png_free_ptr free_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_structp
name|png_ptr
init|=
name|png_create_png_struct
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|mem_ptr
argument_list|,
name|malloc_fn
argument_list|,
name|free_fn
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* USER_MEM */
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|mode
operator|=
name|PNG_IS_READ_STRUCT
expr_stmt|;
comment|/* Added in libpng-1.6.0; this can be used to detect a read structure if        * required (it will be zero in a write structure.)        */
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
name|png_ptr
operator|->
name|IDAT_read_size
operator|=
name|PNG_IDAT_READ_SIZE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_BENIGN_READ_ERRORS_SUPPORTED
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_BENIGN_ERRORS_WARN
expr_stmt|;
comment|/* In stable builds only warn if an application error can be completely           * handled.           */
if|#
directive|if
name|PNG_RELEASE_BUILD
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_APP_WARNINGS_WARN
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* TODO: delay this, it can be done in png_init_io (if the app doesn't        * do it itself) avoiding setting the default function if it is not        * required.        */
name|png_set_read_fn
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|png_ptr
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the information before the actual image data.  This has been  * changed in v0.90 to allow reading a file that already has the magic  * bytes read from the stream.  You can tell libpng how many bytes have  * been read from the beginning of the stream (up to the maximum of 8)  * via png_set_sig_bytes(), and we will only check the remaining bytes  * here.  The application can then have access to the signature bytes we  * read if it is determined that this isn't a valid PNG file.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_info
name|png_read_info
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
name|int
name|keep
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Read and check the PNG file signature. */
name|png_read_sig
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|png_uint_32
name|length
init|=
name|png_read_chunk_header
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|png_uint_32
name|chunk_name
init|=
name|png_ptr
operator|->
name|chunk_name
decl_stmt|;
comment|/* IDAT logic needs to happen here to simplify getting the two flags        * right.        */
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before IDAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before IDAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_AFTER_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many IDATs found"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
comment|/* This should be a binary subdivision search or a hash for        * matching the chunk name rather than a linear search.        */
if|if
condition|(
name|chunk_name
operator|==
name|png_IHDR
condition|)
name|png_handle_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IEND
condition|)
name|png_handle_IEND
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
elseif|else
if|if
condition|(
operator|(
name|keep
operator|=
name|png_chunk_unknown_handling
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|,
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
name|png_ptr
operator|->
name|idat_size
operator|=
literal|0
expr_stmt|;
comment|/* It has been consumed */
break|break;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_handle_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
name|png_ptr
operator|->
name|idat_size
operator|=
name|length
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_bKGD
condition|)
name|png_handle_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_cHRM
condition|)
name|png_handle_cHRM
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_gAMA
condition|)
name|png_handle_gAMA
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_hIST
condition|)
name|png_handle_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_oFFs
condition|)
name|png_handle_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pCAL
condition|)
name|png_handle_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sCAL
condition|)
name|png_handle_sCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pHYs
condition|)
name|png_handle_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sBIT
condition|)
name|png_handle_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sRGB
condition|)
name|png_handle_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iCCP
condition|)
name|png_handle_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sPLT
condition|)
name|png_handle_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tEXt
condition|)
name|png_handle_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tIME
condition|)
name|png_handle_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tRNS
condition|)
name|png_handle_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_zTXt
condition|)
name|png_handle_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iTXt
condition|)
name|png_handle_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|,
name|PNG_HANDLE_CHUNK_AS_DEFAULT
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_comment
comment|/* Optional call to update the users info_ptr structure */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_update_info
name|png_read_update_info
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_update_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|png_read_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
name|png_read_transform_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
endif|#
directive|endif
block|}
comment|/* New in 1.6.0 this avoids the bug of doing the initializations twice */
else|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_read_update_info/png_start_read_image: duplicate call"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Initialize palette, background, etc, after transformations  * are set, but before any reading takes place.  This allows  * the user to obtain a gamma-corrected palette, for example.  * If the user doesn't call this, we will do it ourselves.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_start_read_image
name|png_start_read_image
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_start_read_image"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
operator|==
literal|0
condition|)
name|png_read_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* New in 1.6.0 this avoids the bug of doing the initializations twice */
else|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_start_read_image/png_read_update_info: duplicate call"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
end_ifdef
begin_comment
comment|/* Undoes intrapixel differencing,  * NOTE: this is apparently only supported in the 'sequential' reader.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_read_intrapixel
name|png_do_read_intrapixel
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_read_intrapixel"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|bytes_per_pixel
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
name|bytes_per_pixel
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|bytes_per_pixel
operator|=
literal|4
expr_stmt|;
else|else
return|return;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|rp
operator|+=
name|bytes_per_pixel
control|)
block|{
operator|*
operator|(
name|rp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|256
operator|+
operator|*
name|rp
operator|+
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|256
operator|+
operator|*
operator|(
name|rp
operator|+
literal|2
operator|)
operator|+
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
name|bytes_per_pixel
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|bytes_per_pixel
operator|=
literal|8
expr_stmt|;
else|else
return|return;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|rp
operator|+=
name|bytes_per_pixel
control|)
block|{
name|png_uint_32
name|s0
init|=
operator|(
operator|*
operator|(
name|rp
operator|)
operator|<<
literal|8
operator|)
operator||
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
decl_stmt|;
name|png_uint_32
name|s1
init|=
operator|(
operator|*
operator|(
name|rp
operator|+
literal|2
operator|)
operator|<<
literal|8
operator|)
operator||
operator|*
operator|(
name|rp
operator|+
literal|3
operator|)
decl_stmt|;
name|png_uint_32
name|s2
init|=
operator|(
operator|*
operator|(
name|rp
operator|+
literal|4
operator|)
operator|<<
literal|8
operator|)
operator||
operator|*
operator|(
name|rp
operator|+
literal|5
operator|)
decl_stmt|;
name|png_uint_32
name|red
init|=
operator|(
name|s0
operator|+
name|s1
operator|+
literal|65536
operator|)
operator|&
literal|0xffff
decl_stmt|;
name|png_uint_32
name|blue
init|=
operator|(
name|s2
operator|+
name|s1
operator|+
literal|65536
operator|)
operator|&
literal|0xffff
decl_stmt|;
operator|*
operator|(
name|rp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|red
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|red
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|blue
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|blue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MNG_FEATURES */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_row
name|png_read_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_bytep
name|dsp_row
parameter_list|)
block|{
name|png_row_info
name|row_info
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_debug2
argument_list|(
literal|1
argument_list|,
literal|"in png_read_row (row %lu, pass %d)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|row_number
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|)
expr_stmt|;
comment|/* png_read_start_row sets the information (in particular iwidth) for this     * interlace pass.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
operator|==
literal|0
condition|)
name|png_read_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* 1.5.6: row_info moved out of png_struct to a local here. */
name|row_info
operator|.
name|width
operator|=
name|png_ptr
operator|->
name|iwidth
expr_stmt|;
comment|/* NOTE: width of current interlaced row */
name|row_info
operator|.
name|color_type
operator|=
name|png_ptr
operator|->
name|color_type
expr_stmt|;
name|row_info
operator|.
name|bit_depth
operator|=
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
name|row_info
operator|.
name|channels
operator|=
name|png_ptr
operator|->
name|channels
expr_stmt|;
name|row_info
operator|.
name|pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
name|row_info
operator|.
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|.
name|pixel_depth
argument_list|,
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* Check for transforms that have been set but were defined out */
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_INVERT_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_INVERT_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_MONO
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_INVERT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_FILLER_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_FILLER_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_FILLER
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_FILLER_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_PACKSWAP_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|PNG_READ_PACKSWAP_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_PACKSWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_PACK_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_PACK_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_PACK_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_SHIFT_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_SHIFT_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SHIFT
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_SHIFT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_BGR_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_BGR_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BGR
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_BGR_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_SWAP_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_READ_SWAP_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SWAP_BYTES
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_READ_SWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* WARNINGS */
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* If interlaced and we do not need a new row, combine row and return.     * Notice that the pixels we have from previous rows have been transformed     * already; we can only combine like with like (transformed or     * untransformed) and, because of the libpng API for interlaced images, this     * means we must transform before de-interlacing.     */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|png_ptr
operator|->
name|pass
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|5
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
operator|&&
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|4
operator|)
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|3
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|3
operator|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
operator|&&
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|2
operator|)
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|5
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|1
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
case|case
literal|6
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid attempt to read row data"
argument_list|)
expr_stmt|;
comment|/* Fill the row with IDAT data: */
name|png_read_IDAT_data
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
argument_list|,
name|row_info
operator|.
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|>
name|PNG_FILTER_VALUE_NONE
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|<
name|PNG_FILTER_VALUE_LAST
condition|)
name|png_read_filter_row
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|prev_row
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad adaptive filter value"
argument_list|)
expr_stmt|;
block|}
comment|/* libpng 1.5.6: the following line was copying png_ptr->rowbytes before     * 1.5.6, while the buffer really is this big in current versions of libpng     * it may not be in the future, so this was changed just to copy the     * interlaced count:     */
name|memcpy
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
name|png_ptr
operator|->
name|row_buf
argument_list|,
name|row_info
operator|.
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
condition|)
block|{
comment|/* Intrapixel differencing */
name|png_do_read_intrapixel
argument_list|(
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
condition|)
name|png_do_read_transformations
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The transformed pixel depth should match the depth now in row_info. */
if|if
condition|(
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|=
name|row_info
operator|.
name|pixel_depth
expr_stmt|;
if|if
condition|(
name|row_info
operator|.
name|pixel_depth
operator|>
name|png_ptr
operator|->
name|maximum_pixel_depth
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"sequential row overflow"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|!=
name|row_info
operator|.
name|pixel_depth
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal sequential row size calculation error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Expand interlaced rows to full size */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|6
condition|)
name|png_do_read_interlace
argument_list|(
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|,
name|png_ptr
operator|->
name|transformations
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
literal|1
comment|/*display*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|,
literal|0
comment|/*row*/
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|,
operator|-
literal|1
comment|/*ignored*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|dsp_row
argument_list|,
operator|-
literal|1
comment|/*ignored*/
argument_list|)
expr_stmt|;
block|}
name|png_read_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|read_row_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|read_row_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|png_ptr
operator|->
name|row_number
operator|,
name|png_ptr
operator|->
name|pass
operator|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read one or more rows of image data.  If the image is interlaced,  * and png_set_interlace_handling() has been called, the rows need to  * contain the contents of the rows from the previous pass.  If the  * image has alpha or transparency, and png_handle_alpha()[*] has been  * called, the rows contents must be initialized to the contents of the  * screen.  *  * "row" holds the actual image, and pixels are placed in it  * as they arrive.  If the image is displayed after each pass, it will  * appear to "sparkle" in.  "display_row" can be used to display a  * "chunky" progressive image, with finer detail added as it becomes  * available.  If you do not want this "chunky" display, you may pass  * NULL for display_row.  If you do not want the sparkle display, and  * you have not called png_handle_alpha(), you may pass NULL for rows.  * If you have called png_handle_alpha(), and the image has either an  * alpha channel or a transparency chunk, you must provide a buffer for  * rows.  In this case, you do not have to provide a display_row buffer  * also, but you may.  If the image is not interlaced, or if you have  * not called png_set_interlace_handling(), the display_row buffer will  * be ignored, so pass NULL to it.  *  * [*] png_handle_alpha() does not exist yet, as of this version of libpng  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_rows
name|png_read_rows
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytepp
name|row
parameter_list|,
name|png_bytepp
name|display_row
parameter_list|,
name|png_uint_32
name|num_rows
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
name|png_bytepp
name|rp
decl_stmt|;
name|png_bytepp
name|dp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_rows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|rp
operator|=
name|row
expr_stmt|;
name|dp
operator|=
name|display_row
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|dp
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
control|)
block|{
name|png_bytep
name|rptr
init|=
operator|*
name|rp
operator|++
decl_stmt|;
name|png_bytep
name|dptr
init|=
operator|*
name|dp
operator|++
decl_stmt|;
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|rptr
argument_list|,
name|dptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
control|)
block|{
name|png_bytep
name|rptr
init|=
operator|*
name|rp
decl_stmt|;
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|rptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
control|)
block|{
name|png_bytep
name|dptr
init|=
operator|*
name|dp
decl_stmt|;
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|dptr
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the entire image.  If the image has an alpha channel or a tRNS  * chunk, and you have called png_handle_alpha()[*], you will need to  * initialize the image to the current image that PNG will be overlaying.  * We set the num_rows again here, in case it was incorrectly set in  * png_read_start_row() by a call to png_read_update_info() or  * png_start_read_image() if png_set_interlace_handling() wasn't called  * prior to either of these functions like it should have been.  You can  * only call this function once.  If you desire to have an image for  * each pass of a interlaced image, use png_read_rows() instead.  *  * [*] png_handle_alpha() does not exist yet, as of this version of libpng  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_image
name|png_read_image
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytepp
name|image
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|,
name|image_height
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|j
decl_stmt|;
name|png_bytepp
name|rp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_image"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|pass
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* And make sure transforms are initialized. */
name|png_start_read_image
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Caller called png_start_read_image or png_read_update_info without           * first turning on the PNG_INTERLACE transform.  We can fix this here,           * but the caller should do it!           */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Interlace handling should be turned on when "
literal|"using png_read_image"
argument_list|)
expr_stmt|;
comment|/* Make sure this is set correctly */
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
block|}
comment|/* Obtain the pass number, which also turns on the PNG_INTERLACE flag in        * the above error case.        */
name|pass
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Cannot read interlaced image -- interlace handler disabled"
argument_list|)
expr_stmt|;
name|pass
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|image_height
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pass
condition|;
name|j
operator|++
control|)
block|{
name|rp
operator|=
name|image
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|image_height
condition|;
name|i
operator|++
control|)
block|{
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|rp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the end of the PNG file.  Will not read past the end of the  * file, will verify the end is accurate, and will read any comments  * or time information at the end of the file, if info is not NULL.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_read_end
name|png_read_end
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
name|int
name|keep
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* If png_read_end is called in the middle of reading the rows there may     * still be pending IDAT data and an owned zstream.  Deal with this here.     */
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
if|if
condition|(
name|png_chunk_unknown_handling
argument_list|(
name|png_ptr
argument_list|,
name|png_IDAT
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|png_read_finish_IDAT
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
comment|/* Report invalid palette index; added at libng-1.5.10 */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|png_ptr
operator|->
name|num_palette_max
operator|>
name|png_ptr
operator|->
name|num_palette
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Read palette index exceeding num_palette"
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|png_uint_32
name|length
init|=
name|png_read_chunk_header
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|png_uint_32
name|chunk_name
init|=
name|png_ptr
operator|->
name|chunk_name
decl_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_IEND
condition|)
name|png_handle_IEND
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IHDR
condition|)
name|png_handle_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info_ptr
operator|==
name|NULL
condition|)
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
elseif|else
if|if
condition|(
operator|(
name|keep
operator|=
name|png_chunk_unknown_handling
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_AFTER_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many IDATs found"
argument_list|)
expr_stmt|;
block|}
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|,
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
comment|/* Zero length IDATs are legal after the last IDAT has been           * read, but not after other chunks have been read.           */
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_AFTER_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many IDATs found"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_handle_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_bKGD
condition|)
name|png_handle_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_cHRM
condition|)
name|png_handle_cHRM
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_gAMA
condition|)
name|png_handle_gAMA
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_hIST
condition|)
name|png_handle_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_oFFs
condition|)
name|png_handle_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pCAL
condition|)
name|png_handle_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sCAL
condition|)
name|png_handle_sCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pHYs
condition|)
name|png_handle_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sBIT
condition|)
name|png_handle_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sRGB
condition|)
name|png_handle_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iCCP
condition|)
name|png_handle_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sPLT
condition|)
name|png_handle_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tEXt
condition|)
name|png_handle_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tIME
condition|)
name|png_handle_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tRNS
condition|)
name|png_handle_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_zTXt
condition|)
name|png_handle_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iTXt
condition|)
name|png_handle_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|length
argument_list|,
name|PNG_HANDLE_CHUNK_AS_DEFAULT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IEND
operator|)
operator|==
literal|0
condition|)
do|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_comment
comment|/* Free all memory used in the read struct */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_read_destroy
name|png_read_destroy
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_destroy"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
name|png_destroy_gamma_table
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|big_row_buf
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|big_row_buf
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|big_prev_row
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|big_prev_row
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|read_buffer
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|read_buffer
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|palette_lookup
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|palette_lookup
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|quantize_index
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|quantize_index
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|free_me
operator|&
name|PNG_FREE_PLTE
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_zfree
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|palette
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|palette
operator|=
name|NULL
expr_stmt|;
block|}
name|png_ptr
operator|->
name|free_me
operator|&=
operator|~
name|PNG_FREE_PLTE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_tRNS_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_EXPAND_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|free_me
operator|&
name|PNG_FREE_TRNS
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|trans_alpha
operator|=
name|NULL
expr_stmt|;
block|}
name|png_ptr
operator|->
name|free_me
operator|&=
operator|~
name|PNG_FREE_TRNS
expr_stmt|;
endif|#
directive|endif
name|inflateEnd
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_list
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* NOTE: the 'setjmp' buffer may still be allocated and the memory and error     * callbacks are still set at this point.  They are required to complete the     * destruction of the png_struct itself.     */
block|}
end_function
begin_comment
comment|/* Free all memory used by the read */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_destroy_read_struct
name|png_destroy_read_struct
parameter_list|(
name|png_structpp
name|png_ptr_ptr
parameter_list|,
name|png_infopp
name|info_ptr_ptr
parameter_list|,
name|png_infopp
name|end_info_ptr_ptr
parameter_list|)
block|{
name|png_structrp
name|png_ptr
init|=
name|NULL
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_destroy_read_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr_ptr
operator|!=
name|NULL
condition|)
name|png_ptr
operator|=
operator|*
name|png_ptr_ptr
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* libpng 1.6.0: use the API to destroy info structs to ensure consistent     * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.     * The extra was, apparently, unnecessary yet this hides memory leak bugs.     */
name|png_destroy_info_struct
argument_list|(
name|png_ptr
argument_list|,
name|end_info_ptr_ptr
argument_list|)
expr_stmt|;
name|png_destroy_info_struct
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr_ptr
argument_list|)
expr_stmt|;
operator|*
name|png_ptr_ptr
operator|=
name|NULL
expr_stmt|;
name|png_read_destroy
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_destroy_png_struct
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_read_status_fn
name|png_set_read_status_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_read_status_ptr
name|read_row_fn
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|read_row_fn
operator|=
name|read_row_fn
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_read_png
name|png_read_png
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|transforms
parameter_list|,
name|voidp
name|params
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* png_read_info() gives us all of the information from the     * PNG file before the first IDAT (image data chunk).     */
name|png_read_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|height
operator|>
name|PNG_UINT_32_MAX
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|png_bytep
argument_list|)
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Image is too high to process with png_read_png()"
argument_list|)
expr_stmt|;
comment|/* -------------- image transformations start here ------------------- */
comment|/* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM     * is not implemented.  This will only happen in de-configured (non-default)     * libpng builds.  The results can be unexpected - png_read_png may return     * short or mal-formed rows because the transform is skipped.     */
comment|/* Tell libpng to strip 16-bit/color files down to 8 bits per color.     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SCALE_16
operator|)
operator|!=
literal|0
condition|)
comment|/* Added at libpng-1.5.4. "strip_16" produces the same result that it        * did in earlier versions, while "scale_16" is now more accurate.        */
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
name|png_set_scale_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_SCALE_16 not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If both SCALE and STRIP are required pngrtran will effectively cancel the     * latter by doing SCALE first.  This is ok and allows apps not to check for     * which is supported to get the right answer.     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_16
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
name|png_set_strip_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_STRIP_16 not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Strip alpha bytes from the input data without combining with     * the background (not recommended).     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_ALPHA
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
name|png_set_strip_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_STRIP_ALPHA not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Extract multiple pixels with bit depths of 1, 2, or 4 from a single     * byte into separate bytes (useful for paletted and grayscale images).     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKING
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_PACK_SUPPORTED
name|png_set_packing
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_PACKING not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Change the order of packed pixels to least significant bit first     * (not useful if you are using png_set_packing).     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
name|png_set_packswap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_PACKSWAP not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Expand paletted colors into true RGB triplets     * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel     * Expand paletted or RGB images with transparency to full alpha     * channels so the data will be available as RGBA quartets.     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_EXPAND
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
name|png_set_expand
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_EXPAND not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We don't handle background color or gamma transformation or quantizing.     */
comment|/* Invert monochrome files to have 0 as white and 1 as black     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_MONO
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_SUPPORTED
name|png_set_invert_mono
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_INVERT_MONO not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If you want to shift the pixel values from the range [0,255] or     * [0,65535] to the original [0,7] or [0,31], or whatever range the     * colors were originally in:     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SHIFT
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_SHIFT_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sBIT
operator|)
operator|!=
literal|0
condition|)
name|png_set_shift
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|sig_bit
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_SHIFT not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Flip the RGB pixels to BGR (or RGBA to BGRA) */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_BGR
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_BGR_SUPPORTED
name|png_set_bgr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_BGR not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ALPHA
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_SWAP_ALPHA_SUPPORTED
name|png_set_swap_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_SWAP_ALPHA not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Swap bytes of 16-bit files to least significant byte first */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ENDIAN
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_SWAP_SUPPORTED
name|png_set_swap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_SWAP_ENDIAN not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added at libpng-1.2.41 */
comment|/* Invert the alpha channel from opacity to transparency */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_ALPHA
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_ALPHA_SUPPORTED
name|png_set_invert_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_INVERT_ALPHA not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added at libpng-1.2.41 */
comment|/* Expand grayscale image to RGB */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_GRAY_TO_RGB
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
name|png_set_gray_to_rgb
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_GRAY_TO_RGB not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Added at libpng-1.5.4 */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_EXPAND_16
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
name|png_set_expand_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_EXPAND_16 not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We don't handle adding filler bytes */
comment|/* We use png_read_image and rely on that for interlace handling, but we also     * call png_read_update_info therefore must turn on interlace handling now:     */
operator|(
name|void
operator|)
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Optional call to gamma correct and add the background to the palette     * and update info structure.  REQUIRED if you are expecting libpng to     * update the palette for you (i.e., you selected such a transform above).     */
name|png_read_update_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* -------------- image transformations end here ------------------- */
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|row_pointers
operator|==
name|NULL
condition|)
block|{
name|png_uint_32
name|iptr
decl_stmt|;
name|info_ptr
operator|->
name|row_pointers
operator|=
name|png_voidcast
argument_list|(
name|png_bytepp
argument_list|,
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|height
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_bytep
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iptr
operator|=
literal|0
init|;
name|iptr
operator|<
name|info_ptr
operator|->
name|height
condition|;
name|iptr
operator|++
control|)
name|info_ptr
operator|->
name|row_pointers
index|[
name|iptr
index|]
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_ROWS
expr_stmt|;
for|for
control|(
name|iptr
operator|=
literal|0
init|;
name|iptr
operator|<
name|info_ptr
operator|->
name|height
condition|;
name|iptr
operator|++
control|)
name|info_ptr
operator|->
name|row_pointers
index|[
name|iptr
index|]
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|rowbytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|png_read_image
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_IDAT
expr_stmt|;
comment|/* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
name|png_read_end
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|params
argument_list|)
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* INFO_IMAGE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* SIMPLIFIED READ  *  * This code currently relies on the sequential reader, though it could easily  * be made to work with the progressive one.  */
end_comment
begin_comment
comment|/* Arguments to png_image_finish_read: */
end_comment
begin_comment
comment|/* Encoding of PNG data (used by the color-map code) */
end_comment
begin_define
DECL|macro|P_NOTSET
define|#
directive|define
name|P_NOTSET
value|0
end_define
begin_comment
DECL|macro|P_NOTSET
comment|/* File encoding not yet known */
end_comment
begin_define
DECL|macro|P_sRGB
define|#
directive|define
name|P_sRGB
value|1
end_define
begin_comment
DECL|macro|P_sRGB
comment|/* 8-bit encoded to sRGB gamma */
end_comment
begin_define
DECL|macro|P_LINEAR
define|#
directive|define
name|P_LINEAR
value|2
end_define
begin_comment
DECL|macro|P_LINEAR
comment|/* 16-bit linear: not encoded, NOT pre-multiplied! */
end_comment
begin_define
DECL|macro|P_FILE
define|#
directive|define
name|P_FILE
value|3
end_define
begin_comment
DECL|macro|P_FILE
comment|/* 8-bit encoded to file gamma, not sRGB or linear */
end_comment
begin_define
DECL|macro|P_LINEAR8
define|#
directive|define
name|P_LINEAR8
value|4
end_define
begin_comment
DECL|macro|P_LINEAR8
comment|/* 8-bit linear: only from a file value */
end_comment
begin_comment
comment|/* Color-map processing: after libpng has run on the PNG image further  * processing may be needed to convert the data to color-map indices.  */
end_comment
begin_define
DECL|macro|PNG_CMAP_NONE
define|#
directive|define
name|PNG_CMAP_NONE
value|0
end_define
begin_define
DECL|macro|PNG_CMAP_GA
define|#
directive|define
name|PNG_CMAP_GA
value|1
end_define
begin_comment
DECL|macro|PNG_CMAP_GA
comment|/* Process GA data to a color-map with alpha */
end_comment
begin_define
DECL|macro|PNG_CMAP_TRANS
define|#
directive|define
name|PNG_CMAP_TRANS
value|2
end_define
begin_comment
DECL|macro|PNG_CMAP_TRANS
comment|/* Process GA data to a background index */
end_comment
begin_define
DECL|macro|PNG_CMAP_RGB
define|#
directive|define
name|PNG_CMAP_RGB
value|3
end_define
begin_comment
DECL|macro|PNG_CMAP_RGB
comment|/* Process RGB data */
end_comment
begin_define
DECL|macro|PNG_CMAP_RGB_ALPHA
define|#
directive|define
name|PNG_CMAP_RGB_ALPHA
value|4
end_define
begin_comment
DECL|macro|PNG_CMAP_RGB_ALPHA
comment|/* Process RGBA data */
end_comment
begin_comment
comment|/* The following document where the background is for each processing case. */
end_comment
begin_define
DECL|macro|PNG_CMAP_NONE_BACKGROUND
define|#
directive|define
name|PNG_CMAP_NONE_BACKGROUND
value|256
end_define
begin_define
DECL|macro|PNG_CMAP_GA_BACKGROUND
define|#
directive|define
name|PNG_CMAP_GA_BACKGROUND
value|231
end_define
begin_define
DECL|macro|PNG_CMAP_TRANS_BACKGROUND
define|#
directive|define
name|PNG_CMAP_TRANS_BACKGROUND
value|254
end_define
begin_define
DECL|macro|PNG_CMAP_RGB_BACKGROUND
define|#
directive|define
name|PNG_CMAP_RGB_BACKGROUND
value|256
end_define
begin_define
DECL|macro|PNG_CMAP_RGB_ALPHA_BACKGROUND
define|#
directive|define
name|PNG_CMAP_RGB_ALPHA_BACKGROUND
value|216
end_define
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Arguments: */
DECL|member|image
name|png_imagep
name|image
decl_stmt|;
DECL|member|buffer
name|png_voidp
name|buffer
decl_stmt|;
DECL|member|row_stride
name|png_int_32
name|row_stride
decl_stmt|;
DECL|member|colormap
name|png_voidp
name|colormap
decl_stmt|;
DECL|member|background
name|png_const_colorp
name|background
decl_stmt|;
comment|/* Local variables: */
DECL|member|local_row
name|png_voidp
name|local_row
decl_stmt|;
DECL|member|first_row
name|png_voidp
name|first_row
decl_stmt|;
DECL|member|row_bytes
name|ptrdiff_t
name|row_bytes
decl_stmt|;
comment|/* step between rows */
DECL|member|file_encoding
name|int
name|file_encoding
decl_stmt|;
comment|/* E_ values above */
DECL|member|gamma_to_linear
name|png_fixed_point
name|gamma_to_linear
decl_stmt|;
comment|/* For P_FILE, reciprocal of gamma */
DECL|member|colormap_processing
name|int
name|colormap_processing
decl_stmt|;
comment|/* PNG_CMAP_ values above */
block|}
DECL|typedef|png_image_read_control
name|png_image_read_control
typedef|;
end_typedef
begin_comment
comment|/* Do all the *safe* initialization - 'safe' means that png_error won't be  * called, so setting up the jmp_buf is not required.  This means that anything  * called from here must *not* call png_malloc - it has to call png_malloc_warn  * instead so that control is returned safely back to this routine.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_image_read_init
name|png_image_read_init
parameter_list|(
name|png_imagep
name|image
parameter_list|)
block|{
if|if
condition|(
name|image
operator|->
name|opaque
operator|==
name|NULL
condition|)
block|{
name|png_structp
name|png_ptr
init|=
name|png_create_read_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|image
argument_list|,
name|png_safe_error
argument_list|,
name|png_safe_warning
argument_list|)
decl_stmt|;
comment|/* And set the rest of the structure to NULL to ensure that the various        * fields are consistent.        */
name|memset
argument_list|(
name|image
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|image
operator|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|version
operator|=
name|PNG_IMAGE_VERSION
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_infop
name|info_ptr
init|=
name|png_create_info_struct
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_controlp
name|control
init|=
name|png_voidcast
argument_list|(
name|png_controlp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|control
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|control
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|control
operator|)
argument_list|)
expr_stmt|;
name|control
operator|->
name|png_ptr
operator|=
name|png_ptr
expr_stmt|;
name|control
operator|->
name|info_ptr
operator|=
name|info_ptr
expr_stmt|;
name|control
operator|->
name|for_write
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|opaque
operator|=
name|control
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Error clean up */
name|png_destroy_info_struct
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
argument_list|)
expr_stmt|;
block|}
name|png_destroy_read_struct
argument_list|(
operator|&
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_read: out of memory"
argument_list|)
return|;
block|}
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_read: opaque pointer not NULL"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Utility to find the base format of a PNG file from a png_struct. */
end_comment
begin_function
specifier|static
name|png_uint_32
DECL|function|png_image_format
name|png_image_format
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_uint_32
name|format
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
name|format
operator||=
name|PNG_FORMAT_FLAG_COLOR
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|format
operator||=
name|PNG_FORMAT_FLAG_ALPHA
expr_stmt|;
comment|/* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS     * sets the png_struct fields; that's all we are interested in here.  The     * precise interaction with an app call to png_set_tRNS and PNG file reading     * is unclear.     */
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
condition|)
name|format
operator||=
name|PNG_FORMAT_FLAG_ALPHA
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|16
condition|)
name|format
operator||=
name|PNG_FORMAT_FLAG_LINEAR
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_PALETTE
operator|)
operator|!=
literal|0
condition|)
name|format
operator||=
name|PNG_FORMAT_FLAG_COLORMAP
expr_stmt|;
return|return
name|format
return|;
block|}
end_function
begin_comment
comment|/* Is the given gamma significantly different from sRGB?  The test is the same  * one used in pngrtran.c when deciding whether to do gamma correction.  The  * arithmetic optimizes the division by using the fact that the inverse of the  * file sRGB gamma is 2.2  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_gamma_not_sRGB
name|png_gamma_not_sRGB
parameter_list|(
name|png_fixed_point
name|g
parameter_list|)
block|{
if|if
condition|(
name|g
operator|<
name|PNG_FP_1
condition|)
block|{
comment|/* An uninitialized gamma is assumed to be sRGB for the simplified API. */
if|if
condition|(
name|g
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|png_gamma_significant
argument_list|(
operator|(
name|g
operator|*
literal|11
operator|+
literal|2
operator|)
operator|/
literal|5
comment|/* i.e. *2.2, rounded */
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* Do the main body of a 'png_image_begin_read' function; read the PNG file  * header and fill in all the information.  This is executed in a safe context,  * unlike the init routine above.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_image_read_header
name|png_image_read_header
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_imagep
name|image
init|=
name|png_voidcast
argument_list|(
name|png_imagep
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|png_inforp
name|info_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|info_ptr
decl_stmt|;
name|png_set_benign_errors
argument_list|(
name|png_ptr
argument_list|,
literal|1
comment|/*warn*/
argument_list|)
expr_stmt|;
name|png_read_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Do this the fast way; just read directly out of png_struct. */
name|image
operator|->
name|width
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
name|image
operator|->
name|height
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
block|{
name|png_uint_32
name|format
init|=
name|png_image_format
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|image
operator|->
name|format
operator|=
name|format
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_COLORSPACE_SUPPORTED
comment|/* Does the colorspace match sRGB?  If there is no color endpoint        * (colorant) information assume yes, otherwise require the        * 'ENDPOINTS_MATCHP_sRGB' colorspace flag to have been set.  If the        * colorspace has been determined to be invalid ignore it.        */
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
operator|(
name|PNG_COLORSPACE_HAVE_ENDPOINTS
operator||
name|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB
operator||
name|PNG_COLORSPACE_INVALID
operator|)
operator|)
operator|==
name|PNG_COLORSPACE_HAVE_ENDPOINTS
operator|)
condition|)
name|image
operator|->
name|flags
operator||=
name|PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* We need the maximum number of entries regardless of the format the     * application sets here.     */
block|{
name|png_uint_32
name|cmap_entries
decl_stmt|;
switch|switch
condition|(
name|png_ptr
operator|->
name|color_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
name|cmap_entries
operator|=
literal|1U
operator|<<
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
name|cmap_entries
operator|=
name|png_ptr
operator|->
name|num_palette
expr_stmt|;
break|break;
default|default:
name|cmap_entries
operator|=
literal|256
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmap_entries
operator|>
literal|256
condition|)
name|cmap_entries
operator|=
literal|256
expr_stmt|;
name|image
operator|->
name|colormap_entries
operator|=
name|cmap_entries
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
end_ifdef
begin_function
name|int
name|PNGAPI
DECL|function|png_image_begin_read_from_stdio
name|png_image_begin_read_from_stdio
parameter_list|(
name|png_imagep
name|image
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|image
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|version
operator|==
name|PNG_IMAGE_VERSION
condition|)
block|{
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|png_image_read_init
argument_list|(
name|image
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This is slightly evil, but png_init_io doesn't do anything other              * than this and we haven't changed the standard IO functions so              * this saves a 'safe' function.              */
name|image
operator|->
name|opaque
operator|->
name|png_ptr
operator|->
name|io_ptr
operator|=
name|file
expr_stmt|;
return|return
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_header
argument_list|,
name|image
argument_list|)
return|;
block|}
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_begin_read_from_stdio: invalid argument"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_begin_read_from_stdio: incorrect PNG_IMAGE_VERSION"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
name|int
name|PNGAPI
DECL|function|png_image_begin_read_from_file
name|png_image_begin_read_from_file
parameter_list|(
name|png_imagep
name|image
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
if|if
condition|(
name|image
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|version
operator|==
name|PNG_IMAGE_VERSION
condition|)
block|{
if|if
condition|(
name|file_name
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|file_name
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|png_image_read_init
argument_list|(
name|image
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|image
operator|->
name|opaque
operator|->
name|png_ptr
operator|->
name|io_ptr
operator|=
name|fp
expr_stmt|;
name|image
operator|->
name|opaque
operator|->
name|owned_file
operator|=
literal|1
expr_stmt|;
return|return
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_header
argument_list|,
name|image
argument_list|)
return|;
block|}
comment|/* Clean up: just the opened file. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_begin_read_from_file: invalid argument"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_begin_read_from_file: incorrect PNG_IMAGE_VERSION"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* STDIO */
end_comment
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|png_image_memory_read
name|png_image_memory_read
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|out
parameter_list|,
name|png_size_t
name|need
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_imagep
name|image
init|=
name|png_voidcast
argument_list|(
name|png_imagep
argument_list|,
name|png_ptr
operator|->
name|io_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
block|{
name|png_controlp
name|cp
init|=
name|image
operator|->
name|opaque
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|png_const_bytep
name|memory
init|=
name|cp
operator|->
name|memory
decl_stmt|;
name|png_size_t
name|size
init|=
name|cp
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|memory
operator|!=
name|NULL
operator|&&
name|size
operator|>=
name|need
condition|)
block|{
name|memcpy
argument_list|(
name|out
argument_list|,
name|memory
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|cp
operator|->
name|memory
operator|=
name|memory
operator|+
name|need
expr_stmt|;
name|cp
operator|->
name|size
operator|=
name|size
operator|-
name|need
expr_stmt|;
return|return;
block|}
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"read beyond end of data"
argument_list|)
expr_stmt|;
block|}
block|}
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid memory read"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|png_image_begin_read_from_memory
name|int
name|PNGAPI
name|png_image_begin_read_from_memory
parameter_list|(
name|png_imagep
name|image
parameter_list|,
name|png_const_voidp
name|memory
parameter_list|,
name|png_size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|image
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|version
operator|==
name|PNG_IMAGE_VERSION
condition|)
block|{
if|if
condition|(
name|memory
operator|!=
name|NULL
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|png_image_read_init
argument_list|(
name|image
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Now set the IO functions to read from the memory buffer and              * store it into io_ptr.  Again do this in-place to avoid calling a              * libpng function that requires error handling.              */
name|image
operator|->
name|opaque
operator|->
name|memory
operator|=
name|png_voidcast
argument_list|(
name|png_const_bytep
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|image
operator|->
name|opaque
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|image
operator|->
name|opaque
operator|->
name|png_ptr
operator|->
name|io_ptr
operator|=
name|image
expr_stmt|;
name|image
operator|->
name|opaque
operator|->
name|png_ptr
operator|->
name|read_data_fn
operator|=
name|png_image_memory_read
expr_stmt|;
return|return
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_header
argument_list|,
name|image
argument_list|)
return|;
block|}
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_begin_read_from_memory: invalid argument"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Utility function to skip chunks that are not used by the simplified image  * read functions and an appropriate macro to call it.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
end_ifdef
begin_function
specifier|static
name|void
DECL|function|png_image_skip_unused_chunks
name|png_image_skip_unused_chunks
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Prepare the reader to ignore all recognized chunks whose data will not     * be used, i.e., all chunks recognized by libpng except for those     * involved in basic image reading:     *     *    IHDR, PLTE, IDAT, IEND     *     * Or image data handling:     *     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.     *     * This provides a small performance improvement and eliminates any     * potential vulnerability to security problems in the unused chunks.     *     * At present the iCCP chunk data isn't used, so iCCP chunk can be ignored     * too.  This allows the simplified API to be compiled without iCCP support,     * however if the support is there the chunk is still checked to detect     * errors (which are unfortunately quite common.)     */
block|{
specifier|static
name|PNG_CONST
name|png_byte
name|chunks_to_process
index|[]
init|=
block|{
literal|98
block|,
literal|75
block|,
literal|71
block|,
literal|68
block|,
literal|'\0'
block|,
comment|/* bKGD */
literal|99
block|,
literal|72
block|,
literal|82
block|,
literal|77
block|,
literal|'\0'
block|,
comment|/* cHRM */
literal|103
block|,
literal|65
block|,
literal|77
block|,
literal|65
block|,
literal|'\0'
block|,
comment|/* gAMA */
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
literal|105
block|,
literal|67
block|,
literal|67
block|,
literal|80
block|,
literal|'\0'
block|,
comment|/* iCCP */
endif|#
directive|endif
literal|115
block|,
literal|66
block|,
literal|73
block|,
literal|84
block|,
literal|'\0'
block|,
comment|/* sBIT */
literal|115
block|,
literal|82
block|,
literal|71
block|,
literal|66
block|,
literal|'\0'
block|,
comment|/* sRGB */
block|}
decl_stmt|;
comment|/* Ignore unknown chunks and all other chunks except for the         * IHDR, PLTE, tRNS, IDAT, and IEND chunks.         */
name|png_set_keep_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|PNG_HANDLE_CHUNK_NEVER
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* But do not ignore image data handling chunks */
name|png_set_keep_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|PNG_HANDLE_CHUNK_AS_DEFAULT
argument_list|,
name|chunks_to_process
argument_list|,
call|(
name|int
call|)
comment|/*SAFE*/
argument_list|(
sizeof|sizeof
name|chunks_to_process
argument_list|)
operator|/
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_define
DECL|macro|PNG_SKIP_CHUNKS
define|#
directive|define
name|PNG_SKIP_CHUNKS
parameter_list|(
name|p
parameter_list|)
value|png_image_skip_unused_chunks(p)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PNG_SKIP_CHUNKS
define|#
directive|define
name|PNG_SKIP_CHUNKS
parameter_list|(
name|p
parameter_list|)
value|((void)0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HANDLE_AS_UNKNOWN */
end_comment
begin_comment
comment|/* The following macro gives the exact rounded answer for all values in the  * range 0..255 (it actually divides by 51.2, but the rounding still generates  * the correct numbers 0..5  */
end_comment
begin_define
DECL|macro|PNG_DIV51
define|#
directive|define
name|PNG_DIV51
parameter_list|(
name|v8
parameter_list|)
value|(((v8) * 5 + 130)>> 8)
end_define
begin_comment
comment|/* Utility functions to make particular color-maps */
end_comment
begin_function
specifier|static
name|void
DECL|function|set_file_encoding
name|set_file_encoding
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|)
block|{
name|png_fixed_point
name|g
init|=
name|display
operator|->
name|image
operator|->
name|opaque
operator|->
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
decl_stmt|;
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|g
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_gamma_not_sRGB
argument_list|(
name|g
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|display
operator|->
name|file_encoding
operator|=
name|P_FILE
expr_stmt|;
name|display
operator|->
name|gamma_to_linear
operator|=
name|png_reciprocal
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
name|display
operator|->
name|file_encoding
operator|=
name|P_sRGB
expr_stmt|;
block|}
else|else
name|display
operator|->
name|file_encoding
operator|=
name|P_LINEAR8
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|unsigned
name|int
DECL|function|decode_gamma
name|decode_gamma
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|,
name|png_uint_32
name|value
parameter_list|,
name|int
name|encoding
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|==
name|P_FILE
condition|)
comment|/* double check */
name|encoding
operator|=
name|display
operator|->
name|file_encoding
expr_stmt|;
if|if
condition|(
name|encoding
operator|==
name|P_NOTSET
condition|)
comment|/* must be the file encoding */
block|{
name|set_file_encoding
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|display
operator|->
name|file_encoding
expr_stmt|;
block|}
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|P_FILE
case|:
name|value
operator|=
name|png_gamma_16bit_correct
argument_list|(
name|value
operator|*
literal|257
argument_list|,
name|display
operator|->
name|gamma_to_linear
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_sRGB
case|:
name|value
operator|=
name|png_sRGB_table
index|[
name|value
index|]
expr_stmt|;
break|break;
case|case
name|P_LINEAR
case|:
break|break;
case|case
name|P_LINEAR8
case|:
name|value
operator|*=
literal|257
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|__GNUC__
default|default:
name|png_error
argument_list|(
name|display
operator|->
name|image
operator|->
name|opaque
operator|->
name|png_ptr
argument_list|,
literal|"unexpected encoding (internal error)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|value
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|png_colormap_compose
name|png_colormap_compose
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|,
name|png_uint_32
name|foreground
parameter_list|,
name|int
name|foreground_encoding
parameter_list|,
name|png_uint_32
name|alpha
parameter_list|,
name|png_uint_32
name|background
parameter_list|,
name|int
name|encoding
parameter_list|)
block|{
comment|/* The file value is composed on the background, the background has the given     * encoding and so does the result, the file is encoded with P_FILE and the     * file and alpha are 8-bit values.  The (output) encoding will always be     * P_LINEAR or P_sRGB.     */
name|png_uint_32
name|f
init|=
name|decode_gamma
argument_list|(
name|display
argument_list|,
name|foreground
argument_list|,
name|foreground_encoding
argument_list|)
decl_stmt|;
name|png_uint_32
name|b
init|=
name|decode_gamma
argument_list|(
name|display
argument_list|,
name|background
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
comment|/* The alpha is always an 8-bit value (it comes from the palette), the value     * scaled by 255 is what PNG_sRGB_FROM_LINEAR requires.     */
name|f
operator|=
name|f
operator|*
name|alpha
operator|+
name|b
operator|*
operator|(
literal|255
operator|-
name|alpha
operator|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|==
name|P_LINEAR
condition|)
block|{
comment|/* Scale to 65535; divide by 255, approximately (in fact this is extremely        * accurate, it divides by 255.00000005937181414556, with no overflow.)        */
name|f
operator|*=
literal|257
expr_stmt|;
comment|/* Now scaled by 65535 */
name|f
operator|+=
name|f
operator|>>
literal|16
expr_stmt|;
name|f
operator|=
operator|(
name|f
operator|+
literal|32768
operator|)
operator|>>
literal|16
expr_stmt|;
block|}
else|else
comment|/* P_sRGB */
name|f
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function
begin_comment
comment|/* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must  * be 8-bit.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_create_colormap_entry
name|png_create_colormap_entry
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|,
name|png_uint_32
name|ip
parameter_list|,
name|png_uint_32
name|red
parameter_list|,
name|png_uint_32
name|green
parameter_list|,
name|png_uint_32
name|blue
parameter_list|,
name|png_uint_32
name|alpha
parameter_list|,
name|int
name|encoding
parameter_list|)
block|{
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
specifier|const
name|int
name|output_encoding
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
operator|!=
literal|0
condition|?
name|P_LINEAR
else|:
name|P_sRGB
decl_stmt|;
specifier|const
name|int
name|convert_to_Y
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|red
operator|!=
name|green
operator|||
name|green
operator|!=
name|blue
operator|)
decl_stmt|;
if|if
condition|(
name|ip
operator|>
literal|255
condition|)
name|png_error
argument_list|(
name|image
operator|->
name|opaque
operator|->
name|png_ptr
argument_list|,
literal|"color-map index out of range"
argument_list|)
expr_stmt|;
comment|/* Update the cache with whether the file gamma is significantly different     * from sRGB.     */
if|if
condition|(
name|encoding
operator|==
name|P_FILE
condition|)
block|{
if|if
condition|(
name|display
operator|->
name|file_encoding
operator|==
name|P_NOTSET
condition|)
name|set_file_encoding
argument_list|(
name|display
argument_list|)
expr_stmt|;
comment|/* Note that the cached value may be P_FILE too, but if it is then the        * gamma_to_linear member has been set.        */
name|encoding
operator|=
name|display
operator|->
name|file_encoding
expr_stmt|;
block|}
if|if
condition|(
name|encoding
operator|==
name|P_FILE
condition|)
block|{
name|png_fixed_point
name|g
init|=
name|display
operator|->
name|gamma_to_linear
decl_stmt|;
name|red
operator|=
name|png_gamma_16bit_correct
argument_list|(
name|red
operator|*
literal|257
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|green
operator|=
name|png_gamma_16bit_correct
argument_list|(
name|green
operator|*
literal|257
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|blue
operator|=
name|png_gamma_16bit_correct
argument_list|(
name|blue
operator|*
literal|257
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_to_Y
operator|!=
literal|0
operator|||
name|output_encoding
operator|==
name|P_LINEAR
condition|)
block|{
name|alpha
operator|*=
literal|257
expr_stmt|;
name|encoding
operator|=
name|P_LINEAR
expr_stmt|;
block|}
else|else
block|{
name|red
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|red
operator|*
literal|255
argument_list|)
expr_stmt|;
name|green
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|green
operator|*
literal|255
argument_list|)
expr_stmt|;
name|blue
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|blue
operator|*
literal|255
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|P_sRGB
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|encoding
operator|==
name|P_LINEAR8
condition|)
block|{
comment|/* This encoding occurs quite frequently in test cases because PngSuite        * includes a gAMA 1.0 chunk with most images.        */
name|red
operator|*=
literal|257
expr_stmt|;
name|green
operator|*=
literal|257
expr_stmt|;
name|blue
operator|*=
literal|257
expr_stmt|;
name|alpha
operator|*=
literal|257
expr_stmt|;
name|encoding
operator|=
name|P_LINEAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|==
name|P_sRGB
operator|&&
operator|(
name|convert_to_Y
operator|!=
literal|0
operator|||
name|output_encoding
operator|==
name|P_LINEAR
operator|)
condition|)
block|{
comment|/* The values are 8-bit sRGB values, but must be converted to 16-bit        * linear.        */
name|red
operator|=
name|png_sRGB_table
index|[
name|red
index|]
expr_stmt|;
name|green
operator|=
name|png_sRGB_table
index|[
name|green
index|]
expr_stmt|;
name|blue
operator|=
name|png_sRGB_table
index|[
name|blue
index|]
expr_stmt|;
name|alpha
operator|*=
literal|257
expr_stmt|;
name|encoding
operator|=
name|P_LINEAR
expr_stmt|;
block|}
comment|/* This is set if the color isn't gray but the output is. */
if|if
condition|(
name|encoding
operator|==
name|P_LINEAR
condition|)
block|{
if|if
condition|(
name|convert_to_Y
operator|!=
literal|0
condition|)
block|{
comment|/* NOTE: these values are copied from png_do_rgb_to_gray */
name|png_uint_32
name|y
init|=
operator|(
name|png_uint_32
operator|)
literal|6968
operator|*
name|red
operator|+
operator|(
name|png_uint_32
operator|)
literal|23434
operator|*
name|green
operator|+
operator|(
name|png_uint_32
operator|)
literal|2366
operator|*
name|blue
decl_stmt|;
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
name|y
operator|=
operator|(
name|y
operator|+
literal|16384
operator|)
operator|>>
literal|15
expr_stmt|;
else|else
block|{
comment|/* y is scaled by 32768, we need it scaled by 255: */
name|y
operator|=
operator|(
name|y
operator|+
literal|128
operator|)
operator|>>
literal|8
expr_stmt|;
name|y
operator|*=
literal|255
expr_stmt|;
name|y
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
operator|(
name|y
operator|+
literal|64
operator|)
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|PNG_DIV257
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|P_sRGB
expr_stmt|;
block|}
name|blue
operator|=
name|red
operator|=
name|green
operator|=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_encoding
operator|==
name|P_sRGB
condition|)
block|{
name|red
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|red
operator|*
literal|255
argument_list|)
expr_stmt|;
name|green
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|green
operator|*
literal|255
argument_list|)
expr_stmt|;
name|blue
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|blue
operator|*
literal|255
argument_list|)
expr_stmt|;
name|alpha
operator|=
name|PNG_DIV257
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|P_sRGB
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encoding
operator|!=
name|output_encoding
condition|)
name|png_error
argument_list|(
name|image
operator|->
name|opaque
operator|->
name|png_ptr
argument_list|,
literal|"bad encoding (internal error)"
argument_list|)
expr_stmt|;
comment|/* Store the value. */
block|{
ifdef|#
directive|ifdef
name|PNG_FORMAT_AFIRST_SUPPORTED
specifier|const
name|int
name|afirst
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|afirst
value|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_FORMAT_BGR_SUPPORTED
specifier|const
name|int
name|bgr
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_BGR
operator|)
operator|!=
literal|0
condition|?
literal|2
else|:
literal|0
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|bgr
value|0
endif|#
directive|endif
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
block|{
name|png_uint_16p
name|entry
init|=
name|png_voidcast
argument_list|(
name|png_uint_16p
argument_list|,
name|display
operator|->
name|colormap
argument_list|)
decl_stmt|;
name|entry
operator|+=
name|ip
operator|*
name|PNG_IMAGE_SAMPLE_CHANNELS
argument_list|(
name|image
operator|->
name|format
argument_list|)
expr_stmt|;
comment|/* The linear 16-bit values must be pre-multiplied by the alpha channel           * value, if less than 65535 (this is, effectively, composite on black           * if the alpha channel is removed.)           */
switch|switch
condition|(
name|PNG_IMAGE_SAMPLE_CHANNELS
argument_list|(
name|image
operator|->
name|format
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|entry
index|[
name|afirst
condition|?
literal|0
else|:
literal|3
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|alpha
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|3
case|:
if|if
condition|(
name|alpha
operator|<
literal|65535
condition|)
block|{
if|if
condition|(
name|alpha
operator|>
literal|0
condition|)
block|{
name|blue
operator|=
operator|(
name|blue
operator|*
name|alpha
operator|+
literal|32767U
operator|)
operator|/
literal|65535U
expr_stmt|;
name|green
operator|=
operator|(
name|green
operator|*
name|alpha
operator|+
literal|32767U
operator|)
operator|/
literal|65535U
expr_stmt|;
name|red
operator|=
operator|(
name|red
operator|*
name|alpha
operator|+
literal|32767U
operator|)
operator|/
literal|65535U
expr_stmt|;
block|}
else|else
name|red
operator|=
name|green
operator|=
name|blue
operator|=
literal|0
expr_stmt|;
block|}
name|entry
index|[
name|afirst
operator|+
operator|(
literal|2
operator|^
name|bgr
operator|)
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|blue
expr_stmt|;
name|entry
index|[
name|afirst
operator|+
literal|1
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|green
expr_stmt|;
name|entry
index|[
name|afirst
operator|+
name|bgr
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|red
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|entry
index|[
literal|1
operator|^
name|afirst
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|alpha
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|1
case|:
if|if
condition|(
name|alpha
operator|<
literal|65535
condition|)
block|{
if|if
condition|(
name|alpha
operator|>
literal|0
condition|)
name|green
operator|=
operator|(
name|green
operator|*
name|alpha
operator|+
literal|32767U
operator|)
operator|/
literal|65535U
expr_stmt|;
else|else
name|green
operator|=
literal|0
expr_stmt|;
block|}
name|entry
index|[
name|afirst
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|green
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
comment|/* output encoding is P_sRGB */
block|{
name|png_bytep
name|entry
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|colormap
argument_list|)
decl_stmt|;
name|entry
operator|+=
name|ip
operator|*
name|PNG_IMAGE_SAMPLE_CHANNELS
argument_list|(
name|image
operator|->
name|format
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|PNG_IMAGE_SAMPLE_CHANNELS
argument_list|(
name|image
operator|->
name|format
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|entry
index|[
name|afirst
condition|?
literal|0
else|:
literal|3
index|]
operator|=
operator|(
name|png_byte
operator|)
name|alpha
expr_stmt|;
case|case
literal|3
case|:
name|entry
index|[
name|afirst
operator|+
operator|(
literal|2
operator|^
name|bgr
operator|)
index|]
operator|=
operator|(
name|png_byte
operator|)
name|blue
expr_stmt|;
name|entry
index|[
name|afirst
operator|+
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|green
expr_stmt|;
name|entry
index|[
name|afirst
operator|+
name|bgr
index|]
operator|=
operator|(
name|png_byte
operator|)
name|red
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|entry
index|[
literal|1
operator|^
name|afirst
index|]
operator|=
operator|(
name|png_byte
operator|)
name|alpha
expr_stmt|;
case|case
literal|1
case|:
name|entry
index|[
name|afirst
index|]
operator|=
operator|(
name|png_byte
operator|)
name|green
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|afirst
DECL|macro|afirst
undef|#
directive|undef
name|afirst
endif|#
directive|endif
ifdef|#
directive|ifdef
name|bgr
DECL|macro|bgr
undef|#
directive|undef
name|bgr
endif|#
directive|endif
block|}
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|make_gray_file_colormap
name|make_gray_file_colormap
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|255
argument_list|,
name|P_FILE
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|make_gray_colormap
name|make_gray_colormap
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|255
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_define
DECL|macro|PNG_GRAY_COLORMAP_ENTRIES
define|#
directive|define
name|PNG_GRAY_COLORMAP_ENTRIES
value|256
end_define
begin_function
specifier|static
name|int
DECL|function|make_ga_colormap
name|make_ga_colormap
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|a
decl_stmt|;
comment|/* Alpha is retained, the output will be a color-map with entries     * selected by six levels of alpha.  One transparent entry, 6 gray     * levels for all the intermediate alpha values, leaving 230 entries     * for the opaque grays.  The color-map entries are the six values     * [0..5]*51, the GA processing uses PNG_DIV51(value) to find the     * relevant entry.     *     * if (alpha> 229) // opaque     * {     *    // The 231 entries are selected to make the math below work:     *    base = 0;     *    entry = (231 * gray + 128)>> 8;     * }     * else if (alpha< 26) // transparent     * {     *    base = 231;     *    entry = 0;     * }     * else // partially opaque     * {     *    base = 226 + 6 * PNG_DIV51(alpha);     *    entry = PNG_DIV51(gray);     * }     */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|231
condition|)
block|{
name|unsigned
name|int
name|gray
init|=
operator|(
name|i
operator|*
literal|256
operator|+
literal|115
operator|)
operator|/
literal|231
decl_stmt|;
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
operator|++
argument_list|,
name|gray
argument_list|,
name|gray
argument_list|,
name|gray
argument_list|,
literal|255
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
block|}
comment|/* 255 is used here for the component values for consistency with the code     * that undoes premultiplication in pngwrite.c.     */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
operator|++
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|1
init|;
name|a
operator|<
literal|5
condition|;
operator|++
name|a
control|)
block|{
name|unsigned
name|int
name|g
decl_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
literal|6
condition|;
operator|++
name|g
control|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
operator|++
argument_list|,
name|g
operator|*
literal|51
argument_list|,
name|g
operator|*
literal|51
argument_list|,
name|g
operator|*
literal|51
argument_list|,
name|a
operator|*
literal|51
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function
begin_define
DECL|macro|PNG_GA_COLORMAP_ENTRIES
define|#
directive|define
name|PNG_GA_COLORMAP_ENTRIES
value|256
end_define
begin_function
specifier|static
name|int
DECL|function|make_rgb_colormap
name|make_rgb_colormap
parameter_list|(
name|png_image_read_control
modifier|*
name|display
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
comment|/* Build a 6x6x6 opaque RGB cube */
for|for
control|(
name|i
operator|=
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|6
condition|;
operator|++
name|r
control|)
block|{
name|unsigned
name|int
name|g
decl_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
literal|6
condition|;
operator|++
name|g
control|)
block|{
name|unsigned
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|6
condition|;
operator|++
name|b
control|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
operator|++
argument_list|,
name|r
operator|*
literal|51
argument_list|,
name|g
operator|*
literal|51
argument_list|,
name|b
operator|*
literal|51
argument_list|,
literal|255
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function
begin_define
DECL|macro|PNG_RGB_COLORMAP_ENTRIES
define|#
directive|define
name|PNG_RGB_COLORMAP_ENTRIES
value|216
end_define
begin_comment
comment|/* Return a palette index to the above palette given three 8-bit sRGB values. */
end_comment
begin_define
DECL|macro|PNG_RGB_INDEX
define|#
directive|define
name|PNG_RGB_INDEX
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
define|\
value|((png_byte)(6 * (6 * PNG_DIV51(r) + PNG_DIV51(g)) + PNG_DIV51(b)))
end_define
begin_function
specifier|static
name|int
DECL|function|png_image_read_colormap
name|png_image_read_colormap
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_read_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_read_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
specifier|const
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
specifier|const
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
specifier|const
name|png_uint_32
name|output_format
init|=
name|image
operator|->
name|format
decl_stmt|;
specifier|const
name|int
name|output_encoding
init|=
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
operator|!=
literal|0
condition|?
name|P_LINEAR
else|:
name|P_sRGB
decl_stmt|;
name|unsigned
name|int
name|cmap_entries
decl_stmt|;
name|unsigned
name|int
name|output_processing
decl_stmt|;
comment|/* Output processing option */
name|unsigned
name|int
name|data_encoding
init|=
name|P_NOTSET
decl_stmt|;
comment|/* Encoding libpng must produce */
comment|/* Background information; the background color and the index of this color     * in the color-map if it exists (else 256).     */
name|unsigned
name|int
name|background_index
init|=
literal|256
decl_stmt|;
name|png_uint_32
name|back_r
decl_stmt|,
name|back_g
decl_stmt|,
name|back_b
decl_stmt|;
comment|/* Flags to accumulate things that need to be done to the input. */
name|int
name|expand_tRNS
init|=
literal|0
decl_stmt|;
comment|/* Exclude the NYI feature of compositing onto a color-mapped buffer; it is     * very difficult to do, the results look awful, and it is difficult to see     * what possible use it is because the application can't control the     * color-map.     */
if|if
condition|(
operator|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
operator|||
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
operator|)
comment|/* alpha in input */
operator|&&
operator|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|==
literal|0
operator|)
comment|/* no alpha in output */
condition|)
block|{
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
comment|/* compose on black */
name|back_b
operator|=
name|back_g
operator|=
name|back_r
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|display
operator|->
name|background
operator|==
name|NULL
comment|/* no way to remove it */
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"a background color must be supplied to remove alpha/transparency"
argument_list|)
expr_stmt|;
comment|/* Get a copy of the background color (this avoids repeating the checks        * below.)  The encoding is 8-bit sRGB or 16-bit linear, depending on the        * output format.        */
else|else
block|{
name|back_g
operator|=
name|display
operator|->
name|background
operator|->
name|green
expr_stmt|;
if|if
condition|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|back_r
operator|=
name|display
operator|->
name|background
operator|->
name|red
expr_stmt|;
name|back_b
operator|=
name|display
operator|->
name|background
operator|->
name|blue
expr_stmt|;
block|}
else|else
name|back_b
operator|=
name|back_r
operator|=
name|back_g
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
name|back_b
operator|=
name|back_r
operator|=
name|back_g
operator|=
literal|65535
expr_stmt|;
else|else
name|back_b
operator|=
name|back_r
operator|=
name|back_g
operator|=
literal|255
expr_stmt|;
comment|/* Default the input file gamma if required - this is necessary because     * libpng assumes that if no gamma information is present the data is in the     * output format, but the simplified API deduces the gamma from the input     * format.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_GAMMA
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Do this directly, not using the png_colorspace functions, to ensure        * that it happens even if the colorspace is invalid (though probably if        * it is the setting will be ignored)  Note that the same thing can be        * achieved at the application interface with png_set_gAMA.        */
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|16
operator|&&
operator|(
name|image
operator|->
name|flags
operator|&
name|PNG_IMAGE_FLAG_16BIT_sRGB
operator|)
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|=
name|PNG_GAMMA_LINEAR
expr_stmt|;
else|else
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|=
name|PNG_GAMMA_sRGB_INVERSE
expr_stmt|;
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_HAVE_GAMMA
expr_stmt|;
block|}
comment|/* Decide what to do based on the PNG color type of the input data.  The     * utility function png_create_colormap_entry deals with most aspects of the     * output transformations; this code works out how to produce bytes of     * color-map entries from the original format.     */
switch|switch
condition|(
name|png_ptr
operator|->
name|color_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|<=
literal|8
condition|)
block|{
comment|/* There at most 256 colors in the output, regardless of              * transparency.              */
name|unsigned
name|int
name|step
decl_stmt|,
name|i
decl_stmt|,
name|val
decl_stmt|,
name|trans
init|=
literal|256
comment|/*ignore*/
decl_stmt|,
name|back_alpha
init|=
literal|0
decl_stmt|;
name|cmap_entries
operator|=
literal|1U
operator|<<
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
if|if
condition|(
name|cmap_entries
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"gray[8] color-map: too few entries"
argument_list|)
expr_stmt|;
name|step
operator|=
literal|255
operator|/
operator|(
name|cmap_entries
operator|-
literal|1
operator|)
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_NONE
expr_stmt|;
comment|/* If there is a tRNS chunk then this either selects a transparent              * value or, if the output has no alpha, the background color.              */
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
condition|)
block|{
name|trans
operator|=
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
expr_stmt|;
if|if
condition|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|==
literal|0
condition|)
name|back_alpha
operator|=
name|output_encoding
operator|==
name|P_LINEAR
condition|?
literal|65535
else|:
literal|255
expr_stmt|;
block|}
comment|/* png_create_colormap_entry just takes an RGBA and writes the              * corresponding color-map entry using the format from 'image',              * including the required conversion to sRGB or linear as              * appropriate.  The input values are always either sRGB (if the              * gamma correction flag is 0) or 0..255 scaled file encoded values              * (if the function must gamma correct them).              */
for|for
control|(
name|i
operator|=
name|val
operator|=
literal|0
init|;
name|i
operator|<
name|cmap_entries
condition|;
operator|++
name|i
operator|,
name|val
operator|+=
name|step
control|)
block|{
comment|/* 'i' is a file value.  While this will result in duplicated                 * entries for 8-bit non-sRGB encoded files it is necessary to                 * have non-gamma corrected values to do tRNS handling.                 */
if|if
condition|(
name|i
operator|!=
name|trans
condition|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
argument_list|,
name|val
argument_list|,
name|val
argument_list|,
name|val
argument_list|,
literal|255
argument_list|,
name|P_FILE
comment|/*8-bit with file gamma*/
argument_list|)
expr_stmt|;
comment|/* Else this entry is transparent.  The colors don't matter if                 * there is an alpha channel (back_alpha == 0), but it does no                 * harm to pass them in; the values are not set above so this                 * passes in white.                 *                 * NOTE: this preserves the full precision of the application                 * supplied background color when it is used.                 */
else|else
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
argument_list|,
name|back_r
argument_list|,
name|back_g
argument_list|,
name|back_b
argument_list|,
name|back_alpha
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
block|}
comment|/* We need libpng to preserve the original encoding. */
name|data_encoding
operator|=
name|P_FILE
expr_stmt|;
comment|/* The rows from libpng, while technically gray values, are now also              * color-map indices; however, they may need to be expanded to 1              * byte per pixel.  This is what png_set_packing does (i.e., it              * unpacks the bit values into bytes.)              */
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|png_set_packing
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* bit depth is 16 */
block|{
comment|/* The 16-bit input values can be converted directly to 8-bit gamma              * encoded values; however, if a tRNS chunk is present 257 color-map              * entries are required.  This means that the extra entry requires              * special processing; add an alpha channel, sacrifice gray level              * 254 and convert transparent (alpha==0) entries to that.              *              * Use libpng to chop the data to 8 bits.  Convert it to sRGB at the              * same time to minimize quality loss.  If a tRNS chunk is present              * this means libpng must handle it too; otherwise it is impossible              * to do the exact match on the 16-bit value.              *              * If the output has no alpha channel *and* the background color is              * gray then it is possible to let libpng handle the substitution by              * ensuring that the corresponding gray level matches the background              * color exactly.              */
name|data_encoding
operator|=
name|P_sRGB
expr_stmt|;
if|if
condition|(
name|PNG_GRAY_COLORMAP_ENTRIES
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"gray[16] color-map: too few entries"
argument_list|)
expr_stmt|;
name|cmap_entries
operator|=
name|make_gray_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|back_alpha
decl_stmt|;
if|if
condition|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|back_alpha
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|back_r
operator|==
name|back_g
operator|&&
name|back_g
operator|==
name|back_b
condition|)
block|{
comment|/* Background is gray; no special processing will be                       * required.                       */
name|png_color_16
name|c
decl_stmt|;
name|png_uint_32
name|gray
init|=
name|back_g
decl_stmt|;
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
block|{
name|gray
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|gray
operator|*
literal|255
argument_list|)
expr_stmt|;
comment|/* And make sure the corresponding palette entry                          * matches.                          */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|gray
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
literal|65535
argument_list|,
name|P_LINEAR
argument_list|)
expr_stmt|;
block|}
comment|/* The background passed to libpng, however, must be the                       * sRGB value.                       */
name|c
operator|.
name|index
operator|=
literal|0
expr_stmt|;
comment|/*unused*/
name|c
operator|.
name|gray
operator|=
name|c
operator|.
name|red
operator|=
name|c
operator|.
name|green
operator|=
name|c
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|gray
expr_stmt|;
comment|/* NOTE: does this work without expanding tRNS to alpha?                       * It should be the color->gray case below apparently                       * doesn't.                       */
name|png_set_background_fixed
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|c
argument_list|,
name|PNG_BACKGROUND_GAMMA_SCREEN
argument_list|,
literal|0
comment|/*need_expand*/
argument_list|,
literal|0
comment|/*gamma: not used*/
argument_list|)
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_NONE
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__COVERITY__
comment|/* Coverity claims that output_encoding cannot be 2 (P_LINEAR)                   * here.                   */
name|back_alpha
operator|=
literal|255
expr_stmt|;
else|#
directive|else
name|back_alpha
operator|=
name|output_encoding
operator|==
name|P_LINEAR
condition|?
literal|65535
else|:
literal|255
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* output_processing means that the libpng-processed row will be                 * 8-bit GA and it has to be processing to single byte color-map                 * values.  Entry 254 is replaced by either a completely                 * transparent entry or by the background color at full                 * precision (and the background color is not a simple gray                 * level in this case.)                 */
name|expand_tRNS
operator|=
literal|1
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_TRANS
expr_stmt|;
name|background_index
operator|=
literal|254
expr_stmt|;
comment|/* And set (overwrite) color-map entry 254 to the actual                 * background color at full precision.                 */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
literal|254
argument_list|,
name|back_r
argument_list|,
name|back_g
argument_list|,
name|back_b
argument_list|,
name|back_alpha
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
block|}
else|else
name|output_processing
operator|=
name|PNG_CMAP_NONE
expr_stmt|;
block|}
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
comment|/* 8-bit or 16-bit PNG with two channels - gray and alpha.  A minimum           * of 65536 combinations.  If, however, the alpha channel is to be           * removed there are only 256 possibilities if the background is gray.           * (Otherwise there is a subset of the 65536 possibilities defined by           * the triangle between black, white and the background color.)           *           * Reduce 16-bit files to 8-bit and sRGB encode the result.  No need to           * worry about tRNS matching - tRNS is ignored if there is an alpha           * channel.           */
name|data_encoding
operator|=
name|P_sRGB
expr_stmt|;
if|if
condition|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|PNG_GA_COLORMAP_ENTRIES
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"gray+alpha color-map: too few entries"
argument_list|)
expr_stmt|;
name|cmap_entries
operator|=
name|make_ga_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|background_index
operator|=
name|PNG_CMAP_GA_BACKGROUND
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_GA
expr_stmt|;
block|}
else|else
comment|/* alpha is removed */
block|{
comment|/* Alpha must be removed as the PNG data is processed when the              * background is a color because the G and A channels are              * independent and the vector addition (non-parallel vectors) is a              * 2-D problem.              *              * This can be reduced to the same algorithm as above by making a              * colormap containing gray levels (for the opaque grays), a              * background entry (for a transparent pixel) and a set of four six              * level color values, one set for each intermediate alpha value.              * See the comments in make_ga_colormap for how this works in the              * per-pixel processing.              *              * If the background is gray, however, we only need a 256 entry gray              * level color map.  It is sufficient to make the entry generated              * for the background color be exactly the color specified.              */
if|if
condition|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|==
literal|0
operator|||
operator|(
name|back_r
operator|==
name|back_g
operator|&&
name|back_g
operator|==
name|back_b
operator|)
condition|)
block|{
comment|/* Background is gray; no special processing will be required. */
name|png_color_16
name|c
decl_stmt|;
name|png_uint_32
name|gray
init|=
name|back_g
decl_stmt|;
if|if
condition|(
name|PNG_GRAY_COLORMAP_ENTRIES
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"gray-alpha color-map: too few entries"
argument_list|)
expr_stmt|;
name|cmap_entries
operator|=
name|make_gray_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
block|{
name|gray
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|gray
operator|*
literal|255
argument_list|)
expr_stmt|;
comment|/* And make sure the corresponding palette entry matches. */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|gray
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
literal|65535
argument_list|,
name|P_LINEAR
argument_list|)
expr_stmt|;
block|}
comment|/* The background passed to libpng, however, must be the sRGB                 * value.                 */
name|c
operator|.
name|index
operator|=
literal|0
expr_stmt|;
comment|/*unused*/
name|c
operator|.
name|gray
operator|=
name|c
operator|.
name|red
operator|=
name|c
operator|.
name|green
operator|=
name|c
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|gray
expr_stmt|;
name|png_set_background_fixed
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|c
argument_list|,
name|PNG_BACKGROUND_GAMMA_SCREEN
argument_list|,
literal|0
comment|/*need_expand*/
argument_list|,
literal|0
comment|/*gamma: not used*/
argument_list|)
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_NONE
expr_stmt|;
block|}
else|else
block|{
name|png_uint_32
name|i
decl_stmt|,
name|a
decl_stmt|;
comment|/* This is the same as png_make_ga_colormap, above, except that                 * the entries are all opaque.                 */
if|if
condition|(
name|PNG_GA_COLORMAP_ENTRIES
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ga-alpha color-map: too few entries"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|231
condition|)
block|{
name|png_uint_32
name|gray
init|=
operator|(
name|i
operator|*
literal|256
operator|+
literal|115
operator|)
operator|/
literal|231
decl_stmt|;
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
operator|++
argument_list|,
name|gray
argument_list|,
name|gray
argument_list|,
name|gray
argument_list|,
literal|255
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
block|}
comment|/* NOTE: this preserves the full precision of the application                 * background color.                 */
name|background_index
operator|=
name|i
expr_stmt|;
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
operator|++
argument_list|,
name|back_r
argument_list|,
name|back_g
argument_list|,
name|back_b
argument_list|,
ifdef|#
directive|ifdef
name|__COVERITY__
comment|/* Coverity claims that output_encoding cannot be 2 (P_LINEAR)                   * here.                   */
literal|255U
argument_list|,
else|#
directive|else
name|output_encoding
operator|==
name|P_LINEAR
condition|?
literal|65535U
else|:
literal|255U
argument_list|,
endif|#
directive|endif
name|output_encoding
argument_list|)
expr_stmt|;
comment|/* For non-opaque input composite on the sRGB background - this                 * requires inverting the encoding for each component.  The input                 * is still converted to the sRGB encoding because this is a                 * reasonable approximate to the logarithmic curve of human                 * visual sensitivity, at least over the narrow range which PNG                 * represents.  Consequently 'G' is always sRGB encoded, while                 * 'A' is linear.  We need the linear background colors.                 */
if|if
condition|(
name|output_encoding
operator|==
name|P_sRGB
condition|)
comment|/* else already linear */
block|{
comment|/* This may produce a value not exactly matching the                    * background, but that's ok because these numbers are only                    * used when alpha != 0                    */
name|back_r
operator|=
name|png_sRGB_table
index|[
name|back_r
index|]
expr_stmt|;
name|back_g
operator|=
name|png_sRGB_table
index|[
name|back_g
index|]
expr_stmt|;
name|back_b
operator|=
name|png_sRGB_table
index|[
name|back_b
index|]
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
literal|1
init|;
name|a
operator|<
literal|5
condition|;
operator|++
name|a
control|)
block|{
name|unsigned
name|int
name|g
decl_stmt|;
comment|/* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled                    * by an 8-bit alpha value (0..255).                    */
name|png_uint_32
name|alpha
init|=
literal|51
operator|*
name|a
decl_stmt|;
name|png_uint_32
name|back_rx
init|=
operator|(
literal|255
operator|-
name|alpha
operator|)
operator|*
name|back_r
decl_stmt|;
name|png_uint_32
name|back_gx
init|=
operator|(
literal|255
operator|-
name|alpha
operator|)
operator|*
name|back_g
decl_stmt|;
name|png_uint_32
name|back_bx
init|=
operator|(
literal|255
operator|-
name|alpha
operator|)
operator|*
name|back_b
decl_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
literal|6
condition|;
operator|++
name|g
control|)
block|{
name|png_uint_32
name|gray
init|=
name|png_sRGB_table
index|[
name|g
operator|*
literal|51
index|]
operator|*
name|alpha
decl_stmt|;
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
operator|++
argument_list|,
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|gray
operator|+
name|back_rx
argument_list|)
argument_list|,
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|gray
operator|+
name|back_gx
argument_list|)
argument_list|,
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|gray
operator|+
name|back_bx
argument_list|)
argument_list|,
literal|255
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
block|}
block|}
name|cmap_entries
operator|=
name|i
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_GA
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PNG_COLOR_TYPE_RGB
case|:
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
comment|/* Exclude the case where the output is gray; we can always handle this           * with the cases above.           */
if|if
condition|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* The color-map will be grayscale, so we may as well convert the              * input RGB values to a simple grayscale and use the grayscale              * code above.              *              * NOTE: calling this apparently damages the recognition of the              * transparent color in background color handling; call              * png_set_tRNS_to_alpha before png_set_background_fixed.              */
name|png_set_rgb_to_gray_fixed
argument_list|(
name|png_ptr
argument_list|,
name|PNG_ERROR_ACTION_NONE
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data_encoding
operator|=
name|P_sRGB
expr_stmt|;
comment|/* The output will now be one or two 8-bit gray or gray+alpha              * channels.  The more complex case arises when the input has alpha.              */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|||
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
operator|)
operator|&&
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Both input and output have an alpha channel, so no background                 * processing is required; just map the GA bytes to the right                 * color-map entry.                 */
name|expand_tRNS
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PNG_GA_COLORMAP_ENTRIES
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"rgb[ga] color-map: too few entries"
argument_list|)
expr_stmt|;
name|cmap_entries
operator|=
name|make_ga_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|background_index
operator|=
name|PNG_CMAP_GA_BACKGROUND
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_GA
expr_stmt|;
block|}
else|else
block|{
comment|/* Either the input or the output has no alpha channel, so there                 * will be no non-opaque pixels in the color-map; it will just be                 * grayscale.                 */
if|if
condition|(
name|PNG_GRAY_COLORMAP_ENTRIES
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"rgb[gray] color-map: too few entries"
argument_list|)
expr_stmt|;
comment|/* Ideally this code would use libpng to do the gamma correction,                 * but if an input alpha channel is to be removed we will hit the                 * libpng bug in gamma+compose+rgb-to-gray (the double gamma                 * correction bug).  Fix this by dropping the gamma correction in                 * this case and doing it in the palette; this will result in                 * duplicate palette entries, but that's better than the                 * alternative of double gamma correction.                 */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|||
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
operator|)
operator|&&
name|png_gamma_not_sRGB
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmap_entries
operator|=
name|make_gray_file_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|data_encoding
operator|=
name|P_FILE
expr_stmt|;
block|}
else|else
name|cmap_entries
operator|=
name|make_gray_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
comment|/* But if the input has alpha or transparency it must be removed                 */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|||
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
condition|)
block|{
name|png_color_16
name|c
decl_stmt|;
name|png_uint_32
name|gray
init|=
name|back_g
decl_stmt|;
comment|/* We need to ensure that the application background exists in                    * the colormap and that completely transparent pixels map to                    * it.  Achieve this simply by ensuring that the entry                    * selected for the background really is the background color.                    */
if|if
condition|(
name|data_encoding
operator|==
name|P_FILE
condition|)
comment|/* from the fixup above */
block|{
comment|/* The app supplied a gray which is in output_encoding, we                       * need to convert it to a value of the input (P_FILE)                       * encoding then set this palette entry to the required                       * output encoding.                       */
if|if
condition|(
name|output_encoding
operator|==
name|P_sRGB
condition|)
name|gray
operator|=
name|png_sRGB_table
index|[
name|gray
index|]
expr_stmt|;
comment|/* now P_LINEAR */
name|gray
operator|=
name|PNG_DIV257
argument_list|(
name|png_gamma_16bit_correct
argument_list|(
name|gray
argument_list|,
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now P_FILE */
comment|/* And make sure the corresponding palette entry contains                       * exactly the required sRGB value.                       */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|gray
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
literal|0
comment|/*unused*/
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
block|{
name|gray
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|gray
operator|*
literal|255
argument_list|)
expr_stmt|;
comment|/* And make sure the corresponding palette entry matches.                       */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|gray
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
name|back_g
argument_list|,
literal|0
comment|/*unused*/
argument_list|,
name|P_LINEAR
argument_list|)
expr_stmt|;
block|}
comment|/* The background passed to libpng, however, must be the                    * output (normally sRGB) value.                    */
name|c
operator|.
name|index
operator|=
literal|0
expr_stmt|;
comment|/*unused*/
name|c
operator|.
name|gray
operator|=
name|c
operator|.
name|red
operator|=
name|c
operator|.
name|green
operator|=
name|c
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|gray
expr_stmt|;
comment|/* NOTE: the following is apparently a bug in libpng. Without                    * it the transparent color recognition in                    * png_set_background_fixed seems to go wrong.                    */
name|expand_tRNS
operator|=
literal|1
expr_stmt|;
name|png_set_background_fixed
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|c
argument_list|,
name|PNG_BACKGROUND_GAMMA_SCREEN
argument_list|,
literal|0
comment|/*need_expand*/
argument_list|,
literal|0
comment|/*gamma: not used*/
argument_list|)
expr_stmt|;
block|}
name|output_processing
operator|=
name|PNG_CMAP_NONE
expr_stmt|;
block|}
block|}
else|else
comment|/* output is color */
block|{
comment|/* We could use png_quantize here so long as there is no transparent              * color or alpha; png_quantize ignores alpha.  Easier overall just              * to do it once and using PNG_DIV51 on the 6x6x6 reduced RGB cube.              * Consequently we always want libpng to produce sRGB data.              */
name|data_encoding
operator|=
name|P_sRGB
expr_stmt|;
comment|/* Is there any transparency or alpha? */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|||
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
condition|)
block|{
comment|/* Is there alpha in the output too?  If so all four channels are                 * processed into a special RGB cube with alpha support.                 */
if|if
condition|(
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_uint_32
name|r
decl_stmt|;
if|if
condition|(
name|PNG_RGB_COLORMAP_ENTRIES
operator|+
literal|1
operator|+
literal|27
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"rgb+alpha color-map: too few entries"
argument_list|)
expr_stmt|;
name|cmap_entries
operator|=
name|make_rgb_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
comment|/* Add a transparent entry. */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|cmap_entries
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
comment|/* This is stored as the background index for the processing                    * algorithm.                    */
name|background_index
operator|=
name|cmap_entries
operator|++
expr_stmt|;
comment|/* Add 27 r,g,b entries each with alpha 0.5. */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|256
condition|;
name|r
operator|=
operator|(
name|r
operator|<<
literal|1
operator|)
operator||
literal|0x7f
control|)
block|{
name|png_uint_32
name|g
decl_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
literal|256
condition|;
name|g
operator|=
operator|(
name|g
operator|<<
literal|1
operator|)
operator||
literal|0x7f
control|)
block|{
name|png_uint_32
name|b
decl_stmt|;
comment|/* This generates components with the values 0, 127 and                          * 255                          */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|256
condition|;
name|b
operator|=
operator|(
name|b
operator|<<
literal|1
operator|)
operator||
literal|0x7f
control|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|cmap_entries
operator|++
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
literal|128
argument_list|,
name|P_sRGB
argument_list|)
expr_stmt|;
block|}
block|}
name|expand_tRNS
operator|=
literal|1
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_RGB_ALPHA
expr_stmt|;
block|}
else|else
block|{
comment|/* Alpha/transparency must be removed.  The background must                    * exist in the color map (achieved by setting adding it after                    * the 666 color-map).  If the standard processing code will                    * pick up this entry automatically that's all that is                    * required; libpng can be called to do the background                    * processing.                    */
name|unsigned
name|int
name|sample_size
init|=
name|PNG_IMAGE_SAMPLE_SIZE
argument_list|(
name|output_format
argument_list|)
decl_stmt|;
name|png_uint_32
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
comment|/* sRGB background */
if|if
condition|(
name|PNG_RGB_COLORMAP_ENTRIES
operator|+
literal|1
operator|+
literal|27
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"rgb-alpha color-map: too few entries"
argument_list|)
expr_stmt|;
name|cmap_entries
operator|=
name|make_rgb_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|cmap_entries
argument_list|,
name|back_r
argument_list|,
name|back_g
argument_list|,
name|back_b
argument_list|,
literal|0
comment|/*unused*/
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_encoding
operator|==
name|P_LINEAR
condition|)
block|{
name|r
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|back_r
operator|*
literal|255
argument_list|)
expr_stmt|;
name|g
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|back_g
operator|*
literal|255
argument_list|)
expr_stmt|;
name|b
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|back_b
operator|*
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|back_r
expr_stmt|;
name|g
operator|=
name|back_g
expr_stmt|;
name|b
operator|=
name|back_g
expr_stmt|;
block|}
comment|/* Compare the newly-created color-map entry with the one the                    * PNG_CMAP_RGB algorithm will use.  If the two entries don't                    * match, add the new one and set this as the background                    * index.                    */
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|png_const_bytep
operator|)
name|display
operator|->
name|colormap
operator|+
name|sample_size
operator|*
name|cmap_entries
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|display
operator|->
name|colormap
operator|+
name|sample_size
operator|*
name|PNG_RGB_INDEX
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
argument_list|,
name|sample_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The background color must be added. */
name|background_index
operator|=
name|cmap_entries
operator|++
expr_stmt|;
comment|/* Add 27 r,g,b entries each with created by composing with                       * the background at alpha 0.5.                       */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|256
condition|;
name|r
operator|=
operator|(
name|r
operator|<<
literal|1
operator|)
operator||
literal|0x7f
control|)
block|{
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
literal|256
condition|;
name|g
operator|=
operator|(
name|g
operator|<<
literal|1
operator|)
operator||
literal|0x7f
control|)
block|{
comment|/* This generates components with the values 0, 127                             * and 255                             */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|256
condition|;
name|b
operator|=
operator|(
name|b
operator|<<
literal|1
operator|)
operator||
literal|0x7f
control|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|cmap_entries
operator|++
argument_list|,
name|png_colormap_compose
argument_list|(
name|display
argument_list|,
name|r
argument_list|,
name|P_sRGB
argument_list|,
literal|128
argument_list|,
name|back_r
argument_list|,
name|output_encoding
argument_list|)
argument_list|,
name|png_colormap_compose
argument_list|(
name|display
argument_list|,
name|g
argument_list|,
name|P_sRGB
argument_list|,
literal|128
argument_list|,
name|back_g
argument_list|,
name|output_encoding
argument_list|)
argument_list|,
name|png_colormap_compose
argument_list|(
name|display
argument_list|,
name|b
argument_list|,
name|P_sRGB
argument_list|,
literal|128
argument_list|,
name|back_b
argument_list|,
name|output_encoding
argument_list|)
argument_list|,
literal|0
comment|/*unused*/
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
block|}
block|}
name|expand_tRNS
operator|=
literal|1
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_RGB_ALPHA
expr_stmt|;
block|}
else|else
comment|/* background color is in the standard color-map */
block|{
name|png_color_16
name|c
decl_stmt|;
name|c
operator|.
name|index
operator|=
literal|0
expr_stmt|;
comment|/*unused*/
name|c
operator|.
name|red
operator|=
operator|(
name|png_uint_16
operator|)
name|back_r
expr_stmt|;
name|c
operator|.
name|gray
operator|=
name|c
operator|.
name|green
operator|=
operator|(
name|png_uint_16
operator|)
name|back_g
expr_stmt|;
name|c
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|back_b
expr_stmt|;
name|png_set_background_fixed
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|c
argument_list|,
name|PNG_BACKGROUND_GAMMA_SCREEN
argument_list|,
literal|0
comment|/*need_expand*/
argument_list|,
literal|0
comment|/*gamma: not used*/
argument_list|)
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_RGB
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* no alpha or transparency in the input */
block|{
comment|/* Alpha in the output is irrelevant, simply map the opaque input                 * pixels to the 6x6x6 color-map.                 */
if|if
condition|(
name|PNG_RGB_COLORMAP_ENTRIES
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"rgb color-map: too few entries"
argument_list|)
expr_stmt|;
name|cmap_entries
operator|=
name|make_rgb_colormap
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_RGB
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
comment|/* It's already got a color-map.  It may be necessary to eliminate the           * tRNS entries though.           */
block|{
name|unsigned
name|int
name|num_trans
init|=
name|png_ptr
operator|->
name|num_trans
decl_stmt|;
name|png_const_bytep
name|trans
init|=
name|num_trans
operator|>
literal|0
condition|?
name|png_ptr
operator|->
name|trans_alpha
else|:
name|NULL
decl_stmt|;
name|png_const_colorp
name|colormap
init|=
name|png_ptr
operator|->
name|palette
decl_stmt|;
specifier|const
name|int
name|do_background
init|=
name|trans
operator|!=
name|NULL
operator|&&
operator|(
name|output_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|==
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Just in case: */
if|if
condition|(
name|trans
operator|==
name|NULL
condition|)
name|num_trans
operator|=
literal|0
expr_stmt|;
name|output_processing
operator|=
name|PNG_CMAP_NONE
expr_stmt|;
name|data_encoding
operator|=
name|P_FILE
expr_stmt|;
comment|/* Don't change from color-map indices */
name|cmap_entries
operator|=
name|png_ptr
operator|->
name|num_palette
expr_stmt|;
if|if
condition|(
name|cmap_entries
operator|>
literal|256
condition|)
name|cmap_entries
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|cmap_entries
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"palette color-map: too few entries"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmap_entries
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|do_background
operator|!=
literal|0
operator|&&
name|i
operator|<
name|num_trans
operator|&&
name|trans
index|[
name|i
index|]
operator|<
literal|255
condition|)
block|{
if|if
condition|(
name|trans
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
argument_list|,
name|back_r
argument_list|,
name|back_g
argument_list|,
name|back_b
argument_list|,
literal|0
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Must compose the PNG file color in the color-map entry                       * on the sRGB color in 'back'.                       */
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
argument_list|,
name|png_colormap_compose
argument_list|(
name|display
argument_list|,
name|colormap
index|[
name|i
index|]
operator|.
name|red
argument_list|,
name|P_FILE
argument_list|,
name|trans
index|[
name|i
index|]
argument_list|,
name|back_r
argument_list|,
name|output_encoding
argument_list|)
argument_list|,
name|png_colormap_compose
argument_list|(
name|display
argument_list|,
name|colormap
index|[
name|i
index|]
operator|.
name|green
argument_list|,
name|P_FILE
argument_list|,
name|trans
index|[
name|i
index|]
argument_list|,
name|back_g
argument_list|,
name|output_encoding
argument_list|)
argument_list|,
name|png_colormap_compose
argument_list|(
name|display
argument_list|,
name|colormap
index|[
name|i
index|]
operator|.
name|blue
argument_list|,
name|P_FILE
argument_list|,
name|trans
index|[
name|i
index|]
argument_list|,
name|back_b
argument_list|,
name|output_encoding
argument_list|)
argument_list|,
name|output_encoding
operator|==
name|P_LINEAR
condition|?
name|trans
index|[
name|i
index|]
operator|*
literal|257U
else|:
name|trans
index|[
name|i
index|]
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|png_create_colormap_entry
argument_list|(
name|display
argument_list|,
name|i
argument_list|,
name|colormap
index|[
name|i
index|]
operator|.
name|red
argument_list|,
name|colormap
index|[
name|i
index|]
operator|.
name|green
argument_list|,
name|colormap
index|[
name|i
index|]
operator|.
name|blue
argument_list|,
name|i
operator|<
name|num_trans
condition|?
name|trans
index|[
name|i
index|]
else|:
literal|255U
argument_list|,
name|P_FILE
comment|/*8-bit*/
argument_list|)
expr_stmt|;
block|}
comment|/* The PNG data may have indices packed in fewer than 8 bits, it              * must be expanded if so.              */
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|png_set_packing
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid PNG color type"
argument_list|)
expr_stmt|;
comment|/*NOT REACHED*/
block|}
comment|/* Now deal with the output processing */
if|if
condition|(
name|expand_tRNS
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|==
literal|0
condition|)
name|png_set_tRNS_to_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data_encoding
condition|)
block|{
case|case
name|P_sRGB
case|:
comment|/* Change to 8-bit sRGB */
name|png_set_alpha_mode_fixed
argument_list|(
name|png_ptr
argument_list|,
name|PNG_ALPHA_PNG
argument_list|,
name|PNG_GAMMA_sRGB
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|P_FILE
case|:
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|>
literal|8
condition|)
name|png_set_scale_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|__GNUC__
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad data option (internal error)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|cmap_entries
operator|>
literal|256
operator|||
name|cmap_entries
operator|>
name|image
operator|->
name|colormap_entries
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"color map overflow (BAD internal error)"
argument_list|)
expr_stmt|;
name|image
operator|->
name|colormap_entries
operator|=
name|cmap_entries
expr_stmt|;
comment|/* Double check using the recorded background index */
switch|switch
condition|(
name|output_processing
condition|)
block|{
case|case
name|PNG_CMAP_NONE
case|:
if|if
condition|(
name|background_index
operator|!=
name|PNG_CMAP_NONE_BACKGROUND
condition|)
goto|goto
name|bad_background
goto|;
break|break;
case|case
name|PNG_CMAP_GA
case|:
if|if
condition|(
name|background_index
operator|!=
name|PNG_CMAP_GA_BACKGROUND
condition|)
goto|goto
name|bad_background
goto|;
break|break;
case|case
name|PNG_CMAP_TRANS
case|:
if|if
condition|(
name|background_index
operator|>=
name|cmap_entries
operator|||
name|background_index
operator|!=
name|PNG_CMAP_TRANS_BACKGROUND
condition|)
goto|goto
name|bad_background
goto|;
break|break;
case|case
name|PNG_CMAP_RGB
case|:
if|if
condition|(
name|background_index
operator|!=
name|PNG_CMAP_RGB_BACKGROUND
condition|)
goto|goto
name|bad_background
goto|;
break|break;
case|case
name|PNG_CMAP_RGB_ALPHA
case|:
if|if
condition|(
name|background_index
operator|!=
name|PNG_CMAP_RGB_ALPHA_BACKGROUND
condition|)
goto|goto
name|bad_background
goto|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad processing option (internal error)"
argument_list|)
expr_stmt|;
name|bad_background
label|:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad background index (internal error)"
argument_list|)
expr_stmt|;
block|}
name|display
operator|->
name|colormap_processing
operator|=
name|output_processing
expr_stmt|;
return|return
literal|1
comment|/*ok*/
return|;
block|}
end_function
begin_comment
comment|/* The final part of the color-map read called from png_image_finish_read. */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_image_read_and_map
name|png_image_read_and_map
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_read_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_read_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|int
name|passes
decl_stmt|;
comment|/* Called when the libpng data must be transformed into the color-mapped     * form.  There is a local row buffer in display->local and this routine must     * do the interlace handling.     */
switch|switch
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
case|case
name|PNG_INTERLACE_NONE
case|:
name|passes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PNG_INTERLACE_ADAM7
case|:
name|passes
operator|=
name|PNG_INTERLACE_ADAM7_PASSES
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown interlace type"
argument_list|)
expr_stmt|;
block|}
block|{
name|png_uint_32
name|height
init|=
name|image
operator|->
name|height
decl_stmt|;
name|png_uint_32
name|width
init|=
name|image
operator|->
name|width
decl_stmt|;
name|int
name|proc
init|=
name|display
operator|->
name|colormap_processing
decl_stmt|;
name|png_bytep
name|first_row
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
name|ptrdiff_t
name|step_row
init|=
name|display
operator|->
name|row_bytes
decl_stmt|;
name|int
name|pass
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|passes
condition|;
operator|++
name|pass
control|)
block|{
name|unsigned
name|int
name|startx
decl_stmt|,
name|stepx
decl_stmt|,
name|stepy
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|==
name|PNG_INTERLACE_ADAM7
condition|)
block|{
comment|/* The row may be empty for a short image: */
if|if
condition|(
name|PNG_PASS_COLS
argument_list|(
name|width
argument_list|,
name|pass
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|startx
operator|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|stepx
operator|=
name|PNG_PASS_COL_OFFSET
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|y
operator|=
name|PNG_PASS_START_ROW
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|stepy
operator|=
name|PNG_PASS_ROW_OFFSET
argument_list|(
name|pass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|startx
operator|=
literal|0
expr_stmt|;
name|stepx
operator|=
name|stepy
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
name|stepy
control|)
block|{
name|png_bytep
name|inrow
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
decl_stmt|;
name|png_bytep
name|outrow
init|=
name|first_row
operator|+
name|y
operator|*
name|step_row
decl_stmt|;
name|png_const_bytep
name|end_row
init|=
name|outrow
operator|+
name|width
decl_stmt|;
comment|/* Read read the libpng data into the temporary buffer. */
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|inrow
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now process the row according to the processing option, note              * that the caller verifies that the format of the libpng output              * data is as required.              */
name|outrow
operator|+=
name|startx
expr_stmt|;
switch|switch
condition|(
name|proc
condition|)
block|{
case|case
name|PNG_CMAP_GA
case|:
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
comment|/* The data is always in the PNG order */
name|unsigned
name|int
name|gray
init|=
operator|*
name|inrow
operator|++
decl_stmt|;
name|unsigned
name|int
name|alpha
init|=
operator|*
name|inrow
operator|++
decl_stmt|;
name|unsigned
name|int
name|entry
decl_stmt|;
comment|/* NOTE: this code is copied as a comment in                       * make_ga_colormap above.  Please update the                       * comment if you change this code!                       */
if|if
condition|(
name|alpha
operator|>
literal|229
condition|)
comment|/* opaque */
block|{
name|entry
operator|=
operator|(
literal|231
operator|*
name|gray
operator|+
literal|128
operator|)
operator|>>
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alpha
operator|<
literal|26
condition|)
comment|/* transparent */
block|{
name|entry
operator|=
literal|231
expr_stmt|;
block|}
else|else
comment|/* partially opaque */
block|{
name|entry
operator|=
literal|226
operator|+
literal|6
operator|*
name|PNG_DIV51
argument_list|(
name|alpha
argument_list|)
operator|+
name|PNG_DIV51
argument_list|(
name|gray
argument_list|)
expr_stmt|;
block|}
operator|*
name|outrow
operator|=
operator|(
name|png_byte
operator|)
name|entry
expr_stmt|;
block|}
break|break;
case|case
name|PNG_CMAP_TRANS
case|:
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
name|png_byte
name|gray
init|=
operator|*
name|inrow
operator|++
decl_stmt|;
name|png_byte
name|alpha
init|=
operator|*
name|inrow
operator|++
decl_stmt|;
if|if
condition|(
name|alpha
operator|==
literal|0
condition|)
operator|*
name|outrow
operator|=
name|PNG_CMAP_TRANS_BACKGROUND
expr_stmt|;
elseif|else
if|if
condition|(
name|gray
operator|!=
name|PNG_CMAP_TRANS_BACKGROUND
condition|)
operator|*
name|outrow
operator|=
name|gray
expr_stmt|;
else|else
operator|*
name|outrow
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|PNG_CMAP_TRANS_BACKGROUND
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PNG_CMAP_RGB
case|:
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
operator|*
name|outrow
operator|=
name|PNG_RGB_INDEX
argument_list|(
name|inrow
index|[
literal|0
index|]
argument_list|,
name|inrow
index|[
literal|1
index|]
argument_list|,
name|inrow
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|inrow
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
name|PNG_CMAP_RGB_ALPHA
case|:
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
name|unsigned
name|int
name|alpha
init|=
name|inrow
index|[
literal|3
index|]
decl_stmt|;
comment|/* Because the alpha entries only hold alpha==0.5 values                       * split the processing at alpha==0.25 (64) and 0.75                       * (196).                       */
if|if
condition|(
name|alpha
operator|>=
literal|196
condition|)
operator|*
name|outrow
operator|=
name|PNG_RGB_INDEX
argument_list|(
name|inrow
index|[
literal|0
index|]
argument_list|,
name|inrow
index|[
literal|1
index|]
argument_list|,
name|inrow
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|alpha
operator|<
literal|64
condition|)
operator|*
name|outrow
operator|=
name|PNG_CMAP_RGB_ALPHA_BACKGROUND
expr_stmt|;
else|else
block|{
comment|/* Likewise there are three entries for each of r, g                          * and b.  We could select the entry by popcount on                          * the top two bits on those architectures that                          * support it, this is what the code below does,                          * crudely.                          */
name|unsigned
name|int
name|back_i
init|=
name|PNG_CMAP_RGB_ALPHA_BACKGROUND
operator|+
literal|1
decl_stmt|;
comment|/* Here are how the values map:                          *                          * 0x00 .. 0x3f -> 0                          * 0x40 .. 0xbf -> 1                          * 0xc0 .. 0xff -> 2                          *                          * So, as above with the explicit alpha checks, the                          * breakpoints are at 64 and 196.                          */
if|if
condition|(
name|inrow
index|[
literal|0
index|]
operator|&
literal|0x80
condition|)
name|back_i
operator|+=
literal|9
expr_stmt|;
comment|/* red */
if|if
condition|(
name|inrow
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
name|back_i
operator|+=
literal|9
expr_stmt|;
if|if
condition|(
name|inrow
index|[
literal|0
index|]
operator|&
literal|0x80
condition|)
name|back_i
operator|+=
literal|3
expr_stmt|;
comment|/* green */
if|if
condition|(
name|inrow
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
name|back_i
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|inrow
index|[
literal|0
index|]
operator|&
literal|0x80
condition|)
name|back_i
operator|+=
literal|1
expr_stmt|;
comment|/* blue */
if|if
condition|(
name|inrow
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
name|back_i
operator|+=
literal|1
expr_stmt|;
operator|*
name|outrow
operator|=
operator|(
name|png_byte
operator|)
name|back_i
expr_stmt|;
block|}
name|inrow
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_image_read_colormapped
name|png_image_read_colormapped
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_read_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_read_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_controlp
name|control
init|=
name|image
operator|->
name|opaque
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|control
operator|->
name|png_ptr
decl_stmt|;
name|png_inforp
name|info_ptr
init|=
name|control
operator|->
name|info_ptr
decl_stmt|;
name|int
name|passes
init|=
literal|0
decl_stmt|;
comment|/* As a flag */
name|PNG_SKIP_CHUNKS
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Update the 'info' structure and make sure the result is as required; first     * make sure to turn on the interlace handling if it will be required     * (because it can't be turned on *after* the call to png_read_update_info!)     */
if|if
condition|(
name|display
operator|->
name|colormap_processing
operator|==
name|PNG_CMAP_NONE
condition|)
name|passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_read_update_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* The expected output can be deduced from the colormap_processing option. */
switch|switch
condition|(
name|display
operator|->
name|colormap_processing
condition|)
block|{
case|case
name|PNG_CMAP_NONE
case|:
comment|/* Output must be one channel and one byte per pixel, the output           * encoding can be anything.           */
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|||
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|)
operator|&&
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|8
condition|)
break|break;
goto|goto
name|bad_output
goto|;
case|case
name|PNG_CMAP_TRANS
case|:
case|case
name|PNG_CMAP_GA
case|:
comment|/* Output must be two channels and the 'G' one must be sRGB, the latter           * can be checked with an exact number because it should have been set           * to this number above!           */
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
operator|&&
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
name|png_ptr
operator|->
name|screen_gamma
operator|==
name|PNG_GAMMA_sRGB
operator|&&
name|image
operator|->
name|colormap_entries
operator|==
literal|256
condition|)
break|break;
goto|goto
name|bad_output
goto|;
case|case
name|PNG_CMAP_RGB
case|:
comment|/* Output must be 8-bit sRGB encoded RGB */
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|&&
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
name|png_ptr
operator|->
name|screen_gamma
operator|==
name|PNG_GAMMA_sRGB
operator|&&
name|image
operator|->
name|colormap_entries
operator|==
literal|216
condition|)
break|break;
goto|goto
name|bad_output
goto|;
case|case
name|PNG_CMAP_RGB_ALPHA
case|:
comment|/* Output must be 8-bit sRGB encoded RGBA */
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|&&
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
name|png_ptr
operator|->
name|screen_gamma
operator|==
name|PNG_GAMMA_sRGB
operator|&&
name|image
operator|->
name|colormap_entries
operator|==
literal|244
comment|/* 216 + 1 + 27 */
condition|)
break|break;
comment|/* goto bad_output; */
comment|/* FALL THROUGH */
default|default:
name|bad_output
label|:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad color-map processing (internal error)"
argument_list|)
expr_stmt|;
block|}
comment|/* Now read the rows.  Do this here if it is possible to read directly into     * the output buffer, otherwise allocate a local row buffer of the maximum     * size libpng requires and call the relevant processing routine safely.     */
block|{
name|png_voidp
name|first_row
init|=
name|display
operator|->
name|buffer
decl_stmt|;
name|ptrdiff_t
name|row_bytes
init|=
name|display
operator|->
name|row_stride
decl_stmt|;
comment|/* The following expression is designed to work correctly whether it gives        * a signed or an unsigned result.        */
if|if
condition|(
name|row_bytes
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|png_voidcast
argument_list|(
name|char
operator|*
argument_list|,
name|first_row
argument_list|)
decl_stmt|;
name|ptr
operator|+=
operator|(
name|image
operator|->
name|height
operator|-
literal|1
operator|)
operator|*
operator|(
operator|-
name|row_bytes
operator|)
expr_stmt|;
name|first_row
operator|=
name|png_voidcast
argument_list|(
name|png_voidp
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|display
operator|->
name|first_row
operator|=
name|first_row
expr_stmt|;
name|display
operator|->
name|row_bytes
operator|=
name|row_bytes
expr_stmt|;
block|}
if|if
condition|(
name|passes
operator|==
literal|0
condition|)
block|{
name|int
name|result
decl_stmt|;
name|png_voidp
name|row
init|=
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_get_rowbytes
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
argument_list|)
decl_stmt|;
name|display
operator|->
name|local_row
operator|=
name|row
expr_stmt|;
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_and_map
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|display
operator|->
name|local_row
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
name|png_alloc_size_t
name|row_bytes
init|=
name|display
operator|->
name|row_bytes
decl_stmt|;
while|while
condition|(
operator|--
name|passes
operator|>=
literal|0
condition|)
block|{
name|png_uint_32
name|y
init|=
name|image
operator|->
name|height
decl_stmt|;
name|png_bytep
name|row
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
while|while
condition|(
name|y
operator|--
operator|>
literal|0
condition|)
block|{
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|row
operator|+=
name|row_bytes
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|/* Just the row reading part of png_image_read. */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_image_read_composite
name|png_image_read_composite
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_read_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_read_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|int
name|passes
decl_stmt|;
switch|switch
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
case|case
name|PNG_INTERLACE_NONE
case|:
name|passes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PNG_INTERLACE_ADAM7
case|:
name|passes
operator|=
name|PNG_INTERLACE_ADAM7_PASSES
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown interlace type"
argument_list|)
expr_stmt|;
block|}
block|{
name|png_uint_32
name|height
init|=
name|image
operator|->
name|height
decl_stmt|;
name|png_uint_32
name|width
init|=
name|image
operator|->
name|width
decl_stmt|;
name|ptrdiff_t
name|step_row
init|=
name|display
operator|->
name|row_bytes
decl_stmt|;
name|unsigned
name|int
name|channels
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|?
literal|3
else|:
literal|1
decl_stmt|;
name|int
name|pass
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|passes
condition|;
operator|++
name|pass
control|)
block|{
name|unsigned
name|int
name|startx
decl_stmt|,
name|stepx
decl_stmt|,
name|stepy
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|==
name|PNG_INTERLACE_ADAM7
condition|)
block|{
comment|/* The row may be empty for a short image: */
if|if
condition|(
name|PNG_PASS_COLS
argument_list|(
name|width
argument_list|,
name|pass
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|startx
operator|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
operator|*
name|channels
expr_stmt|;
name|stepx
operator|=
name|PNG_PASS_COL_OFFSET
argument_list|(
name|pass
argument_list|)
operator|*
name|channels
expr_stmt|;
name|y
operator|=
name|PNG_PASS_START_ROW
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|stepy
operator|=
name|PNG_PASS_ROW_OFFSET
argument_list|(
name|pass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|startx
operator|=
literal|0
expr_stmt|;
name|stepx
operator|=
name|channels
expr_stmt|;
name|stepy
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
name|stepy
control|)
block|{
name|png_bytep
name|inrow
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
decl_stmt|;
name|png_bytep
name|outrow
decl_stmt|;
name|png_const_bytep
name|end_row
decl_stmt|;
comment|/* Read the row, which is packed: */
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|inrow
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|outrow
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
expr_stmt|;
name|outrow
operator|+=
name|y
operator|*
name|step_row
expr_stmt|;
name|end_row
operator|=
name|outrow
operator|+
name|width
operator|*
name|channels
expr_stmt|;
comment|/* Now do the composition on each pixel in this row. */
name|outrow
operator|+=
name|startx
expr_stmt|;
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
name|png_byte
name|alpha
init|=
name|inrow
index|[
name|channels
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|>
literal|0
condition|)
comment|/* else no change to the output */
block|{
name|unsigned
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|channels
condition|;
operator|++
name|c
control|)
block|{
name|png_uint_32
name|component
init|=
name|inrow
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|<
literal|255
condition|)
comment|/* else just use component */
block|{
comment|/* This is PNG_OPTIMIZED_ALPHA, the component value                          * is a linear 8-bit value.  Combine this with the                          * current outrow[c] value which is sRGB encoded.                          * Arithmetic here is 16-bits to preserve the output                          * values correctly.                          */
name|component
operator|*=
literal|257
operator|*
literal|255
expr_stmt|;
comment|/* =65535 */
name|component
operator|+=
operator|(
literal|255
operator|-
name|alpha
operator|)
operator|*
name|png_sRGB_table
index|[
name|outrow
index|[
name|c
index|]
index|]
expr_stmt|;
comment|/* So 'component' is scaled by 255*65535 and is                          * therefore appropriate for the sRGB to linear                          * conversion table.                          */
name|component
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
name|outrow
index|[
name|c
index|]
operator|=
operator|(
name|png_byte
operator|)
name|component
expr_stmt|;
block|}
block|}
name|inrow
operator|+=
name|channels
operator|+
literal|1
expr_stmt|;
comment|/* components and alpha channel */
block|}
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* The do_local_background case; called when all the following transforms are to  * be done:  *  * PNG_RGB_TO_GRAY  * PNG_COMPOSITE  * PNG_GAMMA  *  * This is a work-around for the fact that both the PNG_RGB_TO_GRAY and  * PNG_COMPOSITE code performs gamma correction, so we get double gamma  * correction.  The fix-up is to prevent the PNG_COMPOSITE operation from  * happening inside libpng, so this routine sees an 8 or 16-bit gray+alpha  * row and handles the removal or pre-multiplication of the alpha channel.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_image_read_background
name|png_image_read_background
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_read_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_read_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|png_inforp
name|info_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|info_ptr
decl_stmt|;
name|png_uint_32
name|height
init|=
name|image
operator|->
name|height
decl_stmt|;
name|png_uint_32
name|width
init|=
name|image
operator|->
name|width
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|passes
decl_stmt|;
comment|/* Double check the convoluted logic below.  We expect to get here with     * libpng doing rgb to gray and gamma correction but background processing     * left to the png_image_read_background function.  The rows libpng produce     * might be 8 or 16-bit but should always have two channels; gray plus alpha.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"lost rgb to gray"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unexpected compose"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_channels
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
operator|!=
literal|2
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"lost/gained channels"
argument_list|)
expr_stmt|;
comment|/* Expect the 8-bit case to always remove the alpha channel */
if|if
condition|(
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unexpected 8-bit transformation"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
case|case
name|PNG_INTERLACE_NONE
case|:
name|passes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PNG_INTERLACE_ADAM7
case|:
name|passes
operator|=
name|PNG_INTERLACE_ADAM7_PASSES
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown interlace type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use direct access to info_ptr here because otherwise the simplified API     * would require PNG_EASY_ACCESS_SUPPORTED (just for this.)  Note this is     * checking the value after libpng expansions, not the original value in the     * PNG.     */
switch|switch
condition|(
name|info_ptr
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|8
case|:
comment|/* 8-bit sRGB gray values with an alpha channel; the alpha channel is           * to be removed by composing on a background: either the row if           * display->background is NULL or display->background->green if not.           * Unlike the code above ALPHA_OPTIMIZED has *not* been done.           */
block|{
name|png_bytep
name|first_row
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
name|ptrdiff_t
name|step_row
init|=
name|display
operator|->
name|row_bytes
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|passes
condition|;
operator|++
name|pass
control|)
block|{
name|png_bytep
name|row
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|startx
decl_stmt|,
name|stepx
decl_stmt|,
name|stepy
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|==
name|PNG_INTERLACE_ADAM7
condition|)
block|{
comment|/* The row may be empty for a short image: */
if|if
condition|(
name|PNG_PASS_COLS
argument_list|(
name|width
argument_list|,
name|pass
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|startx
operator|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|stepx
operator|=
name|PNG_PASS_COL_OFFSET
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|y
operator|=
name|PNG_PASS_START_ROW
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|stepy
operator|=
name|PNG_PASS_ROW_OFFSET
argument_list|(
name|pass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|startx
operator|=
literal|0
expr_stmt|;
name|stepx
operator|=
name|stepy
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|display
operator|->
name|background
operator|==
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
name|stepy
control|)
block|{
name|png_bytep
name|inrow
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
decl_stmt|;
name|png_bytep
name|outrow
init|=
name|first_row
operator|+
name|y
operator|*
name|step_row
decl_stmt|;
name|png_const_bytep
name|end_row
init|=
name|outrow
operator|+
name|width
decl_stmt|;
comment|/* Read the row, which is packed: */
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|inrow
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now do the composition on each pixel in this row. */
name|outrow
operator|+=
name|startx
expr_stmt|;
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
name|png_byte
name|alpha
init|=
name|inrow
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|>
literal|0
condition|)
comment|/* else no change to the output */
block|{
name|png_uint_32
name|component
init|=
name|inrow
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|<
literal|255
condition|)
comment|/* else just use component */
block|{
comment|/* Since PNG_OPTIMIZED_ALPHA was not set it is                                * necessary to invert the sRGB transfer                                * function and multiply the alpha out.                                */
name|component
operator|=
name|png_sRGB_table
index|[
name|component
index|]
operator|*
name|alpha
expr_stmt|;
name|component
operator|+=
name|png_sRGB_table
index|[
name|outrow
index|[
literal|0
index|]
index|]
operator|*
operator|(
literal|255
operator|-
name|alpha
operator|)
expr_stmt|;
name|component
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
name|outrow
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|component
expr_stmt|;
block|}
name|inrow
operator|+=
literal|2
expr_stmt|;
comment|/* gray and alpha channel */
block|}
block|}
block|}
else|else
comment|/* constant background value */
block|{
name|png_byte
name|background8
init|=
name|display
operator|->
name|background
operator|->
name|green
decl_stmt|;
name|png_uint_16
name|background
init|=
name|png_sRGB_table
index|[
name|background8
index|]
decl_stmt|;
for|for
control|(
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
name|stepy
control|)
block|{
name|png_bytep
name|inrow
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
decl_stmt|;
name|png_bytep
name|outrow
init|=
name|first_row
operator|+
name|y
operator|*
name|step_row
decl_stmt|;
name|png_const_bytep
name|end_row
init|=
name|outrow
operator|+
name|width
decl_stmt|;
comment|/* Read the row, which is packed: */
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|inrow
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now do the composition on each pixel in this row. */
name|outrow
operator|+=
name|startx
expr_stmt|;
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
name|png_byte
name|alpha
init|=
name|inrow
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|>
literal|0
condition|)
comment|/* else use background */
block|{
name|png_uint_32
name|component
init|=
name|inrow
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|<
literal|255
condition|)
comment|/* else just use component */
block|{
name|component
operator|=
name|png_sRGB_table
index|[
name|component
index|]
operator|*
name|alpha
expr_stmt|;
name|component
operator|+=
name|background
operator|*
operator|(
literal|255
operator|-
name|alpha
operator|)
expr_stmt|;
name|component
operator|=
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
name|outrow
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|component
expr_stmt|;
block|}
else|else
name|outrow
index|[
literal|0
index|]
operator|=
name|background8
expr_stmt|;
name|inrow
operator|+=
literal|2
expr_stmt|;
comment|/* gray and alpha channel */
block|}
name|row
operator|+=
name|display
operator|->
name|row_bytes
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
literal|16
case|:
comment|/* 16-bit linear with pre-multiplied alpha; the pre-multiplication must           * still be done and, maybe, the alpha channel removed.  This code also           * handles the alpha-first option.           */
block|{
name|png_uint_16p
name|first_row
init|=
name|png_voidcast
argument_list|(
name|png_uint_16p
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
comment|/* The division by two is safe because the caller passed in a              * stride which was multiplied by 2 (below) to get row_bytes.              */
name|ptrdiff_t
name|step_row
init|=
name|display
operator|->
name|row_bytes
operator|/
literal|2
decl_stmt|;
name|int
name|preserve_alpha
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
decl_stmt|;
name|unsigned
name|int
name|outchannels
init|=
literal|1
operator|+
name|preserve_alpha
decl_stmt|;
name|int
name|swap_alpha
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED
if|if
condition|(
name|preserve_alpha
operator|!=
literal|0
operator|&&
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
condition|)
name|swap_alpha
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|passes
condition|;
operator|++
name|pass
control|)
block|{
name|unsigned
name|int
name|startx
decl_stmt|,
name|stepx
decl_stmt|,
name|stepy
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
comment|/* The 'x' start and step are adjusted to output components here.                 */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|==
name|PNG_INTERLACE_ADAM7
condition|)
block|{
comment|/* The row may be empty for a short image: */
if|if
condition|(
name|PNG_PASS_COLS
argument_list|(
name|width
argument_list|,
name|pass
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|startx
operator|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
operator|*
name|outchannels
expr_stmt|;
name|stepx
operator|=
name|PNG_PASS_COL_OFFSET
argument_list|(
name|pass
argument_list|)
operator|*
name|outchannels
expr_stmt|;
name|y
operator|=
name|PNG_PASS_START_ROW
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|stepy
operator|=
name|PNG_PASS_ROW_OFFSET
argument_list|(
name|pass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|startx
operator|=
literal|0
expr_stmt|;
name|stepx
operator|=
name|outchannels
expr_stmt|;
name|stepy
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|+=
name|stepy
control|)
block|{
name|png_const_uint_16p
name|inrow
decl_stmt|;
name|png_uint_16p
name|outrow
init|=
name|first_row
operator|+
name|y
operator|*
name|step_row
decl_stmt|;
name|png_uint_16p
name|end_row
init|=
name|outrow
operator|+
name|width
operator|*
name|outchannels
decl_stmt|;
comment|/* Read the row, which is packed: */
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|inrow
operator|=
name|png_voidcast
argument_list|(
name|png_const_uint_16p
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
expr_stmt|;
comment|/* Now do the pre-multiplication on each pixel in this row.                    */
name|outrow
operator|+=
name|startx
expr_stmt|;
for|for
control|(
init|;
name|outrow
operator|<
name|end_row
condition|;
name|outrow
operator|+=
name|stepx
control|)
block|{
name|png_uint_32
name|component
init|=
name|inrow
index|[
literal|0
index|]
decl_stmt|;
name|png_uint_16
name|alpha
init|=
name|inrow
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|>
literal|0
condition|)
comment|/* else 0 */
block|{
if|if
condition|(
name|alpha
operator|<
literal|65535
condition|)
comment|/* else just use component */
block|{
name|component
operator|*=
name|alpha
expr_stmt|;
name|component
operator|+=
literal|32767
expr_stmt|;
name|component
operator|/=
literal|65535
expr_stmt|;
block|}
block|}
else|else
name|component
operator|=
literal|0
expr_stmt|;
name|outrow
index|[
name|swap_alpha
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|component
expr_stmt|;
if|if
condition|(
name|preserve_alpha
operator|!=
literal|0
condition|)
name|outrow
index|[
literal|1
operator|^
name|swap_alpha
index|]
operator|=
name|alpha
expr_stmt|;
name|inrow
operator|+=
literal|2
expr_stmt|;
comment|/* components and alpha channel */
block|}
block|}
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|__GNUC__
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unexpected bit depth"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* The guts of png_image_finish_read as a png_safe_execute callback. */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_image_read_direct
name|png_image_read_direct
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_read_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_read_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|png_inforp
name|info_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|info_ptr
decl_stmt|;
name|png_uint_32
name|format
init|=
name|image
operator|->
name|format
decl_stmt|;
name|int
name|linear
init|=
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|do_local_compose
init|=
literal|0
decl_stmt|;
name|int
name|do_local_background
init|=
literal|0
decl_stmt|;
comment|/* to avoid double gamma correction bug */
name|int
name|passes
init|=
literal|0
decl_stmt|;
comment|/* Add transforms to ensure the correct output format is produced then check     * that the required implementation support is there.  Always expand; always     * need 8 bits minimum, no palette and expanded tRNS.     */
name|png_set_expand
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Now check the format to see if it was modified. */
block|{
name|png_uint_32
name|base_format
init|=
name|png_image_format
argument_list|(
name|png_ptr
argument_list|)
operator|&
operator|~
name|PNG_FORMAT_FLAG_COLORMAP
comment|/* removed by png_set_expand */
decl_stmt|;
name|png_uint_32
name|change
init|=
name|format
operator|^
name|base_format
decl_stmt|;
name|png_fixed_point
name|output_gamma
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* alpha mode */
comment|/* Do this first so that we have a record if rgb to gray is happening. */
if|if
condition|(
operator|(
name|change
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* gray<->color transformation required. */
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|)
name|png_set_gray_to_rgb
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* libpng can't do both rgb to gray and              * background/pre-multiplication if there is also significant gamma              * correction, because both operations require linear colors and              * the code only supports one transform doing the gamma correction.              * Handle this by doing the pre-multiplication or background              * operation in this code, if necessary.              *              * TODO: fix this by rewriting pngrtran.c (!)              *              * For the moment (given that fixing this in pngrtran.c is an              * enormous change) 'do_local_background' is used to indicate that              * the problem exists.              */
if|if
condition|(
operator|(
name|base_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|do_local_background
operator|=
literal|1
comment|/*maybe*/
expr_stmt|;
name|png_set_rgb_to_gray_fixed
argument_list|(
name|png_ptr
argument_list|,
name|PNG_ERROR_ACTION_NONE
argument_list|,
name|PNG_RGB_TO_GRAY_DEFAULT
argument_list|,
name|PNG_RGB_TO_GRAY_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|change
operator|&=
operator|~
name|PNG_FORMAT_FLAG_COLOR
expr_stmt|;
block|}
comment|/* Set the gamma appropriately, linear for 16-bit input, sRGB otherwise.        */
block|{
name|png_fixed_point
name|input_gamma_default
decl_stmt|;
if|if
condition|(
operator|(
name|base_format
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|image
operator|->
name|flags
operator|&
name|PNG_IMAGE_FLAG_16BIT_sRGB
operator|)
operator|==
literal|0
condition|)
name|input_gamma_default
operator|=
name|PNG_GAMMA_LINEAR
expr_stmt|;
else|else
name|input_gamma_default
operator|=
name|PNG_DEFAULT_sRGB
expr_stmt|;
comment|/* Call png_set_alpha_mode to set the default for the input gamma; the           * output gamma is set by a second call below.           */
name|png_set_alpha_mode_fixed
argument_list|(
name|png_ptr
argument_list|,
name|PNG_ALPHA_PNG
argument_list|,
name|input_gamma_default
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linear
operator|!=
literal|0
condition|)
block|{
comment|/* If there *is* an alpha channel in the input it must be multiplied           * out; use PNG_ALPHA_STANDARD, otherwise just use PNG_ALPHA_PNG.           */
if|if
condition|(
operator|(
name|base_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
name|PNG_ALPHA_STANDARD
expr_stmt|;
comment|/* associated alpha */
else|else
name|mode
operator|=
name|PNG_ALPHA_PNG
expr_stmt|;
name|output_gamma
operator|=
name|PNG_GAMMA_LINEAR
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|PNG_ALPHA_PNG
expr_stmt|;
name|output_gamma
operator|=
name|PNG_DEFAULT_sRGB
expr_stmt|;
block|}
comment|/* If 'do_local_background' is set check for the presence of gamma        * correction; this is part of the work-round for the libpng bug        * described above.        *        * TODO: fix libpng and remove this.        */
if|if
condition|(
name|do_local_background
operator|!=
literal|0
condition|)
block|{
name|png_fixed_point
name|gtest
decl_stmt|;
comment|/* This is 'png_gamma_threshold' from pngrtran.c; the test used for           * gamma correction, the screen gamma hasn't been set on png_struct           * yet; it's set below.  png_struct::gamma, however, is set to the           * final value.           */
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|gtest
argument_list|,
name|output_gamma
argument_list|,
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|,
name|PNG_FP_1
argument_list|)
operator|!=
literal|0
operator|&&
name|png_gamma_significant
argument_list|(
name|gtest
argument_list|)
operator|==
literal|0
condition|)
name|do_local_background
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|PNG_ALPHA_STANDARD
condition|)
block|{
name|do_local_background
operator|=
literal|2
comment|/*required*/
expr_stmt|;
name|mode
operator|=
name|PNG_ALPHA_PNG
expr_stmt|;
comment|/* prevent libpng doing it */
block|}
comment|/* else leave as 1 for the checks below */
block|}
comment|/* If the bit-depth changes then handle that here. */
if|if
condition|(
operator|(
name|change
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|linear
operator|!=
literal|0
comment|/*16-bit output*/
condition|)
name|png_set_expand_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|else
comment|/* 8-bit output */
name|png_set_scale_16
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|change
operator|&=
operator|~
name|PNG_FORMAT_FLAG_LINEAR
expr_stmt|;
block|}
comment|/* Now the background/alpha channel changes. */
if|if
condition|(
operator|(
name|change
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Removing an alpha channel requires composition for the 8-bit           * formats; for the 16-bit it is already done, above, by the           * pre-multiplication and the channel just needs to be stripped.           */
if|if
condition|(
operator|(
name|base_format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If RGB->gray is happening the alpha channel must be left and the              * operation completed locally.              *              * TODO: fix libpng and remove this.              */
if|if
condition|(
name|do_local_background
operator|!=
literal|0
condition|)
name|do_local_background
operator|=
literal|2
comment|/*required*/
expr_stmt|;
comment|/* 16-bit output: just remove the channel */
elseif|else
if|if
condition|(
name|linear
operator|!=
literal|0
condition|)
comment|/* compose on black (well, pre-multiply) */
name|png_set_strip_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* 8-bit output: do an appropriate compose */
elseif|else
if|if
condition|(
name|display
operator|->
name|background
operator|!=
name|NULL
condition|)
block|{
name|png_color_16
name|c
decl_stmt|;
name|c
operator|.
name|index
operator|=
literal|0
expr_stmt|;
comment|/*unused*/
name|c
operator|.
name|red
operator|=
name|display
operator|->
name|background
operator|->
name|red
expr_stmt|;
name|c
operator|.
name|green
operator|=
name|display
operator|->
name|background
operator|->
name|green
expr_stmt|;
name|c
operator|.
name|blue
operator|=
name|display
operator|->
name|background
operator|->
name|blue
expr_stmt|;
name|c
operator|.
name|gray
operator|=
name|display
operator|->
name|background
operator|->
name|green
expr_stmt|;
comment|/* This is always an 8-bit sRGB value, using the 'green' channel                 * for gray is much better than calculating the luminance here;                 * we can get off-by-one errors in that calculation relative to                 * the app expectations and that will show up in transparent                 * pixels.                 */
name|png_set_background_fixed
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|c
argument_list|,
name|PNG_BACKGROUND_GAMMA_SCREEN
argument_list|,
literal|0
comment|/*need_expand*/
argument_list|,
literal|0
comment|/*gamma: not used*/
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* compose on row: implemented below. */
block|{
name|do_local_compose
operator|=
literal|1
expr_stmt|;
comment|/* This leaves the alpha channel in the output, so it has to be                 * removed by the code below.  Set the encoding to the 'OPTIMIZE'                 * one so the code only has to hack on the pixels that require                 * composition.                 */
name|mode
operator|=
name|PNG_ALPHA_OPTIMIZED
expr_stmt|;
block|}
block|}
else|else
comment|/* output needs an alpha channel */
block|{
comment|/* This is tricky because it happens before the swap operation has              * been accomplished; however, the swap does *not* swap the added              * alpha channel (weird API), so it must be added in the correct              * place.              */
name|png_uint_32
name|filler
decl_stmt|;
comment|/* opaque filler */
name|int
name|where
decl_stmt|;
if|if
condition|(
name|linear
operator|!=
literal|0
condition|)
name|filler
operator|=
literal|65535
expr_stmt|;
else|else
name|filler
operator|=
literal|255
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FORMAT_AFIRST_SUPPORTED
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
condition|)
block|{
name|where
operator|=
name|PNG_FILLER_BEFORE
expr_stmt|;
name|change
operator|&=
operator|~
name|PNG_FORMAT_FLAG_AFIRST
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|where
operator|=
name|PNG_FILLER_AFTER
expr_stmt|;
name|png_set_add_alpha
argument_list|(
name|png_ptr
argument_list|,
name|filler
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
comment|/* This stops the (irrelevant) call to swap_alpha below. */
name|change
operator|&=
operator|~
name|PNG_FORMAT_FLAG_ALPHA
expr_stmt|;
block|}
comment|/* Now set the alpha mode correctly; this is always done, even if there is        * no alpha channel in either the input or the output because it correctly        * sets the output gamma.        */
name|png_set_alpha_mode_fixed
argument_list|(
name|png_ptr
argument_list|,
name|mode
argument_list|,
name|output_gamma
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FORMAT_BGR_SUPPORTED
if|if
condition|(
operator|(
name|change
operator|&
name|PNG_FORMAT_FLAG_BGR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Check only the output format; PNG is never BGR; don't do this if              * the output is gray, but fix up the 'format' value in that case.              */
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|)
name|png_set_bgr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|else
name|format
operator|&=
operator|~
name|PNG_FORMAT_FLAG_BGR
expr_stmt|;
name|change
operator|&=
operator|~
name|PNG_FORMAT_FLAG_BGR
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_FORMAT_AFIRST_SUPPORTED
if|if
condition|(
operator|(
name|change
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Only relevant if there is an alpha channel - it's particularly              * important to handle this correctly because do_local_compose may              * be set above and then libpng will keep the alpha channel for this              * code to remove.              */
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Disable this if doing a local background,                 * TODO: remove this when local background is no longer required.                 */
if|if
condition|(
name|do_local_background
operator|!=
literal|2
condition|)
name|png_set_swap_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|format
operator|&=
operator|~
name|PNG_FORMAT_FLAG_AFIRST
expr_stmt|;
name|change
operator|&=
operator|~
name|PNG_FORMAT_FLAG_AFIRST
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If the *output* is 16-bit then we need to check for a byte-swap on this        * architecture.        */
if|if
condition|(
name|linear
operator|!=
literal|0
condition|)
block|{
name|PNG_CONST
name|png_uint_16
name|le
init|=
literal|0x0001
decl_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|png_const_bytep
operator|)
operator|&
name|le
operator|)
operator|!=
literal|0
condition|)
name|png_set_swap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* If change is not now 0 some transformation is missing - error out. */
if|if
condition|(
name|change
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_read_image: unsupported transformation"
argument_list|)
expr_stmt|;
block|}
name|PNG_SKIP_CHUNKS
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Update the 'info' structure and make sure the result is as required; first     * make sure to turn on the interlace handling if it will be required     * (because it can't be turned on *after* the call to png_read_update_info!)     *     * TODO: remove the do_local_background fixup below.     */
if|if
condition|(
name|do_local_compose
operator|==
literal|0
operator|&&
name|do_local_background
operator|!=
literal|2
condition|)
name|passes
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_read_update_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|{
name|png_uint_32
name|info_format
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
name|info_format
operator||=
name|PNG_FORMAT_FLAG_COLOR
expr_stmt|;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* do_local_compose removes this channel below. */
if|if
condition|(
name|do_local_compose
operator|==
literal|0
condition|)
block|{
comment|/* do_local_background does the same if required. */
if|if
condition|(
name|do_local_background
operator|!=
literal|2
operator|||
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|info_format
operator||=
name|PNG_FORMAT_FLAG_ALPHA
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_local_compose
operator|!=
literal|0
condition|)
comment|/* internal error */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_image_read: alpha channel lost"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|16
condition|)
name|info_format
operator||=
name|PNG_FORMAT_FLAG_LINEAR
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FORMAT_BGR_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BGR
operator|)
operator|!=
literal|0
condition|)
name|info_format
operator||=
name|PNG_FORMAT_FLAG_BGR
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_FORMAT_AFIRST_SUPPORTED
if|if
condition|(
name|do_local_background
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
condition|)
name|info_format
operator||=
name|PNG_FORMAT_FLAG_AFIRST
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SWAP_ALPHA
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_ADD_ALPHA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_FILLER_AFTER
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|do_local_background
operator|==
literal|2
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unexpected alpha swap transformation"
argument_list|)
expr_stmt|;
name|info_format
operator||=
name|PNG_FORMAT_FLAG_AFIRST
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* This is actually an internal error. */
if|if
condition|(
name|info_format
operator|!=
name|format
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_read_image: invalid transformations"
argument_list|)
expr_stmt|;
block|}
comment|/* Now read the rows.  If do_local_compose is set then it is necessary to use     * a local row buffer.  The output will be GA, RGBA or BGRA and must be     * converted to G, RGB or BGR as appropriate.  The 'local_row' member of the     * display acts as a flag.     */
block|{
name|png_voidp
name|first_row
init|=
name|display
operator|->
name|buffer
decl_stmt|;
name|ptrdiff_t
name|row_bytes
init|=
name|display
operator|->
name|row_stride
decl_stmt|;
if|if
condition|(
name|linear
operator|!=
literal|0
condition|)
name|row_bytes
operator|*=
literal|2
expr_stmt|;
comment|/* The following expression is designed to work correctly whether it gives        * a signed or an unsigned result.        */
if|if
condition|(
name|row_bytes
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|png_voidcast
argument_list|(
name|char
operator|*
argument_list|,
name|first_row
argument_list|)
decl_stmt|;
name|ptr
operator|+=
operator|(
name|image
operator|->
name|height
operator|-
literal|1
operator|)
operator|*
operator|(
operator|-
name|row_bytes
operator|)
expr_stmt|;
name|first_row
operator|=
name|png_voidcast
argument_list|(
name|png_voidp
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|display
operator|->
name|first_row
operator|=
name|first_row
expr_stmt|;
name|display
operator|->
name|row_bytes
operator|=
name|row_bytes
expr_stmt|;
block|}
if|if
condition|(
name|do_local_compose
operator|!=
literal|0
condition|)
block|{
name|int
name|result
decl_stmt|;
name|png_voidp
name|row
init|=
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_get_rowbytes
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
argument_list|)
decl_stmt|;
name|display
operator|->
name|local_row
operator|=
name|row
expr_stmt|;
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_composite
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|display
operator|->
name|local_row
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|do_local_background
operator|==
literal|2
condition|)
block|{
name|int
name|result
decl_stmt|;
name|png_voidp
name|row
init|=
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_get_rowbytes
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
argument_list|)
decl_stmt|;
name|display
operator|->
name|local_row
operator|=
name|row
expr_stmt|;
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_background
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|display
operator|->
name|local_row
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
name|png_alloc_size_t
name|row_bytes
init|=
name|display
operator|->
name|row_bytes
decl_stmt|;
while|while
condition|(
operator|--
name|passes
operator|>=
literal|0
condition|)
block|{
name|png_uint_32
name|y
init|=
name|image
operator|->
name|height
decl_stmt|;
name|png_bytep
name|row
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
while|while
condition|(
name|y
operator|--
operator|>
literal|0
condition|)
block|{
name|png_read_row
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|row
operator|+=
name|row_bytes
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
end_function
begin_function
name|int
name|PNGAPI
DECL|function|png_image_finish_read
name|png_image_finish_read
parameter_list|(
name|png_imagep
name|image
parameter_list|,
name|png_const_colorp
name|background
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|png_int_32
name|row_stride
parameter_list|,
name|void
modifier|*
name|colormap
parameter_list|)
block|{
if|if
condition|(
name|image
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|version
operator|==
name|PNG_IMAGE_VERSION
condition|)
block|{
name|png_uint_32
name|check
decl_stmt|;
if|if
condition|(
name|row_stride
operator|==
literal|0
condition|)
name|row_stride
operator|=
name|PNG_IMAGE_ROW_STRIDE
argument_list|(
operator|*
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_stride
operator|<
literal|0
condition|)
name|check
operator|=
operator|-
name|row_stride
expr_stmt|;
else|else
name|check
operator|=
name|row_stride
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|opaque
operator|!=
name|NULL
operator|&&
name|buffer
operator|!=
name|NULL
operator|&&
name|check
operator|>=
name|PNG_IMAGE_ROW_STRIDE
argument_list|(
operator|*
name|image
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_COLORMAP
operator|)
operator|==
literal|0
operator|||
operator|(
name|image
operator|->
name|colormap_entries
operator|>
literal|0
operator|&&
name|colormap
operator|!=
name|NULL
operator|)
condition|)
block|{
name|int
name|result
decl_stmt|;
name|png_image_read_control
name|display
decl_stmt|;
name|memset
argument_list|(
operator|&
name|display
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
name|display
operator|)
argument_list|)
expr_stmt|;
name|display
operator|.
name|image
operator|=
name|image
expr_stmt|;
name|display
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|display
operator|.
name|row_stride
operator|=
name|row_stride
expr_stmt|;
name|display
operator|.
name|colormap
operator|=
name|colormap
expr_stmt|;
name|display
operator|.
name|background
operator|=
name|background
expr_stmt|;
name|display
operator|.
name|local_row
operator|=
name|NULL
expr_stmt|;
comment|/* Choose the correct 'end' routine; for the color-map case all the              * setup has already been done.              */
if|if
condition|(
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_COLORMAP
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_colormap
argument_list|,
operator|&
name|display
argument_list|)
operator|&&
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_colormapped
argument_list|,
operator|&
name|display
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_read_direct
argument_list|,
operator|&
name|display
argument_list|)
expr_stmt|;
name|png_image_free
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_finish_read[color-map]: no color-map"
argument_list|)
return|;
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_finish_read: invalid argument"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_finish_read: damaged PNG_IMAGE_VERSION"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SIMPLIFIED_READ */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ */
end_comment
end_unit
