begin_unit
begin_comment
comment|/* pngset.c - storage of image information into info struct  *  * Last changed in libpng 1.5.1 [February 3, 2011]  * Copyright (c) 1998-2011 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * The functions here are used during reads to store data from the file  * into the info struct, and during writes to store application data  * into the info struct for writing into the file.  This abstracts the  * info struct and allows us to change the structure in the future.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_bKGD_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_bKGD
name|png_set_bKGD
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_color_16p
name|background
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"bKGD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_memcpy
argument_list|(
operator|&
operator|(
name|info_ptr
operator|->
name|background
operator|)
argument_list|,
name|background
argument_list|,
name|png_sizeof
argument_list|(
name|png_color_16
argument_list|)
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_bKGD
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_cHRM_fixed
name|png_set_cHRM_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_fixed_point
name|white_x
parameter_list|,
name|png_fixed_point
name|white_y
parameter_list|,
name|png_fixed_point
name|red_x
parameter_list|,
name|png_fixed_point
name|red_y
parameter_list|,
name|png_fixed_point
name|green_x
parameter_list|,
name|png_fixed_point
name|green_y
parameter_list|,
name|png_fixed_point
name|blue_x
parameter_list|,
name|png_fixed_point
name|blue_y
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"cHRM fixed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_CHECK_cHRM_SUPPORTED
if|if
condition|(
name|png_check_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|white_x
argument_list|,
name|white_y
argument_list|,
name|red_x
argument_list|,
name|red_y
argument_list|,
name|green_x
argument_list|,
name|green_y
argument_list|,
name|blue_x
argument_list|,
name|blue_y
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|info_ptr
operator|->
name|x_white
operator|=
name|white_x
expr_stmt|;
name|info_ptr
operator|->
name|y_white
operator|=
name|white_y
expr_stmt|;
name|info_ptr
operator|->
name|x_red
operator|=
name|red_x
expr_stmt|;
name|info_ptr
operator|->
name|y_red
operator|=
name|red_y
expr_stmt|;
name|info_ptr
operator|->
name|x_green
operator|=
name|green_x
expr_stmt|;
name|info_ptr
operator|->
name|y_green
operator|=
name|green_y
expr_stmt|;
name|info_ptr
operator|->
name|x_blue
operator|=
name|blue_x
expr_stmt|;
name|info_ptr
operator|->
name|y_blue
operator|=
name|blue_y
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_cHRM
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_cHRM
name|png_set_cHRM
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|double
name|white_x
parameter_list|,
name|double
name|white_y
parameter_list|,
name|double
name|red_x
parameter_list|,
name|double
name|red_y
parameter_list|,
name|double
name|green_x
parameter_list|,
name|double
name|green_y
parameter_list|,
name|double
name|blue_x
parameter_list|,
name|double
name|blue_y
parameter_list|)
block|{
name|png_set_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|white_x
argument_list|,
literal|"cHRM White X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|white_y
argument_list|,
literal|"cHRM White Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red_x
argument_list|,
literal|"cHRM Red X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red_y
argument_list|,
literal|"cHRM Red Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green_x
argument_list|,
literal|"cHRM Green X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green_y
argument_list|,
literal|"cHRM Green Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|blue_x
argument_list|,
literal|"cHRM Blue X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|blue_y
argument_list|,
literal|"cHRM Blue Y"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_FLOATING_POINT_SUPPORTED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_cHRM_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_gAMA_fixed
name|png_set_gAMA_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_fixed_point
name|file_gamma
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"gAMA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Previously these values were limited, however they must be     * wrong, therefore storing them (and setting PNG_INFO_gAMA)     * must be wrong too.     */
if|if
condition|(
name|file_gamma
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Gamma too large, ignored"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|file_gamma
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Negative or zero gamma ignored"
argument_list|)
expr_stmt|;
else|else
block|{
name|info_ptr
operator|->
name|gamma
operator|=
name|file_gamma
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_gAMA
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_gAMA
name|png_set_gAMA
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|double
name|file_gamma
parameter_list|)
block|{
name|png_set_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|file_gamma
argument_list|,
literal|"png_set_gAMA"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_hIST
name|png_set_hIST
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_uint_16p
name|hist
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"hIST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|info_ptr
operator|->
name|num_palette
operator|==
literal|0
operator|||
name|info_ptr
operator|->
name|num_palette
operator|>
name|PNG_MAX_PALETTE_LENGTH
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette size, hIST allocation skipped"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_HIST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in     * version 1.2.1     */
name|png_ptr
operator|->
name|hist
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|PNG_MAX_PALETTE_LENGTH
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|hist
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for hIST chunk data"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_palette
condition|;
name|i
operator|++
control|)
name|png_ptr
operator|->
name|hist
index|[
name|i
index|]
operator|=
name|hist
index|[
name|i
index|]
expr_stmt|;
name|info_ptr
operator|->
name|hist
operator|=
name|png_ptr
operator|->
name|hist
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_hIST
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_HIST
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
name|PNGAPI
DECL|function|png_set_IHDR
name|png_set_IHDR
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|width
parameter_list|,
name|png_uint_32
name|height
parameter_list|,
name|int
name|bit_depth
parameter_list|,
name|int
name|color_type
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|int
name|filter_type
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"IHDR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|info_ptr
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|info_ptr
operator|->
name|bit_depth
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|info_ptr
operator|->
name|color_type
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
name|info_ptr
operator|->
name|compression_type
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
name|info_ptr
operator|->
name|filter_type
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
name|info_ptr
operator|->
name|interlace_type
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
name|png_check_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|width
argument_list|,
name|info_ptr
operator|->
name|height
argument_list|,
name|info_ptr
operator|->
name|bit_depth
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|,
name|info_ptr
operator|->
name|interlace_type
argument_list|,
name|info_ptr
operator|->
name|compression_type
argument_list|,
name|info_ptr
operator|->
name|filter_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|info_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
name|info_ptr
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
else|else
name|info_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
condition|)
name|info_ptr
operator|->
name|channels
operator|++
expr_stmt|;
name|info_ptr
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|info_ptr
operator|->
name|channels
operator|*
name|info_ptr
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
comment|/* Check for potential overflow */
if|if
condition|(
name|width
operator|>
operator|(
name|PNG_UINT_32_MAX
operator|>>
literal|3
operator|)
comment|/* 8-byte RRGGBBAA pixels */
operator|-
literal|48
comment|/* bigrowbuf hack */
operator|-
literal|1
comment|/* filter byte */
operator|-
literal|7
operator|*
literal|8
comment|/* rounding of width to multiple of 8 pixels */
operator|-
literal|8
condition|)
comment|/* extra max_pixel_depth pad */
name|info_ptr
operator|->
name|rowbytes
operator|=
literal|0
expr_stmt|;
else|else
name|info_ptr
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|info_ptr
operator|->
name|pixel_depth
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_oFFs_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_oFFs
name|png_set_oFFs
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_int_32
name|offset_x
parameter_list|,
name|png_int_32
name|offset_y
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"oFFs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|x_offset
operator|=
name|offset_x
expr_stmt|;
name|info_ptr
operator|->
name|y_offset
operator|=
name|offset_y
expr_stmt|;
name|info_ptr
operator|->
name|offset_unit_type
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_oFFs
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_pCAL
name|png_set_pCAL
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_charp
name|purpose
parameter_list|,
name|png_int_32
name|X0
parameter_list|,
name|png_int_32
name|X1
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|nparams
parameter_list|,
name|png_const_charp
name|units
parameter_list|,
name|png_charpp
name|params
parameter_list|)
block|{
name|png_size_t
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"pCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|length
operator|=
name|png_strlen
argument_list|(
name|purpose
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating purpose for info (%lu bytes)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
comment|/* TODO: validate format of calibration name and unit name */
comment|/* Check that the type matches the specification. */
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>
literal|3
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pCAL equation type"
argument_list|)
expr_stmt|;
comment|/* Validate params[nparams] */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|png_check_fp_string
argument_list|(
name|params
index|[
name|i
index|]
argument_list|,
name|png_strlen
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid format for pCAL parameter"
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_purpose
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_purpose
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL purpose"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|info_ptr
operator|->
name|pcal_purpose
argument_list|,
name|purpose
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"storing X0, X1, type, and nparams in info"
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_X0
operator|=
name|X0
expr_stmt|;
name|info_ptr
operator|->
name|pcal_X1
operator|=
name|X1
expr_stmt|;
name|info_ptr
operator|->
name|pcal_type
operator|=
operator|(
name|png_byte
operator|)
name|type
expr_stmt|;
name|info_ptr
operator|->
name|pcal_nparams
operator|=
operator|(
name|png_byte
operator|)
name|nparams
expr_stmt|;
name|length
operator|=
name|png_strlen
argument_list|(
name|units
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating units for info (%lu bytes)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_units
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_units
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL units"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|info_ptr
operator|->
name|pcal_units
argument_list|,
name|units
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
operator|=
operator|(
name|png_charpp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|nparams
operator|+
literal|1
operator|)
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_params
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL params"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memset
argument_list|(
name|info_ptr
operator|->
name|pcal_params
argument_list|,
literal|0
argument_list|,
operator|(
name|nparams
operator|+
literal|1
operator|)
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|length
operator|=
name|png_strlen
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_debug2
argument_list|(
literal|3
argument_list|,
literal|"allocating parameter %d for info (%lu bytes)"
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL parameter"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
argument_list|,
name|params
index|[
name|i
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_pCAL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_PCAL
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sCAL_s
name|png_set_sCAL_s
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|png_const_charp
name|swidth
parameter_list|,
name|png_const_charp
name|sheight
parameter_list|)
block|{
name|png_size_t
name|lengthw
init|=
literal|0
decl_stmt|,
name|lengthh
init|=
literal|0
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Double check the unit (should never get here with an invalid     * unit unless this is an API call.)     */
if|if
condition|(
name|unit
operator|!=
literal|1
operator|&&
name|unit
operator|!=
literal|2
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL unit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|swidth
operator|==
name|NULL
operator|||
operator|(
name|lengthw
operator|=
name|png_strlen
argument_list|(
name|swidth
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|swidth
index|[
literal|0
index|]
operator|==
literal|45
comment|/*'-'*/
operator|||
operator|!
name|png_check_fp_string
argument_list|(
name|swidth
argument_list|,
name|lengthw
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL width"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sheight
operator|==
name|NULL
operator|||
operator|(
name|lengthh
operator|=
name|png_strlen
argument_list|(
name|sheight
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|sheight
index|[
literal|0
index|]
operator|==
literal|45
comment|/*'-'*/
operator|||
operator|!
name|png_check_fp_string
argument_list|(
name|sheight
argument_list|,
name|lengthh
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL height"
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_unit
operator|=
operator|(
name|png_byte
operator|)
name|unit
expr_stmt|;
operator|++
name|lengthw
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating unit for info (%u bytes)"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|lengthw
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_width
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|lengthw
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|scal_s_width
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Memory allocation failed while processing sCAL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|info_ptr
operator|->
name|scal_s_width
argument_list|,
name|swidth
argument_list|,
name|lengthw
argument_list|)
expr_stmt|;
operator|++
name|lengthh
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating unit for info (%u bytes)"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|lengthh
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_height
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|lengthh
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|scal_s_height
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_width
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_width
operator|=
name|NULL
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Memory allocation failed while processing sCAL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|info_ptr
operator|->
name|scal_s_height
argument_list|,
name|sheight
argument_list|,
name|lengthh
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sCAL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_SCAL
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sCAL
name|png_set_sCAL
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|double
name|width
parameter_list|,
name|double
name|height
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sCAL"
argument_list|)
expr_stmt|;
comment|/* Check the arguments. */
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL width ignored"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL height ignored"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert 'width' and 'height' to ASCII. */
name|char
name|swidth
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|sheight
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|png_ascii_from_fp
argument_list|(
name|png_ptr
argument_list|,
name|swidth
argument_list|,
sizeof|sizeof
name|swidth
argument_list|,
name|width
argument_list|,
name|PNG_sCAL_PRECISION
argument_list|)
expr_stmt|;
name|png_ascii_from_fp
argument_list|(
name|png_ptr
argument_list|,
name|sheight
argument_list|,
sizeof|sizeof
name|sheight
argument_list|,
name|height
argument_list|,
name|PNG_sCAL_PRECISION
argument_list|)
expr_stmt|;
name|png_set_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|unit
argument_list|,
name|swidth
argument_list|,
name|sheight
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sCAL_fixed
name|png_set_sCAL_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|png_fixed_point
name|width
parameter_list|,
name|png_fixed_point
name|height
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sCAL"
argument_list|)
expr_stmt|;
comment|/* Check the arguments. */
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL width ignored"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL height ignored"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert 'width' and 'height' to ASCII. */
name|char
name|swidth
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|sheight
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|png_ascii_from_fixed
argument_list|(
name|png_ptr
argument_list|,
name|swidth
argument_list|,
sizeof|sizeof
name|swidth
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|png_ascii_from_fixed
argument_list|(
name|png_ptr
argument_list|,
name|sheight
argument_list|,
sizeof|sizeof
name|sheight
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|png_set_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|unit
argument_list|,
name|swidth
argument_list|,
name|sheight
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_pHYs
name|png_set_pHYs
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|res_x
parameter_list|,
name|png_uint_32
name|res_y
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"pHYs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|x_pixels_per_unit
operator|=
name|res_x
expr_stmt|;
name|info_ptr
operator|->
name|y_pixels_per_unit
operator|=
name|res_y
expr_stmt|;
name|info_ptr
operator|->
name|phys_unit_type
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_pHYs
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
name|PNGAPI
DECL|function|png_set_PLTE
name|png_set_PLTE
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_colorp
name|palette
parameter_list|,
name|int
name|num_palette
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|num_palette
operator|<
literal|0
operator|||
name|num_palette
operator|>
name|PNG_MAX_PALETTE_LENGTH
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette length"
argument_list|)
expr_stmt|;
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette length"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* It may not actually be necessary to set png_ptr->palette here;     * we do it for backward compatibility with the way the png_handle_tRNS     * function used to do the allocation.     */
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_PLTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead     * of num_palette entries, in case of an invalid PNG file that has     * too-large sample values.     */
name|png_ptr
operator|->
name|palette
operator|=
operator|(
name|png_colorp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|PNG_MAX_PALETTE_LENGTH
operator|*
name|png_sizeof
argument_list|(
name|png_color
argument_list|)
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|palette
argument_list|,
name|palette
argument_list|,
name|num_palette
operator|*
name|png_sizeof
argument_list|(
name|png_color
argument_list|)
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|palette
operator|=
name|png_ptr
operator|->
name|palette
expr_stmt|;
name|info_ptr
operator|->
name|num_palette
operator|=
name|png_ptr
operator|->
name|num_palette
operator|=
operator|(
name|png_uint_16
operator|)
name|num_palette
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_PLTE
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_PLTE
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sBIT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sBIT
name|png_set_sBIT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_color_8p
name|sig_bit
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sBIT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_memcpy
argument_list|(
operator|&
operator|(
name|info_ptr
operator|->
name|sig_bit
operator|)
argument_list|,
name|sig_bit
argument_list|,
name|png_sizeof
argument_list|(
name|png_color_8
argument_list|)
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sBIT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sRGB
name|png_set_sRGB
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|srgb_intent
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sRGB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|srgb_intent
operator|=
operator|(
name|png_byte
operator|)
name|srgb_intent
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sRGB
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sRGB_gAMA_and_cHRM
name|png_set_sRGB_gAMA_and_cHRM
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|srgb_intent
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sRGB_gAMA_and_cHRM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|srgb_intent
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
name|png_set_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
literal|45455L
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
name|png_set_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
comment|/* color      x       y */
comment|/* white */
literal|31270L
argument_list|,
literal|32900L
argument_list|,
comment|/* red   */
literal|64000L
argument_list|,
literal|33000L
argument_list|,
comment|/* green */
literal|30000L
argument_list|,
literal|60000L
argument_list|,
comment|/* blue  */
literal|15000L
argument_list|,
literal|6000L
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* cHRM */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* sRGB */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_iCCP
name|png_set_iCCP
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|png_const_bytep
name|profile
parameter_list|,
name|png_uint_32
name|proflen
parameter_list|)
block|{
name|png_charp
name|new_iccp_name
decl_stmt|;
name|png_bytep
name|new_iccp_profile
decl_stmt|;
name|png_uint_32
name|length
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"iCCP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|profile
operator|==
name|NULL
condition|)
return|return;
name|length
operator|=
name|png_strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|new_iccp_name
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_iccp_name
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to process iCCP chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|new_iccp_name
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|new_iccp_profile
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|proflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_iccp_profile
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_iccp_name
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to process iCCP profile"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|new_iccp_profile
argument_list|,
name|profile
argument_list|,
operator|(
name|png_size_t
operator|)
name|proflen
argument_list|)
expr_stmt|;
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ICCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|iccp_proflen
operator|=
name|proflen
expr_stmt|;
name|info_ptr
operator|->
name|iccp_name
operator|=
name|new_iccp_name
expr_stmt|;
name|info_ptr
operator|->
name|iccp_profile
operator|=
name|new_iccp_profile
expr_stmt|;
comment|/* Compression is always zero but is here so the API and info structure     * does not have to change if we introduce multiple compression types     */
name|info_ptr
operator|->
name|iccp_compression
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_ICCP
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_iCCP
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_text
name|png_set_text
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_textp
name|text_ptr
parameter_list|,
name|int
name|num_text
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
name|num_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to store text"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_set_text_2
name|png_set_text_2
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_textp
name|text_ptr
parameter_list|,
name|int
name|num_text
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
operator|(
operator|(
name|png_ptr
operator|==
name|NULL
operator|||
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"text"
else|:
operator|(
name|png_const_charp
operator|)
name|png_ptr
operator|->
name|chunk_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|num_text
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure we have enough space in the "text" array in info_struct     * to hold all of the incoming text_ptr objects.     */
if|if
condition|(
name|info_ptr
operator|->
name|num_text
operator|+
name|num_text
operator|>
name|info_ptr
operator|->
name|max_text
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|text
operator|!=
name|NULL
condition|)
block|{
name|png_textp
name|old_text
decl_stmt|;
name|int
name|old_max
decl_stmt|;
name|old_max
operator|=
name|info_ptr
operator|->
name|max_text
expr_stmt|;
name|info_ptr
operator|->
name|max_text
operator|=
name|info_ptr
operator|->
name|num_text
operator|+
name|num_text
operator|+
literal|8
expr_stmt|;
name|old_text
operator|=
name|info_ptr
operator|->
name|text
expr_stmt|;
name|info_ptr
operator|->
name|text
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|info_ptr
operator|->
name|max_text
operator|*
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|text
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_text
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|png_memcpy
argument_list|(
name|info_ptr
operator|->
name|text
argument_list|,
name|old_text
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|old_max
operator|*
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_ptr
operator|->
name|max_text
operator|=
name|num_text
operator|+
literal|8
expr_stmt|;
name|info_ptr
operator|->
name|num_text
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|text
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|info_ptr
operator|->
name|max_text
operator|*
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|text
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_TEXT
expr_stmt|;
block|}
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocated %d entries for info_ptr->text"
argument_list|,
name|info_ptr
operator|->
name|max_text
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_text
condition|;
name|i
operator|++
control|)
block|{
name|png_size_t
name|text_length
decl_stmt|,
name|key_len
decl_stmt|;
name|png_size_t
name|lang_len
decl_stmt|,
name|lang_key_len
decl_stmt|;
name|png_textp
name|textp
init|=
operator|&
operator|(
name|info_ptr
operator|->
name|text
index|[
name|info_ptr
operator|->
name|num_text
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|key
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|<
name|PNG_TEXT_COMPRESSION_NONE
operator|||
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|>=
name|PNG_TEXT_COMPRESSION_LAST
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"text compression mode is out of range"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|key_len
operator|=
name|png_strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|<=
literal|0
condition|)
block|{
name|lang_len
operator|=
literal|0
expr_stmt|;
name|lang_key_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
block|{
comment|/* Set iTXt data */
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang
operator|!=
name|NULL
condition|)
name|lang_len
operator|=
name|png_strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang
argument_list|)
expr_stmt|;
else|else
name|lang_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang_key
operator|!=
name|NULL
condition|)
name|lang_key_len
operator|=
name|png_strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|)
expr_stmt|;
else|else
name|lang_key_len
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* PNG_iTXt_SUPPORTED */
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"iTXt chunk not supported"
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
operator|==
name|NULL
operator|||
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|text_length
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
name|textp
operator|->
name|compression
operator|=
name|PNG_ITXT_COMPRESSION_NONE
expr_stmt|;
else|else
endif|#
directive|endif
name|textp
operator|->
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
block|}
else|else
block|{
name|text_length
operator|=
name|png_strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|textp
operator|->
name|compression
operator|=
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
expr_stmt|;
block|}
name|textp
operator|->
name|key
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|key_len
operator|+
name|text_length
operator|+
name|lang_len
operator|+
name|lang_key_len
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|textp
operator|->
name|key
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|png_debug2
argument_list|(
literal|2
argument_list|,
literal|"Allocated %lu bytes at %p in png_set_text"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|png_uint_32
argument_list|)
argument_list|(
name|key_len
operator|+
name|lang_len
operator|+
name|lang_key_len
operator|+
name|text_length
operator|+
literal|4
argument_list|)
argument_list|,
name|textp
operator|->
name|key
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|textp
operator|->
name|key
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|key
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|key_len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|key
operator|+
name|key_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
block|{
name|textp
operator|->
name|lang
operator|=
name|textp
operator|->
name|key
operator|+
name|key_len
operator|+
literal|1
expr_stmt|;
name|png_memcpy
argument_list|(
name|textp
operator|->
name|lang
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang
argument_list|,
name|lang_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|lang
operator|+
name|lang_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|textp
operator|->
name|lang_key
operator|=
name|textp
operator|->
name|lang
operator|+
name|lang_len
operator|+
literal|1
expr_stmt|;
name|png_memcpy
argument_list|(
name|textp
operator|->
name|lang_key
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|,
name|lang_key_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|lang_key
operator|+
name|lang_key_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|textp
operator|->
name|text
operator|=
name|textp
operator|->
name|lang_key
operator|+
name|lang_key_len
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|textp
operator|->
name|lang
operator|=
name|NULL
expr_stmt|;
name|textp
operator|->
name|lang_key
operator|=
name|NULL
expr_stmt|;
name|textp
operator|->
name|text
operator|=
name|textp
operator|->
name|key
operator|+
name|key_len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|text_length
condition|)
name|png_memcpy
argument_list|(
name|textp
operator|->
name|text
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|text_length
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|text
operator|+
name|text_length
operator|)
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
if|if
condition|(
name|textp
operator|->
name|compression
operator|>
literal|0
condition|)
block|{
name|textp
operator|->
name|text_length
operator|=
literal|0
expr_stmt|;
name|textp
operator|->
name|itxt_length
operator|=
name|text_length
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|textp
operator|->
name|text_length
operator|=
name|text_length
expr_stmt|;
name|textp
operator|->
name|itxt_length
operator|=
literal|0
expr_stmt|;
block|}
name|info_ptr
operator|->
name|num_text
operator|++
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"transferred text chunk %d"
argument_list|,
name|info_ptr
operator|->
name|num_text
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_tIME
name|png_set_tIME
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_timep
name|mod_time
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"tIME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_tIME
operator|)
condition|)
return|return;
name|png_memcpy
argument_list|(
operator|&
operator|(
name|info_ptr
operator|->
name|mod_time
operator|)
argument_list|,
name|mod_time
argument_list|,
name|png_sizeof
argument_list|(
name|png_time
argument_list|)
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_tIME
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_tRNS
name|png_set_tRNS
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_bytep
name|trans_alpha
parameter_list|,
name|int
name|num_trans
parameter_list|,
name|png_const_color_16p
name|trans_color
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"tRNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|trans_alpha
operator|!=
name|NULL
condition|)
block|{
comment|/* It may not actually be necessary to set png_ptr->trans_alpha here;         * we do it for backward compatibility with the way the png_handle_tRNS         * function used to do the allocation.         */
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_TRNS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
name|png_ptr
operator|->
name|trans_alpha
operator|=
name|info_ptr
operator|->
name|trans_alpha
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_size_t
operator|)
name|PNG_MAX_PALETTE_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_trans
operator|>
literal|0
operator|&&
name|num_trans
operator|<=
name|PNG_MAX_PALETTE_LENGTH
condition|)
name|png_memcpy
argument_list|(
name|info_ptr
operator|->
name|trans_alpha
argument_list|,
name|trans_alpha
argument_list|,
operator|(
name|png_size_t
operator|)
name|num_trans
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trans_color
operator|!=
name|NULL
condition|)
block|{
name|int
name|sample_max
init|=
operator|(
literal|1
operator|<<
name|info_ptr
operator|->
name|bit_depth
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|&&
operator|(
name|int
operator|)
name|trans_color
operator|->
name|gray
operator|>
name|sample_max
operator|)
operator|||
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|&&
operator|(
operator|(
name|int
operator|)
name|trans_color
operator|->
name|red
operator|>
name|sample_max
operator|||
operator|(
name|int
operator|)
name|trans_color
operator|->
name|green
operator|>
name|sample_max
operator|||
operator|(
name|int
operator|)
name|trans_color
operator|->
name|blue
operator|>
name|sample_max
operator|)
operator|)
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"tRNS chunk has out-of-range samples for bit_depth"
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
operator|&
operator|(
name|info_ptr
operator|->
name|trans_color
operator|)
argument_list|,
name|trans_color
argument_list|,
name|png_sizeof
argument_list|(
name|png_color_16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_trans
operator|==
literal|0
condition|)
name|num_trans
operator|=
literal|1
expr_stmt|;
block|}
name|info_ptr
operator|->
name|num_trans
operator|=
operator|(
name|png_uint_16
operator|)
name|num_trans
expr_stmt|;
if|if
condition|(
name|num_trans
operator|!=
literal|0
condition|)
block|{
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_tRNS
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_TRNS
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sPLT
name|png_set_sPLT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_sPLT_tp
name|entries
parameter_list|,
name|int
name|nentries
parameter_list|)
comment|/*  *  entries        - array of png_sPLT_t structures  *                   to be added to the list of palettes  *                   in the info structure.  *  *  nentries       - number of palette structures to be  *                   added.  */
block|{
name|png_sPLT_tp
name|np
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|np
operator|=
operator|(
name|png_sPLT_tp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|info_ptr
operator|->
name|splt_palettes_num
operator|+
name|nentries
operator|)
operator|*
operator|(
name|png_size_t
operator|)
name|png_sizeof
argument_list|(
name|png_sPLT_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No memory for sPLT palettes"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|np
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
argument_list|,
name|info_ptr
operator|->
name|splt_palettes_num
operator|*
name|png_sizeof
argument_list|(
name|png_sPLT_t
argument_list|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|png_sPLT_tp
name|to
init|=
name|np
operator|+
name|info_ptr
operator|->
name|splt_palettes_num
operator|+
name|i
decl_stmt|;
name|png_const_sPLT_tp
name|from
init|=
name|entries
operator|+
name|i
decl_stmt|;
name|png_uint_32
name|length
decl_stmt|;
name|length
operator|=
name|png_strlen
argument_list|(
name|from
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|to
operator|->
name|name
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_size_t
operator|)
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of memory while processing sPLT chunk"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|png_memcpy
argument_list|(
name|to
operator|->
name|name
argument_list|,
name|from
operator|->
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|to
operator|->
name|entries
operator|=
operator|(
name|png_sPLT_entryp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|from
operator|->
name|nentries
operator|*
name|png_sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of memory while processing sPLT chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|to
operator|->
name|name
argument_list|)
expr_stmt|;
name|to
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|png_memcpy
argument_list|(
name|to
operator|->
name|entries
argument_list|,
name|from
operator|->
name|entries
argument_list|,
name|from
operator|->
name|nentries
operator|*
name|png_sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|nentries
operator|=
name|from
operator|->
name|nentries
expr_stmt|;
name|to
operator|->
name|depth
operator|=
name|from
operator|->
name|depth
expr_stmt|;
block|}
name|info_ptr
operator|->
name|splt_palettes
operator|=
name|np
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes_num
operator|+=
name|nentries
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sPLT
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_SPLT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_sPLT_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_unknown_chunks
name|png_set_unknown_chunks
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_const_unknown_chunkp
name|unknowns
parameter_list|,
name|int
name|num_unknowns
parameter_list|)
block|{
name|png_unknown_chunkp
name|np
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|num_unknowns
operator|==
literal|0
condition|)
return|return;
name|np
operator|=
operator|(
name|png_unknown_chunkp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|info_ptr
operator|->
name|unknown_chunks_num
operator|+
name|num_unknowns
argument_list|)
operator|*
name|png_sizeof
argument_list|(
name|png_unknown_chunk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of memory while processing unknown chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_memcpy
argument_list|(
name|np
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
argument_list|,
operator|(
name|png_size_t
operator|)
name|info_ptr
operator|->
name|unknown_chunks_num
operator|*
name|png_sizeof
argument_list|(
name|png_unknown_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_unknowns
condition|;
name|i
operator|++
control|)
block|{
name|png_unknown_chunkp
name|to
init|=
name|np
operator|+
name|info_ptr
operator|->
name|unknown_chunks_num
operator|+
name|i
decl_stmt|;
name|png_const_unknown_chunkp
name|from
init|=
name|unknowns
operator|+
name|i
decl_stmt|;
name|png_memcpy
argument_list|(
name|to
operator|->
name|name
argument_list|,
name|from
operator|->
name|name
argument_list|,
name|png_sizeof
argument_list|(
name|from
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|name
index|[
name|png_sizeof
argument_list|(
name|to
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|to
operator|->
name|size
operator|=
name|from
operator|->
name|size
expr_stmt|;
comment|/* Note our location in the read or write sequence */
name|to
operator|->
name|location
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|mode
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|size
operator|==
literal|0
condition|)
name|to
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|to
operator|->
name|data
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_size_t
operator|)
name|from
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of memory while processing unknown chunk"
argument_list|)
expr_stmt|;
name|to
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|png_memcpy
argument_list|(
name|to
operator|->
name|data
argument_list|,
name|from
operator|->
name|data
argument_list|,
name|from
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|info_ptr
operator|->
name|unknown_chunks
operator|=
name|np
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks_num
operator|+=
name|num_unknowns
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_UNKN
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_unknown_chunk_location
name|png_set_unknown_chunk_location
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|chunk
parameter_list|,
name|int
name|location
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|info_ptr
operator|!=
name|NULL
operator|&&
name|chunk
operator|>=
literal|0
operator|&&
name|chunk
operator|<
name|info_ptr
operator|->
name|unknown_chunks_num
condition|)
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|chunk
index|]
operator|.
name|location
operator|=
operator|(
name|png_byte
operator|)
name|location
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
end_ifdef
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_permit_mng_features
name|png_permit_mng_features
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|mng_features
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_permit_mng_features"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|png_uint_32
operator|)
literal|0
return|;
name|png_ptr
operator|->
name|mng_features_permitted
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|mng_features
operator|&
name|PNG_ALL_MNG_FEATURES
argument_list|)
expr_stmt|;
return|return
operator|(
name|png_uint_32
operator|)
name|png_ptr
operator|->
name|mng_features_permitted
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_keep_unknown_chunks
name|png_set_keep_unknown_chunks
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|keep
parameter_list|,
name|png_const_bytep
name|chunk_list
parameter_list|,
name|int
name|num_chunks
parameter_list|)
block|{
name|png_bytep
name|new_list
decl_stmt|,
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|old_num_chunks
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|num_chunks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|||
name|keep
operator|==
name|PNG_HANDLE_CHUNK_IF_SAFE
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_KEEP_UNKNOWN_CHUNKS
expr_stmt|;
else|else
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_KEEP_UNKNOWN_CHUNKS
expr_stmt|;
if|if
condition|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_KEEP_UNSAFE_CHUNKS
expr_stmt|;
else|else
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_KEEP_UNSAFE_CHUNKS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chunk_list
operator|==
name|NULL
condition|)
return|return;
name|old_num_chunks
operator|=
name|png_ptr
operator|->
name|num_chunk_list
expr_stmt|;
name|new_list
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
literal|5
operator|*
operator|(
name|num_chunks
operator|+
name|old_num_chunks
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunk_list
operator|!=
name|NULL
condition|)
block|{
name|png_memcpy
argument_list|(
name|new_list
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
literal|5
operator|*
name|old_num_chunks
argument_list|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_list
operator|=
name|NULL
expr_stmt|;
block|}
name|png_memcpy
argument_list|(
name|new_list
operator|+
literal|5
operator|*
name|old_num_chunks
argument_list|,
name|chunk_list
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
literal|5
operator|*
name|num_chunks
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|new_list
operator|+
literal|5
operator|*
name|old_num_chunks
operator|+
literal|4
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|5
control|)
operator|*
name|p
operator|=
operator|(
name|png_byte
operator|)
name|keep
expr_stmt|;
name|png_ptr
operator|->
name|num_chunk_list
operator|=
name|old_num_chunks
operator|+
name|num_chunks
expr_stmt|;
name|png_ptr
operator|->
name|chunk_list
operator|=
name|new_list
expr_stmt|;
name|png_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_LIST
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_read_user_chunk_fn
name|png_set_read_user_chunk_fn
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_voidp
name|user_chunk_ptr
parameter_list|,
name|png_user_chunk_ptr
name|read_user_chunk_fn
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_read_user_chunk_fn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|=
name|read_user_chunk_fn
expr_stmt|;
name|png_ptr
operator|->
name|user_chunk_ptr
operator|=
name|user_chunk_ptr
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_rows
name|png_set_rows
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_bytepp
name|row_pointers
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|info_ptr
operator|->
name|row_pointers
operator|&&
operator|(
name|info_ptr
operator|->
name|row_pointers
operator|!=
name|row_pointers
operator|)
condition|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|row_pointers
operator|=
name|row_pointers
expr_stmt|;
if|if
condition|(
name|row_pointers
condition|)
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_IDAT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_buffer_size
name|png_set_compression_buffer_size
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ZLIB_IO_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Attempt to set buffer size beyond max ignored"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zbuf_size
operator|=
name|ZLIB_IO_MAX
expr_stmt|;
name|size
operator|=
name|ZLIB_IO_MAX
expr_stmt|;
comment|/* must fit */
block|}
else|else
name|png_ptr
operator|->
name|zbuf_size
operator|=
operator|(
name|uInt
operator|)
name|size
expr_stmt|;
name|png_ptr
operator|->
name|zbuf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* The following ensures a relatively safe failure if this gets called while      * the buffer is actually in use.      */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_invalid
name|png_set_invalid
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|&&
name|info_ptr
condition|)
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
end_ifdef
begin_comment
comment|/* This function was added to libpng 1.2.6 */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_user_limits
name|png_set_user_limits
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|user_width_max
parameter_list|,
name|png_uint_32
name|user_height_max
parameter_list|)
block|{
comment|/* Images with dimensions larger than these limits will be     * rejected by png_set_IHDR().  To accept any PNG datastream     * regardless of dimensions, set both limits to 0x7ffffffL.     */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|user_width_max
operator|=
name|user_width_max
expr_stmt|;
name|png_ptr
operator|->
name|user_height_max
operator|=
name|user_height_max
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This function was added to libpng 1.4.0 */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_chunk_cache_max
name|png_set_chunk_cache_max
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|user_chunk_cache_max
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
condition|)
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|=
name|user_chunk_cache_max
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This function was added to libpng 1.4.1 */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_chunk_malloc_max
name|png_set_chunk_malloc_max
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_alloc_size_t
name|user_chunk_malloc_max
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
condition|)
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|=
name|user_chunk_malloc_max
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ?PNG_SET_USER_LIMITS_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_benign_errors
name|png_set_benign_errors
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|allowed
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_benign_errors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowed
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_BENIGN_ERRORS_WARN
expr_stmt|;
else|else
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_BENIGN_ERRORS_WARN
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_BENIGN_ERRORS_SUPPORTED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
end_comment
end_unit
