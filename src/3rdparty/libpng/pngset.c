begin_unit
begin_comment
comment|/* pngset.c - storage of image information into info struct  *  * Last changed in libpng 1.6.17 [March 26, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * The functions here are used during reads to store data from the file  * into the info struct, and during writes to store application data  * into the info struct for writing into the file.  This abstracts the  * info struct and allows us to change the structure in the future.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_bKGD_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_bKGD
name|png_set_bKGD
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_color_16p
name|background
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"bKGD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|background
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|background
operator|=
operator|*
name|background
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_bKGD
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_cHRM_fixed
name|png_set_cHRM_fixed
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_fixed_point
name|white_x
parameter_list|,
name|png_fixed_point
name|white_y
parameter_list|,
name|png_fixed_point
name|red_x
parameter_list|,
name|png_fixed_point
name|red_y
parameter_list|,
name|png_fixed_point
name|green_x
parameter_list|,
name|png_fixed_point
name|green_y
parameter_list|,
name|png_fixed_point
name|blue_x
parameter_list|,
name|png_fixed_point
name|blue_y
parameter_list|)
block|{
name|png_xy
name|xy
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"cHRM fixed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|xy
operator|.
name|redx
operator|=
name|red_x
expr_stmt|;
name|xy
operator|.
name|redy
operator|=
name|red_y
expr_stmt|;
name|xy
operator|.
name|greenx
operator|=
name|green_x
expr_stmt|;
name|xy
operator|.
name|greeny
operator|=
name|green_y
expr_stmt|;
name|xy
operator|.
name|bluex
operator|=
name|blue_x
expr_stmt|;
name|xy
operator|.
name|bluey
operator|=
name|blue_y
expr_stmt|;
name|xy
operator|.
name|whitex
operator|=
name|white_x
expr_stmt|;
name|xy
operator|.
name|whitey
operator|=
name|white_y
expr_stmt|;
if|if
condition|(
name|png_colorspace_set_chromaticities
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|colorspace
argument_list|,
operator|&
name|xy
argument_list|,
literal|2
comment|/* override with app values*/
argument_list|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_FROM_cHRM
expr_stmt|;
name|png_colorspace_sync_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_cHRM_XYZ_fixed
name|png_set_cHRM_XYZ_fixed
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_fixed_point
name|int_red_X
parameter_list|,
name|png_fixed_point
name|int_red_Y
parameter_list|,
name|png_fixed_point
name|int_red_Z
parameter_list|,
name|png_fixed_point
name|int_green_X
parameter_list|,
name|png_fixed_point
name|int_green_Y
parameter_list|,
name|png_fixed_point
name|int_green_Z
parameter_list|,
name|png_fixed_point
name|int_blue_X
parameter_list|,
name|png_fixed_point
name|int_blue_Y
parameter_list|,
name|png_fixed_point
name|int_blue_Z
parameter_list|)
block|{
name|png_XYZ
name|XYZ
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"cHRM XYZ fixed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|XYZ
operator|.
name|red_X
operator|=
name|int_red_X
expr_stmt|;
name|XYZ
operator|.
name|red_Y
operator|=
name|int_red_Y
expr_stmt|;
name|XYZ
operator|.
name|red_Z
operator|=
name|int_red_Z
expr_stmt|;
name|XYZ
operator|.
name|green_X
operator|=
name|int_green_X
expr_stmt|;
name|XYZ
operator|.
name|green_Y
operator|=
name|int_green_Y
expr_stmt|;
name|XYZ
operator|.
name|green_Z
operator|=
name|int_green_Z
expr_stmt|;
name|XYZ
operator|.
name|blue_X
operator|=
name|int_blue_X
expr_stmt|;
name|XYZ
operator|.
name|blue_Y
operator|=
name|int_blue_Y
expr_stmt|;
name|XYZ
operator|.
name|blue_Z
operator|=
name|int_blue_Z
expr_stmt|;
if|if
condition|(
name|png_colorspace_set_endpoints
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|colorspace
argument_list|,
operator|&
name|XYZ
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_FROM_cHRM
expr_stmt|;
name|png_colorspace_sync_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_cHRM
name|png_set_cHRM
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|double
name|white_x
parameter_list|,
name|double
name|white_y
parameter_list|,
name|double
name|red_x
parameter_list|,
name|double
name|red_y
parameter_list|,
name|double
name|green_x
parameter_list|,
name|double
name|green_y
parameter_list|,
name|double
name|blue_x
parameter_list|,
name|double
name|blue_y
parameter_list|)
block|{
name|png_set_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|white_x
argument_list|,
literal|"cHRM White X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|white_y
argument_list|,
literal|"cHRM White Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red_x
argument_list|,
literal|"cHRM Red X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red_y
argument_list|,
literal|"cHRM Red Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green_x
argument_list|,
literal|"cHRM Green X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green_y
argument_list|,
literal|"cHRM Green Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|blue_x
argument_list|,
literal|"cHRM Blue X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|blue_y
argument_list|,
literal|"cHRM Blue Y"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_cHRM_XYZ
name|png_set_cHRM_XYZ
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|double
name|red_X
parameter_list|,
name|double
name|red_Y
parameter_list|,
name|double
name|red_Z
parameter_list|,
name|double
name|green_X
parameter_list|,
name|double
name|green_Y
parameter_list|,
name|double
name|green_Z
parameter_list|,
name|double
name|blue_X
parameter_list|,
name|double
name|blue_Y
parameter_list|,
name|double
name|blue_Z
parameter_list|)
block|{
name|png_set_cHRM_XYZ_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red_X
argument_list|,
literal|"cHRM Red X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red_Y
argument_list|,
literal|"cHRM Red Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red_Z
argument_list|,
literal|"cHRM Red Z"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green_X
argument_list|,
literal|"cHRM Red X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green_Y
argument_list|,
literal|"cHRM Red Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green_Z
argument_list|,
literal|"cHRM Red Z"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|blue_X
argument_list|,
literal|"cHRM Red X"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|blue_Y
argument_list|,
literal|"cHRM Red Y"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|blue_Z
argument_list|,
literal|"cHRM Red Z"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* cHRM */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_gAMA_fixed
name|png_set_gAMA_fixed
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_fixed_point
name|file_gamma
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"gAMA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_colorspace_set_gamma
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|colorspace
argument_list|,
name|file_gamma
argument_list|)
expr_stmt|;
name|png_colorspace_sync_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_gAMA
name|png_set_gAMA
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|double
name|file_gamma
parameter_list|)
block|{
name|png_set_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|file_gamma
argument_list|,
literal|"png_set_gAMA"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_hIST
name|png_set_hIST
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_uint_16p
name|hist
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"hIST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|info_ptr
operator|->
name|num_palette
operator|==
literal|0
operator|||
name|info_ptr
operator|->
name|num_palette
operator|>
name|PNG_MAX_PALETTE_LENGTH
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette size, hIST allocation skipped"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_HIST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in     * version 1.2.1     */
name|info_ptr
operator|->
name|hist
operator|=
name|png_voidcast
argument_list|(
name|png_uint_16p
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|PNG_MAX_PALETTE_LENGTH
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|hist
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for hIST chunk data"
argument_list|)
expr_stmt|;
return|return;
block|}
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_HIST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_palette
condition|;
name|i
operator|++
control|)
name|info_ptr
operator|->
name|hist
index|[
name|i
index|]
operator|=
name|hist
index|[
name|i
index|]
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_hIST
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
name|PNGAPI
DECL|function|png_set_IHDR
name|png_set_IHDR
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|width
parameter_list|,
name|png_uint_32
name|height
parameter_list|,
name|int
name|bit_depth
parameter_list|,
name|int
name|color_type
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|int
name|filter_type
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"IHDR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|info_ptr
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|info_ptr
operator|->
name|bit_depth
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|info_ptr
operator|->
name|color_type
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
name|info_ptr
operator|->
name|compression_type
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
name|info_ptr
operator|->
name|filter_type
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
name|info_ptr
operator|->
name|interlace_type
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
name|png_check_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|width
argument_list|,
name|info_ptr
operator|->
name|height
argument_list|,
name|info_ptr
operator|->
name|bit_depth
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|,
name|info_ptr
operator|->
name|interlace_type
argument_list|,
name|info_ptr
operator|->
name|compression_type
argument_list|,
name|info_ptr
operator|->
name|filter_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|info_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
else|else
name|info_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|channels
operator|++
expr_stmt|;
name|info_ptr
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|info_ptr
operator|->
name|channels
operator|*
name|info_ptr
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|info_ptr
operator|->
name|pixel_depth
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_oFFs_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_oFFs
name|png_set_oFFs
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_int_32
name|offset_x
parameter_list|,
name|png_int_32
name|offset_y
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"oFFs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|x_offset
operator|=
name|offset_x
expr_stmt|;
name|info_ptr
operator|->
name|y_offset
operator|=
name|offset_y
expr_stmt|;
name|info_ptr
operator|->
name|offset_unit_type
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_oFFs
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_pCAL
name|png_set_pCAL
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_charp
name|purpose
parameter_list|,
name|png_int_32
name|X0
parameter_list|,
name|png_int_32
name|X1
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|nparams
parameter_list|,
name|png_const_charp
name|units
parameter_list|,
name|png_charpp
name|params
parameter_list|)
block|{
name|png_size_t
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"pCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|purpose
operator|==
name|NULL
operator|||
name|units
operator|==
name|NULL
operator|||
operator|(
name|nparams
operator|>
literal|0
operator|&&
name|params
operator|==
name|NULL
operator|)
condition|)
return|return;
name|length
operator|=
name|strlen
argument_list|(
name|purpose
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating purpose for info (%lu bytes)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
comment|/* TODO: validate format of calibration name and unit name */
comment|/* Check that the type matches the specification. */
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>
literal|3
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pCAL equation type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparams
operator|<
literal|0
operator|||
name|nparams
operator|>
literal|255
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pCAL parameter count"
argument_list|)
expr_stmt|;
comment|/* Validate params[nparams] */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|==
name|NULL
operator|||
operator|!
name|png_check_fp_string
argument_list|(
name|params
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid format for pCAL parameter"
argument_list|)
expr_stmt|;
block|}
name|info_ptr
operator|->
name|pcal_purpose
operator|=
name|png_voidcast
argument_list|(
name|png_charp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_purpose
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL purpose"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|info_ptr
operator|->
name|pcal_purpose
argument_list|,
name|purpose
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"storing X0, X1, type, and nparams in info"
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_X0
operator|=
name|X0
expr_stmt|;
name|info_ptr
operator|->
name|pcal_X1
operator|=
name|X1
expr_stmt|;
name|info_ptr
operator|->
name|pcal_type
operator|=
operator|(
name|png_byte
operator|)
name|type
expr_stmt|;
name|info_ptr
operator|->
name|pcal_nparams
operator|=
operator|(
name|png_byte
operator|)
name|nparams
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|units
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating units for info (%lu bytes)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_units
operator|=
name|png_voidcast
argument_list|(
name|png_charp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_units
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL units"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|info_ptr
operator|->
name|pcal_units
argument_list|,
name|units
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
operator|=
name|png_voidcast
argument_list|(
name|png_charpp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|nparams
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_charp
argument_list|)
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_params
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL params"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|info_ptr
operator|->
name|pcal_params
argument_list|,
literal|0
argument_list|,
operator|(
name|nparams
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_charp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_debug2
argument_list|(
literal|3
argument_list|,
literal|"allocating parameter %d for info (%lu bytes)"
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for pCAL parameter"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
argument_list|,
name|params
index|[
name|i
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_pCAL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_PCAL
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sCAL_s
name|png_set_sCAL_s
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|png_const_charp
name|swidth
parameter_list|,
name|png_const_charp
name|sheight
parameter_list|)
block|{
name|png_size_t
name|lengthw
init|=
literal|0
decl_stmt|,
name|lengthh
init|=
literal|0
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Double check the unit (should never get here with an invalid     * unit unless this is an API call.)     */
if|if
condition|(
name|unit
operator|!=
literal|1
operator|&&
name|unit
operator|!=
literal|2
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL unit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|swidth
operator|==
name|NULL
operator|||
operator|(
name|lengthw
operator|=
name|strlen
argument_list|(
name|swidth
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|swidth
index|[
literal|0
index|]
operator|==
literal|45
comment|/* '-' */
operator|||
operator|!
name|png_check_fp_string
argument_list|(
name|swidth
argument_list|,
name|lengthw
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL width"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sheight
operator|==
name|NULL
operator|||
operator|(
name|lengthh
operator|=
name|strlen
argument_list|(
name|sheight
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|sheight
index|[
literal|0
index|]
operator|==
literal|45
comment|/* '-' */
operator|||
operator|!
name|png_check_fp_string
argument_list|(
name|sheight
argument_list|,
name|lengthh
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL height"
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_unit
operator|=
operator|(
name|png_byte
operator|)
name|unit
expr_stmt|;
operator|++
name|lengthw
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating unit for info (%u bytes)"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|lengthw
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_width
operator|=
name|png_voidcast
argument_list|(
name|png_charp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|lengthw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|scal_s_width
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Memory allocation failed while processing sCAL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|info_ptr
operator|->
name|scal_s_width
argument_list|,
name|swidth
argument_list|,
name|lengthw
argument_list|)
expr_stmt|;
operator|++
name|lengthh
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocating unit for info (%u bytes)"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|lengthh
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_height
operator|=
name|png_voidcast
argument_list|(
name|png_charp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|lengthh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|scal_s_height
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_width
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_width
operator|=
name|NULL
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Memory allocation failed while processing sCAL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|info_ptr
operator|->
name|scal_s_height
argument_list|,
name|sheight
argument_list|,
name|lengthh
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sCAL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_SCAL
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sCAL
name|png_set_sCAL
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|double
name|width
parameter_list|,
name|double
name|height
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sCAL"
argument_list|)
expr_stmt|;
comment|/* Check the arguments. */
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL width ignored"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL height ignored"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert 'width' and 'height' to ASCII. */
name|char
name|swidth
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|sheight
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|png_ascii_from_fp
argument_list|(
name|png_ptr
argument_list|,
name|swidth
argument_list|,
operator|(
sizeof|sizeof
name|swidth
operator|)
argument_list|,
name|width
argument_list|,
name|PNG_sCAL_PRECISION
argument_list|)
expr_stmt|;
name|png_ascii_from_fp
argument_list|(
name|png_ptr
argument_list|,
name|sheight
argument_list|,
operator|(
sizeof|sizeof
name|sheight
operator|)
argument_list|,
name|height
argument_list|,
name|PNG_sCAL_PRECISION
argument_list|)
expr_stmt|;
name|png_set_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|unit
argument_list|,
name|swidth
argument_list|,
name|sheight
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sCAL_fixed
name|png_set_sCAL_fixed
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|png_fixed_point
name|width
parameter_list|,
name|png_fixed_point
name|height
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sCAL"
argument_list|)
expr_stmt|;
comment|/* Check the arguments. */
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL width ignored"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL height ignored"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert 'width' and 'height' to ASCII. */
name|char
name|swidth
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|sheight
index|[
name|PNG_sCAL_MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|png_ascii_from_fixed
argument_list|(
name|png_ptr
argument_list|,
name|swidth
argument_list|,
operator|(
sizeof|sizeof
name|swidth
operator|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|png_ascii_from_fixed
argument_list|(
name|png_ptr
argument_list|,
name|sheight
argument_list|,
operator|(
sizeof|sizeof
name|sheight
operator|)
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|png_set_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|unit
argument_list|,
name|swidth
argument_list|,
name|sheight
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_pHYs
name|png_set_pHYs
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|res_x
parameter_list|,
name|png_uint_32
name|res_y
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"pHYs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|x_pixels_per_unit
operator|=
name|res_x
expr_stmt|;
name|info_ptr
operator|->
name|y_pixels_per_unit
operator|=
name|res_y
expr_stmt|;
name|info_ptr
operator|->
name|phys_unit_type
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_pHYs
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
name|PNGAPI
DECL|function|png_set_PLTE
name|png_set_PLTE
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_colorp
name|palette
parameter_list|,
name|int
name|num_palette
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|num_palette
operator|<
literal|0
operator|||
name|num_palette
operator|>
name|PNG_MAX_PALETTE_LENGTH
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette length"
argument_list|)
expr_stmt|;
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette length"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|num_palette
operator|>
literal|0
operator|&&
name|palette
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_palette
operator|==
literal|0
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
operator|&&
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_EMPTY_PLTE
operator|)
operator|==
literal|0
endif|#
directive|endif
operator|)
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette"
argument_list|)
expr_stmt|;
block|}
comment|/* It may not actually be necessary to set png_ptr->palette here;     * we do it for backward compatibility with the way the png_handle_tRNS     * function used to do the allocation.     *     * 1.6.0: the above statement appears to be incorrect; something has to set     * the palette inside png_struct on read.     */
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_PLTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead     * of num_palette entries, in case of an invalid PNG file that has     * too-large sample values.     */
name|png_ptr
operator|->
name|palette
operator|=
name|png_voidcast
argument_list|(
name|png_colorp
argument_list|,
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|PNG_MAX_PALETTE_LENGTH
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_color
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_palette
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|png_ptr
operator|->
name|palette
argument_list|,
name|palette
argument_list|,
name|num_palette
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_color
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|palette
operator|=
name|png_ptr
operator|->
name|palette
expr_stmt|;
name|info_ptr
operator|->
name|num_palette
operator|=
name|png_ptr
operator|->
name|num_palette
operator|=
operator|(
name|png_uint_16
operator|)
name|num_palette
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_PLTE
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_PLTE
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sBIT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sBIT
name|png_set_sBIT
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_color_8p
name|sig_bit
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sBIT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|sig_bit
operator|==
name|NULL
condition|)
return|return;
name|info_ptr
operator|->
name|sig_bit
operator|=
operator|*
name|sig_bit
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sBIT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sRGB
name|png_set_sRGB
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|srgb_intent
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sRGB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|png_colorspace_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|colorspace
argument_list|,
name|srgb_intent
argument_list|)
expr_stmt|;
name|png_colorspace_sync_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sRGB_gAMA_and_cHRM
name|png_set_sRGB_gAMA_and_cHRM
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|srgb_intent
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"sRGB_gAMA_and_cHRM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|png_colorspace_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|colorspace
argument_list|,
name|srgb_intent
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This causes the gAMA and cHRM to be written too */
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_FROM_gAMA
operator||
name|PNG_COLORSPACE_FROM_cHRM
expr_stmt|;
block|}
name|png_colorspace_sync_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* sRGB */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_iCCP
name|png_set_iCCP
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|png_const_bytep
name|profile
parameter_list|,
name|png_uint_32
name|proflen
parameter_list|)
block|{
name|png_charp
name|new_iccp_name
decl_stmt|;
name|png_bytep
name|new_iccp_profile
decl_stmt|;
name|png_size_t
name|length
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"iCCP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|profile
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|compression_type
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid iCCP compression method"
argument_list|)
expr_stmt|;
comment|/* Set the colorspace first because this validates the profile; do not     * override previously set app cHRM or gAMA here (because likely as not the     * application knows better than libpng what the correct values are.)  Pass     * the info_ptr color_type field to png_colorspace_set_ICC because in the     * write case it has not yet been stored in png_ptr.     */
block|{
name|int
name|result
init|=
name|png_colorspace_set_ICC
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|colorspace
argument_list|,
name|name
argument_list|,
name|proflen
argument_list|,
name|profile
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|)
decl_stmt|;
name|png_colorspace_sync_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Don't do any of the copying if the profile was bad, or inconsistent. */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return;
comment|/* But do write the gAMA and cHRM chunks from the profile. */
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_FROM_gAMA
operator||
name|PNG_COLORSPACE_FROM_cHRM
expr_stmt|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|new_iccp_name
operator|=
name|png_voidcast
argument_list|(
name|png_charp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_iccp_name
operator|==
name|NULL
condition|)
block|{
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to process iCCP chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|new_iccp_name
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|new_iccp_profile
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|proflen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_iccp_profile
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_iccp_name
argument_list|)
expr_stmt|;
name|new_iccp_name
operator|=
name|NULL
expr_stmt|;
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to process iCCP profile"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|new_iccp_profile
argument_list|,
name|profile
argument_list|,
name|proflen
argument_list|)
expr_stmt|;
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ICCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|iccp_proflen
operator|=
name|proflen
expr_stmt|;
name|info_ptr
operator|->
name|iccp_name
operator|=
name|new_iccp_name
expr_stmt|;
name|info_ptr
operator|->
name|iccp_profile
operator|=
name|new_iccp_profile
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_ICCP
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_iCCP
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_text
name|png_set_text
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_textp
name|text_ptr
parameter_list|,
name|int
name|num_text
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
name|num_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to store text"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_set_text_2
name|png_set_text_2
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_textp
name|text_ptr
parameter_list|,
name|int
name|num_text
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %lx storage function"
argument_list|,
name|png_ptr
operator|==
name|NULL
condition|?
literal|"unexpected"
else|:
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|num_text
operator|<=
literal|0
operator|||
name|text_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make sure we have enough space in the "text" array in info_struct     * to hold all of the incoming text_ptr objects.  This compare can't overflow     * because max_text>= num_text (anyway, subtract of two positive integers     * can't overflow in any case.)     */
if|if
condition|(
name|num_text
operator|>
name|info_ptr
operator|->
name|max_text
operator|-
name|info_ptr
operator|->
name|num_text
condition|)
block|{
name|int
name|old_num_text
init|=
name|info_ptr
operator|->
name|num_text
decl_stmt|;
name|int
name|max_text
decl_stmt|;
name|png_textp
name|new_text
init|=
name|NULL
decl_stmt|;
comment|/* Calculate an appropriate max_text, checking for overflow. */
name|max_text
operator|=
name|old_num_text
expr_stmt|;
if|if
condition|(
name|num_text
operator|<=
name|INT_MAX
operator|-
name|max_text
condition|)
block|{
name|max_text
operator|+=
name|num_text
expr_stmt|;
comment|/* Round up to a multiple of 8 */
if|if
condition|(
name|max_text
operator|<
name|INT_MAX
operator|-
literal|8
condition|)
name|max_text
operator|=
operator|(
name|max_text
operator|+
literal|8
operator|)
operator|&
operator|~
literal|0x7
expr_stmt|;
else|else
name|max_text
operator|=
name|INT_MAX
expr_stmt|;
comment|/* Now allocate a new array and copy the old members in; this does all           * the overflow checks.           */
name|new_text
operator|=
name|png_voidcast
argument_list|(
name|png_textp
argument_list|,
name|png_realloc_array
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
argument_list|,
name|old_num_text
argument_list|,
name|max_text
operator|-
name|old_num_text
argument_list|,
sizeof|sizeof
expr|*
name|new_text
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_text
operator|==
name|NULL
condition|)
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"too many text chunks"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|text
operator|=
name|new_text
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_TEXT
expr_stmt|;
name|info_ptr
operator|->
name|max_text
operator|=
name|max_text
expr_stmt|;
comment|/* num_text is adjusted below as the entries are copied in */
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"allocated %d entries for info_ptr->text"
argument_list|,
name|max_text
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_text
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|text_length
decl_stmt|,
name|key_len
decl_stmt|;
name|size_t
name|lang_len
decl_stmt|,
name|lang_key_len
decl_stmt|;
name|png_textp
name|textp
init|=
operator|&
operator|(
name|info_ptr
operator|->
name|text
index|[
name|info_ptr
operator|->
name|num_text
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|key
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|<
name|PNG_TEXT_COMPRESSION_NONE
operator|||
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|>=
name|PNG_TEXT_COMPRESSION_LAST
condition|)
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"text compression mode is out of range"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|key_len
operator|=
name|strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|<=
literal|0
condition|)
block|{
name|lang_len
operator|=
literal|0
expr_stmt|;
name|lang_key_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
block|{
comment|/* Set iTXt data */
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang
operator|!=
name|NULL
condition|)
name|lang_len
operator|=
name|strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang
argument_list|)
expr_stmt|;
else|else
name|lang_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang_key
operator|!=
name|NULL
condition|)
name|lang_key_len
operator|=
name|strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|)
expr_stmt|;
else|else
name|lang_key_len
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* iTXt */
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"iTXt chunk not supported"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
operator|==
name|NULL
operator|||
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|text_length
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
name|textp
operator|->
name|compression
operator|=
name|PNG_ITXT_COMPRESSION_NONE
expr_stmt|;
else|else
endif|#
directive|endif
name|textp
operator|->
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
block|}
else|else
block|{
name|text_length
operator|=
name|strlen
argument_list|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|textp
operator|->
name|compression
operator|=
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
expr_stmt|;
block|}
name|textp
operator|->
name|key
operator|=
name|png_voidcast
argument_list|(
name|png_charp
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
name|key_len
operator|+
name|text_length
operator|+
name|lang_len
operator|+
name|lang_key_len
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|textp
operator|->
name|key
operator|==
name|NULL
condition|)
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"text chunk: out of memory"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|png_debug2
argument_list|(
literal|2
argument_list|,
literal|"Allocated %lu bytes at %p in png_set_text"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|png_uint_32
argument_list|)
argument_list|(
name|key_len
operator|+
name|lang_len
operator|+
name|lang_key_len
operator|+
name|text_length
operator|+
literal|4
argument_list|)
argument_list|,
name|textp
operator|->
name|key
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|textp
operator|->
name|key
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|key
operator|+
name|key_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|text_ptr
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
block|{
name|textp
operator|->
name|lang
operator|=
name|textp
operator|->
name|key
operator|+
name|key_len
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|textp
operator|->
name|lang
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang
argument_list|,
name|lang_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|lang
operator|+
name|lang_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|textp
operator|->
name|lang_key
operator|=
name|textp
operator|->
name|lang
operator|+
name|lang_len
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|textp
operator|->
name|lang_key
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|,
name|lang_key_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|lang_key
operator|+
name|lang_key_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|textp
operator|->
name|text
operator|=
name|textp
operator|->
name|lang_key
operator|+
name|lang_key_len
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|textp
operator|->
name|lang
operator|=
name|NULL
expr_stmt|;
name|textp
operator|->
name|lang_key
operator|=
name|NULL
expr_stmt|;
name|textp
operator|->
name|text
operator|=
name|textp
operator|->
name|key
operator|+
name|key_len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|text_length
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|textp
operator|->
name|text
argument_list|,
name|text_ptr
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|text_length
argument_list|)
expr_stmt|;
operator|*
operator|(
name|textp
operator|->
name|text
operator|+
name|text_length
operator|)
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_iTXt_SUPPORTED
if|if
condition|(
name|textp
operator|->
name|compression
operator|>
literal|0
condition|)
block|{
name|textp
operator|->
name|text_length
operator|=
literal|0
expr_stmt|;
name|textp
operator|->
name|itxt_length
operator|=
name|text_length
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|textp
operator|->
name|text_length
operator|=
name|text_length
expr_stmt|;
name|textp
operator|->
name|itxt_length
operator|=
literal|0
expr_stmt|;
block|}
name|info_ptr
operator|->
name|num_text
operator|++
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"transferred text chunk %d"
argument_list|,
name|info_ptr
operator|->
name|num_text
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_tIME
name|png_set_tIME
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_timep
name|mod_time
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"tIME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|mod_time
operator|==
name|NULL
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_tIME
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|mod_time
operator|->
name|month
operator|==
literal|0
operator|||
name|mod_time
operator|->
name|month
operator|>
literal|12
operator|||
name|mod_time
operator|->
name|day
operator|==
literal|0
operator|||
name|mod_time
operator|->
name|day
operator|>
literal|31
operator|||
name|mod_time
operator|->
name|hour
operator|>
literal|23
operator|||
name|mod_time
operator|->
name|minute
operator|>
literal|59
operator|||
name|mod_time
operator|->
name|second
operator|>
literal|60
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring invalid time value"
argument_list|)
expr_stmt|;
return|return;
block|}
name|info_ptr
operator|->
name|mod_time
operator|=
operator|*
name|mod_time
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_tIME
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_tRNS
name|png_set_tRNS
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_bytep
name|trans_alpha
parameter_list|,
name|int
name|num_trans
parameter_list|,
name|png_const_color_16p
name|trans_color
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"tRNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|trans_alpha
operator|!=
name|NULL
condition|)
block|{
comment|/* It may not actually be necessary to set png_ptr->trans_alpha here;         * we do it for backward compatibility with the way the png_handle_tRNS         * function used to do the allocation.         *         * 1.6.0: The above statement is incorrect; png_handle_tRNS effectively         * relies on png_set_tRNS storing the information in png_struct         * (otherwise it won't be there for the code in pngrtran.c).         */
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_TRNS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
name|png_ptr
operator|->
name|trans_alpha
operator|=
name|info_ptr
operator|->
name|trans_alpha
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|PNG_MAX_PALETTE_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_trans
operator|>
literal|0
operator|&&
name|num_trans
operator|<=
name|PNG_MAX_PALETTE_LENGTH
condition|)
name|memcpy
argument_list|(
name|info_ptr
operator|->
name|trans_alpha
argument_list|,
name|trans_alpha
argument_list|,
operator|(
name|png_size_t
operator|)
name|num_trans
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trans_color
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|bit_depth
operator|<
literal|16
condition|)
block|{
name|int
name|sample_max
init|=
operator|(
literal|1
operator|<<
name|info_ptr
operator|->
name|bit_depth
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|&&
name|trans_color
operator|->
name|gray
operator|>
name|sample_max
operator|)
operator|||
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|&&
operator|(
name|trans_color
operator|->
name|red
operator|>
name|sample_max
operator|||
name|trans_color
operator|->
name|green
operator|>
name|sample_max
operator|||
name|trans_color
operator|->
name|blue
operator|>
name|sample_max
operator|)
operator|)
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"tRNS chunk has out-of-range samples for bit_depth"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|info_ptr
operator|->
name|trans_color
operator|=
operator|*
name|trans_color
expr_stmt|;
if|if
condition|(
name|num_trans
operator|==
literal|0
condition|)
name|num_trans
operator|=
literal|1
expr_stmt|;
block|}
name|info_ptr
operator|->
name|num_trans
operator|=
operator|(
name|png_uint_16
operator|)
name|num_trans
expr_stmt|;
if|if
condition|(
name|num_trans
operator|!=
literal|0
condition|)
block|{
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_tRNS
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_TRNS
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sPLT
name|png_set_sPLT
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_sPLT_tp
name|entries
parameter_list|,
name|int
name|nentries
parameter_list|)
comment|/*  *  entries        - array of png_sPLT_t structures  *                   to be added to the list of palettes  *                   in the info structure.  *  *  nentries       - number of palette structures to be  *                   added.  */
block|{
name|png_sPLT_tp
name|np
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|nentries
operator|<=
literal|0
operator|||
name|entries
operator|==
name|NULL
condition|)
return|return;
comment|/* Use the internal realloc function, which checks for all the possible     * overflows.  Notice that the parameters are (int) and (size_t)     */
name|np
operator|=
name|png_voidcast
argument_list|(
name|png_sPLT_tp
argument_list|,
name|png_realloc_array
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
argument_list|,
name|info_ptr
operator|->
name|splt_palettes_num
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
expr|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
comment|/* Out of memory or too many chunks */
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"too many sPLT chunks"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
operator|=
name|np
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_SPLT
expr_stmt|;
name|np
operator|+=
name|info_ptr
operator|->
name|splt_palettes_num
expr_stmt|;
do|do
block|{
name|png_size_t
name|length
decl_stmt|;
comment|/* Skip invalid input entries */
if|if
condition|(
name|entries
operator|->
name|name
operator|==
name|NULL
operator|||
name|entries
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
comment|/* png_handle_sPLT doesn't do this, so this is an app error */
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_set_sPLT: invalid sPLT"
argument_list|)
expr_stmt|;
comment|/* Just skip the invalid entry */
continue|continue;
block|}
name|np
operator|->
name|depth
operator|=
name|entries
operator|->
name|depth
expr_stmt|;
comment|/* In the event of out-of-memory just return - there's no point keeping        * on trying to add sPLT chunks.        */
name|length
operator|=
name|strlen
argument_list|(
name|entries
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|np
operator|->
name|name
operator|=
name|png_voidcast
argument_list|(
name|png_charp
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|name
operator|==
name|NULL
condition|)
break|break;
name|memcpy
argument_list|(
name|np
operator|->
name|name
argument_list|,
name|entries
operator|->
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* IMPORTANT: we have memory now that won't get freed if something else        * goes wrong; this code must free it.  png_malloc_array produces no        * warnings; use a png_chunk_report (below) if there is an error.        */
name|np
operator|->
name|entries
operator|=
name|png_voidcast
argument_list|(
name|png_sPLT_entryp
argument_list|,
name|png_malloc_array
argument_list|(
name|png_ptr
argument_list|,
name|entries
operator|->
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|np
operator|->
name|nentries
operator|=
name|entries
operator|->
name|nentries
expr_stmt|;
comment|/* This multiply can't overflow because png_malloc_array has already        * checked it when doing the allocation.        */
name|memcpy
argument_list|(
name|np
operator|->
name|entries
argument_list|,
name|entries
operator|->
name|entries
argument_list|,
name|entries
operator|->
name|nentries
operator|*
sizeof|sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that 'continue' skips the advance of the out pointer and out        * count, so an invalid entry is not added.        */
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sPLT
expr_stmt|;
operator|++
operator|(
name|info_ptr
operator|->
name|splt_palettes_num
operator|)
expr_stmt|;
operator|++
name|np
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|entries
operator|,
operator|--
name|nentries
condition|)
do|;
if|if
condition|(
name|nentries
operator|>
literal|0
condition|)
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT out of memory"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* sPLT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_function
specifier|static
name|png_byte
DECL|function|check_location
name|check_location
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|location
operator|&=
operator|(
name|PNG_HAVE_IHDR
operator||
name|PNG_HAVE_PLTE
operator||
name|PNG_AFTER_IDAT
operator|)
expr_stmt|;
comment|/* New in 1.6.0; copy the location and check it.  This is an API     * change; previously the app had to use the     * png_set_unknown_chunk_location API below for each chunk.     */
if|if
condition|(
name|location
operator|==
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Write struct, so unknown chunks come from the app */
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"png_set_unknown_chunks now expects a valid location"
argument_list|)
expr_stmt|;
comment|/* Use the old behavior */
name|location
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|mode
operator|&
operator|(
name|PNG_HAVE_IHDR
operator||
name|PNG_HAVE_PLTE
operator||
name|PNG_AFTER_IDAT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* This need not be an internal error - if the app calls     * png_set_unknown_chunks on a read pointer it must get the location right.     */
if|if
condition|(
name|location
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid location in png_set_unknown_chunks"
argument_list|)
expr_stmt|;
comment|/* Now reduce the location to the top-most set bit by removing each least     * significant bit in turn.     */
while|while
condition|(
name|location
operator|!=
operator|(
name|location
operator|&
operator|-
name|location
operator|)
condition|)
name|location
operator|&=
operator|~
operator|(
name|location
operator|&
operator|-
name|location
operator|)
expr_stmt|;
comment|/* The cast is safe because 'location' is a bit mask and only the low four     * bits are significant.     */
return|return
operator|(
name|png_byte
operator|)
name|location
return|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_unknown_chunks
name|png_set_unknown_chunks
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_const_unknown_chunkp
name|unknowns
parameter_list|,
name|int
name|num_unknowns
parameter_list|)
block|{
name|png_unknown_chunkp
name|np
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
operator|||
name|num_unknowns
operator|<=
literal|0
operator|||
name|unknowns
operator|==
name|NULL
condition|)
return|return;
comment|/* Check for the failure cases where support has been disabled at compile     * time.  This code is hardly ever compiled - it's here because     * STORE_UNKNOWN_CHUNKS is set by both read and write code (compiling in this     * code) but may be meaningless if the read or write handling of unknown     * chunks is not compiled in.     */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no unknown chunk support on read"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|==
literal|0
condition|)
block|{
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no unknown chunk support on write"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Prior to 1.6.0 this code used png_malloc_warn; however, this meant that     * unknown critical chunks could be lost with just a warning resulting in     * undefined behavior.  Now png_chunk_report is used to provide behavior     * appropriate to read or write.     */
name|np
operator|=
name|png_voidcast
argument_list|(
name|png_unknown_chunkp
argument_list|,
name|png_realloc_array
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks_num
argument_list|,
name|num_unknowns
argument_list|,
sizeof|sizeof
expr|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"too many unknown chunks"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
operator|=
name|np
expr_stmt|;
comment|/* safe because it is initialized */
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_UNKN
expr_stmt|;
name|np
operator|+=
name|info_ptr
operator|->
name|unknown_chunks_num
expr_stmt|;
comment|/* Increment unknown_chunks_num each time round the loop to protect the     * just-allocated chunk data.     */
for|for
control|(
init|;
name|num_unknowns
operator|>
literal|0
condition|;
operator|--
name|num_unknowns
operator|,
operator|++
name|unknowns
control|)
block|{
name|memcpy
argument_list|(
name|np
operator|->
name|name
argument_list|,
name|unknowns
operator|->
name|name
argument_list|,
operator|(
sizeof|sizeof
name|np
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|name
index|[
operator|(
sizeof|sizeof
name|np
operator|->
name|name
operator|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|np
operator|->
name|location
operator|=
name|check_location
argument_list|(
name|png_ptr
argument_list|,
name|unknowns
operator|->
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknowns
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|np
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|np
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|data
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
name|unknowns
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown chunk: out of memory"
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
comment|/* But just skip storing the unknown chunk */
continue|continue;
block|}
name|memcpy
argument_list|(
name|np
operator|->
name|data
argument_list|,
name|unknowns
operator|->
name|data
argument_list|,
name|unknowns
operator|->
name|size
argument_list|)
expr_stmt|;
name|np
operator|->
name|size
operator|=
name|unknowns
operator|->
name|size
expr_stmt|;
block|}
comment|/* These increments are skipped on out-of-memory for the data - the        * unknown chunk entry gets overwritten if the png_chunk_report returns.        * This is correct in the read case (the chunk is just dropped.)        */
operator|++
name|np
expr_stmt|;
operator|++
operator|(
name|info_ptr
operator|->
name|unknown_chunks_num
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_unknown_chunk_location
name|png_set_unknown_chunk_location
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|chunk
parameter_list|,
name|int
name|location
parameter_list|)
block|{
comment|/* This API is pretty pointless in 1.6.0 because the location can be set     * before the call to png_set_unknown_chunks.     *     * TODO: add a png_app_warning in 1.7     */
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|info_ptr
operator|!=
name|NULL
operator|&&
name|chunk
operator|>=
literal|0
operator|&&
name|chunk
operator|<
name|info_ptr
operator|->
name|unknown_chunks_num
condition|)
block|{
if|if
condition|(
operator|(
name|location
operator|&
operator|(
name|PNG_HAVE_IHDR
operator||
name|PNG_HAVE_PLTE
operator||
name|PNG_AFTER_IDAT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid unknown chunk location"
argument_list|)
expr_stmt|;
comment|/* Fake out the pre 1.6.0 behavior: */
if|if
condition|(
operator|(
name|location
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
comment|/* undocumented! */
name|location
operator|=
name|PNG_AFTER_IDAT
expr_stmt|;
else|else
name|location
operator|=
name|PNG_HAVE_IHDR
expr_stmt|;
comment|/* also undocumented */
block|}
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|chunk
index|]
operator|.
name|location
operator|=
name|check_location
argument_list|(
name|png_ptr
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* STORE_UNKNOWN_CHUNKS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
end_ifdef
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_permit_mng_features
name|png_permit_mng_features
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|mng_features
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_permit_mng_features"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|png_ptr
operator|->
name|mng_features_permitted
operator|=
name|mng_features
operator|&
name|PNG_ALL_MNG_FEATURES
expr_stmt|;
return|return
name|png_ptr
operator|->
name|mng_features_permitted
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
end_ifdef
begin_function
specifier|static
name|unsigned
name|int
DECL|function|add_one_chunk
name|add_one_chunk
parameter_list|(
name|png_bytep
name|list
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|,
name|png_const_bytep
name|add
parameter_list|,
name|int
name|keep
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Utility function: update the 'keep' state of a chunk if it is already in     * the list, otherwise add it to the list.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
operator|,
name|list
operator|+=
literal|5
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|list
argument_list|,
name|add
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|list
index|[
literal|4
index|]
operator|=
operator|(
name|png_byte
operator|)
name|keep
expr_stmt|;
return|return
name|count
return|;
block|}
block|}
if|if
condition|(
name|keep
operator|!=
name|PNG_HANDLE_CHUNK_AS_DEFAULT
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|memcpy
argument_list|(
name|list
argument_list|,
name|add
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|list
index|[
literal|4
index|]
operator|=
operator|(
name|png_byte
operator|)
name|keep
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_keep_unknown_chunks
name|png_set_keep_unknown_chunks
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|keep
parameter_list|,
name|png_const_bytep
name|chunk_list
parameter_list|,
name|int
name|num_chunks_in
parameter_list|)
block|{
name|png_bytep
name|new_list
decl_stmt|;
name|unsigned
name|int
name|num_chunks
decl_stmt|,
name|old_num_chunks
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|keep
operator|<
literal|0
operator|||
name|keep
operator|>=
name|PNG_HANDLE_CHUNK_LAST
condition|)
block|{
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_set_keep_unknown_chunks: invalid keep"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|num_chunks_in
operator|<=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|unknown_default
operator|=
name|keep
expr_stmt|;
comment|/* '0' means just set the flags, so stop here */
if|if
condition|(
name|num_chunks_in
operator|==
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|num_chunks_in
operator|<
literal|0
condition|)
block|{
comment|/* Ignore all unknown chunks and all chunks recognized by        * libpng except for IHDR, PLTE, tRNS, IDAT, and IEND        */
specifier|static
name|PNG_CONST
name|png_byte
name|chunks_to_ignore
index|[]
init|=
block|{
literal|98
block|,
literal|75
block|,
literal|71
block|,
literal|68
block|,
literal|'\0'
block|,
comment|/* bKGD */
literal|99
block|,
literal|72
block|,
literal|82
block|,
literal|77
block|,
literal|'\0'
block|,
comment|/* cHRM */
literal|103
block|,
literal|65
block|,
literal|77
block|,
literal|65
block|,
literal|'\0'
block|,
comment|/* gAMA */
literal|104
block|,
literal|73
block|,
literal|83
block|,
literal|84
block|,
literal|'\0'
block|,
comment|/* hIST */
literal|105
block|,
literal|67
block|,
literal|67
block|,
literal|80
block|,
literal|'\0'
block|,
comment|/* iCCP */
literal|105
block|,
literal|84
block|,
literal|88
block|,
literal|116
block|,
literal|'\0'
block|,
comment|/* iTXt */
literal|111
block|,
literal|70
block|,
literal|70
block|,
literal|115
block|,
literal|'\0'
block|,
comment|/* oFFs */
literal|112
block|,
literal|67
block|,
literal|65
block|,
literal|76
block|,
literal|'\0'
block|,
comment|/* pCAL */
literal|112
block|,
literal|72
block|,
literal|89
block|,
literal|115
block|,
literal|'\0'
block|,
comment|/* pHYs */
literal|115
block|,
literal|66
block|,
literal|73
block|,
literal|84
block|,
literal|'\0'
block|,
comment|/* sBIT */
literal|115
block|,
literal|67
block|,
literal|65
block|,
literal|76
block|,
literal|'\0'
block|,
comment|/* sCAL */
literal|115
block|,
literal|80
block|,
literal|76
block|,
literal|84
block|,
literal|'\0'
block|,
comment|/* sPLT */
literal|115
block|,
literal|84
block|,
literal|69
block|,
literal|82
block|,
literal|'\0'
block|,
comment|/* sTER */
literal|115
block|,
literal|82
block|,
literal|71
block|,
literal|66
block|,
literal|'\0'
block|,
comment|/* sRGB */
literal|116
block|,
literal|69
block|,
literal|88
block|,
literal|116
block|,
literal|'\0'
block|,
comment|/* tEXt */
literal|116
block|,
literal|73
block|,
literal|77
block|,
literal|69
block|,
literal|'\0'
block|,
comment|/* tIME */
literal|122
block|,
literal|84
block|,
literal|88
block|,
literal|116
block|,
literal|'\0'
comment|/* zTXt */
block|}
decl_stmt|;
name|chunk_list
operator|=
name|chunks_to_ignore
expr_stmt|;
name|num_chunks
operator|=
call|(
name|unsigned
name|int
call|)
comment|/*SAFE*/
argument_list|(
sizeof|sizeof
name|chunks_to_ignore
argument_list|)
operator|/
literal|5U
expr_stmt|;
block|}
else|else
comment|/* num_chunks_in> 0 */
block|{
if|if
condition|(
name|chunk_list
operator|==
name|NULL
condition|)
block|{
comment|/* Prior to 1.6.0 this was silently ignored, now it is an app_error           * which can be switched off.           */
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_set_keep_unknown_chunks: no chunk list"
argument_list|)
expr_stmt|;
return|return;
block|}
name|num_chunks
operator|=
name|num_chunks_in
expr_stmt|;
block|}
name|old_num_chunks
operator|=
name|png_ptr
operator|->
name|num_chunk_list
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunk_list
operator|==
name|NULL
condition|)
name|old_num_chunks
operator|=
literal|0
expr_stmt|;
comment|/* Since num_chunks is always restricted to UINT_MAX/5 this can't overflow.     */
if|if
condition|(
name|num_chunks
operator|+
name|old_num_chunks
operator|>
name|UINT_MAX
operator|/
literal|5
condition|)
block|{
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_set_keep_unknown_chunks: too many chunks"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If these chunks are being reset to the default then no more memory is     * required because add_one_chunk above doesn't extend the list if the 'keep'     * parameter is the default.     */
if|if
condition|(
name|keep
operator|!=
literal|0
condition|)
block|{
name|new_list
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|5
operator|*
operator|(
name|num_chunks
operator|+
name|old_num_chunks
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_num_chunks
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|new_list
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|,
literal|5
operator|*
name|old_num_chunks
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_num_chunks
operator|>
literal|0
condition|)
name|new_list
operator|=
name|png_ptr
operator|->
name|chunk_list
expr_stmt|;
else|else
name|new_list
operator|=
name|NULL
expr_stmt|;
comment|/* Add the new chunks together with each one's handling code.  If the chunk     * already exists the code is updated, otherwise the chunk is added to the     * end.  (In libpng 1.6.0 order no longer matters because this code enforces     * the earlier convention that the last setting is the one that is used.)     */
if|if
condition|(
name|new_list
operator|!=
name|NULL
condition|)
block|{
name|png_const_bytep
name|inlist
decl_stmt|;
name|png_bytep
name|outlist
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
operator|++
name|i
control|)
block|{
name|old_num_chunks
operator|=
name|add_one_chunk
argument_list|(
name|new_list
argument_list|,
name|old_num_chunks
argument_list|,
name|chunk_list
operator|+
literal|5
operator|*
name|i
argument_list|,
name|keep
argument_list|)
expr_stmt|;
block|}
comment|/* Now remove any spurious 'default' entries. */
name|num_chunks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|inlist
operator|=
name|outlist
operator|=
name|new_list
init|;
name|i
operator|<
name|old_num_chunks
condition|;
operator|++
name|i
operator|,
name|inlist
operator|+=
literal|5
control|)
block|{
if|if
condition|(
name|inlist
index|[
literal|4
index|]
condition|)
block|{
if|if
condition|(
name|outlist
operator|!=
name|inlist
condition|)
name|memcpy
argument_list|(
name|outlist
argument_list|,
name|inlist
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|outlist
operator|+=
literal|5
expr_stmt|;
operator|++
name|num_chunks
expr_stmt|;
block|}
block|}
comment|/* This means the application has removed all the specialized handling. */
if|if
condition|(
name|num_chunks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|chunk_list
operator|!=
name|new_list
condition|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_list
argument_list|)
expr_stmt|;
name|new_list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|num_chunks
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|num_chunk_list
operator|=
name|num_chunks
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunk_list
operator|!=
name|new_list
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|chunk_list
operator|!=
name|NULL
condition|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_list
operator|=
name|new_list
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_read_user_chunk_fn
name|png_set_read_user_chunk_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_voidp
name|user_chunk_ptr
parameter_list|,
name|png_user_chunk_ptr
name|read_user_chunk_fn
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_read_user_chunk_fn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|=
name|read_user_chunk_fn
expr_stmt|;
name|png_ptr
operator|->
name|user_chunk_ptr
operator|=
name|user_chunk_ptr
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_rows
name|png_set_rows
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_bytepp
name|row_pointers
parameter_list|)
block|{
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in %s storage function"
argument_list|,
literal|"rows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|info_ptr
operator|->
name|row_pointers
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|row_pointers
operator|!=
name|row_pointers
operator|)
condition|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|row_pointers
operator|=
name|row_pointers
expr_stmt|;
if|if
condition|(
name|row_pointers
operator|!=
name|NULL
condition|)
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_IDAT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_buffer_size
name|png_set_compression_buffer_size
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|>
name|PNG_UINT_31_MAX
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid compression buffer size"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|IDAT_read_size
operator|=
operator|(
name|png_uint_32
operator|)
name|size
expr_stmt|;
comment|/* checked above */
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|!=
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Compression buffer size cannot be changed because it is in use"
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|__COVERITY__
if|if
condition|(
name|size
operator|>
name|ZLIB_IO_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Compression buffer size limited to system maximum"
argument_list|)
expr_stmt|;
name|size
operator|=
name|ZLIB_IO_MAX
expr_stmt|;
comment|/* must fit */
block|}
endif|#
directive|endif
if|if
condition|(
name|size
operator|<
literal|6
condition|)
block|{
comment|/* Deflate will potentially go into an infinite loop on a SYNC_FLUSH              * if this is permitted.              */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Compression buffer size cannot be reduced below 6"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|zbuffer_size
operator|!=
name|size
condition|)
block|{
name|png_free_buffer_list
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|zbuffer_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zbuffer_size
operator|=
operator|(
name|uInt
operator|)
name|size
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_invalid
name|png_set_invalid
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|info_ptr
operator|!=
name|NULL
condition|)
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
end_ifdef
begin_comment
comment|/* This function was added to libpng 1.2.6 */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_user_limits
name|png_set_user_limits
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|user_width_max
parameter_list|,
name|png_uint_32
name|user_height_max
parameter_list|)
block|{
comment|/* Images with dimensions larger than these limits will be     * rejected by png_set_IHDR().  To accept any PNG datastream     * regardless of dimensions, set both limits to 0x7ffffffL.     */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|user_width_max
operator|=
name|user_width_max
expr_stmt|;
name|png_ptr
operator|->
name|user_height_max
operator|=
name|user_height_max
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This function was added to libpng 1.4.0 */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_chunk_cache_max
name|png_set_chunk_cache_max
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|user_chunk_cache_max
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|=
name|user_chunk_cache_max
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This function was added to libpng 1.4.1 */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_chunk_malloc_max
name|png_set_chunk_malloc_max
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_alloc_size_t
name|user_chunk_malloc_max
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|=
name|user_chunk_malloc_max
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ?SET_USER_LIMITS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_benign_errors
name|png_set_benign_errors
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|allowed
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_benign_errors"
argument_list|)
expr_stmt|;
comment|/* If allowed is 1, png_benign_error() is treated as a warning.     *     * If allowed is 0, png_benign_error() is treated as an error (which     * is the default behavior if png_set_benign_errors() is not called).     */
if|if
condition|(
name|allowed
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_BENIGN_ERRORS_WARN
operator||
name|PNG_FLAG_APP_WARNINGS_WARN
operator||
name|PNG_FLAG_APP_ERRORS_WARN
expr_stmt|;
else|else
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PNG_FLAG_BENIGN_ERRORS_WARN
operator||
name|PNG_FLAG_APP_WARNINGS_WARN
operator||
name|PNG_FLAG_APP_ERRORS_WARN
operator|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* BENIGN_ERRORS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
end_ifdef
begin_comment
comment|/* Whether to report invalid palette index; added at libng-1.5.10.     * It is possible for an indexed (color-type==3) PNG file to contain     * pixels with invalid (out-of-range) indexes if the PLTE chunk has     * fewer entries than the image's bit-depth would allow. We recover     * from this gracefully by filling any incomplete palette with zeros     * (opaque black).  By default, when this occurs libpng will issue     * a benign error.  This API can be used to override that behavior.     */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_check_for_invalid_index
name|png_set_check_for_invalid_index
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|allowed
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_check_for_invalid_index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowed
operator|>
literal|0
condition|)
name|png_ptr
operator|->
name|num_palette_max
operator|=
literal|0
expr_stmt|;
else|else
name|png_ptr
operator|->
name|num_palette_max
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ || WRITE */
end_comment
end_unit
