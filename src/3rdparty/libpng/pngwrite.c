begin_unit
begin_comment
comment|/* pngwrite.c - general routines to write a PNG file  *  * Last changed in libpng 1.5.1 [February 3, 2011]  * Copyright (c) 1998-2011 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_comment
comment|/* Writes all the PNG information.  This is the suggested way to use the  * library.  If you have a new chunk to add, make a function to write it,  * and put it in the correct location here.  If you want the chunk written  * after the image data, put it in png_write_end().  I strongly encourage  * you to supply a PNG_INFO_ flag, and check info_ptr->valid before writing  * the chunk, as that will keep the code from breaking if you want to just  * write a plain PNG file.  If you have long comments, I suggest writing  * them in png_write_end(), and compressing them.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_info_before_PLTE
name|png_write_info_before_PLTE
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_info_before_PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_INFO_BEFORE_PLTE
operator|)
condition|)
block|{
comment|/* Write PNG signature */
name|png_write_sig
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|&&
expr|\
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"MNG features are not allowed in a PNG datastream"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mng_features_permitted
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Write IHDR information. */
name|png_write_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|width
argument_list|,
name|info_ptr
operator|->
name|height
argument_list|,
name|info_ptr
operator|->
name|bit_depth
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|,
name|info_ptr
operator|->
name|compression_type
argument_list|,
name|info_ptr
operator|->
name|filter_type
argument_list|,
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
name|info_ptr
operator|->
name|interlace_type
argument_list|)
expr_stmt|;
else|#
directive|else
literal|0
block|)
empty_stmt|;
endif|#
directive|endif
comment|/* The rest of these check to see if the valid field has the appropriate     * flag set, and if it does, writes the chunk.     */
ifdef|#
directive|ifdef
name|PNG_WRITE_gAMA_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_gAMA
condition|)
name|png_write_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|gamma
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sRGB_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
condition|)
name|png_write_sRGB
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|srgb_intent
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_iCCP_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_iCCP
condition|)
name|png_write_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_name
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
operator|(
name|png_charp
operator|)
name|info_ptr
operator|->
name|iccp_profile
argument_list|,
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|iccp_proflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sBIT_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sBIT
condition|)
name|png_write_sBIT
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|sig_bit
operator|)
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_cHRM_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_cHRM
condition|)
name|png_write_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|x_white
argument_list|,
name|info_ptr
operator|->
name|y_white
argument_list|,
name|info_ptr
operator|->
name|x_red
argument_list|,
name|info_ptr
operator|->
name|y_red
argument_list|,
name|info_ptr
operator|->
name|x_green
argument_list|,
name|info_ptr
operator|->
name|y_green
argument_list|,
name|info_ptr
operator|->
name|x_blue
argument_list|,
name|info_ptr
operator|->
name|y_blue
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks_num
condition|)
block|{
name|png_unknown_chunk
modifier|*
name|up
decl_stmt|;
name|png_debug
argument_list|(
literal|5
argument_list|,
literal|"writing extra chunks"
argument_list|)
expr_stmt|;
for|for
control|(
name|up
operator|=
name|info_ptr
operator|->
name|unknown_chunks
init|;
name|up
operator|<
name|info_ptr
operator|->
name|unknown_chunks
operator|+
name|info_ptr
operator|->
name|unknown_chunks_num
condition|;
name|up
operator|++
control|)
block|{
name|int
name|keep
init|=
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|keep
operator|!=
name|PNG_HANDLE_CHUNK_NEVER
operator|&&
name|up
operator|->
name|location
operator|&&
operator|!
operator|(
name|up
operator|->
name|location
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|location
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|&&
operator|(
operator|(
name|up
operator|->
name|name
index|[
literal|3
index|]
operator|&
literal|0x20
operator|)
operator|||
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|||
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_KEEP_UNSAFE_CHUNKS
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|size
operator|==
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Writing zero-length unknown chunk"
argument_list|)
expr_stmt|;
name|png_write_chunk
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|,
name|up
operator|->
name|data
argument_list|,
name|up
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_WROTE_INFO_BEFORE_PLTE
expr_stmt|;
block|}
end_function
begin_function
unit|}  void
name|PNGAPI
DECL|function|png_write_info
name|png_write_info
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_TEXT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_sPLT_SUPPORTED
argument_list|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_write_info_before_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_PLTE
condition|)
name|png_write_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|palette
argument_list|,
operator|(
name|png_uint_32
operator|)
name|info_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Valid palette required for paletted images"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_tRNS_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_INVERT_ALPHA_SUPPORTED
comment|/* Invert the alpha channel (in tRNS) */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_ALPHA
operator|)
operator|&&
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|num_trans
condition|;
name|j
operator|++
control|)
name|info_ptr
operator|->
name|trans_alpha
index|[
name|j
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
name|info_ptr
operator|->
name|trans_alpha
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|png_write_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|trans_alpha
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|trans_color
operator|)
argument_list|,
name|info_ptr
operator|->
name|num_trans
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_bKGD_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_bKGD
condition|)
name|png_write_bKGD
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|background
operator|)
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_hIST_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_hIST
condition|)
name|png_write_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|hist
argument_list|,
name|info_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_oFFs_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_oFFs
condition|)
name|png_write_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|x_offset
argument_list|,
name|info_ptr
operator|->
name|y_offset
argument_list|,
name|info_ptr
operator|->
name|offset_unit_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_pCAL_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pCAL
condition|)
name|png_write_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_purpose
argument_list|,
name|info_ptr
operator|->
name|pcal_X0
argument_list|,
name|info_ptr
operator|->
name|pcal_X1
argument_list|,
name|info_ptr
operator|->
name|pcal_type
argument_list|,
name|info_ptr
operator|->
name|pcal_nparams
argument_list|,
name|info_ptr
operator|->
name|pcal_units
argument_list|,
name|info_ptr
operator|->
name|pcal_params
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sCAL_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sCAL
condition|)
name|png_write_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|scal_unit
argument_list|,
name|info_ptr
operator|->
name|scal_s_width
argument_list|,
name|info_ptr
operator|->
name|scal_s_height
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sCAL */
ifdef|#
directive|ifdef
name|PNG_WRITE_pHYs_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pHYs
condition|)
name|png_write_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|x_pixels_per_unit
argument_list|,
name|info_ptr
operator|->
name|y_pixels_per_unit
argument_list|,
name|info_ptr
operator|->
name|phys_unit_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pHYs */
ifdef|#
directive|ifdef
name|PNG_WRITE_tIME_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tIME
condition|)
block|{
name|png_write_tIME
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|mod_time
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_WROTE_tIME
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* tIME */
ifdef|#
directive|ifdef
name|PNG_WRITE_sPLT_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sPLT
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|splt_palettes_num
condition|;
name|i
operator|++
control|)
name|png_write_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
operator|+
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sPLT */
ifdef|#
directive|ifdef
name|PNG_WRITE_TEXT_SUPPORTED
comment|/* Check to see if we need to write text chunks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_text
condition|;
name|i
operator|++
control|)
block|{
name|png_debug2
argument_list|(
literal|2
argument_list|,
literal|"Writing header text chunk %d, type %d"
argument_list|,
name|i
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
comment|/* An internationalized chunk? */
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_iTXt_SUPPORTED
comment|/* Write international chunk */
name|png_write_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write international text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
block|}
comment|/* If we want a compressed text chunk */
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_zTXt
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_zTXt_SUPPORTED
comment|/* Write compressed chunk */
name|png_write_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write compressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt_WR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_tEXt_SUPPORTED
comment|/* Write uncompressed chunk */
name|png_write_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
else|#
directive|else
comment|/* Can't get here */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write uncompressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* tEXt */
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks_num
condition|)
block|{
name|png_unknown_chunk
modifier|*
name|up
decl_stmt|;
name|png_debug
argument_list|(
literal|5
argument_list|,
literal|"writing extra chunks"
argument_list|)
expr_stmt|;
for|for
control|(
name|up
operator|=
name|info_ptr
operator|->
name|unknown_chunks
init|;
name|up
operator|<
name|info_ptr
operator|->
name|unknown_chunks
operator|+
name|info_ptr
operator|->
name|unknown_chunks_num
condition|;
name|up
operator|++
control|)
block|{
name|int
name|keep
init|=
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|keep
operator|!=
name|PNG_HANDLE_CHUNK_NEVER
operator|&&
name|up
operator|->
name|location
operator|&&
operator|(
name|up
operator|->
name|location
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|location
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|&&
operator|(
operator|(
name|up
operator|->
name|name
index|[
literal|3
index|]
operator|&
literal|0x20
operator|)
operator|||
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|||
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_KEEP_UNSAFE_CHUNKS
operator|)
operator|)
condition|)
block|{
name|png_write_chunk
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|,
name|up
operator|->
name|data
argument_list|,
name|up
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* Writes the end of the PNG file.  If you don't want to write comments or  * time information, you can pass NULL for info.  If you already wrote these  * in png_write_info(), do not write them again here.  If you have long  * comments, I suggest writing them here, and compressing them.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_end
name|png_write_end
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"No IDATs written into file"
argument_list|)
expr_stmt|;
comment|/* See if user wants us to write information chunks */
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_TEXT_SUPPORTED
name|int
name|i
decl_stmt|;
comment|/* local index variable */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_tIME_SUPPORTED
comment|/* Check to see if user has supplied a time chunk */
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tIME
operator|)
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_tIME
operator|)
condition|)
name|png_write_tIME
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|mod_time
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_TEXT_SUPPORTED
comment|/* Loop through comment chunks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_text
condition|;
name|i
operator|++
control|)
block|{
name|png_debug2
argument_list|(
literal|2
argument_list|,
literal|"Writing trailer text chunk %d, type %d"
argument_list|,
name|i
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
comment|/* An internationalized chunk? */
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_iTXt_SUPPORTED
comment|/* Write international chunk */
name|png_write_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write international text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|>=
name|PNG_TEXT_COMPRESSION_zTXt
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_zTXt_SUPPORTED
comment|/* Write compressed chunk */
name|png_write_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write compressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt_WR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_tEXt_SUPPORTED
comment|/* Write uncompressed chunk */
name|png_write_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write uncompressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks_num
condition|)
block|{
name|png_unknown_chunk
modifier|*
name|up
decl_stmt|;
name|png_debug
argument_list|(
literal|5
argument_list|,
literal|"writing extra chunks"
argument_list|)
expr_stmt|;
for|for
control|(
name|up
operator|=
name|info_ptr
operator|->
name|unknown_chunks
init|;
name|up
operator|<
name|info_ptr
operator|->
name|unknown_chunks
operator|+
name|info_ptr
operator|->
name|unknown_chunks_num
condition|;
name|up
operator|++
control|)
block|{
name|int
name|keep
init|=
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|keep
operator|!=
name|PNG_HANDLE_CHUNK_NEVER
operator|&&
name|up
operator|->
name|location
operator|&&
operator|(
name|up
operator|->
name|location
operator|&
name|PNG_AFTER_IDAT
operator|)
operator|&&
operator|(
operator|(
name|up
operator|->
name|name
index|[
literal|3
index|]
operator|&
literal|0x20
operator|)
operator|||
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|||
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_KEEP_UNSAFE_CHUNKS
operator|)
operator|)
condition|)
block|{
name|png_write_chunk
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|,
name|up
operator|->
name|data
argument_list|,
name|up
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
comment|/* Write end of PNG file */
name|png_write_IEND
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,     * and restored again in libpng-1.2.30, may cause some applications that     * do not set png_ptr->output_flush_fn to crash.  If your application     * experiences a problem, please try building libpng with     * PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED defined, and report the event to     * png-mng-implement at lists.sf.net .     */
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED
name|png_flush
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CONVERT_tIME_SUPPORTED
end_ifdef
begin_comment
comment|/* "tm" structure is not supported on WindowsCE */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_convert_from_struct_tm
name|png_convert_from_struct_tm
parameter_list|(
name|png_timep
name|ptime
parameter_list|,
name|PNG_CONST
name|struct
name|tm
name|FAR
modifier|*
name|ttime
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_convert_from_struct_tm"
argument_list|)
expr_stmt|;
name|ptime
operator|->
name|year
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
literal|1900
operator|+
name|ttime
operator|->
name|tm_year
argument_list|)
expr_stmt|;
name|ptime
operator|->
name|month
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|ttime
operator|->
name|tm_mon
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptime
operator|->
name|day
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_mday
expr_stmt|;
name|ptime
operator|->
name|hour
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_hour
expr_stmt|;
name|ptime
operator|->
name|minute
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_min
expr_stmt|;
name|ptime
operator|->
name|second
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_sec
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_convert_from_time_t
name|png_convert_from_time_t
parameter_list|(
name|png_timep
name|ptime
parameter_list|,
name|time_t
name|ttime
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tbuf
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_convert_from_time_t"
argument_list|)
expr_stmt|;
name|tbuf
operator|=
name|gmtime
argument_list|(
operator|&
name|ttime
argument_list|)
expr_stmt|;
name|png_convert_from_struct_tm
argument_list|(
name|ptime
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Initialize png_ptr structure, and allocate any memory needed */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_write_struct
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
return|return
operator|(
name|png_create_write_struct_2
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_block
begin_comment
comment|/* Alternate initialize png_ptr structure, and allocate any memory needed */
end_comment
begin_function_decl
specifier|static
name|void
name|png_reset_filter_heuristics
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* forward decl */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_write_struct_2
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,     png_malloc_ptr malloc_fn, png_free_ptr free_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
endif|#
directive|endif
comment|/* PNG_USER_MEM_SUPPORTED */
specifier|volatile
name|int
name|png_cleanup_needed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
specifier|volatile
endif|#
directive|endif
name|png_structp
name|png_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
name|jmp_buf
name|png_jmpbuf
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_create_write_struct"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_ptr
operator|=
operator|(
name|png_structp
operator|)
name|png_create_struct_2
argument_list|(
name|PNG_STRUCT_PNG
argument_list|,
operator|(
name|png_malloc_ptr
operator|)
name|malloc_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_ptr
operator|=
operator|(
name|png_structp
operator|)
name|png_create_struct
argument_list|(
name|PNG_STRUCT_PNG
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_USER_MEM_SUPPORTED */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Added at libpng-1.2.6 */
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
name|png_ptr
operator|->
name|user_width_max
operator|=
name|PNG_USER_WIDTH_MAX
expr_stmt|;
name|png_ptr
operator|->
name|user_height_max
operator|=
name|PNG_USER_HEIGHT_MAX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* Applications that neglect to set up their own setjmp() and then    encounter a png_error() will longjmp here.  Since the jmpbuf is    then meaningless we abort instead of returning. */
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
condition|)
comment|/* sets longjmp to match setjmp */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
name|png_memcpy
argument_list|(
name|png_jmpbuf
argument_list|(
name|png_ptr
argument_list|)
argument_list|,
name|png_jmpbuf
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PNG_ABORT
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_set_mem_fn
argument_list|(
name|png_ptr
argument_list|,
name|mem_ptr
argument_list|,
name|malloc_fn
argument_list|,
name|free_fn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_USER_MEM_SUPPORTED */
name|png_set_error_fn
argument_list|(
name|png_ptr
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_png_ver
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|user_png_ver
index|[
name|i
index|]
operator|!=
name|png_libpng_ver
index|[
name|i
index|]
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_LIBRARY_MISMATCH
expr_stmt|;
block|}
do|while
condition|(
name|png_libpng_ver
index|[
name|i
operator|++
index|]
condition|)
do|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_LIBRARY_MISMATCH
condition|)
block|{
comment|/* Libpng 0.90 and later are binary incompatible with libpng 0.89, so       * we must recompile any applications that use any older library version.       * For versions after libpng 1.0, we will be compatible, so we need       * only check the first digit.       */
if|if
condition|(
name|user_png_ver
operator|==
name|NULL
operator|||
name|user_png_ver
index|[
literal|0
index|]
operator|!=
name|png_libpng_ver
index|[
literal|0
index|]
operator|||
operator|(
name|user_png_ver
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|user_png_ver
index|[
literal|2
index|]
operator|!=
name|png_libpng_ver
index|[
literal|2
index|]
operator|)
operator|||
operator|(
name|user_png_ver
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|user_png_ver
index|[
literal|2
index|]
operator|<
literal|'9'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
name|char
name|msg
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|user_png_ver
condition|)
block|{
name|png_snprintf2
argument_list|(
name|msg
argument_list|,
literal|80
argument_list|,
literal|"Application built with libpng-%.20s"
literal|" but running with %.20s"
argument_list|,
name|user_png_ver
argument_list|,
name|png_libpng_ver
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incompatible libpng version in application and library"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
name|png_ptr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Initialize zbuf - compression buffer */
name|png_ptr
operator|->
name|zbuf_size
operator|=
name|PNG_ZBUF_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|png_cleanup_needed
condition|)
block|{
name|png_ptr
operator|->
name|zbuf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zbuf
operator|==
name|NULL
condition|)
name|png_cleanup_needed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|png_cleanup_needed
condition|)
block|{
comment|/* Clean up PNG structure and deallocate any memory. */
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zbuf
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|,
operator|(
name|png_free_ptr
operator|)
name|free_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|png_set_write_fn
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
name|png_reset_filter_heuristics
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|png_ptr
operator|)
return|;
block|}
end_block
begin_comment
comment|/* Write a few rows of image data.  If the image is interlaced,  * either you will have to write the 7 sub images, or, if you  * have called png_set_interlace_handling(), you will have to  * "write" the image seven times.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_rows
name|png_write_rows
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytepp
name|row
parameter_list|,
name|png_uint_32
name|num_rows
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
comment|/* row counter */
name|png_bytepp
name|rp
decl_stmt|;
comment|/* row pointer */
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_rows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Loop through the rows */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Write the image.  You only need to call this function once, even  * if you are writing an interlaced image.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_image
name|png_write_image
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytepp
name|image
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
comment|/* row index */
name|int
name|pass
decl_stmt|,
name|num_pass
decl_stmt|;
comment|/* pass variables */
name|png_bytepp
name|rp
decl_stmt|;
comment|/* points to current row */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_image"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Initialize interlace handling.  If image is not interlaced,     * this will set pass to 1     */
name|num_pass
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|num_pass
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Loop through passes */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_pass
condition|;
name|pass
operator|++
control|)
block|{
comment|/* Loop through image */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|image
init|;
name|i
operator|<
name|png_ptr
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Called by user to write a row of image data */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_row
name|png_write_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|row
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_debug2
argument_list|(
literal|1
argument_list|,
literal|"in png_write_row (row %u, pass %d)"
argument_list|,
name|png_ptr
operator|->
name|row_number
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|)
expr_stmt|;
comment|/* Initialize transformations and other stuff if first time */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* Make sure we wrote the header info */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_INFO_BEFORE_PLTE
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_write_info was never called before png_write_row"
argument_list|)
expr_stmt|;
comment|/* Check for transforms that have been set but were defined out */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_INVERT_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_INVERT_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_MONO
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_INVERT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_FILLER_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_FILLER_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_FILLER
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_FILLER_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_PACKSWAP_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_READ_PACKSWAP_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_PACKSWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_PACK_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_PACK_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_PACK_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_SHIFT_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_SHIFT_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SHIFT
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_SHIFT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_BGR_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_BGR_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BGR
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_BGR_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_SWAP_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_SWAP_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SWAP_BYTES
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_SWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_write_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* If interlaced and not interested in row, return */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
switch|switch
condition|(
name|png_ptr
operator|->
name|pass
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|5
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|!=
literal|4
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x03
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|3
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x03
operator|)
operator|!=
literal|2
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|5
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x01
operator|)
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|2
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|6
case|:
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x01
operator|)
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
comment|/* error: ignore it */
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* Set up row info for transformations */
name|png_ptr
operator|->
name|row_info
operator|.
name|color_type
operator|=
name|png_ptr
operator|->
name|color_type
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|width
operator|=
name|png_ptr
operator|->
name|usr_width
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|channels
operator|=
name|png_ptr
operator|->
name|usr_channels
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|bit_depth
operator|=
name|png_ptr
operator|->
name|usr_bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|row_info
operator|.
name|bit_depth
operator|*
name|png_ptr
operator|->
name|row_info
operator|.
name|channels
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->color_type = %d"
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|color_type
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->width = %u"
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->channels = %d"
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|channels
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->bit_depth = %d"
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|bit_depth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->pixel_depth = %d"
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->rowbytes = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|row_info
operator|.
name|rowbytes
argument_list|)
expr_stmt|;
comment|/* Copy user's row into buffer, leaving room for filter byte. */
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|row
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|rowbytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Handle interlacing */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|&&
name|png_ptr
operator|->
name|pass
operator|<
literal|6
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
name|png_do_write_interlace
argument_list|(
operator|&
operator|(
name|png_ptr
operator|->
name|row_info
operator|)
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|)
expr_stmt|;
comment|/* This should always get caught above, but still ... */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|row_info
operator|.
name|width
operator|)
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* Handle other transformations */
if|if
condition|(
name|png_ptr
operator|->
name|transformations
condition|)
name|png_do_write_transformations
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
comment|/* Write filter_method 64 (intrapixel differencing) only if     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and     * 2. Libpng did not write a PNG signature (this filter_method is only     *    used in PNG datastreams that are embedded in MNG datastreams) and     * 3. The application called png_permit_mng_features with a mask that     *    included PNG_FLAG_MNG_FILTER_64 and     * 4. The filter_method is 64 and     * 5. The color_type is RGB or RGBA     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|&&
operator|(
name|png_ptr
operator|->
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
condition|)
block|{
comment|/* Intrapixel differencing */
name|png_do_write_intrapixel
argument_list|(
operator|&
operator|(
name|png_ptr
operator|->
name|row_info
operator|)
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Find a filter if necessary, filter the row and write it out. */
name|png_write_find_filter
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|row_info
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|write_row_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|write_row_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|png_ptr
operator|->
name|row_number
operator|,
name|png_ptr
operator|->
name|pass
operator|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
end_ifdef
begin_comment
comment|/* Set the automatic flush interval or 0 to turn flushing off */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_flush
name|png_set_flush
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|nrows
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_flush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|flush_dist
operator|=
operator|(
name|nrows
operator|<
literal|0
condition|?
literal|0
else|:
name|nrows
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Flush the current output buffers now */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_flush
name|png_write_flush
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|int
name|wrote_IDAT
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_flush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* We have already written out all of the data */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|>=
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
do|do
block|{
name|int
name|ret
decl_stmt|;
comment|/* Compress the data */
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
name|wrote_IDAT
operator|=
literal|0
expr_stmt|;
comment|/* Check for compression errors */
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib error"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
condition|)
block|{
comment|/* Write the IDAT and reset the zlib output buffer */
name|png_write_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|wrote_IDAT
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|wrote_IDAT
operator|==
literal|1
condition|)
do|;
comment|/* If there is any data left to be output, write it into a new IDAT */
if|if
condition|(
name|png_ptr
operator|->
name|zbuf_size
operator|!=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
condition|)
block|{
comment|/* Write the IDAT and reset the zlib output buffer */
name|png_write_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
block|}
name|png_ptr
operator|->
name|flush_rows
operator|=
literal|0
expr_stmt|;
name|png_flush
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_WRITE_FLUSH_SUPPORTED */
end_comment
begin_comment
comment|/* Free all memory used by the write */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_destroy_write_struct
name|png_destroy_write_struct
parameter_list|(
name|png_structpp
name|png_ptr_ptr
parameter_list|,
name|png_infopp
name|info_ptr_ptr
parameter_list|)
block|{
name|png_structp
name|png_ptr
init|=
name|NULL
decl_stmt|;
name|png_infop
name|info_ptr
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_free_ptr
name|free_fn
init|=
name|NULL
decl_stmt|;
name|png_voidp
name|mem_ptr
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_destroy_write_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_ptr
operator|=
operator|*
name|png_ptr_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|free_fn
operator|=
name|png_ptr
operator|->
name|free_fn
expr_stmt|;
name|mem_ptr
operator|=
name|png_ptr
operator|->
name|mem_ptr
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|free_fn
operator|=
name|png_ptr
operator|->
name|free_fn
expr_stmt|;
name|mem_ptr
operator|=
name|png_ptr
operator|->
name|mem_ptr
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|info_ptr_ptr
operator|!=
name|NULL
condition|)
name|info_ptr
operator|=
operator|*
name|info_ptr_ptr
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ALL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|num_chunk_list
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_chunk_list
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|,
operator|(
name|png_free_ptr
operator|)
name|free_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|info_ptr_ptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_write_destroy
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|,
operator|(
name|png_free_ptr
operator|)
name|free_fn
argument_list|,
operator|(
name|png_voidp
operator|)
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|png_ptr_ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Free any memory used in png_ptr struct (old method) */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_destroy
name|png_write_destroy
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|jmp_buf
name|tmp_jmp
decl_stmt|;
comment|/* Save jump buffer */
endif|#
directive|endif
name|png_error_ptr
name|error_fn
decl_stmt|;
name|png_error_ptr
name|warning_fn
decl_stmt|;
name|png_voidp
name|error_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_free_ptr
name|free_fn
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_destroy"
argument_list|)
expr_stmt|;
comment|/* Free any memory zlib uses */
name|deflateEnd
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
comment|/* Free our memory.  png_free checks NULL for us. */
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|prev_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|sub_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|up_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|avg_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|paeth_row
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|time_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* Use this to save a little code space, it doesn't free the filter_costs */
name|png_reset_filter_heuristics
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|filter_costs
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|inv_filter_costs
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* Reset structure */
name|png_memcpy
argument_list|(
name|tmp_jmp
argument_list|,
name|png_ptr
operator|->
name|png_jmpbuf
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error_fn
operator|=
name|png_ptr
operator|->
name|error_fn
expr_stmt|;
name|warning_fn
operator|=
name|png_ptr
operator|->
name|warning_fn
expr_stmt|;
name|error_ptr
operator|=
name|png_ptr
operator|->
name|error_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|free_fn
operator|=
name|png_ptr
operator|->
name|free_fn
expr_stmt|;
endif|#
directive|endif
name|png_memset
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|,
name|png_sizeof
argument_list|(
name|png_struct
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|error_fn
operator|=
name|error_fn
expr_stmt|;
name|png_ptr
operator|->
name|warning_fn
operator|=
name|warning_fn
expr_stmt|;
name|png_ptr
operator|->
name|error_ptr
operator|=
name|error_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_ptr
operator|->
name|free_fn
operator|=
name|free_fn
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|png_jmpbuf
argument_list|,
name|tmp_jmp
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* Allow the application to select one or more row filters to use. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_filter
name|png_set_filter
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|method
parameter_list|,
name|int
name|filters
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_filter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|&&
operator|(
name|method
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
condition|)
name|method
operator|=
name|PNG_FILTER_TYPE_BASE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|method
operator|==
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
switch|switch
condition|(
name|filters
operator|&
operator|(
name|PNG_ALL_FILTERS
operator||
literal|0x07
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown row filter for method 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_WRITE_FILTER_SUPPORTED */
case|case
name|PNG_FILTER_VALUE_NONE
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_NONE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
case|case
name|PNG_FILTER_VALUE_SUB
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_SUB
expr_stmt|;
break|break;
case|case
name|PNG_FILTER_VALUE_UP
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_UP
expr_stmt|;
break|break;
case|case
name|PNG_FILTER_VALUE_AVG
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_AVG
expr_stmt|;
break|break;
case|case
name|PNG_FILTER_VALUE_PAETH
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_PAETH
expr_stmt|;
break|break;
default|default:
name|png_ptr
operator|->
name|do_filter
operator|=
operator|(
name|png_byte
operator|)
name|filters
expr_stmt|;
break|break;
else|#
directive|else
default|default:
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown row filter for method 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_WRITE_FILTER_SUPPORTED */
block|}
comment|/* If we have allocated the row_buf, this means we have already started        * with the image and we should have allocated all of the filter buffers        * that have been selected.  If prev_row isn't already allocated, then        * it is too late to start using the filters that need it, since we        * will be missing the data in the previous row.  If an application        * wants to start and stop using particular filters during compression,        * it should start out with all of the filters, and then add and        * remove them after the start of compression.        */
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_SUB
operator|)
operator|&&
name|png_ptr
operator|->
name|sub_row
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|sub_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sub_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_SUB
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_UP
operator|)
operator|&&
name|png_ptr
operator|->
name|up_row
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't add Up filter after starting"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|do_filter
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|do_filter
operator|&
operator|~
name|PNG_FILTER_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|up_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|up_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_UP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_AVG
operator|)
operator|&&
name|png_ptr
operator|->
name|avg_row
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't add Average filter after starting"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|do_filter
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|do_filter
operator|&
operator|~
name|PNG_FILTER_AVG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|avg_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|avg_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_AVG
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_PAETH
operator|)
operator|&&
name|png_ptr
operator|->
name|paeth_row
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't add Paeth filter after starting"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|do_filter
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|~
name|PNG_FILTER_PAETH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|paeth_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|paeth_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_PAETH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|==
name|PNG_NO_FILTERS
condition|)
endif|#
directive|endif
comment|/* PNG_WRITE_FILTER_SUPPORTED */
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_NONE
expr_stmt|;
block|}
block|}
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown custom filter method"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This allows us to influence the way in which libpng chooses the "best"  * filter for the current scanline.  While the "minimum-sum-of-absolute-  * differences metric is relatively fast and effective, there is some  * question as to whether it can be improved upon by trying to keep the  * filtered data going to zlib more consistent, hopefully resulting in  * better compression.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
end_ifdef
begin_comment
comment|/* GRR 970116 */
end_comment
begin_comment
comment|/* Conveneince reset API. */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_reset_filter_heuristics
name|png_reset_filter_heuristics
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Clear out any old values in the 'weights' - this must be done because if     * the app calls set_filter_heuristics multiple times with different     * 'num_weights' values we would otherwise potentially have wrong sized     * arrays.     */
name|png_ptr
operator|->
name|num_prev_filters
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|heuristic_method
operator|=
name|PNG_FILTER_HEURISTIC_UNWEIGHTED
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
operator|!=
name|NULL
condition|)
block|{
name|png_bytep
name|old
init|=
name|png_ptr
operator|->
name|prev_filters
decl_stmt|;
name|png_ptr
operator|->
name|prev_filters
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|filter_weights
operator|!=
name|NULL
condition|)
block|{
name|png_uint_16p
name|old
init|=
name|png_ptr
operator|->
name|filter_weights
decl_stmt|;
name|png_ptr
operator|->
name|filter_weights
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|inv_filter_weights
operator|!=
name|NULL
condition|)
block|{
name|png_uint_16p
name|old
init|=
name|png_ptr
operator|->
name|inv_filter_weights
decl_stmt|;
name|png_ptr
operator|->
name|inv_filter_weights
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|/* Leave the filter_costs - this array is fixed size. */
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_init_filter_heuristics
name|png_init_filter_heuristics
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|heuristic_method
parameter_list|,
name|int
name|num_weights
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Clear out the arrays */
name|png_reset_filter_heuristics
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Check arguments; the 'reset' function makes the correct settings for the     * unweighted case, but we must handle the weight case by initializing the     * arrays for the caller.     */
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_weights
operator|>
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|prev_filters
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|png_sizeof
argument_list|(
name|png_byte
argument_list|)
operator|*
name|num_weights
argument_list|)
argument_list|)
expr_stmt|;
comment|/* To make sure that the weighting starts out fairly */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
name|png_ptr
operator|->
name|prev_filters
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|png_ptr
operator|->
name|filter_weights
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|*
name|num_weights
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|inv_filter_weights
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|*
name|num_weights
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
name|PNG_WEIGHT_FACTOR
expr_stmt|;
block|}
comment|/* Safe to set this now */
name|png_ptr
operator|->
name|num_prev_filters
operator|=
operator|(
name|png_byte
operator|)
name|num_weights
expr_stmt|;
block|}
comment|/* If, in the future, there are other filter methods, this would        * need to be based on png_ptr->filter.        */
if|if
condition|(
name|png_ptr
operator|->
name|filter_costs
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|filter_costs
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|*
name|PNG_FILTER_VALUE_LAST
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|inv_filter_costs
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|*
name|PNG_FILTER_VALUE_LAST
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNG_FILTER_VALUE_LAST
condition|;
name|i
operator|++
control|)
block|{
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_costs
index|[
name|i
index|]
operator|=
name|PNG_COST_FACTOR
expr_stmt|;
block|}
comment|/* All the arrays are inited, safe to set this: */
name|png_ptr
operator|->
name|heuristic_method
operator|=
name|PNG_FILTER_HEURISTIC_WEIGHTED
expr_stmt|;
comment|/* Return the 'ok' code. */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_DEFAULT
operator|||
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_UNWEIGHTED
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter heuristic method"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/* Provide floating and fixed point APIs */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_filter_heuristics
name|png_set_filter_heuristics
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|heuristic_method
parameter_list|,
name|int
name|num_weights
parameter_list|,
name|png_const_doublep
name|filter_weights
parameter_list|,
name|png_const_doublep
name|filter_costs
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_filter_heuristics"
argument_list|)
expr_stmt|;
comment|/* The internal API allocates all the arrays and ensures that the elements of     * those arrays are set to the default value.     */
if|if
condition|(
operator|!
name|png_init_filter_heuristics
argument_list|(
name|png_ptr
argument_list|,
name|heuristic_method
argument_list|,
name|num_weights
argument_list|)
condition|)
return|return;
comment|/* If using the weighted method copy in the weights. */
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter_weights
index|[
name|i
index|]
operator|<=
literal|0.0
condition|)
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
name|PNG_WEIGHT_FACTOR
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_WEIGHT_FACTOR
operator|*
name|filter_weights
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_WEIGHT_FACTOR
operator|/
name|filter_weights
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here is where we set the relative costs of the different filters.  We        * should take the desired compression level into account when setting        * the costs, so that Paeth, for instance, has a high relative cost at low        * compression levels, while it has a lower relative cost at higher        * compression settings.  The filter types are in order of increasing        * relative cost, so it would be possible to do this with an algorithm.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNG_FILTER_VALUE_LAST
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|filter_costs
index|[
name|i
index|]
operator|>=
literal|1.0
condition|)
block|{
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_COST_FACTOR
operator|/
name|filter_costs
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|filter_costs
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_COST_FACTOR
operator|*
name|filter_costs
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_filter_heuristics_fixed
name|png_set_filter_heuristics_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|heuristic_method
parameter_list|,
name|int
name|num_weights
parameter_list|,
name|png_const_fixed_point_p
name|filter_weights
parameter_list|,
name|png_const_fixed_point_p
name|filter_costs
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_filter_heuristics_fixed"
argument_list|)
expr_stmt|;
comment|/* The internal API allocates all the arrays and ensures that the elements of     * those arrays are set to the default value.     */
if|if
condition|(
operator|!
name|png_init_filter_heuristics
argument_list|(
name|png_ptr
argument_list|,
name|heuristic_method
argument_list|,
name|num_weights
argument_list|)
condition|)
return|return;
comment|/* If using the weighted method copy in the weights. */
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter_weights
index|[
name|i
index|]
operator|<=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
name|PNG_WEIGHT_FACTOR
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|PNG_WEIGHT_FACTOR
operator|*
name|filter_weights
index|[
name|i
index|]
operator|+
name|PNG_FP_HALF
operator|)
operator|/
name|PNG_FP_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|PNG_WEIGHT_FACTOR
operator|*
name|PNG_FP_1
operator|+
operator|(
name|filter_weights
index|[
name|i
index|]
operator|/
literal|2
operator|)
operator|)
operator|/
name|filter_weights
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here is where we set the relative costs of the different filters.  We        * should take the desired compression level into account when setting        * the costs, so that Paeth, for instance, has a high relative cost at low        * compression levels, while it has a lower relative cost at higher        * compression settings.  The filter types are in order of increasing        * relative cost, so it would be possible to do this with an algorithm.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNG_FILTER_VALUE_LAST
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|filter_costs
index|[
name|i
index|]
operator|>=
name|PNG_FP_1
condition|)
block|{
name|png_uint_32
name|tmp
decl_stmt|;
comment|/* Use a 32 bit unsigned temporary here because otherwise the           * intermediate value will be a 32 bit *signed* integer (ANSI rules)           * and this will get the wrong answer on division.           */
name|tmp
operator|=
name|PNG_COST_FACTOR
operator|*
name|PNG_FP_1
operator|+
operator|(
name|filter_costs
index|[
name|i
index|]
operator|/
literal|2
operator|)
expr_stmt|;
name|tmp
operator|/=
name|filter_costs
index|[
name|i
index|]
expr_stmt|;
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|tmp
expr_stmt|;
name|tmp
operator|=
name|PNG_COST_FACTOR
operator|*
name|filter_costs
index|[
name|i
index|]
operator|+
name|PNG_FP_HALF
expr_stmt|;
name|tmp
operator|/=
name|PNG_FP_1
expr_stmt|;
name|png_ptr
operator|->
name|filter_costs
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FIXED_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_level
name|png_set_compression_level
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_CUSTOM_LEVEL
expr_stmt|;
name|png_ptr
operator|->
name|zlib_level
operator|=
name|level
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_mem_level
name|png_set_compression_mem_level
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|mem_level
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_mem_level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL
expr_stmt|;
name|png_ptr
operator|->
name|zlib_mem_level
operator|=
name|mem_level
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_strategy
name|png_set_compression_strategy
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|strategy
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_strategy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_CUSTOM_STRATEGY
expr_stmt|;
name|png_ptr
operator|->
name|zlib_strategy
operator|=
name|strategy
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_window_bits
name|png_set_compression_window_bits
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|window_bits
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|window_bits
operator|>
literal|15
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression windows<= 32k supported by PNG"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|window_bits
operator|<
literal|8
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression windows>= 256 supported by PNG"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WBITS_8_OK
comment|/* Avoid libpng bug with 256-byte windows */
if|if
condition|(
name|window_bits
operator|==
literal|8
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Compression window is being reset to 512"
argument_list|)
expr_stmt|;
name|window_bits
operator|=
literal|9
expr_stmt|;
block|}
endif|#
directive|endif
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS
expr_stmt|;
name|png_ptr
operator|->
name|zlib_window_bits
operator|=
name|window_bits
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_method
name|png_set_compression_method
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|method
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|method
operator|!=
literal|8
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression method 8 is supported by PNG"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_CUSTOM_METHOD
expr_stmt|;
name|png_ptr
operator|->
name|zlib_method
operator|=
name|method
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_write_status_fn
name|png_set_write_status_fn
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_write_status_ptr
name|write_row_fn
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|write_row_fn
operator|=
name|write_row_fn
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_write_user_transform_fn
name|png_set_write_user_transform_fn
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_user_transform_ptr
name|write_user_transform_fn
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_write_user_transform_fn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_USER_TRANSFORM
expr_stmt|;
name|png_ptr
operator|->
name|write_user_transform_fn
operator|=
name|write_user_transform_fn
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_write_png
name|png_write_png
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|transforms
parameter_list|,
name|voidp
name|params
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Write the file header information. */
name|png_write_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* ------ these transformations don't touch the info structure ------- */
ifdef|#
directive|ifdef
name|PNG_WRITE_INVERT_SUPPORTED
comment|/* Invert monochrome pixels */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_MONO
condition|)
name|png_set_invert_mono
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SHIFT_SUPPORTED
comment|/* Shift the pixels up to a legal bit depth and fill in     * as appropriate to correctly scale the image.     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SHIFT
operator|)
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sBIT
operator|)
condition|)
name|png_set_shift
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|sig_bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_PACK_SUPPORTED
comment|/* Pack pixels into bytes */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKING
condition|)
name|png_set_packing
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SWAP_ALPHA_SUPPORTED
comment|/* Swap location of alpha bytes from ARGB to RGBA */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ALPHA
condition|)
name|png_set_swap_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_FILLER_SUPPORTED
comment|/* Pack XRGB/RGBX/ARGB/RGBA into * RGB (4 channels -> 3 channels) */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_FILLER_AFTER
condition|)
name|png_set_filler
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|,
name|PNG_FILLER_AFTER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_FILLER_BEFORE
condition|)
name|png_set_filler
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|,
name|PNG_FILLER_BEFORE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_BGR_SUPPORTED
comment|/* Flip BGR pixels to RGB */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_BGR
condition|)
name|png_set_bgr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SWAP_SUPPORTED
comment|/* Swap bytes of 16-bit files to most significant byte first */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ENDIAN
condition|)
name|png_set_swap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_PACKSWAP_SUPPORTED
comment|/* Swap bits of 1, 2, 4 bit packed pixel formats */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKSWAP
condition|)
name|png_set_packswap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_INVERT_ALPHA_SUPPORTED
comment|/* Invert the alpha channel from opacity to transparency */
if|if
condition|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_ALPHA
condition|)
name|png_set_invert_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ----------------------- end of transformations ------------------- */
comment|/* Write the bits */
if|if
condition|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_IDAT
condition|)
name|png_write_image
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
argument_list|)
expr_stmt|;
comment|/* It is REQUIRED to call this to finish writing the rest of the file */
name|png_write_end
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|transforms
argument_list|)
comment|/* Quiet compiler warnings */
name|PNG_UNUSED
argument_list|(
argument|params
argument_list|)
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_WRITE_SUPPORTED */
end_comment
end_unit
