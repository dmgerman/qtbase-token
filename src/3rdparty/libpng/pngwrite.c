begin_unit
begin_comment
comment|/* pngwrite.c - general routines to write a PNG file  *  * Last changed in libpng 1.6.17 [March 26, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_STDIO_SUPPORTED
argument_list|)
end_if
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_comment
comment|/* Write out all the unknown chunks for the current given location */
end_comment
begin_function
specifier|static
name|void
DECL|function|write_unknown_chunks
name|write_unknown_chunks
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_inforp
name|info_ptr
parameter_list|,
name|unsigned
name|int
name|where
parameter_list|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks_num
operator|!=
literal|0
condition|)
block|{
name|png_const_unknown_chunkp
name|up
decl_stmt|;
name|png_debug
argument_list|(
literal|5
argument_list|,
literal|"writing extra chunks"
argument_list|)
expr_stmt|;
for|for
control|(
name|up
operator|=
name|info_ptr
operator|->
name|unknown_chunks
init|;
name|up
operator|<
name|info_ptr
operator|->
name|unknown_chunks
operator|+
name|info_ptr
operator|->
name|unknown_chunks_num
condition|;
operator|++
name|up
control|)
if|if
condition|(
operator|(
name|up
operator|->
name|location
operator|&
name|where
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If per-chunk unknown chunk handling is enabled use it, otherwise           * just write the chunks the application has set.           */
ifdef|#
directive|ifdef
name|PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
name|int
name|keep
init|=
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* NOTE: this code is radically different from the read side in the           * matter of handling an ancillary unknown chunk.  In the read side           * the default behavior is to discard it, in the code below the default           * behavior is to write it.  Critical chunks are, however, only           * written if explicitly listed or if the default is set to write all           * unknown chunks.           *           * The default handling is also slightly weird - it is not possible to           * stop the writing of all unsafe-to-copy chunks!           *           * TODO: REVIEW: this would seem to be a bug.           */
if|if
condition|(
name|keep
operator|!=
name|PNG_HANDLE_CHUNK_NEVER
operator|&&
operator|(
operator|(
name|up
operator|->
name|name
index|[
literal|3
index|]
operator|&
literal|0x20
operator|)
comment|/* safe-to-copy overrides everything */
operator|||
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|||
operator|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_AS_DEFAULT
operator|&&
name|png_ptr
operator|->
name|unknown_default
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|)
operator|)
condition|)
endif|#
directive|endif
block|{
comment|/* TODO: review, what is wrong with a zero length unknown chunk? */
if|if
condition|(
name|up
operator|->
name|size
operator|==
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Writing zero-length unknown chunk"
argument_list|)
expr_stmt|;
name|png_write_chunk
argument_list|(
name|png_ptr
argument_list|,
name|up
operator|->
name|name
argument_list|,
name|up
operator|->
name|data
argument_list|,
name|up
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_UNKNOWN_CHUNKS */
end_comment
begin_comment
comment|/* Writes all the PNG information.  This is the suggested way to use the  * library.  If you have a new chunk to add, make a function to write it,  * and put it in the correct location here.  If you want the chunk written  * after the image data, put it in png_write_end().  I strongly encourage  * you to supply a PNG_INFO_ flag, and check info_ptr->valid before writing  * the chunk, as that will keep the code from breaking if you want to just  * write a plain PNG file.  If you have long comments, I suggest writing  * them in png_write_end(), and compressing them.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_info_before_PLTE
name|png_write_info_before_PLTE
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_inforp
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_info_before_PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_INFO_BEFORE_PLTE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Write PNG signature */
name|png_write_sig
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|!=
literal|0
operator|&&
expr|\
name|png_ptr
operator|->
name|mng_features_permitted
operator|!=
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"MNG features are not allowed in a PNG datastream"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mng_features_permitted
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Write IHDR information. */
name|png_write_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|width
argument_list|,
name|info_ptr
operator|->
name|height
argument_list|,
name|info_ptr
operator|->
name|bit_depth
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|,
name|info_ptr
operator|->
name|compression_type
argument_list|,
name|info_ptr
operator|->
name|filter_type
argument_list|,
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
name|info_ptr
operator|->
name|interlace_type
else|#
directive|else
literal|0
endif|#
directive|endif
argument_list|)
expr_stmt|;
comment|/* The rest of these check to see if the valid field has the appropriate     * flag set, and if it does, writes the chunk.     *     * 1.6.0: COLORSPACE support controls the writing of these chunks too, and     * the chunks will be written if the WRITE routine is there and information     * is available in the COLORSPACE.  (See png_colorspace_sync_info in png.c     * for where the valid flags get set.)     *     * Under certain circumstances the colorspace can be invalidated without     * syncing the info_struct 'valid' flags; this happens if libpng detects and     * error and calls png_error while the color space is being set, yet the     * application continues writing the PNG.  So check the 'invalid' flag here     * too.     */
ifdef|#
directive|ifdef
name|PNG_GAMMA_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_gAMA_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_FROM_gAMA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_gAMA
operator|)
operator|!=
literal|0
condition|)
name|png_write_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_COLORSPACE_SUPPORTED
comment|/* Write only one of sRGB or an ICC profile.  If a profile was supplied     * and it matches one of the known sRGB ones issue a warning.     */
ifdef|#
directive|ifdef
name|PNG_WRITE_iCCP_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_iCCP
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_sRGB_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
operator|)
operator|!=
literal|0
condition|)
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"profile matches sRGB but writing iCCP instead"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_write_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_name
argument_list|,
name|info_ptr
operator|->
name|iccp_profile
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_sRGB_SUPPORTED
elseif|else
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sRGB_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
operator|)
operator|!=
literal|0
condition|)
name|png_write_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|colorspace
operator|.
name|rendering_intent
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WRITE_sRGB */
endif|#
directive|endif
comment|/* COLORSPACE */
ifdef|#
directive|ifdef
name|PNG_WRITE_sBIT_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sBIT
operator|)
operator|!=
literal|0
condition|)
name|png_write_sBIT
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|sig_bit
operator|)
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_COLORSPACE_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_cHRM_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_FROM_cHRM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_cHRM
operator|)
operator|!=
literal|0
condition|)
name|png_write_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|colorspace
operator|.
name|end_points_xy
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
name|write_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_HAVE_IHDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_WROTE_INFO_BEFORE_PLTE
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_write_info
name|png_write_info
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_inforp
name|info_ptr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_TEXT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_sPLT_SUPPORTED
argument_list|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_write_info_before_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_PLTE
operator|)
operator|!=
literal|0
condition|)
name|png_write_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|palette
argument_list|,
operator|(
name|png_uint_32
operator|)
name|info_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Valid palette required for paletted images"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_tRNS_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_INVERT_ALPHA_SUPPORTED
comment|/* Invert the alpha channel (in tRNS) */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_ALPHA
operator|)
operator|!=
literal|0
operator|&&
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|num_trans
condition|;
name|j
operator|++
control|)
name|info_ptr
operator|->
name|trans_alpha
index|[
name|j
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
name|info_ptr
operator|->
name|trans_alpha
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|png_write_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|trans_alpha
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|trans_color
operator|)
argument_list|,
name|info_ptr
operator|->
name|num_trans
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_bKGD_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_bKGD
operator|)
operator|!=
literal|0
condition|)
name|png_write_bKGD
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|background
operator|)
argument_list|,
name|info_ptr
operator|->
name|color_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_hIST_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_hIST
operator|)
operator|!=
literal|0
condition|)
name|png_write_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|hist
argument_list|,
name|info_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_oFFs_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_oFFs
operator|)
operator|!=
literal|0
condition|)
name|png_write_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|x_offset
argument_list|,
name|info_ptr
operator|->
name|y_offset
argument_list|,
name|info_ptr
operator|->
name|offset_unit_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_pCAL_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pCAL
operator|)
operator|!=
literal|0
condition|)
name|png_write_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_purpose
argument_list|,
name|info_ptr
operator|->
name|pcal_X0
argument_list|,
name|info_ptr
operator|->
name|pcal_X1
argument_list|,
name|info_ptr
operator|->
name|pcal_type
argument_list|,
name|info_ptr
operator|->
name|pcal_nparams
argument_list|,
name|info_ptr
operator|->
name|pcal_units
argument_list|,
name|info_ptr
operator|->
name|pcal_params
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_sCAL_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sCAL
operator|)
operator|!=
literal|0
condition|)
name|png_write_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|scal_unit
argument_list|,
name|info_ptr
operator|->
name|scal_s_width
argument_list|,
name|info_ptr
operator|->
name|scal_s_height
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sCAL */
ifdef|#
directive|ifdef
name|PNG_WRITE_pHYs_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pHYs
operator|)
operator|!=
literal|0
condition|)
name|png_write_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|x_pixels_per_unit
argument_list|,
name|info_ptr
operator|->
name|y_pixels_per_unit
argument_list|,
name|info_ptr
operator|->
name|phys_unit_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pHYs */
ifdef|#
directive|ifdef
name|PNG_WRITE_tIME_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tIME
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_write_tIME
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|mod_time
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_WROTE_tIME
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* tIME */
ifdef|#
directive|ifdef
name|PNG_WRITE_sPLT_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sPLT
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|splt_palettes_num
condition|;
name|i
operator|++
control|)
name|png_write_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
operator|+
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sPLT */
ifdef|#
directive|ifdef
name|PNG_WRITE_TEXT_SUPPORTED
comment|/* Check to see if we need to write text chunks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_text
condition|;
name|i
operator|++
control|)
block|{
name|png_debug2
argument_list|(
literal|2
argument_list|,
literal|"Writing header text chunk %d, type %d"
argument_list|,
name|i
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
comment|/* An internationalized chunk? */
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_iTXt_SUPPORTED
comment|/* Write international chunk */
name|png_write_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
comment|/* Mark this chunk as written */
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
else|else
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt_WR
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write international text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If we want a compressed text chunk */
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_zTXt
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_zTXt_SUPPORTED
comment|/* Write compressed chunk */
name|png_write_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt_WR
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write compressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_tEXt_SUPPORTED
comment|/* Write uncompressed chunk */
name|png_write_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
else|#
directive|else
comment|/* Can't get here */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write uncompressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* tEXt */
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
name|write_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_HAVE_PLTE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* Writes the end of the PNG file.  If you don't want to write comments or  * time information, you can pass NULL for info.  If you already wrote these  * in png_write_info(), do not write them again here.  If you have long  * comments, I suggest writing them here, and compressing them.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_end
name|png_write_end
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_end"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"No IDATs written into file"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|num_palette_max
operator|>
name|png_ptr
operator|->
name|num_palette
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Wrote palette index exceeding num_palette"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if user wants us to write information chunks */
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_TEXT_SUPPORTED
name|int
name|i
decl_stmt|;
comment|/* local index variable */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_tIME_SUPPORTED
comment|/* Check to see if user has supplied a time chunk */
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tIME
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_tIME
operator|)
operator|==
literal|0
condition|)
name|png_write_tIME
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|mod_time
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_TEXT_SUPPORTED
comment|/* Loop through comment chunks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_text
condition|;
name|i
operator|++
control|)
block|{
name|png_debug2
argument_list|(
literal|2
argument_list|,
literal|"Writing trailer text chunk %d, type %d"
argument_list|,
name|i
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
comment|/* An internationalized chunk? */
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_iTXt_SUPPORTED
comment|/* Write international chunk */
name|png_write_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|lang_key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
comment|/* Mark this chunk as written */
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
else|else
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt_WR
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write international text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|>=
name|PNG_TEXT_COMPRESSION_zTXt
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_zTXt_SUPPORTED
comment|/* Write compressed chunk */
name|png_write_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
argument_list|)
expr_stmt|;
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt_WR
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write compressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_tEXt_SUPPORTED
comment|/* Write uncompressed chunk */
name|png_write_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark this chunk as written */
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE_WR
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unable to write uncompressed text"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
name|write_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_AFTER_IDAT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
comment|/* Write end of PNG file */
name|png_write_IEND
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,     * and restored again in libpng-1.2.30, may cause some applications that     * do not set png_ptr->output_flush_fn to crash.  If your application     * experiences a problem, please try building libpng with     * PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED defined, and report the event to     * png-mng-implement at lists.sf.net .     */
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED
name|png_flush
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CONVERT_tIME_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_convert_from_struct_tm
name|png_convert_from_struct_tm
parameter_list|(
name|png_timep
name|ptime
parameter_list|,
name|PNG_CONST
name|struct
name|tm
modifier|*
name|ttime
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_convert_from_struct_tm"
argument_list|)
expr_stmt|;
name|ptime
operator|->
name|year
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
literal|1900
operator|+
name|ttime
operator|->
name|tm_year
argument_list|)
expr_stmt|;
name|ptime
operator|->
name|month
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|ttime
operator|->
name|tm_mon
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptime
operator|->
name|day
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_mday
expr_stmt|;
name|ptime
operator|->
name|hour
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_hour
expr_stmt|;
name|ptime
operator|->
name|minute
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_min
expr_stmt|;
name|ptime
operator|->
name|second
operator|=
operator|(
name|png_byte
operator|)
name|ttime
operator|->
name|tm_sec
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_convert_from_time_t
name|png_convert_from_time_t
parameter_list|(
name|png_timep
name|ptime
parameter_list|,
name|time_t
name|ttime
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tbuf
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_convert_from_time_t"
argument_list|)
expr_stmt|;
name|tbuf
operator|=
name|gmtime
argument_list|(
operator|&
name|ttime
argument_list|)
expr_stmt|;
name|png_convert_from_struct_tm
argument_list|(
name|ptime
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Initialize png_ptr structure, and allocate any memory needed */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_write_struct
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
ifndef|#
directive|ifndef
name|PNG_USER_MEM_SUPPORTED
name|png_structrp
name|png_ptr
init|=
name|png_create_png_struct
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
else|#
directive|else
return|return
name|png_create_write_struct_2
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* Alternate initialize png_ptr structure, and allocate any memory needed */
end_comment
begin_macro
name|PNG_FUNCTION
argument_list|(
argument|png_structp
argument_list|,
argument|PNGAPI png_create_write_struct_2
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,     png_malloc_ptr malloc_fn, png_free_ptr free_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_structrp
name|png_ptr
init|=
name|png_create_png_struct
argument_list|(
name|user_png_ver
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|,
name|mem_ptr
argument_list|,
name|malloc_fn
argument_list|,
name|free_fn
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* USER_MEM */
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Set the zlib control values to defaults; they can be overridden by the        * application after the struct has been created.        */
name|png_ptr
operator|->
name|zbuffer_size
operator|=
name|PNG_ZBUF_SIZE
expr_stmt|;
comment|/* The 'zlib_strategy' setting is irrelevant because png_default_claim in        * pngwutil.c defaults it according to whether or not filters will be        * used, and ignores this setting.        */
name|png_ptr
operator|->
name|zlib_strategy
operator|=
name|PNG_Z_DEFAULT_STRATEGY
expr_stmt|;
name|png_ptr
operator|->
name|zlib_level
operator|=
name|PNG_Z_DEFAULT_COMPRESSION
expr_stmt|;
name|png_ptr
operator|->
name|zlib_mem_level
operator|=
literal|8
expr_stmt|;
name|png_ptr
operator|->
name|zlib_window_bits
operator|=
literal|15
expr_stmt|;
name|png_ptr
operator|->
name|zlib_method
operator|=
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
name|png_ptr
operator|->
name|zlib_text_strategy
operator|=
name|PNG_TEXT_Z_DEFAULT_STRATEGY
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_level
operator|=
name|PNG_TEXT_Z_DEFAULT_COMPRESSION
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_mem_level
operator|=
literal|8
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_window_bits
operator|=
literal|15
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_method
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
comment|/* WRITE_COMPRESSED_TEXT */
comment|/* This is a highly dubious configuration option; by default it is off,        * but it may be appropriate for private builds that are testing        * extensions not conformant to the current specification, or of        * applications that must not fail to write at all costs!        */
ifdef|#
directive|ifdef
name|PNG_BENIGN_WRITE_ERRORS_SUPPORTED
comment|/* In stable builds only warn if an application error can be completely        * handled.        */
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_BENIGN_ERRORS_WARN
expr_stmt|;
endif|#
directive|endif
comment|/* App warnings are warnings in release (or release candidate) builds but        * are errors during development.        */
if|#
directive|if
name|PNG_LIBPNG_BUILD_BASE_TYPE
operator|>=
name|PNG_LIBPNG_BUILD_RC
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_APP_WARNINGS_WARN
expr_stmt|;
endif|#
directive|endif
comment|/* TODO: delay this, it can be done in png_init_io() (if the app doesn't        * do it itself) avoiding setting the default function if it is not        * required.        */
name|png_set_write_fn
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|png_ptr
return|;
block|}
end_block
begin_comment
comment|/* Write a few rows of image data.  If the image is interlaced,  * either you will have to write the 7 sub images, or, if you  * have called png_set_interlace_handling(), you will have to  * "write" the image seven times.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_rows
name|png_write_rows
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytepp
name|row
parameter_list|,
name|png_uint_32
name|num_rows
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
comment|/* row counter */
name|png_bytepp
name|rp
decl_stmt|;
comment|/* row pointer */
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_rows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Loop through the rows */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Write the image.  You only need to call this function once, even  * if you are writing an interlaced image.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_image
name|png_write_image
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytepp
name|image
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
comment|/* row index */
name|int
name|pass
decl_stmt|,
name|num_pass
decl_stmt|;
comment|/* pass variables */
name|png_bytepp
name|rp
decl_stmt|;
comment|/* points to current row */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_image"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Initialize interlace handling.  If image is not interlaced,     * this will set pass to 1     */
name|num_pass
operator|=
name|png_set_interlace_handling
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|num_pass
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Loop through passes */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_pass
condition|;
name|pass
operator|++
control|)
block|{
comment|/* Loop through image */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|image
init|;
name|i
operator|<
name|png_ptr
operator|->
name|height
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
end_ifdef
begin_comment
comment|/* Performs intrapixel differencing  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_write_intrapixel
name|png_do_write_intrapixel
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_write_intrapixel"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|bytes_per_pixel
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
name|bytes_per_pixel
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|bytes_per_pixel
operator|=
literal|4
expr_stmt|;
else|else
return|return;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|rp
operator|+=
name|bytes_per_pixel
control|)
block|{
operator|*
operator|(
name|rp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|*
name|rp
operator|-
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|*
operator|(
name|rp
operator|+
literal|2
operator|)
operator|-
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
name|bytes_per_pixel
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|bytes_per_pixel
operator|=
literal|8
expr_stmt|;
else|else
return|return;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|rp
operator|+=
name|bytes_per_pixel
control|)
block|{
name|png_uint_32
name|s0
init|=
operator|(
operator|*
operator|(
name|rp
operator|)
operator|<<
literal|8
operator|)
operator||
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
decl_stmt|;
name|png_uint_32
name|s1
init|=
operator|(
operator|*
operator|(
name|rp
operator|+
literal|2
operator|)
operator|<<
literal|8
operator|)
operator||
operator|*
operator|(
name|rp
operator|+
literal|3
operator|)
decl_stmt|;
name|png_uint_32
name|s2
init|=
operator|(
operator|*
operator|(
name|rp
operator|+
literal|4
operator|)
operator|<<
literal|8
operator|)
operator||
operator|*
operator|(
name|rp
operator|+
literal|5
operator|)
decl_stmt|;
name|png_uint_32
name|red
init|=
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
name|s0
operator|-
name|s1
operator|)
operator|&
literal|0xffffL
argument_list|)
decl_stmt|;
name|png_uint_32
name|blue
init|=
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
name|s2
operator|-
name|s1
operator|)
operator|&
literal|0xffffL
argument_list|)
decl_stmt|;
operator|*
operator|(
name|rp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|red
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|1
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|red
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|blue
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rp
operator|+
literal|5
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|blue
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* WRITE_16BIT */
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MNG_FEATURES */
end_comment
begin_comment
comment|/* Called by user to write a row of image data */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_row
name|png_write_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|row
parameter_list|)
block|{
comment|/* 1.5.6: moved from png_struct to be a local structure: */
name|png_row_info
name|row_info
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_debug2
argument_list|(
literal|1
argument_list|,
literal|"in png_write_row (row %u, pass %d)"
argument_list|,
name|png_ptr
operator|->
name|row_number
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|)
expr_stmt|;
comment|/* Initialize transformations and other stuff if first time */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* Make sure we wrote the header info */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_WROTE_INFO_BEFORE_PLTE
operator|)
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_write_info was never called before png_write_row"
argument_list|)
expr_stmt|;
comment|/* Check for transforms that have been set but were defined out */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_INVERT_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_INVERT_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_MONO
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_INVERT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_FILLER_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_FILLER_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_FILLER
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_FILLER_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_PACKSWAP_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_READ_PACKSWAP_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_PACKSWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_PACK_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_PACK_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_PACK_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_SHIFT_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_SHIFT_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SHIFT
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_SHIFT_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_BGR_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_BGR_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BGR
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_BGR_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PNG_WRITE_SWAP_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_SWAP_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SWAP_BYTES
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_WRITE_SWAP_SUPPORTED is not defined"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_write_start_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* If interlaced and not interested in row, return */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|png_ptr
operator|->
name|pass
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|!=
literal|0
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|5
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x07
operator|)
operator|!=
literal|4
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x03
operator|)
operator|!=
literal|0
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|3
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x03
operator|)
operator|!=
literal|2
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|5
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x01
operator|)
operator|!=
literal|0
operator|||
name|png_ptr
operator|->
name|width
operator|<
literal|2
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|6
case|:
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|row_number
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
comment|/* error: ignore it */
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* Set up row info for transformations */
name|row_info
operator|.
name|color_type
operator|=
name|png_ptr
operator|->
name|color_type
expr_stmt|;
name|row_info
operator|.
name|width
operator|=
name|png_ptr
operator|->
name|usr_width
expr_stmt|;
name|row_info
operator|.
name|channels
operator|=
name|png_ptr
operator|->
name|usr_channels
expr_stmt|;
name|row_info
operator|.
name|bit_depth
operator|=
name|png_ptr
operator|->
name|usr_bit_depth
expr_stmt|;
name|row_info
operator|.
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|.
name|bit_depth
operator|*
name|row_info
operator|.
name|channels
argument_list|)
expr_stmt|;
name|row_info
operator|.
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|.
name|pixel_depth
argument_list|,
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->color_type = %d"
argument_list|,
name|row_info
operator|.
name|color_type
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->width = %u"
argument_list|,
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->channels = %d"
argument_list|,
name|row_info
operator|.
name|channels
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->bit_depth = %d"
argument_list|,
name|row_info
operator|.
name|bit_depth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->pixel_depth = %d"
argument_list|,
name|row_info
operator|.
name|pixel_depth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"row_info->rowbytes = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|row_info
operator|.
name|rowbytes
argument_list|)
expr_stmt|;
comment|/* Copy user's row into buffer, leaving room for filter byte. */
name|memcpy
argument_list|(
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|row
argument_list|,
name|row_info
operator|.
name|rowbytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Handle interlacing */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|&&
name|png_ptr
operator|->
name|pass
operator|<
literal|6
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_do_write_interlace
argument_list|(
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|)
expr_stmt|;
comment|/* This should always get caught above, but still ... */
if|if
condition|(
name|row_info
operator|.
name|width
operator|==
literal|0
condition|)
block|{
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_TRANSFORMS_SUPPORTED
comment|/* Handle other transformations */
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|!=
literal|0
condition|)
name|png_do_write_transformations
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* At this point the row_info pixel depth must match the 'transformed' depth,     * which is also the output depth.     */
if|if
condition|(
name|row_info
operator|.
name|pixel_depth
operator|!=
name|png_ptr
operator|->
name|pixel_depth
operator|||
name|row_info
operator|.
name|pixel_depth
operator|!=
name|png_ptr
operator|->
name|transformed_pixel_depth
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal write transform logic error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
comment|/* Write filter_method 64 (intrapixel differencing) only if     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and     * 2. Libpng did not write a PNG signature (this filter_method is only     *    used in PNG datastreams that are embedded in MNG datastreams) and     * 3. The application called png_permit_mng_features with a mask that     *    included PNG_FLAG_MNG_FILTER_64 and     * 4. The filter_method is 64 and     * 5. The color_type is RGB or RGBA     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
condition|)
block|{
comment|/* Intrapixel differencing */
name|png_do_write_intrapixel
argument_list|(
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Added at libpng-1.5.10 */
ifdef|#
directive|ifdef
name|PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
comment|/* Check for out-of-range palette index */
if|if
condition|(
name|row_info
operator|.
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|png_ptr
operator|->
name|num_palette_max
operator|>=
literal|0
condition|)
name|png_do_check_palette_indexes
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Find a filter if necessary, filter the row and write it out. */
name|png_write_find_filter
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|write_row_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|write_row_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|png_ptr
operator|->
name|row_number
operator|,
name|png_ptr
operator|->
name|pass
operator|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
end_ifdef
begin_comment
comment|/* Set the automatic flush interval or 0 to turn flushing off */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_flush
name|png_set_flush
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|nrows
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_flush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|flush_dist
operator|=
operator|(
name|nrows
operator|<
literal|0
condition|?
literal|0
else|:
name|nrows
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Flush the current output buffers now */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_flush
name|png_write_flush
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_flush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* We have already written out all of the data */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|>=
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
name|png_compress_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|flush_rows
operator|=
literal|0
expr_stmt|;
name|png_flush
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_FLUSH */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
end_ifdef
begin_function_decl
specifier|static
name|void
name|png_reset_filter_heuristics
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* forward decl */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Free any memory used in png_ptr struct without freeing the struct itself. */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_destroy
name|png_write_destroy
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_destroy"
argument_list|)
expr_stmt|;
comment|/* Free any memory zlib uses */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_INITIALIZED
operator|)
operator|!=
literal|0
condition|)
name|deflateEnd
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
comment|/* Free our memory.  png_free checks NULL for us. */
name|png_free_buffer_list
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|zbuffer_list
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|row_buf
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|prev_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|sub_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|up_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|avg_row
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|paeth_row
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|prev_row
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|sub_row
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|up_row
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|avg_row
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|paeth_row
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* Use this to save a little code space, it doesn't free the filter_costs */
name|png_reset_filter_heuristics
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|filter_costs
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|inv_filter_costs
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|filter_costs
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|inv_filter_costs
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_list
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* The error handling and memory handling information is left intact at this     * point: the jmp_buf may still have to be freed.  See png_destroy_png_struct     * for how this happens.     */
block|}
end_function
begin_comment
comment|/* Free all memory used by the write.  * In libpng 1.6.0 this API changed quietly to no longer accept a NULL value for  * *png_ptr_ptr.  Prior to 1.6.0 it would accept such a value and it would free  * the passed in info_structs but it would quietly fail to free any of the data  * inside them.  In 1.6.0 it quietly does nothing (it has to be quiet because it  * has no png_ptr.)  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_destroy_write_struct
name|png_destroy_write_struct
parameter_list|(
name|png_structpp
name|png_ptr_ptr
parameter_list|,
name|png_infopp
name|info_ptr_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_destroy_write_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_structrp
name|png_ptr
init|=
operator|*
name|png_ptr_ptr
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
comment|/* added in libpng 1.6.0 */
block|{
name|png_destroy_info_struct
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr_ptr
argument_list|)
expr_stmt|;
operator|*
name|png_ptr_ptr
operator|=
name|NULL
expr_stmt|;
name|png_write_destroy
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_destroy_png_struct
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Allow the application to select one or more row filters to use. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_filter
name|png_set_filter
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|method
parameter_list|,
name|int
name|filters
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_filter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|method
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
condition|)
name|method
operator|=
name|PNG_FILTER_TYPE_BASE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|method
operator|==
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
switch|switch
condition|(
name|filters
operator|&
operator|(
name|PNG_ALL_FILTERS
operator||
literal|0x07
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown row filter for method 0"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
endif|#
directive|endif
comment|/* WRITE_FILTER */
case|case
name|PNG_FILTER_VALUE_NONE
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_NONE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
case|case
name|PNG_FILTER_VALUE_SUB
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_SUB
expr_stmt|;
break|break;
case|case
name|PNG_FILTER_VALUE_UP
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_UP
expr_stmt|;
break|break;
case|case
name|PNG_FILTER_VALUE_AVG
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_AVG
expr_stmt|;
break|break;
case|case
name|PNG_FILTER_VALUE_PAETH
case|:
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_PAETH
expr_stmt|;
break|break;
default|default:
name|png_ptr
operator|->
name|do_filter
operator|=
operator|(
name|png_byte
operator|)
name|filters
expr_stmt|;
break|break;
else|#
directive|else
default|default:
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown row filter for method 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WRITE_FILTER */
block|}
comment|/* If we have allocated the row_buf, this means we have already started        * with the image and we should have allocated all of the filter buffers        * that have been selected.  If prev_row isn't already allocated, then        * it is too late to start using the filters that need it, since we        * will be missing the data in the previous row.  If an application        * wants to start and stop using particular filters during compression,        * it should start out with all of the filters, and then remove them        * or add them back after the start of compression.        */
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_SUB
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|sub_row
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|sub_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sub_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_SUB
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_UP
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|up_row
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't add Up filter after starting"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|do_filter
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|do_filter
operator|&
operator|~
name|PNG_FILTER_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|up_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|up_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_UP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_AVG
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|avg_row
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't add Average filter after starting"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|do_filter
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|do_filter
operator|&
operator|~
name|PNG_FILTER_AVG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|avg_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|avg_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_AVG
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_PAETH
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|paeth_row
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't add Paeth filter after starting"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|do_filter
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|~
name|PNG_FILTER_PAETH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|paeth_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|paeth_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_PAETH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|==
name|PNG_NO_FILTERS
condition|)
endif|#
directive|endif
comment|/* WRITE_FILTER */
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_NONE
expr_stmt|;
block|}
block|}
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown custom filter method"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This allows us to influence the way in which libpng chooses the "best"  * filter for the current scanline.  While the "minimum-sum-of-absolute-  * differences metric is relatively fast and effective, there is some  * question as to whether it can be improved upon by trying to keep the  * filtered data going to zlib more consistent, hopefully resulting in  * better compression.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
end_ifdef
begin_comment
comment|/* GRR 970116 */
end_comment
begin_comment
comment|/* Convenience reset API. */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_reset_filter_heuristics
name|png_reset_filter_heuristics
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Clear out any old values in the 'weights' - this must be done because if     * the app calls set_filter_heuristics multiple times with different     * 'num_weights' values we would otherwise potentially have wrong sized     * arrays.     */
name|png_ptr
operator|->
name|num_prev_filters
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|heuristic_method
operator|=
name|PNG_FILTER_HEURISTIC_UNWEIGHTED
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
operator|!=
name|NULL
condition|)
block|{
name|png_bytep
name|old
init|=
name|png_ptr
operator|->
name|prev_filters
decl_stmt|;
name|png_ptr
operator|->
name|prev_filters
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|filter_weights
operator|!=
name|NULL
condition|)
block|{
name|png_uint_16p
name|old
init|=
name|png_ptr
operator|->
name|filter_weights
decl_stmt|;
name|png_ptr
operator|->
name|filter_weights
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|inv_filter_weights
operator|!=
name|NULL
condition|)
block|{
name|png_uint_16p
name|old
init|=
name|png_ptr
operator|->
name|inv_filter_weights
decl_stmt|;
name|png_ptr
operator|->
name|inv_filter_weights
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|/* Leave the filter_costs - this array is fixed size. */
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_init_filter_heuristics
name|png_init_filter_heuristics
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|heuristic_method
parameter_list|,
name|int
name|num_weights
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Clear out the arrays */
name|png_reset_filter_heuristics
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Check arguments; the 'reset' function makes the correct settings for the     * unweighted case, but we must handle the weight case by initializing the     * arrays for the caller.     */
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_weights
operator|>
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|prev_filters
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
operator|*
name|num_weights
argument_list|)
argument_list|)
expr_stmt|;
comment|/* To make sure that the weighting starts out fairly */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
name|png_ptr
operator|->
name|prev_filters
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|png_ptr
operator|->
name|filter_weights
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
operator|*
name|num_weights
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|inv_filter_weights
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
operator|*
name|num_weights
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
name|PNG_WEIGHT_FACTOR
expr_stmt|;
block|}
comment|/* Safe to set this now */
name|png_ptr
operator|->
name|num_prev_filters
operator|=
operator|(
name|png_byte
operator|)
name|num_weights
expr_stmt|;
block|}
comment|/* If, in the future, there are other filter methods, this would        * need to be based on png_ptr->filter.        */
if|if
condition|(
name|png_ptr
operator|->
name|filter_costs
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|filter_costs
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
operator|*
name|PNG_FILTER_VALUE_LAST
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|inv_filter_costs
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
operator|*
name|PNG_FILTER_VALUE_LAST
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNG_FILTER_VALUE_LAST
condition|;
name|i
operator|++
control|)
block|{
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_costs
index|[
name|i
index|]
operator|=
name|PNG_COST_FACTOR
expr_stmt|;
block|}
comment|/* All the arrays are inited, safe to set this: */
name|png_ptr
operator|->
name|heuristic_method
operator|=
name|PNG_FILTER_HEURISTIC_WEIGHTED
expr_stmt|;
comment|/* Return the 'ok' code. */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_DEFAULT
operator|||
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_UNWEIGHTED
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter heuristic method"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/* Provide floating and fixed point APIs */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_filter_heuristics
name|png_set_filter_heuristics
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|heuristic_method
parameter_list|,
name|int
name|num_weights
parameter_list|,
name|png_const_doublep
name|filter_weights
parameter_list|,
name|png_const_doublep
name|filter_costs
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_filter_heuristics"
argument_list|)
expr_stmt|;
comment|/* The internal API allocates all the arrays and ensures that the elements of     * those arrays are set to the default value.     */
if|if
condition|(
name|png_init_filter_heuristics
argument_list|(
name|png_ptr
argument_list|,
name|heuristic_method
argument_list|,
name|num_weights
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* If using the weighted method copy in the weights. */
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter_weights
index|[
name|i
index|]
operator|<=
literal|0.0
condition|)
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
name|PNG_WEIGHT_FACTOR
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_WEIGHT_FACTOR
operator|*
name|filter_weights
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_WEIGHT_FACTOR
operator|/
name|filter_weights
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here is where we set the relative costs of the different filters.  We        * should take the desired compression level into account when setting        * the costs, so that Paeth, for instance, has a high relative cost at low        * compression levels, while it has a lower relative cost at higher        * compression settings.  The filter types are in order of increasing        * relative cost, so it would be possible to do this with an algorithm.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNG_FILTER_VALUE_LAST
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|filter_costs
index|[
name|i
index|]
operator|>=
literal|1.0
condition|)
block|{
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_COST_FACTOR
operator|/
name|filter_costs
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|filter_costs
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|PNG_COST_FACTOR
operator|*
name|filter_costs
index|[
name|i
index|]
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_filter_heuristics_fixed
name|png_set_filter_heuristics_fixed
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|heuristic_method
parameter_list|,
name|int
name|num_weights
parameter_list|,
name|png_const_fixed_point_p
name|filter_weights
parameter_list|,
name|png_const_fixed_point_p
name|filter_costs
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_filter_heuristics_fixed"
argument_list|)
expr_stmt|;
comment|/* The internal API allocates all the arrays and ensures that the elements of     * those arrays are set to the default value.     */
if|if
condition|(
name|png_init_filter_heuristics
argument_list|(
name|png_ptr
argument_list|,
name|heuristic_method
argument_list|,
name|num_weights
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* If using the weighted method copy in the weights. */
if|if
condition|(
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_weights
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter_weights
index|[
name|i
index|]
operator|<=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
name|PNG_WEIGHT_FACTOR
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|PNG_WEIGHT_FACTOR
operator|*
name|filter_weights
index|[
name|i
index|]
operator|+
name|PNG_FP_HALF
operator|)
operator|/
name|PNG_FP_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|filter_weights
index|[
name|i
index|]
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|PNG_WEIGHT_FACTOR
operator|*
name|PNG_FP_1
operator|+
operator|(
name|filter_weights
index|[
name|i
index|]
operator|/
literal|2
operator|)
operator|)
operator|/
name|filter_weights
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here is where we set the relative costs of the different filters.  We        * should take the desired compression level into account when setting        * the costs, so that Paeth, for instance, has a high relative cost at low        * compression levels, while it has a lower relative cost at higher        * compression settings.  The filter types are in order of increasing        * relative cost, so it would be possible to do this with an algorithm.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PNG_FILTER_VALUE_LAST
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|filter_costs
index|[
name|i
index|]
operator|>=
name|PNG_FP_1
condition|)
block|{
name|png_uint_32
name|tmp
decl_stmt|;
comment|/* Use a 32 bit unsigned temporary here because otherwise the           * intermediate value will be a 32 bit *signed* integer (ANSI rules)           * and this will get the wrong answer on division.           */
name|tmp
operator|=
name|PNG_COST_FACTOR
operator|*
name|PNG_FP_1
operator|+
operator|(
name|filter_costs
index|[
name|i
index|]
operator|/
literal|2
operator|)
expr_stmt|;
name|tmp
operator|/=
name|filter_costs
index|[
name|i
index|]
expr_stmt|;
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|tmp
expr_stmt|;
name|tmp
operator|=
name|PNG_COST_FACTOR
operator|*
name|filter_costs
index|[
name|i
index|]
operator|+
name|PNG_FP_HALF
expr_stmt|;
name|tmp
operator|/=
name|PNG_FP_1
expr_stmt|;
name|png_ptr
operator|->
name|filter_costs
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FIXED_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_WEIGHTED_FILTER */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_level
name|png_set_compression_level
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|zlib_level
operator|=
name|level
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_mem_level
name|png_set_compression_mem_level
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|mem_level
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_mem_level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|zlib_mem_level
operator|=
name|mem_level
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_strategy
name|png_set_compression_strategy
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|strategy
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_strategy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* The flag setting here prevents the libpng dynamic selection of strategy.     */
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_CUSTOM_STRATEGY
expr_stmt|;
name|png_ptr
operator|->
name|zlib_strategy
operator|=
name|strategy
expr_stmt|;
block|}
end_function
begin_comment
comment|/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a  * smaller value of window_bits if it can do so safely.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_window_bits
name|png_set_compression_window_bits
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|window_bits
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Prior to 1.6.0 this would warn but then set the window_bits value. This     * meant that negative window bits values could be selected that would cause     * libpng to write a non-standard PNG file with raw deflate or gzip     * compressed IDAT or ancillary chunks.  Such files can be read and there is     * no warning on read, so this seems like a very bad idea.     */
if|if
condition|(
name|window_bits
operator|>
literal|15
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression windows<= 32k supported by PNG"
argument_list|)
expr_stmt|;
name|window_bits
operator|=
literal|15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|window_bits
operator|<
literal|8
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression windows>= 256 supported by PNG"
argument_list|)
expr_stmt|;
name|window_bits
operator|=
literal|8
expr_stmt|;
block|}
name|png_ptr
operator|->
name|zlib_window_bits
operator|=
name|window_bits
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_compression_method
name|png_set_compression_method
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|method
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_compression_method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* This would produce an invalid PNG file if it worked, but it doesn't and     * deflate will fault it, so it is harmless to just warn here.     */
if|if
condition|(
name|method
operator|!=
literal|8
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression method 8 is supported by PNG"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zlib_method
operator|=
name|method
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_CUSTOMIZE_COMPRESSION */
end_comment
begin_comment
comment|/* The following were added to libpng-1.5.4 */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_text_compression_level
name|png_set_text_compression_level
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_text_compression_level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|zlib_text_level
operator|=
name|level
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_text_compression_mem_level
name|png_set_text_compression_mem_level
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|mem_level
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_text_compression_mem_level"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|zlib_text_mem_level
operator|=
name|mem_level
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_text_compression_strategy
name|png_set_text_compression_strategy
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|strategy
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_text_compression_strategy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|zlib_text_strategy
operator|=
name|strategy
expr_stmt|;
block|}
end_function
begin_comment
comment|/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a  * smaller value of window_bits if it can do so safely.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_text_compression_window_bits
name|png_set_text_compression_window_bits
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|window_bits
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|window_bits
operator|>
literal|15
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression windows<= 32k supported by PNG"
argument_list|)
expr_stmt|;
name|window_bits
operator|=
literal|15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|window_bits
operator|<
literal|8
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression windows>= 256 supported by PNG"
argument_list|)
expr_stmt|;
name|window_bits
operator|=
literal|8
expr_stmt|;
block|}
name|png_ptr
operator|->
name|zlib_text_window_bits
operator|=
name|window_bits
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_text_compression_method
name|png_set_text_compression_method
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|method
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_text_compression_method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|method
operator|!=
literal|8
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Only compression method 8 is supported by PNG"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_method
operator|=
name|method
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
end_comment
begin_comment
comment|/* end of API added to libpng-1.5.4 */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_write_status_fn
name|png_set_write_status_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_write_status_ptr
name|write_row_fn
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|write_row_fn
operator|=
name|write_row_fn
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_write_user_transform_fn
name|png_set_write_user_transform_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_user_transform_ptr
name|write_user_transform_fn
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_write_user_transform_fn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_USER_TRANSFORM
expr_stmt|;
name|png_ptr
operator|->
name|write_user_transform_fn
operator|=
name|write_user_transform_fn
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_write_png
name|png_write_png
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|transforms
parameter_list|,
name|voidp
name|params
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_IDAT
operator|)
operator|==
literal|0
condition|)
block|{
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no rows for png_write_image to write"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write the file header information. */
name|png_write_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* ------ these transformations don't touch the info structure ------- */
comment|/* Invert monochrome pixels */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_MONO
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_INVERT_SUPPORTED
name|png_set_invert_mono
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_INVERT_MONO not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Shift the pixels up to a legal bit depth and fill in     * as appropriate to correctly scale the image.     */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SHIFT
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_SHIFT_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sBIT
operator|)
operator|!=
literal|0
condition|)
name|png_set_shift
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
operator|->
name|sig_bit
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_SHIFT not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pack pixels into bytes */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKING
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_PACK_SUPPORTED
name|png_set_packing
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_PACKING not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Swap location of alpha bytes from ARGB to RGBA */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ALPHA
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_SWAP_ALPHA_SUPPORTED
name|png_set_swap_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_SWAP_ALPHA not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remove a filler (X) from XRGB/RGBX/AG/GA into to convert it into     * RGB, note that the code expects the input color type to be G or RGB; no     * alpha channel.     */
if|if
condition|(
operator|(
name|transforms
operator|&
operator|(
name|PNG_TRANSFORM_STRIP_FILLER_AFTER
operator||
name|PNG_TRANSFORM_STRIP_FILLER_BEFORE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_FILLER_SUPPORTED
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_FILLER_AFTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_FILLER_BEFORE
operator|)
operator|!=
literal|0
condition|)
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_STRIP_FILLER: BEFORE+AFTER not supported"
argument_list|)
expr_stmt|;
comment|/* Continue if ignored - this is the pre-1.6.10 behavior */
name|png_set_filler
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|,
name|PNG_FILLER_AFTER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_STRIP_FILLER_BEFORE
operator|)
operator|!=
literal|0
condition|)
name|png_set_filler
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|,
name|PNG_FILLER_BEFORE
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_STRIP_FILLER not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Flip BGR pixels to RGB */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_BGR
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_BGR_SUPPORTED
name|png_set_bgr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_BGR not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Swap bytes of 16-bit files to most significant byte first */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_SWAP_ENDIAN
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_SWAP_SUPPORTED
name|png_set_swap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_SWAP_ENDIAN not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Swap bits of 1, 2, 4 bit packed pixel formats */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_PACKSWAP_SUPPORTED
name|png_set_packswap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_PACKSWAP not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Invert the alpha channel from opacity to transparency */
if|if
condition|(
operator|(
name|transforms
operator|&
name|PNG_TRANSFORM_INVERT_ALPHA
operator|)
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|PNG_WRITE_INVERT_ALPHA_SUPPORTED
name|png_set_invert_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG_TRANSFORM_INVERT_ALPHA not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ----------------------- end of transformations ------------------- */
comment|/* Write the bits */
name|png_write_image
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
argument_list|)
expr_stmt|;
comment|/* It is REQUIRED to call this to finish writing the rest of the file */
name|png_write_end
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|params
argument_list|)
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
end_ifdef
begin_comment
comment|/* currently required for png_image_write_* */
end_comment
begin_comment
comment|/* Initialize the write structure - general purpose utility. */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_image_write_init
name|png_image_write_init
parameter_list|(
name|png_imagep
name|image
parameter_list|)
block|{
name|png_structp
name|png_ptr
init|=
name|png_create_write_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|image
argument_list|,
name|png_safe_error
argument_list|,
name|png_safe_warning
argument_list|)
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_infop
name|info_ptr
init|=
name|png_create_info_struct
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_controlp
name|control
init|=
name|png_voidcast
argument_list|(
name|png_controlp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|control
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|control
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|control
operator|)
argument_list|)
expr_stmt|;
name|control
operator|->
name|png_ptr
operator|=
name|png_ptr
expr_stmt|;
name|control
operator|->
name|info_ptr
operator|=
name|info_ptr
expr_stmt|;
name|control
operator|->
name|for_write
operator|=
literal|1
expr_stmt|;
name|image
operator|->
name|opaque
operator|=
name|control
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Error clean up */
name|png_destroy_info_struct
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|info_ptr
argument_list|)
expr_stmt|;
block|}
name|png_destroy_write_struct
argument_list|(
operator|&
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_write_: out of memory"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Arguments to png_image_write_main: */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Arguments: */
DECL|member|image
name|png_imagep
name|image
decl_stmt|;
DECL|member|buffer
name|png_const_voidp
name|buffer
decl_stmt|;
DECL|member|row_stride
name|png_int_32
name|row_stride
decl_stmt|;
DECL|member|colormap
name|png_const_voidp
name|colormap
decl_stmt|;
DECL|member|convert_to_8bit
name|int
name|convert_to_8bit
decl_stmt|;
comment|/* Local variables: */
DECL|member|first_row
name|png_const_voidp
name|first_row
decl_stmt|;
DECL|member|row_bytes
name|ptrdiff_t
name|row_bytes
decl_stmt|;
DECL|member|local_row
name|png_voidp
name|local_row
decl_stmt|;
block|}
DECL|typedef|png_image_write_control
name|png_image_write_control
typedef|;
end_typedef
begin_comment
comment|/* Write png_uint_16 input to a 16-bit PNG; the png_ptr has already been set to  * do any necessary byte swapping.  The component order is defined by the  * png_image format value.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_write_image_16bit
name|png_write_image_16bit
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_write_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_write_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|png_const_uint_16p
name|input_row
init|=
name|png_voidcast
argument_list|(
name|png_const_uint_16p
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
name|png_uint_16p
name|output_row
init|=
name|png_voidcast
argument_list|(
name|png_uint_16p
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
decl_stmt|;
name|png_uint_16p
name|row_end
decl_stmt|;
specifier|const
name|int
name|channels
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|?
literal|3
else|:
literal|1
decl_stmt|;
name|int
name|aindex
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|y
init|=
name|image
operator|->
name|height
decl_stmt|;
if|if
condition|(
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
if|if
condition|(
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
condition|)
block|{
name|aindex
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|input_row
expr_stmt|;
comment|/* To point to the first component */
operator|++
name|output_row
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|aindex
operator|=
name|channels
expr_stmt|;
block|}
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_write_image: internal call error"
argument_list|)
expr_stmt|;
comment|/* Work out the output row end and count over this, note that the increment     * above to 'row' means that row_end can actually be beyond the end of the     * row; this is correct.     */
name|row_end
operator|=
name|output_row
operator|+
name|image
operator|->
name|width
operator|*
operator|(
name|channels
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|y
operator|--
operator|>
literal|0
condition|)
block|{
name|png_const_uint_16p
name|in_ptr
init|=
name|input_row
decl_stmt|;
name|png_uint_16p
name|out_ptr
init|=
name|output_row
decl_stmt|;
while|while
condition|(
name|out_ptr
operator|<
name|row_end
condition|)
block|{
specifier|const
name|png_uint_16
name|alpha
init|=
name|in_ptr
index|[
name|aindex
index|]
decl_stmt|;
name|png_uint_32
name|reciprocal
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|out_ptr
index|[
name|aindex
index|]
operator|=
name|alpha
expr_stmt|;
comment|/* Calculate a reciprocal.  The correct calculation is simply           * component/alpha*65535<< 15. (I.e. 15 bits of precision); this           * allows correct rounding by adding .5 before the shift.  'reciprocal'           * is only initialized when required.           */
if|if
condition|(
name|alpha
operator|>
literal|0
operator|&&
name|alpha
operator|<
literal|65535
condition|)
name|reciprocal
operator|=
operator|(
operator|(
literal|0xffff
operator|<<
literal|15
operator|)
operator|+
operator|(
name|alpha
operator|>>
literal|1
operator|)
operator|)
operator|/
name|alpha
expr_stmt|;
name|c
operator|=
name|channels
expr_stmt|;
do|do
comment|/* always at least one channel */
block|{
name|png_uint_16
name|component
init|=
operator|*
name|in_ptr
operator|++
decl_stmt|;
comment|/* The following gives 65535 for an alpha of 0, which is fine,              * otherwise if 0/0 is represented as some other value there is more              * likely to be a discontinuity which will probably damage              * compression when moving from a fully transparent area to a              * nearly transparent one.  (The assumption here is that opaque              * areas tend not to be 0 intensity.)              */
if|if
condition|(
name|component
operator|>=
name|alpha
condition|)
name|component
operator|=
literal|65535
expr_stmt|;
comment|/* component<alpha, so component/alpha is less than one and              * component*reciprocal is less than 2^31.              */
elseif|else
if|if
condition|(
name|component
operator|>
literal|0
operator|&&
name|alpha
operator|<
literal|65535
condition|)
block|{
name|png_uint_32
name|calc
init|=
name|component
operator|*
name|reciprocal
decl_stmt|;
name|calc
operator|+=
literal|16384
expr_stmt|;
comment|/* round to nearest */
name|component
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|calc
operator|>>
literal|15
argument_list|)
expr_stmt|;
block|}
operator|*
name|out_ptr
operator|++
operator|=
name|component
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
operator|>
literal|0
condition|)
do|;
comment|/* Skip to next component (skip the intervening alpha channel) */
operator|++
name|in_ptr
expr_stmt|;
operator|++
name|out_ptr
expr_stmt|;
block|}
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
name|png_voidcast
argument_list|(
name|png_const_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
argument_list|)
expr_stmt|;
name|input_row
operator|+=
name|display
operator|->
name|row_bytes
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* Given 16-bit input (1 to 4 channels) write 8-bit output.  If an alpha channel  * is present it must be removed from the components, the components are then  * written in sRGB encoding.  No components are added or removed.  *  * Calculate an alpha reciprocal to reverse pre-multiplication.  As above the  * calculation can be done to 15 bits of accuracy; however, the output needs to  * be scaled in the range 0..255*65535, so include that scaling here.  */
end_comment
begin_define
DECL|macro|UNP_RECIPROCAL
define|#
directive|define
name|UNP_RECIPROCAL
parameter_list|(
name|alpha
parameter_list|)
value|((((0xffff*0xff)<<7)+(alpha>>1))/alpha)
end_define
begin_function
specifier|static
name|png_byte
DECL|function|png_unpremultiply
name|png_unpremultiply
parameter_list|(
name|png_uint_32
name|component
parameter_list|,
name|png_uint_32
name|alpha
parameter_list|,
name|png_uint_32
name|reciprocal
comment|/*from the above macro*/
parameter_list|)
block|{
comment|/* The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0     * is represented as some other value there is more likely to be a     * discontinuity which will probably damage compression when moving from a     * fully transparent area to a nearly transparent one.  (The assumption here     * is that opaque areas tend not to be 0 intensity.)     *     * There is a rounding problem here; if alpha is less than 128 it will end up     * as 0 when scaled to 8 bits.  To avoid introducing spurious colors into the     * output change for this too.     */
if|if
condition|(
name|component
operator|>=
name|alpha
operator|||
name|alpha
operator|<
literal|128
condition|)
return|return
literal|255
return|;
comment|/* component<alpha, so component/alpha is less than one and     * component*reciprocal is less than 2^31.     */
elseif|else
if|if
condition|(
name|component
operator|>
literal|0
condition|)
block|{
comment|/* The test is that alpha/257 (rounded) is less than 255, the first value        * that becomes 255 is 65407.        * NOTE: this must agree with the PNG_DIV257 macro (which must, therefore,        * be exact!)  [Could also test reciprocal != 0]        */
if|if
condition|(
name|alpha
operator|<
literal|65407
condition|)
block|{
name|component
operator|*=
name|reciprocal
expr_stmt|;
name|component
operator|+=
literal|64
expr_stmt|;
comment|/* round to nearest */
name|component
operator|>>=
literal|7
expr_stmt|;
block|}
else|else
name|component
operator|*=
literal|255
expr_stmt|;
comment|/* Convert the component to sRGB. */
return|return
operator|(
name|png_byte
operator|)
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|component
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_write_image_8bit
name|png_write_image_8bit
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_write_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_write_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|png_const_uint_16p
name|input_row
init|=
name|png_voidcast
argument_list|(
name|png_const_uint_16p
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
name|png_bytep
name|output_row
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
decl_stmt|;
name|png_uint_32
name|y
init|=
name|image
operator|->
name|height
decl_stmt|;
specifier|const
name|int
name|channels
init|=
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|?
literal|3
else|:
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_bytep
name|row_end
decl_stmt|;
name|int
name|aindex
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
if|if
condition|(
operator|(
name|image
operator|->
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
condition|)
block|{
name|aindex
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|input_row
expr_stmt|;
comment|/* To point to the first component */
operator|++
name|output_row
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|aindex
operator|=
name|channels
expr_stmt|;
comment|/* Use row_end in place of a loop counter: */
name|row_end
operator|=
name|output_row
operator|+
name|image
operator|->
name|width
operator|*
operator|(
name|channels
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|y
operator|--
operator|>
literal|0
condition|)
block|{
name|png_const_uint_16p
name|in_ptr
init|=
name|input_row
decl_stmt|;
name|png_bytep
name|out_ptr
init|=
name|output_row
decl_stmt|;
while|while
condition|(
name|out_ptr
operator|<
name|row_end
condition|)
block|{
name|png_uint_16
name|alpha
init|=
name|in_ptr
index|[
name|aindex
index|]
decl_stmt|;
name|png_byte
name|alphabyte
init|=
operator|(
name|png_byte
operator|)
name|PNG_DIV257
argument_list|(
name|alpha
argument_list|)
decl_stmt|;
name|png_uint_32
name|reciprocal
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Scale and write the alpha channel. */
name|out_ptr
index|[
name|aindex
index|]
operator|=
name|alphabyte
expr_stmt|;
if|if
condition|(
name|alphabyte
operator|>
literal|0
operator|&&
name|alphabyte
operator|<
literal|255
condition|)
name|reciprocal
operator|=
name|UNP_RECIPROCAL
argument_list|(
name|alpha
argument_list|)
expr_stmt|;
name|c
operator|=
name|channels
expr_stmt|;
do|do
comment|/* always at least one channel */
operator|*
name|out_ptr
operator|++
operator|=
name|png_unpremultiply
argument_list|(
operator|*
name|in_ptr
operator|++
argument_list|,
name|alpha
argument_list|,
name|reciprocal
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|c
operator|>
literal|0
condition|)
do|;
comment|/* Skip to next component (skip the intervening alpha channel) */
operator|++
name|in_ptr
expr_stmt|;
operator|++
name|out_ptr
expr_stmt|;
block|}
comment|/* while out_ptr< row_end */
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
name|png_voidcast
argument_list|(
name|png_const_bytep
argument_list|,
name|display
operator|->
name|local_row
argument_list|)
argument_list|)
expr_stmt|;
name|input_row
operator|+=
name|display
operator|->
name|row_bytes
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* while y */
block|}
else|else
block|{
comment|/* No alpha channel, so the row_end really is the end of the row and it        * is sufficient to loop over the components one by one.        */
name|png_bytep
name|row_end
init|=
name|output_row
operator|+
name|image
operator|->
name|width
operator|*
name|channels
decl_stmt|;
while|while
condition|(
name|y
operator|--
operator|>
literal|0
condition|)
block|{
name|png_const_uint_16p
name|in_ptr
init|=
name|input_row
decl_stmt|;
name|png_bytep
name|out_ptr
init|=
name|output_row
decl_stmt|;
while|while
condition|(
name|out_ptr
operator|<
name|row_end
condition|)
block|{
name|png_uint_32
name|component
init|=
operator|*
name|in_ptr
operator|++
decl_stmt|;
name|component
operator|*=
literal|255
expr_stmt|;
operator|*
name|out_ptr
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|PNG_sRGB_FROM_LINEAR
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
name|output_row
argument_list|)
expr_stmt|;
name|input_row
operator|+=
name|display
operator|->
name|row_bytes
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|png_image_set_PLTE
name|png_image_set_PLTE
parameter_list|(
name|png_image_write_control
modifier|*
name|display
parameter_list|)
block|{
specifier|const
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
specifier|const
name|void
modifier|*
name|cmap
init|=
name|display
operator|->
name|colormap
decl_stmt|;
specifier|const
name|int
name|entries
init|=
name|image
operator|->
name|colormap_entries
operator|>
literal|256
condition|?
literal|256
else|:
operator|(
name|int
operator|)
name|image
operator|->
name|colormap_entries
decl_stmt|;
comment|/* NOTE: the caller must check for cmap != NULL and entries != 0 */
specifier|const
name|png_uint_32
name|format
init|=
name|image
operator|->
name|format
decl_stmt|;
specifier|const
name|int
name|channels
init|=
name|PNG_IMAGE_SAMPLE_CHANNELS
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_FORMAT_BGR_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
argument_list|)
specifier|const
name|int
name|afirst
init|=
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|afirst
value|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_FORMAT_BGR_SUPPORTED
specifier|const
name|int
name|bgr
init|=
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_BGR
operator|)
operator|!=
literal|0
condition|?
literal|2
else|:
literal|0
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|bgr
value|0
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|num_trans
decl_stmt|;
name|png_color
name|palette
index|[
literal|256
index|]
decl_stmt|;
name|png_byte
name|tRNS
index|[
literal|256
index|]
decl_stmt|;
name|memset
argument_list|(
name|tRNS
argument_list|,
literal|255
argument_list|,
operator|(
sizeof|sizeof
name|tRNS
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|palette
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
name|palette
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_trans
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
operator|++
name|i
control|)
block|{
comment|/* This gets automatically converted to sRGB with reversal of the        * pre-multiplication if the color-map has an alpha channel.        */
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_const_uint_16p
name|entry
init|=
name|png_voidcast
argument_list|(
name|png_const_uint_16p
argument_list|,
name|cmap
argument_list|)
decl_stmt|;
name|entry
operator|+=
name|i
operator|*
name|channels
expr_stmt|;
if|if
condition|(
operator|(
name|channels
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
comment|/* no alpha */
block|{
if|if
condition|(
name|channels
operator|>=
literal|3
condition|)
comment|/* RGB */
block|{
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|PNG_sRGB_FROM_LINEAR
argument_list|(
literal|255
operator|*
name|entry
index|[
operator|(
literal|2
operator|^
name|bgr
operator|)
index|]
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
operator|(
name|png_byte
operator|)
name|PNG_sRGB_FROM_LINEAR
argument_list|(
literal|255
operator|*
name|entry
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
operator|(
name|png_byte
operator|)
name|PNG_sRGB_FROM_LINEAR
argument_list|(
literal|255
operator|*
name|entry
index|[
name|bgr
index|]
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Gray */
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
operator|(
name|png_byte
operator|)
name|PNG_sRGB_FROM_LINEAR
argument_list|(
literal|255
operator|*
operator|*
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* alpha */
block|{
name|png_uint_16
name|alpha
init|=
name|entry
index|[
name|afirst
condition|?
literal|0
else|:
name|channels
operator|-
literal|1
index|]
decl_stmt|;
name|png_byte
name|alphabyte
init|=
operator|(
name|png_byte
operator|)
name|PNG_DIV257
argument_list|(
name|alpha
argument_list|)
decl_stmt|;
name|png_uint_32
name|reciprocal
init|=
literal|0
decl_stmt|;
comment|/* Calculate a reciprocal, as in the png_write_image_8bit code above              * this is designed to produce a value scaled to 255*65535 when              * divided by 128 (i.e. asr 7).              */
if|if
condition|(
name|alphabyte
operator|>
literal|0
operator|&&
name|alphabyte
operator|<
literal|255
condition|)
name|reciprocal
operator|=
operator|(
operator|(
operator|(
literal|0xffff
operator|*
literal|0xff
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
name|alpha
operator|>>
literal|1
operator|)
operator|)
operator|/
name|alpha
expr_stmt|;
name|tRNS
index|[
name|i
index|]
operator|=
name|alphabyte
expr_stmt|;
if|if
condition|(
name|alphabyte
operator|<
literal|255
condition|)
name|num_trans
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|channels
operator|>=
literal|3
condition|)
comment|/* RGB */
block|{
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|png_unpremultiply
argument_list|(
name|entry
index|[
name|afirst
operator|+
operator|(
literal|2
operator|^
name|bgr
operator|)
index|]
argument_list|,
name|alpha
argument_list|,
name|reciprocal
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|png_unpremultiply
argument_list|(
name|entry
index|[
name|afirst
operator|+
literal|1
index|]
argument_list|,
name|alpha
argument_list|,
name|reciprocal
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|png_unpremultiply
argument_list|(
name|entry
index|[
name|afirst
operator|+
name|bgr
index|]
argument_list|,
name|alpha
argument_list|,
name|reciprocal
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* gray */
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|png_unpremultiply
argument_list|(
name|entry
index|[
name|afirst
index|]
argument_list|,
name|alpha
argument_list|,
name|reciprocal
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Color-map has sRGB values */
block|{
name|png_const_bytep
name|entry
init|=
name|png_voidcast
argument_list|(
name|png_const_bytep
argument_list|,
name|cmap
argument_list|)
decl_stmt|;
name|entry
operator|+=
name|i
operator|*
name|channels
expr_stmt|;
switch|switch
condition|(
name|channels
condition|)
block|{
case|case
literal|4
case|:
name|tRNS
index|[
name|i
index|]
operator|=
name|entry
index|[
name|afirst
condition|?
literal|0
else|:
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|tRNS
index|[
name|i
index|]
operator|<
literal|255
condition|)
name|num_trans
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|3
case|:
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|entry
index|[
name|afirst
operator|+
operator|(
literal|2
operator|^
name|bgr
operator|)
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|entry
index|[
name|afirst
operator|+
literal|1
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|entry
index|[
name|afirst
operator|+
name|bgr
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tRNS
index|[
name|i
index|]
operator|=
name|entry
index|[
literal|1
operator|^
name|afirst
index|]
expr_stmt|;
if|if
condition|(
name|tRNS
index|[
name|i
index|]
operator|<
literal|255
condition|)
name|num_trans
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|1
case|:
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|entry
index|[
name|afirst
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|afirst
DECL|macro|afirst
undef|#
directive|undef
name|afirst
endif|#
directive|endif
ifdef|#
directive|ifdef
name|bgr
DECL|macro|bgr
undef|#
directive|undef
name|bgr
endif|#
directive|endif
name|png_set_PLTE
argument_list|(
name|image
operator|->
name|opaque
operator|->
name|png_ptr
argument_list|,
name|image
operator|->
name|opaque
operator|->
name|info_ptr
argument_list|,
name|palette
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_trans
operator|>
literal|0
condition|)
name|png_set_tRNS
argument_list|(
name|image
operator|->
name|opaque
operator|->
name|png_ptr
argument_list|,
name|image
operator|->
name|opaque
operator|->
name|info_ptr
argument_list|,
name|tRNS
argument_list|,
name|num_trans
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image
operator|->
name|colormap_entries
operator|=
name|entries
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_image_write_main
name|png_image_write_main
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_image_write_control
modifier|*
name|display
init|=
name|png_voidcast
argument_list|(
name|png_image_write_control
operator|*
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_imagep
name|image
init|=
name|display
operator|->
name|image
decl_stmt|;
name|png_structrp
name|png_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|png_ptr
decl_stmt|;
name|png_inforp
name|info_ptr
init|=
name|image
operator|->
name|opaque
operator|->
name|info_ptr
decl_stmt|;
name|png_uint_32
name|format
init|=
name|image
operator|->
name|format
decl_stmt|;
comment|/* The following four ints are actually booleans */
name|int
name|colormap
init|=
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_COLORMAP
operator|)
decl_stmt|;
name|int
name|linear
init|=
operator|!
name|colormap
operator|&&
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_LINEAR
operator|)
decl_stmt|;
comment|/* input */
name|int
name|alpha
init|=
operator|!
name|colormap
operator|&&
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
decl_stmt|;
name|int
name|write_16bit
init|=
name|linear
operator|&&
operator|!
name|colormap
operator|&&
operator|(
name|display
operator|->
name|convert_to_8bit
operator|==
literal|0
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
comment|/* Make sure we error out on any bad situation */
name|png_set_benign_errors
argument_list|(
name|png_ptr
argument_list|,
literal|0
comment|/*error*/
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Default the 'row_stride' parameter if required. */
if|if
condition|(
name|display
operator|->
name|row_stride
operator|==
literal|0
condition|)
name|display
operator|->
name|row_stride
operator|=
name|PNG_IMAGE_ROW_STRIDE
argument_list|(
operator|*
name|image
argument_list|)
expr_stmt|;
comment|/* Set the required transforms then write the rows in the correct order. */
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_COLORMAP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|display
operator|->
name|colormap
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|colormap_entries
operator|>
literal|0
condition|)
block|{
name|png_uint_32
name|entries
init|=
name|image
operator|->
name|colormap_entries
decl_stmt|;
name|png_set_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|image
operator|->
name|width
argument_list|,
name|image
operator|->
name|height
argument_list|,
name|entries
operator|>
literal|16
condition|?
literal|8
else|:
operator|(
name|entries
operator|>
literal|4
condition|?
literal|4
else|:
operator|(
name|entries
operator|>
literal|2
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
argument_list|,
name|PNG_COLOR_TYPE_PALETTE
argument_list|,
name|PNG_INTERLACE_NONE
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|)
expr_stmt|;
name|png_image_set_PLTE
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
else|else
name|png_error
argument_list|(
name|image
operator|->
name|opaque
operator|->
name|png_ptr
argument_list|,
literal|"no color-map for color-mapped image"
argument_list|)
expr_stmt|;
block|}
else|else
name|png_set_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|image
operator|->
name|width
argument_list|,
name|image
operator|->
name|height
argument_list|,
name|write_16bit
condition|?
literal|16
else|:
literal|8
argument_list|,
operator|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
condition|?
name|PNG_COLOR_MASK_COLOR
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
condition|?
name|PNG_COLOR_MASK_ALPHA
else|:
literal|0
operator|)
argument_list|,
name|PNG_INTERLACE_NONE
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|)
expr_stmt|;
comment|/* Counter-intuitively the data transformations must be called *after*     * png_write_info, not before as in the read code, but the 'set' functions     * must still be called before.  Just set the color space information, never     * write an interlaced image.     */
if|if
condition|(
name|write_16bit
operator|!=
literal|0
condition|)
block|{
comment|/* The gamma here is 1.0 (linear) and the cHRM chunk matches sRGB. */
name|png_set_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_GAMMA_LINEAR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|image
operator|->
name|flags
operator|&
name|PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB
operator|)
operator|==
literal|0
condition|)
name|png_set_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
comment|/* color      x       y */
comment|/* white */
literal|31270
argument_list|,
literal|32900
argument_list|,
comment|/* red   */
literal|64000
argument_list|,
literal|33000
argument_list|,
comment|/* green */
literal|30000
argument_list|,
literal|60000
argument_list|,
comment|/* blue  */
literal|15000
argument_list|,
literal|6000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|image
operator|->
name|flags
operator|&
name|PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB
operator|)
operator|==
literal|0
condition|)
name|png_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_sRGB_INTENT_PERCEPTUAL
argument_list|)
expr_stmt|;
comment|/* Else writing an 8-bit file and the *colors* aren't sRGB, but the 8-bit     * space must still be gamma encoded.     */
else|else
name|png_set_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_GAMMA_sRGB_INVERSE
argument_list|)
expr_stmt|;
comment|/* Write the file header. */
name|png_write_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Now set up the data transformations (*after* the header is written),     * remove the handled transformations from the 'format' flags for checking.     *     * First check for a little endian system if writing 16 bit files.     */
if|if
condition|(
name|write_16bit
operator|!=
literal|0
condition|)
block|{
name|PNG_CONST
name|png_uint_16
name|le
init|=
literal|0x0001
decl_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|png_const_bytep
operator|)
operator|&
name|le
operator|)
operator|!=
literal|0
condition|)
name|png_set_swap
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_WRITE_BGR_SUPPORTED
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_BGR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|colormap
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_COLOR
operator|)
operator|!=
literal|0
condition|)
name|png_set_bgr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|PNG_FORMAT_FLAG_BGR
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
if|if
condition|(
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_AFIRST
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|colormap
operator|==
literal|0
operator|&&
operator|(
name|format
operator|&
name|PNG_FORMAT_FLAG_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|png_set_swap_alpha
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|PNG_FORMAT_FLAG_AFIRST
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If there are 16 or fewer color-map entries we wrote a lower bit depth     * above, but the application data is still byte packed.     */
if|if
condition|(
name|colormap
operator|!=
literal|0
operator|&&
name|image
operator|->
name|colormap_entries
operator|<=
literal|16
condition|)
name|png_set_packing
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* That should have handled all (both) the transforms. */
if|if
condition|(
operator|(
name|format
operator|&
operator|~
call|(
name|png_uint_32
call|)
argument_list|(
name|PNG_FORMAT_FLAG_COLOR
operator||
name|PNG_FORMAT_FLAG_LINEAR
operator||
name|PNG_FORMAT_FLAG_ALPHA
operator||
name|PNG_FORMAT_FLAG_COLORMAP
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_write_image: unsupported transformation"
argument_list|)
expr_stmt|;
block|{
name|png_const_bytep
name|row
init|=
name|png_voidcast
argument_list|(
name|png_const_bytep
argument_list|,
name|display
operator|->
name|buffer
argument_list|)
decl_stmt|;
name|ptrdiff_t
name|row_bytes
init|=
name|display
operator|->
name|row_stride
decl_stmt|;
if|if
condition|(
name|linear
operator|!=
literal|0
condition|)
name|row_bytes
operator|*=
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|row_bytes
operator|<
literal|0
condition|)
name|row
operator|+=
operator|(
name|image
operator|->
name|height
operator|-
literal|1
operator|)
operator|*
operator|(
operator|-
name|row_bytes
operator|)
expr_stmt|;
name|display
operator|->
name|first_row
operator|=
name|row
expr_stmt|;
name|display
operator|->
name|row_bytes
operator|=
name|row_bytes
expr_stmt|;
block|}
comment|/* Apply 'fast' options if the flag is set. */
if|if
condition|(
operator|(
name|image
operator|->
name|flags
operator|&
name|PNG_IMAGE_FLAG_FAST
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_set_filter
argument_list|(
name|png_ptr
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|,
name|PNG_NO_FILTERS
argument_list|)
expr_stmt|;
comment|/* NOTE: determined by experiment using pngstest, this reflects some        * balance between the time to write the image once and the time to read        * it about 50 times.  The speed-up in pngstest was about 10-20% of the        * total (user) time on a heavily loaded system.        */
ifdef|#
directive|ifdef
name|PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
name|png_set_compression_level
argument_list|(
name|png_ptr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Check for the cases that currently require a pre-transform on the row     * before it is written.  This only applies when the input is 16-bit and     * either there is an alpha channel or it is converted to 8-bit.     */
if|if
condition|(
operator|(
name|linear
operator|!=
literal|0
operator|&&
name|alpha
operator|!=
literal|0
operator|)
operator|||
operator|(
name|colormap
operator|==
literal|0
operator|&&
name|display
operator|->
name|convert_to_8bit
operator|!=
literal|0
operator|)
condition|)
block|{
name|png_bytep
name|row
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_get_rowbytes
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|display
operator|->
name|local_row
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|write_16bit
operator|!=
literal|0
condition|)
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_write_image_16bit
argument_list|,
name|display
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_write_image_8bit
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|display
operator|->
name|local_row
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|)
expr_stmt|;
comment|/* Skip the 'write_end' on error: */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Otherwise this is the case where the input is in a format currently     * supported by the rest of the libpng write code; call it directly.     */
else|else
block|{
name|png_const_bytep
name|row
init|=
name|png_voidcast
argument_list|(
name|png_const_bytep
argument_list|,
name|display
operator|->
name|first_row
argument_list|)
decl_stmt|;
name|ptrdiff_t
name|row_bytes
init|=
name|display
operator|->
name|row_bytes
decl_stmt|;
name|png_uint_32
name|y
init|=
name|image
operator|->
name|height
decl_stmt|;
while|while
condition|(
name|y
operator|--
operator|>
literal|0
condition|)
block|{
name|png_write_row
argument_list|(
name|png_ptr
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|row
operator|+=
name|row_bytes
expr_stmt|;
block|}
block|}
name|png_write_end
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
name|int
name|PNGAPI
DECL|function|png_image_write_to_stdio
name|png_image_write_to_stdio
parameter_list|(
name|png_imagep
name|image
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|convert_to_8bit
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|png_int_32
name|row_stride
parameter_list|,
specifier|const
name|void
modifier|*
name|colormap
parameter_list|)
block|{
comment|/* Write the image to the given (FILE*). */
if|if
condition|(
name|image
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|version
operator|==
name|PNG_IMAGE_VERSION
condition|)
block|{
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|png_image_write_init
argument_list|(
name|image
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|png_image_write_control
name|display
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* This is slightly evil, but png_init_io doesn't do anything other              * than this and we haven't changed the standard IO functions so              * this saves a 'safe' function.              */
name|image
operator|->
name|opaque
operator|->
name|png_ptr
operator|->
name|io_ptr
operator|=
name|file
expr_stmt|;
name|memset
argument_list|(
operator|&
name|display
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
name|display
operator|)
argument_list|)
expr_stmt|;
name|display
operator|.
name|image
operator|=
name|image
expr_stmt|;
name|display
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|display
operator|.
name|row_stride
operator|=
name|row_stride
expr_stmt|;
name|display
operator|.
name|colormap
operator|=
name|colormap
expr_stmt|;
name|display
operator|.
name|convert_to_8bit
operator|=
name|convert_to_8bit
expr_stmt|;
name|result
operator|=
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_write_main
argument_list|,
operator|&
name|display
argument_list|)
expr_stmt|;
name|png_image_free
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_write_to_stdio: invalid argument"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_write_to_stdio: incorrect PNG_IMAGE_VERSION"
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
name|int
name|PNGAPI
DECL|function|png_image_write_to_file
name|png_image_write_to_file
parameter_list|(
name|png_imagep
name|image
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|int
name|convert_to_8bit
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|png_int_32
name|row_stride
parameter_list|,
specifier|const
name|void
modifier|*
name|colormap
parameter_list|)
block|{
comment|/* Write the image to the named file. */
if|if
condition|(
name|image
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|version
operator|==
name|PNG_IMAGE_VERSION
condition|)
block|{
if|if
condition|(
name|file_name
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|file_name
argument_list|,
literal|"wb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|png_image_write_to_stdio
argument_list|(
name|image
argument_list|,
name|fp
argument_list|,
name|convert_to_8bit
argument_list|,
name|buffer
argument_list|,
name|row_stride
argument_list|,
name|colormap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* from fflush/fclose */
comment|/* Make sure the file is flushed correctly. */
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
operator|&&
name|ferror
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|error
operator|=
name|errno
expr_stmt|;
comment|/* from fclose */
block|}
else|else
block|{
name|error
operator|=
name|errno
expr_stmt|;
comment|/* from fflush or ferror */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|remove
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
comment|/* The image has already been cleaned up; this is just used to                 * set the error (because the original write succeeded).                 */
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Clean up: just the opened file. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_write_to_file: invalid argument"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
return|return
name|png_image_error
argument_list|(
name|image
argument_list|,
literal|"png_image_write_to_file: incorrect PNG_IMAGE_VERSION"
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* STDIO */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SIMPLIFIED_WRITE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE */
end_comment
end_unit
