begin_unit
begin_comment
comment|/* pngtest.c - a simple test program to test libpng  *  * Last changed in libpng 1.5.0 [January 6, 2011]  * Copyright (c) 1998-2011 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * This program reads in a PNG image, writes it out again, and then  * compares the two files.  If the files are identical, this shows that  * the basic chunk handling, filtering, and (de)compression code is working  * properly.  It does not currently test all of the transforms, although  * it probably should.  *  * The program will report "FAIL" in certain legitimate cases:  * 1) when the compression level or filter selection method is changed.  * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.  * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks  *    exist in the input file.  * 4) others not listed here...  * In these cases, it is best to check with another tool such as "pngcheck"  * to see what the differences between the two files are.  *  * If a filename is given on the command-line, then this file is used  * for the input, rather than the default "pngtest.png".  This allows  * testing a wide variety of files easily.  You can also test a number  * of files at once by typing "pngtest -m file1.png file2.png ..."  */
end_comment
begin_include
include|#
directive|include
file|"zlib.h"
end_include
begin_include
include|#
directive|include
file|"png.h"
end_include
begin_comment
comment|/* Copied from pngpriv.h but only used in error messages below. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_ZBUF_SIZE
end_ifndef
begin_define
DECL|macro|PNG_ZBUF_SIZE
define|#
directive|define
name|PNG_ZBUF_SIZE
value|8192
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_define
DECL|macro|FCLOSE
define|#
directive|define
name|FCLOSE
parameter_list|(
name|file
parameter_list|)
value|fclose(file)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_STDIO_SUPPORTED
end_ifndef
begin_typedef
DECL|typedef|png_FILE_p
typedef|typedef
name|FILE
modifier|*
name|png_FILE_p
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Makes pngtest verbose so we can find problems. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_DEBUG
end_ifndef
begin_define
DECL|macro|PNG_DEBUG
define|#
directive|define
name|PNG_DEBUG
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|PNG_DEBUG
operator|>
literal|1
end_if
begin_define
DECL|macro|pngtest_debug
define|#
directive|define
name|pngtest_debug
parameter_list|(
name|m
parameter_list|)
value|((void)fprintf(stderr, m "\n"))
end_define
begin_define
DECL|macro|pngtest_debug1
define|#
directive|define
name|pngtest_debug1
parameter_list|(
name|m
parameter_list|,
name|p1
parameter_list|)
value|((void)fprintf(stderr, m "\n", p1))
end_define
begin_define
DECL|macro|pngtest_debug2
define|#
directive|define
name|pngtest_debug2
parameter_list|(
name|m
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|)
value|((void)fprintf(stderr, m "\n", p1, p2))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|pngtest_debug
define|#
directive|define
name|pngtest_debug
parameter_list|(
name|m
parameter_list|)
value|((void)0)
end_define
begin_define
DECL|macro|pngtest_debug1
define|#
directive|define
name|pngtest_debug1
parameter_list|(
name|m
parameter_list|,
name|p1
parameter_list|)
value|((void)0)
end_define
begin_define
DECL|macro|pngtest_debug2
define|#
directive|define
name|pngtest_debug2
parameter_list|(
name|m
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|)
value|((void)0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|PNG_DEBUG
end_if
begin_define
DECL|macro|SINGLE_ROWBUF_ALLOC
define|#
directive|define
name|SINGLE_ROWBUF_ALLOC
end_define
begin_comment
DECL|macro|SINGLE_ROWBUF_ALLOC
comment|/* Makes buffer overruns easier to nail */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The code uses memcmp and memcpy on large objects (typically row pointers) so  * it is necessary to do soemthing special on certain architectures, note that  * the actual support for this was effectively removed in 1.4, so only the  * memory remains in this program:  */
end_comment
begin_define
DECL|macro|CVT_PTR
define|#
directive|define
name|CVT_PTR
parameter_list|(
name|ptr
parameter_list|)
value|(ptr)
end_define
begin_define
DECL|macro|CVT_PTR_NOCHECK
define|#
directive|define
name|CVT_PTR_NOCHECK
parameter_list|(
name|ptr
parameter_list|)
value|(ptr)
end_define
begin_define
DECL|macro|png_memcmp
define|#
directive|define
name|png_memcmp
value|memcmp
end_define
begin_define
DECL|macro|png_memcpy
define|#
directive|define
name|png_memcpy
value|memcpy
end_define
begin_define
DECL|macro|png_memset
define|#
directive|define
name|png_memset
value|memset
end_define
begin_comment
comment|/* Turn on CPU timing #define PNGTEST_TIMING */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifndef
begin_undef
DECL|macro|PNGTEST_TIMING
undef|#
directive|undef
name|PNGTEST_TIMING
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNGTEST_TIMING
end_ifdef
begin_decl_stmt
DECL|variable|t_start
DECL|variable|t_stop
DECL|variable|t_decode
DECL|variable|t_encode
DECL|variable|t_misc
specifier|static
name|float
name|t_start
decl_stmt|,
name|t_stop
decl_stmt|,
name|t_decode
decl_stmt|,
name|t_encode
decl_stmt|,
name|t_misc
decl_stmt|;
end_decl_stmt
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
end_ifdef
begin_define
DECL|macro|PNG_tIME_STRING_LENGTH
define|#
directive|define
name|PNG_tIME_STRING_LENGTH
value|29
end_define
begin_decl_stmt
DECL|variable|tIME_chunk_present
specifier|static
name|int
name|tIME_chunk_present
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tIME_string
specifier|static
name|char
name|tIME_string
index|[
name|PNG_tIME_STRING_LENGTH
index|]
init|=
literal|"tIME chunk is not present"
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|verbose
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|test_one_file
name|PNGARG
argument_list|(
operator|(
name|PNG_CONST
name|char
operator|*
name|inname
operator|,
name|PNG_CONST
name|char
operator|*
name|outname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|__TURBOC__
end_ifdef
begin_include
include|#
directive|include
file|<mem.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Defined so I can write to a file on gui/windowing platforms */
end_comment
begin_comment
comment|/*  #define STDERR stderr  */
end_comment
begin_define
DECL|macro|STDERR
define|#
directive|define
name|STDERR
value|stdout
end_define
begin_comment
DECL|macro|STDERR
comment|/* For DOS */
end_comment
begin_comment
comment|/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|png_jmpbuf
end_ifndef
begin_define
DECL|macro|png_jmpbuf
define|#
directive|define
name|png_jmpbuf
parameter_list|(
name|png_ptr
parameter_list|)
value|png_ptr->jmpbuf
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Example of using row callbacks to make a simple progress meter */
end_comment
begin_decl_stmt
DECL|variable|status_pass
specifier|static
name|int
name|status_pass
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|status_dots_requested
specifier|static
name|int
name|status_dots_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|status_dots
specifier|static
name|int
name|status_dots
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|PNGCBAPI
name|read_row_callback
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|row_number
parameter_list|,
name|int
name|pass
parameter_list|)
function_decl|;
end_function_decl
begin_function
name|void
name|PNGCBAPI
DECL|function|read_row_callback
name|read_row_callback
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|row_number
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|row_number
operator|>
name|PNG_UINT_31_MAX
condition|)
return|return;
if|if
condition|(
name|status_pass
operator|!=
name|pass
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n Pass %d: "
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|status_pass
operator|=
name|pass
expr_stmt|;
name|status_dots
operator|=
literal|31
expr_stmt|;
block|}
name|status_dots
operator|--
expr_stmt|;
if|if
condition|(
name|status_dots
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n         "
argument_list|)
expr_stmt|;
name|status_dots
operator|=
literal|30
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
name|void
name|PNGCBAPI
name|write_row_callback
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|row_number
parameter_list|,
name|int
name|pass
parameter_list|)
function_decl|;
end_function_decl
begin_function
name|void
name|PNGCBAPI
DECL|function|write_row_callback
name|write_row_callback
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|row_number
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|row_number
operator|>
name|PNG_UINT_31_MAX
operator|||
name|pass
operator|>
literal|7
condition|)
return|return;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
end_ifdef
begin_comment
comment|/* Example of using user transform callback (we don't transform anything,  * but merely examine the row filters.  We set this to 256 rather than  * 5 in case illegal filter values are present.)  */
end_comment
begin_decl_stmt
DECL|variable|filters_used
specifier|static
name|png_uint_32
name|filters_used
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|PNGCBAPI
name|count_filters
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|data
parameter_list|)
function_decl|;
end_function_decl
begin_function
name|void
name|PNGCBAPI
DECL|function|count_filters
name|count_filters
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|data
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|row_info
operator|!=
name|NULL
condition|)
operator|++
name|filters_used
index|[
operator|*
operator|(
name|data
operator|-
literal|1
operator|)
index|]
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
end_ifdef
begin_comment
comment|/* Example of using user transform callback (we don't transform anything,  * but merely count the zero samples)  */
end_comment
begin_decl_stmt
DECL|variable|zero_samples
specifier|static
name|png_uint_32
name|zero_samples
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|PNGCBAPI
name|count_zero_samples
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|data
parameter_list|)
function_decl|;
end_function_decl
begin_function
name|void
name|PNGCBAPI
DECL|function|count_zero_samples
name|count_zero_samples
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|data
parameter_list|)
block|{
name|png_bytep
name|dp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Contents of row_info:     *  png_uint_32 width      width of row     *  png_uint_32 rowbytes   number of bytes in row     *  png_byte color_type    color type of pixels     *  png_byte bit_depth     bit depth of samples     *  png_byte channels      number of channels (1-4)     *  png_byte pixel_depth   bits per pixel (depth*channels)     */
comment|/* Counts the number of zero samples (or zero pixels if color_type is 3 */
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
literal|0
operator|||
name|row_info
operator|->
name|color_type
operator|==
literal|3
condition|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|n
decl_stmt|,
name|nstop
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|nstop
operator|=
name|row_info
operator|->
name|width
init|;
name|n
operator|<
name|nstop
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|dp
operator|<<
name|pos
operator|++
operator|)
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|zero_samples
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|8
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|dp
operator|<<
operator|(
name|pos
operator|+=
literal|2
operator|)
operator|)
operator|&
literal|0xc0
operator|)
operator|==
literal|0
condition|)
name|zero_samples
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|8
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|dp
operator|<<
operator|(
name|pos
operator|+=
literal|4
operator|)
operator|)
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
name|zero_samples
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|8
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
if|if
condition|(
operator|*
name|dp
operator|++
operator|==
literal|0
condition|)
name|zero_samples
operator|++
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator||
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|zero_samples
operator|++
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Other color types */
block|{
name|png_uint_32
name|n
decl_stmt|,
name|nstop
decl_stmt|;
name|int
name|channel
decl_stmt|;
name|int
name|color_channels
init|=
name|row_info
operator|->
name|channels
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|>
literal|3
condition|)
name|color_channels
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|nstop
operator|=
name|row_info
operator|->
name|width
init|;
name|n
operator|<
name|nstop
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|color_channels
condition|;
name|channel
operator|++
control|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
if|if
condition|(
operator|*
name|dp
operator|++
operator|==
literal|0
condition|)
name|zero_samples
operator|++
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator||
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|zero_samples
operator|++
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|>
literal|3
condition|)
block|{
name|dp
operator|++
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
name|dp
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_WRITE_USER_TRANSFORM_SUPPORTED */
end_comment
begin_decl_stmt
DECL|variable|wrote_question
specifier|static
name|int
name|wrote_question
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_STDIO_SUPPORTED
end_ifndef
begin_comment
comment|/* START of code to validate stdio-free compilation */
end_comment
begin_comment
comment|/* These copies of the default read/write functions come from pngrio.c and  * pngwio.c.  They allow "don't include stdio" testing of the library.  * This is the function that does the actual reading of data.  If you are  * not reading from a standard C stream, you should create a replacement  * read_data function and use it at run time with png_set_read_fn(), rather  * than changing the library.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
end_ifdef
begin_function_decl
name|void
name|pngtest_check_io_state
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_size_t
name|data_length
parameter_list|,
name|png_uint_32
name|io_op
parameter_list|)
function_decl|;
end_function_decl
begin_function
name|void
DECL|function|pngtest_check_io_state
name|pngtest_check_io_state
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_size_t
name|data_length
parameter_list|,
name|png_uint_32
name|io_op
parameter_list|)
block|{
name|png_uint_32
name|io_state
init|=
name|png_get_io_state
argument_list|(
name|png_ptr
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check if the current operation (reading / writing) is as expected. */
if|if
condition|(
operator|(
name|io_state
operator|&
name|PNG_IO_MASK_OP
operator|)
operator|!=
name|io_op
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect operation in I/O state"
argument_list|)
expr_stmt|;
comment|/* Check if the buffer size specific to the current location     * (file signature / header / data / crc) is as expected.     */
switch|switch
condition|(
name|io_state
operator|&
name|PNG_IO_MASK_LOC
condition|)
block|{
case|case
name|PNG_IO_SIGNATURE
case|:
if|if
condition|(
name|data_length
operator|>
literal|8
condition|)
name|err
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PNG_IO_CHUNK_HDR
case|:
if|if
condition|(
name|data_length
operator|!=
literal|8
condition|)
name|err
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PNG_IO_CHUNK_DATA
case|:
break|break;
comment|/* no restrictions here */
case|case
name|PNG_IO_CHUNK_CRC
case|:
if|if
condition|(
name|data_length
operator|!=
literal|4
condition|)
name|err
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|err
operator|=
literal|1
expr_stmt|;
comment|/* uninitialized */
block|}
if|if
condition|(
name|err
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Bad I/O state or buffer size"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|USE_FAR_KEYWORD
end_ifndef
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|pngtest_read_data
name|pngtest_read_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_size_t
name|check
init|=
literal|0
decl_stmt|;
name|png_voidp
name|io_ptr
decl_stmt|;
comment|/* fread() returns 0 on error, so it is OK to store this in a png_size_t     * instead of an int, which is what fread() actually returns.     */
name|io_ptr
operator|=
name|png_get_io_ptr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_ptr
operator|!=
name|NULL
condition|)
block|{
name|check
operator|=
name|fread
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
operator|(
name|png_FILE_p
operator|)
name|io_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|!=
name|length
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Read Error"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|pngtest_check_io_state
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|,
name|PNG_IO_READING
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* This is the model-independent version. Since the standard I/O library    can't handle far buffers in the medium and small models, we have to copy    the data. */
end_comment
begin_define
DECL|macro|NEAR_BUF_SIZE
define|#
directive|define
name|NEAR_BUF_SIZE
value|1024
end_define
begin_define
DECL|macro|MIN
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a<= b ? a : b)
end_define
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|pngtest_read_data
name|pngtest_read_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_size_t
name|check
decl_stmt|;
name|png_byte
modifier|*
name|n_data
decl_stmt|;
name|png_FILE_p
name|io_ptr
decl_stmt|;
comment|/* Check if data really is near. If so, use usual code. */
name|n_data
operator|=
operator|(
name|png_byte
operator|*
operator|)
name|CVT_PTR_NOCHECK
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|io_ptr
operator|=
operator|(
name|png_FILE_p
operator|)
name|CVT_PTR
argument_list|(
name|png_get_io_ptr
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_bytep
operator|)
name|n_data
operator|==
name|data
condition|)
block|{
name|check
operator|=
name|fread
argument_list|(
name|n_data
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|io_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_byte
name|buf
index|[
name|NEAR_BUF_SIZE
index|]
decl_stmt|;
name|png_size_t
name|read
decl_stmt|,
name|remaining
decl_stmt|,
name|err
decl_stmt|;
name|check
operator|=
literal|0
expr_stmt|;
name|remaining
operator|=
name|length
expr_stmt|;
do|do
block|{
name|read
operator|=
name|MIN
argument_list|(
name|NEAR_BUF_SIZE
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
name|err
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|io_ptr
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|data
argument_list|,
name|buf
argument_list|,
name|read
argument_list|)
expr_stmt|;
comment|/* Copy far buffer to near buffer */
if|if
condition|(
name|err
operator|!=
name|read
condition|)
break|break;
else|else
name|check
operator|+=
name|err
expr_stmt|;
name|data
operator|+=
name|read
expr_stmt|;
name|remaining
operator|-=
name|read
expr_stmt|;
block|}
do|while
condition|(
name|remaining
operator|!=
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|check
operator|!=
name|length
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Read Error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|pngtest_check_io_state
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|,
name|PNG_IO_READING
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_FAR_KEYWORD */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
end_ifdef
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|pngtest_flush
name|pngtest_flush
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Do nothing; fflush() is said to be just a waste of energy. */
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Stifle compiler warning */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This is the function that does the actual writing of data.  If you are  * not writing to a standard C stream, you should create a replacement  * write_data function and use it at run time with png_set_write_fn(), rather  * than changing the library.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_FAR_KEYWORD
end_ifndef
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|pngtest_write_data
name|pngtest_write_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_size_t
name|check
decl_stmt|;
name|check
operator|=
name|fwrite
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
operator|(
name|png_FILE_p
operator|)
name|png_get_io_ptr
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|!=
name|length
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Write Error"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|pngtest_check_io_state
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|,
name|PNG_IO_WRITING
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* This is the model-independent version. Since the standard I/O library    can't handle far buffers in the medium and small models, we have to copy    the data. */
end_comment
begin_define
DECL|macro|NEAR_BUF_SIZE
define|#
directive|define
name|NEAR_BUF_SIZE
value|1024
end_define
begin_define
DECL|macro|MIN
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a<= b ? a : b)
end_define
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|pngtest_write_data
name|pngtest_write_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_size_t
name|check
decl_stmt|;
name|png_byte
modifier|*
name|near_data
decl_stmt|;
comment|/* Needs to be "png_byte *" instead of "png_bytep" */
name|png_FILE_p
name|io_ptr
decl_stmt|;
comment|/* Check if data really is near. If so, use usual code. */
name|near_data
operator|=
operator|(
name|png_byte
operator|*
operator|)
name|CVT_PTR_NOCHECK
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|io_ptr
operator|=
operator|(
name|png_FILE_p
operator|)
name|CVT_PTR
argument_list|(
name|png_get_io_ptr
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_bytep
operator|)
name|near_data
operator|==
name|data
condition|)
block|{
name|check
operator|=
name|fwrite
argument_list|(
name|near_data
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|io_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_byte
name|buf
index|[
name|NEAR_BUF_SIZE
index|]
decl_stmt|;
name|png_size_t
name|written
decl_stmt|,
name|remaining
decl_stmt|,
name|err
decl_stmt|;
name|check
operator|=
literal|0
expr_stmt|;
name|remaining
operator|=
name|length
expr_stmt|;
do|do
block|{
name|written
operator|=
name|MIN
argument_list|(
name|NEAR_BUF_SIZE
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|written
argument_list|)
expr_stmt|;
comment|/* Copy far buffer to near buffer */
name|err
operator|=
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|written
argument_list|,
name|io_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|written
condition|)
break|break;
else|else
name|check
operator|+=
name|err
expr_stmt|;
name|data
operator|+=
name|written
expr_stmt|;
name|remaining
operator|-=
name|written
expr_stmt|;
block|}
do|while
condition|(
name|remaining
operator|!=
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|check
operator|!=
name|length
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Write Error"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|pngtest_check_io_state
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|,
name|PNG_IO_WRITING
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_FAR_KEYWORD */
end_comment
begin_comment
comment|/* This function is called when there is a warning, but the library thinks  * it can continue anyway.  Replacement functions don't have to do anything  * here if you don't want to.  In the default configuration, png_ptr is  * not used, but it is passed in case it may be useful.  */
end_comment
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|pngtest_warning
name|pngtest_warning
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|message
parameter_list|)
block|{
name|PNG_CONST
name|char
modifier|*
name|name
init|=
literal|"UNKNOWN (ERROR!)"
decl_stmt|;
name|char
modifier|*
name|test
decl_stmt|;
name|test
operator|=
name|png_get_error_ptr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"%s: libpng warning: %s\n"
argument_list|,
name|name
argument_list|,
name|message
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"%s: libpng warning: %s\n"
argument_list|,
name|test
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is the default error handling function.  Note that replacements for  * this function MUST NOT RETURN, or the program will likely crash.  This  * function is used by default, or if the program supplies NULL for the  * error function pointer in png_set_error_fn().  */
end_comment
begin_function
specifier|static
name|void
name|PNGCBAPI
DECL|function|pngtest_error
name|pngtest_error
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|message
parameter_list|)
block|{
name|pngtest_warning
argument_list|(
name|png_ptr
argument_list|,
name|message
argument_list|)
expr_stmt|;
comment|/* We can return because png_error calls the default handler, which is     * actually OK in this case.     */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !PNG_STDIO_SUPPORTED */
end_comment
begin_comment
comment|/* END of code to validate stdio-free compilation */
end_comment
begin_comment
comment|/* START of code to validate memory allocation and deallocation */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
end_if
begin_comment
comment|/* Allocate memory.  For reasonable files, size should never exceed  * 64K.  However, zlib may allocate more then 64K if you don't tell  * it not to.  See zconf.h and png.h for more information.  zlib does  * need to allocate exactly 64K, so whatever you call here must  * have the ability to do that.  *  * This piece of code can be compiled to validate max 64K allocations  * by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K.  */
end_comment
begin_typedef
DECL|struct|memory_information
typedef|typedef
struct|struct
name|memory_information
block|{
DECL|member|size
name|png_alloc_size_t
name|size
decl_stmt|;
DECL|member|pointer
name|png_voidp
name|pointer
decl_stmt|;
DECL|member|next
name|struct
name|memory_information
name|FAR
modifier|*
name|next
decl_stmt|;
block|}
DECL|typedef|memory_information
name|memory_information
typedef|;
end_typedef
begin_typedef
DECL|typedef|memory_infop
typedef|typedef
name|memory_information
name|FAR
modifier|*
name|memory_infop
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|pinformation
specifier|static
name|memory_infop
name|pinformation
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_allocation
specifier|static
name|int
name|current_allocation
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|maximum_allocation
specifier|static
name|int
name|maximum_allocation
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|total_allocation
specifier|static
name|int
name|total_allocation
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|num_allocations
specifier|static
name|int
name|num_allocations
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|png_voidp
name|PNGCBAPI
name|png_debug_malloc
name|PNGARG
argument_list|(
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_alloc_size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|void
name|PNGCBAPI
name|png_debug_free
name|PNGARG
argument_list|(
operator|(
name|png_structp
name|png_ptr
operator|,
name|png_voidp
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
name|png_voidp
DECL|function|png_debug_malloc
name|PNGCBAPI
name|png_debug_malloc
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_alloc_size_t
name|size
parameter_list|)
block|{
comment|/* png_malloc has already tested for NULL; png_create_struct calls     * png_debug_malloc directly, with png_ptr == NULL which is OK     */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* This calls the library allocator twice, once to get the requested       buffer and once to get a new free list entry. */
block|{
comment|/* Disable malloc_fn and free_fn */
name|memory_infop
name|pinfo
decl_stmt|;
name|png_set_mem_fn
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pinfo
operator|=
operator|(
name|memory_infop
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_sizeof
argument_list|(
operator|*
name|pinfo
argument_list|)
argument_list|)
expr_stmt|;
name|pinfo
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|current_allocation
operator|+=
name|size
expr_stmt|;
name|total_allocation
operator|+=
name|size
expr_stmt|;
name|num_allocations
operator|++
expr_stmt|;
if|if
condition|(
name|current_allocation
operator|>
name|maximum_allocation
condition|)
name|maximum_allocation
operator|=
name|current_allocation
expr_stmt|;
name|pinfo
operator|->
name|pointer
operator|=
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Restore malloc_fn and free_fn */
name|png_set_mem_fn
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|png_debug_malloc
argument_list|,
name|png_debug_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|pinfo
operator|->
name|pointer
operator|==
name|NULL
condition|)
block|{
name|current_allocation
operator|-=
name|size
expr_stmt|;
name|total_allocation
operator|-=
name|size
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory in pngtest->png_debug_malloc"
argument_list|)
expr_stmt|;
block|}
name|pinfo
operator|->
name|next
operator|=
name|pinformation
expr_stmt|;
name|pinformation
operator|=
name|pinfo
expr_stmt|;
comment|/* Make sure the caller isn't assuming zeroed memory. */
name|png_memset
argument_list|(
name|pinfo
operator|->
name|pointer
argument_list|,
literal|0xdd
argument_list|,
name|pinfo
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"png_malloc %lu bytes at %p\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
name|pinfo
operator|->
name|pointer
argument_list|)
expr_stmt|;
return|return
call|(
name|png_voidp
call|)
argument_list|(
name|pinfo
operator|->
name|pointer
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/* Free a pointer.  It is removed from the list at the same time. */
end_comment
begin_function
name|void
name|PNGCBAPI
DECL|function|png_debug_free
name|png_debug_free
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_voidp
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"NULL pointer to png_debug_free.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This happens all the time. */
block|fprintf(STDERR, "WARNING: freeing NULL pointer\n");
endif|#
directive|endif
return|return;
block|}
comment|/* Unlink the element from the list. */
block|{
name|memory_infop
name|FAR
modifier|*
name|ppinfo
init|=
operator|&
name|pinformation
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|memory_infop
name|pinfo
init|=
operator|*
name|ppinfo
decl_stmt|;
if|if
condition|(
name|pinfo
operator|->
name|pointer
operator|==
name|ptr
condition|)
block|{
operator|*
name|ppinfo
operator|=
name|pinfo
operator|->
name|next
expr_stmt|;
name|current_allocation
operator|-=
name|pinfo
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|current_allocation
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Duplicate free of memory\n"
argument_list|)
expr_stmt|;
comment|/* We must free the list element too, but first kill                the memory that is to be freed. */
name|png_memset
argument_list|(
name|ptr
argument_list|,
literal|0x55
argument_list|,
name|pinfo
operator|->
name|size
argument_list|)
expr_stmt|;
name|png_free_default
argument_list|(
name|png_ptr
argument_list|,
name|pinfo
argument_list|)
expr_stmt|;
name|pinfo
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pinfo
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Pointer %x not found\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|ppinfo
operator|=
operator|&
name|pinfo
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Finally free the data. */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Freeing %p\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|png_free_default
argument_list|(
name|png_ptr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_USER_MEM_SUPPORTED&& PNG_DEBUG */
end_comment
begin_comment
comment|/* END of code to test memory allocation/deallocation */
end_comment
begin_comment
comment|/* Demonstration of user chunk support of the sTER and vpAg chunks */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_comment
comment|/* (sTER is a public chunk not yet known by libpng.  vpAg is a private chunk used in ImageMagick to store "virtual page" size).  */
end_comment
begin_decl_stmt
DECL|variable|user_chunk_data
specifier|static
name|png_uint_32
name|user_chunk_data
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* 0: sTER mode + 1      * 1: vpAg width      * 2: vpAg height      * 3: vpAg units      */
end_comment
begin_function
DECL|function|read_user_chunk_callback
specifier|static
name|int
name|PNGCBAPI
name|read_user_chunk_callback
parameter_list|(
name|png_struct
modifier|*
name|png_ptr
parameter_list|,
name|png_unknown_chunkp
name|chunk
parameter_list|)
block|{
name|png_uint_32
modifier|*
name|my_user_chunk_data
decl_stmt|;
comment|/* Return one of the following:     *    return (-n);  chunk had an error     *    return (0);  did not recognize     *    return (n);  success     *     * The unknown chunk structure contains the chunk data:     * png_byte name[5];     * png_byte *data;     * png_size_t size;     *     * Note that libpng has already taken care of the CRC handling.     */
if|if
condition|(
name|chunk
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|115
operator|&&
name|chunk
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|84
operator|&&
comment|/* s  T */
name|chunk
operator|->
name|name
index|[
literal|2
index|]
operator|==
literal|69
operator|&&
name|chunk
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|82
condition|)
comment|/* E  R */
block|{
comment|/* Found sTER chunk */
if|if
condition|(
name|chunk
operator|->
name|size
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Error return */
if|if
condition|(
name|chunk
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|chunk
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid mode */
name|my_user_chunk_data
operator|=
operator|(
name|png_uint_32
operator|*
operator|)
name|png_get_user_chunk_ptr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|my_user_chunk_data
index|[
literal|0
index|]
operator|=
name|chunk
operator|->
name|data
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|chunk
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|118
operator|||
name|chunk
operator|->
name|name
index|[
literal|1
index|]
operator|!=
literal|112
operator|||
comment|/* v  p */
name|chunk
operator|->
name|name
index|[
literal|2
index|]
operator|!=
literal|65
operator|||
name|chunk
operator|->
name|name
index|[
literal|3
index|]
operator|!=
literal|103
condition|)
comment|/* A  g */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Did not recognize */
comment|/* Found ImageMagick vpAg chunk */
if|if
condition|(
name|chunk
operator|->
name|size
operator|!=
literal|9
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Error return */
name|my_user_chunk_data
operator|=
operator|(
name|png_uint_32
operator|*
operator|)
name|png_get_user_chunk_ptr
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|my_user_chunk_data
index|[
literal|1
index|]
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|chunk
operator|->
name|data
argument_list|)
expr_stmt|;
name|my_user_chunk_data
index|[
literal|2
index|]
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|chunk
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|my_user_chunk_data
index|[
literal|3
index|]
operator|=
operator|(
name|png_uint_32
operator|)
name|chunk
operator|->
name|data
index|[
literal|8
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* END of code to demonstrate user chunk support */
end_comment
begin_comment
comment|/* Test one file */
end_comment
begin_function
name|int
DECL|function|test_one_file
name|test_one_file
parameter_list|(
name|PNG_CONST
name|char
modifier|*
name|inname
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|outname
parameter_list|)
block|{
specifier|static
name|png_FILE_p
name|fpin
decl_stmt|;
specifier|static
name|png_FILE_p
name|fpout
decl_stmt|;
comment|/* "static" prevents setjmp corruption */
name|png_structp
name|read_ptr
decl_stmt|;
name|png_infop
name|read_info_ptr
decl_stmt|,
name|end_info_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|png_structp
name|write_ptr
decl_stmt|;
name|png_infop
name|write_info_ptr
decl_stmt|;
name|png_infop
name|write_end_info_ptr
decl_stmt|;
else|#
directive|else
name|png_structp
name|write_ptr
init|=
name|NULL
decl_stmt|;
name|png_infop
name|write_info_ptr
init|=
name|NULL
decl_stmt|;
name|png_infop
name|write_end_info_ptr
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|png_bytep
name|row_buf
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
name|png_uint_32
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|num_pass
decl_stmt|,
name|pass
decl_stmt|;
name|int
name|bit_depth
decl_stmt|,
name|color_type
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
name|jmp_buf
name|png_jmpbuf
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|char
name|inbuf
index|[
literal|256
index|]
decl_stmt|,
name|outbuf
index|[
literal|256
index|]
decl_stmt|;
name|row_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fpin
operator|=
name|fopen
argument_list|(
name|inname
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Could not find input file %s\n"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fpout
operator|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Could not open output file %s\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pngtest_debug
argument_list|(
literal|"Allocating read and write structures"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
name|read_ptr
operator|=
name|png_create_read_struct_2
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|png_debug_malloc
argument_list|,
name|png_debug_free
argument_list|)
expr_stmt|;
else|#
directive|else
name|read_ptr
operator|=
name|png_create_read_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PNG_STDIO_SUPPORTED
name|png_set_error_fn
argument_list|(
name|read_ptr
argument_list|,
operator|(
name|png_voidp
operator|)
name|inname
argument_list|,
name|pngtest_error
argument_list|,
name|pngtest_warning
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
name|user_chunk_data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|user_chunk_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|user_chunk_data
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|user_chunk_data
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|png_set_read_user_chunk_fn
argument_list|(
name|read_ptr
argument_list|,
name|user_chunk_data
argument_list|,
name|read_user_chunk_callback
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
name|write_ptr
operator|=
name|png_create_write_struct_2
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|png_debug_malloc
argument_list|,
name|png_debug_free
argument_list|)
expr_stmt|;
else|#
directive|else
name|write_ptr
operator|=
name|png_create_write_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PNG_STDIO_SUPPORTED
name|png_set_error_fn
argument_list|(
name|write_ptr
argument_list|,
operator|(
name|png_voidp
operator|)
name|inname
argument_list|,
name|pngtest_error
argument_list|,
name|pngtest_warning
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|pngtest_debug
argument_list|(
literal|"Allocating read_info, write_info and end_info structures"
argument_list|)
expr_stmt|;
name|read_info_ptr
operator|=
name|png_create_info_struct
argument_list|(
name|read_ptr
argument_list|)
expr_stmt|;
name|end_info_ptr
operator|=
name|png_create_info_struct
argument_list|(
name|read_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|write_info_ptr
operator|=
name|png_create_info_struct
argument_list|(
name|write_ptr
argument_list|)
expr_stmt|;
name|write_end_info_ptr
operator|=
name|png_create_info_struct
argument_list|(
name|write_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|pngtest_debug
argument_list|(
literal|"Setting jmpbuf for read struct"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|read_ptr
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"%s -> %s: libpng read error\n"
argument_list|,
name|inname
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|read_ptr
argument_list|,
name|row_buf
argument_list|)
expr_stmt|;
name|row_buf
operator|=
name|NULL
expr_stmt|;
name|png_destroy_read_struct
argument_list|(
operator|&
name|read_ptr
argument_list|,
operator|&
name|read_info_ptr
argument_list|,
operator|&
name|end_info_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|png_destroy_info_struct
argument_list|(
name|write_ptr
argument_list|,
operator|&
name|write_end_info_ptr
argument_list|)
expr_stmt|;
name|png_destroy_write_struct
argument_list|(
operator|&
name|write_ptr
argument_list|,
operator|&
name|write_info_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fpout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
name|png_memcpy
argument_list|(
name|png_jmpbuf
argument_list|(
name|read_ptr
argument_list|)
argument_list|,
name|png_jmpbuf
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|pngtest_debug
argument_list|(
literal|"Setting jmpbuf for write struct"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|write_ptr
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"%s -> %s: libpng write error\n"
argument_list|,
name|inname
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|png_destroy_read_struct
argument_list|(
operator|&
name|read_ptr
argument_list|,
operator|&
name|read_info_ptr
argument_list|,
operator|&
name|end_info_ptr
argument_list|)
expr_stmt|;
name|png_destroy_info_struct
argument_list|(
name|write_ptr
argument_list|,
operator|&
name|write_end_info_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|png_destroy_write_struct
argument_list|(
operator|&
name|write_ptr
argument_list|,
operator|&
name|write_info_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fpout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
name|png_memcpy
argument_list|(
name|png_jmpbuf
argument_list|(
name|write_ptr
argument_list|)
argument_list|,
name|png_jmpbuf
argument_list|,
name|png_sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|pngtest_debug
argument_list|(
literal|"Initializing input and output streams"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
name|png_init_io
argument_list|(
name|read_ptr
argument_list|,
name|fpin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|png_init_io
argument_list|(
name|write_ptr
argument_list|,
name|fpout
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|png_set_read_fn
argument_list|(
name|read_ptr
argument_list|,
operator|(
name|png_voidp
operator|)
name|fpin
argument_list|,
name|pngtest_read_data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|png_set_write_fn
argument_list|(
name|write_ptr
argument_list|,
operator|(
name|png_voidp
operator|)
name|fpout
argument_list|,
name|pngtest_write_data
argument_list|,
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
name|pngtest_flush
argument_list|)
expr_stmt|;
else|#
directive|else
name|NULL
block|)
function|;
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|if
condition|(
name|status_dots_requested
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|png_set_write_status_fn
argument_list|(
name|write_ptr
argument_list|,
name|write_row_callback
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_set_read_status_fn
argument_list|(
name|read_ptr
argument_list|,
name|read_row_callback
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
name|png_set_write_status_fn
argument_list|(
name|write_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_set_read_status_fn
argument_list|(
name|read_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
end_ifdef
begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|filters_used
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|png_set_read_user_transform_fn
argument_list|(
name|read_ptr
argument_list|,
name|count_filters
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
end_ifdef
begin_expr_stmt
name|zero_samples
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|png_set_write_user_transform_fn
argument_list|(
name|write_ptr
argument_list|,
name|count_zero_samples
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_HANDLE_CHUNK_ALWAYS
end_ifndef
begin_define
DECL|macro|PNG_HANDLE_CHUNK_ALWAYS
define|#
directive|define
name|PNG_HANDLE_CHUNK_ALWAYS
value|3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|png_set_keep_unknown_chunks
argument_list|(
name|read_ptr
argument_list|,
name|PNG_HANDLE_CHUNK_ALWAYS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_HANDLE_CHUNK_IF_SAFE
end_ifndef
begin_define
DECL|macro|PNG_HANDLE_CHUNK_IF_SAFE
define|#
directive|define
name|PNG_HANDLE_CHUNK_IF_SAFE
value|2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|png_set_keep_unknown_chunks
argument_list|(
name|write_ptr
argument_list|,
name|PNG_HANDLE_CHUNK_IF_SAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Reading info struct"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|png_read_info
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Transferring info struct"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_block
block|{
name|int
name|interlace_type
decl_stmt|,
name|compression_type
decl_stmt|,
name|filter_type
decl_stmt|;
if|if
condition|(
name|png_get_IHDR
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|bit_depth
argument_list|,
operator|&
name|color_type
argument_list|,
operator|&
name|interlace_type
argument_list|,
operator|&
name|compression_type
argument_list|,
operator|&
name|filter_type
argument_list|)
condition|)
block|{
name|png_set_IHDR
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bit_depth
argument_list|,
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
name|color_type
argument_list|,
name|interlace_type
argument_list|,
name|compression_type
argument_list|,
name|filter_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|color_type
operator|,
name|PNG_INTERLACE_NONE
operator|,
name|compression_type
operator|,
name|filter_type
block|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block
begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_fixed_point
name|white_x
decl_stmt|,
name|white_y
decl_stmt|,
name|red_x
decl_stmt|,
name|red_y
decl_stmt|,
name|green_x
decl_stmt|,
name|green_y
decl_stmt|,
name|blue_x
decl_stmt|,
name|blue_y
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_cHRM_fixed
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|white_x
argument_list|,
operator|&
name|white_y
argument_list|,
operator|&
name|red_x
argument_list|,
operator|&
name|red_y
argument_list|,
operator|&
name|green_x
argument_list|,
operator|&
name|green_y
argument_list|,
operator|&
name|blue_x
argument_list|,
operator|&
name|blue_y
argument_list|)
condition|)
block|{
name|png_set_cHRM_fixed
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|white_x
argument_list|,
name|white_y
argument_list|,
name|red_x
argument_list|,
name|red_y
argument_list|,
name|green_x
argument_list|,
name|green_y
argument_list|,
name|blue_x
argument_list|,
name|blue_y
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_fixed_point
name|gamma
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_gAMA_fixed
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|gamma
argument_list|)
condition|)
name|png_set_gAMA_fixed
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Use floating point versions */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|double
name|white_x
decl_stmt|,
name|white_y
decl_stmt|,
name|red_x
decl_stmt|,
name|red_y
decl_stmt|,
name|green_x
decl_stmt|,
name|green_y
decl_stmt|,
name|blue_x
decl_stmt|,
name|blue_y
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_cHRM
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|white_x
argument_list|,
operator|&
name|white_y
argument_list|,
operator|&
name|red_x
argument_list|,
operator|&
name|red_y
argument_list|,
operator|&
name|green_x
argument_list|,
operator|&
name|green_y
argument_list|,
operator|&
name|blue_x
argument_list|,
operator|&
name|blue_y
argument_list|)
condition|)
block|{
name|png_set_cHRM
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|white_x
argument_list|,
name|white_y
argument_list|,
name|red_x
argument_list|,
name|red_y
argument_list|,
name|green_x
argument_list|,
name|green_y
argument_list|,
name|blue_x
argument_list|,
name|blue_y
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_gAMA_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|double
name|gamma
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_gAMA
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|gamma
argument_list|)
condition|)
name|png_set_gAMA
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|gamma
argument_list|)
expr_stmt|;
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Floating point */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Fixed point */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_charp
name|name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|png_bytep
name|profile
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|png_uint_32
name|proflen
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|compression_type
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_iCCP
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|compression_type
argument_list|,
operator|&
name|profile
argument_list|,
operator|&
name|proflen
argument_list|)
condition|)
block|{
name|png_set_iCCP
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|name
argument_list|,
name|compression_type
argument_list|,
name|profile
argument_list|,
name|proflen
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|int
name|intent
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_sRGB
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|intent
argument_list|)
condition|)
name|png_set_sRGB
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|intent
argument_list|)
expr_stmt|;
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_decl_stmt
unit|{
name|png_colorp
name|palette
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|num_palette
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_PLTE
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|palette
argument_list|,
operator|&
name|num_palette
argument_list|)
condition|)
name|png_set_PLTE
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|palette
argument_list|,
name|num_palette
argument_list|)
expr_stmt|;
end_if
begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|PNG_bKGD_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_color_16p
name|background
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_bKGD
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|background
argument_list|)
condition|)
block|{
name|png_set_bKGD
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|background
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_uint_16p
name|hist
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_hIST
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|hist
argument_list|)
condition|)
name|png_set_hIST
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|hist
argument_list|)
expr_stmt|;
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_oFFs_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_int_32
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|unit_type
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_oFFs
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|offset_x
argument_list|,
operator|&
name|offset_y
argument_list|,
operator|&
name|unit_type
argument_list|)
condition|)
block|{
name|png_set_oFFs
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|,
name|unit_type
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_charp
name|purpose
decl_stmt|,
name|units
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|png_charpp
name|params
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|png_int_32
name|X0
decl_stmt|,
name|X1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|type
decl_stmt|,
name|nparams
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_pCAL
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|purpose
argument_list|,
operator|&
name|X0
argument_list|,
operator|&
name|X1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|nparams
argument_list|,
operator|&
name|units
argument_list|,
operator|&
name|params
argument_list|)
condition|)
block|{
name|png_set_pCAL
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|purpose
argument_list|,
name|X0
argument_list|,
name|X1
argument_list|,
name|type
argument_list|,
name|nparams
argument_list|,
name|units
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_pHYs_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_uint_32
name|res_x
decl_stmt|,
name|res_y
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|unit_type
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_pHYs
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|res_x
argument_list|,
operator|&
name|res_y
argument_list|,
operator|&
name|unit_type
argument_list|)
condition|)
name|png_set_pHYs
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|res_x
argument_list|,
name|res_y
argument_list|,
name|unit_type
argument_list|)
expr_stmt|;
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sBIT_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_color_8p
name|sig_bit
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_sBIT
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|sig_bit
argument_list|)
condition|)
name|png_set_sBIT
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|sig_bit
argument_list|)
expr_stmt|;
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|int
name|unit
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|double
name|scal_width
decl_stmt|,
name|scal_height
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_sCAL
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|unit
argument_list|,
operator|&
name|scal_width
argument_list|,
operator|&
name|scal_height
argument_list|)
condition|)
block|{
name|png_set_sCAL
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|unit
argument_list|,
name|scal_width
argument_list|,
name|scal_height
argument_list|)
expr_stmt|;
block|}
end_if
begin_else
unit|}
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|int
name|unit
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|png_charp
name|scal_width
decl_stmt|,
name|scal_height
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_sCAL_s
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|unit
argument_list|,
operator|&
name|scal_width
argument_list|,
operator|&
name|scal_height
argument_list|)
condition|)
block|{
name|png_set_sCAL_s
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|unit
argument_list|,
name|scal_width
argument_list|,
name|scal_height
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_textp
name|text_ptr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|num_text
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_text
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|text_ptr
argument_list|,
operator|&
name|num_text
argument_list|)
operator|>
literal|0
condition|)
block|{
name|pngtest_debug1
argument_list|(
literal|"Handling %d iTXt/tEXt/zTXt chunks"
argument_list|,
name|num_text
argument_list|)
expr_stmt|;
name|png_set_text
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|text_ptr
argument_list|,
name|num_text
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_timep
name|mod_time
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_tIME
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|mod_time
argument_list|)
condition|)
block|{
name|png_set_tIME
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|mod_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
comment|/* We have to use png_memcpy instead of "=" because the string           * pointed to by png_convert_to_rfc1123() gets free'ed before           * we use it.           */
name|png_memcpy
argument_list|(
name|tIME_string
argument_list|,
name|png_convert_to_rfc1123
argument_list|(
name|read_ptr
argument_list|,
name|mod_time
argument_list|)
argument_list|,
name|png_sizeof
argument_list|(
name|tIME_string
argument_list|)
argument_list|)
expr_stmt|;
name|tIME_string
index|[
name|png_sizeof
argument_list|(
name|tIME_string
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tIME_chunk_present
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_TIME_RFC1123_SUPPORTED */
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_bytep
name|trans_alpha
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|num_trans
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|png_color_16p
name|trans_color
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|png_get_tRNS
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|trans_alpha
argument_list|,
operator|&
name|num_trans
argument_list|,
operator|&
name|trans_color
argument_list|)
condition|)
block|{
name|int
name|sample_max
init|=
operator|(
literal|1
operator|<<
name|bit_depth
operator|)
decl_stmt|;
comment|/* libpng doesn't reject a tRNS chunk with out-of-range samples */
if|if
condition|(
operator|!
operator|(
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|&&
operator|(
name|int
operator|)
name|trans_color
operator|->
name|gray
operator|>
name|sample_max
operator|)
operator|||
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|&&
operator|(
operator|(
name|int
operator|)
name|trans_color
operator|->
name|red
operator|>
name|sample_max
operator|||
operator|(
name|int
operator|)
name|trans_color
operator|->
name|green
operator|>
name|sample_max
operator|||
operator|(
name|int
operator|)
name|trans_color
operator|->
name|blue
operator|>
name|sample_max
operator|)
operator|)
operator|)
condition|)
name|png_set_tRNS
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|trans_alpha
argument_list|,
name|num_trans
argument_list|,
name|trans_color
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_decl_stmt
unit|{
name|png_unknown_chunkp
name|unknowns
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|num_unknowns
init|=
name|png_get_unknown_chunks
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
operator|&
name|unknowns
argument_list|)
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|num_unknowns
condition|)
block|{
name|int
name|i
decl_stmt|;
name|png_set_unknown_chunks
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|unknowns
argument_list|,
name|num_unknowns
argument_list|)
expr_stmt|;
comment|/* Copy the locations from the read_info_ptr.  The automatically           * generated locations in write_info_ptr are wrong because we           * haven't written anything yet.           */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_unknowns
condition|;
name|i
operator|++
control|)
name|png_set_unknown_chunk_location
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|i
argument_list|,
name|unknowns
index|[
name|i
index|]
operator|.
name|location
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_expr_stmt
unit|pngtest_debug
operator|(
literal|"Writing info struct"
operator|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* If we wanted, we could write info in two steps:  * png_write_info_before_PLTE(write_ptr, write_info_ptr);  */
end_comment
begin_expr_stmt
name|png_write_info
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_if
if|if
condition|(
name|user_chunk_data
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|png_byte
name|png_sTER
index|[
literal|5
index|]
init|=
block|{
literal|115
block|,
literal|84
block|,
literal|69
block|,
literal|82
block|,
literal|'\0'
block|}
decl_stmt|;
name|unsigned
name|char
name|ster_chunk_data
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n stereo mode = %lu\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|user_chunk_data
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ster_chunk_data
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|user_chunk_data
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|png_write_chunk
argument_list|(
name|write_ptr
argument_list|,
name|png_sTER
argument_list|,
name|ster_chunk_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_if
begin_if
if|if
condition|(
name|user_chunk_data
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|user_chunk_data
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|png_byte
name|png_vpAg
index|[
literal|5
index|]
init|=
block|{
literal|118
block|,
literal|112
block|,
literal|65
block|,
literal|103
block|,
literal|'\0'
block|}
decl_stmt|;
name|unsigned
name|char
name|vpag_chunk_data
index|[
literal|9
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" vpAg = %lu x %lu, units = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|user_chunk_data
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|user_chunk_data
index|[
literal|2
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|user_chunk_data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|vpag_chunk_data
argument_list|,
name|user_chunk_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|vpag_chunk_data
operator|+
literal|4
argument_list|,
name|user_chunk_data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|vpag_chunk_data
index|[
literal|8
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|user_chunk_data
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|png_write_chunk
argument_list|(
name|write_ptr
argument_list|,
name|png_vpAg
argument_list|,
name|vpag_chunk_data
argument_list|,
literal|9
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|SINGLE_ROWBUF_ALLOC
end_ifdef
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Allocating row buffer..."
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|read_ptr
argument_list|,
name|png_get_rowbytes
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|pngtest_debug1
argument_list|(
literal|"\t0x%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|row_buf
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SINGLE_ROWBUF_ALLOC */
end_comment
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Writing row data"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_INTERLACING_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_INTERLACING_SUPPORTED
argument_list|)
end_if
begin_expr_stmt
name|num_pass
operator|=
name|png_set_interlace_handling
argument_list|(
name|read_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_expr_stmt
name|png_set_interlace_handling
argument_list|(
name|write_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_expr_stmt
name|num_pass
operator|=
literal|1
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNGTEST_TIMING
end_ifdef
begin_expr_stmt
name|t_stop
operator|=
operator|(
name|float
operator|)
name|clock
argument_list|()
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|t_misc
operator|+=
operator|(
name|t_stop
operator|-
name|t_start
operator|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|t_start
operator|=
name|t_stop
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_for
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|num_pass
condition|;
name|pass
operator|++
control|)
block|{
name|pngtest_debug1
argument_list|(
literal|"Writing row data for pass %d"
argument_list|,
name|pass
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|SINGLE_ROWBUF_ALLOC
name|pngtest_debug2
argument_list|(
literal|"Allocating row buffer (pass %d, y = %u)..."
argument_list|,
name|pass
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|read_ptr
argument_list|,
name|png_get_rowbytes
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|pngtest_debug2
argument_list|(
literal|"\t0x%08lx (%u bytes)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|row_buf
argument_list|,
name|png_get_rowbytes
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SINGLE_ROWBUF_ALLOC */
name|png_read_rows
argument_list|(
name|read_ptr
argument_list|,
operator|(
name|png_bytepp
operator|)
operator|&
name|row_buf
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
ifdef|#
directive|ifdef
name|PNGTEST_TIMING
name|t_stop
operator|=
operator|(
name|float
operator|)
name|clock
argument_list|()
expr_stmt|;
name|t_decode
operator|+=
operator|(
name|t_stop
operator|-
name|t_start
operator|)
expr_stmt|;
name|t_start
operator|=
name|t_stop
expr_stmt|;
endif|#
directive|endif
name|png_write_rows
argument_list|(
name|write_ptr
argument_list|,
operator|(
name|png_bytepp
operator|)
operator|&
name|row_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNGTEST_TIMING
name|t_stop
operator|=
operator|(
name|float
operator|)
name|clock
argument_list|()
expr_stmt|;
name|t_encode
operator|+=
operator|(
name|t_stop
operator|-
name|t_start
operator|)
expr_stmt|;
name|t_start
operator|=
name|t_stop
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PNG_WRITE_SUPPORTED */
ifndef|#
directive|ifndef
name|SINGLE_ROWBUF_ALLOC
name|pngtest_debug2
argument_list|(
literal|"Freeing row buffer (pass %d, y = %u)"
argument_list|,
name|pass
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|read_ptr
argument_list|,
name|row_buf
argument_list|)
expr_stmt|;
name|row_buf
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* !SINGLE_ROWBUF_ALLOC */
block|}
block|}
end_for
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_expr_stmt
name|png_free_data
argument_list|(
name|read_ptr
argument_list|,
name|read_info_ptr
argument_list|,
name|PNG_FREE_UNKN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_expr_stmt
name|png_free_data
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|,
name|PNG_FREE_UNKN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Reading and writing end_info data"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|png_read_end
argument_list|(
name|read_ptr
argument_list|,
name|end_info_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
end_ifdef
begin_block
block|{
name|png_textp
name|text_ptr
decl_stmt|;
name|int
name|num_text
decl_stmt|;
if|if
condition|(
name|png_get_text
argument_list|(
name|read_ptr
argument_list|,
name|end_info_ptr
argument_list|,
operator|&
name|text_ptr
argument_list|,
operator|&
name|num_text
argument_list|)
operator|>
literal|0
condition|)
block|{
name|pngtest_debug1
argument_list|(
literal|"Handling %d iTXt/tEXt/zTXt chunks"
argument_list|,
name|num_text
argument_list|)
expr_stmt|;
name|png_set_text
argument_list|(
name|write_ptr
argument_list|,
name|write_end_info_ptr
argument_list|,
name|text_ptr
argument_list|,
name|num_text
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_tIME_SUPPORTED
end_ifdef
begin_block
block|{
name|png_timep
name|mod_time
decl_stmt|;
if|if
condition|(
name|png_get_tIME
argument_list|(
name|read_ptr
argument_list|,
name|end_info_ptr
argument_list|,
operator|&
name|mod_time
argument_list|)
condition|)
block|{
name|png_set_tIME
argument_list|(
name|write_ptr
argument_list|,
name|write_end_info_ptr
argument_list|,
name|mod_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
comment|/* We have to use png_memcpy instead of "=" because the string             pointed to by png_convert_to_rfc1123() gets free'ed before             we use it */
name|png_memcpy
argument_list|(
name|tIME_string
argument_list|,
name|png_convert_to_rfc1123
argument_list|(
name|read_ptr
argument_list|,
name|mod_time
argument_list|)
argument_list|,
name|png_sizeof
argument_list|(
name|tIME_string
argument_list|)
argument_list|)
expr_stmt|;
name|tIME_string
index|[
name|png_sizeof
argument_list|(
name|tIME_string
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tIME_chunk_present
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_TIME_RFC1123_SUPPORTED */
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_block
block|{
name|png_unknown_chunkp
name|unknowns
decl_stmt|;
name|int
name|num_unknowns
init|=
name|png_get_unknown_chunks
argument_list|(
name|read_ptr
argument_list|,
name|end_info_ptr
argument_list|,
operator|&
name|unknowns
argument_list|)
decl_stmt|;
if|if
condition|(
name|num_unknowns
condition|)
block|{
name|int
name|i
decl_stmt|;
name|png_set_unknown_chunks
argument_list|(
name|write_ptr
argument_list|,
name|write_end_info_ptr
argument_list|,
name|unknowns
argument_list|,
name|num_unknowns
argument_list|)
expr_stmt|;
comment|/* Copy the locations from the read_info_ptr.  The automatically           * generated locations in write_end_info_ptr are wrong because we           * haven't written the end_info yet.           */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_unknowns
condition|;
name|i
operator|++
control|)
name|png_set_unknown_chunk_location
argument_list|(
name|write_ptr
argument_list|,
name|write_end_info_ptr
argument_list|,
name|i
argument_list|,
name|unknowns
index|[
name|i
index|]
operator|.
name|location
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_expr_stmt
name|png_write_end
argument_list|(
name|write_ptr
argument_list|,
name|write_end_info_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_EASY_ACCESS_SUPPORTED
end_ifdef
begin_if
if|if
condition|(
name|verbose
condition|)
block|{
name|png_uint_32
name|iwidth
decl_stmt|,
name|iheight
decl_stmt|;
name|iwidth
operator|=
name|png_get_image_width
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|)
expr_stmt|;
name|iheight
operator|=
name|png_get_image_height
argument_list|(
name|write_ptr
argument_list|,
name|write_info_ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n Image width = %lu, height = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|iwidth
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|iheight
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Destroying data structs"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|SINGLE_ROWBUF_ALLOC
end_ifdef
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"destroying row_buf for read_ptr"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|png_free
argument_list|(
name|read_ptr
argument_list|,
name|row_buf
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|row_buf
operator|=
name|NULL
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SINGLE_ROWBUF_ALLOC */
end_comment
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"destroying read_ptr, read_info_ptr, end_info_ptr"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|png_destroy_read_struct
argument_list|(
operator|&
name|read_ptr
argument_list|,
operator|&
name|read_info_ptr
argument_list|,
operator|&
name|end_info_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"destroying write_end_info_ptr"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|png_destroy_info_struct
argument_list|(
name|write_ptr
argument_list|,
operator|&
name|write_end_info_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"destroying write_ptr, write_info_ptr"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|png_destroy_write_struct
argument_list|(
operator|&
name|write_ptr
argument_list|,
operator|&
name|write_info_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Destruction complete."
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|FCLOSE
argument_list|(
name|fpout
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|pngtest_debug
argument_list|(
literal|"Opening files for comparison"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|(
name|fpin
operator|=
name|fopen
argument_list|(
name|inname
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Could not find file %s\n"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_if
begin_if
if|if
condition|(
operator|(
name|fpout
operator|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Could not find file %s\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_if
begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|png_size_t
name|num_in
decl_stmt|,
name|num_out
decl_stmt|;
name|num_in
operator|=
name|fread
argument_list|(
name|inbuf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fpin
argument_list|)
expr_stmt|;
name|num_out
operator|=
name|fread
argument_list|(
name|outbuf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fpout
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_in
operator|!=
name|num_out
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\nFiles %s and %s are of a different size\n"
argument_list|,
name|inname
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote_question
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"   Was %s written with the same maximum IDAT chunk size (%d bytes),"
argument_list|,
name|inname
argument_list|,
name|PNG_ZBUF_SIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n   filtering heuristic (libpng default), compression"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" level (zlib default),\n   and zlib version (%s)?\n\n"
argument_list|,
name|ZLIB_VERSION
argument_list|)
expr_stmt|;
name|wrote_question
operator|=
literal|1
expr_stmt|;
block|}
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fpout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|num_in
condition|)
break|break;
if|if
condition|(
name|png_memcmp
argument_list|(
name|inbuf
argument_list|,
name|outbuf
argument_list|,
name|num_in
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\nFiles %s and %s are different\n"
argument_list|,
name|inname
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote_question
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"   Was %s written with the same maximum IDAT chunk size (%d bytes),"
argument_list|,
name|inname
argument_list|,
name|PNG_ZBUF_SIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n   filtering heuristic (libpng default), compression"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" level (zlib default),\n   and zlib version (%s)?\n\n"
argument_list|,
name|ZLIB_VERSION
argument_list|)
expr_stmt|;
name|wrote_question
operator|=
literal|1
expr_stmt|;
block|}
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fpout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_for
begin_expr_stmt
name|FCLOSE
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|FCLOSE
argument_list|(
name|fpout
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return
begin_comment
unit|}
comment|/* Input and output filenames */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|RISCOS
end_ifdef
begin_decl_stmt
unit|static
DECL|variable|inname
name|PNG_CONST
name|char
modifier|*
name|inname
init|=
literal|"pngtest/png"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|outname
specifier|static
name|PNG_CONST
name|char
modifier|*
name|outname
init|=
literal|"pngout/png"
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|inname
specifier|static
name|PNG_CONST
name|char
modifier|*
name|inname
init|=
literal|"pngtest.png"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|outname
specifier|static
name|PNG_CONST
name|char
modifier|*
name|outname
init|=
literal|"pngout.png"
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|int
DECL|function|main
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|multiple
init|=
literal|0
decl_stmt|;
name|int
name|ierror
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n Testing libpng version %s\n"
argument_list|,
name|PNG_LIBPNG_VER_STRING
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"   with zlib   version %s\n"
argument_list|,
name|ZLIB_VERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"%s"
argument_list|,
name|png_get_copyright
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Show the version of libpng used in building the library */
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" library (%lu):%s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_access_version_number
argument_list|()
argument_list|,
name|png_get_header_version
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Show the version of libpng used in building the application */
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" pngtest (%lu):%s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PNG_LIBPNG_VER
argument_list|,
name|PNG_HEADER_VERSION_STRING
argument_list|)
expr_stmt|;
comment|/* Do some consistency checking on the memory allocation settings, I'm     * not sure this matters, but it is nice to know, the first of these     * tests should be impossible because of the way the macros are set     * in pngconf.h     */
if|#
directive|if
name|defined
argument_list|(
name|MAXSEG_64K
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_MAX_MALLOC_64K
argument_list|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" NOTE: Zlib compiled for max 64k, libpng not\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* I think the following can happen. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXSEG_64K
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_MAX_MALLOC_64K
argument_list|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" NOTE: libpng compiled for max 64k, zlib not\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|png_libpng_ver
argument_list|,
name|PNG_LIBPNG_VER_STRING
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"Warning: versions are different between png.h and png.c\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"  png.h version: %s\n"
argument_list|,
name|PNG_LIBPNG_VER_STRING
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"  png.c version: %s\n\n"
argument_list|,
name|png_libpng_ver
argument_list|)
expr_stmt|;
operator|++
name|ierror
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-m"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|multiple
operator|=
literal|1
expr_stmt|;
name|status_dots_requested
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-mv"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-vm"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|multiple
operator|=
literal|1
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
name|status_dots_requested
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
name|status_dots_requested
operator|=
literal|1
expr_stmt|;
name|inname
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|inname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|status_dots_requested
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|multiple
operator|&&
name|argc
operator|==
literal|3
operator|+
name|verbose
condition|)
name|outname
operator|=
name|argv
index|[
literal|2
operator|+
name|verbose
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|multiple
operator|&&
name|argc
operator|>
literal|3
operator|+
name|verbose
operator|)
operator|||
operator|(
name|multiple
operator|&&
name|argc
operator|<
literal|2
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"  reads/writes one PNG file (without -m) or multiple files (-m)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"  with -m %s is used as a temporary file\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multiple
condition|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
name|int
name|allocation_now
init|=
name|current_allocation
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|kerror
decl_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n Testing %s:"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kerror
operator|=
name|test_one_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
name|int
name|k
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n PASS (%lu zero samples)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zero_samples
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" PASS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|256
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|filters_used
index|[
name|k
index|]
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Filter %d was used %lu times\n"
argument_list|,
name|k
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|filters_used
index|[
name|k
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
if|if
condition|(
name|tIME_chunk_present
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" tIME = %s\n"
argument_list|,
name|tIME_string
argument_list|)
expr_stmt|;
name|tIME_chunk_present
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_TIME_RFC1123_SUPPORTED */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" FAIL\n"
argument_list|)
expr_stmt|;
name|ierror
operator|+=
name|kerror
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
if|if
condition|(
name|allocation_now
operator|!=
name|current_allocation
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"MEMORY ERROR: %d bytes lost\n"
argument_list|,
name|current_allocation
operator|-
name|allocation_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_allocation
operator|!=
literal|0
condition|)
block|{
name|memory_infop
name|pinfo
init|=
name|pinformation
decl_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"MEMORY ERROR: %d bytes still allocated\n"
argument_list|,
name|current_allocation
argument_list|)
expr_stmt|;
while|while
condition|(
name|pinfo
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" %lu bytes at %x\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pinfo
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|pinfo
operator|->
name|pointer
argument_list|)
expr_stmt|;
name|pinfo
operator|=
name|pinfo
operator|->
name|next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Current memory allocation: %10d bytes\n"
argument_list|,
name|current_allocation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Maximum memory allocation: %10d bytes\n"
argument_list|,
name|maximum_allocation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Total   memory allocation: %10d bytes\n"
argument_list|,
name|total_allocation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"     Number of allocations: %10d\n"
argument_list|,
name|num_allocations
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|int
name|kerror
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
name|int
name|allocation_now
init|=
name|current_allocation
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|status_dots_requested
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
operator|==
literal|0
condition|)
name|status_dots_requested
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|verbose
operator|==
literal|1
operator|||
name|ierror
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n Testing %s:"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
name|kerror
operator|=
name|test_one_file
argument_list|(
name|inname
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
operator|==
literal|1
operator|||
name|i
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
name|int
name|k
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n PASS (%lu zero samples)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zero_samples
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" PASS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|256
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|filters_used
index|[
name|k
index|]
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Filter %d was used %lu times\n"
argument_list|,
name|k
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|filters_used
index|[
name|k
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
if|if
condition|(
name|tIME_chunk_present
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" tIME = %s\n"
argument_list|,
name|tIME_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_TIME_RFC1123_SUPPORTED */
block|}
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"\n Testing %s:"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" FAIL\n"
argument_list|)
expr_stmt|;
name|ierror
operator|+=
name|kerror
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
if|if
condition|(
name|allocation_now
operator|!=
name|current_allocation
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"MEMORY ERROR: %d bytes lost\n"
argument_list|,
name|current_allocation
operator|-
name|allocation_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_allocation
operator|!=
literal|0
condition|)
block|{
name|memory_infop
name|pinfo
init|=
name|pinformation
decl_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"MEMORY ERROR: %d bytes still allocated\n"
argument_list|,
name|current_allocation
argument_list|)
expr_stmt|;
while|while
condition|(
name|pinfo
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" %lu bytes at %x\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pinfo
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|pinfo
operator|->
name|pointer
argument_list|)
expr_stmt|;
name|pinfo
operator|=
name|pinfo
operator|->
name|next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_MEM_SUPPORTED
argument_list|)
operator|&&
name|PNG_DEBUG
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Current memory allocation: %10d bytes\n"
argument_list|,
name|current_allocation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Maximum memory allocation: %10d bytes\n"
argument_list|,
name|maximum_allocation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" Total   memory allocation: %10d bytes\n"
argument_list|,
name|total_allocation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"     Number of allocations: %10d\n"
argument_list|,
name|num_allocations
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PNGTEST_TIMING
name|t_stop
operator|=
operator|(
name|float
operator|)
name|clock
argument_list|()
expr_stmt|;
name|t_misc
operator|+=
operator|(
name|t_stop
operator|-
name|t_start
operator|)
expr_stmt|;
name|t_start
operator|=
name|t_stop
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" CPU time used = %.3f seconds"
argument_list|,
operator|(
name|t_misc
operator|+
name|t_decode
operator|+
name|t_encode
operator|)
operator|/
operator|(
name|float
operator|)
name|CLOCKS_PER_SEC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" (decoding %.3f,\n"
argument_list|,
name|t_decode
operator|/
operator|(
name|float
operator|)
name|CLOCKS_PER_SEC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|"        encoding %.3f ,"
argument_list|,
name|t_encode
operator|/
operator|(
name|float
operator|)
name|CLOCKS_PER_SEC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" other %.3f seconds)\n\n"
argument_list|,
name|t_misc
operator|/
operator|(
name|float
operator|)
name|CLOCKS_PER_SEC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ierror
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" libpng passes test\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|STDERR
argument_list|,
literal|" libpng FAILS test\n"
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|ierror
operator|!=
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Generate a compiler error if there is an old png.h in the search path. */
end_comment
begin_typedef
DECL|typedef|Your_png_h_is_not_version_1_5_1
typedef|typedef
name|png_libpng_version_1_5_1
name|Your_png_h_is_not_version_1_5_1
typedef|;
end_typedef
end_unit
