begin_unit
begin_comment
comment|/* pngerror.c - stub functions for i/o and memory allocation  *  * Last changed in libpng 1.6.15 [November 20, 2014]  * Copyright (c) 1998-2014 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * This file provides a location for all error handling.  Users who  * need special error handling are expected to write replacement functions  * and use png_set_error_fn() to use those functions.  See the instructions  * at each function.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_expr_stmt
specifier|static
name|PNG_FUNCTION
argument_list|(
name|void
argument_list|,
name|png_default_error
argument_list|,
name|PNGARG
argument_list|(
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|error_message
operator|)
argument_list|)
argument_list|,
name|PNG_NORETURN
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
end_ifdef
begin_decl_stmt
specifier|static
name|void
comment|/* PRIVATE */
name|png_default_warning
name|PNGARG
argument_list|(
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|png_const_charp
name|warning_message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WARNINGS */
end_comment
begin_comment
comment|/* This function is called whenever there is a fatal error.  This function  * should not be changed.  If there is a need to handle errors differently,  * you should supply a replacement error function and use png_set_error_fn()  * to replace the error function at run-time.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_ERROR_TEXT_SUPPORTED
end_ifdef
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|void
argument_list|,
argument|PNGAPI png_error
argument_list|,
argument|(png_const_structrp png_ptr, png_const_charp error_message)
argument_list|,
argument|PNG_NORETURN
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
name|char
name|msg
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
operator|(
name|PNG_FLAG_STRIP_ERROR_NUMBERS
operator||
name|PNG_FLAG_STRIP_ERROR_TEXT
operator|)
operator|)
operator|!=
literal|0
block|{
if|if
condition|(
operator|*
name|error_message
operator|==
name|PNG_LITERAL_SHARP
condition|)
block|{
comment|/* Strip "#nnnn " from beginning of error message. */
name|int
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|1
init|;
name|offset
operator|<
literal|15
condition|;
name|offset
operator|++
control|)
if|if
condition|(
name|error_message
index|[
name|offset
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_STRIP_ERROR_TEXT
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|offset
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|msg
index|[
name|i
index|]
operator|=
name|error_message
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|msg
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error_message
operator|=
name|msg
expr_stmt|;
block|}
else|else
name|error_message
operator|+=
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_STRIP_ERROR_TEXT
operator|)
operator|!=
literal|0
condition|)
block|{
name|msg
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error_message
operator|=
name|msg
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|error_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|error_fn
operator|)
operator|)
operator|(
name|png_constcast
argument_list|(
name|png_structrp
argument_list|,
name|png_ptr
argument_list|)
operator|,
name|error_message
operator|)
expr_stmt|;
comment|/* If the custom handler doesn't exist, or if it returns,       use the default handler, which will not return. */
name|png_default_error
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|void
argument_list|,
argument|PNGAPI png_err
argument_list|,
argument|(png_const_structrp png_ptr)
argument_list|,
argument|PNG_NORETURN
argument_list|)
end_macro
begin_block
block|{
comment|/* Prior to 1.5.2 the error_fn received a NULL pointer, expressed     * erroneously as '\0', instead of the empty string "".  This was     * apparently an error, introduced in libpng-1.2.20, and png_default_error     * will crash in this case.     */
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|error_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|error_fn
operator|)
operator|)
operator|(
name|png_constcast
argument_list|(
name|png_structrp
argument_list|,
name|png_ptr
argument_list|)
operator|,
literal|""
operator|)
expr_stmt|;
comment|/* If the custom handler doesn't exist, or if it returns,       use the default handler, which will not return. */
name|png_default_error
argument_list|(
name|png_ptr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ERROR_TEXT */
end_comment
begin_comment
comment|/* Utility to safely appends strings to a buffer.  This never errors out so  * error checking is not required in the caller.  */
end_comment
begin_function
name|size_t
DECL|function|png_safecat
name|png_safecat
parameter_list|(
name|png_charp
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|png_const_charp
name|string
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|bufsize
condition|)
block|{
if|if
condition|(
name|string
operator|!=
name|NULL
condition|)
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
operator|&&
name|pos
operator|<
name|bufsize
operator|-
literal|1
condition|)
name|buffer
index|[
name|pos
operator|++
index|]
operator|=
operator|*
name|string
operator|++
expr_stmt|;
name|buffer
index|[
name|pos
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_WARNINGS_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_TIME_RFC1123_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Utility to dump an unsigned value into a buffer, given a start pointer and  * and end pointer (which should point just *beyond* the end of the buffer!)  * Returns the pointer to the start of the formatted string.  */
end_comment
begin_function
name|png_charp
DECL|function|png_format_number
name|png_format_number
parameter_list|(
name|png_const_charp
name|start
parameter_list|,
name|png_charp
name|end
parameter_list|,
name|int
name|format
parameter_list|,
name|png_alloc_size_t
name|number
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* number of digits output */
name|int
name|mincount
init|=
literal|1
decl_stmt|;
comment|/* minimum number required */
name|int
name|output
init|=
literal|0
decl_stmt|;
comment|/* digit output (for the fixed point format) */
operator|*
operator|--
name|end
operator|=
literal|'\0'
expr_stmt|;
comment|/* This is written so that the loop always runs at least once, even with     * number zero.     */
while|while
condition|(
name|end
operator|>
name|start
operator|&&
operator|(
name|number
operator|!=
literal|0
operator|||
name|count
operator|<
name|mincount
operator|)
condition|)
block|{
specifier|static
specifier|const
name|char
name|digits
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|PNG_NUMBER_FORMAT_fixed
case|:
comment|/* Needs five digits (the fraction) */
name|mincount
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|output
operator|!=
literal|0
operator|||
name|number
operator|%
literal|10
operator|!=
literal|0
condition|)
block|{
operator|*
operator|--
name|end
operator|=
name|digits
index|[
name|number
operator|%
literal|10
index|]
expr_stmt|;
name|output
operator|=
literal|1
expr_stmt|;
block|}
name|number
operator|/=
literal|10
expr_stmt|;
break|break;
case|case
name|PNG_NUMBER_FORMAT_02u
case|:
comment|/* Expects at least 2 digits. */
name|mincount
operator|=
literal|2
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|PNG_NUMBER_FORMAT_u
case|:
operator|*
operator|--
name|end
operator|=
name|digits
index|[
name|number
operator|%
literal|10
index|]
expr_stmt|;
name|number
operator|/=
literal|10
expr_stmt|;
break|break;
case|case
name|PNG_NUMBER_FORMAT_02x
case|:
comment|/* This format expects at least two digits */
name|mincount
operator|=
literal|2
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|PNG_NUMBER_FORMAT_x
case|:
operator|*
operator|--
name|end
operator|=
name|digits
index|[
name|number
operator|&
literal|0xf
index|]
expr_stmt|;
name|number
operator|>>=
literal|4
expr_stmt|;
break|break;
default|default:
comment|/* an error */
name|number
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Keep track of the number of digits added */
operator|++
name|count
expr_stmt|;
comment|/* Float a fixed number here: */
if|if
condition|(
operator|(
name|format
operator|==
name|PNG_NUMBER_FORMAT_fixed
operator|)
operator|&&
operator|(
name|count
operator|==
literal|5
operator|)
operator|&&
operator|(
name|end
operator|>
name|start
operator|)
condition|)
block|{
comment|/* End of the fraction, but maybe nothing was output?  In that case           * drop the decimal point.  If the number is a true zero handle that           * here.           */
if|if
condition|(
name|output
operator|!=
literal|0
condition|)
operator|*
operator|--
name|end
operator|=
literal|'.'
expr_stmt|;
elseif|else
if|if
condition|(
name|number
operator|==
literal|0
condition|)
comment|/* and !output */
operator|*
operator|--
name|end
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
return|return
name|end
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
end_ifdef
begin_comment
comment|/* This function is called whenever there is a non-fatal error.  This function  * should not be changed.  If there is a need to handle warnings differently,  * you should supply a replacement warning function and use  * png_set_error_fn() to replace the warning function at run-time.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_warning
name|png_warning
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|warning_message
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
operator|(
name|PNG_FLAG_STRIP_ERROR_NUMBERS
operator||
name|PNG_FLAG_STRIP_ERROR_TEXT
operator|)
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|*
name|warning_message
operator|==
name|PNG_LITERAL_SHARP
condition|)
block|{
for|for
control|(
name|offset
operator|=
literal|1
init|;
name|offset
operator|<
literal|15
condition|;
name|offset
operator|++
control|)
if|if
condition|(
name|warning_message
index|[
name|offset
index|]
operator|==
literal|' '
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|warning_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|warning_fn
operator|)
operator|)
operator|(
name|png_constcast
argument_list|(
name|png_structrp
argument_list|,
name|png_ptr
argument_list|)
operator|,
name|warning_message
operator|+
name|offset
operator|)
expr_stmt|;
else|else
name|png_default_warning
argument_list|(
name|png_ptr
argument_list|,
name|warning_message
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* These functions support 'formatted' warning messages with up to  * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter  * is introduced by @<number>, where 'number' starts at 1.  This follows the  * standard established by X/Open for internationalizable error messages.  */
end_comment
begin_function
name|void
DECL|function|png_warning_parameter
name|png_warning_parameter
parameter_list|(
name|png_warning_parameters
name|p
parameter_list|,
name|int
name|number
parameter_list|,
name|png_const_charp
name|string
parameter_list|)
block|{
if|if
condition|(
name|number
operator|>
literal|0
operator|&&
name|number
operator|<=
name|PNG_WARNING_PARAMETER_COUNT
condition|)
operator|(
name|void
operator|)
name|png_safecat
argument_list|(
name|p
index|[
name|number
operator|-
literal|1
index|]
argument_list|,
operator|(
sizeof|sizeof
name|p
index|[
name|number
operator|-
literal|1
index|]
operator|)
argument_list|,
literal|0
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|png_warning_parameter_unsigned
name|png_warning_parameter_unsigned
parameter_list|(
name|png_warning_parameters
name|p
parameter_list|,
name|int
name|number
parameter_list|,
name|int
name|format
parameter_list|,
name|png_alloc_size_t
name|value
parameter_list|)
block|{
name|char
name|buffer
index|[
name|PNG_NUMBER_BUFFER_SIZE
index|]
decl_stmt|;
name|png_warning_parameter
argument_list|(
name|p
argument_list|,
name|number
argument_list|,
name|PNG_FORMAT_NUMBER
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|png_warning_parameter_signed
name|png_warning_parameter_signed
parameter_list|(
name|png_warning_parameters
name|p
parameter_list|,
name|int
name|number
parameter_list|,
name|int
name|format
parameter_list|,
name|png_int_32
name|value
parameter_list|)
block|{
name|png_alloc_size_t
name|u
decl_stmt|;
name|png_charp
name|str
decl_stmt|;
name|char
name|buffer
index|[
name|PNG_NUMBER_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* Avoid overflow by doing the negate in a png_alloc_size_t: */
name|u
operator|=
operator|(
name|png_alloc_size_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|u
operator|=
operator|~
name|u
operator|+
literal|1
expr_stmt|;
name|str
operator|=
name|PNG_FORMAT_NUMBER
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
operator|&&
name|str
operator|>
name|buffer
condition|)
operator|*
operator|--
name|str
operator|=
literal|'-'
expr_stmt|;
name|png_warning_parameter
argument_list|(
name|p
argument_list|,
name|number
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|png_formatted_warning
name|png_formatted_warning
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_warning_parameters
name|p
parameter_list|,
name|png_const_charp
name|message
parameter_list|)
block|{
comment|/* The internal buffer is just 192 bytes - enough for all our messages,     * overflow doesn't happen because this code checks!  If someone figures     * out how to send us a message longer than 192 bytes, all that will     * happen is that the message will be truncated appropriately.     */
name|size_t
name|i
init|=
literal|0
decl_stmt|;
comment|/* Index in the msg[] buffer: */
name|char
name|msg
index|[
literal|192
index|]
decl_stmt|;
comment|/* Each iteration through the following loop writes at most one character     * to msg[i++] then returns here to validate that there is still space for     * the trailing '\0'.  It may (in the case of a parameter) read more than     * one character from message[]; it must check for '\0' and continue to the     * test if it finds the end of string.     */
while|while
condition|(
name|i
operator|<
operator|(
sizeof|sizeof
name|msg
operator|)
operator|-
literal|1
operator|&&
operator|*
name|message
operator|!=
literal|'\0'
condition|)
block|{
comment|/* '@' at end of string is now just printed (previously it was skipped);        * it is an error in the calling code to terminate the string with @.        */
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|message
operator|==
literal|'@'
operator|&&
name|message
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|parameter_char
init|=
operator|*
operator|++
name|message
decl_stmt|;
comment|/* Consume the '@' */
specifier|static
specifier|const
name|char
name|valid_parameters
index|[]
init|=
literal|"123456789"
decl_stmt|;
name|int
name|parameter
init|=
literal|0
decl_stmt|;
comment|/* Search for the parameter digit, the index in the string is the           * parameter to use.           */
while|while
condition|(
name|valid_parameters
index|[
name|parameter
index|]
operator|!=
name|parameter_char
operator|&&
name|valid_parameters
index|[
name|parameter
index|]
operator|!=
literal|'\0'
condition|)
operator|++
name|parameter
expr_stmt|;
comment|/* If the parameter digit is out of range it will just get printed. */
if|if
condition|(
name|parameter
operator|<
name|PNG_WARNING_PARAMETER_COUNT
condition|)
block|{
comment|/* Append this parameter */
name|png_const_charp
name|parm
init|=
name|p
index|[
name|parameter
index|]
decl_stmt|;
name|png_const_charp
name|pend
init|=
name|p
index|[
name|parameter
index|]
operator|+
operator|(
sizeof|sizeof
name|p
index|[
name|parameter
index|]
operator|)
decl_stmt|;
comment|/* No need to copy the trailing '\0' here, but there is no guarantee              * that parm[] has been initialized, so there is no guarantee of a              * trailing '\0':              */
while|while
condition|(
name|i
operator|<
operator|(
sizeof|sizeof
name|msg
operator|)
operator|-
literal|1
operator|&&
operator|*
name|parm
operator|!=
literal|'\0'
operator|&&
name|parm
operator|<
name|pend
condition|)
name|msg
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|parm
operator|++
expr_stmt|;
comment|/* Consume the parameter digit too: */
operator|++
name|message
expr_stmt|;
continue|continue;
block|}
comment|/* else not a parameter and there is a character after the @ sign; just           * copy that.  This is known not to be '\0' because of the test above.           */
block|}
comment|/* At this point *message can't be '\0', even in the bad parameter case        * above where there is a lone '@' at the end of the message string.        */
name|msg
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|message
operator|++
expr_stmt|;
block|}
comment|/* i is always less than (sizeof msg), so: */
name|msg
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* And this is the formatted message. It may be larger than     * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these     * are not (currently) formatted.     */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WARNINGS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_benign_error
name|png_benign_error
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|error_message
parameter_list|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_BENIGN_ERRORS_WARN
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|chunk_name
operator|!=
literal|0
condition|)
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|chunk_name
operator|!=
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PNG_ERROR_TEXT_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|error_message
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_app_warning
name|png_app_warning
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|error_message
parameter_list|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_APP_WARNINGS_WARN
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_ERROR_TEXT_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|error_message
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_app_error
name|png_app_error
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|error_message
parameter_list|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_APP_ERRORS_WARN
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_ERROR_TEXT_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|error_message
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* BENIGN_ERRORS */
end_comment
begin_define
DECL|macro|PNG_MAX_ERROR_TEXT
define|#
directive|define
name|PNG_MAX_ERROR_TEXT
value|196
end_define
begin_comment
DECL|macro|PNG_MAX_ERROR_TEXT
comment|/* Currently limited by profile_error in png.c */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_WARNINGS_SUPPORTED
argument_list|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_ERROR_TEXT_SUPPORTED
argument_list|)
operator|)
end_if
begin_comment
comment|/* These utilities are used internally to build an error message that relates  * to the current chunk.  The chunk name comes from png_ptr->chunk_name,  * which is used to prefix the message.  The message is limited in length  * to 63 bytes. The name characters are output as hex digits wrapped in []  * if the character is invalid.  */
end_comment
begin_define
DECL|macro|isnonalpha
define|#
directive|define
name|isnonalpha
parameter_list|(
name|c
parameter_list|)
value|((c)< 65 || (c)> 122 || ((c)> 90&& (c)< 97))
end_define
begin_decl_stmt
DECL|variable|png_digit
specifier|static
name|PNG_CONST
name|char
name|png_digit
index|[
literal|16
index|]
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|void
comment|/* PRIVATE */
DECL|function|png_format_buffer
name|png_format_buffer
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_charp
name|buffer
parameter_list|,
name|png_const_charp
name|error_message
parameter_list|)
block|{
name|png_uint_32
name|chunk_name
init|=
name|png_ptr
operator|->
name|chunk_name
decl_stmt|;
name|int
name|iout
init|=
literal|0
decl_stmt|,
name|ishift
init|=
literal|24
decl_stmt|;
while|while
condition|(
name|ishift
operator|>=
literal|0
condition|)
block|{
name|int
name|c
init|=
call|(
name|int
call|)
argument_list|(
name|chunk_name
operator|>>
name|ishift
argument_list|)
operator|&
literal|0xff
decl_stmt|;
name|ishift
operator|-=
literal|8
expr_stmt|;
if|if
condition|(
name|isnonalpha
argument_list|(
name|c
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
name|PNG_LITERAL_LEFT_SQUARE_BRACKET
expr_stmt|;
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
name|png_digit
index|[
operator|(
name|c
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
name|png_digit
index|[
name|c
operator|&
literal|0x0f
index|]
expr_stmt|;
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
name|PNG_LITERAL_RIGHT_SQUARE_BRACKET
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error_message
operator|==
name|NULL
condition|)
name|buffer
index|[
name|iout
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|int
name|iin
init|=
literal|0
decl_stmt|;
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|iin
operator|<
name|PNG_MAX_ERROR_TEXT
operator|-
literal|1
operator|&&
name|error_message
index|[
name|iin
index|]
operator|!=
literal|'\0'
condition|)
name|buffer
index|[
name|iout
operator|++
index|]
operator|=
name|error_message
index|[
name|iin
operator|++
index|]
expr_stmt|;
comment|/* iin< PNG_MAX_ERROR_TEXT, so the following is safe: */
name|buffer
index|[
name|iout
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WARNINGS || ERROR_TEXT */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_ERROR_TEXT_SUPPORTED
argument_list|)
end_if
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|void
argument_list|,
argument|PNGAPI png_chunk_error
argument_list|,
argument|(png_const_structrp png_ptr, png_const_charp error_message)
argument_list|,
argument|PNG_NORETURN
argument_list|)
end_macro
begin_block
block|{
name|char
name|msg
index|[
literal|18
operator|+
name|PNG_MAX_ERROR_TEXT
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
else|else
block|{
name|png_format_buffer
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ&& ERROR_TEXT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_chunk_warning
name|png_chunk_warning
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|warning_message
parameter_list|)
block|{
name|char
name|msg
index|[
literal|18
operator|+
name|PNG_MAX_ERROR_TEXT
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|warning_message
argument_list|)
expr_stmt|;
else|else
block|{
name|png_format_buffer
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|,
name|warning_message
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WARNINGS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_BENIGN_ERRORS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_chunk_benign_error
name|png_chunk_benign_error
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|error_message
parameter_list|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_BENIGN_ERRORS_WARN
operator|)
operator|!=
literal|0
condition|)
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
else|else
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_ERROR_TEXT_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|error_message
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_chunk_report
name|png_chunk_report
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|message
parameter_list|,
name|int
name|error
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PNG_WARNINGS_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|message
argument_list|)
endif|#
directive|endif
comment|/* This is always supported, but for just read or just write it     * unconditionally does the right thing.     */
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
block|{
if|if
condition|(
name|error
operator|<
name|PNG_CHUNK_ERROR
condition|)
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
name|message
argument_list|)
expr_stmt|;
else|else
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
block|{
if|if
condition|(
name|error
operator|<
name|PNG_CHUNK_WRITE_ERROR
condition|)
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
name|message
argument_list|)
expr_stmt|;
else|else
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_ERROR_TEXT_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|void
argument_list|,
argument|png_fixed_error
argument_list|,
argument|(png_const_structrp png_ptr, png_const_charp name)
argument_list|,
argument|PNG_NORETURN
argument_list|)
end_macro
begin_block
block|{
DECL|macro|fixed_message
define|#
directive|define
name|fixed_message
value|"fixed point overflow in "
DECL|macro|fixed_message_ln
define|#
directive|define
name|fixed_message_ln
value|((sizeof fixed_message)-1)
name|int
name|iin
decl_stmt|;
name|char
name|msg
index|[
name|fixed_message_ln
operator|+
name|PNG_MAX_ERROR_TEXT
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|msg
argument_list|,
name|fixed_message
argument_list|,
name|fixed_message_ln
argument_list|)
expr_stmt|;
name|iin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
while|while
condition|(
name|iin
operator|<
operator|(
name|PNG_MAX_ERROR_TEXT
operator|-
literal|1
operator|)
operator|&&
name|name
index|[
name|iin
index|]
operator|!=
literal|0
condition|)
block|{
name|msg
index|[
name|fixed_message_ln
operator|+
name|iin
index|]
operator|=
name|name
index|[
name|iin
index|]
expr_stmt|;
operator|++
name|iin
expr_stmt|;
block|}
name|msg
index|[
name|fixed_message_ln
operator|+
name|iin
index|]
operator|=
literal|0
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
end_ifdef
begin_comment
comment|/* This API only exists if ANSI-C style error handling is used,  * otherwise it is necessary for png_default_error to be overridden.  */
end_comment
begin_function
name|jmp_buf
modifier|*
name|PNGAPI
DECL|function|png_set_longjmp_fn
name|png_set_longjmp_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_longjmp_ptr
name|longjmp_fn
parameter_list|,
name|size_t
name|jmp_buf_size
parameter_list|)
block|{
comment|/* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value     * and it must not change after that.  Libpng doesn't care how big the     * buffer is, just that it doesn't change.     *     * If the buffer size is no *larger* than the size of jmp_buf when libpng is     * compiled a built in jmp_buf is returned; this preserves the pre-1.6.0     * semantics that this call will not fail.  If the size is larger, however,     * the buffer is allocated and this may fail, causing the function to return     * NULL.     */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|jmp_buf_size
operator|=
literal|0
expr_stmt|;
comment|/* not allocated */
if|if
condition|(
name|jmp_buf_size
operator|<=
operator|(
sizeof|sizeof
name|png_ptr
operator|->
name|jmp_buf_local
operator|)
condition|)
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|=
operator|&
name|png_ptr
operator|->
name|jmp_buf_local
expr_stmt|;
else|else
block|{
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|=
name|png_voidcast
argument_list|(
name|jmp_buf
operator|*
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|jmp_buf_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* new NULL return on OOM */
name|png_ptr
operator|->
name|jmp_buf_size
operator|=
name|jmp_buf_size
expr_stmt|;
block|}
block|}
else|else
comment|/* Already allocated: check the size */
block|{
name|size_t
name|size
init|=
name|png_ptr
operator|->
name|jmp_buf_size
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|size
operator|=
operator|(
sizeof|sizeof
name|png_ptr
operator|->
name|jmp_buf_local
operator|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|!=
operator|&
name|png_ptr
operator|->
name|jmp_buf_local
condition|)
block|{
comment|/* This is an internal error in libpng: somehow we have been left              * with a stack allocated jmp_buf when the application regained              * control.  It's always possible to fix this up, but for the moment              * this is a png_error because that makes it easy to detect.              */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Libpng jmp_buf still allocated"
argument_list|)
expr_stmt|;
comment|/* png_ptr->jmp_buf_ptr =&png_ptr->jmp_buf_local; */
block|}
block|}
if|if
condition|(
name|size
operator|!=
name|jmp_buf_size
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Application jmp_buf size changed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* caller will probably crash: no choice here */
block|}
block|}
comment|/* Finally fill in the function, now we have a satisfactory buffer. It is     * valid to change the function on every call.     */
name|png_ptr
operator|->
name|longjmp_fn
operator|=
name|longjmp_fn
expr_stmt|;
return|return
name|png_ptr
operator|->
name|jmp_buf_ptr
return|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_free_jmpbuf
name|png_free_jmpbuf
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|jmp_buf
modifier|*
name|jb
init|=
name|png_ptr
operator|->
name|jmp_buf_ptr
decl_stmt|;
comment|/* A size of 0 is used to indicate a local, stack, allocation of the        * pointer; used here and in png.c        */
if|if
condition|(
name|jb
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|jmp_buf_size
operator|>
literal|0
condition|)
block|{
comment|/* This stuff is so that a failure to free the error control structure           * does not leave libpng in a state with no valid error handling: the           * free always succeeds, if there is an error it gets ignored.           */
if|if
condition|(
name|jb
operator|!=
operator|&
name|png_ptr
operator|->
name|jmp_buf_local
condition|)
block|{
comment|/* Make an internal, libpng, jmp_buf to return here */
name|jmp_buf
name|free_jmp_buf
decl_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|free_jmp_buf
argument_list|)
condition|)
block|{
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|=
operator|&
name|free_jmp_buf
expr_stmt|;
comment|/* come back here */
name|png_ptr
operator|->
name|jmp_buf_size
operator|=
literal|0
expr_stmt|;
comment|/* stack allocation */
name|png_ptr
operator|->
name|longjmp_fn
operator|=
name|longjmp
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|jb
argument_list|)
expr_stmt|;
comment|/* Return to setjmp on error */
block|}
block|}
block|}
comment|/* *Always* cancel everything out: */
name|png_ptr
operator|->
name|jmp_buf_size
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|longjmp_fn
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This is the default error handling function.  Note that replacements for  * this function MUST NOT RETURN, or the program will likely crash.  This  * function is used by default, or if the program supplies NULL for the  * error function pointer in png_set_error_fn().  */
end_comment
begin_expr_stmt
DECL|function|PNG_FUNCTION
specifier|static
name|PNG_FUNCTION
argument_list|(
argument|void
comment|/* PRIVATE */
argument_list|,
argument|png_default_error
argument_list|,
argument|(png_const_structrp png_ptr, png_const_charp error_message)
argument_list|,
argument|PNG_NORETURN
argument_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
comment|/* Check on NULL only added in 1.5.4 */
if|if
condition|(
name|error_message
operator|!=
name|NULL
operator|&&
operator|*
name|error_message
operator|==
name|PNG_LITERAL_SHARP
condition|)
block|{
comment|/* Strip "#nnnn " from beginning of error message. */
name|int
name|offset
decl_stmt|;
name|char
name|error_number
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|15
condition|;
name|offset
operator|++
control|)
block|{
name|error_number
index|[
name|offset
index|]
operator|=
name|error_message
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|error_message
index|[
name|offset
index|]
operator|==
literal|' '
condition|)
break|break;
block|}
end_expr_stmt
begin_if
if|if
condition|(
operator|(
name|offset
operator|>
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<
literal|15
operator|)
condition|)
block|{
name|error_number
index|[
name|offset
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libpng error no. %s: %s"
argument_list|,
name|error_number
argument_list|,
name|error_message
operator|+
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PNG_STRING_NEWLINE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libpng error: %s, offset=%d"
argument_list|,
name|error_message
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PNG_STRING_NEWLINE
argument_list|)
expr_stmt|;
block|}
end_if
begin_endif
unit|}    else
endif|#
directive|endif
end_endif
begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libpng error: %s"
argument_list|,
name|error_message
condition|?
name|error_message
else|:
literal|"undefined"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PNG_STRING_NEWLINE
argument_list|)
expr_stmt|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_macro
name|PNG_UNUSED
argument_list|(
argument|error_message
argument_list|)
end_macro
begin_comment
comment|/* Make compiler happy */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|png_longjmp
argument_list|(
name|png_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|}  PNG_FUNCTION
DECL|function|PNG_FUNCTION
operator|(
name|void
operator|,
name|PNGAPI
name|png_longjmp
operator|,
operator|(
name|png_const_structrp
name|png_ptr
operator|,
name|int
name|val
operator|)
operator|,
name|PNG_NORETURN
operator|)
block|{
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|longjmp_fn
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|jmp_buf_ptr
operator|!=
name|NULL
condition|)
name|png_ptr
operator|->
name|longjmp_fn
argument_list|(
operator|*
name|png_ptr
operator|->
name|jmp_buf_ptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
name|PNG_UNUSED
argument_list|(
argument|val
argument_list|)
endif|#
directive|endif
comment|/* If control reaches this point, png_longjmp() must not return. The only     * choice is to terminate the whole process (or maybe the thread); to do     * this the ANSI-C abort() function is used unless a different method is      * implemented by overriding the default configuration setting for     * PNG_ABORT().     */
name|PNG_ABORT
argument_list|()
expr_stmt|;
end_expr_stmt
begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
end_ifdef
begin_comment
comment|/* This function is called when there is a warning, but the library thinks  * it can continue anyway.  Replacement functions don't have to do anything  * here if you don't want them to.  In the default configuration, png_ptr is  * not used, but it is passed in case it may be useful.  */
end_comment
begin_function
unit|static
name|void
comment|/* PRIVATE */
DECL|function|png_default_warning
name|png_default_warning
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|warning_message
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
if|if
condition|(
operator|*
name|warning_message
operator|==
name|PNG_LITERAL_SHARP
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|char
name|warning_number
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|15
condition|;
name|offset
operator|++
control|)
block|{
name|warning_number
index|[
name|offset
index|]
operator|=
name|warning_message
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|warning_message
index|[
name|offset
index|]
operator|==
literal|' '
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|offset
operator|>
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<
literal|15
operator|)
condition|)
block|{
name|warning_number
index|[
name|offset
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libpng warning no. %s: %s"
argument_list|,
name|warning_number
argument_list|,
name|warning_message
operator|+
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PNG_STRING_NEWLINE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libpng warning: %s"
argument_list|,
name|warning_message
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PNG_STRING_NEWLINE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libpng warning: %s"
argument_list|,
name|warning_message
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PNG_STRING_NEWLINE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|warning_message
argument_list|)
comment|/* Make compiler happy */
endif|#
directive|endif
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Make compiler happy */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WARNINGS */
end_comment
begin_comment
comment|/* This function is called when the application wants to use another method  * of handling errors and warnings.  Note that the error function MUST NOT  * return to the calling routine or serious problems will occur.  The return  * method used in the default routine calls longjmp(png_ptr->jmp_buf_ptr, 1)  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_error_fn
name|png_set_error_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_voidp
name|error_ptr
parameter_list|,
name|png_error_ptr
name|error_fn
parameter_list|,
name|png_error_ptr
name|warning_fn
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|error_ptr
operator|=
name|error_ptr
expr_stmt|;
name|png_ptr
operator|->
name|error_fn
operator|=
name|error_fn
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
name|png_ptr
operator|->
name|warning_fn
operator|=
name|warning_fn
expr_stmt|;
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|warning_fn
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* This function returns a pointer to the error_ptr associated with the user  * functions.  The application should free any memory associated with this  * pointer before png_write_destroy and png_read_destroy are called.  */
end_comment
begin_function
name|png_voidp
name|PNGAPI
DECL|function|png_get_error_ptr
name|png_get_error_ptr
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|(
name|png_voidp
operator|)
name|png_ptr
operator|->
name|error_ptr
operator|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_strip_error_numbers
name|png_set_strip_error_numbers
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|strip_mode
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|flags
operator|&=
operator|(
operator|(
operator|~
operator|(
name|PNG_FLAG_STRIP_ERROR_NUMBERS
operator||
name|PNG_FLAG_STRIP_ERROR_TEXT
operator|)
operator|)
operator|&
name|strip_mode
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_READ_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Currently the above both depend on SETJMP_SUPPORTED, however it would be     * possible to implement without setjmp support just so long as there is some     * way to handle the error return here:     */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|void
comment|/* PRIVATE */
argument_list|,
argument|(PNGCBAPI png_safe_error)
argument_list|,
argument|(png_structp png_nonconst_ptr, png_const_charp error_message)
argument_list|,
argument|PNG_NORETURN
argument_list|)
end_macro
begin_block
block|{
specifier|const
name|png_const_structrp
name|png_ptr
init|=
name|png_nonconst_ptr
decl_stmt|;
name|png_imagep
name|image
init|=
name|png_voidcast
argument_list|(
name|png_imagep
argument_list|,
name|png_ptr
operator|->
name|error_ptr
argument_list|)
decl_stmt|;
comment|/* An error is always logged here, overwriting anything (typically a warning)     * that is already there:     */
if|if
condition|(
name|image
operator|!=
name|NULL
condition|)
block|{
name|png_safecat
argument_list|(
name|image
operator|->
name|message
argument_list|,
operator|(
sizeof|sizeof
name|image
operator|->
name|message
operator|)
argument_list|,
literal|0
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
name|image
operator|->
name|warning_or_error
operator||=
name|PNG_IMAGE_ERROR
expr_stmt|;
comment|/* Retrieve the jmp_buf from within the png_control, making this work for        * C++ compilation too is pretty tricky: C++ wants a pointer to the first        * element of a jmp_buf, but C doesn't tell us the type of that.        */
if|if
condition|(
name|image
operator|->
name|opaque
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|opaque
operator|->
name|error_buf
operator|!=
name|NULL
condition|)
name|longjmp
argument_list|(
name|png_control_jmp_buf
argument_list|(
name|image
operator|->
name|opaque
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Missing longjmp buffer, the following is to help debugging: */
block|{
name|size_t
name|pos
init|=
name|png_safecat
argument_list|(
name|image
operator|->
name|message
argument_list|,
operator|(
sizeof|sizeof
name|image
operator|->
name|message
operator|)
argument_list|,
literal|0
argument_list|,
literal|"bad longjmp: "
argument_list|)
decl_stmt|;
name|png_safecat
argument_list|(
name|image
operator|->
name|message
argument_list|,
operator|(
sizeof|sizeof
name|image
operator|->
name|message
operator|)
argument_list|,
name|pos
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here on an internal programming error. */
name|abort
argument_list|()
expr_stmt|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
name|PNGCBAPI
DECL|function|png_safe_warning
name|png_safe_warning
parameter_list|(
name|png_structp
name|png_nonconst_ptr
parameter_list|,
name|png_const_charp
name|warning_message
parameter_list|)
block|{
specifier|const
name|png_const_structrp
name|png_ptr
init|=
name|png_nonconst_ptr
decl_stmt|;
name|png_imagep
name|image
init|=
name|png_voidcast
argument_list|(
name|png_imagep
argument_list|,
name|png_ptr
operator|->
name|error_ptr
argument_list|)
decl_stmt|;
comment|/* A warning is only logged if there is no prior warning or error. */
if|if
condition|(
name|image
operator|->
name|warning_or_error
operator|==
literal|0
condition|)
block|{
name|png_safecat
argument_list|(
name|image
operator|->
name|message
argument_list|,
operator|(
sizeof|sizeof
name|image
operator|->
name|message
operator|)
argument_list|,
literal|0
argument_list|,
name|warning_message
argument_list|)
expr_stmt|;
name|image
operator|->
name|warning_or_error
operator||=
name|PNG_IMAGE_WARNING
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_safe_execute
name|png_safe_execute
parameter_list|(
name|png_imagep
name|image_in
parameter_list|,
name|int
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|png_voidp
parameter_list|)
parameter_list|,
name|png_voidp
name|arg
parameter_list|)
block|{
specifier|volatile
name|png_imagep
name|image
init|=
name|image_in
decl_stmt|;
specifier|volatile
name|int
name|result
decl_stmt|;
specifier|volatile
name|png_voidp
name|saved_error_buf
decl_stmt|;
name|jmp_buf
name|safe_jmpbuf
decl_stmt|;
comment|/* Safely execute function(arg) with png_error returning to this function. */
name|saved_error_buf
operator|=
name|image
operator|->
name|opaque
operator|->
name|error_buf
expr_stmt|;
name|result
operator|=
name|setjmp
argument_list|(
name|safe_jmpbuf
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|image
operator|->
name|opaque
operator|->
name|error_buf
operator|=
name|safe_jmpbuf
expr_stmt|;
name|result
operator|=
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|image
operator|->
name|opaque
operator|->
name|error_buf
operator|=
name|saved_error_buf
expr_stmt|;
comment|/* And do the cleanup prior to any failure return. */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|png_image_free
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SIMPLIFIED READ || SIMPLIFIED_WRITE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ || WRITE */
end_comment
end_unit
