begin_unit
begin_comment
comment|/* pngpread.c - read a png file in push mode  *  * Last changed in libpng 1.6.18 [July 23, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Push model modes */
end_comment
begin_define
DECL|macro|PNG_READ_SIG_MODE
define|#
directive|define
name|PNG_READ_SIG_MODE
value|0
end_define
begin_define
DECL|macro|PNG_READ_CHUNK_MODE
define|#
directive|define
name|PNG_READ_CHUNK_MODE
value|1
end_define
begin_define
DECL|macro|PNG_READ_IDAT_MODE
define|#
directive|define
name|PNG_READ_IDAT_MODE
value|2
end_define
begin_define
DECL|macro|PNG_READ_tEXt_MODE
define|#
directive|define
name|PNG_READ_tEXt_MODE
value|4
end_define
begin_define
DECL|macro|PNG_READ_zTXt_MODE
define|#
directive|define
name|PNG_READ_zTXt_MODE
value|5
end_define
begin_define
DECL|macro|PNG_READ_DONE_MODE
define|#
directive|define
name|PNG_READ_DONE_MODE
value|6
end_define
begin_define
DECL|macro|PNG_READ_iTXt_MODE
define|#
directive|define
name|PNG_READ_iTXt_MODE
value|7
end_define
begin_define
DECL|macro|PNG_ERROR_MODE
define|#
directive|define
name|PNG_ERROR_MODE
value|8
end_define
begin_define
DECL|macro|PNG_PUSH_SAVE_BUFFER_IF_FULL
define|#
directive|define
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
define|\
value|if (png_ptr->push_length + 4> png_ptr->buffer_size) \    { png_push_save_buffer(png_ptr); return; }
end_define
begin_define
DECL|macro|PNG_PUSH_SAVE_BUFFER_IF_LT
define|#
directive|define
name|PNG_PUSH_SAVE_BUFFER_IF_LT
parameter_list|(
name|N
parameter_list|)
define|\
value|if (png_ptr->buffer_size< N) \    { png_push_save_buffer(png_ptr); return; }
end_define
begin_function
name|void
name|PNGAPI
DECL|function|png_process_data
name|png_process_data
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|buffer_size
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_push_restore_buffer
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_process_some_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|png_size_t
name|PNGAPI
DECL|function|png_process_data_pause
name|png_process_data_pause
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|save
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* It's easiest for the caller if we do the save; then the caller doesn't        * have to supply the same data again:        */
if|if
condition|(
name|save
operator|!=
literal|0
condition|)
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This includes any pending saved bytes: */
name|png_size_t
name|remaining
init|=
name|png_ptr
operator|->
name|buffer_size
decl_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
comment|/* So subtract the saved buffer size, unless all the data           * is actually 'saved', in which case we just return 0           */
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|<
name|remaining
condition|)
return|return
name|remaining
operator|-
name|png_ptr
operator|->
name|save_buffer_size
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_process_data_skip
name|png_process_data_skip
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* TODO: Deprecate and remove this API.    * Somewhere the implementation of this seems to have been lost,    * or abandoned.  It was only to support some internal back-door access    * to png_struct) in libpng-1.4.x.    */
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"png_process_data_skip is not implemented in any current version of libpng"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* What we do with the incoming data depends on what we were previously  * doing before we ran out of data...  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_process_some_data
name|png_process_some_data
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|png_ptr
operator|->
name|process_mode
condition|)
block|{
case|case
name|PNG_READ_SIG_MODE
case|:
block|{
name|png_push_read_sig
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PNG_READ_CHUNK_MODE
case|:
block|{
name|png_push_read_chunk
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PNG_READ_IDAT_MODE
case|:
block|{
name|png_push_read_IDAT
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|png_ptr
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Read any remaining signature bytes from the stream and compare them with  * the correct PNG signature.  It is possible that this routine is called  * with bytes already read from the signature, either because they have been  * checked by the calling application, or because of multiple calls to this  * routine.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_sig
name|png_push_read_sig
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
name|png_size_t
name|num_checked
init|=
name|png_ptr
operator|->
name|sig_bytes
decl_stmt|,
comment|/* SAFE, does not exceed 8 */
name|num_to_check
init|=
literal|8
operator|-
name|num_checked
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
name|num_to_check
condition|)
block|{
name|num_to_check
operator|=
name|png_ptr
operator|->
name|buffer_size
expr_stmt|;
block|}
name|png_push_fill_buffer
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|signature
index|[
name|num_checked
index|]
operator|)
argument_list|,
name|num_to_check
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sig_bytes
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|sig_bytes
operator|+
name|num_to_check
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
argument_list|)
condition|)
block|{
if|if
condition|(
name|num_checked
operator|<
literal|4
operator|&&
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
operator|-
literal|4
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not a PNG file"
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG file corrupted by ASCII conversion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|png_ptr
operator|->
name|sig_bytes
operator|>=
literal|8
condition|)
block|{
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_CHUNK_MODE
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_chunk
name|png_push_read_chunk
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
name|png_uint_32
name|chunk_name
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
name|int
name|keep
decl_stmt|;
comment|/* unknown handling method */
endif|#
directive|endif
comment|/* First we make sure we have enough data for the 4-byte chunk name     * and the 4-byte chunk length before proceeding with decoding the     * chunk data.  To fully decode each of these chunks, we also make     * sure we have enough data in the buffer for the 4-byte CRC at the     * end of every chunk (except IDAT, which is handled separately).     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_HEADER
operator|)
operator|==
literal|0
condition|)
block|{
name|png_byte
name|chunk_length
index|[
literal|4
index|]
decl_stmt|;
name|png_byte
name|chunk_tag
index|[
literal|4
index|]
decl_stmt|;
name|PNG_PUSH_SAVE_BUFFER_IF_LT
argument_list|(
literal|8
argument_list|)
name|png_push_fill_buffer
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|push_length
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|)
expr_stmt|;
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|chunk_tag
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_name
operator|=
name|PNG_CHUNK_FROM_STRING
argument_list|(
name|chunk_tag
argument_list|)
expr_stmt|;
name|png_check_chunk_name
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
block|}
name|chunk_name
operator|=
name|png_ptr
operator|->
name|chunk_name
expr_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_AFTER_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_CHUNK_AFTER_IDAT
expr_stmt|;
comment|/* If we reach an IDAT chunk, this means we have read all of the        * header chunks, and we can start reading the image (or if this        * is called after the image has been read - we have an error).        */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before IDAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before IDAT"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_IDAT_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_AFTER_IDAT
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_AFTER_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many IDATs found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chunk_name
operator|==
name|png_IHDR
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|!=
literal|13
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid IHDR length"
argument_list|)
expr_stmt|;
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IEND
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_IEND
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_DONE_MODE
expr_stmt|;
name|png_push_have_end
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
elseif|else
if|if
condition|(
operator|(
name|keep
operator|=
name|png_chunk_unknown_handling
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|,
name|keep
argument_list|)
decl_stmt|;
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_PLTE
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_IDAT
condition|)
block|{
name|png_ptr
operator|->
name|idat_size
operator|=
name|png_ptr
operator|->
name|push_length
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_IDAT_MODE
expr_stmt|;
name|png_push_have_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
operator|==
name|png_gAMA
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_gAMA
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
operator|==
name|png_sBIT
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
operator|==
name|png_cHRM
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_cHRM
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sRGB
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
operator|==
name|png_iCCP
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sPLT
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tRNS
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_bKGD
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_hIST
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pHYs
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_oFFs
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_pCAL
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_sCAL
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_sCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tIME
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_tEXt
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_zTXt
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
elseif|else
if|if
condition|(
name|chunk_name
operator|==
name|png_iTXt
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_FULL
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|,
name|PNG_HANDLE_CHUNK_AS_DEFAULT
argument_list|)
decl_stmt|;
block|}
name|png_ptr
operator|->
name|mode
operator|&=
operator|~
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGCBAPI
DECL|function|png_push_fill_buffer
name|png_push_fill_buffer
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_bytep
name|ptr
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|ptr
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|!=
literal|0
condition|)
block|{
name|png_size_t
name|save_size
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|png_ptr
operator|->
name|save_buffer_size
condition|)
name|save_size
operator|=
name|length
expr_stmt|;
else|else
name|save_size
operator|=
name|png_ptr
operator|->
name|save_buffer_size
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|length
operator|-=
name|save_size
expr_stmt|;
name|ptr
operator|+=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|current_buffer_size
operator|!=
literal|0
condition|)
block|{
name|png_size_t
name|save_size
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|png_ptr
operator|->
name|current_buffer_size
condition|)
name|save_size
operator|=
name|length
expr_stmt|;
else|else
name|save_size
operator|=
name|png_ptr
operator|->
name|current_buffer_size
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_save_buffer
name|png_push_save_buffer
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_ptr
operator|!=
name|png_ptr
operator|->
name|save_buffer
condition|)
block|{
name|png_size_t
name|i
decl_stmt|,
name|istop
decl_stmt|;
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|istop
operator|=
name|png_ptr
operator|->
name|save_buffer_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|png_ptr
operator|->
name|save_buffer_ptr
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|save_buffer
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
operator|*
name|sp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|+
name|png_ptr
operator|->
name|current_buffer_size
operator|>
name|png_ptr
operator|->
name|save_buffer_max
condition|)
block|{
name|png_size_t
name|new_max
decl_stmt|;
name|png_bytep
name|old_buffer
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|>
name|PNG_SIZE_MAX
operator|-
operator|(
name|png_ptr
operator|->
name|current_buffer_size
operator|+
literal|256
operator|)
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Potential overflow of save_buffer"
argument_list|)
expr_stmt|;
block|}
name|new_max
operator|=
name|png_ptr
operator|->
name|save_buffer_size
operator|+
name|png_ptr
operator|->
name|current_buffer_size
operator|+
literal|256
expr_stmt|;
name|old_buffer
operator|=
name|png_ptr
operator|->
name|save_buffer
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_size_t
operator|)
name|new_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_buffer
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for save_buffer"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|png_ptr
operator|->
name|save_buffer
argument_list|,
name|old_buffer
argument_list|,
name|png_ptr
operator|->
name|save_buffer_size
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_buffer
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_max
operator|=
name|new_max
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|current_buffer_size
condition|)
block|{
name|memcpy
argument_list|(
name|png_ptr
operator|->
name|save_buffer
operator|+
name|png_ptr
operator|->
name|save_buffer_size
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_size
operator|+=
name|png_ptr
operator|->
name|current_buffer_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|=
literal|0
expr_stmt|;
block|}
name|png_ptr
operator|->
name|save_buffer_ptr
operator|=
name|png_ptr
operator|->
name|save_buffer
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_restore_buffer
name|png_push_restore_buffer
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|buffer_length
parameter_list|)
block|{
name|png_ptr
operator|->
name|current_buffer
operator|=
name|buffer
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|=
name|buffer_length
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|=
name|buffer_length
operator|+
name|png_ptr
operator|->
name|save_buffer_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_ptr
operator|=
name|png_ptr
operator|->
name|current_buffer
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_IDAT
name|png_push_read_IDAT
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_HEADER
operator|)
operator|==
literal|0
condition|)
block|{
name|png_byte
name|chunk_length
index|[
literal|4
index|]
decl_stmt|;
name|png_byte
name|chunk_tag
index|[
literal|4
index|]
decl_stmt|;
comment|/* TODO: this code can be commoned up with the same code in push_read */
name|PNG_PUSH_SAVE_BUFFER_IF_LT
argument_list|(
literal|8
argument_list|)
name|png_push_fill_buffer
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|push_length
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|)
expr_stmt|;
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|chunk_tag
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_name
operator|=
name|PNG_CHUNK_FROM_STRING
argument_list|(
name|chunk_tag
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
operator|!=
name|png_IDAT
condition|)
block|{
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_CHUNK_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_ENDED
operator|)
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough compressed data"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|idat_size
operator|=
name|png_ptr
operator|->
name|push_length
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|idat_size
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|save_buffer_size
operator|!=
literal|0
condition|)
block|{
name|png_size_t
name|save_size
init|=
name|png_ptr
operator|->
name|save_buffer_size
decl_stmt|;
name|png_uint_32
name|idat_size
init|=
name|png_ptr
operator|->
name|idat_size
decl_stmt|;
comment|/* We want the smaller of 'idat_size' and 'current_buffer_size', but they        * are of different types and we don't know which variable has the fewest        * bits.  Carefully select the smaller and cast it to the type of the        * larger - this cannot overflow.  Do not cast in the following test - it        * will break on either 16-bit or 64-bit platforms.        */
if|if
condition|(
name|idat_size
operator|<
name|save_size
condition|)
name|save_size
operator|=
operator|(
name|png_size_t
operator|)
name|idat_size
expr_stmt|;
else|else
name|idat_size
operator|=
operator|(
name|png_uint_32
operator|)
name|save_size
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_process_IDAT_data
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|-=
name|idat_size
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|idat_size
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|current_buffer_size
operator|!=
literal|0
condition|)
block|{
name|png_size_t
name|save_size
init|=
name|png_ptr
operator|->
name|current_buffer_size
decl_stmt|;
name|png_uint_32
name|idat_size
init|=
name|png_ptr
operator|->
name|idat_size
decl_stmt|;
comment|/* We want the smaller of 'idat_size' and 'current_buffer_size', but they        * are of different types and we don't know which variable has the fewest        * bits.  Carefully select the smaller and cast it to the type of the        * larger - this cannot overflow.        */
if|if
condition|(
name|idat_size
operator|<
name|save_size
condition|)
name|save_size
operator|=
operator|(
name|png_size_t
operator|)
name|idat_size
expr_stmt|;
else|else
name|idat_size
operator|=
operator|(
name|png_uint_32
operator|)
name|save_size
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_process_IDAT_data
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|-=
name|idat_size
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|idat_size
operator|==
literal|0
condition|)
block|{
name|PNG_PUSH_SAVE_BUFFER_IF_LT
argument_list|(
literal|4
argument_list|)
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator|&=
operator|~
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_process_IDAT_data
name|png_process_IDAT_data
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|buffer_length
parameter_list|)
block|{
comment|/* The caller checks for a non-zero buffer length. */
if|if
condition|(
operator|!
operator|(
name|buffer_length
operator|>
literal|0
operator|)
operator|||
name|buffer
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"No IDAT data (internal error)"
argument_list|)
expr_stmt|;
comment|/* This routine must process all the data it has been given     * before returning, calling the row callback as required to     * handle the uncompressed results.     */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|buffer
expr_stmt|;
comment|/* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|buffer_length
expr_stmt|;
comment|/* Keep going until the decompressed data is all processed     * or the stream marked as finished.     */
while|while
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|>
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_ENDED
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* We have data for zlib, but we must check that zlib        * has someplace to put the results.  It doesn't matter        * if we don't expect any results -- it may be the input        * data is just the LZ end code.        */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
call|(
name|uInt
call|)
argument_list|(
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
block|}
comment|/* Using Z_SYNC_FLUSH here means that an unterminated        * LZ stream (a stream with a missing end code) can still        * be handled, otherwise (Z_NO_FLUSH) a future zlib        * implementation might defer output and therefore        * change the current behavior (see comments in inflate.c        * for why this doesn't happen at present with zlib 1.2.5).        */
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
comment|/* Check for any failure before proceeding. */
if|if
condition|(
name|ret
operator|!=
name|Z_OK
operator|&&
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
comment|/* Terminate the decompression. */
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZSTREAM_ENDED
expr_stmt|;
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
comment|/* This may be a truncated stream (missing or           * damaged end code).  Treat that as a warning.           */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|>=
name|png_ptr
operator|->
name|num_rows
operator|||
name|png_ptr
operator|->
name|pass
operator|>
literal|6
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncated compressed data in IDAT"
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Decompression error in IDAT"
argument_list|)
expr_stmt|;
comment|/* Skip the check on unprocessed input */
return|return;
block|}
comment|/* Did inflate output any data? */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|!=
name|png_ptr
operator|->
name|row_buf
condition|)
block|{
comment|/* Is this unexpected data after the last row?           * If it is, artificially terminate the LZ output           * here.           */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|>=
name|png_ptr
operator|->
name|num_rows
operator|||
name|png_ptr
operator|->
name|pass
operator|>
literal|6
condition|)
block|{
comment|/* Extra data. */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compressed data in IDAT"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZSTREAM_ENDED
expr_stmt|;
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
comment|/* Do no more processing; skip the unprocessed              * input check below.              */
return|return;
block|}
comment|/* Do we have a complete row? */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|==
literal|0
condition|)
name|png_push_process_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* And check for the end of the stream. */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZSTREAM_ENDED
expr_stmt|;
block|}
comment|/* All the data should have been processed, if anything     * is left at this point we have bytes of IDAT data     * after the zlib end code.     */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|>
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compression data in IDAT"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_process_row
name|png_push_process_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* 1.5.6: row_info moved out of png_struct to a local here. */
name|png_row_info
name|row_info
decl_stmt|;
name|row_info
operator|.
name|width
operator|=
name|png_ptr
operator|->
name|iwidth
expr_stmt|;
comment|/* NOTE: width of current interlaced row */
name|row_info
operator|.
name|color_type
operator|=
name|png_ptr
operator|->
name|color_type
expr_stmt|;
name|row_info
operator|.
name|bit_depth
operator|=
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
name|row_info
operator|.
name|channels
operator|=
name|png_ptr
operator|->
name|channels
expr_stmt|;
name|row_info
operator|.
name|pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
name|row_info
operator|.
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|.
name|pixel_depth
argument_list|,
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|>
name|PNG_FILTER_VALUE_NONE
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|<
name|PNG_FILTER_VALUE_LAST
condition|)
name|png_read_filter_row
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|prev_row
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad adaptive filter value"
argument_list|)
expr_stmt|;
block|}
comment|/* libpng 1.5.6: the following line was copying png_ptr->rowbytes before     * 1.5.6, while the buffer really is this big in current versions of libpng     * it may not be in the future, so this was changed just to copy the     * interlaced row count:     */
name|memcpy
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
name|png_ptr
operator|->
name|row_buf
argument_list|,
name|row_info
operator|.
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|!=
literal|0
condition|)
name|png_do_read_transformations
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|row_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The transformed pixel depth should match the depth now in row_info. */
if|if
condition|(
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|=
name|row_info
operator|.
name|pixel_depth
expr_stmt|;
if|if
condition|(
name|row_info
operator|.
name|pixel_depth
operator|>
name|png_ptr
operator|->
name|maximum_pixel_depth
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"progressive row overflow"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|!=
name|row_info
operator|.
name|pixel_depth
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal progressive row size calculation error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Expand interlaced rows to full size */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|6
condition|)
name|png_do_read_interlace
argument_list|(
operator|&
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|pass
argument_list|,
name|png_ptr
operator|->
name|transformations
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|png_ptr
operator|->
name|pass
condition|)
block|{
case|case
literal|0
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Updates png_ptr->pass */
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|)
comment|/* Pass 1 might be empty */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|4
operator|&&
name|png_ptr
operator|->
name|height
operator|<=
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|6
operator|&&
name|png_ptr
operator|->
name|height
operator|<=
literal|4
condition|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|1
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|)
comment|/* Skip top 4 generated rows */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|)
comment|/* Pass 3 might be empty */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|3
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|)
comment|/* Skip top two generated rows */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|6
condition|)
comment|/* Pass 5 might be empty */
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|5
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|6
condition|)
comment|/* Skip top generated row */
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
case|case
literal|6
case|:
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|!=
literal|6
condition|)
break|break;
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_push_finish_row
name|png_read_push_finish_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_ystart
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_yinc
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
comment|/* Height of interlace block.  This is not currently used - if you need     * it, uncomment it here and in png.h    static PNG_CONST png_byte png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};    */
endif|#
directive|endif
name|png_ptr
operator|->
name|row_number
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|<
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|row_number
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|pass
operator|==
literal|1
operator|&&
name|png_ptr
operator|->
name|width
operator|<
literal|5
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|pass
operator|==
literal|3
operator|&&
name|png_ptr
operator|->
name|width
operator|<
literal|3
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|pass
operator|==
literal|5
operator|&&
name|png_ptr
operator|->
name|width
operator|<
literal|2
operator|)
condition|)
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>
literal|7
condition|)
name|png_ptr
operator|->
name|pass
operator|--
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>=
literal|7
condition|)
break|break;
name|png_ptr
operator|->
name|iwidth
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
block|}
do|while
condition|(
name|png_ptr
operator|->
name|iwidth
operator|==
literal|0
operator|||
name|png_ptr
operator|->
name|num_rows
operator|==
literal|0
condition|)
do|;
block|}
endif|#
directive|endif
comment|/* READ_INTERLACING */
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_have_info
name|png_push_have_info
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|info_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|info_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|info_ptr
operator|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_have_end
name|png_push_have_end
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|end_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|end_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|info_ptr
operator|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_have_row
name|png_push_have_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|row_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|row_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|row
operator|,
name|png_ptr
operator|->
name|row_number
operator|,
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|pass
operator|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_progressive_combine_row
name|png_progressive_combine_row
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|old_row
parameter_list|,
name|png_const_bytep
name|new_row
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* new_row is a flag here - if it is NULL then the app callback was called     * from an empty row (see the calls to png_struct::row_fn below), otherwise     * it must be png_ptr->row_buf+1     */
if|if
condition|(
name|new_row
operator|!=
name|NULL
condition|)
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|old_row
argument_list|,
literal|1
comment|/*blocky display*/
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_INTERLACING */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_progressive_read_fn
name|png_set_progressive_read_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_voidp
name|progressive_ptr
parameter_list|,
name|png_progressive_info_ptr
name|info_fn
parameter_list|,
name|png_progressive_row_ptr
name|row_fn
parameter_list|,
name|png_progressive_end_ptr
name|end_fn
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|info_fn
operator|=
name|info_fn
expr_stmt|;
name|png_ptr
operator|->
name|row_fn
operator|=
name|row_fn
expr_stmt|;
name|png_ptr
operator|->
name|end_fn
operator|=
name|end_fn
expr_stmt|;
name|png_set_read_fn
argument_list|(
name|png_ptr
argument_list|,
name|progressive_ptr
argument_list|,
name|png_push_fill_buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|png_voidp
name|PNGAPI
DECL|function|png_get_progressive_ptr
name|png_get_progressive_ptr
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|png_ptr
operator|->
name|io_ptr
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PROGRESSIVE_READ */
end_comment
end_unit
