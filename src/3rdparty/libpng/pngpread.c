begin_unit
begin_comment
comment|/* pngpread.c - read a png file in push mode  *  * Last changed in libpng 1.5.1 [February 3, 2011]  * Copyright (c) 1998-2011 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_PROGRESSIVE_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Push model modes */
end_comment
begin_define
DECL|macro|PNG_READ_SIG_MODE
define|#
directive|define
name|PNG_READ_SIG_MODE
value|0
end_define
begin_define
DECL|macro|PNG_READ_CHUNK_MODE
define|#
directive|define
name|PNG_READ_CHUNK_MODE
value|1
end_define
begin_define
DECL|macro|PNG_READ_IDAT_MODE
define|#
directive|define
name|PNG_READ_IDAT_MODE
value|2
end_define
begin_define
DECL|macro|PNG_SKIP_MODE
define|#
directive|define
name|PNG_SKIP_MODE
value|3
end_define
begin_define
DECL|macro|PNG_READ_tEXt_MODE
define|#
directive|define
name|PNG_READ_tEXt_MODE
value|4
end_define
begin_define
DECL|macro|PNG_READ_zTXt_MODE
define|#
directive|define
name|PNG_READ_zTXt_MODE
value|5
end_define
begin_define
DECL|macro|PNG_READ_DONE_MODE
define|#
directive|define
name|PNG_READ_DONE_MODE
value|6
end_define
begin_define
DECL|macro|PNG_READ_iTXt_MODE
define|#
directive|define
name|PNG_READ_iTXt_MODE
value|7
end_define
begin_define
DECL|macro|PNG_ERROR_MODE
define|#
directive|define
name|PNG_ERROR_MODE
value|8
end_define
begin_function
name|void
name|PNGAPI
DECL|function|png_process_data
name|png_process_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|buffer_size
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_push_restore_buffer
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_process_some_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|png_size_t
name|PNGAPI
DECL|function|png_process_data_pause
name|png_process_data_pause
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|save
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* It's easiest for the caller if we do the save, then the caller doesn't        * have to supply the same data again:        */
if|if
condition|(
name|save
condition|)
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This includes any pending saved bytes: */
name|png_size_t
name|remaining
init|=
name|png_ptr
operator|->
name|buffer_size
decl_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
comment|/* So subtract the saved buffer size, unless all the data           * is actually 'saved', in which case we just return 0           */
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|<
name|remaining
condition|)
return|return
name|remaining
operator|-
name|png_ptr
operator|->
name|save_buffer_size
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_process_data_skip
name|png_process_data_skip
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_uint_32
name|remaining
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|process_mode
operator|==
name|PNG_SKIP_MODE
operator|&&
name|png_ptr
operator|->
name|skip_length
operator|>
literal|0
condition|)
block|{
comment|/* At the end of png_process_data the buffer size must be 0 (see the loop        * above) so we can detect a broken call here:        */
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_process_data_skip called inside png_process_data"
argument_list|)
expr_stmt|;
comment|/* If is impossible for there to be a saved buffer at this point -        * otherwise we could not be in SKIP mode.  This will also happen if        * png_process_skip is called inside png_process_data (but only very        * rarely.)        */
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_process_data_skip called with saved data"
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|png_ptr
operator|->
name|skip_length
expr_stmt|;
name|png_ptr
operator|->
name|skip_length
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_CHUNK_MODE
expr_stmt|;
block|}
return|return
name|remaining
return|;
block|}
end_function
begin_comment
comment|/* What we do with the incoming data depends on what we were previously  * doing before we ran out of data...  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_process_some_data
name|png_process_some_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|png_ptr
operator|->
name|process_mode
condition|)
block|{
case|case
name|PNG_READ_SIG_MODE
case|:
block|{
name|png_push_read_sig
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PNG_READ_CHUNK_MODE
case|:
block|{
name|png_push_read_chunk
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PNG_READ_IDAT_MODE
case|:
block|{
name|png_push_read_IDAT
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
case|case
name|PNG_READ_tEXt_MODE
case|:
block|{
name|png_push_read_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
case|case
name|PNG_READ_zTXt_MODE
case|:
block|{
name|png_push_read_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
case|case
name|PNG_READ_iTXt_MODE
case|:
block|{
name|png_push_read_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|PNG_SKIP_MODE
case|:
block|{
name|png_push_crc_finish
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|png_ptr
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Read any remaining signature bytes from the stream and compare them with  * the correct PNG signature.  It is possible that this routine is called  * with bytes already read from the signature, either because they have been  * checked by the calling application, or because of multiple calls to this  * routine.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_sig
name|png_push_read_sig
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_size_t
name|num_checked
init|=
name|png_ptr
operator|->
name|sig_bytes
decl_stmt|,
name|num_to_check
init|=
literal|8
operator|-
name|num_checked
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
name|num_to_check
condition|)
block|{
name|num_to_check
operator|=
name|png_ptr
operator|->
name|buffer_size
expr_stmt|;
block|}
name|png_push_fill_buffer
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|signature
index|[
name|num_checked
index|]
operator|)
argument_list|,
name|num_to_check
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sig_bytes
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|sig_bytes
operator|+
name|num_to_check
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
argument_list|)
condition|)
block|{
if|if
condition|(
name|num_checked
operator|<
literal|4
operator|&&
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
operator|-
literal|4
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not a PNG file"
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG file corrupted by ASCII conversion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|png_ptr
operator|->
name|sig_bytes
operator|>=
literal|8
condition|)
block|{
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_CHUNK_MODE
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_chunk
name|png_push_read_chunk
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|PNG_IHDR
expr_stmt|;
name|PNG_IDAT
expr_stmt|;
name|PNG_IEND
expr_stmt|;
name|PNG_PLTE
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
name|PNG_bKGD
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
name|PNG_cHRM
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
name|PNG_gAMA
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
name|PNG_hIST
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
name|PNG_iCCP
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
name|PNG_iTXt
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
name|PNG_oFFs
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
name|PNG_pCAL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
name|PNG_pHYs
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
name|PNG_sBIT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
name|PNG_sCAL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
name|PNG_sRGB
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
name|PNG_sPLT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
name|PNG_tEXt
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
name|PNG_tIME
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
name|PNG_tRNS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
name|PNG_zTXt
expr_stmt|;
endif|#
directive|endif
comment|/* First we make sure we have enough data for the 4 byte chunk name     * and the 4 byte chunk length before proceeding with decoding the     * chunk data.  To fully decode each of these chunks, we also make     * sure we have enough data in the buffer for the 4 byte CRC at the     * end of every chunk (except IDAT, which is handled separately).     */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_HEADER
operator|)
condition|)
block|{
name|png_byte
name|chunk_length
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
literal|8
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_fill_buffer
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|push_length
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|)
expr_stmt|;
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_check_chunk_name
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IDAT
argument_list|,
literal|4
argument_list|)
condition|)
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_AFTER_IDAT
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_CHUNK_AFTER_IDAT
expr_stmt|;
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IHDR
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|!=
literal|13
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid IHDR length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IEND
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_IEND
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_DONE_MODE
expr_stmt|;
name|png_push_have_end
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
elseif|else
if|if
condition|(
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IDAT
argument_list|,
literal|4
argument_list|)
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
name|png_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_PLTE
argument_list|,
literal|4
argument_list|)
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IDAT
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before IDAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before IDAT"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_PLTE
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IDAT
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* If we reach an IDAT chunk, this means we have read all of the        * header chunks, and we can start reading the image (or if this        * is called after the image has been read - we have an error).        */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before IDAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before IDAT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_AFTER_IDAT
operator|)
condition|)
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_AFTER_IDAT
condition|)
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many IDATs found"
argument_list|)
expr_stmt|;
block|}
name|png_ptr
operator|->
name|idat_size
operator|=
name|png_ptr
operator|->
name|push_length
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_IDAT_MODE
expr_stmt|;
name|png_push_have_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_gAMA
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_gAMA
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_sBIT
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_cHRM
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_cHRM
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_sRGB
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_iCCP
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_sPLT
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_tRNS
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_bKGD
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_hIST
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_pHYs
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_oFFs
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_pCAL
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_sCAL
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_sCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_tIME
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_handle_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_tEXt
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_handle_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_zTXt
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_handle_zTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
elseif|else
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_iTXt
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_handle_iTXt
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|png_ptr
operator|->
name|push_length
operator|+
literal|4
operator|>
name|png_ptr
operator|->
name|buffer_size
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_handle_unknown
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|push_length
argument_list|)
expr_stmt|;
block|}
name|png_ptr
operator|->
name|mode
operator|&=
operator|~
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_crc_skip
name|png_push_crc_skip
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|skip
parameter_list|)
block|{
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_SKIP_MODE
expr_stmt|;
name|png_ptr
operator|->
name|skip_length
operator|=
name|skip
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_crc_finish
name|png_push_crc_finish
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|skip_length
operator|&&
name|png_ptr
operator|->
name|save_buffer_size
condition|)
block|{
name|png_size_t
name|save_size
init|=
name|png_ptr
operator|->
name|save_buffer_size
decl_stmt|;
name|png_uint_32
name|skip_length
init|=
name|png_ptr
operator|->
name|skip_length
decl_stmt|;
comment|/* We want the smaller of 'skip_length' and 'save_buffer_size', but        * they are of different types and we don't know which variable has the        * fewest bits.  Carefully select the smaller and cast it to the type of        * the larger - this cannot overflow.  Do not cast in the following test        * - it will break on either 16 or 64 bit platforms.        */
if|if
condition|(
name|skip_length
operator|<
name|save_size
condition|)
name|save_size
operator|=
operator|(
name|png_size_t
operator|)
name|skip_length
expr_stmt|;
else|else
name|skip_length
operator|=
operator|(
name|png_uint_32
operator|)
name|save_size
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|skip_length
operator|-=
name|skip_length
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|skip_length
operator|&&
name|png_ptr
operator|->
name|current_buffer_size
condition|)
block|{
name|png_size_t
name|save_size
init|=
name|png_ptr
operator|->
name|current_buffer_size
decl_stmt|;
name|png_uint_32
name|skip_length
init|=
name|png_ptr
operator|->
name|skip_length
decl_stmt|;
comment|/* We want the smaller of 'skip_length' and 'current_buffer_size', here,        * the same problem exists as above and the same solution.        */
if|if
condition|(
name|skip_length
operator|<
name|save_size
condition|)
name|save_size
operator|=
operator|(
name|png_size_t
operator|)
name|skip_length
expr_stmt|;
else|else
name|skip_length
operator|=
operator|(
name|png_uint_32
operator|)
name|save_size
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|skip_length
operator|-=
name|skip_length
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|png_ptr
operator|->
name|skip_length
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
literal|4
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_CHUNK_MODE
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
name|PNGCBAPI
DECL|function|png_push_fill_buffer
name|png_push_fill_buffer
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_bytep
name|ptr
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|ptr
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
condition|)
block|{
name|png_size_t
name|save_size
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|png_ptr
operator|->
name|save_buffer_size
condition|)
name|save_size
operator|=
name|length
expr_stmt|;
else|else
name|save_size
operator|=
name|png_ptr
operator|->
name|save_buffer_size
expr_stmt|;
name|png_memcpy
argument_list|(
name|ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|length
operator|-=
name|save_size
expr_stmt|;
name|ptr
operator|+=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|&&
name|png_ptr
operator|->
name|current_buffer_size
condition|)
block|{
name|png_size_t
name|save_size
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|png_ptr
operator|->
name|current_buffer_size
condition|)
name|save_size
operator|=
name|length
expr_stmt|;
else|else
name|save_size
operator|=
name|png_ptr
operator|->
name|current_buffer_size
expr_stmt|;
name|png_memcpy
argument_list|(
name|ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_save_buffer
name|png_push_save_buffer
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_ptr
operator|!=
name|png_ptr
operator|->
name|save_buffer
condition|)
block|{
name|png_size_t
name|i
decl_stmt|,
name|istop
decl_stmt|;
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|istop
operator|=
name|png_ptr
operator|->
name|save_buffer_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|png_ptr
operator|->
name|save_buffer_ptr
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|save_buffer
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
operator|*
name|sp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|+
name|png_ptr
operator|->
name|current_buffer_size
operator|>
name|png_ptr
operator|->
name|save_buffer_max
condition|)
block|{
name|png_size_t
name|new_max
decl_stmt|;
name|png_bytep
name|old_buffer
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer_size
operator|>
name|PNG_SIZE_MAX
operator|-
operator|(
name|png_ptr
operator|->
name|current_buffer_size
operator|+
literal|256
operator|)
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Potential overflow of save_buffer"
argument_list|)
expr_stmt|;
block|}
name|new_max
operator|=
name|png_ptr
operator|->
name|save_buffer_size
operator|+
name|png_ptr
operator|->
name|current_buffer_size
operator|+
literal|256
expr_stmt|;
name|old_buffer
operator|=
name|png_ptr
operator|->
name|save_buffer
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_size_t
operator|)
name|new_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|save_buffer
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_buffer
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory for save_buffer"
argument_list|)
expr_stmt|;
block|}
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|save_buffer
argument_list|,
name|old_buffer
argument_list|,
name|png_ptr
operator|->
name|save_buffer_size
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_buffer
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_max
operator|=
name|new_max
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|current_buffer_size
condition|)
block|{
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|save_buffer
operator|+
name|png_ptr
operator|->
name|save_buffer_size
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_size
operator|+=
name|png_ptr
operator|->
name|current_buffer_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|=
literal|0
expr_stmt|;
block|}
name|png_ptr
operator|->
name|save_buffer_ptr
operator|=
name|png_ptr
operator|->
name|save_buffer
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_restore_buffer
name|png_push_restore_buffer
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|buffer_length
parameter_list|)
block|{
name|png_ptr
operator|->
name|current_buffer
operator|=
name|buffer
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|=
name|buffer_length
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|=
name|buffer_length
operator|+
name|png_ptr
operator|->
name|save_buffer_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_ptr
operator|=
name|png_ptr
operator|->
name|current_buffer
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_IDAT
name|png_push_read_IDAT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|PNG_IDAT
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_CHUNK_HEADER
operator|)
condition|)
block|{
name|png_byte
name|chunk_length
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
literal|8
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_fill_buffer
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|push_length
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|chunk_length
argument_list|)
expr_stmt|;
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
if|if
condition|(
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IDAT
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_CHUNK_MODE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_FINISHED
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough compressed data"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|idat_size
operator|=
name|png_ptr
operator|->
name|push_length
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|idat_size
operator|&&
name|png_ptr
operator|->
name|save_buffer_size
condition|)
block|{
name|png_size_t
name|save_size
init|=
name|png_ptr
operator|->
name|save_buffer_size
decl_stmt|;
name|png_uint_32
name|idat_size
init|=
name|png_ptr
operator|->
name|idat_size
decl_stmt|;
comment|/* We want the smaller of 'idat_size' and 'current_buffer_size', but they        * are of different types and we don't know which variable has the fewest        * bits.  Carefully select the smaller and cast it to the type of the        * larger - this cannot overflow.  Do not cast in the following test - it        * will break on either 16 or 64 bit platforms.        */
if|if
condition|(
name|idat_size
operator|<
name|save_size
condition|)
name|save_size
operator|=
operator|(
name|png_size_t
operator|)
name|idat_size
expr_stmt|;
else|else
name|idat_size
operator|=
operator|(
name|png_uint_32
operator|)
name|save_size
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_process_IDAT_data
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|save_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|-=
name|idat_size
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|save_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|idat_size
operator|&&
name|png_ptr
operator|->
name|current_buffer_size
condition|)
block|{
name|png_size_t
name|save_size
init|=
name|png_ptr
operator|->
name|current_buffer_size
decl_stmt|;
name|png_uint_32
name|idat_size
init|=
name|png_ptr
operator|->
name|idat_size
decl_stmt|;
comment|/* We want the smaller of 'idat_size' and 'current_buffer_size', but they        * are of different types and we don't know which variable has the fewest        * bits.  Carefully select the smaller and cast it to the type of the        * larger - this cannot overflow.        */
if|if
condition|(
name|idat_size
operator|<
name|save_size
condition|)
name|save_size
operator|=
operator|(
name|png_size_t
operator|)
name|idat_size
expr_stmt|;
else|else
name|idat_size
operator|=
operator|(
name|png_uint_32
operator|)
name|save_size
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_process_IDAT_data
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|current_buffer_ptr
argument_list|,
name|save_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|-=
name|idat_size
expr_stmt|;
name|png_ptr
operator|->
name|buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_size
operator|-=
name|save_size
expr_stmt|;
name|png_ptr
operator|->
name|current_buffer_ptr
operator|+=
name|save_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|png_ptr
operator|->
name|idat_size
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
literal|4
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator|&=
operator|~
name|PNG_HAVE_CHUNK_HEADER
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_process_IDAT_data
name|png_process_IDAT_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|buffer
parameter_list|,
name|png_size_t
name|buffer_length
parameter_list|)
block|{
comment|/* The caller checks for a non-zero buffer length. */
if|if
condition|(
operator|!
operator|(
name|buffer_length
operator|>
literal|0
operator|)
operator|||
name|buffer
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"No IDAT data (internal error)"
argument_list|)
expr_stmt|;
comment|/* This routine must process all the data it has been given     * before returning, calling the row callback as required to     * handle the uncompressed results.     */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|buffer
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|buffer_length
expr_stmt|;
comment|/* Keep going until the decompressed data is all processed     * or the stream marked as finished.     */
while|while
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|>
literal|0
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_FINISHED
operator|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* We have data for zlib, but we must check that zlib        * has someplace to put the results.  It doesn't matter        * if we don't expect any results -- it may be the input        * data is just the LZ end code.        */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|>
literal|0
operator|)
condition|)
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
block|}
comment|/* Using Z_SYNC_FLUSH here means that an unterminated        * LZ stream (a stream with a missing end code) can still        * be handled, otherwise (Z_NO_FLUSH) a future zlib        * implementation might defer output and therefore        * change the current behavior (see comments in inflate.c        * for why this doesn't happen at present with zlib 1.2.5).        */
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
comment|/* Check for any failure before proceeding. */
if|if
condition|(
name|ret
operator|!=
name|Z_OK
operator|&&
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
comment|/* Terminate the decompression. */
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_FINISHED
expr_stmt|;
comment|/* This may be a truncated stream (missing or           * damaged end code).  Treat that as a warning.           */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|>=
name|png_ptr
operator|->
name|num_rows
operator|||
name|png_ptr
operator|->
name|pass
operator|>
literal|6
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncated compressed data in IDAT"
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Decompression error in IDAT"
argument_list|)
expr_stmt|;
comment|/* Skip the check on unprocessed input */
return|return;
block|}
comment|/* Did inflate output any data? */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|!=
name|png_ptr
operator|->
name|row_buf
condition|)
block|{
comment|/* Is this unexpected data after the last row?           * If it is, artificially terminate the LZ output           * here.           */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|>=
name|png_ptr
operator|->
name|num_rows
operator|||
name|png_ptr
operator|->
name|pass
operator|>
literal|6
condition|)
block|{
comment|/* Extra data. */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compressed data in IDAT"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_FINISHED
expr_stmt|;
comment|/* Do no more processing; skip the unprocessed              * input check below.              */
return|return;
block|}
comment|/* Do we have a complete row? */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|==
literal|0
condition|)
name|png_push_process_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* And check for the end of the stream. */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_FINISHED
expr_stmt|;
block|}
comment|/* All the data should have been processed, if anything     * is left at this point we have bytes of IDAT data     * after the zlib end code.     */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|>
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compression data in IDAT"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_process_row
name|png_push_process_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_ptr
operator|->
name|row_info
operator|.
name|color_type
operator|=
name|png_ptr
operator|->
name|color_type
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|width
operator|=
name|png_ptr
operator|->
name|iwidth
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|channels
operator|=
name|png_ptr
operator|->
name|channels
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|bit_depth
operator|=
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
name|png_ptr
operator|->
name|row_info
operator|.
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|row_info
operator|.
name|width
argument_list|)
expr_stmt|;
name|png_read_filter_row
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|row_info
operator|)
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|prev_row
operator|+
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
name|png_ptr
operator|->
name|row_buf
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|||
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_STRIP_ALPHA
operator|)
condition|)
name|png_do_read_transformations
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Blow up interlaced rows to full size */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|6
condition|)
comment|/*       old interface (pre-1.0.9):          png_do_read_interlace(&(png_ptr->row_info),              png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);  */
name|png_do_read_interlace
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|png_ptr
operator|->
name|pass
condition|)
block|{
case|case
literal|0
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* Updates png_ptr->pass */
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|)
comment|/* Pass 1 might be empty */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|4
operator|&&
name|png_ptr
operator|->
name|height
operator|<=
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|6
operator|&&
name|png_ptr
operator|->
name|height
operator|<=
literal|4
condition|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|1
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|)
comment|/* Skip top 4 generated rows */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|)
comment|/* Pass 3 might be empty */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|3
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|)
comment|/* Skip top two generated rows */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|6
condition|)
comment|/* Pass 5 might be empty */
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|5
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|&&
name|png_ptr
operator|->
name|pass
operator|==
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|==
literal|6
condition|)
comment|/* Skip top generated row */
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
case|case
literal|6
case|:
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|!=
literal|6
condition|)
break|break;
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|png_push_have_row
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_read_push_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_push_finish_row
name|png_read_push_finish_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
name|PNG_CONST
name|int
name|FARDATA
name|png_pass_start
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
name|PNG_CONST
name|int
name|FARDATA
name|png_pass_inc
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
name|PNG_CONST
name|int
name|FARDATA
name|png_pass_ystart
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
name|PNG_CONST
name|int
name|FARDATA
name|png_pass_yinc
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
comment|/* Height of interlace block.  This is not currently used - if you need     * it, uncomment it here and in png.h    PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};    */
name|png_ptr
operator|->
name|row_number
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|<
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
name|png_ptr
operator|->
name|row_number
operator|=
literal|0
expr_stmt|;
name|png_memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|pass
operator|==
literal|1
operator|&&
name|png_ptr
operator|->
name|width
operator|<
literal|5
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|pass
operator|==
literal|3
operator|&&
name|png_ptr
operator|->
name|width
operator|<
literal|3
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|pass
operator|==
literal|5
operator|&&
name|png_ptr
operator|->
name|width
operator|<
literal|2
operator|)
condition|)
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>
literal|7
condition|)
name|png_ptr
operator|->
name|pass
operator|--
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>=
literal|7
condition|)
break|break;
name|png_ptr
operator|->
name|iwidth
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
condition|)
break|break;
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
block|}
do|while
condition|(
name|png_ptr
operator|->
name|iwidth
operator|==
literal|0
operator|||
name|png_ptr
operator|->
name|num_rows
operator|==
literal|0
condition|)
do|;
block|}
endif|#
directive|endif
comment|/* PNG_READ_INTERLACING_SUPPORTED */
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_handle_tEXt
name|png_push_handle_tEXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IEND
operator|)
condition|)
block|{
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
comment|/* To quiet some compiler warnings */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place tEXt"
argument_list|)
expr_stmt|;
comment|/*NOT REACHED*/
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
name|png_ptr
operator|->
name|skip_length
operator|=
literal|0
expr_stmt|;
comment|/* This may not be necessary */
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
comment|/* Can't hold entire string in memory */
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"tEXt chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|skip_length
operator|=
name|length
operator|-
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
name|length
operator|=
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
block|}
endif|#
directive|endif
name|png_ptr
operator|->
name|current_text
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|png_ptr
operator|->
name|current_text_ptr
operator|=
name|png_ptr
operator|->
name|current_text
expr_stmt|;
name|png_ptr
operator|->
name|current_text_size
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_ptr
operator|->
name|current_text_left
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_tEXt_MODE
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_tEXt
name|png_push_read_tEXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|&&
name|png_ptr
operator|->
name|current_text_left
condition|)
block|{
name|png_size_t
name|text_size
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
name|png_ptr
operator|->
name|current_text_left
condition|)
name|text_size
operator|=
name|png_ptr
operator|->
name|buffer_size
expr_stmt|;
else|else
name|text_size
operator|=
name|png_ptr
operator|->
name|current_text_left
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|current_text_ptr
argument_list|,
name|text_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text_left
operator|-=
name|text_size
expr_stmt|;
name|png_ptr
operator|->
name|current_text_ptr
operator|+=
name|text_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|current_text_left
operator|)
condition|)
block|{
name|png_textp
name|text_ptr
decl_stmt|;
name|png_charp
name|text
decl_stmt|;
name|png_charp
name|key
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
literal|4
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_crc_finish
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|png_ptr
operator|->
name|skip_length
condition|)
return|return;
endif|#
directive|endif
name|key
operator|=
name|png_ptr
operator|->
name|current_text
expr_stmt|;
for|for
control|(
name|text
operator|=
name|key
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
if|if
condition|(
name|text
operator|<
name|key
operator|+
name|png_ptr
operator|->
name|current_text_size
condition|)
name|text
operator|++
expr_stmt|;
name|text_ptr
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
expr_stmt|;
name|text_ptr
operator|->
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
name|text_ptr
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|text_ptr
operator|->
name|itxt_length
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|->
name|lang
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|lang_key
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to store text chunk"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_handle_zTXt
name|png_push_handle_zTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IEND
operator|)
condition|)
block|{
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
comment|/* To quiet some compiler warnings */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place zTXt"
argument_list|)
expr_stmt|;
comment|/*NOT REACHED*/
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
comment|/* We can't handle zTXt chunks> 64K, since we don't have enough space     * to be able to store the uncompressed data.  Actually, the threshold     * is probably around 32K, but it isn't as definite as 64K is.     */
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"zTXt chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|png_push_crc_skip
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|png_ptr
operator|->
name|current_text
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|png_ptr
operator|->
name|current_text_ptr
operator|=
name|png_ptr
operator|->
name|current_text
expr_stmt|;
name|png_ptr
operator|->
name|current_text_size
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_ptr
operator|->
name|current_text_left
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_zTXt_MODE
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_zTXt
name|png_push_read_zTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|&&
name|png_ptr
operator|->
name|current_text_left
condition|)
block|{
name|png_size_t
name|text_size
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
operator|(
name|png_uint_32
operator|)
name|png_ptr
operator|->
name|current_text_left
condition|)
name|text_size
operator|=
name|png_ptr
operator|->
name|buffer_size
expr_stmt|;
else|else
name|text_size
operator|=
name|png_ptr
operator|->
name|current_text_left
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|current_text_ptr
argument_list|,
name|text_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text_left
operator|-=
name|text_size
expr_stmt|;
name|png_ptr
operator|->
name|current_text_ptr
operator|+=
name|text_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|current_text_left
operator|)
condition|)
block|{
name|png_textp
name|text_ptr
decl_stmt|;
name|png_charp
name|text
decl_stmt|;
name|png_charp
name|key
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|png_size_t
name|text_size
decl_stmt|,
name|key_size
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
literal|4
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_crc_finish
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|key
operator|=
name|png_ptr
operator|->
name|current_text
expr_stmt|;
for|for
control|(
name|text
operator|=
name|key
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
comment|/* zTXt can't have zero text */
if|if
condition|(
name|text
operator|>=
name|key
operator|+
name|png_ptr
operator|->
name|current_text_size
condition|)
block|{
name|png_ptr
operator|->
name|current_text
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|text
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|text
operator|!=
name|PNG_TEXT_COMPRESSION_zTXt
condition|)
comment|/* Check compression byte */
block|{
name|png_ptr
operator|->
name|current_text
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|text
operator|++
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
operator|(
name|png_bytep
operator|)
name|text
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
call|(
name|uInt
call|)
argument_list|(
name|png_ptr
operator|->
name|current_text_size
operator|-
operator|(
name|text
operator|-
name|key
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|key_size
operator|=
name|text
operator|-
name|key
expr_stmt|;
name|text_size
operator|=
literal|0
expr_stmt|;
name|text
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|Z_STREAM_END
expr_stmt|;
while|while
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
condition|)
block|{
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
operator|&&
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|current_text
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
operator|||
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
block|{
name|text
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|+
name|key_size
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|text
operator|+
name|key_size
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|text
argument_list|,
name|key
argument_list|,
name|key_size
argument_list|)
expr_stmt|;
name|text_size
operator|=
name|key_size
operator|+
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
operator|*
operator|(
name|text
operator|+
name|text_size
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|png_charp
name|tmp
decl_stmt|;
name|tmp
operator|=
name|text
expr_stmt|;
name|text
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|text_size
operator|+
operator|(
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|text
argument_list|,
name|tmp
argument_list|,
name|text_size
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|text
operator|+
name|text_size
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
name|text_size
operator|+=
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
operator|*
operator|(
name|text
operator|+
name|text_size
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
break|break;
block|}
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|png_ptr
operator|->
name|current_text
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|current_text
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|text
expr_stmt|;
name|text
operator|+=
name|key_size
expr_stmt|;
name|text_ptr
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
expr_stmt|;
name|text_ptr
operator|->
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt
expr_stmt|;
name|text_ptr
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|text_ptr
operator|->
name|itxt_length
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|->
name|lang
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|lang_key
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to store text chunk"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_handle_iTXt
name|png_push_handle_iTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IEND
operator|)
condition|)
block|{
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
comment|/* To quiet some compiler warnings */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place iTXt"
argument_list|)
expr_stmt|;
comment|/*NOT REACHED*/
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
name|png_ptr
operator|->
name|skip_length
operator|=
literal|0
expr_stmt|;
comment|/* This may not be necessary */
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
comment|/* Can't hold entire string in memory */
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"iTXt chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|skip_length
operator|=
name|length
operator|-
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
name|length
operator|=
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
block|}
endif|#
directive|endif
name|png_ptr
operator|->
name|current_text
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|png_ptr
operator|->
name|current_text_ptr
operator|=
name|png_ptr
operator|->
name|current_text
expr_stmt|;
name|png_ptr
operator|->
name|current_text_size
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_ptr
operator|->
name|current_text_left
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_ptr
operator|->
name|process_mode
operator|=
name|PNG_READ_iTXt_MODE
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_read_iTXt
name|png_push_read_iTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|&&
name|png_ptr
operator|->
name|current_text_left
condition|)
block|{
name|png_size_t
name|text_size
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
name|png_ptr
operator|->
name|current_text_left
condition|)
name|text_size
operator|=
name|png_ptr
operator|->
name|buffer_size
expr_stmt|;
else|else
name|text_size
operator|=
name|png_ptr
operator|->
name|current_text_left
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|current_text_ptr
argument_list|,
name|text_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text_left
operator|-=
name|text_size
expr_stmt|;
name|png_ptr
operator|->
name|current_text_ptr
operator|+=
name|text_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|current_text_left
operator|)
condition|)
block|{
name|png_textp
name|text_ptr
decl_stmt|;
name|png_charp
name|key
decl_stmt|;
name|int
name|comp_flag
decl_stmt|;
name|png_charp
name|lang
decl_stmt|;
name|png_charp
name|lang_key
decl_stmt|;
name|png_charp
name|text
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|buffer_size
operator|<
literal|4
condition|)
block|{
name|png_push_save_buffer
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_push_crc_finish
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|png_ptr
operator|->
name|skip_length
condition|)
return|return;
endif|#
directive|endif
name|key
operator|=
name|png_ptr
operator|->
name|current_text
expr_stmt|;
for|for
control|(
name|lang
operator|=
name|key
init|;
operator|*
name|lang
condition|;
name|lang
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
if|if
condition|(
name|lang
operator|<
name|key
operator|+
name|png_ptr
operator|->
name|current_text_size
operator|-
literal|3
condition|)
name|lang
operator|++
expr_stmt|;
name|comp_flag
operator|=
operator|*
name|lang
operator|++
expr_stmt|;
name|lang
operator|++
expr_stmt|;
comment|/* Skip comp_type, always zero */
for|for
control|(
name|lang_key
operator|=
name|lang
init|;
operator|*
name|lang_key
condition|;
name|lang_key
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
name|lang_key
operator|++
expr_stmt|;
comment|/* Skip NUL separator */
name|text
operator|=
name|lang_key
expr_stmt|;
if|if
condition|(
name|lang_key
operator|<
name|key
operator|+
name|png_ptr
operator|->
name|current_text_size
operator|-
literal|1
condition|)
block|{
for|for
control|(
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
block|}
if|if
condition|(
name|text
operator|<
name|key
operator|+
name|png_ptr
operator|->
name|current_text_size
condition|)
name|text
operator|++
expr_stmt|;
name|text_ptr
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
expr_stmt|;
name|text_ptr
operator|->
name|compression
operator|=
name|comp_flag
operator|+
literal|2
expr_stmt|;
name|text_ptr
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|text_ptr
operator|->
name|lang
operator|=
name|lang
expr_stmt|;
name|text_ptr
operator|->
name|lang_key
operator|=
name|lang_key
expr_stmt|;
name|text_ptr
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|text_ptr
operator|->
name|text_length
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|->
name|itxt_length
operator|=
name|png_strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|current_text
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to store iTXt chunk"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This function is called when we haven't found a handler for this  * chunk.  If there isn't a problem with the chunk itself (ie a bad chunk  * name or a critical chunk), the chunk is (currently) silently ignored.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_handle_unknown
name|png_push_handle_unknown
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_uint_32
name|skip
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|!=
name|PNG_HANDLE_CHUNK_ALWAYS
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
operator|&&
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|==
name|NULL
endif|#
directive|endif
condition|)
endif|#
directive|endif
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown critical chunk"
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
comment|/* To quiet some compiler warnings */
block|}
ifdef|#
directive|ifdef
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_KEEP_UNKNOWN_CHUNKS
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|skip
operator|=
name|length
operator|-
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
name|length
operator|=
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
block|}
endif|#
directive|endif
name|png_memcpy
argument_list|(
operator|(
name|png_charp
operator|)
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
argument_list|,
operator|(
name|png_charp
operator|)
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_sizeof
argument_list|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
index|[
name|png_sizeof
argument_list|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|size
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|!=
name|NULL
condition|)
block|{
comment|/* Callback to user unknown chunk handler */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"error in user chunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
condition|)
if|if
condition|(
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|!=
name|PNG_HANDLE_CHUNK_ALWAYS
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown critical chunk"
argument_list|)
expr_stmt|;
name|png_set_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|png_set_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|skip
operator|=
name|length
expr_stmt|;
name|png_push_crc_skip
argument_list|(
name|png_ptr
argument_list|,
name|skip
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_have_info
name|png_push_have_info
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|info_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|info_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|info_ptr
operator|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_have_end
name|png_push_have_end
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|end_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|end_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|info_ptr
operator|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_push_have_row
name|png_push_have_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|row_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|row_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
name|row
operator|,
name|png_ptr
operator|->
name|row_number
operator|,
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|pass
operator|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_progressive_combine_row
name|png_progressive_combine_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|old_row
parameter_list|,
name|png_const_bytep
name|new_row
parameter_list|)
block|{
name|PNG_CONST
name|int
name|FARDATA
name|png_pass_dsp_mask
index|[
literal|7
index|]
init|=
block|{
literal|0xff
block|,
literal|0x0f
block|,
literal|0xff
block|,
literal|0x33
block|,
literal|0xff
block|,
literal|0x55
block|,
literal|0xff
block|}
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|new_row
operator|!=
name|NULL
condition|)
comment|/* new_row must == png_ptr->row_buf here. */
name|png_combine_row
argument_list|(
name|png_ptr
argument_list|,
name|old_row
argument_list|,
name|png_pass_dsp_mask
index|[
name|png_ptr
operator|->
name|pass
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_set_progressive_read_fn
name|png_set_progressive_read_fn
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_voidp
name|progressive_ptr
parameter_list|,
name|png_progressive_info_ptr
name|info_fn
parameter_list|,
name|png_progressive_row_ptr
name|row_fn
parameter_list|,
name|png_progressive_end_ptr
name|end_fn
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|info_fn
operator|=
name|info_fn
expr_stmt|;
name|png_ptr
operator|->
name|row_fn
operator|=
name|row_fn
expr_stmt|;
name|png_ptr
operator|->
name|end_fn
operator|=
name|end_fn
expr_stmt|;
name|png_set_read_fn
argument_list|(
name|png_ptr
argument_list|,
name|progressive_ptr
argument_list|,
name|png_push_fill_buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|png_voidp
name|PNGAPI
DECL|function|png_get_progressive_ptr
name|png_get_progressive_ptr
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|png_ptr
operator|->
name|io_ptr
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_PROGRESSIVE_READ_SUPPORTED */
end_comment
end_unit
