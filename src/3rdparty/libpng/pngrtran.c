begin_unit
begin_comment
comment|/* pngrtran.c - transforms the data in a row for PNG readers  *  * Last changed in libpng 1.6.17 [March 26, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * This file contains functions optionally called by an application  * in order to tell libpng how to handle data when reading a PNG.  * Transformations that are used in both reading and writing are  * in pngtrans.c.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* Set the action on getting a CRC error for an ancillary or critical chunk. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_crc_action
name|png_set_crc_action
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|crit_action
parameter_list|,
name|int
name|ancil_action
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_crc_action"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* Tell libpng how we react to CRC errors in critical chunks */
switch|switch
condition|(
name|crit_action
condition|)
block|{
case|case
name|PNG_CRC_NO_CHANGE
case|:
comment|/* Leave setting as is */
break|break;
case|case
name|PNG_CRC_WARN_USE
case|:
comment|/* Warn/use data */
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_CRC_CRITICAL_MASK
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_CRC_CRITICAL_USE
expr_stmt|;
break|break;
case|case
name|PNG_CRC_QUIET_USE
case|:
comment|/* Quiet/use data */
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_CRC_CRITICAL_MASK
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_CRC_CRITICAL_USE
operator||
name|PNG_FLAG_CRC_CRITICAL_IGNORE
expr_stmt|;
break|break;
case|case
name|PNG_CRC_WARN_DISCARD
case|:
comment|/* Not a valid action for critical data */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't discard critical data on CRC error"
argument_list|)
expr_stmt|;
case|case
name|PNG_CRC_ERROR_QUIT
case|:
comment|/* Error/quit */
case|case
name|PNG_CRC_DEFAULT
case|:
default|default:
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_CRC_CRITICAL_MASK
expr_stmt|;
break|break;
block|}
comment|/* Tell libpng how we react to CRC errors in ancillary chunks */
switch|switch
condition|(
name|ancil_action
condition|)
block|{
case|case
name|PNG_CRC_NO_CHANGE
case|:
comment|/* Leave setting as is */
break|break;
case|case
name|PNG_CRC_WARN_USE
case|:
comment|/* Warn/use data */
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_CRC_ANCILLARY_MASK
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_CRC_ANCILLARY_USE
expr_stmt|;
break|break;
case|case
name|PNG_CRC_QUIET_USE
case|:
comment|/* Quiet/use data */
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_CRC_ANCILLARY_MASK
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_CRC_ANCILLARY_USE
operator||
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
expr_stmt|;
break|break;
case|case
name|PNG_CRC_ERROR_QUIT
case|:
comment|/* Error/quit */
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_CRC_ANCILLARY_MASK
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
expr_stmt|;
break|break;
case|case
name|PNG_CRC_WARN_DISCARD
case|:
comment|/* Warn/discard data */
case|case
name|PNG_CRC_DEFAULT
case|:
default|default:
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_CRC_ANCILLARY_MASK
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
end_ifdef
begin_comment
comment|/* Is it OK to set a transformation now?  Only if png_start_read_image or  * png_read_update_info have not been called.  It is not necessary for the IHDR  * to have been read in all cases; the need_IHDR parameter allows for this  * check too.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_rtran_ok
name|png_rtran_ok
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|need_IHDR
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
operator|!=
literal|0
condition|)
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid after png_start_read_image or png_read_update_info"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|need_IHDR
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid before the PNG header has been read"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Turn on failure to initialize correctly for all transforms. */
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_DETECT_UNINITIALIZED
expr_stmt|;
return|return
literal|1
return|;
comment|/* Ok */
block|}
block|}
return|return
literal|0
return|;
comment|/* no png_error possible! */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
end_ifdef
begin_comment
comment|/* Handle alpha and tRNS via a background color */
end_comment
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_background_fixed
name|png_set_background_fixed
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_color_16p
name|background_color
parameter_list|,
name|int
name|background_gamma_code
parameter_list|,
name|int
name|need_expand
parameter_list|,
name|png_fixed_point
name|background_gamma
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_background_fixed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
name|background_color
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|background_gamma_code
operator|==
name|PNG_BACKGROUND_GAMMA_UNKNOWN
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Application must supply a known background gamma"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_COMPOSE
operator||
name|PNG_STRIP_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|=
operator|*
name|background_color
expr_stmt|;
name|png_ptr
operator|->
name|background_gamma
operator|=
name|background_gamma
expr_stmt|;
name|png_ptr
operator|->
name|background_gamma_type
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|background_gamma_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_expand
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_BACKGROUND_EXPAND
expr_stmt|;
else|else
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_BACKGROUND_EXPAND
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_background
name|png_set_background
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_color_16p
name|background_color
parameter_list|,
name|int
name|background_gamma_code
parameter_list|,
name|int
name|need_expand
parameter_list|,
name|double
name|background_gamma
parameter_list|)
block|{
name|png_set_background_fixed
argument_list|(
name|png_ptr
argument_list|,
name|background_color
argument_list|,
name|background_gamma_code
argument_list|,
name|need_expand
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|background_gamma
argument_list|,
literal|"png_set_background"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_BACKGROUND */
end_comment
begin_comment
comment|/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the  * one that pngrtran does first (scale) happens.  This is necessary to allow the  * TRANSFORM and API behavior to be somewhat consistent, and it's simpler.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_scale_16
name|png_set_scale_16
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_scale_16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_SCALE_16_TO_8
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
end_ifdef
begin_comment
comment|/* Chop 16-bit depth files to 8-bit depth */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_strip_16
name|png_set_strip_16
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_strip_16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_16_TO_8
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_strip_alpha
name|png_set_strip_alpha
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_strip_alpha"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_STRIP_ALPHA
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
end_if
begin_function
specifier|static
name|png_fixed_point
DECL|function|translate_gamma_flags
name|translate_gamma_flags
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|output_gamma
parameter_list|,
name|int
name|is_screen
parameter_list|)
block|{
comment|/* Check for flag values.  The main reason for having the old Mac value as a     * flag is that it is pretty near impossible to work out what the correct     * value is from Apple documentation - a working Mac system is needed to     * discover the value!     */
if|if
condition|(
name|output_gamma
operator|==
name|PNG_DEFAULT_sRGB
operator|||
name|output_gamma
operator|==
name|PNG_FP_1
operator|/
name|PNG_DEFAULT_sRGB
condition|)
block|{
comment|/* If there is no sRGB support this just sets the gamma to the standard        * sRGB value.  (This is a side effect of using this function!)        */
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ASSUME_sRGB
expr_stmt|;
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
endif|#
directive|endif
if|if
condition|(
name|is_screen
operator|!=
literal|0
condition|)
name|output_gamma
operator|=
name|PNG_GAMMA_sRGB
expr_stmt|;
else|else
name|output_gamma
operator|=
name|PNG_GAMMA_sRGB_INVERSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|output_gamma
operator|==
name|PNG_GAMMA_MAC_18
operator|||
name|output_gamma
operator|==
name|PNG_FP_1
operator|/
name|PNG_GAMMA_MAC_18
condition|)
block|{
if|if
condition|(
name|is_screen
operator|!=
literal|0
condition|)
name|output_gamma
operator|=
name|PNG_GAMMA_MAC_OLD
expr_stmt|;
else|else
name|output_gamma
operator|=
name|PNG_GAMMA_MAC_INVERSE
expr_stmt|;
block|}
return|return
name|output_gamma
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
specifier|static
name|png_fixed_point
DECL|function|convert_gamma_value
name|convert_gamma_value
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|double
name|output_gamma
parameter_list|)
block|{
comment|/* The following silently ignores cases where fixed point (times 100,000)     * gamma values are passed to the floating point API.  This is safe and it     * means the fixed point constants work just fine with the floating point     * API.  The alternative would just lead to undetected errors and spurious     * bug reports.  Negative values fail inside the _fixed API unless they     * correspond to the flag values.     */
if|if
condition|(
name|output_gamma
operator|>
literal|0
operator|&&
name|output_gamma
operator|<
literal|128
condition|)
name|output_gamma
operator|*=
name|PNG_FP_1
expr_stmt|;
comment|/* This preserves -1 and -2 exactly: */
name|output_gamma
operator|=
name|floor
argument_list|(
name|output_gamma
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_gamma
operator|>
name|PNG_FP_MAX
operator|||
name|output_gamma
operator|<
name|PNG_FP_MIN
condition|)
name|png_fixed_error
argument_list|(
name|png_ptr
argument_list|,
literal|"gamma value"
argument_list|)
expr_stmt|;
return|return
operator|(
name|png_fixed_point
operator|)
name|output_gamma
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_ALPHA_MODE || READ_GAMMA */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_ALPHA_MODE_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_alpha_mode_fixed
name|png_set_alpha_mode_fixed
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|mode
parameter_list|,
name|png_fixed_point
name|output_gamma
parameter_list|)
block|{
name|int
name|compose
init|=
literal|0
decl_stmt|;
name|png_fixed_point
name|file_gamma
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_alpha_mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|output_gamma
operator|=
name|translate_gamma_flags
argument_list|(
name|png_ptr
argument_list|,
name|output_gamma
argument_list|,
literal|1
comment|/*screen*/
argument_list|)
expr_stmt|;
comment|/* Validate the value to ensure it is in a reasonable range. The value     * is expected to be 1 or greater, but this range test allows for some     * viewing correction values.  The intent is to weed out users of this API     * who use the inverse of the gamma value accidentally!  Since some of these     * values are reasonable this may have to be changed.     */
if|if
condition|(
name|output_gamma
operator|<
literal|70000
operator|||
name|output_gamma
operator|>
literal|300000
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"output gamma out of expected range"
argument_list|)
expr_stmt|;
comment|/* The default file gamma is the inverse of the output gamma; the output     * gamma may be changed below so get the file value first:     */
name|file_gamma
operator|=
name|png_reciprocal
argument_list|(
name|output_gamma
argument_list|)
expr_stmt|;
comment|/* There are really 8 possibilities here, composed of any combination     * of:     *     *    premultiply the color channels     *    do not encode non-opaque pixels     *    encode the alpha as well as the color channels     *     * The differences disappear if the input/output ('screen') gamma is 1.0,     * because then the encoding is a no-op and there is only the choice of     * premultiplying the color channels or not.     *     * png_set_alpha_mode and png_set_background interact because both use     * png_compose to do the work.  Calling both is only useful when     * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along     * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.     */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|PNG_ALPHA_PNG
case|:
comment|/* default: png standard */
comment|/* No compose, but it may be set by png_set_background! */
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
break|break;
case|case
name|PNG_ALPHA_ASSOCIATED
case|:
comment|/* color channels premultiplied */
name|compose
operator|=
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
comment|/* The output is linear: */
name|output_gamma
operator|=
name|PNG_FP_1
expr_stmt|;
break|break;
case|case
name|PNG_ALPHA_OPTIMIZED
case|:
comment|/* associated, non-opaque pixels linear */
name|compose
operator|=
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
comment|/* output_gamma records the encoding of opaque pixels! */
break|break;
case|case
name|PNG_ALPHA_BROKEN
case|:
comment|/* associated, non-linear, alpha encoded */
name|compose
operator|=
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid alpha mode"
argument_list|)
expr_stmt|;
block|}
comment|/* Only set the default gamma if the file gamma has not been set (this has     * the side effect that the gamma in a second call to png_set_alpha_mode will     * be ignored.)     */
if|if
condition|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|=
name|file_gamma
expr_stmt|;
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_HAVE_GAMMA
expr_stmt|;
block|}
comment|/* But always set the output gamma: */
name|png_ptr
operator|->
name|screen_gamma
operator|=
name|output_gamma
expr_stmt|;
comment|/* Finally, if pre-multiplying, set the background fields to achieve the     * desired result.     */
if|if
condition|(
name|compose
operator|!=
literal|0
condition|)
block|{
comment|/* And obtain alpha pre-multiplication by composing on black: */
name|memset
argument_list|(
operator|&
name|png_ptr
operator|->
name|background
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
name|png_ptr
operator|->
name|background
operator|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background_gamma
operator|=
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
expr_stmt|;
comment|/* just in case */
name|png_ptr
operator|->
name|background_gamma_type
operator|=
name|PNG_BACKGROUND_GAMMA_FILE
expr_stmt|;
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_BACKGROUND_EXPAND
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"conflicting calls to set alpha mode and background"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_COMPOSE
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_alpha_mode
name|png_set_alpha_mode
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|mode
parameter_list|,
name|double
name|output_gamma
parameter_list|)
block|{
name|png_set_alpha_mode_fixed
argument_list|(
name|png_ptr
argument_list|,
name|mode
argument_list|,
name|convert_gamma_value
argument_list|(
name|png_ptr
argument_list|,
name|output_gamma
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
end_ifdef
begin_comment
comment|/* Dither file to 8-bit.  Supply a palette, the current number  * of elements in the palette, the maximum number of elements  * allowed, and a histogram if possible.  If the current number  * of colors is greater than the maximum number, the palette will be  * modified to fit in the maximum number.  "full_quantize" indicates  * whether we need a quantizing cube set up for RGB images, or if we  * simply are reducing the number of colors in a paletted image.  */
end_comment
begin_typedef
DECL|struct|png_dsort_struct
typedef|typedef
struct|struct
name|png_dsort_struct
block|{
DECL|member|next
name|struct
name|png_dsort_struct
modifier|*
name|next
decl_stmt|;
DECL|member|left
name|png_byte
name|left
decl_stmt|;
DECL|member|right
name|png_byte
name|right
decl_stmt|;
block|}
DECL|typedef|png_dsort
name|png_dsort
typedef|;
end_typedef
begin_typedef
DECL|typedef|png_dsortp
typedef|typedef
name|png_dsort
modifier|*
name|png_dsortp
typedef|;
end_typedef
begin_typedef
DECL|typedef|png_dsortpp
typedef|typedef
name|png_dsort
modifier|*
modifier|*
name|png_dsortpp
typedef|;
end_typedef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_quantize
name|png_set_quantize
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_colorp
name|palette
parameter_list|,
name|int
name|num_palette
parameter_list|,
name|int
name|maximum_colors
parameter_list|,
name|png_const_uint_16p
name|histogram
parameter_list|,
name|int
name|full_quantize
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_quantize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_QUANTIZE
expr_stmt|;
if|if
condition|(
name|full_quantize
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|png_ptr
operator|->
name|quantize_index
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_palette
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
control|)
name|png_ptr
operator|->
name|quantize_index
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
block|}
if|if
condition|(
name|num_palette
operator|>
name|maximum_colors
condition|)
block|{
if|if
condition|(
name|histogram
operator|!=
name|NULL
condition|)
block|{
comment|/* This is easy enough, just throw out the least used colors.           * Perhaps not the best solution, but good enough.           */
name|int
name|i
decl_stmt|;
comment|/* Initialize an array to sort colors */
name|png_ptr
operator|->
name|quantize_sort
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_palette
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the quantize_sort array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
control|)
name|png_ptr
operator|->
name|quantize_sort
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
comment|/* Find the least used palette entries by starting a           * bubble sort, and running it until we have sorted           * out enough colors.  Note that we don't care about           * sorting all the colors, just finding which are           * least used.           */
for|for
control|(
name|i
operator|=
name|num_palette
operator|-
literal|1
init|;
name|i
operator|>=
name|maximum_colors
condition|;
name|i
operator|--
control|)
block|{
name|int
name|done
decl_stmt|;
comment|/* To stop early if the list is pre-sorted */
name|int
name|j
decl_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|histogram
index|[
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
index|]
index|]
operator|<
name|histogram
index|[
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
operator|+
literal|1
index|]
index|]
condition|)
block|{
name|png_byte
name|t
decl_stmt|;
name|t
operator|=
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
index|]
expr_stmt|;
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
index|]
operator|=
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|t
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* Swap the palette around, and set up a table, if necessary */
if|if
condition|(
name|full_quantize
operator|!=
literal|0
condition|)
block|{
name|int
name|j
init|=
name|num_palette
decl_stmt|;
comment|/* Put all the useful colors within the max, but don't              * move the others.              */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maximum_colors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|quantize_sort
index|[
name|i
index|]
operator|>=
name|maximum_colors
condition|)
block|{
do|do
name|j
operator|--
expr_stmt|;
do|while
condition|(
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
index|]
operator|>=
name|maximum_colors
condition|)
do|;
name|palette
index|[
name|i
index|]
operator|=
name|palette
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|j
init|=
name|num_palette
decl_stmt|;
comment|/* Move all the used colors inside the max limit, and              * develop a translation table.              */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maximum_colors
condition|;
name|i
operator|++
control|)
block|{
comment|/* Only move the colors we need to */
if|if
condition|(
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|quantize_sort
index|[
name|i
index|]
operator|>=
name|maximum_colors
condition|)
block|{
name|png_color
name|tmp_color
decl_stmt|;
do|do
name|j
operator|--
expr_stmt|;
do|while
condition|(
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|quantize_sort
index|[
name|j
index|]
operator|>=
name|maximum_colors
condition|)
do|;
name|tmp_color
operator|=
name|palette
index|[
name|j
index|]
expr_stmt|;
name|palette
index|[
name|j
index|]
operator|=
name|palette
index|[
name|i
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|=
name|tmp_color
expr_stmt|;
comment|/* Indicate where the color went */
name|png_ptr
operator|->
name|quantize_index
index|[
name|j
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
name|png_ptr
operator|->
name|quantize_index
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|j
expr_stmt|;
block|}
block|}
comment|/* Find closest color for those colors we are not using */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|quantize_index
index|[
name|i
index|]
operator|>=
name|maximum_colors
condition|)
block|{
name|int
name|min_d
decl_stmt|,
name|k
decl_stmt|,
name|min_k
decl_stmt|,
name|d_index
decl_stmt|;
comment|/* Find the closest color to one we threw out */
name|d_index
operator|=
name|png_ptr
operator|->
name|quantize_index
index|[
name|i
index|]
expr_stmt|;
name|min_d
operator|=
name|PNG_COLOR_DIST
argument_list|(
name|palette
index|[
name|d_index
index|]
argument_list|,
name|palette
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
operator|,
name|min_k
operator|=
literal|0
init|;
name|k
operator|<
name|maximum_colors
condition|;
name|k
operator|++
control|)
block|{
name|int
name|d
decl_stmt|;
name|d
operator|=
name|PNG_COLOR_DIST
argument_list|(
name|palette
index|[
name|d_index
index|]
argument_list|,
name|palette
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|min_d
condition|)
block|{
name|min_d
operator|=
name|d
expr_stmt|;
name|min_k
operator|=
name|k
expr_stmt|;
block|}
block|}
comment|/* Point to closest color */
name|png_ptr
operator|->
name|quantize_index
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|min_k
expr_stmt|;
block|}
block|}
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|quantize_sort
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|quantize_sort
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* This is much harder to do simply (and quickly).  Perhaps           * we need to go through a median cut routine, but those           * don't always behave themselves with only a few colors           * as input.  So we will just find the closest two colors,           * and throw out one of them (chosen somewhat randomly).           * [We don't understand this at all, so if someone wants to           *  work on improving it, be our guest - AED, GRP]           */
name|int
name|i
decl_stmt|;
name|int
name|max_d
decl_stmt|;
name|int
name|num_new_palette
decl_stmt|;
name|png_dsortp
name|t
decl_stmt|;
name|png_dsortpp
name|hash
decl_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize palette index arrays */
name|png_ptr
operator|->
name|index_to_palette
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_palette
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|palette_to_index
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_palette
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the sort array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
control|)
block|{
name|png_ptr
operator|->
name|index_to_palette
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
name|png_ptr
operator|->
name|palette_to_index
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
block|}
name|hash
operator|=
operator|(
name|png_dsortpp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
literal|769
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_dsortp
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|num_new_palette
operator|=
name|num_palette
expr_stmt|;
comment|/* Initial wild guess at how far apart the farthest pixel           * pair we will be eliminating will be.  Larger           * numbers mean more areas will be allocated, Smaller           * numbers run the risk of not saving enough data, and           * having to do this all over again.           *           * I have not done extensive checking on this number.           */
name|max_d
operator|=
literal|96
expr_stmt|;
while|while
condition|(
name|num_new_palette
operator|>
name|maximum_colors
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_new_palette
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|num_new_palette
condition|;
name|j
operator|++
control|)
block|{
name|int
name|d
decl_stmt|;
name|d
operator|=
name|PNG_COLOR_DIST
argument_list|(
name|palette
index|[
name|i
index|]
argument_list|,
name|palette
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<=
name|max_d
condition|)
block|{
name|t
operator|=
operator|(
name|png_dsortp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|png_dsort
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
break|break;
name|t
operator|->
name|next
operator|=
name|hash
index|[
name|d
index|]
expr_stmt|;
name|t
operator|->
name|left
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
name|t
operator|->
name|right
operator|=
operator|(
name|png_byte
operator|)
name|j
expr_stmt|;
name|hash
index|[
name|d
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_d
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hash
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|png_dsortp
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hash
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|index_to_palette
index|[
name|p
operator|->
name|left
index|]
operator|<
name|num_new_palette
operator|&&
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|index_to_palette
index|[
name|p
operator|->
name|right
index|]
operator|<
name|num_new_palette
condition|)
block|{
name|int
name|j
decl_stmt|,
name|next_j
decl_stmt|;
if|if
condition|(
name|num_new_palette
operator|&
literal|0x01
condition|)
block|{
name|j
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|next_j
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|next_j
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
name|num_new_palette
operator|--
expr_stmt|;
name|palette
index|[
name|png_ptr
operator|->
name|index_to_palette
index|[
name|j
index|]
index|]
operator|=
name|palette
index|[
name|num_new_palette
index|]
expr_stmt|;
if|if
condition|(
name|full_quantize
operator|==
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_palette
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|quantize_index
index|[
name|k
index|]
operator|==
name|png_ptr
operator|->
name|index_to_palette
index|[
name|j
index|]
condition|)
name|png_ptr
operator|->
name|quantize_index
index|[
name|k
index|]
operator|=
name|png_ptr
operator|->
name|index_to_palette
index|[
name|next_j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|quantize_index
index|[
name|k
index|]
operator|==
name|num_new_palette
condition|)
name|png_ptr
operator|->
name|quantize_index
index|[
name|k
index|]
operator|=
name|png_ptr
operator|->
name|index_to_palette
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|png_ptr
operator|->
name|index_to_palette
index|[
name|png_ptr
operator|->
name|palette_to_index
index|[
name|num_new_palette
index|]
index|]
operator|=
name|png_ptr
operator|->
name|index_to_palette
index|[
name|j
index|]
expr_stmt|;
name|png_ptr
operator|->
name|palette_to_index
index|[
name|png_ptr
operator|->
name|index_to_palette
index|[
name|j
index|]
index|]
operator|=
name|png_ptr
operator|->
name|palette_to_index
index|[
name|num_new_palette
index|]
expr_stmt|;
name|png_ptr
operator|->
name|index_to_palette
index|[
name|j
index|]
operator|=
operator|(
name|png_byte
operator|)
name|num_new_palette
expr_stmt|;
name|png_ptr
operator|->
name|palette_to_index
index|[
name|num_new_palette
index|]
operator|=
operator|(
name|png_byte
operator|)
name|j
expr_stmt|;
block|}
if|if
condition|(
name|num_new_palette
operator|<=
name|maximum_colors
condition|)
break|break;
block|}
if|if
condition|(
name|num_new_palette
operator|<=
name|maximum_colors
condition|)
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|769
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hash
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|png_dsortp
name|p
init|=
name|hash
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|t
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
expr_stmt|;
block|}
block|}
name|hash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|max_d
operator|+=
literal|96
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|palette_to_index
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|index_to_palette
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|palette_to_index
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|index_to_palette
operator|=
name|NULL
expr_stmt|;
block|}
name|num_palette
operator|=
name|maximum_colors
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|palette
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|palette
operator|=
name|palette
expr_stmt|;
block|}
name|png_ptr
operator|->
name|num_palette
operator|=
operator|(
name|png_uint_16
operator|)
name|num_palette
expr_stmt|;
if|if
condition|(
name|full_quantize
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|png_bytep
name|distance
decl_stmt|;
name|int
name|total_bits
init|=
name|PNG_QUANTIZE_RED_BITS
operator|+
name|PNG_QUANTIZE_GREEN_BITS
operator|+
name|PNG_QUANTIZE_BLUE_BITS
decl_stmt|;
name|int
name|num_red
init|=
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_RED_BITS
operator|)
decl_stmt|;
name|int
name|num_green
init|=
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_GREEN_BITS
operator|)
decl_stmt|;
name|int
name|num_blue
init|=
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_BLUE_BITS
operator|)
decl_stmt|;
name|png_size_t
name|num_entries
init|=
operator|(
operator|(
name|png_size_t
operator|)
literal|1
operator|<<
name|total_bits
operator|)
decl_stmt|;
name|png_ptr
operator|->
name|palette_lookup
operator|=
operator|(
name|png_bytep
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_entries
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|distance
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_entries
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|distance
argument_list|,
literal|0xff
argument_list|,
name|num_entries
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_byte
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ir
decl_stmt|,
name|ig
decl_stmt|,
name|ib
decl_stmt|;
name|int
name|r
init|=
operator|(
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_RED_BITS
operator|)
operator|)
decl_stmt|;
name|int
name|g
init|=
operator|(
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_GREEN_BITS
operator|)
operator|)
decl_stmt|;
name|int
name|b
init|=
operator|(
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|ir
operator|=
literal|0
init|;
name|ir
operator|<
name|num_red
condition|;
name|ir
operator|++
control|)
block|{
comment|/* int dr = abs(ir - r); */
name|int
name|dr
init|=
operator|(
operator|(
name|ir
operator|>
name|r
operator|)
condition|?
name|ir
operator|-
name|r
else|:
name|r
operator|-
name|ir
operator|)
decl_stmt|;
name|int
name|index_r
init|=
operator|(
name|ir
operator|<<
operator|(
name|PNG_QUANTIZE_BLUE_BITS
operator|+
name|PNG_QUANTIZE_GREEN_BITS
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|ig
operator|=
literal|0
init|;
name|ig
operator|<
name|num_green
condition|;
name|ig
operator|++
control|)
block|{
comment|/* int dg = abs(ig - g); */
name|int
name|dg
init|=
operator|(
operator|(
name|ig
operator|>
name|g
operator|)
condition|?
name|ig
operator|-
name|g
else|:
name|g
operator|-
name|ig
operator|)
decl_stmt|;
name|int
name|dt
init|=
name|dr
operator|+
name|dg
decl_stmt|;
name|int
name|dm
init|=
operator|(
operator|(
name|dr
operator|>
name|dg
operator|)
condition|?
name|dr
else|:
name|dg
operator|)
decl_stmt|;
name|int
name|index_g
init|=
name|index_r
operator||
operator|(
name|ig
operator|<<
name|PNG_QUANTIZE_BLUE_BITS
operator|)
decl_stmt|;
for|for
control|(
name|ib
operator|=
literal|0
init|;
name|ib
operator|<
name|num_blue
condition|;
name|ib
operator|++
control|)
block|{
name|int
name|d_index
init|=
name|index_g
operator||
name|ib
decl_stmt|;
comment|/* int db = abs(ib - b); */
name|int
name|db
init|=
operator|(
operator|(
name|ib
operator|>
name|b
operator|)
condition|?
name|ib
operator|-
name|b
else|:
name|b
operator|-
name|ib
operator|)
decl_stmt|;
name|int
name|dmax
init|=
operator|(
operator|(
name|dm
operator|>
name|db
operator|)
condition|?
name|dm
else|:
name|db
operator|)
decl_stmt|;
name|int
name|d
init|=
name|dmax
operator|+
name|dt
operator|+
name|db
decl_stmt|;
if|if
condition|(
name|d
operator|<
operator|(
name|int
operator|)
name|distance
index|[
name|d_index
index|]
condition|)
block|{
name|distance
index|[
name|d_index
index|]
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
name|png_ptr
operator|->
name|palette_lookup
index|[
name|d_index
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|distance
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_QUANTIZE */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_gamma_fixed
name|png_set_gamma_fixed
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|scrn_gamma
parameter_list|,
name|png_fixed_point
name|file_gamma
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_gamma_fixed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* New in libpng-1.5.4 - reserve particular negative values as flags. */
name|scrn_gamma
operator|=
name|translate_gamma_flags
argument_list|(
name|png_ptr
argument_list|,
name|scrn_gamma
argument_list|,
literal|1
comment|/*screen*/
argument_list|)
expr_stmt|;
name|file_gamma
operator|=
name|translate_gamma_flags
argument_list|(
name|png_ptr
argument_list|,
name|file_gamma
argument_list|,
literal|0
comment|/*file*/
argument_list|)
expr_stmt|;
comment|/* Checking the gamma values for being>0 was added in 1.5.4 along with the     * premultiplied alpha support; this actually hides an undocumented feature     * of the previous implementation which allowed gamma processing to be     * disabled in background handling.  There is no evidence (so far) that this     * was being used; however, png_set_background itself accepted and must still     * accept '0' for the gamma value it takes, because it isn't always used.     *     * Since this is an API change (albeit a very minor one that removes an     * undocumented API feature) the following checks were only enabled in     * libpng-1.6.0.     */
if|if
condition|(
name|file_gamma
operator|<=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid file gamma in png_set_gamma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrn_gamma
operator|<=
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid screen gamma in png_set_gamma"
argument_list|)
expr_stmt|;
comment|/* Set the gamma values unconditionally - this overrides the value in the PNG     * file if a gAMA chunk was present.  png_set_alpha_mode provides a     * different, easier, way to default the file gamma.     */
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|=
name|file_gamma
expr_stmt|;
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_HAVE_GAMMA
expr_stmt|;
name|png_ptr
operator|->
name|screen_gamma
operator|=
name|scrn_gamma
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_gamma
name|png_set_gamma
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|double
name|scrn_gamma
parameter_list|,
name|double
name|file_gamma
parameter_list|)
block|{
name|png_set_gamma_fixed
argument_list|(
name|png_ptr
argument_list|,
name|convert_gamma_value
argument_list|(
name|png_ptr
argument_list|,
name|scrn_gamma
argument_list|)
argument_list|,
name|convert_gamma_value
argument_list|(
name|png_ptr
argument_list|,
name|file_gamma
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
end_ifdef
begin_comment
comment|/* Expand paletted images to RGB, expand grayscale images of  * less than 8-bit depth to 8-bit depth, and expand tRNS chunks  * to alpha channels.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_expand
name|png_set_expand
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_expand"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
operator|(
name|PNG_EXPAND
operator||
name|PNG_EXPAND_tRNS
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* GRR 19990627:  the following three functions currently are identical  *  to png_set_expand().  However, it is entirely reasonable that someone  *  might wish to expand an indexed image to RGB but *not* expand a single,  *  fully transparent palette entry to a full alpha channel--perhaps instead  *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace  *  the transparent color with a particular RGB value, or drop tRNS entirely.  *  IOW, a future version of the library may make the transformations flag  *  a bit more fine-grained, with separate bits for each of these three  *  functions.  *  *  More to the point, these functions make it obvious what libpng will be  *  doing, whereas "expand" can (and does) mean any number of things.  *  *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified  *  to expand only the sample depth but not to expand the tRNS to alpha  *  and its name was changed to png_set_expand_gray_1_2_4_to_8().  */
end_comment
begin_comment
comment|/* Expand paletted images to RGB. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_palette_to_rgb
name|png_set_palette_to_rgb
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_palette_to_rgb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
operator|(
name|PNG_EXPAND
operator||
name|PNG_EXPAND_tRNS
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Expand grayscale images of less than 8-bit depth to 8 bits. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_expand_gray_1_2_4_to_8
name|png_set_expand_gray_1_2_4_to_8
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_expand_gray_1_2_4_to_8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_EXPAND
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Expand tRNS chunks to alpha channels. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_tRNS_to_alpha
name|png_set_tRNS_to_alpha
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_tRNS_to_alpha"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
operator|(
name|PNG_EXPAND
operator||
name|PNG_EXPAND_tRNS
operator|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_EXPAND */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
end_ifdef
begin_comment
comment|/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise  * it may not work correctly.)  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_expand_16
name|png_set_expand_16
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_expand_16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|png_ptr
operator|->
name|transformations
operator||=
operator|(
name|PNG_EXPAND_16
operator||
name|PNG_EXPAND
operator||
name|PNG_EXPAND_tRNS
operator|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_gray_to_rgb
name|png_set_gray_to_rgb
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_gray_to_rgb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Because rgb must be 8 bits or more: */
name|png_set_expand_gray_1_2_4_to_8
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_GRAY_TO_RGB
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGFAPI
DECL|function|png_set_rgb_to_gray_fixed
name|png_set_rgb_to_gray_fixed
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|error_action
parameter_list|,
name|png_fixed_point
name|red
parameter_list|,
name|png_fixed_point
name|green
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_rgb_to_gray"
argument_list|)
expr_stmt|;
comment|/* Need the IHDR here because of the check on color_type below. */
comment|/* TODO: fix this */
if|if
condition|(
name|png_rtran_ok
argument_list|(
name|png_ptr
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|error_action
condition|)
block|{
case|case
name|PNG_ERROR_ACTION_NONE
case|:
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_RGB_TO_GRAY
expr_stmt|;
break|break;
case|case
name|PNG_ERROR_ACTION_WARN
case|:
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_RGB_TO_GRAY_WARN
expr_stmt|;
break|break;
case|case
name|PNG_ERROR_ACTION_ERROR
case|:
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_RGB_TO_GRAY_ERR
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid error action to rgb_to_gray"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_EXPAND
expr_stmt|;
else|#
directive|else
block|{
comment|/* Make this an error in 1.6 because otherwise the application may assume        * that it just worked and get a memory overwrite.        */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED"
argument_list|)
expr_stmt|;
comment|/* png_ptr->transformations&= ~PNG_RGB_TO_GRAY; */
block|}
endif|#
directive|endif
block|{
if|if
condition|(
name|red
operator|>=
literal|0
operator|&&
name|green
operator|>=
literal|0
operator|&&
name|red
operator|+
name|green
operator|<=
name|PNG_FP_1
condition|)
block|{
name|png_uint_16
name|red_int
decl_stmt|,
name|green_int
decl_stmt|;
comment|/* NOTE: this calculation does not round, but this behavior is retained           * for consistency; the inaccuracy is very small.  The code here always           * overwrites the coefficients, regardless of whether they have been           * defaulted or set already.           */
name|red_int
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
name|png_uint_32
operator|)
name|red
operator|*
literal|32768
operator|)
operator|/
literal|100000
argument_list|)
expr_stmt|;
name|green_int
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
name|png_uint_32
operator|)
name|green
operator|*
literal|32768
operator|)
operator|/
literal|100000
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|rgb_to_gray_red_coeff
operator|=
name|red_int
expr_stmt|;
name|png_ptr
operator|->
name|rgb_to_gray_green_coeff
operator|=
name|green_int
expr_stmt|;
name|png_ptr
operator|->
name|rgb_to_gray_coefficients_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|red
operator|>=
literal|0
operator|&&
name|green
operator|>=
literal|0
condition|)
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"ignoring out of range rgb_to_gray coefficients"
argument_list|)
expr_stmt|;
comment|/* Use the defaults, from the cHRM chunk if set, else the historical           * values which are close to the sRGB/HDTV/ITU-Rec 709 values.  See           * png_do_rgb_to_gray for more discussion of the values.  In this case           * the coefficients are not marked as 'set' and are not overwritten if           * something has already provided a default.           */
if|if
condition|(
name|png_ptr
operator|->
name|rgb_to_gray_red_coeff
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|rgb_to_gray_green_coeff
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|rgb_to_gray_red_coeff
operator|=
literal|6968
expr_stmt|;
name|png_ptr
operator|->
name|rgb_to_gray_green_coeff
operator|=
literal|23434
expr_stmt|;
comment|/* png_ptr->rgb_to_gray_blue_coeff  = 2366; */
block|}
block|}
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* Convert a RGB image to a grayscale of the same width.  This allows us,  * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_set_rgb_to_gray
name|png_set_rgb_to_gray
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|error_action
parameter_list|,
name|double
name|red
parameter_list|,
name|double
name|green
parameter_list|)
block|{
name|png_set_rgb_to_gray_fixed
argument_list|(
name|png_ptr
argument_list|,
name|error_action
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|red
argument_list|,
literal|"rgb to gray red coefficient"
argument_list|)
argument_list|,
name|png_fixed
argument_list|(
name|png_ptr
argument_list|,
name|green
argument_list|,
literal|"rgb to gray green coefficient"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* RGB_TO_GRAY */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_USER_TRANSFORM_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_USER_TRANSFORM_SUPPORTED
argument_list|)
end_if
begin_function
name|void
name|PNGAPI
DECL|function|png_set_read_user_transform_fn
name|png_set_read_user_transform_fn
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_user_transform_ptr
name|read_user_transform_fn
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_read_user_transform_fn"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_USER_TRANSFORM
expr_stmt|;
name|png_ptr
operator|->
name|read_user_transform_fn
operator|=
name|read_user_transform_fn
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* In the case of gamma transformations only do transformations on images where  * the [file] gamma and screen_gamma are not close reciprocals, otherwise it  * slows things down slightly, and also needlessly introduces small errors.  */
end_comment
begin_function
specifier|static
name|int
comment|/* PRIVATE */
DECL|function|png_gamma_threshold
name|png_gamma_threshold
parameter_list|(
name|png_fixed_point
name|screen_gamma
parameter_list|,
name|png_fixed_point
name|file_gamma
parameter_list|)
block|{
comment|/* PNG_GAMMA_THRESHOLD is the threshold for performing gamma     * correction as a difference of the overall transform from 1.0     *     * We want to compare the threshold with s*f - 1, if we get     * overflow here it is because of wacky gamma values so we     * turn on processing anyway.     */
name|png_fixed_point
name|gtest
decl_stmt|;
return|return
operator|!
name|png_muldiv
argument_list|(
operator|&
name|gtest
argument_list|,
name|screen_gamma
argument_list|,
name|file_gamma
argument_list|,
name|PNG_FP_1
argument_list|)
operator|||
name|png_gamma_significant
argument_list|(
name|gtest
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Initialize everything needed for the read.  This includes modifying  * the palette.  */
end_comment
begin_comment
comment|/* For the moment 'png_init_palette_transformations' and  * 'png_init_rgb_transformations' only do some flag canceling optimizations.  * The intent is that these two routines should have palette or rgb operations  * extracted from 'png_init_read_transformations'.  */
end_comment
begin_function
specifier|static
name|void
comment|/* PRIVATE */
DECL|function|png_init_palette_transformations
name|png_init_palette_transformations
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Called to handle the (input) palette case.  In png_do_read_transformations     * the first step is to expand the palette if requested, so this code must     * take care to only make changes that are invariant with respect to the     * palette expansion, or only do them if there is no expansion.     *     * STRIP_ALPHA has already been handled in the caller (by setting num_trans     * to 0.)     */
name|int
name|input_has_alpha
init|=
literal|0
decl_stmt|;
name|int
name|input_has_transparency
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Ignore if all the entries are opaque (unlikely!) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|png_ptr
operator|->
name|num_trans
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
operator|==
literal|255
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|input_has_transparency
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|input_has_transparency
operator|=
literal|1
expr_stmt|;
name|input_has_alpha
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If no alpha we can optimize. */
if|if
condition|(
name|input_has_alpha
operator|==
literal|0
condition|)
block|{
comment|/* Any alpha means background and associative alpha processing is        * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA        * and ENCODE_ALPHA are irrelevant.        */
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
if|if
condition|(
name|input_has_transparency
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
operator|(
name|PNG_COMPOSE
operator||
name|PNG_BACKGROUND_EXPAND
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_EXPAND_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
comment|/* png_set_background handling - deals with the complexity of whether the     * background color is in the file format or the screen format in the case     * where an 'expand' will happen.     */
comment|/* The following code cannot be entered in the alpha pre-multiplication case     * because PNG_BACKGROUND_EXPAND is cancelled below.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BACKGROUND_EXPAND
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|!=
literal|0
condition|)
block|{
block|{
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|palette
index|[
name|png_ptr
operator|->
name|background
operator|.
name|index
index|]
operator|.
name|red
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|palette
index|[
name|png_ptr
operator|->
name|background
operator|.
name|index
index|]
operator|.
name|green
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|palette
index|[
name|png_ptr
operator|->
name|background
operator|.
name|index
index|]
operator|.
name|blue
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_ALPHA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_tRNS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Invert the alpha channel (in tRNS) unless the pixels are                * going to be expanded, in which case leave it for later                */
name|int
name|i
decl_stmt|,
name|istop
init|=
name|png_ptr
operator|->
name|num_trans
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* READ_INVERT_ALPHA */
block|}
block|}
comment|/* background expand and (therefore) no alpha association. */
endif|#
directive|endif
comment|/* READ_EXPAND&& READ_BACKGROUND */
block|}
end_function
begin_function
specifier|static
name|void
comment|/* PRIVATE */
DECL|function|png_init_rgb_transformations
name|png_init_rgb_transformations
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Added to libpng-1.5.4: check the color type to determine whether there     * is any alpha or transparency in the image and simply cancel the     * background and alpha mode stuff if there isn't.     */
name|int
name|input_has_alpha
init|=
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|input_has_transparency
init|=
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
decl_stmt|;
comment|/* If no alpha we can optimize. */
if|if
condition|(
name|input_has_alpha
operator|==
literal|0
condition|)
block|{
comment|/* Any alpha means background and associative alpha processing is        * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA        * and ENCODE_ALPHA are irrelevant.        */
ifdef|#
directive|ifdef
name|PNG_READ_ALPHA_MODE_SUPPORTED
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|input_has_transparency
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
operator|(
name|PNG_COMPOSE
operator||
name|PNG_BACKGROUND_EXPAND
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_EXPAND_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
comment|/* png_set_background handling - deals with the complexity of whether the     * background color is in the file format or the screen format in the case     * where an 'expand' will happen.     */
comment|/* The following code cannot be entered in the alpha pre-multiplication case     * because PNG_BACKGROUND_EXPAND is cancelled below.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BACKGROUND_EXPAND
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
condition|)
comment|/* i.e., GRAY or GRAY_ALPHA */
block|{
block|{
comment|/* Expand background and tRNS chunks */
name|int
name|gray
init|=
name|png_ptr
operator|->
name|background
operator|.
name|gray
decl_stmt|;
name|int
name|trans_gray
init|=
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
decl_stmt|;
switch|switch
condition|(
name|png_ptr
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
name|gray
operator|*=
literal|0xff
expr_stmt|;
name|trans_gray
operator|*=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|gray
operator|*=
literal|0x55
expr_stmt|;
name|trans_gray
operator|*=
literal|0x55
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|gray
operator|*=
literal|0x11
expr_stmt|;
name|trans_gray
operator|*=
literal|0x11
expr_stmt|;
break|break;
default|default:
case|case
literal|8
case|:
comment|/* FALL THROUGH (Already 8 bits) */
case|case
literal|16
case|:
comment|/* Already a full 16 bits */
break|break;
block|}
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|gray
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_tRNS
operator|)
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|trans_color
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|trans_color
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|trans_color
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|trans_gray
expr_stmt|;
block|}
block|}
block|}
comment|/* background expand and (therefore) no alpha association. */
endif|#
directive|endif
comment|/* READ_EXPAND&& READ_BACKGROUND */
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_init_read_transformations
name|png_init_read_transformations
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_init_read_transformations"
argument_list|)
expr_stmt|;
comment|/* This internal function is called from png_read_start_row in pngrutil.c     * and it is called before the 'rowbytes' calculation is done, so the code     * in here can change or update the transformations flags.     *     * First do updates that do not depend on the details of the PNG image data     * being processed.     */
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds     * png_set_alpha_mode and this is another source for a default file gamma so     * the test needs to be performed later - here.  In addition prior to 1.5.4     * the tests were repeated for the PALETTE color type here - this is no     * longer necessary (and doesn't seem to have been necessary before.)     */
block|{
comment|/* The following temporary indicates if overall gamma correction is        * required.        */
name|int
name|gamma_correction
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|!=
literal|0
condition|)
comment|/* has been set */
block|{
if|if
condition|(
name|png_ptr
operator|->
name|screen_gamma
operator|!=
literal|0
condition|)
comment|/* screen set too */
name|gamma_correction
operator|=
name|png_gamma_threshold
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
expr_stmt|;
else|else
comment|/* Assume the output matches the input; a long time default behavior              * of libpng, although the standard has nothing to say about this.              */
name|png_ptr
operator|->
name|screen_gamma
operator|=
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|screen_gamma
operator|!=
literal|0
condition|)
comment|/* The converse - assume the file matches the screen, note that this           * perhaps undesireable default can (from 1.5.4) be changed by calling           * png_set_alpha_mode (even if the alpha handling mode isn't required           * or isn't changed from the default.)           */
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|=
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
expr_stmt|;
else|else
comment|/* neither are set */
comment|/* Just in case the following prevents any processing - file and screen           * are both assumed to be linear and there is no way to introduce a           * third gamma value other than png_set_background with 'UNIQUE', and,           * prior to 1.5.4           */
name|png_ptr
operator|->
name|screen_gamma
operator|=
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|=
name|PNG_FP_1
expr_stmt|;
comment|/* We have a gamma value now. */
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_HAVE_GAMMA
expr_stmt|;
comment|/* Now turn the gamma transformation on or off as appropriate.  Notice        * that PNG_GAMMA just refers to the file->screen correction.  Alpha        * composition may independently cause gamma correction because it needs        * linear data (e.g. if the file has a gAMA chunk but the screen gamma        * hasn't been specified.)  In any case this flag may get turned off in        * the code immediately below if the transform can be handled outside the        * row loop.        */
if|if
condition|(
name|gamma_correction
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_GAMMA
expr_stmt|;
else|else
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_GAMMA
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Certain transformations have the effect of preventing other     * transformations that happen afterward in png_do_read_transformations;     * resolve the interdependencies here.  From the code of     * png_do_read_transformations the order is:     *     *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)     *  2) PNG_STRIP_ALPHA (if no compose)     *  3) PNG_RGB_TO_GRAY     *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY     *  5) PNG_COMPOSE     *  6) PNG_GAMMA     *  7) PNG_STRIP_ALPHA (if compose)     *  8) PNG_ENCODE_ALPHA     *  9) PNG_SCALE_16_TO_8     * 10) PNG_16_TO_8     * 11) PNG_QUANTIZE (converts to palette)     * 12) PNG_EXPAND_16     * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY     * 14) PNG_INVERT_MONO     * 15) PNG_INVERT_ALPHA     * 16) PNG_SHIFT     * 17) PNG_PACK     * 18) PNG_BGR     * 19) PNG_PACKSWAP     * 20) PNG_FILLER (includes PNG_ADD_ALPHA)     * 21) PNG_SWAP_ALPHA     * 22) PNG_SWAP_BYTES     * 23) PNG_USER_TRANSFORM [must be last]     */
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_STRIP_ALPHA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Stripping the alpha channel happens immediately after the 'expand'        * transformations, before all other transformation, so it cancels out        * the alpha handling.  It has the side effect negating the effect of        * PNG_EXPAND_tRNS too:        */
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
operator|(
name|PNG_BACKGROUND_EXPAND
operator||
name|PNG_ENCODE_ALPHA
operator||
name|PNG_EXPAND_tRNS
operator|)
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
comment|/* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen        * so transparency information would remain just so long as it wasn't        * expanded.  This produces unexpected API changes if the set of things        * that do PNG_EXPAND_tRNS changes (perfectly possible given the        * documentation - which says ask for what you want, accept what you        * get.)  This makes the behavior consistent from 1.5.4:        */
name|png_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STRIP_ALPHA supported, no COMPOSE */
ifdef|#
directive|ifdef
name|PNG_READ_ALPHA_MODE_SUPPORTED
comment|/* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA     * settings will have no effect.     */
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_ENCODE_ALPHA
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_OPTIMIZE_ALPHA
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
comment|/* Make sure the coefficients for the rgb to gray conversion are set     * appropriately.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|!=
literal|0
condition|)
name|png_colorspace_set_rgb_coefficients
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_EXPAND_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
comment|/* Detect gray background and attempt to enable optimization for     * gray --> RGB case.     *     * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or     * RGB_ALPHA (in which case need_expand is superfluous anyway), the     * background color might actually be gray yet not be flagged as such.     * This is not a problem for the current code, which uses     * PNG_BACKGROUND_IS_GRAY only to decide when to do the     * png_do_gray_to_rgb() transformation.     *     * TODO: this code needs to be revised to avoid the complexity and     * interdependencies.  The color type of the background should be recorded in     * png_set_background, along with the bit depth, then the code has a record     * of exactly what color space the background is currently in.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BACKGROUND_EXPAND
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if        * the file was grayscale the background value is gray.        */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_BACKGROUND_IS_GRAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* PNG_COMPOSE: png_set_background was called with need_expand false,        * so the color is in the color space of the output or png_set_alpha_mode        * was called and the color is black.  Ignore RGB_TO_GRAY because that        * happens before GRAY_TO_RGB.        */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GRAY_TO_RGB
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|==
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|&&
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|==
name|png_ptr
operator|->
name|background
operator|.
name|blue
condition|)
block|{
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_BACKGROUND_IS_GRAY
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* READ_EXPAND&& READ_BACKGROUND */
endif|#
directive|endif
comment|/* READ_GRAY_TO_RGB */
comment|/* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations     * can be performed directly on the palette, and some (such as rgb to gray)     * can be optimized inside the palette.  This is particularly true of the     * composite (background and alpha) stuff, which can be pretty much all done     * in the palette even if the result is expanded to RGB or gray afterward.     *     * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and     * earlier and the palette stuff is actually handled on the first row.  This     * leads to the reported bug that the palette returned by png_get_PLTE is not     * updated.     */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|png_init_palette_transformations
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
else|else
name|png_init_rgb_transformations
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_READ_EXPAND_16_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_16
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BACKGROUND_EXPAND
operator|)
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|bit_depth
operator|!=
literal|16
condition|)
block|{
comment|/* TODO: fix this.  Because the expand_16 operation is after the compose        * handling the background color must be 8, not 16, bits deep, but the        * application will supply a 16-bit value so reduce it here.        *        * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at        * present, so that case is ok (until do_expand_16 is moved.)        *        * NOTE: this discards the low 16 bits of the user supplied background        * color, but until expand_16 works properly there is no choice!        */
DECL|macro|CHOP
define|#
directive|define
name|CHOP
parameter_list|(
name|x
parameter_list|)
value|(x)=((png_uint_16)PNG_DIV257(x))
name|CHOP
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
argument_list|)
expr_stmt|;
name|CHOP
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
argument_list|)
expr_stmt|;
name|CHOP
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
argument_list|)
expr_stmt|;
name|CHOP
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
argument_list|)
expr_stmt|;
DECL|macro|CHOP
undef|#
directive|undef
name|CHOP
block|}
endif|#
directive|endif
comment|/* READ_BACKGROUND&& READ_EXPAND_16 */
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
argument_list|)
operator|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_16_TO_8
operator||
name|PNG_SCALE_16_TO_8
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BACKGROUND_EXPAND
operator|)
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
comment|/* On the other hand, if a 16-bit file is to be reduced to 8-bits per        * component this will also happen after PNG_COMPOSE and so the background        * color must be pre-expanded here.        *        * TODO: fix this too.        */
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|*
literal|257
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|*
literal|257
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|*
literal|257
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|*
literal|257
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the     * background support (see the comments in scripts/pnglibconf.dfa), this     * allows pre-multiplication of the alpha channel to be implemented as     * compositing on black.  This is probably sub-optimal and has been done in     * 1.5.4 betas simply to enable external critique and testing (i.e. to     * implement the new API quickly, without lots of internal changes.)     */
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
comment|/* Includes ALPHA_MODE */
name|png_ptr
operator|->
name|background_1
operator|=
name|png_ptr
operator|->
name|background
expr_stmt|;
endif|#
directive|endif
comment|/* This needs to change - in the palette image case a whole set of tables are     * built when it would be quicker to just calculate the correct value for     * each palette entry directly.  Also, the test is too tricky - why check     * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that     * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the     * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction     * the gamma tables will not be built even if composition is required on a     * gamma encoded value.     *     * In 1.5.4 this is addressed below by an additional check on the individual     * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the     * tables.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GAMMA
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_gamma_significant
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
operator|!=
literal|0
operator|||
name|png_gamma_significant
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_gamma_significant
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
operator|!=
literal|0
operator|||
name|png_gamma_significant
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
operator|!=
literal|0
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
operator|||
operator|(
name|png_ptr
operator|->
name|background_gamma_type
operator|==
name|PNG_BACKGROUND_GAMMA_UNIQUE
operator|&&
name|png_gamma_significant
argument_list|(
name|png_ptr
operator|->
name|background_gamma
argument_list|)
operator|!=
literal|0
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|||
operator|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_ENCODE_ALPHA
operator|)
operator|!=
literal|0
operator|&&
name|png_gamma_significant
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|png_build_gamma_table
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Issue a warning about this combination: because RGB_TO_GRAY is           * optimized to do the gamma transform if present yet do_background has           * to do the same thing if both options are set a           * double-gamma-correction happens.  This is true in all versions of           * libpng to date.           */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"libpng does not support gamma+background+rgb_to_gray"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We don't get to here unless there is a tRNS chunk with non-opaque              * entries - see the checking code at the start of this function.              */
name|png_color
name|back
decl_stmt|,
name|back_1
decl_stmt|;
name|png_colorp
name|palette
init|=
name|png_ptr
operator|->
name|palette
decl_stmt|;
name|int
name|num_palette
init|=
name|png_ptr
operator|->
name|num_palette
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|background_gamma_type
operator|==
name|PNG_BACKGROUND_GAMMA_FILE
condition|)
block|{
name|back
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|png_ptr
operator|->
name|background
operator|.
name|red
index|]
expr_stmt|;
name|back
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|png_ptr
operator|->
name|background
operator|.
name|green
index|]
expr_stmt|;
name|back
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|png_ptr
operator|->
name|background
operator|.
name|blue
index|]
expr_stmt|;
name|back_1
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|png_ptr
operator|->
name|background
operator|.
name|red
index|]
expr_stmt|;
name|back_1
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|png_ptr
operator|->
name|background
operator|.
name|green
index|]
expr_stmt|;
name|back_1
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|png_ptr
operator|->
name|background
operator|.
name|blue
index|]
expr_stmt|;
block|}
else|else
block|{
name|png_fixed_point
name|g
decl_stmt|,
name|gs
decl_stmt|;
switch|switch
condition|(
name|png_ptr
operator|->
name|background_gamma_type
condition|)
block|{
case|case
name|PNG_BACKGROUND_GAMMA_SCREEN
case|:
name|g
operator|=
operator|(
name|png_ptr
operator|->
name|screen_gamma
operator|)
expr_stmt|;
name|gs
operator|=
name|PNG_FP_1
expr_stmt|;
break|break;
case|case
name|PNG_BACKGROUND_GAMMA_FILE
case|:
name|g
operator|=
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
expr_stmt|;
name|gs
operator|=
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_BACKGROUND_GAMMA_UNIQUE
case|:
name|g
operator|=
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|background_gamma
argument_list|)
expr_stmt|;
name|gs
operator|=
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|background_gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g
operator|=
name|PNG_FP_1
expr_stmt|;
comment|/* back_1 */
name|gs
operator|=
name|PNG_FP_1
expr_stmt|;
comment|/* back */
break|break;
block|}
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|gs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|back
operator|.
name|red
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
argument_list|,
name|gs
argument_list|)
expr_stmt|;
name|back
operator|.
name|green
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
argument_list|,
name|gs
argument_list|)
expr_stmt|;
name|back
operator|.
name|blue
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
argument_list|,
name|gs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|back
operator|.
name|red
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
name|back
operator|.
name|green
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|green
expr_stmt|;
name|back
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|blue
expr_stmt|;
block|}
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|g
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|back_1
operator|.
name|red
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|back_1
operator|.
name|green
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|back_1
operator|.
name|blue
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|back_1
operator|.
name|red
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
name|back_1
operator|.
name|green
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|green
expr_stmt|;
name|back_1
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|blue
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|num_trans
operator|&&
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
operator|!=
literal|0xff
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|palette
index|[
name|i
index|]
operator|=
name|back
expr_stmt|;
block|}
else|else
comment|/* if (png_ptr->trans_alpha[i] != 0xff) */
block|{
name|png_byte
name|v
decl_stmt|,
name|w
decl_stmt|;
name|v
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|palette
index|[
name|i
index|]
operator|.
name|red
index|]
expr_stmt|;
name|png_composite
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
argument_list|,
name|back_1
operator|.
name|red
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|gamma_from_1
index|[
name|w
index|]
expr_stmt|;
name|v
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|palette
index|[
name|i
index|]
operator|.
name|green
index|]
expr_stmt|;
name|png_composite
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
argument_list|,
name|back_1
operator|.
name|green
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|gamma_from_1
index|[
name|w
index|]
expr_stmt|;
name|v
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|palette
index|[
name|i
index|]
operator|.
name|blue
index|]
expr_stmt|;
name|png_composite
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
argument_list|,
name|back_1
operator|.
name|blue
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|gamma_from_1
index|[
name|w
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|palette
index|[
name|i
index|]
operator|.
name|red
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|palette
index|[
name|i
index|]
operator|.
name|green
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|palette
index|[
name|i
index|]
operator|.
name|blue
index|]
expr_stmt|;
block|}
block|}
comment|/* Prevent the transformations being done again.              *              * NOTE: this is highly dubious; it removes the transformations in              * place.  This seems inconsistent with the general treatment of the              * transformations elsewhere.              */
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
operator|(
name|PNG_COMPOSE
operator||
name|PNG_GAMMA
operator|)
expr_stmt|;
block|}
comment|/* color_type == PNG_COLOR_TYPE_PALETTE */
comment|/* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
else|else
comment|/* color_type != PNG_COLOR_TYPE_PALETTE */
block|{
name|int
name|gs_sig
decl_stmt|,
name|g_sig
decl_stmt|;
name|png_fixed_point
name|g
init|=
name|PNG_FP_1
decl_stmt|;
comment|/* Correction to linear */
name|png_fixed_point
name|gs
init|=
name|PNG_FP_1
decl_stmt|;
comment|/* Correction to screen */
switch|switch
condition|(
name|png_ptr
operator|->
name|background_gamma_type
condition|)
block|{
case|case
name|PNG_BACKGROUND_GAMMA_SCREEN
case|:
name|g
operator|=
name|png_ptr
operator|->
name|screen_gamma
expr_stmt|;
comment|/* gs = PNG_FP_1; */
break|break;
case|case
name|PNG_BACKGROUND_GAMMA_FILE
case|:
name|g
operator|=
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
expr_stmt|;
name|gs
operator|=
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_BACKGROUND_GAMMA_UNIQUE
case|:
name|g
operator|=
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|background_gamma
argument_list|)
expr_stmt|;
name|gs
operator|=
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|background_gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid background gamma type"
argument_list|)
expr_stmt|;
block|}
name|g_sig
operator|=
name|png_gamma_significant
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|gs_sig
operator|=
name|png_gamma_significant
argument_list|(
name|gs
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_sig
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|background_1
operator|.
name|gray
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|gray
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs_sig
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|gray
argument_list|,
name|gs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|!=
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|!=
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|!=
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|)
condition|)
block|{
comment|/* RGB or RGBA with color background */
if|if
condition|(
name|g_sig
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|background_1
operator|.
name|red
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|red
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background_1
operator|.
name|green
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|green
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background_1
operator|.
name|blue
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|blue
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gs_sig
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|red
argument_list|,
name|gs
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|green
argument_list|,
name|gs
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
name|png_gamma_correct
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|blue
argument_list|,
name|gs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
name|png_ptr
operator|->
name|background_1
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|background_1
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|background_1
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|background_1
operator|.
name|gray
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|gray
expr_stmt|;
block|}
comment|/* The background is now in screen gamma: */
name|png_ptr
operator|->
name|background_gamma_type
operator|=
name|PNG_BACKGROUND_GAMMA_SCREEN
expr_stmt|;
block|}
comment|/* color_type != PNG_COLOR_TYPE_PALETTE */
block|}
comment|/* png_ptr->transformations& PNG_BACKGROUND */
elseif|else
comment|/* Transformation does not include PNG_BACKGROUND */
endif|#
directive|endif
comment|/* READ_BACKGROUND */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
comment|/* RGB_TO_GRAY needs to have non-gamma-corrected values! */
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|==
literal|0
operator|||
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|==
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
name|png_colorp
name|palette
init|=
name|png_ptr
operator|->
name|palette
decl_stmt|;
name|int
name|num_palette
init|=
name|png_ptr
operator|->
name|num_palette
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* NOTE: there are other transformations that should probably be in           * here too.           */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
control|)
block|{
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|palette
index|[
name|i
index|]
operator|.
name|red
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|palette
index|[
name|i
index|]
operator|.
name|green
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|palette
index|[
name|i
index|]
operator|.
name|blue
index|]
expr_stmt|;
block|}
comment|/* Done the gamma correction. */
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_GAMMA
expr_stmt|;
block|}
comment|/* color_type == PALETTE&& !PNG_BACKGROUND transformation */
block|}
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
elseif|else
endif|#
directive|endif
endif|#
directive|endif
comment|/* READ_GAMMA */
ifdef|#
directive|ifdef
name|PNG_READ_BACKGROUND_SUPPORTED
comment|/* No GAMMA transformation (see the hanging else 4 lines above) */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|num_trans
decl_stmt|;
name|png_color
name|back
decl_stmt|;
name|png_colorp
name|palette
init|=
name|png_ptr
operator|->
name|palette
decl_stmt|;
name|back
operator|.
name|red
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
name|back
operator|.
name|green
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|green
expr_stmt|;
name|back
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|blue
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|palette
index|[
name|i
index|]
operator|=
name|back
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
operator|!=
literal|0xff
condition|)
block|{
comment|/* The png_composite() macro is defined in png.h */
name|png_composite
argument_list|(
name|palette
index|[
name|i
index|]
operator|.
name|red
argument_list|,
name|palette
index|[
name|i
index|]
operator|.
name|red
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
argument_list|,
name|back
operator|.
name|red
argument_list|)
expr_stmt|;
name|png_composite
argument_list|(
name|palette
index|[
name|i
index|]
operator|.
name|green
argument_list|,
name|palette
index|[
name|i
index|]
operator|.
name|green
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
argument_list|,
name|back
operator|.
name|green
argument_list|)
expr_stmt|;
name|png_composite
argument_list|(
name|palette
index|[
name|i
index|]
operator|.
name|blue
argument_list|,
name|palette
index|[
name|i
index|]
operator|.
name|blue
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
index|[
name|i
index|]
argument_list|,
name|back
operator|.
name|blue
argument_list|)
expr_stmt|;
block|}
block|}
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_COMPOSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* READ_BACKGROUND */
ifdef|#
directive|ifdef
name|PNG_READ_SHIFT_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SHIFT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|==
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
name|png_ptr
operator|->
name|num_palette
decl_stmt|;
name|int
name|shift
init|=
literal|8
operator|-
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
decl_stmt|;
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_SHIFT
expr_stmt|;
comment|/* significant bits can be in the range 1 to 7 for a meaninful result, if        * the number of significant bits is 0 then no shift is done (this is an        * error condition which is silently ignored.)        */
if|if
condition|(
name|shift
operator|>
literal|0
operator|&&
name|shift
operator|<
literal|8
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
operator|++
name|i
control|)
block|{
name|int
name|component
init|=
name|png_ptr
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|red
decl_stmt|;
name|component
operator|>>=
name|shift
expr_stmt|;
name|png_ptr
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
operator|(
name|png_byte
operator|)
name|component
expr_stmt|;
block|}
name|shift
operator|=
literal|8
operator|-
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
operator|&&
name|shift
operator|<
literal|8
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
operator|++
name|i
control|)
block|{
name|int
name|component
init|=
name|png_ptr
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|green
decl_stmt|;
name|component
operator|>>=
name|shift
expr_stmt|;
name|png_ptr
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
operator|(
name|png_byte
operator|)
name|component
expr_stmt|;
block|}
name|shift
operator|=
literal|8
operator|-
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
operator|&&
name|shift
operator|<
literal|8
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
operator|++
name|i
control|)
block|{
name|int
name|component
init|=
name|png_ptr
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|blue
decl_stmt|;
name|component
operator|>>=
name|shift
expr_stmt|;
name|png_ptr
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|component
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* READ_SHIFT */
block|}
end_function
begin_comment
comment|/* Modify the info structure to reflect the transformations.  The  * info should be updated so a PNG file could be written with it,  * assuming the transformations result in valid PNG data.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_transform_info
name|png_read_transform_info
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_transform_info"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
comment|/* This check must match what actually happens in           * png_do_expand_palette; if it ever checks the tRNS chunk to see if           * it is all opaque we must do the same (at present it does not.)           */
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
condition|)
name|info_ptr
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
else|else
name|info_ptr
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|info_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|palette
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Palette is NULL in indexed image"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_tRNS
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|color_type
operator||=
name|PNG_COLOR_MASK_ALPHA
expr_stmt|;
block|}
if|if
condition|(
name|info_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|info_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
comment|/* The following is almost certainly wrong unless the background value is in     * the screen space!     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|background
operator|=
name|png_ptr
operator|->
name|background
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),     * however it seems that the code in png_init_read_transformations, which has     * been called before this from png_read_update_info->png_read_start_row     * sometimes does the gamma transform and cancels the flag.     *     * TODO: this looks wrong; the info_ptr should end up with a gamma equal to     * the screen_gamma value.  The following probably results in weirdness if     * the info_ptr is used by the app after the rows have been read.     */
name|info_ptr
operator|->
name|colorspace
operator|.
name|gamma
operator|=
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SCALE_16_TO_8
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_16_TO_8
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* No 16 bit support: force chopping 16-bit input down to 8, in this case        * the app program can chose if both APIs are available by setting the        * correct scaling to use.        */
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
comment|/* For compatibility with previous versions use the strip method by           * default.  This code works because if PNG_SCALE_16_TO_8 is already           * set the code below will do that in preference to the chop.           */
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_16_TO_8
expr_stmt|;
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
name|png_ptr
operator|->
name|transformations
operator||=
name|PNG_SCALE_16_TO_8
expr_stmt|;
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
else|#
directive|else
name|CONFIGURATION
name|ERROR
range|:
name|you
name|must
name|enable
name|at
name|least
name|one
literal|16
name|to
literal|8
name|method
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* !READ_16BIT */
block|}
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GRAY_TO_RGB
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|color_type
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|info_ptr
operator|->
name|color_type
operator||
name|PNG_COLOR_MASK_COLOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|color_type
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|info_ptr
operator|->
name|color_type
operator|&
operator|~
name|PNG_COLOR_MASK_COLOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_QUANTIZE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|)
operator|||
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|)
operator|&&
name|png_ptr
operator|->
name|palette_lookup
operator|!=
literal|0
operator|&&
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|info_ptr
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_16
operator|)
operator|!=
literal|0
operator|&&
name|info_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
name|info_ptr
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_PACK_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|bit_depth
operator|<
literal|8
operator|)
condition|)
name|info_ptr
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|info_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
else|else
name|info_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_STRIP_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
name|info_ptr
operator|->
name|color_type
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|info_ptr
operator|->
name|color_type
operator|&
operator|~
name|PNG_COLOR_MASK_ALPHA
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|channels
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_FILLER_SUPPORTED
comment|/* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_FILLER
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|info_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|)
condition|)
block|{
name|info_ptr
operator|->
name|channels
operator|++
expr_stmt|;
comment|/* If adding a true alpha channel not just filler */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_ADD_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|color_type
operator||=
name|PNG_COLOR_MASK_ALPHA
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_USER_TRANSFORM_PTR_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_READ_USER_TRANSFORM_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_USER_TRANSFORM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|bit_depth
operator|<
name|png_ptr
operator|->
name|user_transform_depth
condition|)
name|info_ptr
operator|->
name|bit_depth
operator|=
name|png_ptr
operator|->
name|user_transform_depth
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|channels
operator|<
name|png_ptr
operator|->
name|user_transform_channels
condition|)
name|info_ptr
operator|->
name|channels
operator|=
name|png_ptr
operator|->
name|user_transform_channels
expr_stmt|;
block|}
endif|#
directive|endif
name|info_ptr
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|info_ptr
operator|->
name|channels
operator|*
name|info_ptr
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|info_ptr
operator|->
name|pixel_depth
argument_list|,
name|info_ptr
operator|->
name|width
argument_list|)
expr_stmt|;
comment|/* Adding in 1.5.4: cache the above value in png_struct so that we can later     * check in png_rowbytes that the user buffer won't get overwritten.  Note     * that the field is not always set - if png_read_update_info isn't called     * the application has to either not do any transforms or get the calculation     * right itself.     */
name|png_ptr
operator|->
name|info_rowbytes
operator|=
name|info_ptr
operator|->
name|rowbytes
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_READ_EXPAND_SUPPORTED
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
return|return;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_PACK_SUPPORTED
end_ifdef
begin_comment
comment|/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,  * without changing the actual values.  Thus, if you had a row with  * a bit depth of 1, you would end up with bytes that only contained  * the numbers 0 or 1.  If you would rather they contain 0 and 255, use  * png_do_shift() after this.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_unpack
name|png_do_unpack
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_unpack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|<
literal|8
condition|)
block|{
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
switch|switch
condition|(
name|row_info
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|3
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
decl_stmt|;
name|png_uint_32
name|shift
init|=
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|row_width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|7
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|++
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
decl_stmt|;
name|png_uint_32
name|shift
init|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|3
operator|-
operator|(
operator|(
name|row_width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|)
operator|<<
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x03
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|6
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|+=
literal|2
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
decl_stmt|;
name|png_uint_32
name|shift
init|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
operator|(
operator|(
name|row_width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|<<
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|4
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|=
literal|4
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
name|row_info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|8
operator|*
name|row_info
operator|->
name|channels
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
name|row_info
operator|->
name|channels
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SHIFT_SUPPORTED
end_ifdef
begin_comment
comment|/* Reverse the effects of png_do_shift.  This routine merely shifts the  * pixels back to their significant bits values.  Thus, if you have  * a row of bit depth 8, but only 5 are significant, this will shift  * the values back to 0 through 31.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_unshift
name|png_do_unshift
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_color_8p
name|sig_bits
parameter_list|)
block|{
name|int
name|color_type
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_unshift"
argument_list|)
expr_stmt|;
comment|/* The palette case has already been handled in the _init routine. */
name|color_type
operator|=
name|row_info
operator|->
name|color_type
expr_stmt|;
if|if
condition|(
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|int
name|shift
index|[
literal|4
index|]
decl_stmt|;
name|int
name|channels
init|=
literal|0
decl_stmt|;
name|int
name|bit_depth
init|=
name|row_info
operator|->
name|bit_depth
decl_stmt|;
if|if
condition|(
operator|(
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|shift
index|[
name|channels
operator|++
index|]
operator|=
name|bit_depth
operator|-
name|sig_bits
operator|->
name|red
expr_stmt|;
name|shift
index|[
name|channels
operator|++
index|]
operator|=
name|bit_depth
operator|-
name|sig_bits
operator|->
name|green
expr_stmt|;
name|shift
index|[
name|channels
operator|++
index|]
operator|=
name|bit_depth
operator|-
name|sig_bits
operator|->
name|blue
expr_stmt|;
block|}
else|else
block|{
name|shift
index|[
name|channels
operator|++
index|]
operator|=
name|bit_depth
operator|-
name|sig_bits
operator|->
name|gray
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
name|shift
index|[
name|channels
operator|++
index|]
operator|=
name|bit_depth
operator|-
name|sig_bits
operator|->
name|alpha
expr_stmt|;
block|}
block|{
name|int
name|c
decl_stmt|,
name|have_shift
decl_stmt|;
for|for
control|(
name|c
operator|=
name|have_shift
operator|=
literal|0
init|;
name|c
operator|<
name|channels
condition|;
operator|++
name|c
control|)
block|{
comment|/* A shift of more than the bit depth is an error condition but it              * gets ignored here.              */
if|if
condition|(
name|shift
index|[
name|c
index|]
operator|<=
literal|0
operator|||
name|shift
index|[
name|c
index|]
operator|>=
name|bit_depth
condition|)
name|shift
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|have_shift
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|have_shift
operator|==
literal|0
condition|)
return|return;
block|}
switch|switch
condition|(
name|bit_depth
condition|)
block|{
default|default:
comment|/* Must be 1bpp gray: should not be here! */
comment|/* NOTREACHED */
break|break;
case|case
literal|2
case|:
comment|/* Must be 2bpp gray */
comment|/* assert(channels == 1&& shift[0] == 1) */
block|{
name|png_bytep
name|bp
init|=
name|row
decl_stmt|;
name|png_bytep
name|bp_end
init|=
name|bp
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|bp_end
condition|)
block|{
name|int
name|b
init|=
operator|(
operator|*
name|bp
operator|>>
literal|1
operator|)
operator|&
literal|0x55
decl_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|b
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
comment|/* Must be 4bpp gray */
comment|/* assert(channels == 1) */
block|{
name|png_bytep
name|bp
init|=
name|row
decl_stmt|;
name|png_bytep
name|bp_end
init|=
name|bp
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|int
name|gray_shift
init|=
name|shift
index|[
literal|0
index|]
decl_stmt|;
name|int
name|mask
init|=
literal|0xf
operator|>>
name|gray_shift
decl_stmt|;
name|mask
operator||=
name|mask
operator|<<
literal|4
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|bp_end
condition|)
block|{
name|int
name|b
init|=
operator|(
operator|*
name|bp
operator|>>
name|gray_shift
operator|)
operator|&
name|mask
decl_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|b
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|8
case|:
comment|/* Single byte components, G, GA, RGB, RGBA */
block|{
name|png_bytep
name|bp
init|=
name|row
decl_stmt|;
name|png_bytep
name|bp_end
init|=
name|bp
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|int
name|channel
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|bp_end
condition|)
block|{
name|int
name|b
init|=
operator|*
name|bp
operator|>>
name|shift
index|[
name|channel
index|]
decl_stmt|;
if|if
condition|(
operator|++
name|channel
operator|>=
name|channels
condition|)
name|channel
operator|=
literal|0
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|b
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
case|case
literal|16
case|:
comment|/* Double byte components, G, GA, RGB, RGBA */
block|{
name|png_bytep
name|bp
init|=
name|row
decl_stmt|;
name|png_bytep
name|bp_end
init|=
name|bp
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|int
name|channel
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|bp_end
condition|)
block|{
name|int
name|value
init|=
operator|(
name|bp
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|bp
index|[
literal|1
index|]
decl_stmt|;
name|value
operator|>>=
name|shift
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|channel
operator|>=
name|channels
condition|)
name|channel
operator|=
literal|0
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|value
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
end_ifdef
begin_comment
comment|/* Scale rows of bit depth 16 down to 8 accurately */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_scale_16_to_8
name|png_do_scale_16_to_8
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_scale_16_to_8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|png_bytep
name|sp
init|=
name|row
decl_stmt|;
comment|/* source */
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
comment|/* destination */
name|png_bytep
name|ep
init|=
name|sp
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
comment|/* end+1 */
while|while
condition|(
name|sp
operator|<
name|ep
condition|)
block|{
comment|/* The input is an array of 16 bit components, these must be scaled to           * 8 bits each.  For a 16 bit value V the required value (from the PNG           * specification) is:           *           *    (V * 255) / 65535           *           * This reduces to round(V / 257), or floor((V + 128.5)/257)           *           * Represent V as the two byte value vhi.vlo.  Make a guess that the           * result is the top byte of V, vhi, then the correction to this value           * is:           *           *    error = floor(((V-vhi.vhi) + 128.5) / 257)           *          = floor(((vlo-vhi) + 128.5) / 257)           *           * This can be approximated using integer arithmetic (and a signed           * shift):           *           *    error = (vlo-vhi+128)>> 8;           *           * The approximate differs from the exact answer only when (vlo-vhi) is           * 128; it then gives a correction of +1 when the exact correction is           * 0.  This gives 128 errors.  The exact answer (correct for all 16 bit           * input values) is:           *           *    error = (vlo-vhi+128)*65535>> 24;           *           * An alternative arithmetic calculation which also gives no errors is:           *           *    (V * 255 + 32895)>> 16           */
name|png_int_32
name|tmp
init|=
operator|*
name|sp
operator|++
decl_stmt|;
comment|/* must be signed! */
name|tmp
operator|+=
operator|(
operator|(
operator|(
name|int
operator|)
operator|*
name|sp
operator|++
operator|-
name|tmp
operator|+
literal|128
operator|)
operator|*
literal|65535
operator|)
operator|>>
literal|24
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|tmp
expr_stmt|;
block|}
name|row_info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|8
operator|*
name|row_info
operator|->
name|channels
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_info
operator|->
name|width
operator|*
name|row_info
operator|->
name|channels
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
end_ifdef
begin_function
specifier|static
name|void
comment|/* Simply discard the low byte.  This was the default behavior prior  * to libpng-1.5.4.  */
DECL|function|png_do_chop
name|png_do_chop
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_chop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|png_bytep
name|sp
init|=
name|row
decl_stmt|;
comment|/* source */
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
comment|/* destination */
name|png_bytep
name|ep
init|=
name|sp
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
comment|/* end+1 */
while|while
condition|(
name|sp
operator|<
name|ep
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
comment|/* skip low byte */
block|}
name|row_info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|8
operator|*
name|row_info
operator|->
name|channels
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_info
operator|->
name|width
operator|*
name|row_info
operator|->
name|channels
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SWAP_ALPHA_SUPPORTED
end_ifdef
begin_function
specifier|static
name|void
DECL|function|png_do_read_swap_alpha
name|png_do_read_swap_alpha
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_read_swap_alpha"
argument_list|)
expr_stmt|;
block|{
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
block|{
comment|/* This converts from RGBA to ARGB */
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_byte
name|save
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|save
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|save
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
comment|/* This converts from RRGGBBAA to AARRGGBB */
else|else
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_byte
name|save
index|[
literal|2
index|]
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|save
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
name|save
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|save
index|[
literal|0
index|]
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|save
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
block|{
comment|/* This converts from GA to AG */
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_byte
name|save
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|save
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|save
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
comment|/* This converts from GGAA to AAGG */
else|else
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_byte
name|save
index|[
literal|2
index|]
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|save
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
name|save
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|save
index|[
literal|0
index|]
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|save
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_ALPHA_SUPPORTED
end_ifdef
begin_function
specifier|static
name|void
DECL|function|png_do_read_invert_alpha
name|png_do_read_invert_alpha
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_uint_32
name|row_width
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_read_invert_alpha"
argument_list|)
expr_stmt|;
name|row_width
operator|=
name|row_info
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
comment|/* This inverts the alpha channel in RGBA */
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
operator|*
operator|(
operator|--
name|sp
operator|)
argument_list|)
expr_stmt|;
comment|/*          This does nothing:             *(--dp) = *(--sp);             *(--dp) = *(--sp);             *(--dp) = *(--sp);             We can replace it with: */
name|sp
operator|-=
literal|3
expr_stmt|;
name|dp
operator|=
name|sp
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
comment|/* This inverts the alpha channel in RRGGBBAA */
else|else
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
operator|*
operator|(
operator|--
name|sp
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
operator|*
operator|(
operator|--
name|sp
operator|)
argument_list|)
expr_stmt|;
comment|/*          This does nothing:             *(--dp) = *(--sp);             *(--dp) = *(--sp);             *(--dp) = *(--sp);             *(--dp) = *(--sp);             *(--dp) = *(--sp);             *(--dp) = *(--sp);             We can replace it with: */
name|sp
operator|-=
literal|6
expr_stmt|;
name|dp
operator|=
name|sp
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
comment|/* This inverts the alpha channel in GA */
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
operator|*
operator|(
operator|--
name|sp
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
else|else
block|{
comment|/* This inverts the alpha channel in GGAA */
name|png_bytep
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
operator|*
operator|(
operator|--
name|sp
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|255
operator|-
operator|*
operator|(
operator|--
name|sp
operator|)
argument_list|)
expr_stmt|;
comment|/*             *(--dp) = *(--sp);             *(--dp) = *(--sp); */
name|sp
operator|-=
literal|2
expr_stmt|;
name|dp
operator|=
name|sp
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_FILLER_SUPPORTED
end_ifdef
begin_comment
comment|/* Add filler channel if we have RGB color */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_read_filler
name|png_do_read_filler
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_uint_32
name|filler
parameter_list|,
name|png_uint_32
name|flags
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
name|png_byte
name|hi_filler
init|=
call|(
name|png_byte
call|)
argument_list|(
name|filler
operator|>>
literal|8
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|png_byte
name|lo_filler
init|=
operator|(
name|png_byte
operator|)
name|filler
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_read_filler"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|PNG_FLAG_FILLER_AFTER
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This changes the data from G to GX */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
block|}
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|16
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* This changes the data from G to XG */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
block|}
name|row_info
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|16
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|2
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|PNG_FLAG_FILLER_AFTER
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This changes the data from GG to GGXX */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|hi_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
block|}
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|hi_filler
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|32
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* This changes the data from GG to XXGG */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|hi_filler
expr_stmt|;
block|}
name|row_info
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|32
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|4
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* COLOR_TYPE == GRAY */
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|PNG_FLAG_FILLER_AFTER
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This changes the data from RGB to RGBX */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|3
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
block|}
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|32
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* This changes the data from RGB to XRGB */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|3
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
block|}
name|row_info
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|32
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|4
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|PNG_FLAG_FILLER_AFTER
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This changes the data from RRGGBB to RRGGBBXX */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|6
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|hi_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
block|}
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|hi_filler
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|64
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* This changes the data from RRGGBB to XXRRGGBB */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|6
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
operator|*
operator|(
operator|--
name|sp
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|lo_filler
expr_stmt|;
operator|*
operator|(
operator|--
name|dp
operator|)
operator|=
name|hi_filler
expr_stmt|;
block|}
name|row_info
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|64
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|8
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* COLOR_TYPE == RGB */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
end_ifdef
begin_comment
comment|/* Expand grayscale files to RGB, with or without alpha */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_gray_to_rgb
name|png_do_gray_to_rgb
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_gray_to_rgb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|>=
literal|8
operator|&&
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
comment|/* This changes G to RGB */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This changes GG to RRGGBB */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
operator|-
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
comment|/* This changes GA to RGBA */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
operator|-
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This changes GGAA to RRGGBBAA */
name|png_bytep
name|sp
init|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|4
operator|-
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|sp
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|--
operator|)
operator|=
operator|*
operator|(
name|sp
operator|--
operator|)
expr_stmt|;
block|}
block|}
block|}
name|row_info
operator|->
name|channels
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|channels
operator|+
literal|2
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|color_type
operator||=
name|PNG_COLOR_MASK_COLOR
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|channels
operator|*
name|row_info
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
end_ifdef
begin_comment
comment|/* Reduce RGB files to grayscale, with or without alpha  * using the equation given in Poynton's ColorFAQ of 1998-01-04 at  *<http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but  * versions dated 1998 through November 2002 have been archived at  * http://web.archive.org/web/20000816232553/http://www.inforamp.net/  * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )  * Charles Poynton poynton at poynton.com  *  *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B  *  *  which can be expressed with integers as  *  *     Y = (6969 * R + 23434 * G + 2365 * B)/32768  *  * Poynton's current link (as of January 2003 through July 2011):  *<http://www.poynton.com/notes/colour_and_gamma/>  * has changed the numbers slightly:  *  *     Y = 0.2126*R + 0.7152*G + 0.0722*B  *  *  which can be expressed with integers as  *  *     Y = (6966 * R + 23436 * G + 2366 * B)/32768  *  *  Historically, however, libpng uses numbers derived from the ITU-R Rec 709  *  end point chromaticities and the D65 white point.  Depending on the  *  precision used for the D65 white point this produces a variety of different  *  numbers, however if the four decimal place value used in ITU-R Rec 709 is  *  used (0.3127,0.3290) the Y calculation would be:  *  *     Y = (6968 * R + 23435 * G + 2366 * B)/32768  *  *  While this is correct the rounding results in an overflow for white, because  *  the sum of the rounded coefficients is 32769, not 32768.  Consequently  *  libpng uses, instead, the closest non-overflowing approximation:  *  *     Y = (6968 * R + 23434 * G + 2366 * B)/32768  *  *  Starting with libpng-1.5.5, if the image being converted has a cHRM chunk  *  (including an sRGB chunk) then the chromaticities are used to calculate the  *  coefficients.  See the chunk handling in pngrutil.c for more information.  *  *  In all cases the calculation is to be done in a linear colorspace.  If no  *  gamma information is available to correct the encoding of the original RGB  *  values this results in an implicit assumption that the original PNG RGB  *  values were linear.  *  *  Other integer coefficents can be used via png_set_rgb_to_gray().  Because  *  the API takes just red and green coefficients the blue coefficient is  *  calculated to make the sum 32768.  This will result in different rounding  *  to that used above.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_do_rgb_to_gray
name|png_do_rgb_to_gray
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
name|int
name|rgb_error
init|=
literal|0
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_rgb_to_gray"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_PALETTE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|PNG_CONST
name|png_uint_32
name|rc
init|=
name|png_ptr
operator|->
name|rgb_to_gray_red_coeff
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|gc
init|=
name|png_ptr
operator|->
name|rgb_to_gray_green_coeff
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|bc
init|=
literal|32768
operator|-
name|rc
operator|-
name|gc
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|PNG_CONST
name|int
name|have_alpha
init|=
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* Notice that gamma to/from 1 are not necessarily inverses (if           * there is an overall gamma correction).  Prior to 1.5.5 this code           * checked the linearized values for equality; this doesn't match           * the documentation, the original values must be checked.           */
if|if
condition|(
name|png_ptr
operator|->
name|gamma_from_1
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|gamma_to_1
operator|!=
name|NULL
condition|)
block|{
name|png_bytep
name|sp
init|=
name|row
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|red
init|=
operator|*
operator|(
name|sp
operator|++
operator|)
decl_stmt|;
name|png_byte
name|green
init|=
operator|*
operator|(
name|sp
operator|++
operator|)
decl_stmt|;
name|png_byte
name|blue
init|=
operator|*
operator|(
name|sp
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|red
operator|!=
name|green
operator|||
name|red
operator|!=
name|blue
condition|)
block|{
name|red
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|red
index|]
expr_stmt|;
name|green
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|green
index|]
expr_stmt|;
name|blue
operator|=
name|png_ptr
operator|->
name|gamma_to_1
index|[
name|blue
index|]
expr_stmt|;
name|rgb_error
operator||=
literal|1
expr_stmt|;
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
name|png_ptr
operator|->
name|gamma_from_1
index|[
operator|(
name|rc
operator|*
name|red
operator|+
name|gc
operator|*
name|green
operator|+
name|bc
operator|*
name|blue
operator|+
literal|16384
operator|)
operator|>>
literal|15
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* If there is no overall correction the table will not be                    * set.                    */
if|if
condition|(
name|png_ptr
operator|->
name|gamma_table
operator|!=
name|NULL
condition|)
name|red
operator|=
name|png_ptr
operator|->
name|gamma_table
index|[
name|red
index|]
expr_stmt|;
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
name|red
expr_stmt|;
block|}
if|if
condition|(
name|have_alpha
operator|!=
literal|0
condition|)
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
operator|(
name|sp
operator|++
operator|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|png_bytep
name|sp
init|=
name|row
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|red
init|=
operator|*
operator|(
name|sp
operator|++
operator|)
decl_stmt|;
name|png_byte
name|green
init|=
operator|*
operator|(
name|sp
operator|++
operator|)
decl_stmt|;
name|png_byte
name|blue
init|=
operator|*
operator|(
name|sp
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|red
operator|!=
name|green
operator|||
name|red
operator|!=
name|blue
condition|)
block|{
name|rgb_error
operator||=
literal|1
expr_stmt|;
comment|/* NOTE: this is the historical approach which simply                    * truncates the results.                    */
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|rc
operator|*
name|red
operator|+
name|gc
operator|*
name|green
operator|+
name|bc
operator|*
name|blue
operator|)
operator|>>
literal|15
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
name|red
expr_stmt|;
if|if
condition|(
name|have_alpha
operator|!=
literal|0
condition|)
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
operator|(
name|sp
operator|++
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* RGB bit_depth == 16 */
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_to_1
operator|!=
name|NULL
operator|&&
name|png_ptr
operator|->
name|gamma_16_from_1
operator|!=
name|NULL
condition|)
block|{
name|png_bytep
name|sp
init|=
name|row
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|,
name|w
decl_stmt|;
name|png_byte
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|hi
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|lo
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|red
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator||
operator|(
name|lo
operator|)
argument_list|)
expr_stmt|;
name|hi
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|lo
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|green
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator||
operator|(
name|lo
operator|)
argument_list|)
expr_stmt|;
name|hi
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|lo
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|blue
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator||
operator|(
name|lo
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|==
name|green
operator|&&
name|red
operator|==
name|blue
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_table
operator|!=
name|NULL
condition|)
name|w
operator|=
name|png_ptr
operator|->
name|gamma_16_table
index|[
operator|(
name|red
operator|&
literal|0xff
operator|)
operator|>>
name|png_ptr
operator|->
name|gamma_shift
index|]
index|[
name|red
operator|>>
literal|8
index|]
expr_stmt|;
else|else
name|w
operator|=
name|red
expr_stmt|;
block|}
else|else
block|{
name|png_uint_16
name|red_1
init|=
name|png_ptr
operator|->
name|gamma_16_to_1
index|[
operator|(
name|red
operator|&
literal|0xff
operator|)
operator|>>
name|png_ptr
operator|->
name|gamma_shift
index|]
index|[
name|red
operator|>>
literal|8
index|]
decl_stmt|;
name|png_uint_16
name|green_1
init|=
name|png_ptr
operator|->
name|gamma_16_to_1
index|[
operator|(
name|green
operator|&
literal|0xff
operator|)
operator|>>
name|png_ptr
operator|->
name|gamma_shift
index|]
index|[
name|green
operator|>>
literal|8
index|]
decl_stmt|;
name|png_uint_16
name|blue_1
init|=
name|png_ptr
operator|->
name|gamma_16_to_1
index|[
operator|(
name|blue
operator|&
literal|0xff
operator|)
operator|>>
name|png_ptr
operator|->
name|gamma_shift
index|]
index|[
name|blue
operator|>>
literal|8
index|]
decl_stmt|;
name|png_uint_16
name|gray16
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|rc
operator|*
name|red_1
operator|+
name|gc
operator|*
name|green_1
operator|+
name|bc
operator|*
name|blue_1
operator|+
literal|16384
operator|)
operator|>>
literal|15
argument_list|)
decl_stmt|;
name|w
operator|=
name|png_ptr
operator|->
name|gamma_16_from_1
index|[
operator|(
name|gray16
operator|&
literal|0xff
operator|)
operator|>>
name|png_ptr
operator|->
name|gamma_shift
index|]
index|[
name|gray16
operator|>>
literal|8
index|]
expr_stmt|;
name|rgb_error
operator||=
literal|1
expr_stmt|;
block|}
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|w
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_alpha
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
operator|(
name|sp
operator|++
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
operator|(
name|sp
operator|++
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|png_bytep
name|sp
init|=
name|row
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|,
name|gray16
decl_stmt|;
name|png_byte
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|hi
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|lo
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|red
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator||
operator|(
name|lo
operator|)
argument_list|)
expr_stmt|;
name|hi
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|lo
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|green
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator||
operator|(
name|lo
operator|)
argument_list|)
expr_stmt|;
name|hi
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|lo
operator|=
operator|*
operator|(
name|sp
operator|)
operator|++
expr_stmt|;
name|blue
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator||
operator|(
name|lo
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|!=
name|green
operator|||
name|red
operator|!=
name|blue
condition|)
name|rgb_error
operator||=
literal|1
expr_stmt|;
comment|/* From 1.5.5 in the 16 bit case do the accurate conversion even                 * in the 'fast' case - this is because this is where the code                 * ends up when handling linear 16 bit data.                 */
name|gray16
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|rc
operator|*
name|red
operator|+
name|gc
operator|*
name|green
operator|+
name|bc
operator|*
name|blue
operator|+
literal|16384
operator|)
operator|>>
literal|15
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|gray16
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|gray16
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_alpha
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
operator|(
name|sp
operator|++
operator|)
expr_stmt|;
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
operator|(
name|sp
operator|++
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|row_info
operator|->
name|channels
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|channels
operator|-
literal|2
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|color_type
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|color_type
operator|&
operator|~
name|PNG_COLOR_MASK_COLOR
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|channels
operator|*
name|row_info
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
expr_stmt|;
block|}
return|return
name|rgb_error
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Replace any alpha or transparency with the supplied background color.  * "background" is already in the screen gamma, while "background_1" is  * at a gamma of 1.0.  Paletted files have already been taken care of.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_compose
name|png_do_compose
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_structrp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
name|png_const_bytep
name|gamma_table
init|=
name|png_ptr
operator|->
name|gamma_table
decl_stmt|;
name|png_const_bytep
name|gamma_from_1
init|=
name|png_ptr
operator|->
name|gamma_from_1
decl_stmt|;
name|png_const_bytep
name|gamma_to_1
init|=
name|png_ptr
operator|->
name|gamma_to_1
decl_stmt|;
name|png_const_uint_16pp
name|gamma_16
init|=
name|png_ptr
operator|->
name|gamma_16_table
decl_stmt|;
name|png_const_uint_16pp
name|gamma_16_from_1
init|=
name|png_ptr
operator|->
name|gamma_16_from_1
decl_stmt|;
name|png_const_uint_16pp
name|gamma_16_to_1
init|=
name|png_ptr
operator|->
name|gamma_16_to_1
decl_stmt|;
name|int
name|gamma_shift
init|=
name|png_ptr
operator|->
name|gamma_shift
decl_stmt|;
name|int
name|optimize
init|=
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_OPTIMIZE_ALPHA
operator|)
operator|!=
literal|0
decl_stmt|;
endif|#
directive|endif
name|png_bytep
name|sp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_compose"
argument_list|)
expr_stmt|;
block|{
switch|switch
condition|(
name|row_info
operator|->
name|color_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
block|{
switch|switch
condition|(
name|row_info
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|sp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x01
argument_list|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|sp
operator|&
operator|(
literal|0x7f7f
operator|>>
operator|(
literal|7
operator|-
name|shift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|<<
name|shift
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|7
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|--
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_table
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x03
argument_list|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|sp
operator|&
operator|(
literal|0x3f3f
operator|>>
operator|(
literal|6
operator|-
name|shift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|<<
name|shift
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|p
init|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x03
decl_stmt|;
name|unsigned
name|int
name|g
init|=
operator|(
name|gamma_table
index|[
name|p
operator||
operator|(
name|p
operator|<<
literal|2
operator|)
operator||
operator|(
name|p
operator|<<
literal|4
operator|)
operator||
operator|(
name|p
operator|<<
literal|6
operator|)
index|]
operator|>>
literal|6
operator|)
operator|&
literal|0x03
decl_stmt|;
name|unsigned
name|int
name|tmp
init|=
operator|*
name|sp
operator|&
operator|(
literal|0x3f3f
operator|>>
operator|(
literal|6
operator|-
name|shift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|g
operator|<<
name|shift
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|6
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x03
argument_list|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|sp
operator|&
operator|(
literal|0x3f3f
operator|>>
operator|(
literal|6
operator|-
name|shift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|<<
name|shift
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|6
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|2
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_table
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x0f
argument_list|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|sp
operator|&
operator|(
literal|0xf0f
operator|>>
operator|(
literal|4
operator|-
name|shift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|<<
name|shift
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|p
init|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|unsigned
name|int
name|g
init|=
operator|(
name|gamma_table
index|[
name|p
operator||
operator|(
name|p
operator|<<
literal|4
operator|)
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|unsigned
name|int
name|tmp
init|=
operator|*
name|sp
operator|&
operator|(
literal|0xf0f
operator|>>
operator|(
literal|4
operator|-
name|shift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|g
operator|<<
name|shift
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|4
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x0f
argument_list|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|sp
operator|&
operator|(
literal|0xf0f
operator|>>
operator|(
literal|4
operator|-
name|shift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|<<
name|shift
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|4
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|8
case|:
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_table
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|gray
expr_stmt|;
else|else
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|gray
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|16
case|:
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_16
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|2
control|)
block|{
name|png_uint_16
name|v
decl_stmt|;
name|v
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
name|sp
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
block|{
comment|/* Background is already in screen gamma */
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|2
control|)
block|{
name|png_uint_16
name|v
decl_stmt|;
name|v
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
name|sp
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
condition|)
block|{
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
break|break;
block|}
case|case
name|PNG_COLOR_TYPE_RGB
case|:
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_table
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|3
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|red
operator|&&
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|green
operator|&&
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|blue
condition|)
block|{
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|green
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|blue
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
name|gamma_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
name|gamma_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|3
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|red
operator|&&
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|green
operator|&&
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|blue
condition|)
block|{
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|green
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|blue
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
comment|/* if (row_info->bit_depth == 16) */
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_16
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|6
control|)
block|{
name|png_uint_16
name|r
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
name|sp
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|png_uint_16
name|g
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
argument_list|)
decl_stmt|;
name|png_uint_16
name|b
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|red
operator|&&
name|g
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|green
operator|&&
name|b
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|blue
condition|)
block|{
comment|/* Background is already in screen gamma */
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_uint_16
name|v
init|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
decl_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|v
operator|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|v
operator|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|6
control|)
block|{
name|png_uint_16
name|r
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
name|sp
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|png_uint_16
name|g
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
argument_list|)
decl_stmt|;
name|png_uint_16
name|b
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|red
operator|&&
name|g
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|green
operator|&&
name|b
operator|==
name|png_ptr
operator|->
name|trans_color
operator|.
name|blue
condition|)
block|{
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
block|}
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_to_1
operator|!=
name|NULL
operator|&&
name|gamma_from_1
operator|!=
name|NULL
operator|&&
name|gamma_table
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|2
control|)
block|{
name|png_uint_16
name|a
init|=
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0xff
condition|)
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
comment|/* Background is already in screen gamma */
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|gray
expr_stmt|;
block|}
else|else
block|{
name|png_byte
name|v
decl_stmt|,
name|w
decl_stmt|;
name|v
operator|=
name|gamma_to_1
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|png_composite
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|gray
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|w
operator|=
name|gamma_from_1
index|[
name|w
index|]
expr_stmt|;
operator|*
name|sp
operator|=
name|w
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|2
control|)
block|{
name|png_byte
name|a
init|=
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|gray
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|<
literal|0xff
condition|)
name|png_composite
argument_list|(
operator|*
name|sp
argument_list|,
operator|*
name|sp
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|gray
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* if (png_ptr->bit_depth == 16) */
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_16
operator|!=
name|NULL
operator|&&
name|gamma_16_from_1
operator|!=
name|NULL
operator|&&
name|gamma_16_to_1
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|4
control|)
block|{
name|png_uint_16
name|a
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
operator|(
name|png_uint_16
operator|)
literal|0xffff
condition|)
block|{
name|png_uint_16
name|v
decl_stmt|;
name|v
operator|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
comment|/* Background is already in screen gamma */
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_uint_16
name|g
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|;
name|g
operator|=
name|gamma_16_to_1
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|png_composite_16
argument_list|(
name|v
argument_list|,
name|g
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|gray
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|!=
literal|0
condition|)
name|w
operator|=
name|v
expr_stmt|;
else|else
name|w
operator|=
name|gamma_16_from_1
index|[
operator|(
name|v
operator|&
literal|0xff
operator|)
operator|>>
name|gamma_shift
index|]
index|[
name|v
operator|>>
literal|8
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|w
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|4
control|)
block|{
name|png_uint_16
name|a
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|<
literal|0xffff
condition|)
block|{
name|png_uint_16
name|g
decl_stmt|,
name|v
decl_stmt|;
name|g
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
name|sp
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|png_composite_16
argument_list|(
name|v
argument_list|,
name|g
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|gray
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
block|}
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_to_1
operator|!=
name|NULL
operator|&&
name|gamma_from_1
operator|!=
name|NULL
operator|&&
name|gamma_table
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|4
control|)
block|{
name|png_byte
name|a
init|=
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0xff
condition|)
block|{
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
name|gamma_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
name|gamma_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
comment|/* Background is already in screen gamma */
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|green
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|blue
expr_stmt|;
block|}
else|else
block|{
name|png_byte
name|v
decl_stmt|,
name|w
decl_stmt|;
name|v
operator|=
name|gamma_to_1
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|png_composite
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|w
operator|=
name|gamma_from_1
index|[
name|w
index|]
expr_stmt|;
operator|*
name|sp
operator|=
name|w
expr_stmt|;
name|v
operator|=
name|gamma_to_1
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
index|]
expr_stmt|;
name|png_composite
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|w
operator|=
name|gamma_from_1
index|[
name|w
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
name|w
expr_stmt|;
name|v
operator|=
name|gamma_to_1
index|[
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
index|]
expr_stmt|;
name|png_composite
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|w
operator|=
name|gamma_from_1
index|[
name|w
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
name|w
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|4
control|)
block|{
name|png_byte
name|a
init|=
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
operator|*
name|sp
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|red
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|green
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|background
operator|.
name|blue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|<
literal|0xff
condition|)
block|{
name|png_composite
argument_list|(
operator|*
name|sp
argument_list|,
operator|*
name|sp
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|red
argument_list|)
expr_stmt|;
name|png_composite
argument_list|(
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|green
argument_list|)
expr_stmt|;
name|png_composite
argument_list|(
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|blue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
comment|/* if (row_info->bit_depth == 16) */
block|{
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
name|gamma_16
operator|!=
name|NULL
operator|&&
name|gamma_16_from_1
operator|!=
name|NULL
operator|&&
name|gamma_16_to_1
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|8
control|)
block|{
name|png_uint_16
name|a
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
call|(
name|png_uint_16
call|)
argument_list|(
operator|*
operator|(
name|sp
operator|+
literal|6
operator|)
argument_list|)
operator|<<
literal|8
operator|)
operator|+
call|(
name|png_uint_16
call|)
argument_list|(
operator|*
operator|(
name|sp
operator|+
literal|7
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
operator|(
name|png_uint_16
operator|)
literal|0xffff
condition|)
block|{
name|png_uint_16
name|v
decl_stmt|;
name|v
operator|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|v
operator|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|v
operator|=
name|gamma_16
index|[
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
comment|/* Background is already in screen gamma */
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_uint_16
name|v
decl_stmt|,
name|w
decl_stmt|;
name|v
operator|=
name|gamma_16_to_1
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|png_composite_16
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|w
operator|=
name|gamma_16_from_1
index|[
operator|(
operator|(
name|w
operator|&
literal|0xff
operator|)
operator|>>
name|gamma_shift
operator|)
index|]
index|[
name|w
operator|>>
literal|8
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|w
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|v
operator|=
name|gamma_16_to_1
index|[
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
index|]
expr_stmt|;
name|png_composite_16
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|w
operator|=
name|gamma_16_from_1
index|[
operator|(
operator|(
name|w
operator|&
literal|0xff
operator|)
operator|>>
name|gamma_shift
operator|)
index|]
index|[
name|w
operator|>>
literal|8
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|w
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|v
operator|=
name|gamma_16_to_1
index|[
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
index|]
expr_stmt|;
name|png_composite_16
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background_1
operator|.
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|w
operator|=
name|gamma_16_from_1
index|[
operator|(
operator|(
name|w
operator|&
literal|0xff
operator|)
operator|>>
name|gamma_shift
operator|)
index|]
index|[
name|w
operator|>>
literal|8
index|]
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|w
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
literal|8
control|)
block|{
name|png_uint_16
name|a
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
call|(
name|png_uint_16
call|)
argument_list|(
operator|*
operator|(
name|sp
operator|+
literal|6
operator|)
argument_list|)
operator|<<
literal|8
operator|)
operator|+
call|(
name|png_uint_16
call|)
argument_list|(
operator|*
operator|(
name|sp
operator|+
literal|7
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|<
literal|0xffff
condition|)
block|{
name|png_uint_16
name|v
decl_stmt|;
name|png_uint_16
name|r
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
name|sp
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|png_uint_16
name|g
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
argument_list|)
decl_stmt|;
name|png_uint_16
name|b
init|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
operator|(
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
argument_list|)
decl_stmt|;
name|png_composite_16
argument_list|(
name|v
argument_list|,
name|r
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|red
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|png_composite_16
argument_list|(
name|v
argument_list|,
name|g
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|green
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|2
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|3
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|png_composite_16
argument_list|(
name|v
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|png_ptr
operator|->
name|background
operator|.
name|blue
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|4
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|5
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_BACKGROUND || READ_ALPHA_MODE */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* Gamma correct the image, avoiding the alpha channel.  Make sure  * you do this after you deal with the transparency issue on grayscale  * or RGB images. If your bit depth is 8, use gamma_table, if it  * is 16, use gamma_16_table and gamma_shift.  Build these with  * build_gamma_table().  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_gamma
name|png_do_gamma
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_const_bytep
name|gamma_table
init|=
name|png_ptr
operator|->
name|gamma_table
decl_stmt|;
name|png_const_uint_16pp
name|gamma_16_table
init|=
name|png_ptr
operator|->
name|gamma_16_table
decl_stmt|;
name|int
name|gamma_shift
init|=
name|png_ptr
operator|->
name|gamma_shift
decl_stmt|;
name|png_bytep
name|sp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_gamma"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|row_info
operator|->
name|bit_depth
operator|<=
literal|8
operator|&&
name|gamma_table
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
operator|&&
name|gamma_16_table
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|row_info
operator|->
name|color_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_RGB
case|:
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|/* if (row_info->bit_depth == 16) */
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16
name|v
decl_stmt|;
name|v
operator|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
name|v
operator|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
name|v
operator|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|/* if (row_info->bit_depth == 16) */
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16
name|v
init|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
decl_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
name|v
operator|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
name|v
operator|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|4
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
comment|/* if (row_info->bit_depth == 16) */
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16
name|v
init|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
decl_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|4
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|2
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|int
name|a
init|=
operator|*
name|sp
operator|&
literal|0xc0
decl_stmt|;
name|int
name|b
init|=
operator|*
name|sp
operator|&
literal|0x30
decl_stmt|;
name|int
name|c
init|=
operator|*
name|sp
operator|&
literal|0x0c
decl_stmt|;
name|int
name|d
init|=
operator|*
name|sp
operator|&
literal|0x03
decl_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|gamma_table
index|[
name|a
operator||
operator|(
name|a
operator|>>
literal|2
operator|)
operator||
operator|(
name|a
operator|>>
literal|4
operator|)
operator||
operator|(
name|a
operator|>>
literal|6
operator|)
index|]
operator|)
operator|)
operator|&
literal|0xc0
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|gamma_table
index|[
operator|(
name|b
operator|<<
literal|2
operator|)
operator||
name|b
operator||
operator|(
name|b
operator|>>
literal|2
operator|)
operator||
operator|(
name|b
operator|>>
literal|4
operator|)
index|]
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x30
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|gamma_table
index|[
operator|(
name|c
operator|<<
literal|4
operator|)
operator||
operator|(
name|c
operator|<<
literal|2
operator|)
operator||
name|c
operator||
operator|(
name|c
operator|>>
literal|2
operator|)
index|]
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0c
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|gamma_table
index|[
operator|(
name|d
operator|<<
literal|6
operator|)
operator||
operator|(
name|d
operator|<<
literal|4
operator|)
operator||
operator|(
name|d
operator|<<
literal|2
operator|)
operator||
name|d
index|]
operator|)
operator|>>
literal|6
operator|)
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|4
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|msb
init|=
operator|*
name|sp
operator|&
literal|0xf0
decl_stmt|;
name|int
name|lsb
init|=
operator|*
name|sp
operator|&
literal|0x0f
decl_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
operator|(
name|int
operator|)
name|gamma_table
index|[
name|msb
operator||
operator|(
name|msb
operator|>>
literal|4
operator|)
index|]
operator|)
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|gamma_table
index|[
operator|(
name|lsb
operator|<<
literal|4
operator|)
operator||
name|lsb
index|]
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|=
name|gamma_table
index|[
operator|*
name|sp
index|]
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16
name|v
init|=
name|gamma_16_table
index|[
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|sp
index|]
decl_stmt|;
operator|*
name|sp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_ALPHA_MODE_SUPPORTED
end_ifdef
begin_comment
comment|/* Encode the alpha channel to the output gamma (the input channel is always  * linear.)  Called only with color types that have an alpha channel.  Needs the  * from_1 tables.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_encode_alpha
name|png_do_encode_alpha
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_encode_alpha"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|PNG_CONST
name|png_bytep
name|table
init|=
name|png_ptr
operator|->
name|gamma_from_1
decl_stmt|;
if|if
condition|(
name|table
operator|!=
name|NULL
condition|)
block|{
name|PNG_CONST
name|int
name|step
init|=
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
condition|?
literal|4
else|:
literal|2
decl_stmt|;
comment|/* The alpha channel is the last component: */
name|row
operator|+=
name|step
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|row_width
operator|>
literal|0
condition|;
operator|--
name|row_width
operator|,
name|row
operator|+=
name|step
control|)
operator|*
name|row
operator|=
name|table
index|[
operator|*
name|row
index|]
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|PNG_CONST
name|png_uint_16pp
name|table
init|=
name|png_ptr
operator|->
name|gamma_16_from_1
decl_stmt|;
name|PNG_CONST
name|int
name|gamma_shift
init|=
name|png_ptr
operator|->
name|gamma_shift
decl_stmt|;
if|if
condition|(
name|table
operator|!=
name|NULL
condition|)
block|{
name|PNG_CONST
name|int
name|step
init|=
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
condition|?
literal|8
else|:
literal|4
decl_stmt|;
comment|/* The alpha channel is the last component: */
name|row
operator|+=
name|step
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|row_width
operator|>
literal|0
condition|;
operator|--
name|row_width
operator|,
name|row
operator|+=
name|step
control|)
block|{
name|png_uint_16
name|v
decl_stmt|;
name|v
operator|=
name|table
index|[
operator|*
operator|(
name|row
operator|+
literal|1
operator|)
operator|>>
name|gamma_shift
index|]
index|[
operator|*
name|row
index|]
expr_stmt|;
operator|*
name|row
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
operator|(
name|row
operator|+
literal|1
operator|)
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
comment|/* Only get to here if called with a weird row_info; no harm has been done,     * so just issue a warning.     */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"png_do_encode_alpha: unexpected call"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
end_ifdef
begin_comment
comment|/* Expands a palette row to an RGB or RGBA row depending  * upon whether you supply trans and num_trans.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_expand_palette
name|png_do_expand_palette
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_colorp
name|palette
parameter_list|,
name|png_const_bytep
name|trans_alpha
parameter_list|,
name|int
name|num_trans
parameter_list|)
block|{
name|int
name|shift
decl_stmt|,
name|value
decl_stmt|;
name|png_bytep
name|sp
decl_stmt|,
name|dp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_expand_palette"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|<
literal|8
condition|)
block|{
switch|switch
condition|(
name|row_info
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|dp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|row_width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x01
condition|)
operator|*
name|dp
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|7
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|++
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|3
operator|-
operator|(
operator|(
name|row_width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x03
expr_stmt|;
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|6
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|+=
literal|2
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|dp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|row_width
operator|&
literal|0x01
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|4
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|+=
literal|4
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
name|row_info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
expr_stmt|;
block|}
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
block|{
if|if
condition|(
name|num_trans
operator|>
literal|0
condition|)
block|{
name|sp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|dp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|row_width
operator|<<
literal|2
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
operator|*
name|sp
argument_list|)
operator|>=
name|num_trans
condition|)
operator|*
name|dp
operator|--
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|dp
operator|--
operator|=
name|trans_alpha
index|[
operator|*
name|sp
index|]
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
name|palette
index|[
operator|*
name|sp
index|]
operator|.
name|blue
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
name|palette
index|[
operator|*
name|sp
index|]
operator|.
name|green
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
name|palette
index|[
operator|*
name|sp
index|]
operator|.
name|red
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
name|row_info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|32
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|4
expr_stmt|;
name|row_info
operator|->
name|color_type
operator|=
literal|6
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|dp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|row_width
operator|*
literal|3
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|--
operator|=
name|palette
index|[
operator|*
name|sp
index|]
operator|.
name|blue
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
name|palette
index|[
operator|*
name|sp
index|]
operator|.
name|green
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
name|palette
index|[
operator|*
name|sp
index|]
operator|.
name|red
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
name|row_info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|24
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
operator|*
literal|3
expr_stmt|;
name|row_info
operator|->
name|color_type
operator|=
literal|2
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* If the bit depth< 8, it is expanded to 8.  Also, if the already  * expanded transparency value is supplied, an alpha channel is built.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_expand
name|png_do_expand
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_color_16p
name|trans_color
parameter_list|)
block|{
name|int
name|shift
decl_stmt|,
name|value
decl_stmt|;
name|png_bytep
name|sp
decl_stmt|,
name|dp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_expand"
argument_list|)
expr_stmt|;
block|{
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
name|unsigned
name|int
name|gray
init|=
name|trans_color
operator|!=
name|NULL
condition|?
name|trans_color
operator|->
name|gray
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|<
literal|8
condition|)
block|{
switch|switch
condition|(
name|row_info
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|gray
operator|=
operator|(
name|gray
operator|&
literal|0x01
operator|)
operator|*
literal|0xff
expr_stmt|;
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|dp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|row_width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x01
condition|)
operator|*
name|dp
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|7
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|++
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|gray
operator|=
operator|(
name|gray
operator|&
literal|0x03
operator|)
operator|*
literal|0x55
expr_stmt|;
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|3
operator|-
operator|(
operator|(
name|row_width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x03
expr_stmt|;
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|value
operator||
operator|(
name|value
operator|<<
literal|2
operator|)
operator||
operator|(
name|value
operator|<<
literal|4
operator|)
operator||
operator|(
name|value
operator|<<
literal|6
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|6
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|+=
literal|2
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|gray
operator|=
operator|(
name|gray
operator|&
literal|0x0f
operator|)
operator|*
literal|0x11
expr_stmt|;
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_width
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|dp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
operator|(
operator|(
name|row_width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|value
operator||
operator|(
name|value
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|4
condition|)
block|{
name|shift
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|shift
operator|=
literal|4
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
name|row_info
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
literal|8
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|row_width
expr_stmt|;
block|}
if|if
condition|(
name|trans_color
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|gray
operator|=
name|gray
operator|&
literal|0xff
expr_stmt|;
name|sp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_width
operator|-
literal|1
expr_stmt|;
name|dp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|row_width
operator|<<
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|gray
condition|)
operator|*
name|dp
operator|--
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|dp
operator|--
operator|=
literal|0xff
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|unsigned
name|int
name|gray_high
init|=
operator|(
name|gray
operator|>>
literal|8
operator|)
operator|&
literal|0xff
decl_stmt|;
name|unsigned
name|int
name|gray_low
init|=
name|gray
operator|&
literal|0xff
decl_stmt|;
name|sp
operator|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
operator|-
literal|1
expr_stmt|;
name|dp
operator|=
name|row
operator|+
operator|(
name|row_info
operator|->
name|rowbytes
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|==
name|gray_high
operator|&&
operator|*
operator|(
name|sp
operator|)
operator|==
name|gray_low
condition|)
block|{
operator|*
name|dp
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dp
operator|--
operator|=
literal|0xff
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
literal|0xff
expr_stmt|;
block|}
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|row_info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|bit_depth
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|&&
name|trans_color
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
name|png_byte
name|red
init|=
call|(
name|png_byte
call|)
argument_list|(
name|trans_color
operator|->
name|red
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|png_byte
name|green
init|=
call|(
name|png_byte
call|)
argument_list|(
name|trans_color
operator|->
name|green
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|png_byte
name|blue
init|=
call|(
name|png_byte
call|)
argument_list|(
name|trans_color
operator|->
name|blue
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|sp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|row_info
operator|->
name|rowbytes
operator|-
literal|1
expr_stmt|;
name|dp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|row_width
operator|<<
literal|2
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|sp
operator|-
literal|2
operator|)
operator|==
name|red
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|==
name|green
operator|&&
operator|*
operator|(
name|sp
operator|)
operator|==
name|blue
condition|)
operator|*
name|dp
operator|--
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|dp
operator|--
operator|=
literal|0xff
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|png_byte
name|red_high
init|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|trans_color
operator|->
name|red
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|png_byte
name|green_high
init|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|trans_color
operator|->
name|green
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|png_byte
name|blue_high
init|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|trans_color
operator|->
name|blue
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|png_byte
name|red_low
init|=
call|(
name|png_byte
call|)
argument_list|(
name|trans_color
operator|->
name|red
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|png_byte
name|green_low
init|=
call|(
name|png_byte
call|)
argument_list|(
name|trans_color
operator|->
name|green
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|png_byte
name|blue_low
init|=
call|(
name|png_byte
call|)
argument_list|(
name|trans_color
operator|->
name|blue
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|sp
operator|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
operator|-
literal|1
expr_stmt|;
name|dp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|row_width
operator|<<
literal|3
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|sp
operator|-
literal|5
operator|)
operator|==
name|red_high
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|4
operator|)
operator|==
name|red_low
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|3
operator|)
operator|==
name|green_high
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|2
operator|)
operator|==
name|green_low
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|==
name|blue_high
operator|&&
operator|*
operator|(
name|sp
operator|)
operator|==
name|blue_low
condition|)
block|{
operator|*
name|dp
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dp
operator|--
operator|=
literal|0xff
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
literal|0xff
expr_stmt|;
block|}
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
operator|*
name|dp
operator|--
operator|=
operator|*
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|row_info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|bit_depth
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
end_ifdef
begin_comment
comment|/* If the bit depth is 8 and the color type is not a palette type expand the  * whole row to 16 bits.  Has no effect otherwise.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_do_expand_16
name|png_do_expand_16
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|)
block|{
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
name|row_info
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
comment|/* The row have a sequence of bytes containing [0..255] and we need        * to turn it into another row containing [0..65535], to do this we        * calculate:        *        *  (input / 255) * 65535        *        *  Which happens to be exactly input * 257 and this can be achieved        *  simply by byte replication in place (copying backwards).        */
name|png_byte
modifier|*
name|sp
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
comment|/* source, last byte + 1 */
name|png_byte
modifier|*
name|dp
init|=
name|sp
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
comment|/* destination, end + 1 */
while|while
condition|(
name|dp
operator|>
name|sp
condition|)
name|dp
index|[
operator|-
literal|2
index|]
operator|=
name|dp
index|[
operator|-
literal|1
index|]
operator|=
operator|*
operator|--
name|sp
operator|,
name|dp
operator|-=
literal|2
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|*=
literal|2
expr_stmt|;
name|row_info
operator|->
name|bit_depth
operator|=
literal|16
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|channels
operator|*
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
end_ifdef
begin_function
specifier|static
name|void
DECL|function|png_do_quantize
name|png_do_quantize
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|palette_lookup
parameter_list|,
name|png_const_bytep
name|quantize_lookup
parameter_list|)
block|{
name|png_bytep
name|sp
decl_stmt|,
name|dp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_quantize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|bit_depth
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|&&
name|palette_lookup
condition|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|p
decl_stmt|;
name|sp
operator|=
name|row
expr_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* This looks real messy, but the compiler will reduce              * it down to a reasonable formula.  For example, with              * 5 bits per color, we get:              * p = (((r>> 3)& 0x1f)<< 10) |              *    (((g>> 3)& 0x1f)<< 5) |              *    ((b>> 3)& 0x1f);              */
name|p
operator|=
operator|(
operator|(
operator|(
name|r
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_RED_BITS
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_RED_BITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|PNG_QUANTIZE_GREEN_BITS
operator|+
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|g
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_GREEN_BITS
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_GREEN_BITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|)
operator||
operator|(
operator|(
name|b
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|palette_lookup
index|[
name|p
index|]
expr_stmt|;
block|}
name|row_info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
name|row_info
operator|->
name|bit_depth
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|&&
name|palette_lookup
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|p
decl_stmt|;
name|sp
operator|=
name|row
expr_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|g
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|p
operator|=
operator|(
operator|(
operator|(
name|r
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_RED_BITS
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_RED_BITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|PNG_QUANTIZE_GREEN_BITS
operator|+
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|g
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_GREEN_BITS
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_GREEN_BITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|)
operator||
operator|(
operator|(
name|b
operator|>>
operator|(
literal|8
operator|-
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|PNG_QUANTIZE_BLUE_BITS
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|palette_lookup
index|[
name|p
index|]
expr_stmt|;
block|}
name|row_info
operator|->
name|color_type
operator|=
name|PNG_COLOR_TYPE_PALETTE
expr_stmt|;
name|row_info
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
name|row_info
operator|->
name|pixel_depth
operator|=
name|row_info
operator|->
name|bit_depth
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|quantize_lookup
condition|)
block|{
name|sp
operator|=
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
operator|*
name|sp
operator|=
name|quantize_lookup
index|[
operator|*
name|sp
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_QUANTIZE */
end_comment
begin_comment
comment|/* Transform the row.  The order of transformations is significant,  * and is very touchy.  If you add a transformation, take care to  * decide how it fits in with the other transformations here.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_do_read_transformations
name|png_do_read_transformations
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_read_transformations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_buf
operator|==
name|NULL
condition|)
block|{
comment|/* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this        * error is incredibly rare and incredibly easy to debug without this        * information.        */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"NULL row buffer"
argument_list|)
expr_stmt|;
block|}
comment|/* The following is debugging; prior to 1.5.4 the code was never compiled in;     * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro     * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.6 the new flag is set only for     * all transformations, however in practice the ROW_INIT always gets done on     * demand, if necessary.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_DETECT_UNINITIALIZED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ROW_INIT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Application has failed to call either png_read_start_image() or        * png_read_update_info() after setting transforms that expand pixels.        * This check added to libpng-1.2.19 (but not enabled until 1.5.4).        */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Uninitialized row"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_do_expand_palette
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|palette
argument_list|,
name|png_ptr
operator|->
name|trans_alpha
argument_list|,
name|png_ptr
operator|->
name|num_trans
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_tRNS
operator|)
operator|!=
literal|0
condition|)
name|png_do_expand
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|trans_color
operator|)
argument_list|)
expr_stmt|;
else|else
name|png_do_expand
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_STRIP_ALPHA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|||
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
operator|)
condition|)
name|png_do_strip_channel
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
literal|0
comment|/* at_start == false, because SWAP_ALPHA happens later */
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|rgb_error
init|=
name|png_do_rgb_to_gray
argument_list|(
name|png_ptr
argument_list|,
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rgb_error
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|rgb_to_gray_status
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|==
name|PNG_RGB_TO_GRAY_WARN
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"png_do_rgb_to_gray found nongray pixel"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|==
name|PNG_RGB_TO_GRAY_ERR
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_do_rgb_to_gray found nongray pixel"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* From Andreas Dilger e-mail to png-implement, 26 March 1998:  *  *   In most cases, the "simple transparency" should be done prior to doing  *   gray-to-RGB, or you will have to test 3x as many bytes to check if a  *   pixel is transparent.  You would also need to make sure that the  *   transparency information is upgraded to RGB.  *  *   To summarize, the current flow is:  *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite  *                                   with background "in place" if transparent,  *                                   convert to RGB if necessary  *   - Gray + alpha -> composite with gray background and remove alpha bytes,  *                                   convert to RGB if necessary  *  *   To support RGB backgrounds for gray images we need:  *   - Gray + simple transparency -> convert to RGB + simple transparency,  *                                   compare 3 or 6 bytes and composite with  *                                   background "in place" if transparent  *                                   (3x compare/pixel compared to doing  *                                   composite with gray bkgrnd)  *   - Gray + alpha -> convert to RGB + alpha, composite with background and  *                                   remove alpha bytes (3x float  *                                   operations/pixel compared with composite  *                                   on gray background)  *  *  Greg's change will do this.  The reason it wasn't done before is for  *  performance, as this increases the per-pixel operations.  If we would check  *  in advance if the background was gray or RGB, and position the gray-to-RGB  *  transform appropriately, then it would save a lot of work/time.  */
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
comment|/* If gray -> RGB, do so now only if background is non-gray; else do later     * for performance reasons     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GRAY_TO_RGB
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_BACKGROUND_IS_GRAY
operator|)
operator|==
literal|0
condition|)
name|png_do_gray_to_rgb
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
condition|)
name|png_do_compose
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GAMMA
operator|)
operator|!=
literal|0
operator|&&
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
comment|/* Because RGB_TO_GRAY does the gamma transform. */
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_RGB_TO_GRAY
operator|)
operator|==
literal|0
operator|&&
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
comment|/* Because PNG_COMPOSE does the gamma transform if there is something to        * do (if there is an alpha channel or transparency.)        */
operator|!
operator|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|num_trans
operator|!=
literal|0
operator|)
operator|||
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
endif|#
directive|endif
comment|/* Because png_init_read_transformations transforms the palette, unless        * RGB_TO_GRAY will do the transform.        */
operator|(
name|png_ptr
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
operator|)
condition|)
name|png_do_gamma
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_ALPHA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_STRIP_ALPHA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_COMPOSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|||
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
operator|)
condition|)
name|png_do_strip_channel
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
literal|0
comment|/* at_start == false, because SWAP_ALPHA happens later */
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_ALPHA_MODE_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_ENCODE_ALPHA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|row_info
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|png_do_encode_alpha
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SCALE_16_TO_8_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SCALE_16_TO_8
operator|)
operator|!=
literal|0
condition|)
name|png_do_scale_16_to_8
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_STRIP_16_TO_8_SUPPORTED
comment|/* There is no harm in doing both of these because only one has any effect,     * by putting the 'scale' option first if the app asks for scale (either by     * calling the API or in a TRANSFORM flag) this is what happens.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_16_TO_8
operator|)
operator|!=
literal|0
condition|)
name|png_do_chop
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_QUANTIZE_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_QUANTIZE
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_do_quantize
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|palette_lookup
argument_list|,
name|png_ptr
operator|->
name|quantize_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_info
operator|->
name|rowbytes
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"png_do_quantize returned rowbytes=0"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* READ_QUANTIZE */
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
comment|/* Do the expansion now, after all the arithmetic has been done.  Notice     * that previous transformations can handle the PNG_EXPAND_16 flag if this     * is efficient (particularly true in the case of gamma correction, where     * better accuracy results faster!)     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_16
operator|)
operator|!=
literal|0
condition|)
name|png_do_expand_16
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
comment|/* NOTE: moved here in 1.5.4 (from much later in this list.) */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GRAY_TO_RGB
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_BACKGROUND_IS_GRAY
operator|)
operator|!=
literal|0
condition|)
name|png_do_gray_to_rgb
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_MONO
operator|)
operator|!=
literal|0
condition|)
name|png_do_invert
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_INVERT_ALPHA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INVERT_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|png_do_read_invert_alpha
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SHIFT_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SHIFT
operator|)
operator|!=
literal|0
condition|)
name|png_do_unshift
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|shift
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_PACK_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
operator|)
operator|!=
literal|0
condition|)
name|png_do_unpack
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
comment|/* Added at libpng-1.5.10 */
if|if
condition|(
name|row_info
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|png_ptr
operator|->
name|num_palette_max
operator|>=
literal|0
condition|)
name|png_do_check_palette_indexes
argument_list|(
name|png_ptr
argument_list|,
name|row_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_BGR_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_BGR
operator|)
operator|!=
literal|0
condition|)
name|png_do_bgr
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
name|png_do_packswap
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_FILLER_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_FILLER
operator|)
operator|!=
literal|0
condition|)
name|png_do_read_filler
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
operator|(
name|png_uint_32
operator|)
name|png_ptr
operator|->
name|filler
argument_list|,
name|png_ptr
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_SWAP_ALPHA_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SWAP_ALPHA
operator|)
operator|!=
literal|0
condition|)
name|png_do_read_swap_alpha
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_READ_SWAP_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_SWAP_BYTES
operator|)
operator|!=
literal|0
condition|)
name|png_do_swap
argument_list|(
name|row_info
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_USER_TRANSFORM_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_USER_TRANSFORM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|read_user_transform_fn
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|read_user_transform_fn
operator|)
operator|)
comment|/* User read transform function */
operator|(
name|png_ptr
operator|,
comment|/* png_ptr */
name|row_info
operator|,
comment|/* row_info: */
comment|/*  png_uint_32 width;       width of row */
comment|/*  png_size_t rowbytes;     number of bytes in row */
comment|/*  png_byte color_type;     color type of pixels */
comment|/*  png_byte bit_depth;      bit depth of samples */
comment|/*  png_byte channels;       number of channels (1-4) */
comment|/*  png_byte pixel_depth;    bits per pixel (depth*channels) */
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* start of pixel data for row */
ifdef|#
directive|ifdef
name|PNG_USER_TRANSFORM_PTR_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_transform_depth
operator|!=
literal|0
condition|)
name|row_info
operator|->
name|bit_depth
operator|=
name|png_ptr
operator|->
name|user_transform_depth
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|user_transform_channels
operator|!=
literal|0
condition|)
name|row_info
operator|->
name|channels
operator|=
name|png_ptr
operator|->
name|user_transform_channels
expr_stmt|;
endif|#
directive|endif
name|row_info
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|row_info
operator|->
name|bit_depth
operator|*
name|row_info
operator|->
name|channels
argument_list|)
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_info
operator|->
name|width
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_TRANSFORMS */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ */
end_comment
end_unit
