begin_unit
begin_comment
comment|/* pngvalid.c - validate libpng by constructing then reading png files.  *  * Last changed in libpng 1.5.1 [February 3, 2011]  * Copyright (c) 2011 Glenn Randers-Pehrson  * Written by John Cunningham Bowler  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * NOTES:  *   This is a C program that is intended to be linked against libpng.  It  *   generates bitmaps internally, stores them as PNG files (using the  *   sequential write code) then reads them back (using the sequential  *   read code) and validates that the result has the correct data.  *  *   The program can be modified and extended to test the correctness of  *   transformations performed by libpng.  */
end_comment
begin_include
include|#
directive|include
file|"png.h"
end_include
begin_if
if|#
directive|if
name|PNG_LIBPNG_VER
operator|<
literal|10500
end_if
begin_comment
comment|/* This delibarately lacks the PNG_CONST. */
end_comment
begin_typedef
DECL|typedef|png_const_bytep
typedef|typedef
name|png_byte
modifier|*
name|png_const_bytep
typedef|;
end_typedef
begin_comment
comment|/* This is copied from 1.5.1 png.h: */
end_comment
begin_define
DECL|macro|PNG_INTERLACE_ADAM7_PASSES
define|#
directive|define
name|PNG_INTERLACE_ADAM7_PASSES
value|7
end_define
begin_define
DECL|macro|PNG_PASS_START_ROW
define|#
directive|define
name|PNG_PASS_START_ROW
parameter_list|(
name|pass
parameter_list|)
value|(((1U&~(pass))<<(3-((pass)>>1)))&7)
end_define
begin_define
DECL|macro|PNG_PASS_START_COL
define|#
directive|define
name|PNG_PASS_START_COL
parameter_list|(
name|pass
parameter_list|)
value|(((1U& (pass))<<(3-(((pass)+1)>>1)))&7)
end_define
begin_define
DECL|macro|PNG_PASS_ROW_SHIFT
define|#
directive|define
name|PNG_PASS_ROW_SHIFT
parameter_list|(
name|pass
parameter_list|)
value|((pass)>2?(8-(pass))>>1:3)
end_define
begin_define
DECL|macro|PNG_PASS_COL_SHIFT
define|#
directive|define
name|PNG_PASS_COL_SHIFT
parameter_list|(
name|pass
parameter_list|)
value|((pass)>1?(7-(pass))>>1:3)
end_define
begin_define
DECL|macro|PNG_PASS_ROWS
define|#
directive|define
name|PNG_PASS_ROWS
parameter_list|(
name|height
parameter_list|,
name|pass
parameter_list|)
value|(((height)+(((1<<PNG_PASS_ROW_SHIFT(pass))\    -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))
end_define
begin_define
DECL|macro|PNG_PASS_COLS
define|#
directive|define
name|PNG_PASS_COLS
parameter_list|(
name|width
parameter_list|,
name|pass
parameter_list|)
value|(((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\    -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))
end_define
begin_define
DECL|macro|PNG_ROW_FROM_PASS_ROW
define|#
directive|define
name|PNG_ROW_FROM_PASS_ROW
parameter_list|(
name|yIn
parameter_list|,
name|pass
parameter_list|)
define|\
value|(((yIn)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
end_define
begin_define
DECL|macro|PNG_COL_FROM_PASS_COL
define|#
directive|define
name|PNG_COL_FROM_PASS_COL
parameter_list|(
name|xIn
parameter_list|,
name|pass
parameter_list|)
define|\
value|(((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
end_define
begin_define
DECL|macro|PNG_PASS_MASK
define|#
directive|define
name|PNG_PASS_MASK
parameter_list|(
name|pass
parameter_list|,
name|off
parameter_list|)
value|( \    ((0x110145AFU>>(((7-(off))-(pass))<<2))& 0xFU) | \    ((0x01145AF0U>>(((7-(off))-(pass))<<2))& 0xF0U))
end_define
begin_define
DECL|macro|PNG_ROW_IN_INTERLACE_PASS
define|#
directive|define
name|PNG_ROW_IN_INTERLACE_PASS
parameter_list|(
name|y
parameter_list|,
name|pass
parameter_list|)
define|\
value|((PNG_PASS_MASK(pass,0)>> ((y)&7))& 1)
end_define
begin_define
DECL|macro|PNG_COL_IN_INTERLACE_PASS
define|#
directive|define
name|PNG_COL_IN_INTERLACE_PASS
parameter_list|(
name|x
parameter_list|,
name|pass
parameter_list|)
define|\
value|((PNG_PASS_MASK(pass,1)>> ((x)&7))& 1)
end_define
begin_comment
comment|/* These are needed too for the defualt build: */
end_comment
begin_define
DECL|macro|PNG_WRITE_16BIT_SUPPORTED
define|#
directive|define
name|PNG_WRITE_16BIT_SUPPORTED
end_define
begin_define
DECL|macro|PNG_READ_16BIT_SUPPORTED
define|#
directive|define
name|PNG_READ_16BIT_SUPPORTED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"zlib.h"
end_include
begin_comment
comment|/* For crc32 */
end_comment
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_comment
comment|/* For floating point constants */
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_comment
comment|/* For malloc */
end_comment
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/* For memcpy, memset */
end_comment
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_comment
comment|/* For floor */
end_comment
begin_comment
comment|/* Unused formal parameter errors are removed using the following macro which is  * expected to have no bad effects on performance.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_define
DECL|macro|UNUSED
define|#
directive|define
name|UNUSED
parameter_list|(
name|param
parameter_list|)
value|(void)param;
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|UNUSED
define|#
directive|define
name|UNUSED
parameter_list|(
name|param
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/***************************** EXCEPTION HANDLING *****************************/
end_comment
begin_include
include|#
directive|include
file|"contrib/visupng/cexcept.h"
end_include
begin_struct_decl
struct_decl|struct
name|png_store
struct_decl|;
end_struct_decl
begin_expr_stmt
name|define_exception_type
argument_list|(
expr|struct
name|png_store
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* The following are macros to reduce typing everywhere where the well known  * name 'the_exception_context' must be defined.  */
end_comment
begin_define
DECL|macro|anon_context
define|#
directive|define
name|anon_context
parameter_list|(
name|ps
parameter_list|)
value|struct exception_context *the_exception_context = \&(ps)->exception_context
end_define
begin_define
DECL|macro|context
define|#
directive|define
name|context
parameter_list|(
name|ps
parameter_list|,
name|fault
parameter_list|)
value|anon_context(ps); png_store *fault
end_define
begin_comment
comment|/******************************* UTILITIES ************************************/
end_comment
begin_comment
comment|/* Error handling is particularly problematic in production code - error  * handlers often themselves have bugs which lead to programs that detect  * minor errors crashing.  The following functions deal with one very  * common class of errors in error handlers - attempting to format error or  * warning messages into buffers that are too small.  */
end_comment
begin_function
DECL|function|safecat
specifier|static
name|size_t
name|safecat
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|cat
parameter_list|)
block|{
while|while
condition|(
name|pos
operator|<
name|bufsize
operator|&&
name|cat
operator|!=
name|NULL
operator|&&
operator|*
name|cat
operator|!=
literal|0
condition|)
name|buffer
index|[
name|pos
operator|++
index|]
operator|=
operator|*
name|cat
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|bufsize
condition|)
name|pos
operator|=
name|bufsize
operator|-
literal|1
expr_stmt|;
name|buffer
index|[
name|pos
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function
begin_function
DECL|function|safecatn
specifier|static
name|size_t
name|safecatn
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
name|number
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|number
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|number
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|safecatd
specifier|static
name|size_t
name|safecatd
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|double
name|d
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|char
name|number
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|number
argument_list|,
literal|"%.*f"
argument_list|,
name|precision
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|number
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|invalid
specifier|static
name|PNG_CONST
name|char
name|invalid
index|[]
init|=
literal|"invalid"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sep
specifier|static
name|PNG_CONST
name|char
name|sep
index|[]
init|=
literal|": "
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* NOTE: this is indexed by ln2(bit_depth)! */
end_comment
begin_decl_stmt
DECL|variable|bit_depths
specifier|static
name|PNG_CONST
name|char
modifier|*
name|bit_depths
index|[
literal|8
index|]
init|=
block|{
literal|"1"
block|,
literal|"2"
block|,
literal|"4"
block|,
literal|"8"
block|,
literal|"16"
block|,
name|invalid
block|,
name|invalid
block|,
name|invalid
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|colour_types
specifier|static
name|PNG_CONST
name|char
modifier|*
name|colour_types
index|[
literal|8
index|]
init|=
block|{
literal|"greyscale"
block|,
name|invalid
block|,
literal|"truecolour"
block|,
literal|"indexed-colour"
block|,
literal|"greyscale with alpha"
block|,
name|invalid
block|,
literal|"truecolour with alpha"
block|,
name|invalid
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* To get log-bit-depth from bit depth, returns 0 to 7 (7 on error). */
end_comment
begin_function
specifier|static
name|unsigned
name|int
DECL|function|log2depth
name|log2depth
parameter_list|(
name|png_byte
name|bit_depth
parameter_list|)
block|{
switch|switch
condition|(
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|0
return|;
case|case
literal|2
case|:
return|return
literal|1
return|;
case|case
literal|4
case|:
return|return
literal|2
return|;
case|case
literal|8
case|:
return|return
literal|3
return|;
case|case
literal|16
case|:
return|return
literal|4
return|;
default|default:
return|return
literal|7
return|;
block|}
block|}
end_function
begin_comment
comment|/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field  * simply records whether pngvalid did the interlace itself or whether it  * was done by libpng.  Width and height must be less than 256.  */
end_comment
begin_define
DECL|macro|FILEID
define|#
directive|define
name|FILEID
parameter_list|(
name|col
parameter_list|,
name|depth
parameter_list|,
name|interlace
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|do_interlace
parameter_list|)
define|\
value|((png_uint_32)((col) + ((depth)<<3) + ((interlace)<<8) + \     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
end_define
begin_define
DECL|macro|COL_FROM_ID
define|#
directive|define
name|COL_FROM_ID
parameter_list|(
name|id
parameter_list|)
value|((png_byte)((id)& 0x7U))
end_define
begin_define
DECL|macro|DEPTH_FROM_ID
define|#
directive|define
name|DEPTH_FROM_ID
parameter_list|(
name|id
parameter_list|)
value|((png_byte)(((id)>> 3)& 0x1fU))
end_define
begin_define
DECL|macro|INTERLACE_FROM_ID
define|#
directive|define
name|INTERLACE_FROM_ID
parameter_list|(
name|id
parameter_list|)
value|((int)(((id)>> 8)& 0x3))
end_define
begin_define
DECL|macro|DO_INTERLACE_FROM_ID
define|#
directive|define
name|DO_INTERLACE_FROM_ID
parameter_list|(
name|id
parameter_list|)
value|((int)(((id)>>15)& 1))
end_define
begin_define
DECL|macro|WIDTH_FROM_ID
define|#
directive|define
name|WIDTH_FROM_ID
parameter_list|(
name|id
parameter_list|)
value|(((id)>>16)& 0xff)
end_define
begin_define
DECL|macro|HEIGHT_FROM_ID
define|#
directive|define
name|HEIGHT_FROM_ID
parameter_list|(
name|id
parameter_list|)
value|(((id)>>24)& 0xff)
end_define
begin_comment
comment|/* Utility to construct a standard name for a standard image. */
end_comment
begin_function
specifier|static
name|size_t
DECL|function|standard_name
name|standard_name
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|int
name|log_bit_depth
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|png_uint_32
name|w
parameter_list|,
name|png_uint_32
name|h
parameter_list|,
name|int
name|do_interlace
parameter_list|)
block|{
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|colour_types
index|[
name|colour_type
index|]
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|bit_depths
index|[
name|log_bit_depth
index|]
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|" bit "
argument_list|)
expr_stmt|;
if|if
condition|(
name|interlace_type
operator|!=
name|PNG_INTERLACE_NONE
condition|)
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|"interlaced"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_interlace
condition|)
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|"(pngvalid)"
argument_list|)
expr_stmt|;
else|else
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|"(libpng)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0
operator|||
name|h
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
end_function
begin_function
specifier|static
name|size_t
DECL|function|standard_name_from_id
name|standard_name_from_id
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|png_uint_32
name|id
parameter_list|)
block|{
return|return
name|standard_name
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|COL_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|log2depth
argument_list|(
name|DEPTH_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|,
name|INTERLACE_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|WIDTH_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|HEIGHT_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|DO_INTERLACE_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Convenience API and defines to list valid formats.  Note that 16 bit read and  * write support is required to do 16 bit read tests (we must be able to make a  * 16 bit image to test!)  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
end_ifdef
begin_define
DECL|macro|WRITE_BDHI
define|#
directive|define
name|WRITE_BDHI
value|4
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_16BIT_SUPPORTED
end_ifdef
begin_define
DECL|macro|READ_BDHI
define|#
directive|define
name|READ_BDHI
value|4
end_define
begin_define
DECL|macro|DO_16BIT
define|#
directive|define
name|DO_16BIT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|WRITE_BDHI
define|#
directive|define
name|WRITE_BDHI
value|3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|DO_16BIT
end_ifndef
begin_define
DECL|macro|READ_BDHI
define|#
directive|define
name|READ_BDHI
value|3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
specifier|static
name|int
DECL|function|next_format
name|next_format
parameter_list|(
name|png_bytep
name|colour_type
parameter_list|,
name|png_bytep
name|bit_depth
parameter_list|)
block|{
if|if
condition|(
operator|*
name|bit_depth
operator|==
literal|0
condition|)
block|{
operator|*
name|colour_type
operator|=
literal|0
operator|,
operator|*
name|bit_depth
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|bit_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|*
name|bit_depth
operator|<<
literal|1
argument_list|)
expr_stmt|;
comment|/* Palette images are restricted to 8 bit depth */
if|if
condition|(
operator|*
name|bit_depth
operator|<=
literal|8
ifdef|#
directive|ifdef
name|DO_16BIT
operator|||
operator|(
operator|*
name|colour_type
operator|!=
literal|3
operator|&&
operator|*
name|bit_depth
operator|<=
literal|16
operator|)
endif|#
directive|endif
condition|)
return|return
literal|1
return|;
comment|/* Move to the next color type, or return 0 at the end. */
switch|switch
condition|(
operator|*
name|colour_type
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|colour_type
operator|=
literal|2
expr_stmt|;
operator|*
name|bit_depth
operator|=
literal|8
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|2
case|:
operator|*
name|colour_type
operator|=
literal|3
expr_stmt|;
operator|*
name|bit_depth
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|3
case|:
operator|*
name|colour_type
operator|=
literal|4
expr_stmt|;
operator|*
name|bit_depth
operator|=
literal|8
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|4
case|:
operator|*
name|colour_type
operator|=
literal|6
expr_stmt|;
operator|*
name|bit_depth
operator|=
literal|8
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
specifier|static
name|unsigned
name|int
DECL|function|sample
name|sample
parameter_list|(
name|png_const_bytep
name|row
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|,
name|png_uint_32
name|x
parameter_list|,
name|unsigned
name|int
name|sample_index
parameter_list|)
block|{
name|png_uint_32
name|bit_index
decl_stmt|,
name|result
decl_stmt|;
comment|/* Find a sample index for the desired sample: */
name|x
operator|*=
name|bit_depth
expr_stmt|;
name|bit_index
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|(
name|colour_type
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* !palette */
block|{
if|if
condition|(
name|colour_type
operator|&
literal|2
condition|)
name|bit_index
operator|*=
literal|3
expr_stmt|;
if|if
condition|(
name|colour_type
operator|&
literal|4
condition|)
name|bit_index
operator|+=
name|x
expr_stmt|;
comment|/* Alpha channel */
if|if
condition|(
name|colour_type
operator|&
operator|(
literal|2
operator|+
literal|4
operator|)
condition|)
name|bit_index
operator|+=
name|sample_index
operator|*
name|bit_depth
expr_stmt|;
comment|/* Multiple channels: select one */
block|}
comment|/* Return the sample from the row as an integer. */
name|row
operator|+=
name|bit_index
operator|>>
literal|3
expr_stmt|;
name|result
operator|=
operator|*
name|row
expr_stmt|;
if|if
condition|(
name|bit_depth
operator|==
literal|8
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|bit_depth
operator|>
literal|8
condition|)
return|return
operator|(
name|result
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|++
name|row
return|;
comment|/* Less than 8 bits per sample. */
name|bit_index
operator|&=
literal|7
expr_stmt|;
return|return
operator|(
name|result
operator|>>
operator|(
literal|8
operator|-
name|bit_index
operator|-
name|bit_depth
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|bit_depth
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/* Copy a single pixel, of a given size, from one buffer to another -  * while this is basically bit addressed there is an implicit assumption  * that pixels 8 or more bits in size are byte aligned and that pixels  * do not otherwise cross byte boundaries.  (This is, so far as I know,  * universally true in bitmap computer graphics.  [JCB 20101212])  *  * NOTE: The to and from buffers may be the same.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|pixel_copy
name|pixel_copy
parameter_list|(
name|png_bytep
name|toBuffer
parameter_list|,
name|png_uint_32
name|toIndex
parameter_list|,
name|png_const_bytep
name|fromBuffer
parameter_list|,
name|png_uint_32
name|fromIndex
parameter_list|,
name|unsigned
name|int
name|pixelSize
parameter_list|)
block|{
comment|/* Assume we can multiply by 'size' without overflow because we are     * just working in a single buffer.     */
name|toIndex
operator|*=
name|pixelSize
expr_stmt|;
name|fromIndex
operator|*=
name|pixelSize
expr_stmt|;
if|if
condition|(
name|pixelSize
operator|<
literal|8
condition|)
comment|/* Sub-byte */
block|{
comment|/* Mask to select the location of the copied pixel: */
name|unsigned
name|int
name|destMask
init|=
operator|(
operator|(
literal|1U
operator|<<
name|pixelSize
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
literal|8
operator|-
name|pixelSize
operator|-
operator|(
name|toIndex
operator|&
literal|7
operator|)
operator|)
decl_stmt|;
comment|/* The following read the entire pixels and clears the extra: */
name|unsigned
name|int
name|destByte
init|=
name|toBuffer
index|[
name|toIndex
operator|>>
literal|3
index|]
operator|&
operator|~
name|destMask
decl_stmt|;
name|unsigned
name|int
name|sourceByte
init|=
name|fromBuffer
index|[
name|fromIndex
operator|>>
literal|3
index|]
decl_stmt|;
comment|/* Don't rely on<< or>> supporting '0' here, just in case: */
name|fromIndex
operator|&=
literal|7
expr_stmt|;
if|if
condition|(
name|fromIndex
operator|>
literal|0
condition|)
name|sourceByte
operator|<<=
name|fromIndex
expr_stmt|;
if|if
condition|(
operator|(
name|toIndex
operator|&
literal|7
operator|)
operator|>
literal|0
condition|)
name|sourceByte
operator|>>=
name|toIndex
operator|&
literal|7
expr_stmt|;
name|toBuffer
index|[
name|toIndex
operator|>>
literal|3
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|destByte
operator||
operator|(
name|sourceByte
operator|&
name|destMask
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* One or more bytes */
name|memmove
argument_list|(
name|toBuffer
operator|+
operator|(
name|toIndex
operator|>>
literal|3
operator|)
argument_list|,
name|fromBuffer
operator|+
operator|(
name|fromIndex
operator|>>
literal|3
operator|)
argument_list|,
name|pixelSize
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Compare pixels - they are assumed to start at the first byte in the  * given buffers.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|pixel_cmp
name|pixel_cmp
parameter_list|(
name|png_const_bytep
name|pa
parameter_list|,
name|png_const_bytep
name|pb
parameter_list|,
name|png_uint_32
name|bit_width
parameter_list|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|pa
argument_list|,
name|pb
argument_list|,
name|bit_width
operator|>>
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|png_uint_32
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|bit_width
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ok, any differences? */
name|p
operator|=
name|pa
index|[
name|bit_width
operator|>>
literal|3
index|]
expr_stmt|;
name|p
operator|^=
name|pb
index|[
name|bit_width
operator|>>
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* There are, but they may not be significant, remove the bits        * after the end (the low order bits in PNG.)        */
name|bit_width
operator|&=
literal|7
expr_stmt|;
name|p
operator|>>=
literal|8
operator|-
name|bit_width
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* Different */
block|}
end_function
begin_comment
comment|/*************************** BASIC PNG FILE WRITING ***************************/
end_comment
begin_comment
comment|/* A png_store takes data from the sequential writer or provides data  * to the sequential reader.  It can also store the result of a PNG  * write for later retrieval.  */
end_comment
begin_define
DECL|macro|STORE_BUFFER_SIZE
define|#
directive|define
name|STORE_BUFFER_SIZE
value|500
end_define
begin_comment
DECL|macro|STORE_BUFFER_SIZE
comment|/* arbitrary */
end_comment
begin_typedef
DECL|struct|png_store_buffer
typedef|typedef
struct|struct
name|png_store_buffer
block|{
DECL|member|prev
name|struct
name|png_store_buffer
modifier|*
name|prev
decl_stmt|;
comment|/* NOTE: stored in reverse order */
DECL|member|buffer
name|png_byte
name|buffer
index|[
name|STORE_BUFFER_SIZE
index|]
decl_stmt|;
block|}
DECL|typedef|png_store_buffer
name|png_store_buffer
typedef|;
end_typedef
begin_define
DECL|macro|FILE_NAME_SIZE
define|#
directive|define
name|FILE_NAME_SIZE
value|64
end_define
begin_typedef
DECL|struct|png_store_file
typedef|typedef
struct|struct
name|png_store_file
block|{
DECL|member|next
name|struct
name|png_store_file
modifier|*
name|next
decl_stmt|;
comment|/* as many as you like... */
DECL|member|name
name|char
name|name
index|[
name|FILE_NAME_SIZE
index|]
decl_stmt|;
DECL|member|id
name|png_uint_32
name|id
decl_stmt|;
comment|/* must be correct (see FILEID) */
DECL|member|datacount
name|png_size_t
name|datacount
decl_stmt|;
comment|/* In this (the last) buffer */
DECL|member|data
name|png_store_buffer
name|data
decl_stmt|;
comment|/* Last buffer in file */
block|}
DECL|typedef|png_store_file
name|png_store_file
typedef|;
end_typedef
begin_comment
comment|/* The following is a pool of memory allocated by a single libpng read or write  * operation.  */
end_comment
begin_typedef
DECL|struct|store_pool
typedef|typedef
struct|struct
name|store_pool
block|{
DECL|member|store
name|struct
name|png_store
modifier|*
name|store
decl_stmt|;
comment|/* Back pointer */
DECL|member|list
name|struct
name|store_memory
modifier|*
name|list
decl_stmt|;
comment|/* List of allocated memory */
DECL|member|mark
name|png_byte
name|mark
index|[
literal|4
index|]
decl_stmt|;
comment|/* Before and after data */
comment|/* Statistics for this run. */
DECL|member|max
name|png_alloc_size_t
name|max
decl_stmt|;
comment|/* Maximum single allocation */
DECL|member|current
name|png_alloc_size_t
name|current
decl_stmt|;
comment|/* Current allocation */
DECL|member|limit
name|png_alloc_size_t
name|limit
decl_stmt|;
comment|/* Highest current allocation */
DECL|member|total
name|png_alloc_size_t
name|total
decl_stmt|;
comment|/* Total allocation */
comment|/* Overall statistics (retained across successive runs). */
DECL|member|max_max
name|png_alloc_size_t
name|max_max
decl_stmt|;
DECL|member|max_limit
name|png_alloc_size_t
name|max_limit
decl_stmt|;
DECL|member|max_total
name|png_alloc_size_t
name|max_total
decl_stmt|;
block|}
DECL|typedef|store_pool
name|store_pool
typedef|;
end_typedef
begin_typedef
DECL|struct|png_store
typedef|typedef
struct|struct
name|png_store
block|{
comment|/* For cexcept.h exception handling - simply store one of these;     * the context is a self pointer but it may point to a different     * png_store (in fact it never does in this program.)     */
name|struct
name|exception_context
DECL|member|exception_context
name|exception_context
decl_stmt|;
DECL|member|verbose
name|unsigned
name|int
name|verbose
range|:
literal|1
decl_stmt|;
DECL|member|treat_warnings_as_errors
name|unsigned
name|int
name|treat_warnings_as_errors
range|:
literal|1
decl_stmt|;
DECL|member|expect_error
name|unsigned
name|int
name|expect_error
range|:
literal|1
decl_stmt|;
DECL|member|expect_warning
name|unsigned
name|int
name|expect_warning
range|:
literal|1
decl_stmt|;
DECL|member|saw_warning
name|unsigned
name|int
name|saw_warning
range|:
literal|1
decl_stmt|;
DECL|member|speed
name|unsigned
name|int
name|speed
range|:
literal|1
decl_stmt|;
DECL|member|progressive
name|unsigned
name|int
name|progressive
range|:
literal|1
decl_stmt|;
comment|/* use progressive read */
DECL|member|validated
name|unsigned
name|int
name|validated
range|:
literal|1
decl_stmt|;
comment|/* used as a temporary flag */
DECL|member|nerrors
name|int
name|nerrors
decl_stmt|;
DECL|member|nwarnings
name|int
name|nwarnings
decl_stmt|;
DECL|member|test
name|char
name|test
index|[
literal|128
index|]
decl_stmt|;
comment|/* Name of test */
DECL|member|error
name|char
name|error
index|[
literal|256
index|]
decl_stmt|;
comment|/* Read fields */
DECL|member|pread
name|png_structp
name|pread
decl_stmt|;
comment|/* Used to read a saved file */
DECL|member|piread
name|png_infop
name|piread
decl_stmt|;
DECL|member|current
name|png_store_file
modifier|*
name|current
decl_stmt|;
comment|/* Set when reading */
DECL|member|next
name|png_store_buffer
modifier|*
name|next
decl_stmt|;
comment|/* Set when reading */
DECL|member|readpos
name|png_size_t
name|readpos
decl_stmt|;
comment|/* Position in *next */
DECL|member|image
name|png_byte
modifier|*
name|image
decl_stmt|;
comment|/* Buffer for reading interlaced images */
DECL|member|cb_image
name|size_t
name|cb_image
decl_stmt|;
comment|/* Size of this buffer */
DECL|member|read_memory_pool
name|store_pool
name|read_memory_pool
decl_stmt|;
comment|/* Write fields */
DECL|member|saved
name|png_store_file
modifier|*
name|saved
decl_stmt|;
DECL|member|pwrite
name|png_structp
name|pwrite
decl_stmt|;
comment|/* Used when writing a new file */
DECL|member|piwrite
name|png_infop
name|piwrite
decl_stmt|;
DECL|member|writepos
name|png_size_t
name|writepos
decl_stmt|;
comment|/* Position in .new */
DECL|member|wname
name|char
name|wname
index|[
name|FILE_NAME_SIZE
index|]
decl_stmt|;
DECL|member|new
name|png_store_buffer
name|new
decl_stmt|;
comment|/* The end of the new PNG file being written. */
DECL|member|write_memory_pool
name|store_pool
name|write_memory_pool
decl_stmt|;
block|}
DECL|typedef|png_store
name|png_store
typedef|;
end_typedef
begin_comment
comment|/* Initialization and cleanup */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_pool_mark
name|store_pool_mark
parameter_list|(
name|png_byte
modifier|*
name|mark
parameter_list|)
block|{
comment|/* Generate a new mark.  This uses a boring repeatable algorithm and it is     * implemented here so that it gives the same set of numbers on every     * architecture.  It's a linear congruential generator (Knuth or Sedgewick     * "Algorithms") but it comes from the 'feedback taps' table in Horowitz and     * Hill, "The Art of Electronics".     */
specifier|static
name|png_uint_32
name|u0
init|=
literal|0x12345678
decl_stmt|,
name|u1
init|=
literal|1
decl_stmt|;
comment|/* There are thirty three bits, the next bit in the sequence is bit-33 XOR     * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.     */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
comment|/* First generate 8 new bits then shift them in at the end. */
name|png_uint_32
name|u
init|=
operator|(
operator|(
name|u0
operator|>>
operator|(
literal|20
operator|-
literal|8
operator|)
operator|)
operator|^
operator|(
operator|(
name|u1
operator|<<
literal|7
operator|)
operator||
operator|(
name|u0
operator|>>
operator|(
literal|32
operator|-
literal|7
operator|)
operator|)
operator|)
operator|)
operator|&
literal|0xff
decl_stmt|;
name|u1
operator|<<=
literal|8
expr_stmt|;
name|u1
operator||=
name|u0
operator|>>
literal|24
expr_stmt|;
name|u0
operator|<<=
literal|8
expr_stmt|;
name|u0
operator||=
name|u
expr_stmt|;
operator|*
name|mark
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|u
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Use this for random 32 bit values, this function makes sure the result is  * non-zero.  */
end_comment
begin_function
specifier|static
name|png_uint_32
DECL|function|random_32
name|random_32
parameter_list|(
name|void
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|png_byte
name|mark
index|[
literal|4
index|]
decl_stmt|;
name|png_uint_32
name|result
decl_stmt|;
name|store_pool_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|result
operator|=
name|png_get_uint_32
argument_list|(
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_pool_init
name|store_pool_init
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|store_pool
modifier|*
name|pool
parameter_list|)
block|{
name|memset
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|->
name|store
operator|=
name|ps
expr_stmt|;
name|pool
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|max
operator|=
name|pool
operator|->
name|current
operator|=
name|pool
operator|->
name|limit
operator|=
name|pool
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|max_max
operator|=
name|pool
operator|->
name|max_limit
operator|=
name|pool
operator|->
name|max_total
operator|=
literal|0
expr_stmt|;
name|store_pool_mark
argument_list|(
name|pool
operator|->
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_init
name|store_init
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
name|memset
argument_list|(
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ps
argument_list|)
expr_stmt|;
name|init_exception_context
argument_list|(
operator|&
name|ps
operator|->
name|exception_context
argument_list|)
expr_stmt|;
name|store_pool_init
argument_list|(
name|ps
argument_list|,
operator|&
name|ps
operator|->
name|read_memory_pool
argument_list|)
expr_stmt|;
name|store_pool_init
argument_list|(
name|ps
argument_list|,
operator|&
name|ps
operator|->
name|write_memory_pool
argument_list|)
expr_stmt|;
name|ps
operator|->
name|verbose
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|treat_warnings_as_errors
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|expect_error
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|expect_warning
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|saw_warning
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|progressive
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|validated
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|nerrors
operator|=
name|ps
operator|->
name|nwarnings
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|pread
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|piread
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|saved
operator|=
name|ps
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|readpos
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|image
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|cb_image
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|pwrite
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|piwrite
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|writepos
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|new
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This somewhat odd function is used when reading an image to ensure that the  * buffer is big enough - this is why a png_structp is available.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_ensure_image
name|store_ensure_image
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|size_t
name|cb
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|cb_image
operator|<
name|cb
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|image
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ps
operator|->
name|image
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ps
operator|->
name|cb_image
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The buffer is deliberately mis-aligned. */
name|ps
operator|->
name|image
operator|=
name|malloc
argument_list|(
name|cb
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|image
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"OOM allocating image buffer"
argument_list|)
expr_stmt|;
operator|++
operator|(
name|ps
operator|->
name|image
operator|)
expr_stmt|;
name|ps
operator|->
name|cb_image
operator|=
name|cb
expr_stmt|;
block|}
comment|/* And, for error checking, the whole buffer is set to '1' - this     * matches what happens with the 'size' test images on write and also     * matches the unused bits in the test rows.     */
name|memset
argument_list|(
name|ps
operator|->
name|image
argument_list|,
literal|0xff
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_freebuffer
name|store_freebuffer
parameter_list|(
name|png_store_buffer
modifier|*
name|psb
parameter_list|)
block|{
if|if
condition|(
name|psb
operator|->
name|prev
condition|)
block|{
name|store_freebuffer
argument_list|(
name|psb
operator|->
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|psb
operator|->
name|prev
argument_list|)
expr_stmt|;
name|psb
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_freenew
name|store_freenew
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
name|store_freebuffer
argument_list|(
operator|&
name|ps
operator|->
name|new
argument_list|)
expr_stmt|;
name|ps
operator|->
name|writepos
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_storenew
name|store_storenew
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
name|png_store_buffer
modifier|*
name|pb
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|writepos
operator|!=
name|STORE_BUFFER_SIZE
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pwrite
argument_list|,
literal|"invalid store call"
argument_list|)
expr_stmt|;
name|pb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pwrite
argument_list|,
literal|"store new: OOM"
argument_list|)
expr_stmt|;
operator|*
name|pb
operator|=
name|ps
operator|->
name|new
expr_stmt|;
name|ps
operator|->
name|new
operator|.
name|prev
operator|=
name|pb
expr_stmt|;
name|ps
operator|->
name|writepos
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_freefile
name|store_freefile
parameter_list|(
name|png_store_file
modifier|*
modifier|*
name|ppf
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ppf
operator|!=
name|NULL
condition|)
block|{
name|store_freefile
argument_list|(
operator|&
operator|(
operator|*
name|ppf
operator|)
operator|->
name|next
argument_list|)
expr_stmt|;
name|store_freebuffer
argument_list|(
operator|&
operator|(
operator|*
name|ppf
operator|)
operator|->
name|data
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ppf
operator|)
operator|->
name|datacount
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|*
name|ppf
argument_list|)
expr_stmt|;
operator|*
name|ppf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Main interface to file storeage, after writing a new PNG file (see the API  * below) call store_storefile to store the result with the given name and id.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_storefile
name|store_storefile
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_uint_32
name|id
parameter_list|)
block|{
name|png_store_file
modifier|*
name|pf
init|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pf
argument_list|)
decl_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pwrite
argument_list|,
literal|"storefile: OOM"
argument_list|)
expr_stmt|;
name|safecat
argument_list|(
name|pf
operator|->
name|name
argument_list|,
sizeof|sizeof
name|pf
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|ps
operator|->
name|wname
argument_list|)
expr_stmt|;
name|pf
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|pf
operator|->
name|data
operator|=
name|ps
operator|->
name|new
expr_stmt|;
name|pf
operator|->
name|datacount
operator|=
name|ps
operator|->
name|writepos
expr_stmt|;
name|ps
operator|->
name|new
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|writepos
operator|=
literal|0
expr_stmt|;
comment|/* And save it. */
name|pf
operator|->
name|next
operator|=
name|ps
operator|->
name|saved
expr_stmt|;
name|ps
operator|->
name|saved
operator|=
name|pf
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Generate an error message (in the given buffer) */
end_comment
begin_function
specifier|static
name|size_t
DECL|function|store_message
name|store_message
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|pp
operator|==
name|ps
operator|->
name|pread
condition|)
block|{
comment|/* Reading a file */
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|"read: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|current
operator|!=
name|NULL
condition|)
block|{
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|ps
operator|->
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|pp
operator|==
name|ps
operator|->
name|pwrite
condition|)
block|{
comment|/* Writing a file */
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|"write: "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|ps
operator|->
name|wname
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Neither reading nor writing (or a memory error in struct delete) */
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
literal|"pngvalid: "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|test
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|ps
operator|->
name|test
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pos
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function
begin_comment
comment|/* Log an error or warning - the relevant count is always incremented. */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_log
name|store_log
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_const_charp
name|message
parameter_list|,
name|int
name|is_error
parameter_list|)
block|{
comment|/* The warning is copied to the error buffer if there are no errors and it is     * the first warning.  The error is copied to the error buffer if it is the     * first error (overwriting any prior warnings).     */
if|if
condition|(
name|is_error
condition|?
operator|(
name|ps
operator|->
name|nerrors
operator|)
operator|++
operator|==
literal|0
else|:
operator|(
name|ps
operator|->
name|nwarnings
operator|)
operator|++
operator|==
literal|0
operator|&&
name|ps
operator|->
name|nerrors
operator|==
literal|0
condition|)
name|store_message
argument_list|(
name|ps
argument_list|,
name|pp
argument_list|,
name|ps
operator|->
name|error
argument_list|,
sizeof|sizeof
name|ps
operator|->
name|error
argument_list|,
literal|0
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|verbose
condition|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|size_t
name|pos
decl_stmt|;
if|if
condition|(
name|is_error
condition|)
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|0
argument_list|,
literal|"error: "
argument_list|)
expr_stmt|;
else|else
name|pos
operator|=
name|safecat
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|0
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|store_message
argument_list|(
name|ps
argument_list|,
name|pp
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|pos
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Functions to use as PNG callbacks. */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_error
name|store_error
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_const_charp
name|message
parameter_list|)
comment|/* PNG_NORETURN */
block|{
name|png_store
modifier|*
name|ps
init|=
name|png_get_error_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ps
operator|->
name|expect_error
condition|)
name|store_log
argument_list|(
name|ps
argument_list|,
name|pp
argument_list|,
name|message
argument_list|,
literal|1
comment|/* error */
argument_list|)
expr_stmt|;
comment|/* And finally throw an exception. */
block|{
name|struct
name|exception_context
modifier|*
name|the_exception_context
init|=
operator|&
name|ps
operator|->
name|exception_context
decl_stmt|;
name|Throw
name|ps
decl_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_warning
name|store_warning
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_const_charp
name|message
parameter_list|)
block|{
name|png_store
modifier|*
name|ps
init|=
name|png_get_error_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ps
operator|->
name|expect_warning
condition|)
name|store_log
argument_list|(
name|ps
argument_list|,
name|pp
argument_list|,
name|message
argument_list|,
literal|0
comment|/* warning */
argument_list|)
expr_stmt|;
else|else
name|ps
operator|->
name|saw_warning
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_write
name|store_write
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_bytep
name|pb
parameter_list|,
name|png_size_t
name|st
parameter_list|)
block|{
name|png_store
modifier|*
name|ps
init|=
name|png_get_io_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|pwrite
operator|!=
name|pp
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"store state damaged"
argument_list|)
expr_stmt|;
while|while
condition|(
name|st
operator|>
literal|0
condition|)
block|{
name|size_t
name|cb
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|writepos
operator|>=
name|STORE_BUFFER_SIZE
condition|)
name|store_storenew
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|cb
operator|=
name|st
expr_stmt|;
if|if
condition|(
name|cb
operator|>
name|STORE_BUFFER_SIZE
operator|-
name|ps
operator|->
name|writepos
condition|)
name|cb
operator|=
name|STORE_BUFFER_SIZE
operator|-
name|ps
operator|->
name|writepos
expr_stmt|;
name|memcpy
argument_list|(
name|ps
operator|->
name|new
operator|.
name|buffer
operator|+
name|ps
operator|->
name|writepos
argument_list|,
name|pb
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|pb
operator|+=
name|cb
expr_stmt|;
name|st
operator|-=
name|cb
expr_stmt|;
name|ps
operator|->
name|writepos
operator|+=
name|cb
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_flush
name|store_flush
parameter_list|(
name|png_structp
name|pp
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|pp
argument_list|)
comment|/*DOES NOTHING*/
block|}
end_function
begin_function
specifier|static
name|size_t
DECL|function|store_read_buffer_size
name|store_read_buffer_size
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
comment|/* Return the bytes available for read in the current buffer. */
if|if
condition|(
name|ps
operator|->
name|next
operator|!=
operator|&
name|ps
operator|->
name|current
operator|->
name|data
condition|)
return|return
name|STORE_BUFFER_SIZE
return|;
return|return
name|ps
operator|->
name|current
operator|->
name|datacount
return|;
block|}
end_function
begin_comment
comment|/* Return total bytes available for read. */
end_comment
begin_function
specifier|static
name|size_t
DECL|function|store_read_buffer_avail
name|store_read_buffer_avail
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|current
operator|!=
name|NULL
operator|&&
name|ps
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|png_store_buffer
modifier|*
name|next
init|=
operator|&
name|ps
operator|->
name|current
operator|->
name|data
decl_stmt|;
name|size_t
name|cbAvail
init|=
name|ps
operator|->
name|current
operator|->
name|datacount
decl_stmt|;
while|while
condition|(
name|next
operator|!=
name|ps
operator|->
name|next
operator|&&
name|next
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|prev
expr_stmt|;
name|cbAvail
operator|+=
name|STORE_BUFFER_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|ps
operator|->
name|next
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pread
argument_list|,
literal|"buffer read error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbAvail
operator|>
name|ps
operator|->
name|readpos
condition|)
return|return
name|cbAvail
operator|-
name|ps
operator|->
name|readpos
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|store_read_buffer_next
name|store_read_buffer_next
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
name|png_store_buffer
modifier|*
name|pbOld
init|=
name|ps
operator|->
name|next
decl_stmt|;
name|png_store_buffer
modifier|*
name|pbNew
init|=
operator|&
name|ps
operator|->
name|current
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|pbOld
operator|!=
name|pbNew
condition|)
block|{
while|while
condition|(
name|pbNew
operator|!=
name|NULL
operator|&&
name|pbNew
operator|->
name|prev
operator|!=
name|pbOld
condition|)
name|pbNew
operator|=
name|pbNew
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|pbNew
operator|!=
name|NULL
condition|)
block|{
name|ps
operator|->
name|next
operator|=
name|pbNew
expr_stmt|;
name|ps
operator|->
name|readpos
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|png_error
argument_list|(
name|ps
operator|->
name|pread
argument_list|,
literal|"buffer lost"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* EOF or error */
block|}
end_function
begin_comment
comment|/* Need separate implementation and callback to allow use of the same code  * during progressive read, where the io_ptr is set internally by libpng.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_read_imp
name|store_read_imp
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_bytep
name|pb
parameter_list|,
name|png_size_t
name|st
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|current
operator|==
name|NULL
operator|||
name|ps
operator|->
name|next
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pread
argument_list|,
literal|"store state damaged"
argument_list|)
expr_stmt|;
while|while
condition|(
name|st
operator|>
literal|0
condition|)
block|{
name|size_t
name|cbAvail
init|=
name|store_read_buffer_size
argument_list|(
name|ps
argument_list|)
operator|-
name|ps
operator|->
name|readpos
decl_stmt|;
if|if
condition|(
name|cbAvail
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cbAvail
operator|>
name|st
condition|)
name|cbAvail
operator|=
name|st
expr_stmt|;
name|memcpy
argument_list|(
name|pb
argument_list|,
name|ps
operator|->
name|next
operator|->
name|buffer
operator|+
name|ps
operator|->
name|readpos
argument_list|,
name|cbAvail
argument_list|)
expr_stmt|;
name|st
operator|-=
name|cbAvail
expr_stmt|;
name|pb
operator|+=
name|cbAvail
expr_stmt|;
name|ps
operator|->
name|readpos
operator|+=
name|cbAvail
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|store_read_buffer_next
argument_list|(
name|ps
argument_list|)
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pread
argument_list|,
literal|"read beyond end of file"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_read
name|store_read
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_bytep
name|pb
parameter_list|,
name|png_size_t
name|st
parameter_list|)
block|{
name|png_store
modifier|*
name|ps
init|=
name|png_get_io_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
operator|||
name|ps
operator|->
name|pread
operator|!=
name|pp
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"bad store read call"
argument_list|)
expr_stmt|;
name|store_read_imp
argument_list|(
name|ps
argument_list|,
name|pb
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_progressive_read
name|store_progressive_read
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
comment|/* Notice that a call to store_read will cause this function to fail because     * readpos will be set.     */
if|if
condition|(
name|ps
operator|->
name|pread
operator|!=
name|pp
operator|||
name|ps
operator|->
name|current
operator|==
name|NULL
operator|||
name|ps
operator|->
name|next
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"store state damaged (progressive)"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ps
operator|->
name|readpos
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"store_read called during progressive read"
argument_list|)
expr_stmt|;
name|png_process_data
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|ps
operator|->
name|next
operator|->
name|buffer
argument_list|,
name|store_read_buffer_size
argument_list|(
name|ps
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|store_read_buffer_next
argument_list|(
name|ps
argument_list|)
condition|)
do|;
block|}
end_function
begin_comment
comment|/***************************** MEMORY MANAGEMENT*** ***************************/
end_comment
begin_comment
comment|/* A store_memory is simply the header for an allocated block of memory.  The  * pointer returned to libpng is just after the end of the header block, the  * allocated memory is followed by a second copy of the 'mark'.  */
end_comment
begin_typedef
DECL|struct|store_memory
typedef|typedef
struct|struct
name|store_memory
block|{
DECL|member|pool
name|store_pool
modifier|*
name|pool
decl_stmt|;
comment|/* Originating pool */
DECL|member|next
name|struct
name|store_memory
modifier|*
name|next
decl_stmt|;
comment|/* Singly linked list */
DECL|member|size
name|png_alloc_size_t
name|size
decl_stmt|;
comment|/* Size of memory allocated */
DECL|member|mark
name|png_byte
name|mark
index|[
literal|4
index|]
decl_stmt|;
comment|/* ID marker */
block|}
DECL|typedef|store_memory
name|store_memory
typedef|;
end_typedef
begin_comment
comment|/* Handle a fatal error in memory allocation.  This calls png_error if the  * libpng struct is non-NULL, else it outputs a message and returns.  This means  * that a memory problem while libpng is running will abort (png_error) the  * handling of particular file while one in cleanup (after the destroy of the  * struct has returned) will simply keep going and free (or attempt to free)  * all the memory.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_pool_error
name|store_pool_error
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Else we have to do it ourselves.  png_error eventually calls store_log,     * above.  store_log accepts a NULL png_structp - it just changes what gets     * output by store_message.     */
name|store_log
argument_list|(
name|ps
argument_list|,
name|pp
argument_list|,
name|msg
argument_list|,
literal|1
comment|/* error */
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_memory_free
name|store_memory_free
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|store_pool
modifier|*
name|pool
parameter_list|,
name|store_memory
modifier|*
name|memory
parameter_list|)
block|{
comment|/* Note that pp may be NULL (see store_pool_delete below), the caller has     * found 'memory' in pool->list *and* unlinked this entry, so this is a valid     * pointer (for sure), but the contents may have been trashed.     */
if|if
condition|(
name|memory
operator|->
name|pool
operator|!=
name|pool
condition|)
name|store_pool_error
argument_list|(
name|pool
operator|->
name|store
argument_list|,
name|pp
argument_list|,
literal|"memory corrupted (pool)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|memory
operator|->
name|mark
argument_list|,
name|pool
operator|->
name|mark
argument_list|,
sizeof|sizeof
name|memory
operator|->
name|mark
argument_list|)
operator|!=
literal|0
condition|)
name|store_pool_error
argument_list|(
name|pool
operator|->
name|store
argument_list|,
name|pp
argument_list|,
literal|"memory corrupted (start)"
argument_list|)
expr_stmt|;
comment|/* It should be safe to read the size field now. */
else|else
block|{
name|png_alloc_size_t
name|cb
init|=
name|memory
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|cb
operator|>
name|pool
operator|->
name|max
condition|)
name|store_pool_error
argument_list|(
name|pool
operator|->
name|store
argument_list|,
name|pp
argument_list|,
literal|"memory corrupted (size)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
call|(
name|png_bytep
call|)
argument_list|(
name|memory
operator|+
literal|1
argument_list|)
operator|+
name|cb
argument_list|,
name|pool
operator|->
name|mark
argument_list|,
sizeof|sizeof
name|pool
operator|->
name|mark
argument_list|)
operator|!=
literal|0
condition|)
name|store_pool_error
argument_list|(
name|pool
operator|->
name|store
argument_list|,
name|pp
argument_list|,
literal|"memory corrupted (end)"
argument_list|)
expr_stmt|;
comment|/* Finally give the library a chance to find problems too: */
else|else
block|{
name|pool
operator|->
name|current
operator|-=
name|cb
expr_stmt|;
name|free
argument_list|(
name|memory
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_pool_delete
name|store_pool_delete
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|store_pool
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|->
name|list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s %s: memory lost (list follows):\n"
argument_list|,
name|ps
operator|->
name|test
argument_list|,
name|pool
operator|==
operator|&
name|ps
operator|->
name|read_memory_pool
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|pool
operator|==
operator|&
name|ps
operator|->
name|read_memory_pool
condition|?
operator|(
name|ps
operator|->
name|current
operator|!=
name|NULL
condition|?
name|ps
operator|->
name|current
operator|->
name|name
else|:
literal|"unknown file"
operator|)
else|:
name|ps
operator|->
name|wname
argument_list|)
expr_stmt|;
operator|++
name|ps
operator|->
name|nerrors
expr_stmt|;
do|do
block|{
name|store_memory
modifier|*
name|next
init|=
name|pool
operator|->
name|list
decl_stmt|;
name|pool
operator|->
name|list
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%lu bytes @ %p\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|next
operator|->
name|size
argument_list|,
name|next
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* The NULL means this will always return, even if the memory is           * corrupted.           */
name|store_memory_free
argument_list|(
name|NULL
argument_list|,
name|pool
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pool
operator|->
name|list
operator|!=
name|NULL
condition|)
do|;
block|}
comment|/* And reset the other fields too for the next time. */
if|if
condition|(
name|pool
operator|->
name|max
operator|>
name|pool
operator|->
name|max_max
condition|)
name|pool
operator|->
name|max_max
operator|=
name|pool
operator|->
name|max
expr_stmt|;
name|pool
operator|->
name|max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|current
operator|!=
literal|0
condition|)
comment|/* unexpected internal error */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s %s: memory counter mismatch (internal error)\n"
argument_list|,
name|ps
operator|->
name|test
argument_list|,
name|pool
operator|==
operator|&
name|ps
operator|->
name|read_memory_pool
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|pool
operator|==
operator|&
name|ps
operator|->
name|read_memory_pool
condition|?
operator|(
name|ps
operator|->
name|current
operator|!=
name|NULL
condition|?
name|ps
operator|->
name|current
operator|->
name|name
else|:
literal|"unknown file"
operator|)
else|:
name|ps
operator|->
name|wname
argument_list|)
expr_stmt|;
name|pool
operator|->
name|current
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|limit
operator|>
name|pool
operator|->
name|max_limit
condition|)
name|pool
operator|->
name|max_limit
operator|=
name|pool
operator|->
name|limit
expr_stmt|;
name|pool
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|total
operator|>
name|pool
operator|->
name|max_total
condition|)
name|pool
operator|->
name|max_total
operator|=
name|pool
operator|->
name|total
expr_stmt|;
name|pool
operator|->
name|total
operator|=
literal|0
expr_stmt|;
comment|/* Get a new mark too. */
name|store_pool_mark
argument_list|(
name|pool
operator|->
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* The memory callbacks: */
end_comment
begin_function
specifier|static
name|png_voidp
DECL|function|store_malloc
name|store_malloc
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_alloc_size_t
name|cb
parameter_list|)
block|{
name|store_pool
modifier|*
name|pool
init|=
name|png_get_mem_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|store_memory
modifier|*
name|new
init|=
name|malloc
argument_list|(
name|cb
operator|+
operator|(
sizeof|sizeof
expr|*
name|new
operator|)
operator|+
operator|(
sizeof|sizeof
name|pool
operator|->
name|mark
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cb
operator|>
name|pool
operator|->
name|max
condition|)
name|pool
operator|->
name|max
operator|=
name|cb
expr_stmt|;
name|pool
operator|->
name|current
operator|+=
name|cb
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|current
operator|>
name|pool
operator|->
name|limit
condition|)
name|pool
operator|->
name|limit
operator|=
name|pool
operator|->
name|current
expr_stmt|;
name|pool
operator|->
name|total
operator|+=
name|cb
expr_stmt|;
name|new
operator|->
name|size
operator|=
name|cb
expr_stmt|;
name|memcpy
argument_list|(
name|new
operator|->
name|mark
argument_list|,
name|pool
operator|->
name|mark
argument_list|,
sizeof|sizeof
name|new
operator|->
name|mark
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|png_byte
operator|*
operator|)
operator|(
name|new
operator|+
literal|1
operator|)
operator|+
name|cb
argument_list|,
name|pool
operator|->
name|mark
argument_list|,
sizeof|sizeof
name|pool
operator|->
name|mark
argument_list|)
expr_stmt|;
name|new
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|pool
operator|->
name|list
expr_stmt|;
name|pool
operator|->
name|list
operator|=
name|new
expr_stmt|;
operator|++
name|new
expr_stmt|;
block|}
else|else
name|store_pool_error
argument_list|(
name|pool
operator|->
name|store
argument_list|,
name|pp
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_free
name|store_free
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_voidp
name|memory
parameter_list|)
block|{
name|store_pool
modifier|*
name|pool
init|=
name|png_get_mem_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|store_memory
modifier|*
name|this
init|=
name|memory
decl_stmt|,
modifier|*
modifier|*
name|test
decl_stmt|;
comment|/* First check that this 'memory' really is valid memory - it must be in the     * pool list.  If it is, use the shared memory_free function to free it.     */
operator|--
name|this
expr_stmt|;
for|for
control|(
name|test
operator|=
operator|&
name|pool
operator|->
name|list
init|;
operator|*
name|test
operator|!=
name|this
condition|;
name|test
operator|=
operator|&
operator|(
operator|*
name|test
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|test
operator|==
name|NULL
condition|)
block|{
name|store_pool_error
argument_list|(
name|pool
operator|->
name|store
argument_list|,
name|pp
argument_list|,
literal|"bad pointer to free"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Unlink this entry, *test == this. */
operator|*
name|test
operator|=
name|this
operator|->
name|next
expr_stmt|;
name|this
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|store_memory_free
argument_list|(
name|pp
argument_list|,
name|pool
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Setup functions. */
end_comment
begin_comment
comment|/* Cleanup when aborting a write or after storing the new file. */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_write_reset
name|store_write_reset
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|pwrite
operator|!=
name|NULL
condition|)
block|{
name|anon_context
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|Try
name|png_destroy_write_struct
argument_list|(
operator|&
name|ps
operator|->
name|pwrite
argument_list|,
operator|&
name|ps
operator|->
name|piwrite
argument_list|)
decl_stmt|;
name|Catch_anonymous
block|{
comment|/* memory corruption: continue. */
block|}
name|ps
operator|->
name|pwrite
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|piwrite
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* And make sure that all the memory has been freed - this will output     * spurious errors in the case of memory corruption above, but this is safe.     */
name|store_pool_delete
argument_list|(
name|ps
argument_list|,
operator|&
name|ps
operator|->
name|write_memory_pool
argument_list|)
expr_stmt|;
name|store_freenew
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* The following is the main write function, it returns a png_struct and,  * optionally, a png_info suitable for writiing a new PNG file.  Use  * store_storefile above to record this file after it has been written.  The  * returned libpng structures as destroyed by store_write_reset above.  */
end_comment
begin_function
specifier|static
name|png_structp
DECL|function|set_store_for_write
name|set_store_for_write
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_infopp
name|ppi
parameter_list|,
name|PNG_CONST
name|char
modifier|*
specifier|volatile
name|name
parameter_list|)
block|{
name|anon_context
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|Try
block|{
if|if
condition|(
name|ps
operator|->
name|pwrite
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pwrite
argument_list|,
literal|"write store already in use"
argument_list|)
expr_stmt|;
name|store_write_reset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|safecat
argument_list|(
name|ps
operator|->
name|wname
argument_list|,
sizeof|sizeof
name|ps
operator|->
name|wname
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Don't do the slow memory checks if doing a speed test. */
if|if
condition|(
name|ps
operator|->
name|speed
condition|)
name|ps
operator|->
name|pwrite
operator|=
name|png_create_write_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|ps
argument_list|,
name|store_error
argument_list|,
name|store_warning
argument_list|)
expr_stmt|;
else|else
name|ps
operator|->
name|pwrite
operator|=
name|png_create_write_struct_2
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|ps
argument_list|,
name|store_error
argument_list|,
name|store_warning
argument_list|,
operator|&
name|ps
operator|->
name|write_memory_pool
argument_list|,
name|store_malloc
argument_list|,
name|store_free
argument_list|)
expr_stmt|;
name|png_set_write_fn
argument_list|(
name|ps
operator|->
name|pwrite
argument_list|,
name|ps
argument_list|,
name|store_write
argument_list|,
name|store_flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppi
operator|!=
name|NULL
condition|)
operator|*
name|ppi
operator|=
name|ps
operator|->
name|piwrite
operator|=
name|png_create_info_struct
argument_list|(
name|ps
operator|->
name|pwrite
argument_list|)
expr_stmt|;
block|}
name|Catch_anonymous
return|return
name|NULL
return|;
return|return
name|ps
operator|->
name|pwrite
return|;
block|}
end_function
begin_comment
comment|/* Cleanup when finished reading (either due to error or in the success case).  */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_read_reset
name|store_read_reset
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|pread
operator|!=
name|NULL
condition|)
block|{
name|anon_context
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|Try
name|png_destroy_read_struct
argument_list|(
operator|&
name|ps
operator|->
name|pread
argument_list|,
operator|&
name|ps
operator|->
name|piread
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|Catch_anonymous
block|{
comment|/* error already output: continue */
block|}
name|ps
operator|->
name|pread
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|piread
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Always do this to be safe. */
name|store_pool_delete
argument_list|(
name|ps
argument_list|,
operator|&
name|ps
operator|->
name|read_memory_pool
argument_list|)
expr_stmt|;
name|ps
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|readpos
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|validated
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|store_read_set
name|store_read_set
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_uint_32
name|id
parameter_list|)
block|{
name|png_store_file
modifier|*
name|pf
init|=
name|ps
operator|->
name|saved
decl_stmt|;
while|while
condition|(
name|pf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pf
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|ps
operator|->
name|current
operator|=
name|pf
expr_stmt|;
name|ps
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|store_read_buffer_next
argument_list|(
name|ps
argument_list|)
expr_stmt|;
return|return;
block|}
name|pf
operator|=
name|pf
operator|->
name|next
expr_stmt|;
block|}
block|{
name|size_t
name|pos
decl_stmt|;
name|char
name|msg
index|[
name|FILE_NAME_SIZE
operator|+
literal|64
index|]
decl_stmt|;
name|pos
operator|=
name|standard_name_from_id
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|pos
argument_list|,
literal|": file not found"
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|ps
operator|->
name|pread
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* The main interface for reading a saved file - pass the id number of the file  * to retrieve.  Ids must be unique or the earlier file will be hidden.  The API  * returns a png_struct and, optionally, a png_info.  Both of these will be  * destroyed by store_read_reset above.  */
end_comment
begin_function
specifier|static
name|png_structp
DECL|function|set_store_for_read
name|set_store_for_read
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_infopp
name|ppi
parameter_list|,
name|png_uint_32
name|id
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Set the name for png_error */
name|safecat
argument_list|(
name|ps
operator|->
name|test
argument_list|,
sizeof|sizeof
name|ps
operator|->
name|test
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|pread
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|ps
operator|->
name|pread
argument_list|,
literal|"read store already in use"
argument_list|)
expr_stmt|;
name|store_read_reset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* Both the create APIs can return NULL if used in their default mode     * (because there is no other way of handling an error because the jmp_buf     * by default is stored in png_struct and that has not been allocated!)     * However, given that store_error works correctly in these circumstances     * we don't ever expect NULL in this program.     */
if|if
condition|(
name|ps
operator|->
name|speed
condition|)
name|ps
operator|->
name|pread
operator|=
name|png_create_read_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|ps
argument_list|,
name|store_error
argument_list|,
name|store_warning
argument_list|)
expr_stmt|;
else|else
name|ps
operator|->
name|pread
operator|=
name|png_create_read_struct_2
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
name|ps
argument_list|,
name|store_error
argument_list|,
name|store_warning
argument_list|,
operator|&
name|ps
operator|->
name|read_memory_pool
argument_list|,
name|store_malloc
argument_list|,
name|store_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|pread
operator|==
name|NULL
condition|)
block|{
name|struct
name|exception_context
modifier|*
name|the_exception_context
init|=
operator|&
name|ps
operator|->
name|exception_context
decl_stmt|;
name|store_log
argument_list|(
name|ps
argument_list|,
name|NULL
argument_list|,
literal|"png_create_read_struct returned NULL (unexpected)"
argument_list|,
literal|1
comment|/*error*/
argument_list|)
expr_stmt|;
name|Throw
name|ps
decl_stmt|;
block|}
name|store_read_set
argument_list|(
name|ps
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppi
operator|!=
name|NULL
condition|)
operator|*
name|ppi
operator|=
name|ps
operator|->
name|piread
operator|=
name|png_create_info_struct
argument_list|(
name|ps
operator|->
name|pread
argument_list|)
expr_stmt|;
return|return
name|ps
operator|->
name|pread
return|;
block|}
end_function
begin_comment
comment|/* The overall cleanup of a store simply calls the above then removes all the  * saved files.  This does not delete the store itself.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|store_delete
name|store_delete
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
name|store_write_reset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|store_read_reset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|store_freefile
argument_list|(
operator|&
name|ps
operator|->
name|saved
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|image
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ps
operator|->
name|image
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ps
operator|->
name|image
operator|=
name|NULL
expr_stmt|;
name|ps
operator|->
name|cb_image
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*********************** PNG FILE MODIFICATION ON READ ************************/
end_comment
begin_comment
comment|/* Files may be modified on read.  The following structure contains a complete  * png_store together with extra members to handle modification and a special  * read callback for libpng.  To use this the 'modifications' field must be set  * to a list of png_modification structures that actually perform the  * modification, otherwise a png_modifier is functionally equivalent to a  * png_store.  There is a special read function, set_modifier_for_read, which  * replaces set_store_for_read.  */
end_comment
begin_typedef
DECL|struct|png_modifier
typedef|typedef
struct|struct
name|png_modifier
block|{
DECL|member|this
name|png_store
name|this
decl_stmt|;
comment|/* I am a png_store */
DECL|member|modifications
name|struct
name|png_modification
modifier|*
name|modifications
decl_stmt|;
comment|/* Changes to make */
DECL|enum|modifier_state
enum|enum
name|modifier_state
block|{
DECL|enumerator|modifier_start
name|modifier_start
block|,
comment|/* Initial value */
DECL|enumerator|modifier_signature
name|modifier_signature
block|,
comment|/* Have a signature */
DECL|enumerator|modifier_IHDR
name|modifier_IHDR
comment|/* Have an IHDR */
block|}
DECL|member|state
name|state
enum|;
comment|/* My state */
comment|/* Information from IHDR: */
DECL|member|bit_depth
name|png_byte
name|bit_depth
decl_stmt|;
comment|/* From IHDR */
DECL|member|colour_type
name|png_byte
name|colour_type
decl_stmt|;
comment|/* From IHDR */
comment|/* While handling PLTE, IDAT and IEND these chunks may be pended to allow     * other chunks to be inserted.     */
DECL|member|pending_len
name|png_uint_32
name|pending_len
decl_stmt|;
DECL|member|pending_chunk
name|png_uint_32
name|pending_chunk
decl_stmt|;
comment|/* Test values */
DECL|member|gammas
name|double
modifier|*
name|gammas
decl_stmt|;
DECL|member|ngammas
name|unsigned
name|int
name|ngammas
decl_stmt|;
comment|/* Lowest sbit to test (libpng fails for sbit< 8) */
DECL|member|sbitlow
name|png_byte
name|sbitlow
decl_stmt|;
comment|/* Error control - these are the limits on errors accepted by the gamma tests     * below.     */
DECL|member|maxout8
name|double
name|maxout8
decl_stmt|;
comment|/* Maximum output value error */
DECL|member|maxabs8
name|double
name|maxabs8
decl_stmt|;
comment|/* Absolute sample error 0..1 */
DECL|member|maxpc8
name|double
name|maxpc8
decl_stmt|;
comment|/* Percentage sample error 0..100% */
DECL|member|maxout16
name|double
name|maxout16
decl_stmt|;
comment|/* Maximum output value error */
DECL|member|maxabs16
name|double
name|maxabs16
decl_stmt|;
comment|/* Absolute sample error 0..1 */
DECL|member|maxpc16
name|double
name|maxpc16
decl_stmt|;
comment|/* Percentage sample error 0..100% */
comment|/* Logged 8 and 16 bit errors ('output' values): */
DECL|member|error_gray_2
name|double
name|error_gray_2
decl_stmt|;
DECL|member|error_gray_4
name|double
name|error_gray_4
decl_stmt|;
DECL|member|error_gray_8
name|double
name|error_gray_8
decl_stmt|;
DECL|member|error_gray_16
name|double
name|error_gray_16
decl_stmt|;
DECL|member|error_color_8
name|double
name|error_color_8
decl_stmt|;
DECL|member|error_color_16
name|double
name|error_color_16
decl_stmt|;
comment|/* Flags: */
comment|/* Whether or not to interlace. */
DECL|member|interlace_type
name|int
name|interlace_type
range|:
literal|9
decl_stmt|;
comment|/* int, but must store '1' */
comment|/* Run the standard tests? */
DECL|member|test_standard
name|unsigned
name|int
name|test_standard
range|:
literal|1
decl_stmt|;
comment|/* Run the odd-sized image and interlace read/write tests? */
DECL|member|test_size
name|unsigned
name|int
name|test_size
range|:
literal|1
decl_stmt|;
comment|/* Run tests on reading with a combiniation of transforms, */
DECL|member|test_transform
name|unsigned
name|int
name|test_transform
range|:
literal|1
decl_stmt|;
comment|/* When to use the use_input_precision option: */
DECL|member|use_input_precision
name|unsigned
name|int
name|use_input_precision
range|:
literal|1
decl_stmt|;
DECL|member|use_input_precision_sbit
name|unsigned
name|int
name|use_input_precision_sbit
range|:
literal|1
decl_stmt|;
DECL|member|use_input_precision_16to8
name|unsigned
name|int
name|use_input_precision_16to8
range|:
literal|1
decl_stmt|;
comment|/* Which gamma tests to run: */
DECL|member|test_gamma_threshold
name|unsigned
name|int
name|test_gamma_threshold
range|:
literal|1
decl_stmt|;
DECL|member|test_gamma_transform
name|unsigned
name|int
name|test_gamma_transform
range|:
literal|1
decl_stmt|;
comment|/* main tests */
DECL|member|test_gamma_sbit
name|unsigned
name|int
name|test_gamma_sbit
range|:
literal|1
decl_stmt|;
DECL|member|test_gamma_strip16
name|unsigned
name|int
name|test_gamma_strip16
range|:
literal|1
decl_stmt|;
DECL|member|log
name|unsigned
name|int
name|log
range|:
literal|1
decl_stmt|;
comment|/* Log max error */
comment|/* Buffer information, the buffer size limits the size of the chunks that can     * be modified - they must fit (including header and CRC) into the buffer!     */
DECL|member|flush
name|size_t
name|flush
decl_stmt|;
comment|/* Count of bytes to flush */
DECL|member|buffer_count
name|size_t
name|buffer_count
decl_stmt|;
comment|/* Bytes in buffer */
DECL|member|buffer_position
name|size_t
name|buffer_position
decl_stmt|;
comment|/* Position in buffer */
DECL|member|buffer
name|png_byte
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
block|}
DECL|typedef|png_modifier
name|png_modifier
typedef|;
end_typedef
begin_function
DECL|function|abserr
specifier|static
name|double
name|abserr
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
return|return
name|bit_depth
operator|==
literal|16
condition|?
name|pm
operator|->
name|maxabs16
else|:
name|pm
operator|->
name|maxabs8
return|;
block|}
end_function
begin_function
DECL|function|pcerr
specifier|static
name|double
name|pcerr
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
return|return
operator|(
name|bit_depth
operator|==
literal|16
condition|?
name|pm
operator|->
name|maxpc16
else|:
name|pm
operator|->
name|maxpc8
operator|)
operator|*
literal|.01
return|;
block|}
end_function
begin_function
DECL|function|outerr
specifier|static
name|double
name|outerr
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
comment|/* There is a serious error in the 2 and 4 bit grayscale transform because     * the gamma table value (8 bits) is simply shifted, not rounded, so the     * error in 4 bit greyscale gamma is up to the value below.  This is a hack     * to allow pngvalid to succeed:     */
if|if
condition|(
name|bit_depth
operator|==
literal|2
condition|)
return|return
literal|.73182
operator|-
literal|.5
return|;
if|if
condition|(
name|bit_depth
operator|==
literal|4
condition|)
return|return
literal|.90644
operator|-
literal|.5
return|;
if|if
condition|(
name|bit_depth
operator|==
literal|16
condition|)
return|return
name|pm
operator|->
name|maxout16
return|;
return|return
name|pm
operator|->
name|maxout8
return|;
block|}
end_function
begin_comment
comment|/* This returns true if the test should be stopped now because it has already  * failed and it is running silently.  */
end_comment
begin_function
DECL|function|fail
specifier|static
name|int
name|fail
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
return|return
operator|!
name|pm
operator|->
name|log
operator|&&
operator|!
name|pm
operator|->
name|this
operator|.
name|verbose
operator|&&
operator|(
name|pm
operator|->
name|this
operator|.
name|nerrors
operator|>
literal|0
operator|||
operator|(
name|pm
operator|->
name|this
operator|.
name|treat_warnings_as_errors
operator|&&
name|pm
operator|->
name|this
operator|.
name|nwarnings
operator|>
literal|0
operator|)
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|modifier_init
name|modifier_init
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
name|memset
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|pm
argument_list|)
expr_stmt|;
name|store_init
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|)
expr_stmt|;
name|pm
operator|->
name|modifications
operator|=
name|NULL
expr_stmt|;
name|pm
operator|->
name|state
operator|=
name|modifier_start
expr_stmt|;
name|pm
operator|->
name|sbitlow
operator|=
literal|1U
expr_stmt|;
name|pm
operator|->
name|maxout8
operator|=
name|pm
operator|->
name|maxpc8
operator|=
name|pm
operator|->
name|maxabs8
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|maxout16
operator|=
name|pm
operator|->
name|maxpc16
operator|=
name|pm
operator|->
name|maxabs16
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|error_gray_2
operator|=
name|pm
operator|->
name|error_gray_4
operator|=
name|pm
operator|->
name|error_gray_8
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|error_gray_16
operator|=
name|pm
operator|->
name|error_color_8
operator|=
name|pm
operator|->
name|error_color_16
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|interlace_type
operator|=
name|PNG_INTERLACE_NONE
expr_stmt|;
name|pm
operator|->
name|test_standard
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|test_size
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|test_transform
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|use_input_precision
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|use_input_precision_sbit
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|use_input_precision_16to8
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|test_gamma_threshold
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|test_gamma_transform
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|test_gamma_sbit
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|test_gamma_strip16
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|log
operator|=
literal|0
expr_stmt|;
comment|/* Rely on the memset for all the other fields - there are no pointers */
block|}
end_function
begin_comment
comment|/* One modification structure must be provided for each chunk to be modified (in  * fact more than one can be provided if multiple separate changes are desired  * for a single chunk.)  Modifications include adding a new chunk when a  * suitable chunk does not exist.  *  * The caller of modify_fn will reset the CRC of the chunk and record 'modified'  * or 'added' as appropriate if the modify_fn returns 1 (true).  If the  * modify_fn is NULL the chunk is simply removed.  */
end_comment
begin_typedef
DECL|struct|png_modification
typedef|typedef
struct|struct
name|png_modification
block|{
DECL|member|next
name|struct
name|png_modification
modifier|*
name|next
decl_stmt|;
DECL|member|chunk
name|png_uint_32
name|chunk
decl_stmt|;
comment|/* If the following is NULL all matching chunks will be removed: */
DECL|member|modify_fn
name|int
function_decl|(
modifier|*
name|modify_fn
function_decl|)
parameter_list|(
name|struct
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|struct
name|png_modification
modifier|*
name|me
parameter_list|,
name|int
name|add
parameter_list|)
function_decl|;
comment|/* If the following is set to PLTE, IDAT or IEND and the chunk has not been     * found and modified (and there is a modify_fn) the modify_fn will be called     * to add the chunk before the relevant chunk.     */
DECL|member|add
name|png_uint_32
name|add
decl_stmt|;
DECL|member|modified
name|unsigned
name|int
name|modified
range|:
literal|1
decl_stmt|;
comment|/* Chunk was modified */
DECL|member|added
name|unsigned
name|int
name|added
range|:
literal|1
decl_stmt|;
comment|/* Chunk was added */
DECL|member|removed
name|unsigned
name|int
name|removed
range|:
literal|1
decl_stmt|;
comment|/* Chunk was removed */
block|}
DECL|typedef|png_modification
name|png_modification
typedef|;
end_typedef
begin_function
DECL|function|modification_reset
specifier|static
name|void
name|modification_reset
parameter_list|(
name|png_modification
modifier|*
name|pmm
parameter_list|)
block|{
if|if
condition|(
name|pmm
operator|!=
name|NULL
condition|)
block|{
name|pmm
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
name|pmm
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|pmm
operator|->
name|removed
operator|=
literal|0
expr_stmt|;
name|modification_reset
argument_list|(
name|pmm
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|modification_init
name|modification_init
parameter_list|(
name|png_modification
modifier|*
name|pmm
parameter_list|)
block|{
name|memset
argument_list|(
name|pmm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|pmm
argument_list|)
expr_stmt|;
name|pmm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pmm
operator|->
name|chunk
operator|=
literal|0
expr_stmt|;
name|pmm
operator|->
name|modify_fn
operator|=
name|NULL
expr_stmt|;
name|pmm
operator|->
name|add
operator|=
literal|0
expr_stmt|;
name|modification_reset
argument_list|(
name|pmm
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|modifier_reset
name|modifier_reset
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
name|store_read_reset
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|)
expr_stmt|;
name|pm
operator|->
name|modifications
operator|=
name|NULL
expr_stmt|;
name|pm
operator|->
name|state
operator|=
name|modifier_start
expr_stmt|;
name|pm
operator|->
name|bit_depth
operator|=
name|pm
operator|->
name|colour_type
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|pending_len
operator|=
name|pm
operator|->
name|pending_chunk
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|flush
operator|=
name|pm
operator|->
name|buffer_count
operator|=
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Convenience macros. */
end_comment
begin_define
DECL|macro|CHUNK
define|#
directive|define
name|CHUNK
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(((a)<<24)+((b)<<16)+((c)<<8)+(d))
end_define
begin_define
DECL|macro|CHUNK_IHDR
define|#
directive|define
name|CHUNK_IHDR
value|CHUNK(73,72,68,82)
end_define
begin_define
DECL|macro|CHUNK_PLTE
define|#
directive|define
name|CHUNK_PLTE
value|CHUNK(80,76,84,69)
end_define
begin_define
DECL|macro|CHUNK_IDAT
define|#
directive|define
name|CHUNK_IDAT
value|CHUNK(73,68,65,84)
end_define
begin_define
DECL|macro|CHUNK_IEND
define|#
directive|define
name|CHUNK_IEND
value|CHUNK(73,69,78,68)
end_define
begin_define
DECL|macro|CHUNK_cHRM
define|#
directive|define
name|CHUNK_cHRM
value|CHUNK(99,72,82,77)
end_define
begin_define
DECL|macro|CHUNK_gAMA
define|#
directive|define
name|CHUNK_gAMA
value|CHUNK(103,65,77,65)
end_define
begin_define
DECL|macro|CHUNK_sBIT
define|#
directive|define
name|CHUNK_sBIT
value|CHUNK(115,66,73,84)
end_define
begin_define
DECL|macro|CHUNK_sRGB
define|#
directive|define
name|CHUNK_sRGB
value|CHUNK(115,82,71,66)
end_define
begin_comment
comment|/* The guts of modification are performed during a read. */
end_comment
begin_function
specifier|static
name|void
DECL|function|modifier_crc
name|modifier_crc
parameter_list|(
name|png_bytep
name|buffer
parameter_list|)
block|{
comment|/* Recalculate the chunk CRC - a complete chunk must be in     * the buffer, at the start.     */
name|uInt
name|datalen
init|=
name|png_get_uint_32
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|png_save_uint_32
argument_list|(
name|buffer
operator|+
name|datalen
operator|+
literal|8
argument_list|,
name|crc32
argument_list|(
literal|0L
argument_list|,
name|buffer
operator|+
literal|4
argument_list|,
name|datalen
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|modifier_setbuffer
name|modifier_setbuffer
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
name|modifier_crc
argument_list|(
name|pm
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|pm
operator|->
name|buffer_count
operator|=
name|png_get_uint_32
argument_list|(
name|pm
operator|->
name|buffer
argument_list|)
operator|+
literal|12
expr_stmt|;
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Separate the callback into the actual implementation (which is passed the  * png_modifier explicitly) and the callback, which gets the modifier from the  * png_struct.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|modifier_read_imp
name|modifier_read_imp
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_bytep
name|pb
parameter_list|,
name|png_size_t
name|st
parameter_list|)
block|{
while|while
condition|(
name|st
operator|>
literal|0
condition|)
block|{
name|size_t
name|cb
decl_stmt|;
name|png_uint_32
name|len
decl_stmt|,
name|chunk
decl_stmt|;
name|png_modification
modifier|*
name|mod
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|buffer_position
operator|>=
name|pm
operator|->
name|buffer_count
condition|)
switch|switch
condition|(
name|pm
operator|->
name|state
condition|)
block|{
specifier|static
name|png_byte
name|sign
index|[
literal|8
index|]
init|=
block|{
literal|137
block|,
literal|80
block|,
literal|78
block|,
literal|71
block|,
literal|13
block|,
literal|10
block|,
literal|26
block|,
literal|10
block|}
decl_stmt|;
case|case
name|modifier_start
case|:
name|store_read_imp
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|pm
operator|->
name|buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* size of signature. */
name|pm
operator|->
name|buffer_count
operator|=
literal|8
expr_stmt|;
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|pm
operator|->
name|buffer
argument_list|,
name|sign
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
name|png_error
argument_list|(
name|pm
operator|->
name|this
operator|.
name|pread
argument_list|,
literal|"invalid PNG file signature"
argument_list|)
expr_stmt|;
name|pm
operator|->
name|state
operator|=
name|modifier_signature
expr_stmt|;
break|break;
case|case
name|modifier_signature
case|:
name|store_read_imp
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|pm
operator|->
name|buffer
argument_list|,
literal|13
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* size of IHDR */
name|pm
operator|->
name|buffer_count
operator|=
literal|13
operator|+
literal|12
expr_stmt|;
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|png_get_uint_32
argument_list|(
name|pm
operator|->
name|buffer
argument_list|)
operator|!=
literal|13
operator|||
name|png_get_uint_32
argument_list|(
name|pm
operator|->
name|buffer
operator|+
literal|4
argument_list|)
operator|!=
name|CHUNK_IHDR
condition|)
name|png_error
argument_list|(
name|pm
operator|->
name|this
operator|.
name|pread
argument_list|,
literal|"invalid IHDR"
argument_list|)
expr_stmt|;
comment|/* Check the list of modifiers for modifications to the IHDR. */
name|mod
operator|=
name|pm
operator|->
name|modifications
expr_stmt|;
while|while
condition|(
name|mod
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mod
operator|->
name|chunk
operator|==
name|CHUNK_IHDR
operator|&&
name|mod
operator|->
name|modify_fn
operator|&&
call|(
modifier|*
name|mod
operator|->
name|modify_fn
call|)
argument_list|(
name|pm
argument_list|,
name|mod
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mod
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
name|modifier_setbuffer
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore removal or add if IHDR! */
name|mod
operator|=
name|mod
operator|->
name|next
expr_stmt|;
block|}
comment|/* Cache information from the IHDR (the modified one.) */
name|pm
operator|->
name|bit_depth
operator|=
name|pm
operator|->
name|buffer
index|[
literal|8
operator|+
literal|8
index|]
expr_stmt|;
name|pm
operator|->
name|colour_type
operator|=
name|pm
operator|->
name|buffer
index|[
literal|8
operator|+
literal|8
operator|+
literal|1
index|]
expr_stmt|;
name|pm
operator|->
name|state
operator|=
name|modifier_IHDR
expr_stmt|;
name|pm
operator|->
name|flush
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|modifier_IHDR
case|:
default|default:
comment|/* Read a new chunk and process it until we see PLTE, IDAT or              * IEND.  'flush' indicates that there is still some data to              * output from the preceding chunk.              */
if|if
condition|(
operator|(
name|cb
operator|=
name|pm
operator|->
name|flush
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cb
operator|>
name|st
condition|)
name|cb
operator|=
name|st
expr_stmt|;
name|pm
operator|->
name|flush
operator|-=
name|cb
expr_stmt|;
name|store_read_imp
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|pb
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|pb
operator|+=
name|cb
expr_stmt|;
name|st
operator|-=
name|cb
expr_stmt|;
if|if
condition|(
name|st
operator|<=
literal|0
condition|)
return|return;
block|}
comment|/* No more bytes to flush, read a header, or handle a pending              * chunk.              */
if|if
condition|(
name|pm
operator|->
name|pending_chunk
operator|!=
literal|0
condition|)
block|{
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
argument_list|,
name|pm
operator|->
name|pending_len
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
operator|+
literal|4
argument_list|,
name|pm
operator|->
name|pending_chunk
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pending_len
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|pending_chunk
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|store_read_imp
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|pm
operator|->
name|buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pm
operator|->
name|buffer_count
operator|=
literal|8
expr_stmt|;
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
comment|/* Check for something to modify or a terminator chunk. */
name|len
operator|=
name|png_get_uint_32
argument_list|(
name|pm
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|png_get_uint_32
argument_list|(
name|pm
operator|->
name|buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Terminators first, they may have to be delayed for added              * chunks              */
if|if
condition|(
name|chunk
operator|==
name|CHUNK_PLTE
operator|||
name|chunk
operator|==
name|CHUNK_IDAT
operator|||
name|chunk
operator|==
name|CHUNK_IEND
condition|)
block|{
name|mod
operator|=
name|pm
operator|->
name|modifications
expr_stmt|;
while|while
condition|(
name|mod
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|mod
operator|->
name|add
operator|==
name|chunk
operator|||
operator|(
name|mod
operator|->
name|add
operator|==
name|CHUNK_PLTE
operator|&&
name|chunk
operator|==
name|CHUNK_IDAT
operator|)
operator|)
operator|&&
name|mod
operator|->
name|modify_fn
operator|!=
name|NULL
operator|&&
operator|!
name|mod
operator|->
name|modified
operator|&&
operator|!
name|mod
operator|->
name|added
condition|)
block|{
comment|/* Regardless of what the modify function does do not run                       * this again.                       */
name|mod
operator|->
name|added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|mod
operator|->
name|modify_fn
call|)
argument_list|(
name|pm
argument_list|,
name|mod
argument_list|,
literal|1
comment|/*add*/
argument_list|)
condition|)
block|{
comment|/* Reset the CRC on a new chunk */
if|if
condition|(
name|pm
operator|->
name|buffer_count
operator|>
literal|0
condition|)
name|modifier_setbuffer
argument_list|(
name|pm
argument_list|)
expr_stmt|;
else|else
block|{
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
name|mod
operator|->
name|removed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The buffer has been filled with something (we assume)                          * so output this.  Pend the current chunk.                          */
name|pm
operator|->
name|pending_len
operator|=
name|len
expr_stmt|;
name|pm
operator|->
name|pending_chunk
operator|=
name|chunk
expr_stmt|;
break|break;
comment|/* out of while */
block|}
block|}
name|mod
operator|=
name|mod
operator|->
name|next
expr_stmt|;
block|}
comment|/* Don't do any further processing if the buffer was modified -                 * otherwise the code will end up modifying a chunk that was                 * just added.                 */
if|if
condition|(
name|mod
operator|!=
name|NULL
condition|)
break|break;
comment|/* out of switch */
block|}
comment|/* If we get to here then this chunk may need to be modified.  To              * do this it must be less than 1024 bytes in total size, otherwise              * it just gets flushed.              */
if|if
condition|(
name|len
operator|+
literal|12
operator|<=
sizeof|sizeof
name|pm
operator|->
name|buffer
condition|)
block|{
name|store_read_imp
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|pm
operator|->
name|buffer
operator|+
name|pm
operator|->
name|buffer_count
argument_list|,
name|len
operator|+
literal|12
operator|-
name|pm
operator|->
name|buffer_count
argument_list|)
expr_stmt|;
name|pm
operator|->
name|buffer_count
operator|=
name|len
operator|+
literal|12
expr_stmt|;
comment|/* Check for a modification, else leave it be. */
name|mod
operator|=
name|pm
operator|->
name|modifications
expr_stmt|;
while|while
condition|(
name|mod
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mod
operator|->
name|chunk
operator|==
name|chunk
condition|)
block|{
if|if
condition|(
name|mod
operator|->
name|modify_fn
operator|==
name|NULL
condition|)
block|{
comment|/* Remove this chunk */
name|pm
operator|->
name|buffer_count
operator|=
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
name|mod
operator|->
name|removed
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Terminate the while loop */
block|}
elseif|else
if|if
condition|(
call|(
modifier|*
name|mod
operator|->
name|modify_fn
call|)
argument_list|(
name|pm
argument_list|,
name|mod
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mod
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
comment|/* The chunk may have been removed: */
if|if
condition|(
name|pm
operator|->
name|buffer_count
operator|==
literal|0
condition|)
block|{
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|modifier_setbuffer
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
block|}
name|mod
operator|=
name|mod
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
name|pm
operator|->
name|flush
operator|=
name|len
operator|+
literal|12
operator|-
name|pm
operator|->
name|buffer_count
expr_stmt|;
comment|/* data + crc */
comment|/* Take the data from the buffer (if there is any). */
break|break;
block|}
comment|/* Here to read from the modifier buffer (not directly from        * the store, as in the flush case above.)        */
name|cb
operator|=
name|pm
operator|->
name|buffer_count
operator|-
name|pm
operator|->
name|buffer_position
expr_stmt|;
if|if
condition|(
name|cb
operator|>
name|st
condition|)
name|cb
operator|=
name|st
expr_stmt|;
name|memcpy
argument_list|(
name|pb
argument_list|,
name|pm
operator|->
name|buffer
operator|+
name|pm
operator|->
name|buffer_position
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|st
operator|-=
name|cb
expr_stmt|;
name|pb
operator|+=
name|cb
expr_stmt|;
name|pm
operator|->
name|buffer_position
operator|+=
name|cb
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* The callback: */
end_comment
begin_function
specifier|static
name|void
DECL|function|modifier_read
name|modifier_read
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_bytep
name|pb
parameter_list|,
name|png_size_t
name|st
parameter_list|)
block|{
name|png_modifier
modifier|*
name|pm
init|=
name|png_get_io_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
operator|||
name|pm
operator|->
name|this
operator|.
name|pread
operator|!=
name|pp
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"bad modifier_read call"
argument_list|)
expr_stmt|;
name|modifier_read_imp
argument_list|(
name|pm
argument_list|,
name|pb
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Like store_progressive_read but the data is getting changed as we go so we  * need a local buffer.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|modifier_progressive_read
name|modifier_progressive_read
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pm
operator|->
name|this
operator|.
name|pread
operator|!=
name|pp
operator|||
name|pm
operator|->
name|this
operator|.
name|current
operator|==
name|NULL
operator|||
name|pm
operator|->
name|this
operator|.
name|next
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"store state damaged (progressive)"
argument_list|)
expr_stmt|;
comment|/* This is another Horowitz and Hill random noise generator.  In this case     * the aim is to stress the progressive reader with truely horrible variable     * buffer sizes in the range 1..500, so a sequence of 9 bit random numbers     * is generated.  We could probably just count from 1 to 32767 and get as     * good a result.     */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|static
name|png_uint_32
name|noise
init|=
literal|1
decl_stmt|;
name|png_size_t
name|cb
decl_stmt|,
name|cbAvail
decl_stmt|;
name|png_byte
name|buffer
index|[
literal|512
index|]
decl_stmt|;
comment|/* Generate 15 more bits of stuff: */
name|noise
operator|=
operator|(
name|noise
operator|<<
literal|9
operator|)
operator||
operator|(
operator|(
name|noise
operator|^
operator|(
name|noise
operator|>>
operator|(
literal|9
operator|-
literal|5
operator|)
operator|)
operator|)
operator|&
literal|0x1ff
operator|)
expr_stmt|;
name|cb
operator|=
name|noise
operator|&
literal|0x1ff
expr_stmt|;
comment|/* Check that this number of bytes are available (in the current buffer.)        * (This doesn't quite work - the modifier might delete a chunk; unlikely        * but possible, it doesn't happen at present because the modifier only        * adds chunks to standard images.)        */
name|cbAvail
operator|=
name|store_read_buffer_avail
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|buffer_count
operator|>
name|pm
operator|->
name|buffer_position
condition|)
name|cbAvail
operator|+=
name|pm
operator|->
name|buffer_count
operator|-
name|pm
operator|->
name|buffer_position
expr_stmt|;
if|if
condition|(
name|cb
operator|>
name|cbAvail
condition|)
block|{
comment|/* Check for EOF: */
if|if
condition|(
name|cbAvail
operator|==
literal|0
condition|)
break|break;
name|cb
operator|=
name|cbAvail
expr_stmt|;
block|}
name|modifier_read_imp
argument_list|(
name|pm
argument_list|,
name|buffer
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|png_process_data
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|buffer
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
comment|/* Check the invariants at the end (if this fails it's a problem in this     * file!)     */
if|if
condition|(
name|pm
operator|->
name|buffer_count
operator|>
name|pm
operator|->
name|buffer_position
operator|||
name|pm
operator|->
name|this
operator|.
name|next
operator|!=
operator|&
name|pm
operator|->
name|this
operator|.
name|current
operator|->
name|data
operator|||
name|pm
operator|->
name|this
operator|.
name|readpos
operator|<
name|pm
operator|->
name|this
operator|.
name|current
operator|->
name|datacount
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"progressive read implementation error"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Set up a modifier. */
end_comment
begin_function
specifier|static
name|png_structp
DECL|function|set_modifier_for_read
name|set_modifier_for_read
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_infopp
name|ppi
parameter_list|,
name|png_uint_32
name|id
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Do this first so that the modifier fields are cleared even if an error     * happens allocating the png_struct.  No allocation is done here so no     * cleanup is required.     */
name|pm
operator|->
name|state
operator|=
name|modifier_start
expr_stmt|;
name|pm
operator|->
name|bit_depth
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|colour_type
operator|=
literal|255
expr_stmt|;
name|pm
operator|->
name|pending_len
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|pending_chunk
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|flush
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|buffer_count
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
return|return
name|set_store_for_read
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|ppi
argument_list|,
name|id
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/***************************** STANDARD PNG FILES *****************************/
end_comment
begin_comment
comment|/* Standard files - write and save standard files. */
end_comment
begin_comment
comment|/* There are two basic forms of standard images.  Those which attempt to have  * all the possible pixel values (not possible for 16bpp images, but a range of  * values are produced) and those which have a range of image sizes.  The former  * are used for testing transforms, in particular gamma correction and bit  * reduction and increase.  The latter are reserved for testing the behavior of  * libpng with respect to 'odd' image sizes - particularly small images where  * rows become 1 byte and interlace passes disappear.  *  * The first, most useful, set are the 'transform' images, the second set of  * small images are the 'size' images.  *  * The transform files are constructed with rows which fit into a 1024 byte row  * buffer.  This makes allocation easier below.  Further regardless of the file  * format every row has 128 pixels (giving 1024 bytes for 64bpp formats).  *  * Files are stored with no gAMA or sBIT chunks, with a PLTE only when needed  * and with an ID derived from the colour type, bit depth and interlace type  * as above (FILEID).  The width (128) and height (variable) are not stored in  * the FILEID - instead the fields are set to 0, indicating a transform file.  *  * The size files ar constructed with rows a maximum of 128 bytes wide, allowing  * a maximum width of 16 pixels (for the 64bpp case.)  They also have a maximum  * height of 16 rows.  The width and height are stored in the FILEID and, being  * non-zero, indicate a size file.  */
end_comment
begin_comment
comment|/* The number of passes is related to the interlace type. There wass no libpng  * API to determine this prior to 1.5, so we need an inquiry function:  */
end_comment
begin_function
specifier|static
name|int
DECL|function|npasses_from_interlace_type
name|npasses_from_interlace_type
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|int
name|interlace_type
parameter_list|)
block|{
switch|switch
condition|(
name|interlace_type
condition|)
block|{
default|default:
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"invalid interlace type"
argument_list|)
expr_stmt|;
case|case
name|PNG_INTERLACE_NONE
case|:
return|return
literal|1
return|;
case|case
name|PNG_INTERLACE_ADAM7
case|:
return|return
name|PNG_INTERLACE_ADAM7_PASSES
return|;
block|}
block|}
end_function
begin_function
specifier|static
name|unsigned
name|int
DECL|function|bit_size
name|bit_size
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
switch|switch
condition|(
name|colour_type
condition|)
block|{
case|case
literal|0
case|:
return|return
name|bit_depth
return|;
case|case
literal|2
case|:
return|return
literal|3
operator|*
name|bit_depth
return|;
case|case
literal|3
case|:
return|return
name|bit_depth
return|;
case|case
literal|4
case|:
return|return
literal|2
operator|*
name|bit_depth
return|;
case|case
literal|6
case|:
return|return
literal|4
operator|*
name|bit_depth
return|;
default|default:
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"invalid color type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_define
DECL|macro|TRANSFORM_WIDTH
define|#
directive|define
name|TRANSFORM_WIDTH
value|128U
end_define
begin_define
DECL|macro|TRANSFORM_ROWMAX
define|#
directive|define
name|TRANSFORM_ROWMAX
value|(TRANSFORM_WIDTH*8U)
end_define
begin_define
DECL|macro|SIZE_ROWMAX
define|#
directive|define
name|SIZE_ROWMAX
value|(16*8U)
end_define
begin_comment
DECL|macro|SIZE_ROWMAX
comment|/* 16 pixels, max 8 bytes each - 128 bytes */
end_comment
begin_define
DECL|macro|STANDARD_ROWMAX
define|#
directive|define
name|STANDARD_ROWMAX
value|TRANSFORM_ROWMAX
end_define
begin_comment
DECL|macro|STANDARD_ROWMAX
comment|/* The larger of the two */
end_comment
begin_comment
comment|/* So the maximum image sizes are as follows.  A 'transform' image may require  * more than 65535 bytes.  The size images are a maximum of 2046 bytes.  */
end_comment
begin_define
DECL|macro|TRANSFORM_IMAGEMAX
define|#
directive|define
name|TRANSFORM_IMAGEMAX
value|(TRANSFORM_ROWMAX * (png_uint_32)2048)
end_define
begin_define
DECL|macro|SIZE_IMAGEMAX
define|#
directive|define
name|SIZE_IMAGEMAX
value|(SIZE_ROWMAX * 16U)
end_define
begin_function
specifier|static
name|size_t
DECL|function|transform_rowsize
name|transform_rowsize
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
return|return
operator|(
name|TRANSFORM_WIDTH
operator|*
name|bit_size
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
operator|)
operator|/
literal|8
return|;
block|}
end_function
begin_comment
comment|/* transform_width(pp, colour_type, bit_depth) current returns the same number  * every time, so just use a macro:  */
end_comment
begin_define
DECL|macro|transform_width
define|#
directive|define
name|transform_width
parameter_list|(
name|pp
parameter_list|,
name|colour_type
parameter_list|,
name|bit_depth
parameter_list|)
value|TRANSFORM_WIDTH
end_define
begin_function
specifier|static
name|png_uint_32
DECL|function|transform_height
name|transform_height
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
switch|switch
condition|(
name|bit_size
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
return|return
literal|1
return|;
comment|/* Total of 128 pixels */
case|case
literal|8
case|:
return|return
literal|2
return|;
comment|/* Total of 256 pixels/bytes */
case|case
literal|16
case|:
return|return
literal|512
return|;
comment|/* Total of 65536 pixels */
case|case
literal|24
case|:
case|case
literal|32
case|:
return|return
literal|512
return|;
comment|/* 65536 pixels */
case|case
literal|48
case|:
case|case
literal|64
case|:
return|return
literal|2048
return|;
comment|/* 4 x 65536 pixels. */
default|default:
return|return
literal|0
return|;
comment|/* Error, will be caught later */
block|}
block|}
end_function
begin_comment
comment|/* The following can only be defined here, now we have the definitions  * of the transform image sizes.  */
end_comment
begin_function
specifier|static
name|png_uint_32
DECL|function|standard_width
name|standard_width
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_uint_32
name|id
parameter_list|)
block|{
name|png_uint_32
name|width
init|=
name|WIDTH_FROM_ID
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|UNUSED
argument_list|(
argument|pp
argument_list|)
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
name|transform_width
argument_list|(
name|pp
argument_list|,
name|COL_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|DEPTH_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|width
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|standard_height
name|standard_height
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_uint_32
name|id
parameter_list|)
block|{
name|png_uint_32
name|height
init|=
name|HEIGHT_FROM_ID
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|height
operator|==
literal|0
condition|)
name|height
operator|=
name|transform_height
argument_list|(
name|pp
argument_list|,
name|COL_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|DEPTH_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|height
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|standard_rowsize
name|standard_rowsize
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_uint_32
name|id
parameter_list|)
block|{
name|png_uint_32
name|width
init|=
name|standard_width
argument_list|(
name|pp
argument_list|,
name|id
argument_list|)
decl_stmt|;
comment|/* This won't overflow: */
name|width
operator|*=
name|bit_size
argument_list|(
name|pp
argument_list|,
name|COL_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|DEPTH_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|width
operator|+
literal|7
operator|)
operator|/
literal|8
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|transform_row
name|transform_row
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_byte
name|buffer
index|[
name|TRANSFORM_ROWMAX
index|]
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|,
name|png_uint_32
name|y
parameter_list|)
block|{
name|png_uint_32
name|v
init|=
name|y
operator|<<
literal|7
decl_stmt|;
name|png_uint_32
name|i
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|bit_size
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
while|while
condition|(
name|i
operator|<
literal|128
operator|/
literal|8
condition|)
name|buffer
index|[
name|i
index|]
operator|=
name|v
operator|&
literal|0xff
operator|,
name|v
operator|+=
literal|17
operator|,
operator|++
name|i
expr_stmt|;
return|return;
case|case
literal|2
case|:
while|while
condition|(
name|i
operator|<
literal|128
operator|/
literal|4
condition|)
name|buffer
index|[
name|i
index|]
operator|=
name|v
operator|&
literal|0xff
operator|,
name|v
operator|+=
literal|33
operator|,
operator|++
name|i
expr_stmt|;
return|return;
case|case
literal|4
case|:
while|while
condition|(
name|i
operator|<
literal|128
operator|/
literal|2
condition|)
name|buffer
index|[
name|i
index|]
operator|=
name|v
operator|&
literal|0xff
operator|,
name|v
operator|+=
literal|65
operator|,
operator|++
name|i
expr_stmt|;
return|return;
case|case
literal|8
case|:
comment|/* 256 bytes total, 128 bytes in each row set as follows: */
while|while
condition|(
name|i
operator|<
literal|128
condition|)
name|buffer
index|[
name|i
index|]
operator|=
name|v
operator|&
literal|0xff
operator|,
operator|++
name|v
operator|,
operator|++
name|i
expr_stmt|;
return|return;
case|case
literal|16
case|:
comment|/* Generate all 65536 pixel values in order, which includes the 8 bit           * GA case as well as the 16 bit G case.           */
while|while
condition|(
name|i
operator|<
literal|128
condition|)
name|buffer
index|[
literal|2
operator|*
name|i
index|]
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|,
name|buffer
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|v
operator|&
literal|0xff
operator|,
operator|++
name|v
operator|,
operator|++
name|i
expr_stmt|;
return|return;
case|case
literal|24
case|:
comment|/* 65535 pixels, but rotate the values. */
while|while
condition|(
name|i
operator|<
literal|128
condition|)
block|{
comment|/* Three bytes per pixel, r, g, b, make b by r^g */
name|buffer
index|[
literal|3
operator|*
name|i
operator|+
literal|0
index|]
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|3
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
operator|=
operator|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|^
name|v
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|++
name|v
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return;
case|case
literal|32
case|:
comment|/* 65535 pixels, r, g, b, a; just replicate */
while|while
condition|(
name|i
operator|<
literal|128
condition|)
block|{
name|buffer
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
operator|++
name|v
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return;
case|case
literal|48
case|:
comment|/* y is maximum 2047, giving 4x65536 pixels, make 'r' increase by 1 at           * each pixel, g increase by 257 (0x101) and 'b' by 0x1111:           */
while|while
condition|(
name|i
operator|<
literal|128
condition|)
block|{
name|png_uint_32
name|t
init|=
name|v
operator|++
decl_stmt|;
name|buffer
index|[
literal|6
operator|*
name|i
operator|+
literal|0
index|]
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|6
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
name|t
operator|*=
literal|257
expr_stmt|;
name|buffer
index|[
literal|6
operator|*
name|i
operator|+
literal|2
index|]
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|6
operator|*
name|i
operator|+
literal|3
index|]
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
name|t
operator|*=
literal|17
expr_stmt|;
name|buffer
index|[
literal|6
operator|*
name|i
operator|+
literal|4
index|]
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|6
operator|*
name|i
operator|+
literal|5
index|]
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return;
case|case
literal|64
case|:
comment|/* As above in the 32 bit case. */
while|while
condition|(
name|i
operator|<
literal|128
condition|)
block|{
name|png_uint_32
name|t
init|=
name|v
operator|++
decl_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|0
index|]
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|4
index|]
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|5
index|]
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
name|t
operator|*=
literal|257
expr_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|2
index|]
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|3
index|]
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|6
index|]
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|8
operator|*
name|i
operator|+
literal|7
index|]
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is just to do the right cast - could be changed to a function to check  * 'bd' but there isn't much point.  */
end_comment
begin_define
DECL|macro|DEPTH
define|#
directive|define
name|DEPTH
parameter_list|(
name|bd
parameter_list|)
value|((png_byte)(1U<< (bd)))
end_define
begin_comment
comment|/* Make a standardized image given a an image colour type, bit depth and  * interlace type.  The standard images have a very restricted range of  * rows and heights and are used for testing transforms rather than image  * layout details.  See make_size_images below for a way to make images  * that test odd sizes along with the libpng interlace handling.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|make_transform_image
name|make_transform_image
parameter_list|(
name|png_store
modifier|*
name|PNG_CONST
name|ps
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|png_byte
name|PNG_CONST
name|bit_depth
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|png_const_charp
name|name
parameter_list|)
block|{
name|context
argument_list|(
name|ps
argument_list|,
name|fault
argument_list|)
expr_stmt|;
name|Try
block|{
name|png_infop
name|pi
decl_stmt|;
name|png_structp
name|pp
init|=
name|set_store_for_write
argument_list|(
name|ps
argument_list|,
operator|&
name|pi
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|png_uint_32
name|h
decl_stmt|;
comment|/* In the event of a problem return control to the Catch statement below        * to do the clean up - it is not possible to 'return' directly from a Try        * block.        */
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
name|Throw
name|ps
decl_stmt|;
name|h
operator|=
name|transform_height
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
expr_stmt|;
name|png_set_IHDR
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|transform_width
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
argument_list|,
name|h
argument_list|,
name|bit_depth
argument_list|,
name|colour_type
argument_list|,
name|interlace_type
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|colour_type
operator|==
literal|3
condition|)
comment|/* palette */
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|png_color
name|pal
index|[
literal|256
index|]
decl_stmt|;
do|do
name|pal
index|[
name|i
index|]
operator|.
name|red
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|green
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
do|while
condition|(
operator|++
name|i
operator|<
literal|256U
condition|)
do|;
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|pal
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
name|png_write_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_rowbytes
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|transform_rowsize
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"row size incorrect"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Somewhat confusingly this must be called *after* png_write_info           * because if it is called before, the information in *pp has not been           * updated to reflect the interlaced image.           */
name|int
name|npasses
init|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|int
name|pass
decl_stmt|;
if|if
condition|(
name|npasses
operator|!=
name|npasses_from_interlace_type
argument_list|(
name|pp
argument_list|,
name|interlace_type
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"write: png_set_interlace_handling failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|npasses
condition|;
operator|++
name|pass
control|)
block|{
name|png_uint_32
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|png_byte
name|buffer
index|[
name|TRANSFORM_ROWMAX
index|]
decl_stmt|;
name|transform_row
argument_list|(
name|pp
argument_list|,
name|buffer
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|png_write_row
argument_list|(
name|pp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|png_write_end
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* And store this under the appropriate id, then clean up. */
name|store_storefile
argument_list|(
name|ps
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|interlace_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|store_write_reset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
block|{
comment|/* Use the png_store returned by the exception. This may help the compiler        * because 'ps' is not used in this branch of the setjmp.  Note that fault        * and ps will always be the same value.        */
name|store_write_reset
argument_list|(
name|fault
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|make_standard
name|make_standard
parameter_list|(
name|png_store
modifier|*
name|PNG_CONST
name|ps
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|int
name|bdlo
parameter_list|,
name|int
name|PNG_CONST
name|bdhi
parameter_list|)
block|{
for|for
control|(
init|;
name|bdlo
operator|<=
name|bdhi
condition|;
operator|++
name|bdlo
control|)
block|{
name|int
name|interlace_type
decl_stmt|;
for|for
control|(
name|interlace_type
operator|=
name|PNG_INTERLACE_NONE
init|;
name|interlace_type
operator|<
name|PNG_INTERLACE_LAST
condition|;
operator|++
name|interlace_type
control|)
block|{
name|char
name|name
index|[
name|FILE_NAME_SIZE
index|]
decl_stmt|;
name|standard_name
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|0
argument_list|,
name|colour_type
argument_list|,
name|bdlo
argument_list|,
name|interlace_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_transform_image
argument_list|(
name|ps
argument_list|,
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|interlace_type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|make_transform_images
name|make_transform_images
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
comment|/* This is in case of errors. */
name|safecat
argument_list|(
name|ps
operator|->
name|test
argument_list|,
sizeof|sizeof
name|ps
operator|->
name|test
argument_list|,
literal|0
argument_list|,
literal|"make standard images"
argument_list|)
expr_stmt|;
comment|/* Arguments are colour_type, low bit depth, high bit depth     */
name|make_standard
argument_list|(
name|ps
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
name|make_standard
argument_list|(
name|ps
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
name|make_standard
argument_list|(
name|ps
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
comment|/*palette: max 8 bits*/
argument_list|)
expr_stmt|;
name|make_standard
argument_list|(
name|ps
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
name|make_standard
argument_list|(
name|ps
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* The following two routines use the PNG interlace support macros from  * png.h to interlace or deinterlace rows.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|interlace_row
name|interlace_row
parameter_list|(
name|png_bytep
name|buffer
parameter_list|,
name|png_const_bytep
name|imageRow
parameter_list|,
name|unsigned
name|int
name|pixel_size
parameter_list|,
name|png_uint_32
name|w
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|png_uint_32
name|xin
decl_stmt|,
name|xout
decl_stmt|,
name|xstep
decl_stmt|;
comment|/* Note that this can, trivially, be optimized to a memcpy on pass 7, the     * code is presented this way to make it easier to understand.  In practice     * consult the code in the libpng source to see other ways of doing this.     */
name|xin
operator|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|xstep
operator|=
literal|1U
operator|<<
name|PNG_PASS_COL_SHIFT
argument_list|(
name|pass
argument_list|)
expr_stmt|;
for|for
control|(
name|xout
operator|=
literal|0
init|;
name|xin
operator|<
name|w
condition|;
name|xin
operator|+=
name|xstep
control|)
block|{
name|pixel_copy
argument_list|(
name|buffer
argument_list|,
name|xout
argument_list|,
name|imageRow
argument_list|,
name|xin
argument_list|,
name|pixel_size
argument_list|)
expr_stmt|;
operator|++
name|xout
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|deinterlace_row
name|deinterlace_row
parameter_list|(
name|png_bytep
name|buffer
parameter_list|,
name|png_const_bytep
name|row
parameter_list|,
name|unsigned
name|int
name|pixel_size
parameter_list|,
name|png_uint_32
name|w
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* The inverse of the above, 'row' is part of row 'y' of the output image,     * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute     * the pixels of row into buffer and return the number written (to allow     * this to be checked).     */
name|png_uint_32
name|xin
decl_stmt|,
name|xout
decl_stmt|,
name|xstep
decl_stmt|;
name|xout
operator|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|xstep
operator|=
literal|1U
operator|<<
name|PNG_PASS_COL_SHIFT
argument_list|(
name|pass
argument_list|)
expr_stmt|;
for|for
control|(
name|xin
operator|=
literal|0
init|;
name|xout
operator|<
name|w
condition|;
name|xout
operator|+=
name|xstep
control|)
block|{
name|pixel_copy
argument_list|(
name|buffer
argument_list|,
name|xout
argument_list|,
name|row
argument_list|,
name|xin
argument_list|,
name|pixel_size
argument_list|)
expr_stmt|;
operator|++
name|xin
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Build a single row for the 'size' test images, this fills in only the  * first bit_width bits of the sample row.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|size_row
name|size_row
parameter_list|(
name|png_byte
name|buffer
index|[
name|SIZE_ROWMAX
index|]
parameter_list|,
name|png_uint_32
name|bit_width
parameter_list|,
name|png_uint_32
name|y
parameter_list|)
block|{
comment|/* height is in the range 1 to 16, so: */
name|y
operator|=
operator|(
operator|(
name|y
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|y
operator|&
literal|2
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
operator|(
name|y
operator|&
literal|4
operator|)
operator|<<
literal|5
operator|)
operator|+
operator|(
operator|(
name|y
operator|&
literal|8
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* the following ensures bits are set in small images: */
name|y
operator|^=
literal|0xA5
expr_stmt|;
while|while
condition|(
name|bit_width
operator|>=
literal|8
condition|)
operator|*
name|buffer
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|y
operator|++
operator|,
name|bit_width
operator|-=
literal|8
expr_stmt|;
comment|/* There may be up to 7 remaining bits, these go in the most significant     * bits of the byte.     */
if|if
condition|(
name|bit_width
operator|>
literal|0
condition|)
block|{
name|png_uint_32
name|mask
init|=
operator|(
literal|1U
operator|<<
operator|(
literal|8
operator|-
name|bit_width
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
operator|*
name|buffer
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|buffer
operator|&
name|mask
operator|)
operator||
operator|(
name|y
operator|&
operator|~
name|mask
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|make_size_image
name|make_size_image
parameter_list|(
name|png_store
modifier|*
name|PNG_CONST
name|ps
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|png_byte
name|PNG_CONST
name|bit_depth
parameter_list|,
name|int
name|PNG_CONST
name|interlace_type
parameter_list|,
name|png_uint_32
name|PNG_CONST
name|w
parameter_list|,
name|png_uint_32
name|PNG_CONST
name|h
parameter_list|,
name|int
name|PNG_CONST
name|do_interlace
parameter_list|)
block|{
name|context
argument_list|(
name|ps
argument_list|,
name|fault
argument_list|)
expr_stmt|;
name|Try
block|{
name|png_infop
name|pi
decl_stmt|;
name|png_structp
name|pp
decl_stmt|;
name|unsigned
name|int
name|pixel_size
decl_stmt|;
comment|/* Make a name and get an appropriate id for the store: */
name|char
name|name
index|[
name|FILE_NAME_SIZE
index|]
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|id
init|=
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|interlace_type
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|do_interlace
argument_list|)
decl_stmt|;
name|standard_name_from_id
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|0
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pp
operator|=
name|set_store_for_write
argument_list|(
name|ps
argument_list|,
operator|&
name|pi
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* In the event of a problem return control to the Catch statement below        * to do the clean up - it is not possible to 'return' directly from a Try        * block.        */
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
name|Throw
name|ps
decl_stmt|;
name|png_set_IHDR
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|bit_depth
argument_list|,
name|colour_type
argument_list|,
name|interlace_type
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|)
expr_stmt|;
comment|/* Same palette as make_transform_image - I don' think there is any        * benefit from using a different one (JB 20101211)        */
if|if
condition|(
name|colour_type
operator|==
literal|3
condition|)
comment|/* palette */
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|png_color
name|pal
index|[
literal|256
index|]
decl_stmt|;
do|do
name|pal
index|[
name|i
index|]
operator|.
name|red
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|green
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
do|while
condition|(
operator|++
name|i
operator|<
literal|256U
condition|)
do|;
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|pal
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
name|png_write_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Calculate the bit size, divide by 8 to get the byte size - this won't        * overflow because we know the w values are all small enough even for        * a system where 'unsigned int' is only 16 bits.        */
name|pixel_size
operator|=
name|bit_size
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_rowbytes
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
operator|(
operator|(
name|w
operator|*
name|pixel_size
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"row size incorrect"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|npasses
init|=
name|npasses_from_interlace_type
argument_list|(
name|pp
argument_list|,
name|interlace_type
argument_list|)
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|png_byte
name|image
index|[
literal|16
index|]
index|[
name|SIZE_ROWMAX
index|]
decl_stmt|;
comment|/* To help consistent error detection make the parts of this buffer           * that aren't set below all '1':           */
name|memset
argument_list|(
name|image
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_interlace
operator|&&
name|npasses
operator|!=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"write: png_set_interlace_handling failed"
argument_list|)
expr_stmt|;
comment|/* Prepare the whole image first to avoid making it 7 times: */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
name|size_row
argument_list|(
name|image
index|[
name|y
index|]
argument_list|,
name|w
operator|*
name|pixel_size
argument_list|,
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|npasses
condition|;
operator|++
name|pass
control|)
block|{
comment|/* The following two are for checking the macros: */
name|PNG_CONST
name|png_uint_32
name|wPass
init|=
name|PNG_PASS_COLS
argument_list|(
name|w
argument_list|,
name|pass
argument_list|)
decl_stmt|;
comment|/* If do_interlace is set we don't call png_write_row for every              * row because some of them are empty.  In fact, for a 1x1 image,              * most of them are empty!              */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|png_const_bytep
name|row
init|=
name|image
index|[
name|y
index|]
decl_stmt|;
name|png_byte
name|tempRow
index|[
name|SIZE_ROWMAX
index|]
decl_stmt|;
comment|/* If do_interlace *and* the image is interlaced we                 * need a reduced interlace row, this may be reduced                 * to empty.                 */
if|if
condition|(
name|do_interlace
operator|&&
name|interlace_type
operator|==
name|PNG_INTERLACE_ADAM7
condition|)
block|{
comment|/* The row must not be written if it doesn't exist, notice                    * that there are two conditions here, either the row isn't                    * ever in the pass or the row would be but isn't wide                    * enough to contribute any pixels.  In fact the wPass test                    * can be used to skip the whole y loop in this case.                    */
if|if
condition|(
name|PNG_ROW_IN_INTERLACE_PASS
argument_list|(
name|y
argument_list|,
name|pass
argument_list|)
operator|&&
name|wPass
operator|>
literal|0
condition|)
block|{
comment|/* Set to all 1's for error detection (libpng tends to                       * set unset things to 0).                       */
name|memset
argument_list|(
name|tempRow
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
name|tempRow
argument_list|)
expr_stmt|;
name|interlace_row
argument_list|(
name|tempRow
argument_list|,
name|row
argument_list|,
name|pixel_size
argument_list|,
name|w
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|row
operator|=
name|tempRow
expr_stmt|;
block|}
else|else
continue|continue;
block|}
comment|/* Only get to here if the row has some pixels in it. */
name|png_write_row
argument_list|(
name|pp
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|png_write_end
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* And store this under the appropriate id, then clean up. */
name|store_storefile
argument_list|(
name|ps
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|store_write_reset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
block|{
comment|/* Use the png_store returned by the exception. This may help the compiler        * because 'ps' is not used in this branch of the setjmp.  Note that fault        * and ps will always be the same value.        */
name|store_write_reset
argument_list|(
name|fault
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|make_size
name|make_size
parameter_list|(
name|png_store
modifier|*
name|PNG_CONST
name|ps
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|int
name|bdlo
parameter_list|,
name|int
name|PNG_CONST
name|bdhi
parameter_list|)
block|{
for|for
control|(
init|;
name|bdlo
operator|<=
name|bdhi
condition|;
operator|++
name|bdlo
control|)
block|{
name|png_uint_32
name|width
decl_stmt|;
for|for
control|(
name|width
operator|=
literal|1
init|;
name|width
operator|<=
literal|16
condition|;
operator|++
name|width
control|)
block|{
name|png_uint_32
name|height
decl_stmt|;
for|for
control|(
name|height
operator|=
literal|1
init|;
name|height
operator|<=
literal|16
condition|;
operator|++
name|height
control|)
block|{
comment|/* The four combinations of DIY interlace and interlace or not -              * no interlace + DIY should be identical to no interlace with              * libpng doing it.              */
name|make_size_image
argument_list|(
name|ps
argument_list|,
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_NONE
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_size_image
argument_list|(
name|ps
argument_list|,
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_NONE
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|make_size_image
argument_list|(
name|ps
argument_list|,
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_ADAM7
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_size_image
argument_list|(
name|ps
argument_list|,
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_ADAM7
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|make_size_images
name|make_size_images
parameter_list|(
name|png_store
modifier|*
name|ps
parameter_list|)
block|{
comment|/* This is in case of errors. */
name|safecat
argument_list|(
name|ps
operator|->
name|test
argument_list|,
sizeof|sizeof
name|ps
operator|->
name|test
argument_list|,
literal|0
argument_list|,
literal|"make size images"
argument_list|)
expr_stmt|;
comment|/* Arguments are colour_type, low bit depth, high bit depth     */
name|make_size
argument_list|(
name|ps
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
name|make_size
argument_list|(
name|ps
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
name|make_size
argument_list|(
name|ps
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
comment|/*palette: max 8 bits*/
argument_list|)
expr_stmt|;
name|make_size
argument_list|(
name|ps
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
name|make_size
argument_list|(
name|ps
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Return a row based on image id and 'y' for checking: */
end_comment
begin_function
specifier|static
name|void
DECL|function|standard_row
name|standard_row
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_byte
name|std
index|[
name|STANDARD_ROWMAX
index|]
parameter_list|,
name|png_uint_32
name|id
parameter_list|,
name|png_uint_32
name|y
parameter_list|)
block|{
if|if
condition|(
name|WIDTH_FROM_ID
argument_list|(
name|id
argument_list|)
operator|==
literal|0
condition|)
name|transform_row
argument_list|(
name|pp
argument_list|,
name|std
argument_list|,
name|COL_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|DEPTH_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|size_row
argument_list|(
name|std
argument_list|,
name|WIDTH_FROM_ID
argument_list|(
name|id
argument_list|)
operator|*
name|bit_size
argument_list|(
name|pp
argument_list|,
name|COL_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|,
name|DEPTH_FROM_ID
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Tests - individual test cases */
end_comment
begin_comment
comment|/* Like 'make_standard' but errors are deliberately introduced into the calls  * to ensure that they get detected - it should not be possible to write an  * invalid image with libpng!  */
end_comment
begin_function
specifier|static
name|void
DECL|function|sBIT0_error_fn
name|sBIT0_error_fn
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
comment|/* 0 is invalid... */
name|png_color_8
name|bad
decl_stmt|;
name|bad
operator|.
name|red
operator|=
name|bad
operator|.
name|green
operator|=
name|bad
operator|.
name|blue
operator|=
name|bad
operator|.
name|gray
operator|=
name|bad
operator|.
name|alpha
operator|=
literal|0
expr_stmt|;
name|png_set_sBIT
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
operator|&
name|bad
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|sBIT_error_fn
name|sBIT_error_fn
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_byte
name|bit_depth
decl_stmt|;
name|png_color_8
name|bad
decl_stmt|;
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|bit_depth
operator|=
literal|8
expr_stmt|;
else|else
name|bit_depth
operator|=
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Now we know the bit depth we can easily generate an invalid sBIT entry */
name|bad
operator|.
name|red
operator|=
name|bad
operator|.
name|green
operator|=
name|bad
operator|.
name|blue
operator|=
name|bad
operator|.
name|gray
operator|=
name|bad
operator|.
name|alpha
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|bit_depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_set_sBIT
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
operator|&
name|bad
argument_list|)
expr_stmt|;
block|}
end_function
begin_expr_stmt
specifier|static
name|PNG_CONST
expr|struct
block|{
DECL|member|fn
name|void
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|(
name|png_structp
argument_list|,
name|png_infop
argument_list|)
block|;
DECL|member|msg
name|PNG_CONST
name|char
operator|*
name|msg
block|;
DECL|member|warning
name|unsigned
name|int
name|warning
operator|:
literal|1
block|;
comment|/* the error is a warning... */
block|}
DECL|variable|error_test
name|error_test
index|[]
operator|=
block|{
block|{
name|sBIT0_error_fn
block|,
literal|"sBIT(0): failed to detect error"
block|,
literal|1
block|}
block|,
block|{
name|sBIT_error_fn
block|,
literal|"sBIT(too big): failed to detect error"
block|,
literal|1
block|}
block|,     }
expr_stmt|;
end_expr_stmt
begin_function
specifier|static
name|void
DECL|function|make_error
name|make_error
parameter_list|(
name|png_store
modifier|*
specifier|volatile
name|ps
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|int
name|test
parameter_list|,
name|png_const_charp
name|name
parameter_list|)
block|{
name|context
argument_list|(
name|ps
argument_list|,
name|fault
argument_list|)
expr_stmt|;
name|Try
block|{
name|png_structp
name|pp
decl_stmt|;
name|png_infop
name|pi
decl_stmt|;
name|pp
operator|=
name|set_store_for_write
argument_list|(
name|ps
argument_list|,
operator|&
name|pi
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
name|Throw
name|ps
decl_stmt|;
name|png_set_IHDR
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|transform_width
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
argument_list|,
name|transform_height
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
argument_list|,
name|bit_depth
argument_list|,
name|colour_type
argument_list|,
name|interlace_type
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
name|PNG_FILTER_TYPE_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|colour_type
operator|==
literal|3
condition|)
comment|/* palette */
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|png_color
name|pal
index|[
literal|256
index|]
decl_stmt|;
do|do
name|pal
index|[
name|i
index|]
operator|.
name|red
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|green
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
do|while
condition|(
operator|++
name|i
operator|<
literal|256U
condition|)
do|;
name|png_set_PLTE
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
name|pal
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
comment|/* Time for a few errors, these are in various optional chunks, the        * standard tests test the standard chunks pretty well.        */
DECL|macro|exception__prev
define|#
directive|define
name|exception__prev
value|exception_prev_1
DECL|macro|exception__env
define|#
directive|define
name|exception__env
value|exception_env_1
name|Try
block|{
comment|/* Expect this to throw: */
name|ps
operator|->
name|expect_error
operator|=
operator|!
name|error_test
index|[
name|test
index|]
operator|.
name|warning
expr_stmt|;
name|ps
operator|->
name|expect_warning
operator|=
name|error_test
index|[
name|test
index|]
operator|.
name|warning
expr_stmt|;
name|ps
operator|->
name|saw_warning
operator|=
literal|0
expr_stmt|;
name|error_test
index|[
name|test
index|]
operator|.
name|fn
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Normally the error is only detected here: */
name|png_write_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* And handle the case where it was only a warning: */
if|if
condition|(
name|ps
operator|->
name|expect_warning
operator|&&
name|ps
operator|->
name|saw_warning
condition|)
name|Throw
name|ps
decl_stmt|;
comment|/* If we get here there is a problem, we have success - no error or           * no warning - when we shouldn't have success.  Log an error.           */
name|store_log
argument_list|(
name|ps
argument_list|,
name|pp
argument_list|,
name|error_test
index|[
name|test
index|]
operator|.
name|msg
argument_list|,
literal|1
comment|/*error*/
argument_list|)
expr_stmt|;
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
name|ps
operator|=
name|fault
expr_stmt|;
comment|/* expected exit, make sure ps is not clobbered */
DECL|macro|exception__prev
undef|#
directive|undef
name|exception__prev
DECL|macro|exception__env
undef|#
directive|undef
name|exception__env
comment|/* And clear these flags */
name|ps
operator|->
name|expect_error
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|expect_warning
operator|=
literal|0
expr_stmt|;
comment|/* Now write the whole image, just to make sure that the detected, or        * undetected, errro has not created problems inside libpng.        */
if|if
condition|(
name|png_get_rowbytes
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|transform_rowsize
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"row size incorrect"
argument_list|)
expr_stmt|;
else|else
block|{
name|png_uint_32
name|h
init|=
name|transform_height
argument_list|(
name|pp
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
decl_stmt|;
name|int
name|npasses
init|=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|int
name|pass
decl_stmt|;
if|if
condition|(
name|npasses
operator|!=
name|npasses_from_interlace_type
argument_list|(
name|pp
argument_list|,
name|interlace_type
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"write: png_set_interlace_handling failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|npasses
condition|;
operator|++
name|pass
control|)
block|{
name|png_uint_32
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|png_byte
name|buffer
index|[
name|TRANSFORM_ROWMAX
index|]
decl_stmt|;
name|transform_row
argument_list|(
name|pp
argument_list|,
name|buffer
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|png_write_row
argument_list|(
name|pp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|png_write_end
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* The following deletes the file that was just written. */
name|store_write_reset
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
block|{
name|store_write_reset
argument_list|(
name|fault
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|make_errors
name|make_errors
parameter_list|(
name|png_modifier
modifier|*
name|PNG_CONST
name|pm
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|int
name|bdlo
parameter_list|,
name|int
name|PNG_CONST
name|bdhi
parameter_list|)
block|{
for|for
control|(
init|;
name|bdlo
operator|<=
name|bdhi
condition|;
operator|++
name|bdlo
control|)
block|{
name|int
name|interlace_type
decl_stmt|;
for|for
control|(
name|interlace_type
operator|=
name|PNG_INTERLACE_NONE
init|;
name|interlace_type
operator|<
name|PNG_INTERLACE_LAST
condition|;
operator|++
name|interlace_type
control|)
block|{
name|unsigned
name|int
name|test
decl_stmt|;
name|char
name|name
index|[
name|FILE_NAME_SIZE
index|]
decl_stmt|;
name|standard_name
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|0
argument_list|,
name|colour_type
argument_list|,
name|bdlo
argument_list|,
name|interlace_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|test
operator|=
literal|0
init|;
name|test
operator|<
operator|(
sizeof|sizeof
name|error_test
operator|)
operator|/
operator|(
sizeof|sizeof
name|error_test
index|[
literal|0
index|]
operator|)
condition|;
operator|++
name|test
control|)
block|{
name|make_error
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|interlace_type
argument_list|,
name|test
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
comment|/* keep going */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|perform_error_test
name|perform_error_test
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
comment|/* Need to do this here because we just write in this test. */
name|safecat
argument_list|(
name|pm
operator|->
name|this
operator|.
name|test
argument_list|,
sizeof|sizeof
name|pm
operator|->
name|this
operator|.
name|test
argument_list|,
literal|0
argument_list|,
literal|"error test"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_errors
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WRITE_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|make_errors
argument_list|(
name|pm
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|make_errors
argument_list|(
name|pm
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|make_errors
argument_list|(
name|pm
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|make_errors
argument_list|(
name|pm
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
name|WRITE_BDHI
argument_list|)
condition|)
return|return;
block|}
end_function
begin_comment
comment|/* Because we want to use the same code in both the progressive reader and the  * sequential reader it is necessary to deal with the fact that the progressive  * reader callbacks only have one parameter (png_get_progressive_ptr()), so this  * must contain all the test parameters and all the local variables directly  * accessible to the sequential reader implementation.  *  * The technique adopted is to reinvent part of what Dijkstra termed a  * 'display'; an array of pointers to the stack frames of enclosing functions so  * that a nested function definition can access the local (C auto) variables of  * the functions that contain its definition.  In fact C provides the first  * pointer (the local variables - the stack frame pointer) and the last (the  * global variables - the BCPL global vector typically implemented as global  * addresses), this code requires one more pointer to make the display - the  * local variables (and function call parameters) of the function that actually  * invokes either the progressive or sequential reader.  *  * Perhaps confusingly this technique is confounded with classes - the  * 'standard_display' defined here is sub-classed as the 'gamma_display' below.  * A gamma_display is a standard_display, taking advantage of the ANSI-C  * requirement that the pointer to the first member of a structure must be the  * same as the pointer to the structure.  This allows us to reuse standard_  * functions in the gamma test code; something that could not be done with  * nested funtions!  */
end_comment
begin_typedef
DECL|struct|standard_palette_entry
typedef|typedef
struct|struct
name|standard_palette_entry
comment|/* pngvalid format palette! */
block|{
DECL|member|red
name|png_byte
name|red
decl_stmt|;
DECL|member|green
name|png_byte
name|green
decl_stmt|;
DECL|member|blue
name|png_byte
name|blue
decl_stmt|;
DECL|member|alpha
name|png_byte
name|alpha
decl_stmt|;
block|}
DECL|typedef|standard_palette
name|standard_palette
index|[
literal|256
index|]
typedef|;
end_typedef
begin_typedef
DECL|struct|standard_display
typedef|typedef
struct|struct
name|standard_display
block|{
DECL|member|ps
name|png_store
modifier|*
name|ps
decl_stmt|;
comment|/* Test parameters (passed to the function) */
DECL|member|colour_type
name|png_byte
name|colour_type
decl_stmt|;
DECL|member|bit_depth
name|png_byte
name|bit_depth
decl_stmt|;
DECL|member|red_sBIT
name|png_byte
name|red_sBIT
decl_stmt|;
comment|/* Input data sBIT values. */
DECL|member|green_sBIT
name|png_byte
name|green_sBIT
decl_stmt|;
DECL|member|blue_sBIT
name|png_byte
name|blue_sBIT
decl_stmt|;
DECL|member|alpha_sBIT
name|png_byte
name|alpha_sBIT
decl_stmt|;
DECL|member|interlace_type
name|int
name|interlace_type
decl_stmt|;
DECL|member|id
name|png_uint_32
name|id
decl_stmt|;
comment|/* Calculated file ID */
DECL|member|w
name|png_uint_32
name|w
decl_stmt|;
comment|/* Width of image */
DECL|member|h
name|png_uint_32
name|h
decl_stmt|;
comment|/* Height of image */
DECL|member|npasses
name|int
name|npasses
decl_stmt|;
comment|/* Number of interlaced passes */
DECL|member|pixel_size
name|png_uint_32
name|pixel_size
decl_stmt|;
comment|/* Width of one pixel in bits */
DECL|member|bit_width
name|png_uint_32
name|bit_width
decl_stmt|;
comment|/* Width of output row in bits */
DECL|member|cbRow
name|size_t
name|cbRow
decl_stmt|;
comment|/* Bytes in a row of the output image */
DECL|member|do_interlace
name|int
name|do_interlace
decl_stmt|;
comment|/* Do interlacing internally */
DECL|member|is_transparent
name|int
name|is_transparent
decl_stmt|;
comment|/* Transparecy information was present. */
struct|struct
block|{
DECL|member|red
name|png_uint_16
name|red
decl_stmt|;
DECL|member|green
name|png_uint_16
name|green
decl_stmt|;
DECL|member|blue
name|png_uint_16
name|blue
decl_stmt|;
block|}
DECL|member|transparent
name|transparent
struct|;
comment|/* The transparent color, if set. */
name|standard_palette
DECL|member|palette
name|palette
decl_stmt|;
block|}
DECL|typedef|standard_display
name|standard_display
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|standard_display_init
name|standard_display_init
parameter_list|(
name|standard_display
modifier|*
name|dp
parameter_list|,
name|png_store
modifier|*
name|ps
parameter_list|,
name|png_uint_32
name|id
parameter_list|,
name|int
name|do_interlace
parameter_list|)
block|{
name|dp
operator|->
name|ps
operator|=
name|ps
expr_stmt|;
name|dp
operator|->
name|colour_type
operator|=
name|COL_FROM_ID
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|dp
operator|->
name|bit_depth
operator|=
name|DEPTH_FROM_ID
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|dp
operator|->
name|alpha_sBIT
operator|=
name|dp
operator|->
name|blue_sBIT
operator|=
name|dp
operator|->
name|green_sBIT
operator|=
name|dp
operator|->
name|alpha_sBIT
operator|=
name|dp
operator|->
name|bit_depth
expr_stmt|;
name|dp
operator|->
name|interlace_type
operator|=
name|INTERLACE_FROM_ID
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|dp
operator|->
name|id
operator|=
name|id
expr_stmt|;
comment|/* All the rest are filled in after the read_info: */
name|dp
operator|->
name|w
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|h
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|npasses
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|pixel_size
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|bit_width
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|cbRow
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|do_interlace
operator|=
name|do_interlace
expr_stmt|;
name|dp
operator|->
name|is_transparent
operator|=
literal|0
expr_stmt|;
comment|/* Preset the transparent color to black: */
name|memset
argument_list|(
operator|&
name|dp
operator|->
name|transparent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dp
operator|->
name|transparent
argument_list|)
expr_stmt|;
comment|/* Preset the palette to full intensity/opaque througout: */
name|memset
argument_list|(
name|dp
operator|->
name|palette
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
name|dp
operator|->
name|palette
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Call this only if the colour type is 3 - PNG_COLOR_TYPE_PALETTE - otherwise  * it will png_error out.  The API returns true if tRNS information was  * present.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|standard_palette_init
name|standard_palette_init
parameter_list|(
name|standard_palette
name|palette
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_colorp
name|pal
decl_stmt|;
name|png_bytep
name|trans_alpha
decl_stmt|;
name|int
name|num
decl_stmt|;
name|pal
operator|=
literal|0
expr_stmt|;
name|num
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|png_get_PLTE
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
operator|&
name|pal
argument_list|,
operator|&
name|num
argument_list|)
operator|&
name|PNG_INFO_PLTE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
block|{
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|pal
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
block|}
comment|/* Mark the remainder of the entries with a flag value: */
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
literal|126
expr_stmt|;
block|}
else|else
comment|/* !png_get_PLTE */
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: missing PLTE with color type 3"
argument_list|)
expr_stmt|;
name|trans_alpha
operator|=
literal|0
expr_stmt|;
name|num
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|png_get_tRNS
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
operator|&
name|trans_alpha
argument_list|,
operator|&
name|num
argument_list|,
literal|0
argument_list|)
operator|&
name|PNG_INFO_tRNS
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Any of these are crash-worthy - given the implementation of        * png_get_tRNS up to 1.5 an app won't crash if it just checks the        * result above and fails to check that the variables it passed have        * actually been filled in!  Note that if the app were to pass the        * last, png_color_16p, variable too it couldn't rely on this.        */
if|if
condition|(
name|trans_alpha
operator|==
literal|0
operator|||
name|num
operator|<=
literal|0
operator|||
name|num
operator|>
literal|256
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: unexpected png_get_tRNS (palette) result"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
name|palette
index|[
name|i
index|]
operator|.
name|alpha
operator|=
name|trans_alpha
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|palette
index|[
name|i
index|]
operator|.
name|alpha
operator|=
literal|255
expr_stmt|;
return|return
literal|1
return|;
comment|/* transparency */
block|}
else|else
block|{
comment|/* No transparency - just set the alpha channel to opaque. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|palette
index|[
name|i
index|]
operator|.
name|alpha
operator|=
literal|255
expr_stmt|;
return|return
literal|0
return|;
comment|/* no transparency */
block|}
block|}
end_function
begin_comment
comment|/* By passing a 'standard_display' the progressive callbacks can be used  * directly by the sequential code, the functions suffixed "_imp" are the  * implementations, the functions without the suffix are the callbacks.  *  * The code for the info callback is split into two because this callback calls  * png_read_update_info or png_start_read_image and what gets called depends on  * whether the info needs updating (we want to test both calls in pngvalid.)  */
end_comment
begin_function
specifier|static
name|void
DECL|function|standard_info_part1
name|standard_info_part1
parameter_list|(
name|standard_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
if|if
condition|(
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|dp
operator|->
name|bit_depth
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: bit depth changed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|dp
operator|->
name|colour_type
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: color type changed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_filter_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: filter type changed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_interlace_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|dp
operator|->
name|interlace_type
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: interlacing changed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_get_compression_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: compression type changed"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|w
operator|=
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|w
operator|!=
name|standard_width
argument_list|(
name|pp
argument_list|,
name|dp
operator|->
name|id
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: image width changed"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|h
operator|=
name|png_get_image_height
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|h
operator|!=
name|standard_height
argument_list|(
name|pp
argument_list|,
name|dp
operator|->
name|id
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: image height changed"
argument_list|)
expr_stmt|;
comment|/* Record (but don't check at present) the input sBIT according to the colour     * type information.     */
block|{
name|png_color_8p
name|sBIT
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_get_sBIT
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
operator|&
name|sBIT
argument_list|)
operator|&
name|PNG_INFO_sBIT
condition|)
block|{
name|int
name|sBIT_invalid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sBIT
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: unexpected png_get_sBIT result"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|colour_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
block|{
if|if
condition|(
name|sBIT
operator|->
name|red
operator|==
literal|0
operator|||
name|sBIT
operator|->
name|red
operator|>
name|dp
operator|->
name|bit_depth
condition|)
name|sBIT_invalid
operator|=
literal|1
expr_stmt|;
else|else
name|dp
operator|->
name|red_sBIT
operator|=
name|sBIT
operator|->
name|red
expr_stmt|;
if|if
condition|(
name|sBIT
operator|->
name|green
operator|==
literal|0
operator|||
name|sBIT
operator|->
name|green
operator|>
name|dp
operator|->
name|bit_depth
condition|)
name|sBIT_invalid
operator|=
literal|1
expr_stmt|;
else|else
name|dp
operator|->
name|green_sBIT
operator|=
name|sBIT
operator|->
name|green
expr_stmt|;
if|if
condition|(
name|sBIT
operator|->
name|blue
operator|==
literal|0
operator|||
name|sBIT
operator|->
name|blue
operator|>
name|dp
operator|->
name|bit_depth
condition|)
name|sBIT_invalid
operator|=
literal|1
expr_stmt|;
else|else
name|dp
operator|->
name|blue_sBIT
operator|=
name|sBIT
operator|->
name|blue
expr_stmt|;
block|}
else|else
comment|/* !COLOR */
block|{
if|if
condition|(
name|sBIT
operator|->
name|gray
operator|==
literal|0
operator|||
name|sBIT
operator|->
name|gray
operator|>
name|dp
operator|->
name|bit_depth
condition|)
name|sBIT_invalid
operator|=
literal|1
expr_stmt|;
else|else
name|dp
operator|->
name|blue_sBIT
operator|=
name|dp
operator|->
name|green_sBIT
operator|=
name|dp
operator|->
name|red_sBIT
operator|=
name|sBIT
operator|->
name|gray
expr_stmt|;
block|}
comment|/* All 8 bits in tRNS for a palette image are significant - see the           * spec.           */
if|if
condition|(
name|dp
operator|->
name|colour_type
operator|&
name|PNG_COLOR_MASK_ALPHA
condition|)
block|{
if|if
condition|(
name|sBIT
operator|->
name|alpha
operator|==
literal|0
operator|||
name|sBIT
operator|->
name|alpha
operator|>
name|dp
operator|->
name|bit_depth
condition|)
name|sBIT_invalid
operator|=
literal|1
expr_stmt|;
else|else
name|dp
operator|->
name|alpha_sBIT
operator|=
name|sBIT
operator|->
name|alpha
expr_stmt|;
block|}
if|if
condition|(
name|sBIT_invalid
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: sBIT value out of range"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Important: this is validating the value *before* any transforms have been     * put in place.  It doesn't matter for the standard tests, where there are     * no transforms, but it does for other tests where rowbytes may change after     * png_read_update_info.     */
if|if
condition|(
name|png_get_rowbytes
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|!=
name|standard_rowsize
argument_list|(
name|pp
argument_list|,
name|dp
operator|->
name|id
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: row size changed"
argument_list|)
expr_stmt|;
comment|/* The palette is never read for non-palette images, even though it is valid     * - this could be changed.     */
if|if
condition|(
name|dp
operator|->
name|colour_type
operator|==
literal|3
condition|)
comment|/* palette */
block|{
name|int
name|i
decl_stmt|;
name|dp
operator|->
name|is_transparent
operator|=
name|standard_palette_init
argument_list|(
name|dp
operator|->
name|palette
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* And validate the result. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|dp
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|!=
name|i
operator|||
name|dp
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|!=
name|i
operator|||
name|dp
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|!=
name|i
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: color type 3 PLTE chunk changed"
argument_list|)
expr_stmt|;
block|}
comment|/* In any case always check for a tranparent color: */
block|{
name|png_color_16p
name|trans_color
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_get_tRNS
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|trans_color
argument_list|)
operator|&
name|PNG_INFO_tRNS
condition|)
block|{
if|if
condition|(
name|trans_color
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: unexpected png_get_tRNS (color) result"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|colour_type
condition|)
block|{
case|case
literal|0
case|:
name|dp
operator|->
name|transparent
operator|.
name|red
operator|=
name|dp
operator|->
name|transparent
operator|.
name|green
operator|=
name|dp
operator|->
name|transparent
operator|.
name|blue
operator|=
name|trans_color
operator|->
name|gray
expr_stmt|;
name|dp
operator|->
name|is_transparent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dp
operator|->
name|transparent
operator|.
name|red
operator|=
name|trans_color
operator|->
name|red
expr_stmt|;
name|dp
operator|->
name|transparent
operator|.
name|green
operator|=
name|trans_color
operator|->
name|green
expr_stmt|;
name|dp
operator|->
name|transparent
operator|.
name|blue
operator|=
name|trans_color
operator|->
name|blue
expr_stmt|;
name|dp
operator|->
name|is_transparent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Not expected because it should result in the array case              * above.              */
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: unexpected png_get_tRNS result"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: invalid tRNS chunk with alpha image"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Read the number of passes - expected to match the value used when     * creating the image (interlaced or not).  This has the side effect of     * turning on interlace handling (if do_interlace is not set.)     */
name|dp
operator|->
name|npasses
operator|=
name|npasses_from_interlace_type
argument_list|(
name|pp
argument_list|,
name|dp
operator|->
name|interlace_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|do_interlace
operator|&&
name|dp
operator|->
name|npasses
operator|!=
name|png_set_interlace_handling
argument_list|(
name|pp
argument_list|)
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"validate: file changed interlace type"
argument_list|)
expr_stmt|;
comment|/* Caller calls png_read_update_info or png_start_read_image now, then calls     * part2.     */
block|}
end_function
begin_comment
comment|/* This must be called *after* the png_read_update_info call to get the correct  * 'rowbytes' value, otherwise png_get_rowbytes will refer to the untransformed  * image.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|standard_info_part2
name|standard_info_part2
parameter_list|(
name|standard_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|,
name|int
name|nImages
parameter_list|)
block|{
comment|/* Record cbRow now that it can be found. */
name|dp
operator|->
name|pixel_size
operator|=
name|bit_size
argument_list|(
name|pp
argument_list|,
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
argument_list|,
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|bit_width
operator|=
name|png_get_image_width
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
operator|*
name|dp
operator|->
name|pixel_size
expr_stmt|;
name|dp
operator|->
name|cbRow
operator|=
name|png_get_rowbytes
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Validate the rowbytes here again. */
if|if
condition|(
name|dp
operator|->
name|cbRow
operator|!=
operator|(
name|dp
operator|->
name|bit_width
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"bad png_get_rowbytes calculation"
argument_list|)
expr_stmt|;
comment|/* Then ensure there is enough space for the output image(s). */
name|store_ensure_image
argument_list|(
name|dp
operator|->
name|ps
argument_list|,
name|pp
argument_list|,
name|nImages
operator|*
name|dp
operator|->
name|cbRow
operator|*
name|dp
operator|->
name|h
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|standard_info_imp
name|standard_info_imp
parameter_list|(
name|standard_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|,
name|int
name|nImages
parameter_list|)
block|{
comment|/* Note that the validation routine has the side effect of turning on     * interlace handling in the subsequent code.     */
name|standard_info_part1
argument_list|(
name|dp
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* And the info callback has to call this (or png_read_update_info - see     * below in the png_modifier code for that variant.     */
name|png_start_read_image
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Validate the height, width and rowbytes plus ensure that sufficient buffer     * exists for decoding the image.     */
name|standard_info_part2
argument_list|(
name|dp
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|nImages
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|standard_info
name|standard_info
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|standard_display
modifier|*
name|dp
init|=
name|png_get_progressive_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
comment|/* Call with nImages==1 because the progressive reader can only produce one     * image.     */
name|standard_info_imp
argument_list|(
name|dp
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
literal|1
comment|/*only one image*/
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|progressive_row
name|progressive_row
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_bytep
name|new_row
parameter_list|,
name|png_uint_32
name|y
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|PNG_CONST
name|standard_display
modifier|*
name|dp
init|=
name|png_get_progressive_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
comment|/* When handling interlacing some rows will be absent in each pass, the     * callback still gets called, but with a NULL pointer.  This is checked     * in the 'else' clause below.  We need our own 'cbRow', but we can't call     * png_get_rowbytes because we got no info structure.     */
if|if
condition|(
name|new_row
operator|!=
name|NULL
condition|)
block|{
name|png_bytep
name|row
decl_stmt|;
comment|/* In the case where the reader doesn't do the interlace it gives        * us the y in the sub-image:        */
if|if
condition|(
name|dp
operator|->
name|do_interlace
operator|&&
name|dp
operator|->
name|interlace_type
operator|==
name|PNG_INTERLACE_ADAM7
condition|)
name|y
operator|=
name|PNG_ROW_FROM_PASS_ROW
argument_list|(
name|y
argument_list|,
name|pass
argument_list|)
expr_stmt|;
comment|/* Validate this just in case. */
if|if
condition|(
name|y
operator|>=
name|dp
operator|->
name|h
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"invalid y to progressive row callback"
argument_list|)
expr_stmt|;
name|row
operator|=
name|dp
operator|->
name|ps
operator|->
name|image
operator|+
name|y
operator|*
name|dp
operator|->
name|cbRow
expr_stmt|;
comment|/* Combine the new row into the old: */
if|if
condition|(
name|dp
operator|->
name|do_interlace
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|interlace_type
operator|==
name|PNG_INTERLACE_ADAM7
condition|)
name|deinterlace_row
argument_list|(
name|row
argument_list|,
name|new_row
argument_list|,
name|dp
operator|->
name|pixel_size
argument_list|,
name|dp
operator|->
name|w
argument_list|,
name|pass
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|row
argument_list|,
name|new_row
argument_list|,
name|dp
operator|->
name|cbRow
argument_list|)
expr_stmt|;
block|}
else|else
name|png_progressive_combine_row
argument_list|(
name|pp
argument_list|,
name|row
argument_list|,
name|new_row
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|interlace_type
operator|==
name|PNG_INTERLACE_ADAM7
operator|&&
name|PNG_ROW_IN_INTERLACE_PASS
argument_list|(
name|y
argument_list|,
name|pass
argument_list|)
operator|&&
name|PNG_PASS_COLS
argument_list|(
name|dp
operator|->
name|w
argument_list|,
name|pass
argument_list|)
operator|>
literal|0
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"missing row in progressive de-interlacing"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|sequential_row
name|sequential_row
parameter_list|(
name|standard_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|,
name|PNG_CONST
name|png_bytep
name|pImage
parameter_list|,
name|PNG_CONST
name|png_bytep
name|pDisplay
parameter_list|)
block|{
name|PNG_CONST
name|int
name|npasses
init|=
name|dp
operator|->
name|npasses
decl_stmt|;
name|PNG_CONST
name|int
name|do_interlace
init|=
name|dp
operator|->
name|do_interlace
operator|&&
name|dp
operator|->
name|interlace_type
operator|==
name|PNG_INTERLACE_ADAM7
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|height
init|=
name|standard_height
argument_list|(
name|pp
argument_list|,
name|dp
operator|->
name|id
argument_list|)
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|width
init|=
name|standard_width
argument_list|(
name|pp
argument_list|,
name|dp
operator|->
name|id
argument_list|)
decl_stmt|;
name|PNG_CONST
name|size_t
name|cbRow
init|=
name|dp
operator|->
name|cbRow
decl_stmt|;
name|int
name|pass
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
name|npasses
condition|;
operator|++
name|pass
control|)
block|{
name|png_uint_32
name|y
decl_stmt|;
name|png_uint_32
name|wPass
init|=
name|PNG_PASS_COLS
argument_list|(
name|width
argument_list|,
name|pass
argument_list|)
decl_stmt|;
name|png_bytep
name|pRow1
init|=
name|pImage
decl_stmt|;
name|png_bytep
name|pRow2
init|=
name|pDisplay
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|do_interlace
condition|)
block|{
comment|/* wPass may be zero or this row may not be in this pass.              * png_read_row must not be called in either case.              */
if|if
condition|(
name|wPass
operator|>
literal|0
operator|&&
name|PNG_ROW_IN_INTERLACE_PASS
argument_list|(
name|y
argument_list|,
name|pass
argument_list|)
condition|)
block|{
comment|/* Read the row into a pair of temporary buffers, then do the                 * merge here into the output rows.                 */
name|png_byte
name|row
index|[
name|STANDARD_ROWMAX
index|]
decl_stmt|,
name|display
index|[
name|STANDARD_ROWMAX
index|]
decl_stmt|;
comment|/* The following aids (to some extent) error detection - we can                 * see where png_read_row wrote.  Use opposite values in row and                 * display to make this easier.                 */
name|memset
argument_list|(
name|row
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
name|row
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|display
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|display
argument_list|)
expr_stmt|;
name|png_read_row
argument_list|(
name|pp
argument_list|,
name|row
argument_list|,
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRow1
operator|!=
name|NULL
condition|)
name|deinterlace_row
argument_list|(
name|pRow1
argument_list|,
name|row
argument_list|,
name|dp
operator|->
name|pixel_size
argument_list|,
name|dp
operator|->
name|w
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRow2
operator|!=
name|NULL
condition|)
name|deinterlace_row
argument_list|(
name|pRow2
argument_list|,
name|display
argument_list|,
name|dp
operator|->
name|pixel_size
argument_list|,
name|dp
operator|->
name|w
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|png_read_row
argument_list|(
name|pp
argument_list|,
name|pRow1
argument_list|,
name|pRow2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRow1
operator|!=
name|NULL
condition|)
name|pRow1
operator|+=
name|cbRow
expr_stmt|;
if|if
condition|(
name|pRow2
operator|!=
name|NULL
condition|)
name|pRow2
operator|+=
name|cbRow
expr_stmt|;
block|}
block|}
comment|/* And finish the read operation (only really necessary if the caller wants     * to find additional data in png_info from chunks after the last IDAT.)     */
name|png_read_end
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|standard_row_validate
name|standard_row_validate
parameter_list|(
name|standard_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_const_bytep
name|row
parameter_list|,
name|png_const_bytep
name|display
parameter_list|,
name|png_uint_32
name|y
parameter_list|)
block|{
name|png_byte
name|std
index|[
name|STANDARD_ROWMAX
index|]
decl_stmt|;
name|memset
argument_list|(
name|std
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
name|std
argument_list|)
expr_stmt|;
name|standard_row
argument_list|(
name|pp
argument_list|,
name|std
argument_list|,
name|dp
operator|->
name|id
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* At the end both the 'row' and 'display' arrays should end up identical.     * In earlier passes 'row' will be partially filled in, with only the pixels     * that have been read so far, but 'display' will have those pixels     * replicated to fill the unread pixels while reading an interlaced image.     * The side effect inside the libpng sequential reader is that the 'row'     * array retains the correct values for unwritten pixels within the row     * bytes, while the 'display' array gets bits off the end of the image (in     * the last byte) trashed.  Unfortunately in the progressive reader the     * row bytes are always trashed, so we always do a pixel_cmp here even though     * a memcmp of all cbRow bytes will succeed for the sequential reader.     */
if|if
condition|(
name|row
operator|!=
name|NULL
operator|&&
name|pixel_cmp
argument_list|(
name|std
argument_list|,
name|row
argument_list|,
name|dp
operator|->
name|bit_width
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"PNG image row %d changed"
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* In this case use pixel_cmp because we need to compare a partial     * byte at the end of the row if the row is not an exact multiple     * of 8 bits wide.     */
if|if
condition|(
name|display
operator|!=
name|NULL
operator|&&
name|pixel_cmp
argument_list|(
name|std
argument_list|,
name|display
argument_list|,
name|dp
operator|->
name|bit_width
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"display row %d changed"
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|standard_image_validate
name|standard_image_validate
parameter_list|(
name|standard_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_const_bytep
name|pImage
parameter_list|,
name|png_const_bytep
name|pDisplay
parameter_list|)
block|{
name|png_uint_32
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dp
operator|->
name|h
condition|;
operator|++
name|y
control|)
block|{
name|standard_row_validate
argument_list|(
name|dp
argument_list|,
name|pp
argument_list|,
name|pImage
argument_list|,
name|pDisplay
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|pImage
operator|!=
name|NULL
condition|)
name|pImage
operator|+=
name|dp
operator|->
name|cbRow
expr_stmt|;
if|if
condition|(
name|pDisplay
operator|!=
name|NULL
condition|)
name|pDisplay
operator|+=
name|dp
operator|->
name|cbRow
expr_stmt|;
block|}
comment|/* This avoids false positives if the validation code is never called! */
name|dp
operator|->
name|ps
operator|->
name|validated
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|standard_end
name|standard_end
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|standard_display
modifier|*
name|dp
init|=
name|png_get_progressive_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|UNUSED
argument_list|(
argument|pi
argument_list|)
comment|/* Validate the image - progressive reading only produces one variant for     * interlaced images.     */
name|standard_image_validate
argument_list|(
name|dp
argument_list|,
name|pp
argument_list|,
name|dp
operator|->
name|ps
operator|->
name|image
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* A single test run checking the standard image to ensure it is not damaged. */
end_comment
begin_function
specifier|static
name|void
DECL|function|standard_test
name|standard_test
parameter_list|(
name|png_store
modifier|*
name|PNG_CONST
name|psIn
parameter_list|,
name|png_uint_32
name|PNG_CONST
name|id
parameter_list|,
name|int
name|do_interlace
parameter_list|)
block|{
name|standard_display
name|d
decl_stmt|;
name|context
argument_list|(
name|psIn
argument_list|,
name|fault
argument_list|)
expr_stmt|;
comment|/* Set up the display (stack frame) variables from the arguments to the     * function and initialize the locals that are filled in later.     */
name|standard_display_init
argument_list|(
operator|&
name|d
argument_list|,
name|psIn
argument_list|,
name|id
argument_list|,
name|do_interlace
argument_list|)
expr_stmt|;
comment|/* Everything is protected by a Try/Catch.  The functions called also     * typically have local Try/Catch blocks.     */
name|Try
block|{
name|png_structp
name|pp
decl_stmt|;
name|png_infop
name|pi
decl_stmt|;
comment|/* Get a png_struct for reading the image. This will throw an error if it        * fails, so we don't need to check the result.        */
name|pp
operator|=
name|set_store_for_read
argument_list|(
name|d
operator|.
name|ps
argument_list|,
operator|&
name|pi
argument_list|,
name|d
operator|.
name|id
argument_list|,
name|d
operator|.
name|do_interlace
condition|?
operator|(
name|d
operator|.
name|ps
operator|->
name|progressive
condition|?
literal|"pngvalid progressive deinterlacer"
else|:
literal|"pngvalid sequential deinterlacer"
operator|)
else|:
operator|(
name|d
operator|.
name|ps
operator|->
name|progressive
condition|?
literal|"progressive reader"
else|:
literal|"sequential reader"
operator|)
argument_list|)
expr_stmt|;
comment|/* Introduce the correct read function. */
if|if
condition|(
name|d
operator|.
name|ps
operator|->
name|progressive
condition|)
block|{
name|png_set_progressive_read_fn
argument_list|(
name|pp
argument_list|,
operator|&
name|d
argument_list|,
name|standard_info
argument_list|,
name|progressive_row
argument_list|,
name|standard_end
argument_list|)
expr_stmt|;
comment|/* Now feed data into the reader until we reach the end: */
name|store_progressive_read
argument_list|(
name|d
operator|.
name|ps
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that this takes the store, not the display. */
name|png_set_read_fn
argument_list|(
name|pp
argument_list|,
name|d
operator|.
name|ps
argument_list|,
name|store_read
argument_list|)
expr_stmt|;
comment|/* Check the header values: */
name|png_read_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* The code tests both versions of the images that the sequential           * reader can produce.           */
name|standard_info_imp
argument_list|(
operator|&
name|d
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
literal|2
comment|/*images*/
argument_list|)
expr_stmt|;
comment|/* Need the total bytes in the image below; we can't get to this point           * unless the PNG file values have been checked against the expected           * values.           */
block|{
name|PNG_CONST
name|png_bytep
name|pImage
init|=
name|d
operator|.
name|ps
operator|->
name|image
decl_stmt|;
name|PNG_CONST
name|png_bytep
name|pDisplay
init|=
name|pImage
operator|+
name|d
operator|.
name|cbRow
operator|*
name|d
operator|.
name|h
decl_stmt|;
name|sequential_row
argument_list|(
operator|&
name|d
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|pImage
argument_list|,
name|pDisplay
argument_list|)
expr_stmt|;
comment|/* After the last pass loop over the rows again to check that the              * image is correct.              */
name|standard_image_validate
argument_list|(
operator|&
name|d
argument_list|,
name|pp
argument_list|,
name|pImage
argument_list|,
name|pDisplay
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for validation. */
if|if
condition|(
operator|!
name|d
operator|.
name|ps
operator|->
name|validated
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"image read failed silently"
argument_list|)
expr_stmt|;
comment|/* Successful completion. */
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
name|d
operator|.
name|ps
operator|=
name|fault
expr_stmt|;
comment|/* make sure this hasn't been clobbered. */
comment|/* In either case clean up the store. */
name|store_read_reset
argument_list|(
name|d
operator|.
name|ps
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|test_standard
name|test_standard
parameter_list|(
name|png_modifier
modifier|*
name|PNG_CONST
name|pm
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|int
name|bdlo
parameter_list|,
name|int
name|PNG_CONST
name|bdhi
parameter_list|)
block|{
for|for
control|(
init|;
name|bdlo
operator|<=
name|bdhi
condition|;
operator|++
name|bdlo
control|)
block|{
name|int
name|interlace_type
decl_stmt|;
for|for
control|(
name|interlace_type
operator|=
name|PNG_INTERLACE_NONE
init|;
name|interlace_type
operator|<
name|PNG_INTERLACE_LAST
condition|;
operator|++
name|interlace_type
control|)
block|{
name|standard_test
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|interlace_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
comment|/* keep going */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|perform_standard_test
name|perform_standard_test
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
comment|/* Test each colour type over the valid range of bit depths (expressed as     * log2(bit_depth) in turn, stop as soon as any error is detected.     */
if|if
condition|(
operator|!
name|test_standard
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_standard
argument_list|(
name|pm
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_standard
argument_list|(
name|pm
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_standard
argument_list|(
name|pm
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_standard
argument_list|(
name|pm
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
block|}
end_function
begin_comment
comment|/********************************** SIZE TESTS ********************************/
end_comment
begin_function
specifier|static
name|int
DECL|function|test_size
name|test_size
parameter_list|(
name|png_modifier
modifier|*
name|PNG_CONST
name|pm
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|int
name|bdlo
parameter_list|,
name|int
name|PNG_CONST
name|bdhi
parameter_list|)
block|{
comment|/* Run the tests on each combination.     *     * NOTE: on my 32 bit x86 each of the following blocks takes     * a total of 3.5 seconds if done across every combo of bit depth     * width and height.  This is a waste of time in practice, hence the     * hinc and winc stuff:     */
specifier|static
name|PNG_CONST
name|png_byte
name|hinc
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|11
block|,
literal|1
block|,
literal|5
block|}
decl_stmt|;
specifier|static
name|PNG_CONST
name|png_byte
name|winc
index|[]
init|=
block|{
literal|1
block|,
literal|9
block|,
literal|5
block|,
literal|7
block|,
literal|1
block|}
decl_stmt|;
for|for
control|(
init|;
name|bdlo
operator|<=
name|bdhi
condition|;
operator|++
name|bdlo
control|)
block|{
name|png_uint_32
name|h
decl_stmt|,
name|w
decl_stmt|;
for|for
control|(
name|h
operator|=
literal|1
init|;
name|h
operator|<=
literal|16
condition|;
name|h
operator|+=
name|hinc
index|[
name|bdlo
index|]
control|)
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<=
literal|16
condition|;
name|w
operator|+=
name|winc
index|[
name|bdlo
index|]
control|)
block|{
comment|/* First test all the 'size' images against the sequential           * reader using libpng to deinterlace (where required.)  This           * validates the write side of libpng.  There are four possibilities           * to validate.           */
name|standard_test
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_NONE
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
name|standard_test
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_NONE
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
name|standard_test
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_ADAM7
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
name|standard_test
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_ADAM7
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now validate the interlaced read side - do_interlace true,           * in the progressive case this does actually make a difference           * to the code used in the non-interlaced case too.           */
name|standard_test
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_NONE
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
name|standard_test
argument_list|(
operator|&
name|pm
operator|->
name|this
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
argument_list|,
name|PNG_INTERLACE_ADAM7
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
comment|/* keep going */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|perform_size_test
name|perform_size_test
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
comment|/* Test each colour type over the valid range of bit depths (expressed as     * log2(bit_depth) in turn, stop as soon as any error is detected.     */
if|if
condition|(
operator|!
name|test_size
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_size
argument_list|(
name|pm
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
comment|/* For the moment don't do the palette test - it's a waste of time when     * compared to the greyscale test.     */
if|#
directive|if
literal|0
block|if (!test_size(pm, 3, 0, 3))       return;
endif|#
directive|endif
if|if
condition|(
operator|!
name|test_size
argument_list|(
name|pm
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_size
argument_list|(
name|pm
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|)
condition|)
return|return;
block|}
end_function
begin_comment
comment|/******************************* TRANSFORM TESTS ******************************/
end_comment
begin_comment
comment|/* A set of tests to validate libpng image transforms.  The possibilities here  * are legion because the transforms can be combined in a combinatorial  * fashion.  To deal with this some measure of restraint is required, otherwise  * the tests would take forever.  */
end_comment
begin_typedef
DECL|struct|image_pixel
typedef|typedef
struct|struct
name|image_pixel
block|{
comment|/* A local (pngvalid) representation of a PNG pixel, in all its     * various forms.     */
DECL|member|red
DECL|member|green
DECL|member|blue
DECL|member|alpha
name|unsigned
name|int
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|,
name|alpha
decl_stmt|;
comment|/* For non-palette images. */
DECL|member|palette_index
name|unsigned
name|int
name|palette_index
decl_stmt|;
comment|/* For a palette image. */
DECL|member|colour_type
name|png_byte
name|colour_type
decl_stmt|;
comment|/* As in the spec. */
DECL|member|bit_depth
name|png_byte
name|bit_depth
decl_stmt|;
comment|/* Defines bit size in row */
DECL|member|sample_depth
name|png_byte
name|sample_depth
decl_stmt|;
comment|/* Scale of samples */
DECL|member|have_tRNS
name|int
name|have_tRNS
decl_stmt|;
comment|/* tRNS chunk may need processing */
comment|/* For checking the code calculates double precision floating point values     * along with an error value, accumulated from the transforms.  Because an     * sBIT setting allows larger error bounds (indeed, by the spec, apparently     * up to just less than +/-1 in the scaled value) the *lowest* sBIT for each     * channel is stored.  This sBIT value is folded in to the stored error value     * at the end of the application of the transforms to the pixel.     */
DECL|member|redf
DECL|member|greenf
DECL|member|bluef
DECL|member|alphaf
name|double
name|redf
decl_stmt|,
name|greenf
decl_stmt|,
name|bluef
decl_stmt|,
name|alphaf
decl_stmt|;
DECL|member|rede
DECL|member|greene
DECL|member|bluee
DECL|member|alphae
name|double
name|rede
decl_stmt|,
name|greene
decl_stmt|,
name|bluee
decl_stmt|,
name|alphae
decl_stmt|;
DECL|member|red_sBIT
DECL|member|green_sBIT
DECL|member|blue_sBIT
DECL|member|alpha_sBIT
name|png_byte
name|red_sBIT
decl_stmt|,
name|green_sBIT
decl_stmt|,
name|blue_sBIT
decl_stmt|,
name|alpha_sBIT
decl_stmt|;
block|}
DECL|typedef|image_pixel
name|image_pixel
typedef|;
end_typedef
begin_comment
comment|/* Shared utility function, see below. */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_pixel_setf
name|image_pixel_setf
parameter_list|(
name|image_pixel
modifier|*
name|this
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|)
block|{
name|this
operator|->
name|redf
operator|=
name|this
operator|->
name|red
operator|/
operator|(
name|double
operator|)
name|max
expr_stmt|;
name|this
operator|->
name|greenf
operator|=
name|this
operator|->
name|green
operator|/
operator|(
name|double
operator|)
name|max
expr_stmt|;
name|this
operator|->
name|bluef
operator|=
name|this
operator|->
name|blue
operator|/
operator|(
name|double
operator|)
name|max
expr_stmt|;
name|this
operator|->
name|alphaf
operator|=
name|this
operator|->
name|alpha
operator|/
operator|(
name|double
operator|)
name|max
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|red
operator|<
name|max
condition|)
name|this
operator|->
name|rede
operator|=
name|this
operator|->
name|redf
operator|*
name|DBL_EPSILON
expr_stmt|;
else|else
name|this
operator|->
name|rede
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|green
operator|<
name|max
condition|)
name|this
operator|->
name|greene
operator|=
name|this
operator|->
name|greenf
operator|*
name|DBL_EPSILON
expr_stmt|;
else|else
name|this
operator|->
name|greene
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|blue
operator|<
name|max
condition|)
name|this
operator|->
name|bluee
operator|=
name|this
operator|->
name|bluef
operator|*
name|DBL_EPSILON
expr_stmt|;
else|else
name|this
operator|->
name|bluee
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|alpha
operator|<
name|max
condition|)
name|this
operator|->
name|alphae
operator|=
name|this
operator|->
name|alphaf
operator|*
name|DBL_EPSILON
expr_stmt|;
else|else
name|this
operator|->
name|alphae
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Initialize the structure for the next pixel - call this before doing any  * transforms and call it for each pixel since all the fields may need to be  * reset.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_pixel_init
name|image_pixel_init
parameter_list|(
name|image_pixel
modifier|*
name|this
parameter_list|,
name|png_const_bytep
name|row
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|,
name|png_uint_32
name|x
parameter_list|,
name|standard_palette
name|palette
parameter_list|)
block|{
name|PNG_CONST
name|png_byte
name|sample_depth
init|=
call|(
name|png_byte
call|)
argument_list|(
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|?
literal|8
else|:
name|bit_depth
argument_list|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
name|sample_depth
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* Initially just set everything to the same number and the alpha to opaque.     * Note that this currently assumes a simple palette where entry x has colour     * rgb(x,x,x)!     */
name|this
operator|->
name|palette_index
operator|=
name|this
operator|->
name|red
operator|=
name|this
operator|->
name|green
operator|=
name|this
operator|->
name|blue
operator|=
name|sample
argument_list|(
name|row
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|->
name|alpha
operator|=
name|max
expr_stmt|;
name|this
operator|->
name|red_sBIT
operator|=
name|this
operator|->
name|green_sBIT
operator|=
name|this
operator|->
name|blue_sBIT
operator|=
name|this
operator|->
name|alpha_sBIT
operator|=
name|sample_depth
expr_stmt|;
comment|/* Then override as appropriate: */
if|if
condition|(
name|colour_type
operator|==
literal|3
condition|)
comment|/* palette */
block|{
comment|/* This permits the caller to default to the sample value. */
if|if
condition|(
name|palette
operator|!=
literal|0
condition|)
block|{
name|PNG_CONST
name|unsigned
name|int
name|i
init|=
name|this
operator|->
name|palette_index
decl_stmt|;
name|this
operator|->
name|red
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|this
operator|->
name|green
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|this
operator|->
name|blue
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
name|this
operator|->
name|alpha
operator|=
name|palette
index|[
name|i
index|]
operator|.
name|alpha
expr_stmt|;
block|}
block|}
else|else
comment|/* not palette */
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|colour_type
operator|&
literal|2
condition|)
block|{
name|this
operator|->
name|green
operator|=
name|sample
argument_list|(
name|row
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|this
operator|->
name|blue
operator|=
name|sample
argument_list|(
name|row
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|colour_type
operator|&
literal|4
condition|)
name|this
operator|->
name|alpha
operator|=
name|sample
argument_list|(
name|row
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|x
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the scaled values, these are simply the values divided by     * 'max' and the error is initialized to the double precision epsilon value     * from the header file.     */
name|image_pixel_setf
argument_list|(
name|this
argument_list|,
name|max
argument_list|)
expr_stmt|;
comment|/* Store the input information for use in the transforms - these will     * modify the information.     */
name|this
operator|->
name|colour_type
operator|=
name|colour_type
expr_stmt|;
name|this
operator|->
name|bit_depth
operator|=
name|bit_depth
expr_stmt|;
name|this
operator|->
name|sample_depth
operator|=
name|sample_depth
expr_stmt|;
name|this
operator|->
name|have_tRNS
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Convert a palette image to an rgb image.  This necessarily converts the tRNS  * chunk at the same time, because the tRNS will be in palette form.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_pixel_convert_PLTE
name|image_pixel_convert_PLTE
parameter_list|(
name|image_pixel
modifier|*
name|this
parameter_list|,
specifier|const
name|standard_display
modifier|*
name|display
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|PNG_CONST
name|unsigned
name|int
name|i
init|=
name|this
operator|->
name|palette_index
decl_stmt|;
name|this
operator|->
name|bit_depth
operator|=
name|this
operator|->
name|sample_depth
expr_stmt|;
name|this
operator|->
name|red
operator|=
name|display
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|this
operator|->
name|green
operator|=
name|display
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|this
operator|->
name|blue
operator|=
name|display
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
name|this
operator|->
name|red_sBIT
operator|=
name|display
operator|->
name|red_sBIT
expr_stmt|;
name|this
operator|->
name|green_sBIT
operator|=
name|display
operator|->
name|green_sBIT
expr_stmt|;
name|this
operator|->
name|blue_sBIT
operator|=
name|display
operator|->
name|blue_sBIT
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|have_tRNS
condition|)
block|{
name|this
operator|->
name|alpha
operator|=
name|display
operator|->
name|palette
index|[
name|i
index|]
operator|.
name|alpha
expr_stmt|;
name|this
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
name|this
operator|->
name|have_tRNS
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|this
operator|->
name|alpha
operator|=
literal|255
expr_stmt|;
name|this
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
block|}
name|this
operator|->
name|alpha_sBIT
operator|=
literal|8
expr_stmt|;
comment|/* And regenerate the scaled values and all the errors, which are now set        * back to the initial values.        */
name|image_pixel_setf
argument_list|(
name|this
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Add an alpha channel, this will glom in the tRNS information because tRNS is  * not valid in an alpha image.  The bit depth will invariably be set to at  * least 8.  Palette images will be converted to alpha (using the above API).  */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_pixel_add_alpha
name|image_pixel_add_alpha
parameter_list|(
name|image_pixel
modifier|*
name|this
parameter_list|,
specifier|const
name|standard_display
modifier|*
name|display
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|image_pixel_convert_PLTE
argument_list|(
name|this
argument_list|,
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|colour_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|this
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|have_tRNS
condition|)
block|{
name|this
operator|->
name|have_tRNS
operator|=
literal|0
expr_stmt|;
comment|/* Check the input, original, channel value here against the              * original tRNS gray chunk valie.              */
if|if
condition|(
name|this
operator|->
name|red
operator|==
name|display
operator|->
name|transparent
operator|.
name|red
condition|)
name|this
operator|->
name|alphaf
operator|=
literal|0
expr_stmt|;
else|else
name|this
operator|->
name|alphaf
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|this
operator|->
name|alphaf
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|have_tRNS
condition|)
block|{
name|this
operator|->
name|have_tRNS
operator|=
literal|0
expr_stmt|;
comment|/* Again, check the exact input values, not the current transformed              * value!              */
if|if
condition|(
name|this
operator|->
name|red
operator|==
name|display
operator|->
name|transparent
operator|.
name|red
operator|&&
name|this
operator|->
name|green
operator|==
name|display
operator|->
name|transparent
operator|.
name|green
operator|&&
name|this
operator|->
name|blue
operator|==
name|display
operator|->
name|transparent
operator|.
name|blue
condition|)
name|this
operator|->
name|alphaf
operator|=
literal|0
expr_stmt|;
else|else
name|this
operator|->
name|alphaf
operator|=
literal|1
expr_stmt|;
name|this
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
block|}
block|}
comment|/* The error in the alpha is zero and the sBIT value comes from the        * original sBIT data (actually it will always be the original bit depth).        */
name|this
operator|->
name|alphae
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|alpha_sBIT
operator|=
name|display
operator|->
name|alpha_sBIT
expr_stmt|;
block|}
block|}
end_function
begin_struct_decl
struct_decl|struct
name|transform_display
struct_decl|;
end_struct_decl
begin_typedef
DECL|struct|image_transform
typedef|typedef
struct|struct
name|image_transform
block|{
comment|/* The name of this transform: a string. */
DECL|member|name
name|PNG_CONST
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Each transform can be disabled from the command line: */
DECL|member|enable
name|int
name|enable
decl_stmt|;
comment|/* The global list of transforms; read only. */
DECL|member|list
name|struct
name|image_transform
modifier|*
name|PNG_CONST
name|list
decl_stmt|;
comment|/* The global count of the number of times this transform has been set on an     * image.     */
DECL|member|global_use
name|unsigned
name|int
name|global_use
decl_stmt|;
comment|/* The local count of the number of times this transform has been set. */
DECL|member|local_use
name|unsigned
name|int
name|local_use
decl_stmt|;
comment|/* The next transform in the list, each transform must call its own next     * transform after it has processed the pixel successfully.     */
DECL|member|next
name|PNG_CONST
name|struct
name|image_transform
modifier|*
name|next
decl_stmt|;
comment|/* A single transform for the image, expressed as a series of function     * callbacks and some space for values.     *     * First a callback to set the transform on the current png_read_struct:     */
DECL|member|set
name|void
function_decl|(
modifier|*
name|set
function_decl|)
parameter_list|(
name|PNG_CONST
name|struct
name|image_transform
modifier|*
name|this
parameter_list|,
name|struct
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
function_decl|;
comment|/* Then a transform that takes an input pixel in one PNG format or another     * and modifies it by a pngvalid implementation of the transform (thus     * duplicating the libpng intent without, we hope, duplicating the bugs     * in the libpng implementation!)  The png_structp is solely to allow error     * reporting via png_error and png_warning.     */
DECL|member|mod
name|void
function_decl|(
modifier|*
name|mod
function_decl|)
parameter_list|(
name|PNG_CONST
name|struct
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|struct
name|transform_display
modifier|*
name|display
parameter_list|)
function_decl|;
comment|/* Add this transform to the list and return true if the transform is     * meaningful for this colour type and bit depth - if false then the     * transform should have no effect on the image so there's not a lot of     * point running it.     */
DECL|member|add
name|int
function_decl|(
modifier|*
name|add
function_decl|)
parameter_list|(
name|struct
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|struct
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
function_decl|;
block|}
DECL|typedef|image_transform
name|image_transform
typedef|;
end_typedef
begin_typedef
DECL|struct|transform_display
typedef|typedef
struct|struct
name|transform_display
block|{
DECL|member|this
name|standard_display
name|this
decl_stmt|;
comment|/* Parameters */
DECL|member|pm
name|png_modifier
modifier|*
name|pm
decl_stmt|;
DECL|member|transform_list
name|PNG_CONST
name|image_transform
modifier|*
name|transform_list
decl_stmt|;
comment|/* Local variables */
DECL|member|output_colour_type
name|png_byte
name|output_colour_type
decl_stmt|;
DECL|member|output_bit_depth
name|png_byte
name|output_bit_depth
decl_stmt|;
block|}
DECL|typedef|transform_display
name|transform_display
typedef|;
end_typedef
begin_comment
comment|/* Two functions to end the list: */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_set_end
name|image_transform_set_end
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|this
argument_list|)
name|UNUSED
argument_list|(
argument|that
argument_list|)
name|UNUSED
argument_list|(
argument|pp
argument_list|)
name|UNUSED
argument_list|(
argument|pi
argument_list|)
block|}
end_function
begin_comment
comment|/* At the end of the list recalculate the output image pixel value from the  * double precision values set up by the preceding 'mod' calls:  */
end_comment
begin_function
specifier|static
name|unsigned
name|int
DECL|function|sample_scale
name|sample_scale
parameter_list|(
name|double
name|sample_value
parameter_list|,
name|unsigned
name|int
name|scale
parameter_list|)
block|{
name|sample_value
operator|=
name|floor
argument_list|(
name|sample_value
operator|*
name|scale
operator|+
literal|.5
argument_list|)
expr_stmt|;
comment|/* Return NaN as 0: */
if|if
condition|(
operator|!
operator|(
name|sample_value
operator|>
literal|0
operator|)
condition|)
name|sample_value
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sample_value
operator|>
name|scale
condition|)
name|sample_value
operator|=
name|scale
expr_stmt|;
return|return
operator|(
name|unsigned
name|int
operator|)
name|sample_value
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_mod_end
name|image_transform_mod_end
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
name|PNG_CONST
name|unsigned
name|int
name|scale
init|=
operator|(
literal|1U
operator|<<
name|that
operator|->
name|sample_depth
operator|)
operator|-
literal|1
decl_stmt|;
name|UNUSED
argument_list|(
argument|this
argument_list|)
name|UNUSED
argument_list|(
argument|pp
argument_list|)
name|UNUSED
argument_list|(
argument|display
argument_list|)
comment|/* At the end recalculate the digitized red green and blue values according     * to the current sample_depth of the pixel.     *     * The sample value is simply scaled to the maximum, checking for over     * and underflow (which can both happen for some image transforms,     * including simple size scaling, though libpng doesn't do that at present.     */
name|that
operator|->
name|red
operator|=
name|sample_scale
argument_list|(
name|that
operator|->
name|redf
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* The error value is increased, at the end, according to the lowest sBIT     * value seen.  Common sense tells us that the intermediate integer     * representations are no more accurate than +/- 0.5 in the integral values,     * the sBIT allows the implementation to be worse than this.  In addition the     * PNG specification actually permits any error within the range (-1..+1),     * but that is ignored here.  Instead the final digitized value is compared,     * below to the digitized value of the error limits - this has the net effect     * of allowing (almost) +/-1 in the output value.  It's difficult to see how     * any algorithm that digitizes intermediate results can be more accurate.     */
name|that
operator|->
name|rede
operator|+=
literal|1.
operator|/
operator|(
literal|2
operator|*
operator|(
operator|(
literal|1U
operator|<<
name|that
operator|->
name|red_sBIT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|colour_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
block|{
name|that
operator|->
name|green
operator|=
name|sample_scale
argument_list|(
name|that
operator|->
name|greenf
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|that
operator|->
name|blue
operator|=
name|sample_scale
argument_list|(
name|that
operator|->
name|bluef
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|that
operator|->
name|greene
operator|+=
literal|1.
operator|/
operator|(
literal|2
operator|*
operator|(
operator|(
literal|1U
operator|<<
name|that
operator|->
name|green_sBIT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|that
operator|->
name|bluee
operator|+=
literal|1.
operator|/
operator|(
literal|2
operator|*
operator|(
operator|(
literal|1U
operator|<<
name|that
operator|->
name|blue_sBIT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|that
operator|->
name|blue
operator|=
name|that
operator|->
name|green
operator|=
name|that
operator|->
name|red
expr_stmt|;
name|that
operator|->
name|bluef
operator|=
name|that
operator|->
name|greenf
operator|=
name|that
operator|->
name|redf
expr_stmt|;
name|that
operator|->
name|bluee
operator|=
name|that
operator|->
name|greene
operator|=
name|that
operator|->
name|rede
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|that
operator|->
name|colour_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|||
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|that
operator|->
name|alpha
operator|=
name|sample_scale
argument_list|(
name|that
operator|->
name|alphaf
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|that
operator|->
name|alphae
operator|+=
literal|1.
operator|/
operator|(
literal|2
operator|*
operator|(
operator|(
literal|1U
operator|<<
name|that
operator|->
name|alpha_sBIT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|that
operator|->
name|alpha
operator|=
name|scale
expr_stmt|;
comment|/* opaque */
name|that
operator|->
name|alpha
operator|=
literal|1
expr_stmt|;
comment|/* Override this. */
name|that
operator|->
name|alphae
operator|=
literal|0
expr_stmt|;
comment|/* It's exact ;-) */
block|}
block|}
end_function
begin_comment
comment|/* Static 'end' structure: */
end_comment
begin_decl_stmt
DECL|variable|image_transform_end
specifier|static
name|image_transform
name|image_transform_end
init|=
block|{
literal|"(end)"
block|,
comment|/* name */
literal|1
block|,
comment|/* enable */
literal|0
block|,
comment|/* list */
literal|0
block|,
comment|/* global_use */
literal|0
block|,
comment|/* local_use */
literal|0
block|,
comment|/* next */
name|image_transform_set_end
block|,
name|image_transform_mod_end
block|,
literal|0
comment|/* never called, I want it to crash if it is! */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Reader callbacks and implementations, where they differ from the standard  * ones.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|transform_display_init
name|transform_display_init
parameter_list|(
name|transform_display
modifier|*
name|dp
parameter_list|,
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_uint_32
name|id
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
name|transform_list
parameter_list|)
block|{
comment|/* Standard fields */
name|standard_display_init
argument_list|(
operator|&
name|dp
operator|->
name|this
argument_list|,
operator|&
name|pm
operator|->
name|this
argument_list|,
name|id
argument_list|,
literal|0
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
comment|/* Parameter fields */
name|dp
operator|->
name|pm
operator|=
name|pm
expr_stmt|;
name|dp
operator|->
name|transform_list
operator|=
name|transform_list
expr_stmt|;
comment|/* Local variable fields */
name|dp
operator|->
name|output_colour_type
operator|=
literal|255
expr_stmt|;
comment|/* invalid */
name|dp
operator|->
name|output_bit_depth
operator|=
literal|255
expr_stmt|;
comment|/* invalid */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|transform_info_imp
name|transform_info_imp
parameter_list|(
name|transform_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
comment|/* Reuse the standard stuff as appropriate. */
name|standard_info_part1
argument_list|(
operator|&
name|dp
operator|->
name|this
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Now set the list of transforms. */
name|dp
operator|->
name|transform_list
operator|->
name|set
argument_list|(
name|dp
operator|->
name|transform_list
argument_list|,
name|dp
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Update the info structure for these transforms: */
name|png_read_update_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* And get the output information into the standard_display */
name|standard_info_part2
argument_list|(
operator|&
name|dp
operator|->
name|this
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
literal|1
comment|/*images*/
argument_list|)
expr_stmt|;
comment|/* Plus the extra stuff we need for the transform tests: */
name|dp
operator|->
name|output_colour_type
operator|=
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|dp
operator|->
name|output_bit_depth
operator|=
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Validate the combination of colour type and bit depth that we are getting     * out of libpng; the semantics of something not in the PNG spec are, at     * best, unclear.     */
switch|switch
condition|(
name|dp
operator|->
name|output_colour_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
if|if
condition|(
name|dp
operator|->
name|output_bit_depth
operator|>
literal|8
condition|)
goto|goto
name|error
goto|;
comment|/*FALL THROUGH*/
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
if|if
condition|(
name|dp
operator|->
name|output_bit_depth
operator|==
literal|1
operator|||
name|dp
operator|->
name|output_bit_depth
operator|==
literal|2
operator|||
name|dp
operator|->
name|output_bit_depth
operator|==
literal|4
condition|)
break|break;
comment|/*FALL THROUGH*/
default|default:
if|if
condition|(
name|dp
operator|->
name|output_bit_depth
operator|==
literal|8
operator|||
name|dp
operator|->
name|output_bit_depth
operator|==
literal|16
condition|)
break|break;
comment|/*FALL THROUGH*/
name|error
label|:
block|{
name|char
name|message
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|pos
decl_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
literal|0
argument_list|,
literal|"invalid final bit depth: colour type("
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|dp
operator|->
name|output_colour_type
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|") with bit depth: "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|dp
operator|->
name|output_bit_depth
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use a test pixel to check that the output agrees with what we expect -     * this avoids running the whole test if the output is unexpected.     */
block|{
name|image_pixel
name|test_pixel
decl_stmt|;
name|memset
argument_list|(
operator|&
name|test_pixel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|test_pixel
argument_list|)
expr_stmt|;
name|test_pixel
operator|.
name|colour_type
operator|=
name|dp
operator|->
name|this
operator|.
name|colour_type
expr_stmt|;
comment|/* input */
name|test_pixel
operator|.
name|bit_depth
operator|=
name|dp
operator|->
name|this
operator|.
name|bit_depth
expr_stmt|;
if|if
condition|(
name|test_pixel
operator|.
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|test_pixel
operator|.
name|sample_depth
operator|=
literal|8
expr_stmt|;
else|else
name|test_pixel
operator|.
name|sample_depth
operator|=
name|test_pixel
operator|.
name|bit_depth
expr_stmt|;
comment|/* Don't need sBIT here */
name|test_pixel
operator|.
name|have_tRNS
operator|=
name|dp
operator|->
name|this
operator|.
name|is_transparent
expr_stmt|;
name|dp
operator|->
name|transform_list
operator|->
name|mod
argument_list|(
name|dp
operator|->
name|transform_list
argument_list|,
operator|&
name|test_pixel
argument_list|,
name|pp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_pixel
operator|.
name|colour_type
operator|!=
name|dp
operator|->
name|output_colour_type
condition|)
block|{
name|char
name|message
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|pos
init|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
literal|0
argument_list|,
literal|"colour type "
argument_list|)
decl_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|dp
operator|->
name|output_colour_type
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|" expected "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|test_pixel
operator|.
name|colour_type
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|test_pixel
operator|.
name|bit_depth
operator|!=
name|dp
operator|->
name|output_bit_depth
condition|)
block|{
name|char
name|message
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|pos
init|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
literal|0
argument_list|,
literal|"bit depth "
argument_list|)
decl_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|dp
operator|->
name|output_bit_depth
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|" expected "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|test_pixel
operator|.
name|bit_depth
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/* If both bit depth and colour type are correct check the sample depth.        * I believe these are both internal errors.        */
if|if
condition|(
name|test_pixel
operator|.
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|test_pixel
operator|.
name|sample_depth
operator|!=
literal|8
condition|)
comment|/* oops - internal error! */
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"pngvalid: internal: palette sample depth not 8"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test_pixel
operator|.
name|sample_depth
operator|!=
name|dp
operator|->
name|output_bit_depth
condition|)
block|{
name|char
name|message
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|pos
init|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
literal|0
argument_list|,
literal|"internal: sample depth "
argument_list|)
decl_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|dp
operator|->
name|output_bit_depth
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|" expected "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|test_pixel
operator|.
name|sample_depth
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|transform_info
name|transform_info
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|transform_info_imp
argument_list|(
name|png_get_progressive_ptr
argument_list|(
name|pp
argument_list|)
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|transform_range_check
name|transform_range_check
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|unsigned
name|int
name|r
parameter_list|,
name|unsigned
name|int
name|g
parameter_list|,
name|unsigned
name|int
name|b
parameter_list|,
name|unsigned
name|int
name|a
parameter_list|,
name|unsigned
name|int
name|in_digitized
parameter_list|,
name|double
name|in
parameter_list|,
name|unsigned
name|int
name|out
parameter_list|,
name|png_byte
name|sample_depth
parameter_list|,
name|double
name|err
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Compare the scaled, digitzed, values of our local calculation (in+-err)     * with the digitized values libpng produced;  'sample_depth' is the actual     * digitization depth of the libpng output colors (the bit depth except for     * palette images where it is always 8.)     */
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
name|sample_depth
operator|)
operator|-
literal|1
decl_stmt|;
name|double
name|in_min
init|=
name|ceil
argument_list|(
operator|(
name|in
operator|-
name|err
operator|)
operator|*
name|max
operator|-
literal|.5
argument_list|)
decl_stmt|;
name|double
name|in_max
init|=
name|floor
argument_list|(
operator|(
name|in
operator|+
name|err
operator|)
operator|*
name|max
operator|+
literal|.5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|out
operator|>=
name|in_min
operator|&&
name|out
operator|<=
name|in_max
operator|)
condition|)
block|{
name|char
name|message
index|[
literal|256
index|]
decl_stmt|;
name|size_t
name|pos
decl_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|" output value error: rgba("
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|"): "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|" expected: "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
name|in_digitized
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatd
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
operator|(
name|in
operator|-
name|err
operator|)
operator|*
name|max
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatd
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
operator|(
name|in
operator|+
name|err
operator|)
operator|*
name|max
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|message
argument_list|,
sizeof|sizeof
name|message
argument_list|,
name|pos
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|transform_image_validate
name|transform_image_validate
parameter_list|(
name|transform_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|,
name|png_const_bytep
name|pRow
parameter_list|)
block|{
comment|/* Constants for the loop below: */
name|PNG_CONST
name|png_byte
name|in_ct
init|=
name|dp
operator|->
name|this
operator|.
name|colour_type
decl_stmt|;
name|PNG_CONST
name|png_byte
name|in_bd
init|=
name|dp
operator|->
name|this
operator|.
name|bit_depth
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|w
init|=
name|dp
operator|->
name|this
operator|.
name|w
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|h
init|=
name|dp
operator|->
name|this
operator|.
name|h
decl_stmt|;
name|PNG_CONST
name|size_t
name|cbRow
init|=
name|dp
operator|->
name|this
operator|.
name|cbRow
decl_stmt|;
name|PNG_CONST
name|png_byte
name|out_ct
init|=
name|dp
operator|->
name|output_colour_type
decl_stmt|;
name|PNG_CONST
name|png_byte
name|out_bd
init|=
name|dp
operator|->
name|output_bit_depth
decl_stmt|;
name|PNG_CONST
name|png_byte
name|sample_depth
init|=
call|(
name|png_byte
call|)
argument_list|(
name|out_ct
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|?
literal|8
else|:
name|out_bd
argument_list|)
decl_stmt|;
name|PNG_CONST
name|png_byte
name|red_sBIT
init|=
name|dp
operator|->
name|this
operator|.
name|red_sBIT
decl_stmt|;
name|PNG_CONST
name|png_byte
name|green_sBIT
init|=
name|dp
operator|->
name|this
operator|.
name|green_sBIT
decl_stmt|;
name|PNG_CONST
name|png_byte
name|blue_sBIT
init|=
name|dp
operator|->
name|this
operator|.
name|blue_sBIT
decl_stmt|;
name|PNG_CONST
name|png_byte
name|alpha_sBIT
init|=
name|dp
operator|->
name|this
operator|.
name|alpha_sBIT
decl_stmt|;
name|PNG_CONST
name|int
name|have_tRNS
init|=
name|dp
operator|->
name|this
operator|.
name|is_transparent
decl_stmt|;
name|standard_palette
name|out_palette
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
name|UNUSED
argument_list|(
argument|pi
argument_list|)
comment|/* Read the palette corresponding to the output if the output colour type     * indicates a palette, othewise set out_palette to garbage.     */
if|if
condition|(
name|out_ct
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
operator|(
name|void
operator|)
name|standard_palette_init
argument_list|(
name|out_palette
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|out_palette
argument_list|,
literal|0x5e
argument_list|,
sizeof|sizeof
name|out_palette
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
operator|,
name|pRow
operator|+=
name|cbRow
control|)
block|{
name|png_uint_32
name|x
decl_stmt|;
comment|/* The original, standard, row pre-transforms. */
name|png_byte
name|std
index|[
name|STANDARD_ROWMAX
index|]
decl_stmt|;
name|transform_row
argument_list|(
name|pp
argument_list|,
name|std
argument_list|,
name|in_ct
argument_list|,
name|in_bd
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Go through each original pixel transforming it and comparing with what        * libpng did to the same pixel.        */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|image_pixel
name|in_pixel
decl_stmt|,
name|out_pixel
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|a
decl_stmt|;
comment|/* Find out what we think the pixel should be: */
name|image_pixel_init
argument_list|(
operator|&
name|in_pixel
argument_list|,
name|std
argument_list|,
name|in_ct
argument_list|,
name|in_bd
argument_list|,
name|x
argument_list|,
name|dp
operator|->
name|this
operator|.
name|palette
argument_list|)
expr_stmt|;
name|in_pixel
operator|.
name|red_sBIT
operator|=
name|red_sBIT
expr_stmt|;
name|in_pixel
operator|.
name|green_sBIT
operator|=
name|green_sBIT
expr_stmt|;
name|in_pixel
operator|.
name|blue_sBIT
operator|=
name|blue_sBIT
expr_stmt|;
name|in_pixel
operator|.
name|alpha_sBIT
operator|=
name|alpha_sBIT
expr_stmt|;
name|in_pixel
operator|.
name|have_tRNS
operator|=
name|have_tRNS
expr_stmt|;
comment|/* For error detection, below. */
name|r
operator|=
name|in_pixel
operator|.
name|red
expr_stmt|;
name|g
operator|=
name|in_pixel
operator|.
name|green
expr_stmt|;
name|b
operator|=
name|in_pixel
operator|.
name|blue
expr_stmt|;
name|a
operator|=
name|in_pixel
operator|.
name|alpha
expr_stmt|;
name|dp
operator|->
name|transform_list
operator|->
name|mod
argument_list|(
name|dp
operator|->
name|transform_list
argument_list|,
operator|&
name|in_pixel
argument_list|,
name|pp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* Read the output pixel and compare it to what we got, we don't           * use the error field here, so no need to update sBIT.           */
name|image_pixel_init
argument_list|(
operator|&
name|out_pixel
argument_list|,
name|pRow
argument_list|,
name|out_ct
argument_list|,
name|out_bd
argument_list|,
name|x
argument_list|,
name|out_palette
argument_list|)
expr_stmt|;
comment|/* We don't expect changes to the index here even if the bit depth is           * changed.           */
if|if
condition|(
name|in_ct
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
name|out_ct
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|in_pixel
operator|.
name|palette_index
operator|!=
name|out_pixel
operator|.
name|palette_index
condition|)
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"unexpected transformed palette index"
argument_list|)
expr_stmt|;
block|}
comment|/* Check the colours for palette images too - in fact the palette could           * be separately verified itself in most cases.           */
if|if
condition|(
name|in_pixel
operator|.
name|red
operator|!=
name|out_pixel
operator|.
name|red
condition|)
name|transform_range_check
argument_list|(
name|pp
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|in_pixel
operator|.
name|red
argument_list|,
name|in_pixel
operator|.
name|redf
argument_list|,
name|out_pixel
operator|.
name|red
argument_list|,
name|sample_depth
argument_list|,
name|in_pixel
operator|.
name|rede
argument_list|,
literal|"red/gray"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out_ct
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
operator|&&
name|in_pixel
operator|.
name|green
operator|!=
name|out_pixel
operator|.
name|green
condition|)
name|transform_range_check
argument_list|(
name|pp
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|in_pixel
operator|.
name|green
argument_list|,
name|in_pixel
operator|.
name|greenf
argument_list|,
name|out_pixel
operator|.
name|green
argument_list|,
name|sample_depth
argument_list|,
name|in_pixel
operator|.
name|greene
argument_list|,
literal|"green"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out_ct
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
operator|&&
name|in_pixel
operator|.
name|blue
operator|!=
name|out_pixel
operator|.
name|blue
condition|)
name|transform_range_check
argument_list|(
name|pp
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|in_pixel
operator|.
name|blue
argument_list|,
name|in_pixel
operator|.
name|bluef
argument_list|,
name|out_pixel
operator|.
name|blue
argument_list|,
name|sample_depth
argument_list|,
name|in_pixel
operator|.
name|bluee
argument_list|,
literal|"blue"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out_ct
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
operator|&&
name|in_pixel
operator|.
name|alpha
operator|!=
name|out_pixel
operator|.
name|alpha
condition|)
name|transform_range_check
argument_list|(
name|pp
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|in_pixel
operator|.
name|alpha
argument_list|,
name|in_pixel
operator|.
name|alphaf
argument_list|,
name|out_pixel
operator|.
name|alpha
argument_list|,
name|sample_depth
argument_list|,
name|in_pixel
operator|.
name|alphae
argument_list|,
literal|"alpha"
argument_list|)
expr_stmt|;
block|}
comment|/* pixel (x) loop */
block|}
comment|/* row (y) loop */
comment|/* Record that something was actually checked to avoid a false positive. */
name|dp
operator|->
name|this
operator|.
name|ps
operator|->
name|validated
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|transform_end
name|transform_end
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|transform_display
modifier|*
name|dp
init|=
name|png_get_progressive_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|transform_image_validate
argument_list|(
name|dp
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|dp
operator|->
name|this
operator|.
name|ps
operator|->
name|image
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* A single test run. */
end_comment
begin_function
specifier|static
name|void
DECL|function|transform_test
name|transform_test
parameter_list|(
name|png_modifier
modifier|*
name|pmIn
parameter_list|,
name|PNG_CONST
name|png_uint_32
name|idIn
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
name|transform_listIn
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|name
parameter_list|)
block|{
name|transform_display
name|d
decl_stmt|;
name|context
argument_list|(
operator|&
name|pmIn
operator|->
name|this
argument_list|,
name|fault
argument_list|)
expr_stmt|;
name|transform_display_init
argument_list|(
operator|&
name|d
argument_list|,
name|pmIn
argument_list|,
name|idIn
argument_list|,
name|transform_listIn
argument_list|)
expr_stmt|;
name|Try
block|{
name|png_structp
name|pp
decl_stmt|;
name|png_infop
name|pi
decl_stmt|;
comment|/* Get a png_struct for writing the image. */
name|pp
operator|=
name|set_modifier_for_read
argument_list|(
name|d
operator|.
name|pm
argument_list|,
operator|&
name|pi
argument_list|,
name|d
operator|.
name|this
operator|.
name|id
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Logging (debugging only) */
block|{             char buffer[256];              (void)store_message(&d.pm->this, pp, buffer, sizeof buffer, 0,                "running test");              fprintf(stderr, "%s\n", buffer);          }
endif|#
directive|endif
comment|/* Introduce the correct read function. */
if|if
condition|(
name|d
operator|.
name|pm
operator|->
name|this
operator|.
name|progressive
condition|)
block|{
comment|/* Share the row function with the standard implementation. */
name|png_set_progressive_read_fn
argument_list|(
name|pp
argument_list|,
operator|&
name|d
argument_list|,
name|transform_info
argument_list|,
name|progressive_row
argument_list|,
name|transform_end
argument_list|)
expr_stmt|;
comment|/* Now feed data into the reader until we reach the end: */
name|modifier_progressive_read
argument_list|(
name|d
operator|.
name|pm
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* modifier_read expects a png_modifier* */
name|png_set_read_fn
argument_list|(
name|pp
argument_list|,
name|d
operator|.
name|pm
argument_list|,
name|modifier_read
argument_list|)
expr_stmt|;
comment|/* Check the header values: */
name|png_read_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Process the 'info' requirements. Only one image is generated */
name|transform_info_imp
argument_list|(
operator|&
name|d
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|sequential_row
argument_list|(
operator|&
name|d
operator|.
name|this
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|NULL
argument_list|,
name|d
operator|.
name|this
operator|.
name|ps
operator|->
name|image
argument_list|)
expr_stmt|;
name|transform_image_validate
argument_list|(
operator|&
name|d
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|d
operator|.
name|this
operator|.
name|ps
operator|->
name|image
argument_list|)
expr_stmt|;
block|}
name|modifier_reset
argument_list|(
name|d
operator|.
name|pm
argument_list|)
expr_stmt|;
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
name|modifier_reset
argument_list|(
operator|(
name|png_modifier
operator|*
operator|)
name|fault
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* The transforms: */
end_comment
begin_define
DECL|macro|ITSTRUCT
define|#
directive|define
name|ITSTRUCT
parameter_list|(
name|name
parameter_list|)
value|image_transform_##name
end_define
begin_define
DECL|macro|IT
define|#
directive|define
name|IT
parameter_list|(
name|name
parameter_list|,
name|prev
parameter_list|)
define|\
value|static image_transform ITSTRUCT(name) =\ {\    #name,\    1,
comment|/*enable*/
value|\&ITSTRUCT(prev),
comment|/*list*/
value|\    0,
comment|/*global_use*/
value|\    0,
comment|/*local_use*/
value|\    0,
comment|/*next*/
value|\    image_transform_png_set_##name##_set,\    image_transform_png_set_##name##_mod,\    image_transform_png_set_##name##_add\ }
end_define
begin_comment
comment|/* To save code: */
end_comment
begin_function
specifier|static
name|int
DECL|function|image_transform_default_add
name|image_transform_default_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|colour_type
argument_list|)
name|UNUSED
argument_list|(
argument|bit_depth
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* png_set_palette_to_rgb */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_palette_to_rgb_set
name|image_transform_png_set_palette_to_rgb_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_set_palette_to_rgb
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_palette_to_rgb_mod
name|image_transform_png_set_palette_to_rgb_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|image_pixel_convert_PLTE
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_palette_to_rgb_add
name|image_transform_png_set_palette_to_rgb_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|bit_depth
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
return|return
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|palette_to_rgb
argument_list|,
name|end
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_tRNS_to_alpha */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_tRNS_to_alpha_set
name|image_transform_png_set_tRNS_to_alpha_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_set_tRNS_to_alpha
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_tRNS_to_alpha_mod
name|image_transform_png_set_tRNS_to_alpha_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
comment|/* LIBPNG BUG: this always forces palette images to RGB. */
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|image_pixel_convert_PLTE
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
comment|/* This effectively does an 'expand' only if there is some transparency to     * covert to an alpha channel.     */
if|if
condition|(
name|that
operator|->
name|have_tRNS
condition|)
name|image_pixel_add_alpha
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
comment|/* LIBPNG BUG: otherwise libpng still expands to 8 bits! */
else|else
block|{
if|if
condition|(
name|that
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|that
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|sample_depth
operator|<
literal|8
condition|)
name|that
operator|->
name|sample_depth
operator|=
literal|8
expr_stmt|;
block|}
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_tRNS_to_alpha_add
name|image_transform_png_set_tRNS_to_alpha_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|bit_depth
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
comment|/* We don't know yet whether there will be a tRNS chunk, but we know that     * this transformation should do nothing if there already is an alpha     * channel.     */
return|return
operator|(
name|colour_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|tRNS_to_alpha
argument_list|,
name|palette_to_rgb
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_gray_to_rgb */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_gray_to_rgb_set
name|image_transform_png_set_gray_to_rgb_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_set_gray_to_rgb
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_gray_to_rgb_mod
name|image_transform_png_set_gray_to_rgb_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
comment|/* NOTE: we can actually pend the tRNS processing at this point because we     * can correctly recognize the original pixel value even though we have     * mapped the one gray channel to the three RGB ones, but in fact libpng     * doesn't do this, so we don't either.     */
if|if
condition|(
operator|(
name|that
operator|->
name|colour_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
operator|&&
name|that
operator|->
name|have_tRNS
condition|)
name|image_pixel_add_alpha
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
comment|/* Simply expand the bit depth and alter the colour type as required. */
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
comment|/* RGB images have a bit depth at least equal to '8' */
if|if
condition|(
name|that
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|that
operator|->
name|sample_depth
operator|=
name|that
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
comment|/* And just changing the colour type works here because the green and blue        * channels are being maintained in lock-step with the red/gray:        */
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_RGB_ALPHA
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_gray_to_rgb_add
name|image_transform_png_set_gray_to_rgb_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|bit_depth
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
return|return
operator|(
name|colour_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|gray_to_rgb
argument_list|,
name|tRNS_to_alpha
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_expand */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_expand_set
name|image_transform_png_set_expand_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_set_expand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_expand_mod
name|image_transform_png_set_expand_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
comment|/* The general expand case depends on what the colour type is: */
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|image_pixel_convert_PLTE
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|that
operator|->
name|bit_depth
operator|<
literal|8
condition|)
comment|/* grayscale */
name|that
operator|->
name|sample_depth
operator|=
name|that
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|have_tRNS
condition|)
name|image_pixel_add_alpha
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_expand_add
name|image_transform_png_set_expand_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|bit_depth
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
comment|/* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit     * depth is at least 8 already.     */
return|return
operator|(
name|colour_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|expand
argument_list|,
name|gray_to_rgb
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_expand_gray_1_2_4_to_8  * LIBPNG BUG: this just does an 'expand'  */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_expand_gray_1_2_4_to_8_set
name|image_transform_png_set_expand_gray_1_2_4_to_8_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_set_expand_gray_1_2_4_to_8
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_expand_gray_1_2_4_to_8_mod
name|image_transform_png_set_expand_gray_1_2_4_to_8_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
name|image_transform_png_set_expand_mod
argument_list|(
name|this
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_expand_gray_1_2_4_to_8_add
name|image_transform_png_set_expand_gray_1_2_4_to_8_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
return|return
name|image_transform_png_set_expand_add
argument_list|(
name|this
argument_list|,
name|that
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|expand_gray_1_2_4_to_8
argument_list|,
name|expand
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_strip_16 */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_strip_16_set
name|image_transform_png_set_strip_16_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_set_strip_16
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_strip_16_mod
name|image_transform_png_set_strip_16_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
if|if
condition|(
name|that
operator|->
name|bit_depth
operator|==
literal|16
condition|)
block|{
name|that
operator|->
name|sample_depth
operator|=
name|that
operator|->
name|bit_depth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|red_sBIT
operator|>
literal|8
condition|)
name|that
operator|->
name|red_sBIT
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|green_sBIT
operator|>
literal|8
condition|)
name|that
operator|->
name|green_sBIT
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|blue_sBIT
operator|>
literal|8
condition|)
name|that
operator|->
name|blue_sBIT
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|alpha_sBIT
operator|>
literal|8
condition|)
name|that
operator|->
name|alpha_sBIT
operator|=
literal|8
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
comment|/* The strip 16 algoirithm drops the low 8 bits rather than calculating           * 1/257, so we need to adjust the permitted errors appropriately:           */
block|{
name|PNG_CONST
name|double
name|d
init|=
operator|(
literal|255
operator|-
literal|128.5
operator|)
operator|/
literal|65535
decl_stmt|;
name|that
operator|->
name|rede
operator|+=
name|d
expr_stmt|;
name|that
operator|->
name|greene
operator|+=
name|d
expr_stmt|;
name|that
operator|->
name|bluee
operator|+=
name|d
expr_stmt|;
name|that
operator|->
name|alphae
operator|+=
name|d
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_strip_16_add
name|image_transform_png_set_strip_16_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|colour_type
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
return|return
name|bit_depth
operator|>
literal|8
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|strip_16
argument_list|,
name|expand_gray_1_2_4_to_8
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_strip_alpha */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_strip_alpha_set
name|image_transform_png_set_strip_alpha_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_set_strip_alpha
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_strip_alpha_mod
name|image_transform_png_set_strip_alpha_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
name|that
operator|->
name|have_tRNS
operator|=
literal|0
expr_stmt|;
name|that
operator|->
name|alphaf
operator|=
literal|1
expr_stmt|;
name|that
operator|->
name|alphae
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_strip_alpha_add
name|image_transform_png_set_strip_alpha_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|bit_depth
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
return|return
operator|(
name|colour_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|strip_alpha
argument_list|,
name|strip_16
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_rgb_to_gray(png_structp, int err_action, double red, double green)  * png_set_rgb_to_gray_fixed(png_structp, int err_action, png_fixed_point red,  *    png_fixed_point green)  * png_get_rgb_to_gray_status  *  * At present the APIs are simply tested using the 16.16 fixed point conversion  * values known to be used inside libpng:  *  *   red:    6968  *   green: 23434  *   blue:   2366  *  * NOTE: this currently ignores the gamma because no gamma is being set, the  * tests on gamma need to happen in the gamma test set.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_rgb_to_gray_set
name|image_transform_png_set_rgb_to_gray_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|PNG_CONST
name|int
name|error_action
init|=
literal|1
decl_stmt|;
comment|/* no error, no defines in png.h */
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
name|png_set_rgb_to_gray
argument_list|(
name|pp
argument_list|,
name|error_action
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_set_rgb_to_gray_fixed
argument_list|(
name|pp
argument_list|,
name|error_action
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_rgb_to_gray_mod
name|image_transform_png_set_rgb_to_gray_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
if|if
condition|(
operator|(
name|that
operator|->
name|colour_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|image_pixel_convert_PLTE
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
comment|/* Image now has RGB channels... */
name|that
operator|->
name|bluef
operator|=
name|that
operator|->
name|greenf
operator|=
name|that
operator|->
name|redf
operator|=
operator|(
name|that
operator|->
name|redf
operator|*
literal|6968
operator|+
name|that
operator|->
name|greenf
operator|*
literal|23434
operator|+
name|that
operator|->
name|bluef
operator|*
literal|2366
operator|)
operator|/
literal|32768
expr_stmt|;
name|that
operator|->
name|bluee
operator|=
name|that
operator|->
name|greene
operator|=
name|that
operator|->
name|rede
operator|=
operator|(
name|that
operator|->
name|rede
operator|*
literal|6968
operator|+
name|that
operator|->
name|greene
operator|*
literal|23434
operator|+
name|that
operator|->
name|bluee
operator|*
literal|2366
operator|)
operator|/
literal|32768
operator|*
operator|(
literal|1
operator|+
name|DBL_EPSILON
operator|*
literal|6
operator|)
expr_stmt|;
comment|/* The sBIT is the minium of the three colour channel sBITs. */
if|if
condition|(
name|that
operator|->
name|red_sBIT
operator|>
name|that
operator|->
name|green_sBIT
condition|)
name|that
operator|->
name|red_sBIT
operator|=
name|that
operator|->
name|green_sBIT
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|red_sBIT
operator|>
name|that
operator|->
name|blue_sBIT
condition|)
name|that
operator|->
name|red_sBIT
operator|=
name|that
operator|->
name|blue_sBIT
expr_stmt|;
name|that
operator|->
name|blue_sBIT
operator|=
name|that
operator|->
name|green_sBIT
operator|=
name|that
operator|->
name|red_sBIT
expr_stmt|;
comment|/* And zap the colour bit in the type: */
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
elseif|else
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_GRAY_ALPHA
expr_stmt|;
block|}
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_png_set_rgb_to_gray_add
name|image_transform_png_set_rgb_to_gray_add
parameter_list|(
name|image_transform
modifier|*
name|this
parameter_list|,
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|that
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|bit_depth
argument_list|)
name|this
operator|->
name|next
operator|=
operator|*
name|that
expr_stmt|;
operator|*
name|that
operator|=
name|this
expr_stmt|;
return|return
operator|(
name|colour_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
return|;
block|}
end_function
begin_expr_stmt
name|IT
argument_list|(
name|rgb_to_gray
argument_list|,
name|strip_alpha
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* png_set_background(png_structp, png_const_color_16p background_color,  *    int background_gamma_code, int need_expand, double background_gamma)  * png_set_background_fixed(png_structp, png_const_color_16p background_color,  *    int background_gamma_code, int need_expand,  *    png_fixed_point background_gamma)  *  * As with rgb_to_gray this ignores the gamma. */
end_comment
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_background_set
name|image_transform_png_set_background_set
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|transform_display
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|png_color_16
name|back
decl_stmt|;
comment|/* Since we don't know the output bit depth at this point we must use the     * input values and ask libpng to expand the chunk as required.     */
name|back
operator|.
name|index
operator|=
literal|255
expr_stmt|;
comment|/* Should not be used */
name|back
operator|.
name|gray
operator|=
name|back
operator|.
name|blue
operator|=
name|back
operator|.
name|green
operator|=
name|back
operator|.
name|red
operator|=
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
literal|1U
operator|<<
name|that
operator|->
name|this
operator|.
name|bit_depth
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
name|png_set_background
argument_list|(
name|pp
argument_list|,
operator|&
name|back
argument_list|,
name|PNG_BACKGROUND_GAMMA_FILE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_set_background_fixed
argument_list|(
name|pp
argument_list|,
operator|&
name|back
argument_list|,
name|PNG_BACKGROUND_GAMMA_FILE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_png_set_background_mod
name|image_transform_png_set_background_mod
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
name|this
parameter_list|,
name|image_pixel
modifier|*
name|that
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|PNG_CONST
name|transform_display
modifier|*
name|display
parameter_list|)
block|{
comment|/* Check for tRNS first: */
if|if
condition|(
name|that
operator|->
name|have_tRNS
operator|&&
name|that
operator|->
name|colour_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|image_pixel_add_alpha
argument_list|(
name|that
argument_list|,
operator|&
name|display
operator|->
name|this
argument_list|)
expr_stmt|;
comment|/* This is only necessary if the alpha value is less than 1. */
if|if
condition|(
name|that
operator|->
name|alphaf
operator|<
literal|1
condition|)
block|{
comment|/* Repeat the calculation above and scale the result: */
name|unsigned
name|int
name|tmp
init|=
operator|(
literal|1U
operator|<<
name|display
operator|->
name|this
operator|.
name|bit_depth
operator|)
decl_stmt|;
name|double
name|component
init|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|/
call|(
name|double
call|)
argument_list|(
name|tmp
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/* Now we do the background calculation without any gamma correction. */
if|if
condition|(
name|that
operator|->
name|alphaf
operator|<=
literal|0
condition|)
block|{
name|that
operator|->
name|bluef
operator|=
name|that
operator|->
name|greenf
operator|=
name|that
operator|->
name|redf
operator|=
name|component
expr_stmt|;
name|that
operator|->
name|bluee
operator|=
name|that
operator|->
name|greene
operator|=
name|that
operator|->
name|rede
operator|=
name|component
operator|*
name|DBL_EPSILON
expr_stmt|;
name|that
operator|->
name|blue_sBIT
operator|=
name|that
operator|->
name|green_sBIT
operator|=
name|that
operator|->
name|red_sBIT
operator|=
name|that
operator|->
name|bit_depth
expr_stmt|;
block|}
else|else
block|{
name|component
operator|*=
literal|1
operator|-
name|that
operator|->
name|alphaf
expr_stmt|;
name|that
operator|->
name|redf
operator|=
name|that
operator|->
name|redf
operator|*
name|that
operator|->
name|alphaf
operator|+
name|component
expr_stmt|;
name|that
operator|->
name|rede
operator|=
name|that
operator|->
name|rede
operator|*
name|that
operator|->
name|alphaf
operator|+
name|that
operator|->
name|redf
operator|*
literal|3
operator|*
name|DBL_EPSILON
expr_stmt|;
name|that
operator|->
name|greenf
operator|=
name|that
operator|->
name|greenf
operator|*
name|that
operator|->
name|alphaf
operator|+
name|component
expr_stmt|;
name|that
operator|->
name|greene
operator|=
name|that
operator|->
name|greene
operator|*
name|that
operator|->
name|alphaf
operator|+
name|that
operator|->
name|greenf
operator|*
literal|3
operator|*
name|DBL_EPSILON
expr_stmt|;
name|that
operator|->
name|bluef
operator|=
name|that
operator|->
name|bluef
operator|*
name|that
operator|->
name|alphaf
operator|+
name|component
expr_stmt|;
name|that
operator|->
name|bluee
operator|=
name|that
operator|->
name|bluee
operator|*
name|that
operator|->
name|alphaf
operator|+
name|that
operator|->
name|bluef
operator|*
literal|3
operator|*
name|DBL_EPSILON
expr_stmt|;
block|}
comment|/* Remove the alpha type and set the alpha. */
name|that
operator|->
name|alphaf
operator|=
literal|1
expr_stmt|;
name|that
operator|->
name|alphae
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_RGB
expr_stmt|;
elseif|else
if|if
condition|(
name|that
operator|->
name|colour_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
name|that
operator|->
name|colour_type
operator|=
name|PNG_COLOR_TYPE_GRAY
expr_stmt|;
block|}
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|image_transform_png_set_background_add
define|#
directive|define
name|image_transform_png_set_background_add
value|image_transform_default_add
end_define
begin_expr_stmt
name|IT
argument_list|(
name|background
argument_list|,
name|rgb_to_gray
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
DECL|variable|image_transform_first
specifier|static
name|image_transform
modifier|*
name|PNG_CONST
name|image_transform_first
init|=
operator|&
name|ITSTRUCT
argument_list|(
name|background
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|void
DECL|function|transform_enable
name|transform_enable
parameter_list|(
name|PNG_CONST
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Everything starts out enabled, so if we see an 'enable' disabled     * everything else the first time round.     */
specifier|static
name|int
name|all_disabled
init|=
literal|0
decl_stmt|;
name|int
name|found_it
init|=
literal|0
decl_stmt|;
name|image_transform
modifier|*
name|list
init|=
name|image_transform_first
decl_stmt|;
while|while
condition|(
name|list
operator|!=
operator|&
name|image_transform_end
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|list
operator|->
name|enable
operator|=
literal|1
expr_stmt|;
name|found_it
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|all_disabled
condition|)
name|list
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|list
expr_stmt|;
block|}
name|all_disabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|found_it
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: --transform-enable=%s: unknown transform\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|transform_disable
name|transform_disable
parameter_list|(
name|PNG_CONST
name|char
modifier|*
name|name
parameter_list|)
block|{
name|image_transform
modifier|*
name|list
init|=
name|image_transform_first
decl_stmt|;
while|while
condition|(
name|list
operator|!=
operator|&
name|image_transform_end
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|list
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|list
operator|->
name|list
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: --transform-disable=%s: unknown transform\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|image_transform_reset_count
name|image_transform_reset_count
parameter_list|(
name|void
parameter_list|)
block|{
name|image_transform
modifier|*
name|next
init|=
name|image_transform_first
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next
operator|!=
operator|&
name|image_transform_end
condition|)
block|{
name|next
operator|->
name|local_use
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|list
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
comment|/* This can only happen if we every have more than 32 transforms (excluding     * the end) in the list.     */
if|if
condition|(
name|count
operator|>
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|image_transform_test_counter
name|image_transform_test_counter
parameter_list|(
name|png_uint_32
name|counter
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|)
block|{
comment|/* Test the list to see if there is any point contining, given a current     * counter and a 'max' value.     */
name|image_transform
modifier|*
name|next
init|=
name|image_transform_first
decl_stmt|;
while|while
condition|(
name|next
operator|!=
operator|&
name|image_transform_end
condition|)
block|{
comment|/* For max 0 or 1 continue until the counter overflows: */
name|counter
operator|>>=
literal|1
expr_stmt|;
comment|/* Continue if any entry hasn't reacked the max. */
if|if
condition|(
name|max
operator|>
literal|1
operator|&&
name|next
operator|->
name|local_use
operator|<
name|max
condition|)
return|return
literal|1
return|;
name|next
operator|=
name|next
operator|->
name|list
expr_stmt|;
block|}
return|return
name|max
operator|<=
literal|1
operator|&&
name|counter
operator|==
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|image_transform_add
name|image_transform_add
parameter_list|(
name|PNG_CONST
name|image_transform
modifier|*
modifier|*
name|this
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|,
name|png_uint_32
name|counter
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|sizeof_name
parameter_list|,
name|size_t
modifier|*
name|pos
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
comment|/* until we manage to add something */
block|{
name|png_uint_32
name|mask
decl_stmt|;
name|image_transform
modifier|*
name|list
decl_stmt|;
comment|/* Find the next counter value, if the counter is zero this is the start        * of the list.  This routine always returns the current counter (not the        * next) so it returns 0 at the end and expects 0 at the beginning.        */
if|if
condition|(
name|counter
operator|==
literal|0
condition|)
comment|/* first time */
block|{
name|image_transform_reset_count
argument_list|()
expr_stmt|;
if|if
condition|(
name|max
operator|<=
literal|1
condition|)
name|counter
operator|=
literal|1
expr_stmt|;
else|else
name|counter
operator|=
name|random_32
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* advance the counter */
block|{
switch|switch
condition|(
name|max
condition|)
block|{
case|case
literal|0
case|:
operator|++
name|counter
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|counter
operator|<<=
literal|1
expr_stmt|;
break|break;
default|default:
name|counter
operator|=
name|random_32
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now add all these items, if possible */
operator|*
name|this
operator|=
operator|&
name|image_transform_end
expr_stmt|;
name|list
operator|=
name|image_transform_first
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
comment|/* Go through the whole list adding anything that the counter selects: */
while|while
condition|(
name|list
operator|!=
operator|&
name|image_transform_end
condition|)
block|{
if|if
condition|(
operator|(
name|counter
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
name|list
operator|->
name|enable
operator|&&
operator|(
name|max
operator|==
literal|0
operator|||
name|list
operator|->
name|local_use
operator|<
name|max
operator|)
condition|)
block|{
comment|/* Candidate to add: */
if|if
condition|(
name|list
operator|->
name|add
argument_list|(
name|list
argument_list|,
name|this
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
operator|||
name|max
operator|==
literal|0
condition|)
block|{
comment|/* Added, so add to the name too. */
operator|*
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
name|sizeof_name
argument_list|,
operator|*
name|pos
argument_list|,
literal|" +"
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
name|sizeof_name
argument_list|,
operator|*
name|pos
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not useful and max>0, so remvoe it from *this: */
operator|*
name|this
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* And, since we know it isn't useful, stop it being added again                 * in this run:                 */
name|list
operator|->
name|local_use
operator|=
name|max
expr_stmt|;
block|}
block|}
name|mask
operator|<<=
literal|1
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|list
expr_stmt|;
block|}
comment|/* Now if anything was added we have something to do. */
if|if
condition|(
operator|*
name|this
operator|!=
operator|&
name|image_transform_end
condition|)
return|return
name|counter
return|;
comment|/* Nothing added, but was there anything in there to add? */
if|if
condition|(
operator|!
name|image_transform_test_counter
argument_list|(
name|counter
argument_list|,
name|max
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|THIS_IS_THE_PROFORMA
end_ifdef
begin_expr_stmt
specifier|static
name|void
DECL|function|_set
name|image_transform_png_set_
expr|@
name|_set
argument_list|(
argument|PNG_CONST image_transform *this
argument_list|,
argument|transform_display *that
argument_list|,
argument|png_structp pp
argument_list|,
argument|png_infop pi
argument_list|)
block|{
name|png_set_
expr|@
operator|(
name|pp
operator|)
block|;
name|this
operator|->
name|next
operator|->
name|set
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
block|; }
specifier|static
name|void
DECL|function|_mod
name|image_transform_png_set_
expr|@
name|_mod
argument_list|(
argument|PNG_CONST image_transform *this
argument_list|,
argument|image_pixel *that
argument_list|,
argument|png_structp pp
argument_list|,
argument|PNG_CONST transform_display *display
argument_list|)
block|{
name|this
operator|->
name|next
operator|->
name|mod
argument_list|(
name|this
operator|->
name|next
argument_list|,
name|that
argument_list|,
name|pp
argument_list|,
name|display
argument_list|)
block|; }
specifier|static
name|int
DECL|function|_add
name|image_transform_png_set_
expr|@
name|_add
argument_list|(
argument|image_transform *this
argument_list|,
argument|PNG_CONST image_transform **that
argument_list|,
argument|char *name
argument_list|,
argument|size_t sizeof_name
argument_list|,
argument|size_t *pos
argument_list|,
argument|png_byte colour_type
argument_list|,
argument|png_byte bit_depth
argument_list|)
block|{
name|this
operator|->
name|next
operator|=
operator|*
name|that
block|;
operator|*
name|that
operator|=
name|this
block|;
operator|*
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
name|sizeof_name
argument_list|,
operator|*
name|pos
argument_list|,
literal|" +@"
argument_list|)
block|;
return|return
literal|1
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|IT
argument_list|(
argument|@
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* png_set_quantize(png_structp, png_colorp palette, int num_palette,  *    int maximum_colors, png_const_uint_16p histogram, int full_quantize)  *  * Very difficult to validate this!  */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* The data layout transforms are handled by swapping our own channel data,  * necessarily these need to happen at the end of the transform list because the  * semantic of the channels changes after these are executed.  Some of these,  * like set_shift and set_packing, can't be done at present because they change  * the layout of the data at the sub-sample level so sample() won't get the  * right answer.  */
end_comment
begin_comment
comment|/* png_set_invert_alpha */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_bgr */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_swap_alpha */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_swap */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_filler, (png_structp png_ptr, png_uint_32 filler, int flags)); */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_add_alpha, (png_structp png_ptr, png_uint_32 filler, int flags)); */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_packing */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_packswap */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_invert_mono */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_comment
comment|/* png_set_shift(png_structp, png_const_color_8p true_bits) */
end_comment
begin_comment
comment|/*NOTE: TBD NYI */
end_comment
begin_function
specifier|static
name|int
DECL|function|test_transform
name|test_transform
parameter_list|(
name|png_modifier
modifier|*
name|PNG_CONST
name|pm
parameter_list|,
name|png_byte
name|PNG_CONST
name|colour_type
parameter_list|,
name|int
name|bdlo
parameter_list|,
name|int
name|PNG_CONST
name|bdhi
parameter_list|,
name|png_uint_32
name|max
parameter_list|)
block|{
for|for
control|(
init|;
name|bdlo
operator|<=
name|bdhi
condition|;
operator|++
name|bdlo
control|)
block|{
name|PNG_CONST
name|png_byte
name|bit_depth
init|=
name|DEPTH
argument_list|(
name|bdlo
argument_list|)
decl_stmt|;
name|png_uint_32
name|counter
init|=
literal|0
decl_stmt|;
name|size_t
name|base_pos
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|base_pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|0
argument_list|,
literal|"transform:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
name|pos
init|=
name|base_pos
decl_stmt|;
name|PNG_CONST
name|image_transform
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|counter
operator|=
name|image_transform_add
argument_list|(
operator|&
name|list
argument_list|,
name|max
argument_list|,
name|counter
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
operator|&
name|pos
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|==
literal|0
condition|)
break|break;
comment|/* The command line can change this to checking interlaced images. */
name|transform_test
argument_list|(
name|pm
argument_list|,
name|FILEID
argument_list|(
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|list
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
comment|/* keep going */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|perform_transform_test
name|perform_transform_test
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
comment|/* Test each colour type over the valid range of bit depths (expressed as     * log2(bit_depth) in turn, stop as soon as any error is detected.     */
if|if
condition|(
operator|!
name|test_transform
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|READ_BDHI
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_transform
argument_list|(
name|pm
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_transform
argument_list|(
name|pm
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_transform
argument_list|(
name|pm
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|test_transform
argument_list|(
name|pm
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
name|READ_BDHI
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
block|}
end_function
begin_comment
comment|/********************************* GAMMA TESTS ********************************/
end_comment
begin_comment
comment|/* Gamma test images. */
end_comment
begin_typedef
DECL|struct|gamma_modification
typedef|typedef
struct|struct
name|gamma_modification
block|{
DECL|member|this
name|png_modification
name|this
decl_stmt|;
DECL|member|gamma
name|png_fixed_point
name|gamma
decl_stmt|;
block|}
DECL|typedef|gamma_modification
name|gamma_modification
typedef|;
end_typedef
begin_function
specifier|static
name|int
DECL|function|gamma_modify
name|gamma_modify
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_modification
modifier|*
name|me
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|add
argument_list|)
comment|/* This simply dumps the given gamma value into the buffer. */
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
operator|+
literal|4
argument_list|,
name|CHUNK_gAMA
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
operator|+
literal|8
argument_list|,
operator|(
operator|(
name|gamma_modification
operator|*
operator|)
name|me
operator|)
operator|->
name|gamma
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gamma_modification_init
name|gamma_modification_init
parameter_list|(
name|gamma_modification
modifier|*
name|me
parameter_list|,
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|double
name|gammad
parameter_list|)
block|{
name|double
name|g
decl_stmt|;
name|modification_init
argument_list|(
operator|&
name|me
operator|->
name|this
argument_list|)
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|chunk
operator|=
name|CHUNK_gAMA
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|modify_fn
operator|=
name|gamma_modify
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|add
operator|=
name|CHUNK_PLTE
expr_stmt|;
name|g
operator|=
name|floor
argument_list|(
name|gammad
operator|*
literal|100000
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|me
operator|->
name|gamma
operator|=
operator|(
name|png_fixed_point
operator|)
name|g
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|next
operator|=
name|pm
operator|->
name|modifications
expr_stmt|;
name|pm
operator|->
name|modifications
operator|=
operator|&
name|me
operator|->
name|this
expr_stmt|;
block|}
end_function
begin_typedef
DECL|struct|srgb_modification
typedef|typedef
struct|struct
name|srgb_modification
block|{
DECL|member|this
name|png_modification
name|this
decl_stmt|;
DECL|member|intent
name|png_byte
name|intent
decl_stmt|;
block|}
DECL|typedef|srgb_modification
name|srgb_modification
typedef|;
end_typedef
begin_function
specifier|static
name|int
DECL|function|srgb_modify
name|srgb_modify
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_modification
modifier|*
name|me
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|UNUSED
argument_list|(
argument|add
argument_list|)
comment|/* As above, ignore add and just make a new chunk */
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
operator|+
literal|4
argument_list|,
name|CHUNK_sRGB
argument_list|)
expr_stmt|;
name|pm
operator|->
name|buffer
index|[
literal|8
index|]
operator|=
operator|(
operator|(
name|srgb_modification
operator|*
operator|)
name|me
operator|)
operator|->
name|intent
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|srgb_modification_init
name|srgb_modification_init
parameter_list|(
name|srgb_modification
modifier|*
name|me
parameter_list|,
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_byte
name|intent
parameter_list|)
block|{
name|modification_init
argument_list|(
operator|&
name|me
operator|->
name|this
argument_list|)
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|chunk
operator|=
name|CHUNK_sBIT
expr_stmt|;
if|if
condition|(
name|intent
operator|<=
literal|3
condition|)
comment|/* if valid, else *delete* sRGB chunks */
block|{
name|me
operator|->
name|this
operator|.
name|modify_fn
operator|=
name|srgb_modify
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|add
operator|=
name|CHUNK_PLTE
expr_stmt|;
name|me
operator|->
name|intent
operator|=
name|intent
expr_stmt|;
block|}
else|else
block|{
name|me
operator|->
name|this
operator|.
name|modify_fn
operator|=
literal|0
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|add
operator|=
literal|0
expr_stmt|;
name|me
operator|->
name|intent
operator|=
literal|0
expr_stmt|;
block|}
name|me
operator|->
name|this
operator|.
name|next
operator|=
name|pm
operator|->
name|modifications
expr_stmt|;
name|pm
operator|->
name|modifications
operator|=
operator|&
name|me
operator|->
name|this
expr_stmt|;
block|}
end_function
begin_typedef
DECL|struct|sbit_modification
typedef|typedef
struct|struct
name|sbit_modification
block|{
DECL|member|this
name|png_modification
name|this
decl_stmt|;
DECL|member|sbit
name|png_byte
name|sbit
decl_stmt|;
block|}
DECL|typedef|sbit_modification
name|sbit_modification
typedef|;
end_typedef
begin_function
specifier|static
name|int
DECL|function|sbit_modify
name|sbit_modify
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_modification
modifier|*
name|me
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|png_byte
name|sbit
init|=
operator|(
operator|(
name|sbit_modification
operator|*
operator|)
name|me
operator|)
operator|->
name|sbit
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|bit_depth
operator|>
name|sbit
condition|)
block|{
name|int
name|cb
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pm
operator|->
name|colour_type
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|cb
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cb
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|cb
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|pm
operator|->
name|this
operator|.
name|pread
argument_list|,
literal|"unexpected colour type in sBIT modification"
argument_list|)
expr_stmt|;
block|}
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|pm
operator|->
name|buffer
operator|+
literal|4
argument_list|,
name|CHUNK_sBIT
argument_list|)
expr_stmt|;
while|while
condition|(
name|cb
operator|>
literal|0
condition|)
operator|(
name|pm
operator|->
name|buffer
operator|+
literal|8
operator|)
index|[
operator|--
name|cb
index|]
operator|=
name|sbit
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|add
condition|)
block|{
comment|/* Remove the sBIT chunk */
name|pm
operator|->
name|buffer_count
operator|=
name|pm
operator|->
name|buffer_position
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
comment|/* do nothing */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|sbit_modification_init
name|sbit_modification_init
parameter_list|(
name|sbit_modification
modifier|*
name|me
parameter_list|,
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_byte
name|sbit
parameter_list|)
block|{
name|modification_init
argument_list|(
operator|&
name|me
operator|->
name|this
argument_list|)
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|chunk
operator|=
name|CHUNK_sBIT
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|modify_fn
operator|=
name|sbit_modify
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|add
operator|=
name|CHUNK_PLTE
expr_stmt|;
name|me
operator|->
name|sbit
operator|=
name|sbit
expr_stmt|;
name|me
operator|->
name|this
operator|.
name|next
operator|=
name|pm
operator|->
name|modifications
expr_stmt|;
name|pm
operator|->
name|modifications
operator|=
operator|&
name|me
operator|->
name|this
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Reader callbacks and implementations, where they differ from the standard  * ones.  */
end_comment
begin_typedef
DECL|struct|gamma_display
typedef|typedef
struct|struct
name|gamma_display
block|{
DECL|member|this
name|standard_display
name|this
decl_stmt|;
comment|/* Parameters */
DECL|member|pm
name|png_modifier
modifier|*
name|pm
decl_stmt|;
DECL|member|file_gamma
name|double
name|file_gamma
decl_stmt|;
DECL|member|screen_gamma
name|double
name|screen_gamma
decl_stmt|;
DECL|member|sbit
name|png_byte
name|sbit
decl_stmt|;
DECL|member|threshold_test
name|int
name|threshold_test
decl_stmt|;
DECL|member|name
name|PNG_CONST
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|speed
name|int
name|speed
decl_stmt|;
DECL|member|use_input_precision
name|int
name|use_input_precision
decl_stmt|;
DECL|member|strip16
name|int
name|strip16
decl_stmt|;
comment|/* Local variables */
DECL|member|maxerrout
name|double
name|maxerrout
decl_stmt|;
DECL|member|maxerrpc
name|double
name|maxerrpc
decl_stmt|;
DECL|member|maxerrabs
name|double
name|maxerrabs
decl_stmt|;
block|}
DECL|typedef|gamma_display
name|gamma_display
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|gamma_display_init
name|gamma_display_init
parameter_list|(
name|gamma_display
modifier|*
name|dp
parameter_list|,
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_uint_32
name|id
parameter_list|,
name|double
name|file_gamma
parameter_list|,
name|double
name|screen_gamma
parameter_list|,
name|png_byte
name|sbit
parameter_list|,
name|int
name|threshold_test
parameter_list|,
name|int
name|speed
parameter_list|,
name|int
name|use_input_precision
parameter_list|,
name|int
name|strip16
parameter_list|)
block|{
comment|/* Standard fields */
name|standard_display_init
argument_list|(
operator|&
name|dp
operator|->
name|this
argument_list|,
operator|&
name|pm
operator|->
name|this
argument_list|,
name|id
argument_list|,
literal|0
comment|/*do_interlace*/
argument_list|)
expr_stmt|;
comment|/* Parameter fields */
name|dp
operator|->
name|pm
operator|=
name|pm
expr_stmt|;
name|dp
operator|->
name|file_gamma
operator|=
name|file_gamma
expr_stmt|;
name|dp
operator|->
name|screen_gamma
operator|=
name|screen_gamma
expr_stmt|;
name|dp
operator|->
name|sbit
operator|=
name|sbit
expr_stmt|;
name|dp
operator|->
name|threshold_test
operator|=
name|threshold_test
expr_stmt|;
name|dp
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|dp
operator|->
name|use_input_precision
operator|=
name|use_input_precision
expr_stmt|;
name|dp
operator|->
name|strip16
operator|=
name|strip16
expr_stmt|;
comment|/* Local variable fields */
name|dp
operator|->
name|maxerrout
operator|=
name|dp
operator|->
name|maxerrpc
operator|=
name|dp
operator|->
name|maxerrabs
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gamma_info_imp
name|gamma_info_imp
parameter_list|(
name|gamma_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
comment|/* Reuse the standard stuff as appropriate. */
name|standard_info_part1
argument_list|(
operator|&
name|dp
operator|->
name|this
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* If requested strip 16 to 8 bits - this is handled automagically below     * because the output bit depth is read from the library.  Note that there     * are interactions with sBIT but, internally, libpng makes sbit at most     * PNG_MAX_GAMMA_8 when doing the following.     */
if|if
condition|(
name|dp
operator|->
name|strip16
condition|)
ifdef|#
directive|ifdef
name|PNG_READ_16_TO_8_SUPPORTED
name|png_set_strip_16
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"strip16 (16 to 8 bit conversion) not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_read_update_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Now we may get a different cbRow: */
name|standard_info_part2
argument_list|(
operator|&
name|dp
operator|->
name|this
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
literal|1
comment|/*images*/
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gamma_info
name|gamma_info
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|gamma_info_imp
argument_list|(
name|png_get_progressive_ptr
argument_list|(
name|pp
argument_list|)
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gamma_image_validate
name|gamma_image_validate
parameter_list|(
name|gamma_display
modifier|*
name|dp
parameter_list|,
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|,
name|png_const_bytep
name|pRow
parameter_list|)
block|{
comment|/* Get some constants derived from the input and output file formats: */
name|PNG_CONST
name|png_byte
name|sbit
init|=
name|dp
operator|->
name|sbit
decl_stmt|;
name|PNG_CONST
name|double
name|file_gamma
init|=
name|dp
operator|->
name|file_gamma
decl_stmt|;
name|PNG_CONST
name|double
name|screen_gamma
init|=
name|dp
operator|->
name|screen_gamma
decl_stmt|;
name|PNG_CONST
name|int
name|use_input_precision
init|=
name|dp
operator|->
name|use_input_precision
decl_stmt|;
name|PNG_CONST
name|int
name|speed
init|=
name|dp
operator|->
name|speed
decl_stmt|;
name|PNG_CONST
name|png_byte
name|in_ct
init|=
name|dp
operator|->
name|this
operator|.
name|colour_type
decl_stmt|;
name|PNG_CONST
name|png_byte
name|in_bd
init|=
name|dp
operator|->
name|this
operator|.
name|bit_depth
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|w
init|=
name|dp
operator|->
name|this
operator|.
name|w
decl_stmt|;
name|PNG_CONST
name|png_uint_32
name|h
init|=
name|dp
operator|->
name|this
operator|.
name|h
decl_stmt|;
name|PNG_CONST
name|size_t
name|cbRow
init|=
name|dp
operator|->
name|this
operator|.
name|cbRow
decl_stmt|;
name|PNG_CONST
name|png_byte
name|out_ct
init|=
name|png_get_color_type
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
decl_stmt|;
name|PNG_CONST
name|png_byte
name|out_bd
init|=
name|png_get_bit_depth
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|outmax
init|=
operator|(
literal|1U
operator|<<
name|out_bd
operator|)
operator|-
literal|1
decl_stmt|;
name|PNG_CONST
name|double
name|maxabs
init|=
name|abserr
argument_list|(
name|dp
operator|->
name|pm
argument_list|,
name|out_bd
argument_list|)
decl_stmt|;
name|PNG_CONST
name|double
name|maxout
init|=
name|outerr
argument_list|(
name|dp
operator|->
name|pm
argument_list|,
name|out_bd
argument_list|)
decl_stmt|;
name|PNG_CONST
name|double
name|maxpc
init|=
name|pcerr
argument_list|(
name|dp
operator|->
name|pm
argument_list|,
name|out_bd
argument_list|)
decl_stmt|;
comment|/* There are three sources of error, firstly the quantization in the     * file encoding, determined by sbit and/or the file depth, secondly     * the output (screen) gamma and thirdly the output file encoding.     *     * Since this API receives the screen and file gamma in double     * precision it is possible to calculate an exact answer given an input     * pixel value.  Therefore we assume that the *input* value is exact -     * sample/maxsample - calculate the corresponding gamma corrected     * output to the limits of double precision arithmetic and compare with     * what libpng returns.     *     * Since the library must quantize the output to 8 or 16 bits there is     * a fundamental limit on the accuracy of the output of +/-.5 - this     * quantization limit is included in addition to the other limits     * specified by the paramaters to the API.  (Effectively, add .5     * everywhere.)     *     * The behavior of the 'sbit' paramter is defined by section 12.5     * (sample depth scaling) of the PNG spec.  That section forces the     * decoder to assume that the PNG values have been scaled if sBIT is     * present:     *     *     png-sample = floor( input-sample * (max-out/max-in) + .5);     *     * This means that only a subset of the possible PNG values should     * appear in the input. However, the spec allows the encoder to use a     * variety of approximations to the above and doesn't require any     * restriction of the values produced.     *     * Nevertheless the spec requires that the upper 'sBIT' bits of the     * value stored in a PNG file be the original sample bits.     * Consequently the code below simply scales the top sbit bits by     * (1<<sbit)-1 to obtain an original sample value.     *     * Because there is limited precision in the input it is arguable that     * an acceptable result is any valid result from input-.5 to input+.5.     * The basic tests below do not do this, however if     * 'use_input_precision' is set a subsequent test is performed below.     */
name|PNG_CONST
name|int
name|processing
init|=
operator|(
name|fabs
argument_list|(
name|screen_gamma
operator|*
name|file_gamma
operator|-
literal|1
argument_list|)
operator|>=
name|PNG_GAMMA_THRESHOLD
operator|&&
operator|!
name|dp
operator|->
name|threshold_test
operator|&&
operator|!
name|speed
operator|&&
name|in_ct
operator|!=
literal|3
operator|)
operator|||
name|in_bd
operator|!=
name|out_bd
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|samples_per_pixel
init|=
operator|(
name|out_ct
operator|&
literal|2U
operator|)
condition|?
literal|3U
else|:
literal|1U
decl_stmt|;
name|PNG_CONST
name|double
name|gamma_correction
init|=
literal|1
operator|/
operator|(
name|file_gamma
operator|*
name|screen_gamma
operator|)
decl_stmt|;
comment|/* Overall */
name|double
name|maxerrout
init|=
literal|0
decl_stmt|,
name|maxerrabs
init|=
literal|0
decl_stmt|,
name|maxerrpc
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
operator|,
name|pRow
operator|+=
name|cbRow
control|)
block|{
name|unsigned
name|int
name|s
decl_stmt|,
name|x
decl_stmt|;
name|png_byte
name|std
index|[
name|STANDARD_ROWMAX
index|]
decl_stmt|;
name|transform_row
argument_list|(
name|pp
argument_list|,
name|std
argument_list|,
name|in_ct
argument_list|,
name|in_bd
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|samples_per_pixel
condition|;
operator|++
name|s
control|)
block|{
comment|/* Input sample values: */
name|PNG_CONST
name|unsigned
name|int
name|id
init|=
name|sample
argument_list|(
name|std
argument_list|,
name|in_ct
argument_list|,
name|in_bd
argument_list|,
name|x
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|od
init|=
name|sample
argument_list|(
name|pRow
argument_list|,
name|out_ct
argument_list|,
name|out_bd
argument_list|,
name|x
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|isbit
init|=
name|id
operator|>>
operator|(
name|in_bd
operator|-
name|sbit
operator|)
decl_stmt|;
name|double
name|i
decl_stmt|,
name|input_sample
decl_stmt|,
name|encoded_sample
decl_stmt|,
name|output
decl_stmt|;
name|double
name|encoded_error
decl_stmt|,
name|error
decl_stmt|;
name|double
name|es_lo
decl_stmt|,
name|es_hi
decl_stmt|;
comment|/* First check on the 'perfect' result obtained from the              * digitized input value, id, and compare this against the              * actual digitized result, 'od'.  'i' is the input result              * in the range 0..1:              *              * NOTE: sBIT should be taken into account here but isn't,              * as described above.              */
name|i
operator|=
name|isbit
expr_stmt|;
name|i
operator|/=
operator|(
literal|1U
operator|<<
name|sbit
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Then get the gamma corrected version of 'i' and compare              * to 'od', any error less than .5 is insignificant - just              * quantization of the output value to the nearest digital              * value (nevertheless the error is still recorded - it's              * interesting ;-)              */
name|encoded_sample
operator|=
name|pow
argument_list|(
name|i
argument_list|,
name|gamma_correction
argument_list|)
operator|*
name|outmax
expr_stmt|;
name|encoded_error
operator|=
name|fabs
argument_list|(
name|od
operator|-
name|encoded_sample
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_error
operator|>
name|maxerrout
condition|)
name|maxerrout
operator|=
name|encoded_error
expr_stmt|;
if|if
condition|(
name|encoded_error
operator|<
literal|.5
operator|+
name|maxout
condition|)
continue|continue;
comment|/* There may be an error, so calculate the actual sample              * values - unencoded light intensity values.  Note that              * in practice these are not unencoded because they              * include a 'viewing correction' to decrease or              * (normally) increase the perceptual contrast of the              * image.  There's nothing we can do about this - we don't              * know what it is - so assume the unencoded value is              * perceptually linear.              */
name|input_sample
operator|=
name|pow
argument_list|(
name|i
argument_list|,
literal|1
operator|/
name|file_gamma
argument_list|)
expr_stmt|;
comment|/* In range 0..1 */
name|output
operator|=
name|od
expr_stmt|;
name|output
operator|/=
name|outmax
expr_stmt|;
name|output
operator|=
name|pow
argument_list|(
name|output
argument_list|,
name|screen_gamma
argument_list|)
expr_stmt|;
comment|/* Now we have the numbers for real errors, both absolute              * values as as a percentage of the correct value (output):              */
name|error
operator|=
name|fabs
argument_list|(
name|input_sample
operator|-
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
name|maxerrabs
condition|)
name|maxerrabs
operator|=
name|error
expr_stmt|;
comment|/* The following is an attempt to ignore the tendency of              * quantization to dominate the percentage errors for low              * output sample values:              */
if|if
condition|(
name|input_sample
operator|*
name|maxpc
operator|>
literal|.5
operator|+
name|maxabs
condition|)
block|{
name|double
name|percentage_error
init|=
name|error
operator|/
name|input_sample
decl_stmt|;
if|if
condition|(
name|percentage_error
operator|>
name|maxerrpc
condition|)
name|maxerrpc
operator|=
name|percentage_error
expr_stmt|;
block|}
comment|/* Now calculate the digitization limits for              * 'encoded_sample' using the 'max' values.  Note that              * maxout is in the encoded space but maxpc and maxabs are              * in linear light space.              *              * First find the maximum error in linear light space,              * range 0..1:              */
block|{
name|double
name|tmp
init|=
name|input_sample
operator|*
name|maxpc
decl_stmt|;
if|if
condition|(
name|tmp
operator|<
name|maxabs
condition|)
name|tmp
operator|=
name|maxabs
expr_stmt|;
comment|/* Low bound - the minimum of the three: */
name|es_lo
operator|=
name|encoded_sample
operator|-
name|maxout
expr_stmt|;
if|if
condition|(
name|es_lo
operator|>
literal|0
operator|&&
name|input_sample
operator|-
name|tmp
operator|>
literal|0
condition|)
block|{
name|double
name|low_value
init|=
name|outmax
operator|*
name|pow
argument_list|(
name|input_sample
operator|-
name|tmp
argument_list|,
literal|1
operator|/
name|screen_gamma
argument_list|)
decl_stmt|;
if|if
condition|(
name|low_value
operator|<
name|es_lo
condition|)
name|es_lo
operator|=
name|low_value
expr_stmt|;
block|}
else|else
name|es_lo
operator|=
literal|0
expr_stmt|;
name|es_hi
operator|=
name|encoded_sample
operator|+
name|maxout
expr_stmt|;
if|if
condition|(
name|es_hi
operator|<
name|outmax
operator|&&
name|input_sample
operator|+
name|tmp
operator|<
literal|1
condition|)
block|{
name|double
name|high_value
init|=
name|outmax
operator|*
name|pow
argument_list|(
name|input_sample
operator|+
name|tmp
argument_list|,
literal|1
operator|/
name|screen_gamma
argument_list|)
decl_stmt|;
if|if
condition|(
name|high_value
operator|>
name|es_hi
condition|)
name|es_hi
operator|=
name|high_value
expr_stmt|;
block|}
else|else
name|es_hi
operator|=
name|outmax
expr_stmt|;
block|}
comment|/* The primary test is that the final encoded value              * returned by the library should be between the two limits              * (inclusive) that were calculated above.  At this point              * quantization of the output must be taken into account.              */
if|if
condition|(
name|od
operator|+
literal|.5
operator|<
name|es_lo
operator|||
name|od
operator|-
literal|.5
operator|>
name|es_hi
condition|)
block|{
comment|/* There has been an error in processing. */
name|double
name|is_lo
decl_stmt|,
name|is_hi
decl_stmt|;
if|if
condition|(
name|use_input_precision
condition|)
block|{
comment|/* Ok, something is wrong - this actually happens in                    * current libpng sbit processing.  Assume that the                    * input value (id, adjusted for sbit) can be                    * anywhere between value-.5 and value+.5 - quite a                    * large range if sbit is low.                    */
name|double
name|tmp
init|=
operator|(
name|isbit
operator|-
literal|.5
operator|)
operator|/
operator|(
operator|(
literal|1U
operator|<<
name|sbit
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
name|is_lo
operator|=
name|outmax
operator|*
name|pow
argument_list|(
name|tmp
argument_list|,
name|gamma_correction
argument_list|)
operator|-
name|maxout
expr_stmt|;
if|if
condition|(
name|is_lo
operator|<
literal|0
condition|)
name|is_lo
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|is_lo
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
operator|(
name|isbit
operator|+
literal|.5
operator|)
operator|/
operator|(
operator|(
literal|1U
operator|<<
name|sbit
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|1
condition|)
block|{
name|is_hi
operator|=
name|outmax
operator|*
name|pow
argument_list|(
name|tmp
argument_list|,
name|gamma_correction
argument_list|)
operator|+
name|maxout
expr_stmt|;
if|if
condition|(
name|is_hi
operator|>
name|outmax
condition|)
name|is_hi
operator|=
name|outmax
expr_stmt|;
block|}
else|else
name|is_hi
operator|=
name|outmax
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|od
operator|+
literal|.5
operator|<
name|is_lo
operator|||
name|od
operator|-
literal|.5
operator|>
name|is_hi
operator|)
condition|)
continue|continue;
block|}
else|else
name|is_lo
operator|=
name|es_lo
operator|,
name|is_hi
operator|=
name|es_hi
expr_stmt|;
block|{
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"error: %.3f; %u{%u;%u} -> %u not %.2f (%.1f-%.1f)"
argument_list|,
name|od
operator|-
name|encoded_sample
argument_list|,
name|id
argument_list|,
name|sbit
argument_list|,
name|isbit
argument_list|,
name|od
argument_list|,
name|encoded_sample
argument_list|,
name|is_lo
argument_list|,
name|is_hi
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|pp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|speed
operator|&&
name|memcmp
argument_list|(
name|std
argument_list|,
name|pRow
argument_list|,
name|cbRow
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
comment|/* No transform is expected on the threshold tests. */
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"gamma: below threshold row %d changed"
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|pp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* row (y) loop */
name|dp
operator|->
name|maxerrout
operator|=
name|maxerrout
expr_stmt|;
name|dp
operator|->
name|maxerrabs
operator|=
name|maxerrabs
expr_stmt|;
name|dp
operator|->
name|maxerrpc
operator|=
name|maxerrpc
expr_stmt|;
name|dp
operator|->
name|this
operator|.
name|ps
operator|->
name|validated
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gamma_end
name|gamma_end
parameter_list|(
name|png_structp
name|pp
parameter_list|,
name|png_infop
name|pi
parameter_list|)
block|{
name|gamma_display
modifier|*
name|dp
init|=
name|png_get_progressive_ptr
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|gamma_image_validate
argument_list|(
name|dp
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|dp
operator|->
name|this
operator|.
name|ps
operator|->
name|image
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* A single test run checking a gamma transformation.  *  * maxabs: maximum absolute error as a fraction  * maxout: maximum output error in the output units  * maxpc:  maximum percentage error (as a percentage)  */
end_comment
begin_function
specifier|static
name|void
DECL|function|gamma_test
name|gamma_test
parameter_list|(
name|png_modifier
modifier|*
name|pmIn
parameter_list|,
name|PNG_CONST
name|png_byte
name|colour_typeIn
parameter_list|,
name|PNG_CONST
name|png_byte
name|bit_depthIn
parameter_list|,
name|PNG_CONST
name|int
name|interlace_typeIn
parameter_list|,
name|PNG_CONST
name|double
name|file_gammaIn
parameter_list|,
name|PNG_CONST
name|double
name|screen_gammaIn
parameter_list|,
name|PNG_CONST
name|png_byte
name|sbitIn
parameter_list|,
name|PNG_CONST
name|int
name|threshold_testIn
parameter_list|,
name|PNG_CONST
name|char
modifier|*
name|name
parameter_list|,
name|PNG_CONST
name|int
name|speedIn
parameter_list|,
name|PNG_CONST
name|int
name|use_input_precisionIn
parameter_list|,
name|PNG_CONST
name|int
name|strip16In
parameter_list|)
block|{
name|gamma_display
name|d
decl_stmt|;
name|context
argument_list|(
operator|&
name|pmIn
operator|->
name|this
argument_list|,
name|fault
argument_list|)
expr_stmt|;
name|gamma_display_init
argument_list|(
operator|&
name|d
argument_list|,
name|pmIn
argument_list|,
name|FILEID
argument_list|(
name|colour_typeIn
argument_list|,
name|bit_depthIn
argument_list|,
name|interlace_typeIn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file_gammaIn
argument_list|,
name|screen_gammaIn
argument_list|,
name|sbitIn
argument_list|,
name|threshold_testIn
argument_list|,
name|speedIn
argument_list|,
name|use_input_precisionIn
argument_list|,
name|strip16In
argument_list|)
expr_stmt|;
name|Try
block|{
name|png_structp
name|pp
decl_stmt|;
name|png_infop
name|pi
decl_stmt|;
name|gamma_modification
name|gamma_mod
decl_stmt|;
name|srgb_modification
name|srgb_mod
decl_stmt|;
name|sbit_modification
name|sbit_mod
decl_stmt|;
comment|/* Make an appropriate modifier to set the PNG file gamma to the        * given gamma value and the sBIT chunk to the given precision.        */
name|d
operator|.
name|pm
operator|->
name|modifications
operator|=
name|NULL
expr_stmt|;
name|gamma_modification_init
argument_list|(
operator|&
name|gamma_mod
argument_list|,
name|d
operator|.
name|pm
argument_list|,
name|d
operator|.
name|file_gamma
argument_list|)
expr_stmt|;
name|srgb_modification_init
argument_list|(
operator|&
name|srgb_mod
argument_list|,
name|d
operator|.
name|pm
argument_list|,
literal|127
comment|/*delete*/
argument_list|)
expr_stmt|;
name|sbit_modification_init
argument_list|(
operator|&
name|sbit_mod
argument_list|,
name|d
operator|.
name|pm
argument_list|,
name|d
operator|.
name|sbit
argument_list|)
expr_stmt|;
name|modification_reset
argument_list|(
name|d
operator|.
name|pm
operator|->
name|modifications
argument_list|)
expr_stmt|;
comment|/* Get a png_struct for writing the image. */
name|pp
operator|=
name|set_modifier_for_read
argument_list|(
name|d
operator|.
name|pm
argument_list|,
operator|&
name|pi
argument_list|,
name|d
operator|.
name|this
operator|.
name|id
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Set up gamma processing. */
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
name|png_set_gamma
argument_list|(
name|pp
argument_list|,
name|d
operator|.
name|screen_gamma
argument_list|,
name|d
operator|.
name|file_gamma
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|png_fixed_point
name|s
init|=
name|floor
argument_list|(
name|d
operator|.
name|screen_gamma
operator|*
literal|100000
operator|+
literal|.5
argument_list|)
decl_stmt|;
name|png_fixed_point
name|f
init|=
name|floor
argument_list|(
name|d
operator|.
name|file_gamma
operator|*
literal|100000
operator|+
literal|.5
argument_list|)
decl_stmt|;
name|png_set_gamma_fixed
argument_list|(
name|pp
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Introduce the correct read function. */
if|if
condition|(
name|d
operator|.
name|pm
operator|->
name|this
operator|.
name|progressive
condition|)
block|{
comment|/* Share the row function with the standard implementation. */
name|png_set_progressive_read_fn
argument_list|(
name|pp
argument_list|,
operator|&
name|d
argument_list|,
name|gamma_info
argument_list|,
name|progressive_row
argument_list|,
name|gamma_end
argument_list|)
expr_stmt|;
comment|/* Now feed data into the reader until we reach the end: */
name|modifier_progressive_read
argument_list|(
name|d
operator|.
name|pm
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* modifier_read expects a png_modifier* */
name|png_set_read_fn
argument_list|(
name|pp
argument_list|,
name|d
operator|.
name|pm
argument_list|,
name|modifier_read
argument_list|)
expr_stmt|;
comment|/* Check the header values: */
name|png_read_info
argument_list|(
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Process the 'info' requirements. Only one image is generated */
name|gamma_info_imp
argument_list|(
operator|&
name|d
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|sequential_row
argument_list|(
operator|&
name|d
operator|.
name|this
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|NULL
argument_list|,
name|d
operator|.
name|this
operator|.
name|ps
operator|->
name|image
argument_list|)
expr_stmt|;
name|gamma_image_validate
argument_list|(
operator|&
name|d
argument_list|,
name|pp
argument_list|,
name|pi
argument_list|,
name|d
operator|.
name|this
operator|.
name|ps
operator|->
name|image
argument_list|)
expr_stmt|;
block|}
name|modifier_reset
argument_list|(
name|d
operator|.
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|pm
operator|->
name|log
operator|&&
operator|!
name|d
operator|.
name|threshold_test
operator|&&
operator|!
name|d
operator|.
name|speed
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d bit %s %s: max error %f (%.2g, %2g%%)\n"
argument_list|,
name|d
operator|.
name|this
operator|.
name|bit_depth
argument_list|,
name|colour_types
index|[
name|d
operator|.
name|this
operator|.
name|colour_type
index|]
argument_list|,
name|d
operator|.
name|name
argument_list|,
name|d
operator|.
name|maxerrout
argument_list|,
name|d
operator|.
name|maxerrabs
argument_list|,
literal|100
operator|*
name|d
operator|.
name|maxerrpc
argument_list|)
expr_stmt|;
comment|/* Log the summary values too. */
if|if
condition|(
name|d
operator|.
name|this
operator|.
name|colour_type
operator|==
literal|0
operator|||
name|d
operator|.
name|this
operator|.
name|colour_type
operator|==
literal|4
condition|)
block|{
switch|switch
condition|(
name|d
operator|.
name|this
operator|.
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|d
operator|.
name|maxerrout
operator|>
name|d
operator|.
name|pm
operator|->
name|error_gray_2
condition|)
name|d
operator|.
name|pm
operator|->
name|error_gray_2
operator|=
name|d
operator|.
name|maxerrout
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|d
operator|.
name|maxerrout
operator|>
name|d
operator|.
name|pm
operator|->
name|error_gray_4
condition|)
name|d
operator|.
name|pm
operator|->
name|error_gray_4
operator|=
name|d
operator|.
name|maxerrout
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|d
operator|.
name|maxerrout
operator|>
name|d
operator|.
name|pm
operator|->
name|error_gray_8
condition|)
name|d
operator|.
name|pm
operator|->
name|error_gray_8
operator|=
name|d
operator|.
name|maxerrout
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|d
operator|.
name|maxerrout
operator|>
name|d
operator|.
name|pm
operator|->
name|error_gray_16
condition|)
name|d
operator|.
name|pm
operator|->
name|error_gray_16
operator|=
name|d
operator|.
name|maxerrout
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"bad bit depth (internal: 1)"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|.
name|this
operator|.
name|colour_type
operator|==
literal|2
operator|||
name|d
operator|.
name|this
operator|.
name|colour_type
operator|==
literal|6
condition|)
block|{
switch|switch
condition|(
name|d
operator|.
name|this
operator|.
name|bit_depth
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
name|d
operator|.
name|maxerrout
operator|>
name|d
operator|.
name|pm
operator|->
name|error_color_8
condition|)
name|d
operator|.
name|pm
operator|->
name|error_color_8
operator|=
name|d
operator|.
name|maxerrout
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|d
operator|.
name|maxerrout
operator|>
name|d
operator|.
name|pm
operator|->
name|error_color_16
condition|)
name|d
operator|.
name|pm
operator|->
name|error_color_16
operator|=
name|d
operator|.
name|maxerrout
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|pp
argument_list|,
literal|"bad bit depth (internal: 2)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
name|modifier_reset
argument_list|(
operator|(
name|png_modifier
operator|*
operator|)
name|fault
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|gamma_threshold_test
specifier|static
name|void
name|gamma_threshold_test
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|png_byte
name|colour_type
parameter_list|,
name|png_byte
name|bit_depth
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|double
name|file_gamma
parameter_list|,
name|double
name|screen_gamma
parameter_list|)
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
literal|"threshold "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatd
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
name|file_gamma
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatd
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
name|screen_gamma
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gamma_test
argument_list|(
name|pm
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|interlace_type
argument_list|,
name|file_gamma
argument_list|,
name|screen_gamma
argument_list|,
name|bit_depth
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
literal|0
comment|/*speed*/
argument_list|,
literal|0
comment|/*no input precision*/
argument_list|,
literal|0
comment|/*no strip16*/
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|perform_gamma_threshold_tests
name|perform_gamma_threshold_tests
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|)
block|{
name|png_byte
name|colour_type
init|=
literal|0
decl_stmt|;
name|png_byte
name|bit_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next_format
argument_list|(
operator|&
name|colour_type
argument_list|,
operator|&
name|bit_depth
argument_list|)
condition|)
block|{
name|double
name|test_gamma
init|=
literal|1.0
decl_stmt|;
while|while
condition|(
name|test_gamma
operator|>=
literal|.4
condition|)
block|{
comment|/* There's little point testing the interlacing vs non-interlacing,           * but this can be set from the command line.           */
name|gamma_threshold_test
argument_list|(
name|pm
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
name|test_gamma
argument_list|,
literal|1
operator|/
name|test_gamma
argument_list|)
expr_stmt|;
name|test_gamma
operator|*=
literal|.95
expr_stmt|;
block|}
comment|/* And a special test for sRGB */
name|gamma_threshold_test
argument_list|(
name|pm
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|.45455
argument_list|,
literal|2.2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
block|}
block|}
end_function
begin_function
DECL|function|gamma_transform_test
specifier|static
name|void
name|gamma_transform_test
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|PNG_CONST
name|png_byte
name|colour_type
parameter_list|,
name|PNG_CONST
name|png_byte
name|bit_depth
parameter_list|,
name|PNG_CONST
name|int
name|interlace_type
parameter_list|,
name|PNG_CONST
name|double
name|file_gamma
parameter_list|,
name|PNG_CONST
name|double
name|screen_gamma
parameter_list|,
name|PNG_CONST
name|png_byte
name|sbit
parameter_list|,
name|PNG_CONST
name|int
name|speed
parameter_list|,
name|PNG_CONST
name|int
name|use_input_precision
parameter_list|,
name|PNG_CONST
name|int
name|strip16
parameter_list|)
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|sbit
operator|!=
name|bit_depth
condition|)
block|{
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
literal|"sbit("
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatn
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
name|sbit
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
else|else
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
literal|"gamma "
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip16
condition|)
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
literal|"16to8 "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatd
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
name|file_gamma
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecat
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
literal|"->"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|safecatd
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|pos
argument_list|,
name|screen_gamma
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gamma_test
argument_list|(
name|pm
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|interlace_type
argument_list|,
name|file_gamma
argument_list|,
name|screen_gamma
argument_list|,
name|sbit
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|speed
argument_list|,
name|use_input_precision
argument_list|,
name|strip16
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|perform_gamma_transform_tests
specifier|static
name|void
name|perform_gamma_transform_tests
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
name|png_byte
name|colour_type
init|=
literal|0
decl_stmt|;
name|png_byte
name|bit_depth
init|=
literal|0
decl_stmt|;
comment|/* Ignore palette images - the gamma correction happens on the palette entry,     * haven't got the tests for this yet.     */
while|while
condition|(
name|next_format
argument_list|(
operator|&
name|colour_type
argument_list|,
operator|&
name|bit_depth
argument_list|)
condition|)
if|if
condition|(
name|colour_type
operator|!=
literal|3
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pm
operator|->
name|ngammas
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pm
operator|->
name|ngammas
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
name|colour_type
argument_list|,
name|bit_depth
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|bit_depth
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision
argument_list|,
literal|0
comment|/*do not strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
block|}
block|}
block|}
end_function
begin_function
DECL|function|perform_gamma_sbit_tests
specifier|static
name|void
name|perform_gamma_sbit_tests
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
name|png_byte
name|sbit
decl_stmt|;
comment|/* The only interesting cases are colour and grayscale, alpha is ignored here     * for overall speed.  Only bit depths 8 and 16 are tested.     */
for|for
control|(
name|sbit
operator|=
name|pm
operator|->
name|sbitlow
init|;
name|sbit
operator|<
operator|(
literal|1
operator|<<
name|READ_BDHI
operator|)
condition|;
operator|++
name|sbit
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pm
operator|->
name|ngammas
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pm
operator|->
name|ngammas
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
if|if
condition|(
name|sbit
operator|<
literal|8
condition|)
block|{
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|sbit
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_sbit
argument_list|,
literal|0
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|2
argument_list|,
literal|8
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|sbit
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_sbit
argument_list|,
literal|0
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
block|}
ifdef|#
directive|ifdef
name|DO_16BIT
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|sbit
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_sbit
argument_list|,
literal|0
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|sbit
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_sbit
argument_list|,
literal|0
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* Note that this requires a 16 bit source image but produces 8 bit output, so  * we only need the 16bit write support.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_16_TO_8_SUPPORTED
end_ifdef
begin_function
DECL|function|perform_gamma_strip16_tests
specifier|static
name|void
name|perform_gamma_strip16_tests
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PNG_MAX_GAMMA_8
DECL|macro|PNG_MAX_GAMMA_8
define|#
directive|define
name|PNG_MAX_GAMMA_8
value|11
endif|#
directive|endif
comment|/* Include the alpha cases here. Note that sbit matches the internal value     * used by the library - otherwise we will get spurious errors from the     * internal sbit style approximation.     *     * The threshold test is here because otherwise the 16 to 8 conversion will     * proceed *without* gamma correction, and the tests above will fail (but not     * by much) - this could be fixed, it only appears with the -g option.     */
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pm
operator|->
name|ngammas
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pm
operator|->
name|ngammas
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|fabs
argument_list|(
name|pm
operator|->
name|gammas
index|[
name|j
index|]
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
operator|>=
name|PNG_GAMMA_THRESHOLD
condition|)
block|{
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|PNG_MAX_GAMMA_8
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_16to8
argument_list|,
literal|1
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|PNG_MAX_GAMMA_8
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_16to8
argument_list|,
literal|1
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|PNG_MAX_GAMMA_8
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_16to8
argument_list|,
literal|1
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
name|gamma_transform_test
argument_list|(
name|pm
argument_list|,
literal|6
argument_list|,
literal|16
argument_list|,
name|pm
operator|->
name|interlace_type
argument_list|,
literal|1
operator|/
name|pm
operator|->
name|gammas
index|[
name|i
index|]
argument_list|,
name|pm
operator|->
name|gammas
index|[
name|j
index|]
argument_list|,
name|PNG_MAX_GAMMA_8
argument_list|,
name|speed
argument_list|,
name|pm
operator|->
name|use_input_precision_16to8
argument_list|,
literal|1
comment|/*strip16*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 16 to 8 bit conversion */
end_comment
begin_function
specifier|static
name|void
DECL|function|perform_gamma_test
name|perform_gamma_test
parameter_list|(
name|png_modifier
modifier|*
name|pm
parameter_list|,
name|int
name|speed
parameter_list|,
name|int
name|summary
parameter_list|)
block|{
comment|/* First some arbitrary no-transform tests: */
if|if
condition|(
operator|!
name|speed
operator|&&
name|pm
operator|->
name|test_gamma_threshold
condition|)
block|{
name|perform_gamma_threshold_tests
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
block|}
comment|/* Now some real transforms. */
if|if
condition|(
name|pm
operator|->
name|test_gamma_transform
condition|)
block|{
name|perform_gamma_transform_tests
argument_list|(
name|pm
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|printf
argument_list|(
literal|"Gamma correction error summary\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The printed value is the maximum error in the pixel values\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calculated by the libpng gamma correction code.  The error\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"is calculated as the difference between the output pixel\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"value (always an integer) and the ideal value from the\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"libpng specification (typically not an integer).\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Expect this value to be less than .5 for 8 bit formats,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"less than 1 for formats with fewer than 8 bits and a small\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"number (typically less than 5) for the 16 bit formats.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"For performance reasons the value for 16 bit formats\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"increases when the image file includes an sBIT chunk.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  2 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  4 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  8 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  8 bit color: %.5f\n"
argument_list|,
name|pm
operator|->
name|error_color_8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_16BIT
name|printf
argument_list|(
literal|" 16 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 16 bit color: %.5f\n"
argument_list|,
name|pm
operator|->
name|error_color_16
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* The sbit tests produce much larger errors: */
if|if
condition|(
name|pm
operator|->
name|test_gamma_sbit
condition|)
block|{
name|pm
operator|->
name|error_gray_2
operator|=
name|pm
operator|->
name|error_gray_4
operator|=
name|pm
operator|->
name|error_gray_8
operator|=
name|pm
operator|->
name|error_gray_16
operator|=
name|pm
operator|->
name|error_color_8
operator|=
name|pm
operator|->
name|error_color_16
operator|=
literal|0
expr_stmt|;
name|perform_gamma_sbit_tests
argument_list|(
name|pm
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|printf
argument_list|(
literal|"Gamma correction with sBIT:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|sbitlow
operator|<
literal|8U
condition|)
block|{
name|printf
argument_list|(
literal|"  2 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  4 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  8 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  8 bit color: %.5f\n"
argument_list|,
name|pm
operator|->
name|error_color_8
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DO_16BIT
name|printf
argument_list|(
literal|" 16 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 16 bit color: %.5f\n"
argument_list|,
name|pm
operator|->
name|error_color_16
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|PNG_READ_16_TO_8_SUPPORTED
if|if
condition|(
name|pm
operator|->
name|test_gamma_strip16
condition|)
block|{
comment|/* The 16 to 8 bit strip operations: */
name|pm
operator|->
name|error_gray_2
operator|=
name|pm
operator|->
name|error_gray_4
operator|=
name|pm
operator|->
name|error_gray_8
operator|=
name|pm
operator|->
name|error_gray_16
operator|=
name|pm
operator|->
name|error_color_8
operator|=
name|pm
operator|->
name|error_color_16
operator|=
literal|0
expr_stmt|;
name|perform_gamma_strip16_tests
argument_list|(
name|pm
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|printf
argument_list|(
literal|"Gamma correction with 16 to 8 bit reduction:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 16 bit gray:  %.5f\n"
argument_list|,
name|pm
operator|->
name|error_gray_16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 16 bit color: %.5f\n"
argument_list|,
name|pm
operator|->
name|error_color_16
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* INTERLACE MACRO VALIDATION */
end_comment
begin_comment
comment|/* This is copied verbatim from the specification, it is simply the pass  * number in which each pixel in each 8x8 tile appears.  The array must  * be indexed adam7[y][x] and notice that the pass numbers are based at  * 1, not 0 - the base libpng uses.  */
end_comment
begin_decl_stmt
specifier|static
name|PNG_CONST
DECL|variable|adam7
name|png_byte
name|adam7
index|[
literal|8
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
literal|1
block|,
literal|6
block|,
literal|4
block|,
literal|6
block|,
literal|2
block|,
literal|6
block|,
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|6
block|,
literal|4
block|,
literal|6
block|,
literal|3
block|,
literal|6
block|,
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* This routine validates all the interlace support macros in png.h for  * a variety of valid PNG widths and heights.  It uses a number of similarly  * named internal routines that feed off the above array.  */
end_comment
begin_function
specifier|static
name|png_uint_32
DECL|function|png_pass_start_row
name|png_pass_start_row
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
operator|++
name|y
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
return|return
name|y
return|;
return|return
literal|0xf
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|png_pass_start_col
name|png_pass_start_col
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
operator|++
name|x
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
operator|++
name|y
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
return|return
name|x
return|;
return|return
literal|0xf
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_pass_row_shift
name|png_pass_row_shift
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|base
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|,
name|inc
init|=
literal|8
decl_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
operator|++
name|y
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
block|{
if|if
condition|(
name|base
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
name|base
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
name|y
condition|)
block|{}
elseif|else
if|if
condition|(
name|inc
operator|==
name|y
operator|-
name|base
condition|)
name|base
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|inc
operator|==
literal|8
condition|)
name|inc
operator|=
name|y
operator|-
name|base
operator|,
name|base
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|inc
operator|!=
name|y
operator|-
name|base
condition|)
return|return
literal|0xff
return|;
comment|/* error - more than one 'inc' value! */
block|}
if|if
condition|(
name|base
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
return|return
literal|0xfe
return|;
comment|/* error - no row in pass! */
comment|/* The shift is always 1, 2 or 3 - no pass has all the rows! */
switch|switch
condition|(
name|inc
condition|)
block|{
case|case
literal|2
case|:
return|return
literal|1
return|;
case|case
literal|4
case|:
return|return
literal|2
return|;
case|case
literal|8
case|:
return|return
literal|3
return|;
default|default:
break|break;
block|}
comment|/* error - unrecognized 'inc' */
return|return
operator|(
name|inc
operator|<<
literal|8
operator|)
operator|+
literal|0xfd
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_pass_col_shift
name|png_pass_col_shift
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|base
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|,
name|inc
init|=
literal|8
decl_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
operator|++
name|x
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
operator|++
name|y
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
block|{
if|if
condition|(
name|base
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
name|base
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
name|x
condition|)
block|{}
elseif|else
if|if
condition|(
name|inc
operator|==
name|x
operator|-
name|base
condition|)
name|base
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|inc
operator|==
literal|8
condition|)
name|inc
operator|=
name|x
operator|-
name|base
operator|,
name|base
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|inc
operator|!=
name|x
operator|-
name|base
condition|)
return|return
literal|0xff
return|;
comment|/* error - more than one 'inc' value! */
block|}
if|if
condition|(
name|base
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
return|return
literal|0xfe
return|;
comment|/* error - no row in pass! */
comment|/* The shift is always 1, 2 or 3 - no pass has all the rows! */
switch|switch
condition|(
name|inc
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|0
return|;
comment|/* pass 7 has all the columns */
case|case
literal|2
case|:
return|return
literal|1
return|;
case|case
literal|4
case|:
return|return
literal|2
return|;
case|case
literal|8
case|:
return|return
literal|3
return|;
default|default:
break|break;
block|}
comment|/* error - unrecognized 'inc' */
return|return
operator|(
name|inc
operator|<<
literal|8
operator|)
operator|+
literal|0xfd
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|png_row_from_pass_row
name|png_row_from_pass_row
parameter_list|(
name|png_uint_32
name|yIn
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* By examination of the array: */
switch|switch
condition|(
name|pass
condition|)
block|{
case|case
literal|0
case|:
return|return
name|yIn
operator|*
literal|8
return|;
case|case
literal|1
case|:
return|return
name|yIn
operator|*
literal|8
return|;
case|case
literal|2
case|:
return|return
name|yIn
operator|*
literal|8
operator|+
literal|4
return|;
case|case
literal|3
case|:
return|return
name|yIn
operator|*
literal|4
return|;
case|case
literal|4
case|:
return|return
name|yIn
operator|*
literal|4
operator|+
literal|2
return|;
case|case
literal|5
case|:
return|return
name|yIn
operator|*
literal|2
return|;
case|case
literal|6
case|:
return|return
name|yIn
operator|*
literal|2
operator|+
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0xff
return|;
comment|/* bad pass number */
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|png_col_from_pass_col
name|png_col_from_pass_col
parameter_list|(
name|png_uint_32
name|xIn
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* By examination of the array: */
switch|switch
condition|(
name|pass
condition|)
block|{
case|case
literal|0
case|:
return|return
name|xIn
operator|*
literal|8
return|;
case|case
literal|1
case|:
return|return
name|xIn
operator|*
literal|8
operator|+
literal|4
return|;
case|case
literal|2
case|:
return|return
name|xIn
operator|*
literal|4
return|;
case|case
literal|3
case|:
return|return
name|xIn
operator|*
literal|4
operator|+
literal|2
return|;
case|case
literal|4
case|:
return|return
name|xIn
operator|*
literal|2
return|;
case|case
literal|5
case|:
return|return
name|xIn
operator|*
literal|2
operator|+
literal|1
return|;
case|case
literal|6
case|:
return|return
name|xIn
return|;
default|default:
break|break;
block|}
return|return
literal|0xff
return|;
comment|/* bad pass number */
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_row_in_interlace_pass
name|png_row_in_interlace_pass
parameter_list|(
name|png_uint_32
name|y
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* Is row 'y' in pass 'pass'? */
name|int
name|x
decl_stmt|;
name|y
operator|&=
literal|7
expr_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_col_in_interlace_pass
name|png_col_in_interlace_pass
parameter_list|(
name|png_uint_32
name|x
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* Is column 'x' in pass 'pass'? */
name|int
name|y
decl_stmt|;
name|x
operator|&=
literal|7
expr_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
operator|++
name|y
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|png_pass_rows
name|png_pass_rows
parameter_list|(
name|png_uint_32
name|height
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|png_uint_32
name|tiles
init|=
name|height
operator|>>
literal|3
decl_stmt|;
name|png_uint_32
name|rows
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|height
operator|&=
literal|7
expr_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
operator|++
name|y
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
block|{
name|rows
operator|+=
name|tiles
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|height
condition|)
operator|++
name|rows
expr_stmt|;
break|break;
comment|/* i.e. break the 'x', column, loop. */
block|}
return|return
name|rows
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_32
DECL|function|png_pass_cols
name|png_pass_cols
parameter_list|(
name|png_uint_32
name|width
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|png_uint_32
name|tiles
init|=
name|width
operator|>>
literal|3
decl_stmt|;
name|png_uint_32
name|cols
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|width
operator|&=
literal|7
expr_stmt|;
operator|++
name|pass
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
operator|++
name|x
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
operator|++
name|y
control|)
if|if
condition|(
name|adam7
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|pass
condition|)
block|{
name|cols
operator|+=
name|tiles
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|width
condition|)
operator|++
name|cols
expr_stmt|;
break|break;
comment|/* i.e. break the 'y', row, loop. */
block|}
return|return
name|cols
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|perform_interlace_macro_validation
name|perform_interlace_macro_validation
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The macros to validate, first those that depend only on pass:     *     * PNG_PASS_START_ROW(pass)     * PNG_PASS_START_COL(pass)     * PNG_PASS_ROW_SHIFT(pass)     * PNG_PASS_COL_SHIFT(pass)     */
name|int
name|pass
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|7
condition|;
operator|++
name|pass
control|)
block|{
name|png_uint_32
name|m
decl_stmt|,
name|f
decl_stmt|,
name|v
decl_stmt|;
name|m
operator|=
name|PNG_PASS_START_ROW
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_pass_start_row
argument_list|(
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_PASS_START_ROW(%d) = %u != %x\n"
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_pass_start_col
argument_list|(
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_PASS_START_COL(%d) = %u != %x\n"
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|PNG_PASS_ROW_SHIFT
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_pass_row_shift
argument_list|(
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_PASS_ROW_SHIFT(%d) = %u != %x\n"
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|PNG_PASS_COL_SHIFT
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_pass_col_shift
argument_list|(
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_PASS_COL_SHIFT(%d) = %u != %x\n"
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Macros that depend on the image or sub-image height too:        *        * PNG_PASS_ROWS(height, pass)        * PNG_PASS_COLS(width, pass)        * PNG_ROW_FROM_PASS_ROW(yIn, pass)        * PNG_COL_FROM_PASS_COL(xIn, pass)        * PNG_ROW_IN_INTERLACE_PASS(y, pass)        * PNG_COL_IN_INTERLACE_PASS(x, pass)        */
for|for
control|(
name|v
operator|=
literal|0
init|;
condition|;
control|)
block|{
comment|/* First the base 0 stuff: */
name|m
operator|=
name|PNG_ROW_FROM_PASS_ROW
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_row_from_pass_row
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\n"
argument_list|,
name|v
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|PNG_COL_FROM_PASS_COL
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_col_from_pass_col
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\n"
argument_list|,
name|v
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|PNG_ROW_IN_INTERLACE_PASS
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_row_in_interlace_pass
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\n"
argument_list|,
name|v
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|PNG_COL_IN_INTERLACE_PASS
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_col_in_interlace_pass
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\n"
argument_list|,
name|v
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Then the base 1 stuff: */
operator|++
name|v
expr_stmt|;
name|m
operator|=
name|PNG_PASS_ROWS
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_pass_rows
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_PASS_ROWS(%u, %d) = %u != %x\n"
argument_list|,
name|v
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|PNG_PASS_COLS
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|f
operator|=
name|png_pass_cols
argument_list|(
name|v
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PNG_PASS_COLS(%u, %d) = %u != %x\n"
argument_list|,
name|v
argument_list|,
name|pass
argument_list|,
name|m
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Move to the next v - the stepping algorithm starts skipping           * values above 1024.           */
if|if
condition|(
name|v
operator|>
literal|1024
condition|)
block|{
if|if
condition|(
name|v
operator|==
name|PNG_UINT_31_MAX
condition|)
break|break;
name|v
operator|=
operator|(
name|v
operator|<<
literal|1
operator|)
operator|^
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>=
name|PNG_UINT_31_MAX
condition|)
name|v
operator|=
name|PNG_UINT_31_MAX
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* main program */
end_comment
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|PNG_CONST
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|volatile
name|int
name|summary
init|=
literal|1
decl_stmt|;
comment|/* Print the error summary at the end */
comment|/* Create the given output file on success: */
name|PNG_CONST
name|char
modifier|*
specifier|volatile
name|touch
init|=
name|NULL
decl_stmt|;
comment|/* This is an array of standard gamma values (believe it or not I've seen     * every one of these mentioned somewhere.)     *     * In the following list the most useful values are first!     */
specifier|static
name|double
name|gammas
index|[]
init|=
block|{
literal|2.2
block|,
literal|1.0
block|,
literal|2.2
operator|/
literal|1.45
block|,
literal|1.8
block|,
literal|1.5
block|,
literal|2.4
block|,
literal|2.5
block|,
literal|2.62
block|,
literal|2.9
block|}
decl_stmt|;
name|png_modifier
name|pm
decl_stmt|;
name|context
argument_list|(
operator|&
name|pm
operator|.
name|this
argument_list|,
name|fault
argument_list|)
expr_stmt|;
name|modifier_init
argument_list|(
operator|&
name|pm
argument_list|)
expr_stmt|;
comment|/* Preallocate the image buffer, because we know how big it needs to be,     * note that, for testing purposes, it is deliberately mis-aligned.     */
name|pm
operator|.
name|this
operator|.
name|image
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|TRANSFORM_IMAGEMAX
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|.
name|this
operator|.
name|image
operator|!=
name|NULL
condition|)
block|{
comment|/* Ignore OOM at this point - the 'ensure' routine above will allocate        * the array appropriately.        */
operator|++
operator|(
name|pm
operator|.
name|this
operator|.
name|image
operator|)
expr_stmt|;
name|pm
operator|.
name|this
operator|.
name|cb_image
operator|=
literal|2
operator|*
name|TRANSFORM_IMAGEMAX
expr_stmt|;
block|}
comment|/* Default to error on warning: */
name|pm
operator|.
name|this
operator|.
name|treat_warnings_as_errors
operator|=
literal|1
expr_stmt|;
comment|/* Store the test gammas */
name|pm
operator|.
name|gammas
operator|=
name|gammas
expr_stmt|;
name|pm
operator|.
name|ngammas
operator|=
literal|0
expr_stmt|;
comment|/* default to off */
name|pm
operator|.
name|sbitlow
operator|=
literal|8U
expr_stmt|;
comment|/* because libpng doesn't do sBIT below 8! */
name|pm
operator|.
name|use_input_precision_16to8
operator|=
literal|1U
expr_stmt|;
comment|/* Because of the way libpng does it */
comment|/* Some default values (set the behavior for 'make check' here).     * These values simply control the maximum error permitted in the gamma     * transformations.  The practial limits for human perception are described     * below (the setting for maxpc16), however for 8 bit encodings it isn't     * possible to meet the accepted capabilities of human vision - i.e. 8 bit     * images can never be good enough, regardless of encoding.     */
name|pm
operator|.
name|maxout8
operator|=
literal|.1
expr_stmt|;
comment|/* Arithmetic error in *encoded* value */
name|pm
operator|.
name|maxabs8
operator|=
literal|.00005
expr_stmt|;
comment|/* 1/20000 */
name|pm
operator|.
name|maxpc8
operator|=
literal|.499
expr_stmt|;
comment|/* I.e., .499% fractional error */
name|pm
operator|.
name|maxout16
operator|=
literal|.499
expr_stmt|;
comment|/* Error in *encoded* value */
name|pm
operator|.
name|maxabs16
operator|=
literal|.00005
expr_stmt|;
comment|/* 1/20000 */
comment|/* NOTE: this is a reasonable perceptual limit. We assume that humans can     * perceive light level differences of 1% over a 100:1 range, so we need to     * maintain 1 in 10000 accuracy (in linear light space), which is what the     * following guarantees.  It also allows significantly higher errors at     * higher 16 bit values, which is important for performance.  The actual     * maximum 16 bit error is about +/-1.9 in the fixed point implementation but     * this is only allowed for values>38149 by the following:     */
name|pm
operator|.
name|maxpc16
operator|=
literal|.005
expr_stmt|;
comment|/* I.e., 1/200% - 1/20000 */
comment|/* Now parse the command line options. */
while|while
condition|(
operator|--
name|argc
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|this
operator|.
name|verbose
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|log
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-q"
argument_list|)
operator|==
literal|0
condition|)
name|summary
operator|=
name|pm
operator|.
name|this
operator|.
name|verbose
operator|=
name|pm
operator|.
name|log
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-w"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|this
operator|.
name|treat_warnings_as_errors
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--speed"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|this
operator|.
name|speed
operator|=
literal|1
operator|,
name|pm
operator|.
name|ngammas
operator|=
operator|(
sizeof|sizeof
name|gammas
operator|)
operator|/
operator|(
sizeof|sizeof
name|gammas
index|[
literal|0
index|]
operator|)
operator|,
name|pm
operator|.
name|test_standard
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--size"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--nosize"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_size
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--standard"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_standard
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--nostandard"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_standard
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--transform"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_transform
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--notransform"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_transform
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--transform-disable="
argument_list|,
sizeof|sizeof
expr|"--transform-disable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pm
operator|.
name|test_transform
operator|=
literal|1
expr_stmt|;
name|transform_disable
argument_list|(
operator|*
name|argv
operator|+
sizeof|sizeof
expr|"--transform-disable"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--transform-enable="
argument_list|,
sizeof|sizeof
expr|"--transform-enable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pm
operator|.
name|test_transform
operator|=
literal|1
expr_stmt|;
name|transform_enable
argument_list|(
operator|*
name|argv
operator|+
sizeof|sizeof
expr|"--transform-enable"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--gamma"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Just do two gamma tests here (2.2 and linear) for speed: */
name|pm
operator|.
name|ngammas
operator|=
literal|2U
expr_stmt|;
name|pm
operator|.
name|test_gamma_threshold
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_gamma_transform
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_gamma_sbit
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_gamma_strip16
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--nogamma"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|ngammas
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--gamma-threshold"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|ngammas
operator|=
literal|2U
operator|,
name|pm
operator|.
name|test_gamma_threshold
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--nogamma-threshold"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_gamma_threshold
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--gamma-transform"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|ngammas
operator|=
literal|2U
operator|,
name|pm
operator|.
name|test_gamma_transform
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--nogamma-transform"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_gamma_transform
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--gamma-sbit"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|ngammas
operator|=
literal|2U
operator|,
name|pm
operator|.
name|test_gamma_sbit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--nogamma-sbit"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_gamma_sbit
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--gamma-16-to-8"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|ngammas
operator|=
literal|2U
operator|,
name|pm
operator|.
name|test_gamma_strip16
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--nogamma-16-to-8"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|test_gamma_strip16
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--all-gammas"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|ngammas
operator|=
operator|(
sizeof|sizeof
name|gammas
operator|)
operator|/
operator|(
sizeof|sizeof
name|gammas
index|[
literal|0
index|]
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--progressive-read"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|this
operator|.
name|progressive
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--interlace"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|interlace_type
operator|=
name|PNG_INTERLACE_ADAM7
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|>=
literal|1
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--sbitlow"
argument_list|)
operator|==
literal|0
condition|)
operator|--
name|argc
operator|,
name|pm
operator|.
name|sbitlow
operator|=
operator|(
name|png_byte
operator|)
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|>=
literal|1
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--touch"
argument_list|)
operator|==
literal|0
condition|)
operator|--
name|argc
operator|,
name|touch
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--max"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|argc
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|4
operator|+
operator|*
name|argv
argument_list|,
literal|"abs8"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|maxabs8
operator|=
name|atof
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|4
operator|+
operator|*
name|argv
argument_list|,
literal|"abs16"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|maxabs16
operator|=
name|atof
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|4
operator|+
operator|*
name|argv
argument_list|,
literal|"out8"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|maxout8
operator|=
name|atof
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|4
operator|+
operator|*
name|argv
argument_list|,
literal|"out16"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|maxout16
operator|=
name|atof
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|4
operator|+
operator|*
name|argv
argument_list|,
literal|"pc8"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|maxpc8
operator|=
name|atof
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|4
operator|+
operator|*
name|argv
argument_list|,
literal|"pc16"
argument_list|)
operator|==
literal|0
condition|)
name|pm
operator|.
name|maxpc16
operator|=
name|atof
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: %s: unknown 'max' option\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: %s: unknown argument\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If pngvalid is run with no arguments default to a reasonable set of the     * tests.     */
if|if
condition|(
name|pm
operator|.
name|test_standard
operator|==
literal|0
operator|&&
name|pm
operator|.
name|test_size
operator|==
literal|0
operator|&&
name|pm
operator|.
name|test_transform
operator|==
literal|0
operator|&&
name|pm
operator|.
name|ngammas
operator|==
literal|0
condition|)
block|{
name|pm
operator|.
name|test_standard
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_size
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_transform
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|ngammas
operator|=
literal|3U
expr_stmt|;
block|}
if|if
condition|(
name|pm
operator|.
name|ngammas
operator|>
literal|0
operator|&&
name|pm
operator|.
name|test_gamma_threshold
operator|==
literal|0
operator|&&
name|pm
operator|.
name|test_gamma_transform
operator|==
literal|0
operator|&&
name|pm
operator|.
name|test_gamma_sbit
operator|==
literal|0
operator|&&
name|pm
operator|.
name|test_gamma_strip16
operator|==
literal|0
condition|)
block|{
name|pm
operator|.
name|test_gamma_threshold
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_gamma_transform
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_gamma_sbit
operator|=
literal|1
expr_stmt|;
name|pm
operator|.
name|test_gamma_strip16
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pm
operator|.
name|ngammas
operator|==
literal|0
condition|)
block|{
comment|/* Nothing to test so turn everything off: */
name|pm
operator|.
name|test_gamma_threshold
operator|=
literal|0
expr_stmt|;
name|pm
operator|.
name|test_gamma_transform
operator|=
literal|0
expr_stmt|;
name|pm
operator|.
name|test_gamma_sbit
operator|=
literal|0
expr_stmt|;
name|pm
operator|.
name|test_gamma_strip16
operator|=
literal|0
expr_stmt|;
block|}
name|Try
block|{
comment|/* Make useful base images */
name|make_transform_images
argument_list|(
operator|&
name|pm
operator|.
name|this
argument_list|)
expr_stmt|;
comment|/* Perform the standard and gamma tests. */
if|if
condition|(
name|pm
operator|.
name|test_standard
condition|)
block|{
name|perform_interlace_macro_validation
argument_list|()
expr_stmt|;
name|perform_standard_test
argument_list|(
operator|&
name|pm
argument_list|)
expr_stmt|;
name|perform_error_test
argument_list|(
operator|&
name|pm
argument_list|)
expr_stmt|;
block|}
comment|/* Various oddly sized images: */
if|if
condition|(
name|pm
operator|.
name|test_size
condition|)
block|{
name|make_size_images
argument_list|(
operator|&
name|pm
operator|.
name|this
argument_list|)
expr_stmt|;
name|perform_size_test
argument_list|(
operator|&
name|pm
argument_list|)
expr_stmt|;
block|}
comment|/* Combinatorial transforms: */
if|if
condition|(
name|pm
operator|.
name|test_transform
condition|)
name|perform_transform_test
argument_list|(
operator|&
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|.
name|ngammas
operator|>
literal|0
condition|)
name|perform_gamma_test
argument_list|(
operator|&
name|pm
argument_list|,
name|pm
operator|.
name|this
operator|.
name|speed
operator|!=
literal|0
argument_list|,
name|summary
operator|&&
operator|!
name|pm
operator|.
name|this
operator|.
name|speed
argument_list|)
expr_stmt|;
block|}
name|Catch
argument_list|(
argument|fault
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: test aborted (probably failed in cleanup)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pm
operator|.
name|this
operator|.
name|verbose
condition|)
block|{
if|if
condition|(
name|pm
operator|.
name|this
operator|.
name|error
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: first error: %s\n"
argument_list|,
name|pm
operator|.
name|this
operator|.
name|error
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: run with -v to see what happened\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|&&
operator|!
name|pm
operator|.
name|this
operator|.
name|speed
condition|)
block|{
name|printf
argument_list|(
literal|"Results using %s point arithmetic %s\n"
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
argument_list|)
operator|||
name|PNG_LIBPNG_VER
operator|<
literal|10500
literal|"floating"
argument_list|,
else|#
directive|else
literal|"fixed"
argument_list|,
endif|#
directive|endif
operator|(
name|pm
operator|.
name|this
operator|.
name|nerrors
operator|||
operator|(
name|pm
operator|.
name|this
operator|.
name|treat_warnings_as_errors
operator|&&
name|pm
operator|.
name|this
operator|.
name|nwarnings
operator|)
operator|)
condition|?
literal|"(errors)"
else|:
operator|(
name|pm
operator|.
name|this
operator|.
name|nwarnings
condition|?
literal|"(warnings)"
else|:
literal|"(no errors or warnings)"
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Allocated memory statistics (in bytes):\n"
literal|"\tread  %lu maximum single, %lu peak, %lu total\n"
literal|"\twrite %lu maximum single, %lu peak, %lu total\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pm
operator|.
name|this
operator|.
name|read_memory_pool
operator|.
name|max_max
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pm
operator|.
name|this
operator|.
name|read_memory_pool
operator|.
name|max_limit
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pm
operator|.
name|this
operator|.
name|read_memory_pool
operator|.
name|max_total
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pm
operator|.
name|this
operator|.
name|write_memory_pool
operator|.
name|max_max
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pm
operator|.
name|this
operator|.
name|write_memory_pool
operator|.
name|max_limit
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pm
operator|.
name|this
operator|.
name|write_memory_pool
operator|.
name|max_total
argument_list|)
expr_stmt|;
block|}
comment|/* Do this here to provoke memory corruption errors in memory not directly     * allocated by libpng - not a complete test, but better than nothing.     */
name|store_delete
argument_list|(
operator|&
name|pm
operator|.
name|this
argument_list|)
expr_stmt|;
comment|/* Error exit if there are any errors, and maybe if there are any     * warnings.     */
if|if
condition|(
name|pm
operator|.
name|this
operator|.
name|nerrors
operator|||
operator|(
name|pm
operator|.
name|this
operator|.
name|treat_warnings_as_errors
operator|&&
name|pm
operator|.
name|this
operator|.
name|nwarnings
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pm
operator|.
name|this
operator|.
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: %s\n"
argument_list|,
name|pm
operator|.
name|this
operator|.
name|error
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pngvalid: %d errors, %d warnings\n"
argument_list|,
name|pm
operator|.
name|this
operator|.
name|nerrors
argument_list|,
name|pm
operator|.
name|this
operator|.
name|nwarnings
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Success case. */
if|if
condition|(
name|touch
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|fsuccess
init|=
name|fopen
argument_list|(
name|touch
argument_list|,
literal|"wt"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fsuccess
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|fsuccess
argument_list|,
literal|"PNG validation succeeded\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fsuccess
argument_list|)
expr_stmt|;
name|error
operator|=
name|ferror
argument_list|(
name|fsuccess
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fsuccess
argument_list|)
operator|||
name|error
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write failed\n"
argument_list|,
name|touch
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
