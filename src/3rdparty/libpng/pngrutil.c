begin_unit
begin_comment
comment|/* pngrutil.c - utilities to read a PNG file  *  * Last changed in libpng 1.5.1 [February 3, 2011]  * Copyright (c) 1998-2011 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * This file contains routines that are only called from within  * libpng itself during the course of reading an image.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_define
DECL|macro|png_strtod
define|#
directive|define
name|png_strtod
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|strtod(a,b)
end_define
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_get_uint_31
name|png_get_uint_31
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|uval
operator|>
name|PNG_UINT_31_MAX
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG unsigned integer out of range"
argument_list|)
expr_stmt|;
return|return
operator|(
name|uval
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_gAMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_cHRM_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* The following is a variation on the above for use with the fixed  * point values used for gAMA and cHRM.  Instead of png_error it  * issues a warning and returns (-1) - an invalid value because both  * gAMA and cHRM use *unsigned* integers for fixed point values.  */
end_comment
begin_define
DECL|macro|PNG_FIXED_ERROR
define|#
directive|define
name|PNG_FIXED_ERROR
value|(-1)
end_define
begin_function
specifier|static
name|png_fixed_point
comment|/* PRIVATE */
DECL|function|png_get_fixed_point
name|png_get_fixed_point
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|uval
operator|<=
name|PNG_UINT_31_MAX
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|uval
return|;
comment|/* known to be in range */
comment|/* The caller can turn off the warning by passing NULL. */
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG fixed point integer out of range"
argument_list|)
expr_stmt|;
return|return
name|PNG_FIXED_ERROR
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_INT_FUNCTIONS_SUPPORTED
end_ifdef
begin_comment
comment|/* NOTE: the read macros will obscure these definitions, so that if  * PNG_USE_READ_MACROS is set the library will not use them internally,  * but the APIs will still be available externally.  *  * The parentheses around "PNGAPI function_name" in the following three  * functions are necessary because they allow the macros to co-exist with  * these (unused but exported) functions.  */
end_comment
begin_comment
comment|/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
end_comment
begin_function
name|png_uint_32
function|(
name|PNGAPI
DECL|function|png_get_uint_32
name|png_get_uint_32
function|)
parameter_list|(
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|)
argument_list|)
operator|<<
literal|24
operator|)
operator|+
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
argument_list|)
operator|<<
literal|16
operator|)
operator|+
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|2
operator|)
argument_list|)
operator|<<
literal|8
operator|)
operator|+
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|3
operator|)
argument_list|)
operator|)
decl_stmt|;
return|return
name|uval
return|;
block|}
end_function
begin_comment
comment|/* Grab a signed 32-bit integer from a buffer in big-endian format.  The  * data is stored in the PNG file in two's complement format and there  * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore  * the following code does a two's complement to native conversion.  */
end_comment
begin_function
name|png_int_32
function|(
name|PNGAPI
DECL|function|png_get_int_32
name|png_get_int_32
function|)
parameter_list|(
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|uval
operator|&
literal|0x80000000L
operator|)
operator|==
literal|0
condition|)
comment|/* non-negative */
return|return
name|uval
return|;
name|uval
operator|=
operator|(
name|uval
operator|^
literal|0xffffffffL
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 2's complement: -x = ~x+1 */
return|return
operator|-
operator|(
name|png_int_32
operator|)
name|uval
return|;
block|}
end_function
begin_comment
comment|/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
end_comment
begin_function
name|png_uint_16
function|(
name|PNGAPI
DECL|function|png_get_uint_16
name|png_get_uint_16
function|)
parameter_list|(
name|png_const_bytep
name|buf
parameter_list|)
block|{
comment|/* ANSI-C requires an int value to accomodate at least 16 bits so this     * works and allows the compiler not to worry about possible narrowing     * on 32 bit systems.  (Pre-ANSI systems did not make integers smaller     * than 16 bits either.)     */
name|unsigned
name|int
name|val
init|=
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|buf
argument_list|)
operator|<<
literal|8
operator|)
operator|+
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|png_uint_16
operator|)
name|val
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_INT_FUNCTIONS_SUPPORTED */
end_comment
begin_comment
comment|/* Read and check the PNG file signature */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_sig
name|png_read_sig
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_size_t
name|num_checked
decl_stmt|,
name|num_to_check
decl_stmt|;
comment|/* Exit if the user application does not expect a signature. */
if|if
condition|(
name|png_ptr
operator|->
name|sig_bytes
operator|>=
literal|8
condition|)
return|return;
name|num_checked
operator|=
name|png_ptr
operator|->
name|sig_bytes
expr_stmt|;
name|num_to_check
operator|=
literal|8
operator|-
name|num_checked
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_SIGNATURE
expr_stmt|;
endif|#
directive|endif
comment|/* The signature must be serialized in a single I/O call. */
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|signature
index|[
name|num_checked
index|]
operator|)
argument_list|,
name|num_to_check
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sig_bytes
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
argument_list|)
condition|)
block|{
if|if
condition|(
name|num_checked
operator|<
literal|4
operator|&&
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
operator|-
literal|4
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not a PNG file"
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG file corrupted by ASCII conversion"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_checked
operator|<
literal|3
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PNG_SIGNATURE
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Read the chunk header (length + type name).  * Put the type name into png_ptr->chunk_name, and return the length.  */
end_comment
begin_function
name|png_uint_32
comment|/* PRIVATE */
DECL|function|png_read_chunk_header
name|png_read_chunk_header
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|png_uint_32
name|length
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_CHUNK_HDR
expr_stmt|;
endif|#
directive|endif
comment|/* Read the length and the chunk name.     * This must be performed in a single I/O call.     */
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|length
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Put the chunk name into png_ptr->chunk_name. */
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|buf
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|png_debug2
argument_list|(
literal|0
argument_list|,
literal|"Reading %s chunk, length = %u"
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Reset the crc and run it over the chunk name. */
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Check to see if chunk name is valid. */
name|png_check_chunk_name
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_CHUNK_DATA
expr_stmt|;
endif|#
directive|endif
return|return
name|length
return|;
block|}
end_function
begin_comment
comment|/* Read data, and (optionally) run it through the CRC. */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_crc_read
name|png_crc_read
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|buf
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Optionally skip data and then check the CRC.  Depending on whether we  * are reading a ancillary or critical chunk, and how the program has set  * things up, we may calculate the CRC on the data and print a message.  * Returns '1' if there was a CRC error, '0' otherwise.  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_crc_finish
name|png_crc_finish
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|skip
parameter_list|)
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_size_t
name|istop
init|=
name|png_ptr
operator|->
name|zbuf_size
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|png_size_t
operator|)
name|skip
init|;
name|i
operator|>
name|istop
condition|;
name|i
operator|-=
name|istop
control|)
block|{
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_crc_error
argument_list|(
name|png_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
operator|&&
comment|/* Ancillary */
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
operator|&&
comment|/* Critical  */
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_CRITICAL_USE
operator|)
operator|)
condition|)
block|{
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/* Compare the CRC stored in the PNG file with that calculated by libpng from  * the data it has read thus far.  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_crc_error
name|png_crc_error
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|crc_bytes
index|[
literal|4
index|]
decl_stmt|;
name|png_uint_32
name|crc
decl_stmt|;
name|int
name|need_crc
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
condition|)
comment|/* ancillary */
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_MASK
operator|)
operator|==
operator|(
name|PNG_FLAG_CRC_ANCILLARY_USE
operator||
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* critical */
block|{
if|if
condition|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_CRITICAL_IGNORE
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_CHUNK_CRC
expr_stmt|;
endif|#
directive|endif
comment|/* The chunk CRC must be serialized in a single I/O call. */
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
name|crc_bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_crc
condition|)
block|{
name|crc
operator|=
name|png_get_uint_32
argument_list|(
name|crc_bytes
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|crc
operator|!=
name|png_ptr
operator|->
name|crc
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_zTXt_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_iTXt_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_iCCP_SUPPORTED
argument_list|)
end_if
begin_function
specifier|static
name|png_size_t
DECL|function|png_inflate
name|png_inflate
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|data
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|png_bytep
name|output
parameter_list|,
name|png_size_t
name|output_size
parameter_list|)
block|{
name|png_size_t
name|count
init|=
literal|0
decl_stmt|;
comment|/* zlib can't necessarily handle more than 65535 bytes at once (i.e. it can't     * even necessarily handle 65536 bytes) because the type uInt is "16 bits or     * more".  Consequently it is necessary to chunk the input to zlib.  This     * code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the maximum value     * that can be stored in a uInt.)  It is possible to set ZLIB_IO_MAX to a     * lower value in pngpriv.h and this may sometimes have a performance     * advantage, because it forces access of the input data to be separated from     * at least some of the use by some period of time.     */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|data
expr_stmt|;
comment|/* avail_in is set below from 'size' */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ret
decl_stmt|,
name|avail
decl_stmt|;
comment|/* The setting of 'avail_in' used to be outside the loop, by setting it        * inside it is possible to chunk the input to zlib and simply rely on        * zlib to advance the 'next_in' pointer.  This allows arbitrary amounts o        * data to be passed through zlib at the unavoidable cost of requiring a        * window save (memcpy of up to 32768 output bytes) every ZLIB_IO_MAX        * input bytes.        */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|==
literal|0
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|<=
name|ZLIB_IO_MAX
condition|)
block|{
comment|/* The value is less than ZLIB_IO_MAX so the cast is safe: */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|size
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|ZLIB_IO_MAX
expr_stmt|;
name|size
operator|-=
name|ZLIB_IO_MAX
expr_stmt|;
block|}
block|}
comment|/* Reset the output buffer each time round - we empty it        * after every inflate call.        */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|avail
operator|=
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
comment|/* First copy/count any new output - but only if we didn't        * get an error code.        */
if|if
condition|(
operator|(
name|ret
operator|==
name|Z_OK
operator|||
name|ret
operator|==
name|Z_STREAM_END
operator|)
operator|&&
name|avail
operator|>
literal|0
condition|)
block|{
name|png_size_t
name|space
init|=
name|avail
decl_stmt|;
comment|/*> 0, see above */
if|if
condition|(
name|output
operator|!=
literal|0
operator|&&
name|output_size
operator|>
name|count
condition|)
block|{
name|png_size_t
name|copy
init|=
name|output_size
operator|-
name|count
decl_stmt|;
if|if
condition|(
name|space
operator|<
name|copy
condition|)
name|copy
operator|=
name|space
expr_stmt|;
name|png_memcpy
argument_list|(
name|output
operator|+
name|count
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|count
operator|+=
name|space
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
continue|continue;
comment|/* Termination conditions - always reset the zstream, it        * must be left in inflateInit state.        */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
return|return
name|count
return|;
comment|/* NOTE: may be zero. */
comment|/* Now handle the error codes - the API always returns 0        * and the error message is dumped into the uncompressed        * buffer if available.        */
block|{
name|PNG_CONST
name|char
modifier|*
name|msg
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
name|char
name|umsg
index|[
literal|52
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|!=
literal|0
condition|)
name|msg
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_BUF_ERROR
case|:
name|msg
operator|=
literal|"Buffer error in compressed datastream in %s chunk"
expr_stmt|;
break|break;
case|case
name|Z_DATA_ERROR
case|:
name|msg
operator|=
literal|"Data error in compressed datastream in %s chunk"
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
literal|"Incomplete compressed datastream in %s chunk"
expr_stmt|;
break|break;
block|}
name|png_snprintf
argument_list|(
name|umsg
argument_list|,
sizeof|sizeof
name|umsg
argument_list|,
name|msg
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
name|msg
operator|=
name|umsg
expr_stmt|;
else|#
directive|else
name|msg
operator|=
literal|"Damaged compressed datastream in chunk other than IDAT"
expr_stmt|;
endif|#
directive|endif
block|}
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* 0 means an error - notice that this code simply ignores        * zero length compressed chunks as a result.        */
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Decompress trailing data in a chunk.  The assumption is that chunkdata  * points at an allocated area holding the contents of a chunk with a  * trailing compressed part.  What we get back is an allocated area  * holding the original prefix part and an uncompressed version of the  * trailing part (the malloc area passed in is freed).  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_decompress_chunk
name|png_decompress_chunk
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|comp_type
parameter_list|,
name|png_size_t
name|chunklength
parameter_list|,
name|png_size_t
name|prefix_size
parameter_list|,
name|png_size_t
modifier|*
name|newlength
parameter_list|)
block|{
comment|/* The caller should guarantee this */
if|if
condition|(
name|prefix_size
operator|>
name|chunklength
condition|)
block|{
comment|/* The recovery is to delete the chunk. */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid chunklength"
argument_list|)
expr_stmt|;
name|prefix_size
operator|=
literal|0
expr_stmt|;
comment|/* To delete everything */
block|}
elseif|else
if|if
condition|(
name|comp_type
operator|==
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
name|png_size_t
name|expanded_size
init|=
name|png_inflate
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_bytep
call|)
argument_list|(
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_size
argument_list|)
argument_list|,
name|chunklength
operator|-
name|prefix_size
argument_list|,
literal|0
argument_list|,
comment|/*output*/
literal|0
argument_list|)
decl_stmt|;
comment|/*output size*/
comment|/* Now check the limits on this chunk - if the limit fails the        * compressed data will be removed, the prefix will remain.        */
ifdef|#
directive|ifdef
name|PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|&&
operator|(
name|prefix_size
operator|+
name|expanded_size
operator|>=
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|-
literal|1
operator|)
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|PNG_USER_CHUNK_MALLOC_MAX
if|if
condition|(
operator|(
name|PNG_USER_CHUNK_MALLOC_MAX
operator|>
literal|0
operator|)
operator|&&
name|prefix_size
operator|+
name|expanded_size
operator|>=
name|PNG_USER_CHUNK_MALLOC_MAX
operator|-
literal|1
condition|)
endif|#
directive|endif
endif|#
directive|endif
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Exceeded size limit while expanding chunk"
argument_list|)
expr_stmt|;
comment|/* If the size is zero either there was an error and a message        * has already been output (warning) or the size really is zero        * and we have nothing to do - the code will exit through the        * error case below.        */
if|#
directive|if
name|defined
argument_list|(
name|PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_USER_CHUNK_MALLOC_MAX
argument_list|)
elseif|else
if|if
condition|(
name|expanded_size
operator|>
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|expanded_size
operator|>
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* Success (maybe) - really uncompress the chunk. */
name|png_size_t
name|new_size
init|=
literal|0
decl_stmt|;
name|png_charp
name|text
init|=
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|prefix_size
operator|+
name|expanded_size
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
block|{
name|png_memcpy
argument_list|(
name|text
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|prefix_size
argument_list|)
expr_stmt|;
name|new_size
operator|=
name|png_inflate
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_bytep
call|)
argument_list|(
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_size
argument_list|)
argument_list|,
name|chunklength
operator|-
name|prefix_size
argument_list|,
call|(
name|png_bytep
call|)
argument_list|(
name|text
operator|+
name|prefix_size
argument_list|)
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
name|text
index|[
name|prefix_size
operator|+
name|expanded_size
index|]
operator|=
literal|0
expr_stmt|;
comment|/* just in case */
if|if
condition|(
name|new_size
operator|==
name|expanded_size
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|text
expr_stmt|;
operator|*
name|newlength
operator|=
name|prefix_size
operator|+
name|expanded_size
expr_stmt|;
return|return;
comment|/* The success return! */
block|}
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"png_inflate logic error"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough memory to decompress chunk"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
block|{
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
name|char
name|umsg
index|[
literal|50
index|]
decl_stmt|;
name|png_snprintf
argument_list|(
name|umsg
argument_list|,
sizeof|sizeof
name|umsg
argument_list|,
literal|"Unknown zTXt compression type %d"
argument_list|,
name|comp_type
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|umsg
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown zTXt compression type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The recovery is to simply drop the data. */
block|}
comment|/* Generic error return - leave the prefix, delete the compressed     * data, reallocate the chunkdata to remove the potentially large     * amount of compressed data.     */
block|{
name|png_charp
name|text
init|=
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|prefix_size
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|prefix_size
operator|>
literal|0
condition|)
name|png_memcpy
argument_list|(
name|text
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|prefix_size
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|text
expr_stmt|;
comment|/* This is an extra zero in the 'uncompressed' part. */
operator|*
operator|(
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_size
operator|)
operator|=
literal|0x00
expr_stmt|;
block|}
comment|/* Ignore a malloc error here - it is safe. */
block|}
operator|*
name|newlength
operator|=
name|prefix_size
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Read and check the IDHR chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_IHDR
name|png_handle_IHDR
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|13
index|]
decl_stmt|;
name|png_uint_32
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|bit_depth
decl_stmt|,
name|color_type
decl_stmt|,
name|compression_type
decl_stmt|,
name|filter_type
decl_stmt|;
name|int
name|interlace_type
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_IHDR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place IHDR"
argument_list|)
expr_stmt|;
comment|/* Check the length */
if|if
condition|(
name|length
operator|!=
literal|13
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid IHDR chunk"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IHDR
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|width
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|height
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bit_depth
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|color_type
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|compression_type
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
name|filter_type
operator|=
name|buf
index|[
literal|11
index|]
expr_stmt|;
name|interlace_type
operator|=
name|buf
index|[
literal|12
index|]
expr_stmt|;
comment|/* Set internal variables */
name|png_ptr
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|png_ptr
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|png_ptr
operator|->
name|bit_depth
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|interlaced
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
name|png_ptr
operator|->
name|color_type
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
name|png_ptr
operator|->
name|filter_type
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|compression_type
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
comment|/* Find number of channels */
switch|switch
condition|(
name|png_ptr
operator|->
name|color_type
condition|)
block|{
default|default:
comment|/* invalid, png_set_IHDR calls png_error */
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Set up other useful info */
name|png_ptr
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|bit_depth
operator|*
name|png_ptr
operator|->
name|channels
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"bit_depth = %d"
argument_list|,
name|png_ptr
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"channels = %d"
argument_list|,
name|png_ptr
operator|->
name|channels
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"rowbytes = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|rowbytes
argument_list|)
expr_stmt|;
name|png_set_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bit_depth
argument_list|,
name|color_type
argument_list|,
name|interlace_type
argument_list|,
name|compression_type
argument_list|,
name|filter_type
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Read and check the palette */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_PLTE
name|png_handle_PLTE
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_color
name|palette
index|[
name|PNG_MAX_PALETTE_LENGTH
index|]
decl_stmt|;
name|int
name|num
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
name|png_colorp
name|pal_ptr
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before PLTE"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid PLTE after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate PLTE chunk"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring PLTE chunk in grayscale PNG"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|PNG_READ_OPT_PLTE_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|length
operator|>
literal|3
operator|*
name|PNG_MAX_PALETTE_LENGTH
operator|||
name|length
operator|%
literal|3
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid palette chunk"
argument_list|)
expr_stmt|;
block|}
block|}
name|num
operator|=
operator|(
name|int
operator|)
name|length
operator|/
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pal_ptr
operator|=
name|palette
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|pal_ptr
operator|++
control|)
block|{
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pal_ptr
operator|->
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|pal_ptr
operator|->
name|green
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|pal_ptr
operator|->
name|blue
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Don't depend upon png_color being any order */
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we actually need the PLTE chunk (ie for a paletted image), we do     * whatever the normal CRC configuration tells us.  However, if we     * have an RGB image, the PLTE can be considered ancillary, so     * we will act as though it is.     */
ifndef|#
directive|ifndef
name|PNG_READ_OPT_PLTE_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
endif|#
directive|endif
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PNG_READ_OPT_PLTE_SUPPORTED
elseif|else
if|if
condition|(
name|png_crc_error
argument_list|(
name|png_ptr
argument_list|)
condition|)
comment|/* Only if we have a CRC error */
block|{
comment|/* If we don't want to use the data from an ancillary chunk,        * we have two options: an error abort, or a warning and we        * ignore the data in this chunk (which should be OK, since        * it's considered ancillary for a RGB or RGBA image).        */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_USE
operator|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Otherwise, we (optionally) emit a warning and use the chunk. */
elseif|else
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
condition|)
block|{
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|png_set_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|palette
argument_list|,
name|num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
operator|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|>
operator|(
name|png_uint_16
operator|)
name|num
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncating incorrect tRNS chunk length"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_trans
operator|=
operator|(
name|png_uint_16
operator|)
name|num
expr_stmt|;
block|}
if|if
condition|(
name|info_ptr
operator|->
name|num_trans
operator|>
operator|(
name|png_uint_16
operator|)
name|num
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncating incorrect info tRNS chunk length"
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|num_trans
operator|=
operator|(
name|png_uint_16
operator|)
name|num
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_IEND
name|png_handle_IEND
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_IEND"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|||
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"No image in file"
argument_list|)
expr_stmt|;
block|}
name|png_ptr
operator|->
name|mode
operator||=
operator|(
name|PNG_AFTER_IDAT
operator||
name|PNG_HAVE_IEND
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect IEND chunk length"
argument_list|)
expr_stmt|;
block|}
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
comment|/* Quiet compiler warnings about unused info_ptr */
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_gAMA
name|png_handle_gAMA
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_fixed_point
name|igamma
decl_stmt|;
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_gAMA"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before gAMA"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid gAMA after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
condition|)
comment|/* Should be an error, but we can cope with it */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place gAMA chunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_gAMA
operator|)
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
operator|&&
operator|!
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
operator|)
endif|#
directive|endif
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate gAMA chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|4
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect gAMA chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|igamma
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Check for zero gamma or an error. */
if|if
condition|(
name|igamma
operator|<=
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring gAMA chunk with out of range gamma"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
operator|)
condition|)
block|{
if|if
condition|(
name|PNG_OUT_OF_RANGE
argument_list|(
name|igamma
argument_list|,
literal|45500L
argument_list|,
literal|500
argument_list|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring incorrect gAMA value when sRGB is also present"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gamma = (%d/100000)"
argument_list|,
operator|(
name|int
operator|)
name|igamma
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* PNG_READ_sRGB_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
comment|/* Gamma correction on read is supported. */
name|png_ptr
operator|->
name|gamma
operator|=
name|igamma
expr_stmt|;
endif|#
directive|endif
comment|/* And set the 'info' structure members. */
name|png_set_gAMA_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|igamma
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sBIT
name|png_handle_sBIT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_size_t
name|truelen
decl_stmt|;
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sBIT"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before sBIT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sBIT after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
condition|)
block|{
comment|/* Should be an error, but we can cope with it */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place sBIT chunk"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sBIT
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate sBIT chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|truelen
operator|=
literal|3
expr_stmt|;
else|else
name|truelen
operator|=
operator|(
name|png_size_t
operator|)
name|png_ptr
operator|->
name|channels
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|truelen
operator|||
name|length
operator|>
literal|4
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect sBIT chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|truelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
block|{
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|alpha
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|sig_bit
operator|.
name|gray
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|alpha
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
block|}
name|png_set_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|sig_bit
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_cHRM
name|png_handle_cHRM
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|png_fixed_point
name|x_white
decl_stmt|,
name|y_white
decl_stmt|,
name|x_red
decl_stmt|,
name|y_red
decl_stmt|,
name|x_green
decl_stmt|,
name|y_green
decl_stmt|,
name|x_blue
decl_stmt|,
name|y_blue
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_cHRM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before cHRM"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
condition|)
comment|/* Should be an error, but we can cope with it */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before cHRM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_cHRM
operator|)
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
operator|&&
operator|!
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
operator|)
endif|#
directive|endif
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate cHRM chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|32
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect cHRM chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|x_white
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|y_white
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|x_red
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|8
argument_list|)
expr_stmt|;
name|y_red
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|12
argument_list|)
expr_stmt|;
name|x_green
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|16
argument_list|)
expr_stmt|;
name|y_green
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|20
argument_list|)
expr_stmt|;
name|x_blue
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|24
argument_list|)
expr_stmt|;
name|y_blue
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|28
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_white
operator|==
name|PNG_FIXED_ERROR
operator|||
name|y_white
operator|==
name|PNG_FIXED_ERROR
operator|||
name|x_red
operator|==
name|PNG_FIXED_ERROR
operator|||
name|y_red
operator|==
name|PNG_FIXED_ERROR
operator|||
name|x_green
operator|==
name|PNG_FIXED_ERROR
operator|||
name|y_green
operator|==
name|PNG_FIXED_ERROR
operator|||
name|x_blue
operator|==
name|PNG_FIXED_ERROR
operator|||
name|y_blue
operator|==
name|PNG_FIXED_ERROR
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring cHRM chunk with negative chromaticities"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
if|if
condition|(
operator|(
name|info_ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
operator|)
condition|)
block|{
if|if
condition|(
name|PNG_OUT_OF_RANGE
argument_list|(
name|x_white
argument_list|,
literal|31270
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|y_white
argument_list|,
literal|32900
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|x_red
argument_list|,
literal|64000L
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|y_red
argument_list|,
literal|33000
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|x_green
argument_list|,
literal|30000
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|y_green
argument_list|,
literal|60000L
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|x_blue
argument_list|,
literal|15000
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|y_blue
argument_list|,
literal|6000
argument_list|,
literal|1000
argument_list|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring incorrect cHRM value when sRGB is also present"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"wx=%d, wy=%d, rx=%d, ry=%d\n"
argument_list|,
name|x_white
argument_list|,
name|y_white
argument_list|,
name|x_red
argument_list|,
name|y_red
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gx=%d, gy=%d, bx=%d, by=%d\n"
argument_list|,
name|x_green
argument_list|,
name|y_green
argument_list|,
name|x_blue
argument_list|,
name|y_blue
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_CONSOLE_IO_SUPPORTED */
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* PNG_READ_sRGB_SUPPORTED */
name|png_set_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|x_white
argument_list|,
name|y_white
argument_list|,
name|x_red
argument_list|,
name|y_red
argument_list|,
name|x_green
argument_list|,
name|y_green
argument_list|,
name|x_blue
argument_list|,
name|y_blue
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sRGB
name|png_handle_sRGB
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|int
name|intent
decl_stmt|;
name|png_byte
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sRGB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before sRGB"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sRGB after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
condition|)
comment|/* Should be an error, but we can cope with it */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place sRGB chunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sRGB
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate sRGB chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|1
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect sRGB chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|intent
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* Check for bad intent */
if|if
condition|(
name|intent
operator|>=
name|PNG_sRGB_INTENT_LAST
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown sRGB intent"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_gAMA_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_gAMA
operator|)
condition|)
block|{
if|if
condition|(
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|gamma
argument_list|,
literal|45500L
argument_list|,
literal|500
argument_list|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring incorrect gAMA value when sRGB is also present"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_CONSOLE_IO_SUPPORTED
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"incorrect gamma=(%d/100000)\n"
argument_list|,
name|info_ptr
operator|->
name|gamma
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* PNG_READ_gAMA_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_cHRM
operator|)
condition|)
if|if
condition|(
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|x_white
argument_list|,
literal|31270
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|y_white
argument_list|,
literal|32900
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|x_red
argument_list|,
literal|64000L
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|y_red
argument_list|,
literal|33000
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|x_green
argument_list|,
literal|30000
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|y_green
argument_list|,
literal|60000L
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|x_blue
argument_list|,
literal|15000
argument_list|,
literal|1000
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|info_ptr
operator|->
name|y_blue
argument_list|,
literal|6000
argument_list|,
literal|1000
argument_list|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring incorrect cHRM value when sRGB is also present"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PNG_READ_cHRM_SUPPORTED */
name|png_set_sRGB_gAMA_and_cHRM
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|intent
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_sRGB_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_iCCP
name|png_handle_iCCP
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
comment|/* Note: this does not properly handle chunks that are> 64K under DOS */
block|{
name|png_byte
name|compression_type
decl_stmt|;
name|png_bytep
name|pC
decl_stmt|;
name|png_charp
name|profile
decl_stmt|;
name|png_uint_32
name|skip
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|profile_size
decl_stmt|;
name|png_alloc_size_t
name|profile_length
decl_stmt|;
name|png_size_t
name|slength
decl_stmt|,
name|prefix_length
decl_stmt|,
name|data_length
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_iCCP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before iCCP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid iCCP after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
condition|)
comment|/* Should be an error, but we can cope with it */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place iCCP chunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_iCCP
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate iCCP chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"iCCP chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|skip
operator|=
name|length
operator|-
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
name|length
operator|=
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
block|}
endif|#
directive|endif
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|slength
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|skip
argument_list|)
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|chunkdata
index|[
name|slength
index|]
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|profile
operator|=
name|png_ptr
operator|->
name|chunkdata
init|;
operator|*
name|profile
condition|;
name|profile
operator|++
control|)
comment|/* Empty loop to find end of name */
empty_stmt|;
operator|++
name|profile
expr_stmt|;
comment|/* There should be at least one zero (the compression type byte)     * following the separator, and we should be on it     */
if|if
condition|(
name|profile
operator|>=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|slength
operator|-
literal|1
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Malformed iCCP chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Compression_type should always be zero */
name|compression_type
operator|=
operator|*
name|profile
operator|++
expr_stmt|;
if|if
condition|(
name|compression_type
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring nonzero compression type in iCCP chunk"
argument_list|)
expr_stmt|;
name|compression_type
operator|=
literal|0x00
expr_stmt|;
comment|/* Reset it to zero (libpng-1.0.6 through 1.0.8                                  wrote nonzero) */
block|}
name|prefix_length
operator|=
name|profile
operator|-
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
name|png_decompress_chunk
argument_list|(
name|png_ptr
argument_list|,
name|compression_type
argument_list|,
name|slength
argument_list|,
name|prefix_length
argument_list|,
operator|&
name|data_length
argument_list|)
expr_stmt|;
name|profile_length
operator|=
name|data_length
operator|-
name|prefix_length
expr_stmt|;
if|if
condition|(
name|prefix_length
operator|>
name|data_length
operator|||
name|profile_length
operator|<
literal|4
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Profile size field missing from iCCP chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check the profile_size recorded in the first 32 bits of the ICC profile */
name|pC
operator|=
call|(
name|png_bytep
call|)
argument_list|(
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_length
argument_list|)
expr_stmt|;
name|profile_size
operator|=
operator|(
operator|(
operator|*
operator|(
name|pC
operator|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|pC
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|pC
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|pC
operator|+
literal|3
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* NOTE: the following guarantees that 'profile_length' fits into 32 bits,     * because profile_size is a 32 bit value.     */
if|if
condition|(
name|profile_size
operator|<
name|profile_length
condition|)
name|profile_length
operator|=
name|profile_size
expr_stmt|;
comment|/* And the following guarantees that profile_size == profile_length. */
if|if
condition|(
name|profile_size
operator|>
name|profile_length
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
block|{
name|char
name|umsg
index|[
literal|80
index|]
decl_stmt|;
name|png_snprintf2
argument_list|(
name|umsg
argument_list|,
literal|80
argument_list|,
literal|"Ignoring iCCP chunk with declared size = %u "
literal|"and actual length = %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|profile_size
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|profile_length
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|umsg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring iCCP chunk with uncompressed size mismatch"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|png_set_iCCP
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|compression_type
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_length
argument_list|,
name|profile_size
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_iCCP_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sPLT
name|png_handle_sPLT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
comment|/* Note: this does not properly handle chunks that are> 64K under DOS */
block|{
name|png_bytep
name|entry_start
decl_stmt|;
name|png_sPLT_t
name|new_palette
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
name|png_sPLT_entryp
name|pp
decl_stmt|;
endif|#
directive|endif
name|png_uint_32
name|data_length
decl_stmt|;
name|int
name|entry_size
decl_stmt|,
name|i
decl_stmt|;
name|png_uint_32
name|skip
init|=
literal|0
decl_stmt|;
name|png_size_t
name|slength
decl_stmt|;
name|png_uint_32
name|dl
decl_stmt|;
name|png_size_t
name|max_dl
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sPLT"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No space in chunk cache for sPLT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before sPLT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sPLT after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|skip
operator|=
name|length
operator|-
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
name|length
operator|=
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
block|}
endif|#
directive|endif
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* WARNING: this may break if size_t is less than 32 bits; it is assumed     * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a     * potential breakage point if the types in pngconf.h aren't exactly right.     */
name|slength
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|skip
argument_list|)
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|chunkdata
index|[
name|slength
index|]
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|entry_start
operator|=
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
init|;
operator|*
name|entry_start
condition|;
name|entry_start
operator|++
control|)
comment|/* Empty loop to find end of name */
empty_stmt|;
operator|++
name|entry_start
expr_stmt|;
comment|/* A sample depth should follow the separator, and we should be on it  */
if|if
condition|(
name|entry_start
operator|>
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
operator|+
name|slength
operator|-
literal|2
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"malformed sPLT chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_palette
operator|.
name|depth
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|entry_size
operator|=
operator|(
name|new_palette
operator|.
name|depth
operator|==
literal|8
condition|?
literal|6
else|:
literal|10
operator|)
expr_stmt|;
comment|/* This must fit in a png_uint_32 because it is derived from the original     * chunk data length (and use 'length', not 'slength' here for clarity -     * they are guaranteed to be the same, see the tests above.)     */
name|data_length
operator|=
name|length
operator|-
call|(
name|png_uint_32
call|)
argument_list|(
name|entry_start
operator|-
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
comment|/* Integrity-check the data length */
if|if
condition|(
name|data_length
operator|%
name|entry_size
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT chunk has bad length"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dl
operator|=
call|(
name|png_int_32
call|)
argument_list|(
name|data_length
operator|/
name|entry_size
argument_list|)
expr_stmt|;
name|max_dl
operator|=
name|PNG_SIZE_MAX
operator|/
name|png_sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|>
name|max_dl
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT chunk too long"
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_palette
operator|.
name|nentries
operator|=
call|(
name|png_int_32
call|)
argument_list|(
name|data_length
operator|/
name|entry_size
argument_list|)
expr_stmt|;
name|new_palette
operator|.
name|entries
operator|=
operator|(
name|png_sPLT_entryp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|new_palette
operator|.
name|nentries
operator|*
name|png_sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_palette
operator|.
name|entries
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT chunk requires too much memory"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_palette
operator|.
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
name|new_palette
operator|.
name|entries
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|new_palette
operator|.
name|depth
operator|==
literal|8
condition|)
block|{
name|pp
operator|->
name|red
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
operator|->
name|green
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
operator|->
name|blue
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
operator|->
name|alpha
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
operator|->
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
operator|->
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
operator|->
name|alpha
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
name|pp
operator|->
name|frequency
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
else|#
directive|else
name|pp
operator|=
name|new_palette
operator|.
name|entries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_palette
operator|.
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|new_palette
operator|.
name|depth
operator|==
literal|8
condition|)
block|{
name|pp
index|[
name|i
index|]
operator|.
name|red
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|green
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|alpha
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pp
index|[
name|i
index|]
operator|.
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|alpha
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
name|pp
operator|->
name|frequency
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Discard all chunk data except the name and stash that */
name|new_palette
operator|.
name|name
operator|=
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
name|png_set_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|new_palette
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_palette
operator|.
name|entries
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_sPLT_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_tRNS
name|png_handle_tRNS
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|readbuf
index|[
name|PNG_MAX_PALETTE_LENGTH
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_tRNS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before tRNS"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid tRNS after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate tRNS chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
name|png_byte
name|buf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|length
operator|!=
literal|2
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect tRNS chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_trans
operator|=
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|length
operator|!=
literal|6
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect tRNS chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_trans
operator|=
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
condition|)
block|{
comment|/* Should be an error, but we can cope with it. */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before tRNS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
name|png_ptr
operator|->
name|num_palette
operator|||
name|length
operator|>
name|PNG_MAX_PALETTE_LENGTH
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect tRNS chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Zero length tRNS chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|readbuf
argument_list|,
operator|(
name|png_size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_trans
operator|=
operator|(
name|png_uint_16
operator|)
name|length
expr_stmt|;
block|}
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"tRNS chunk not allowed with alpha channel"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|png_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|png_set_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|readbuf
argument_list|,
name|png_ptr
operator|->
name|num_trans
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|trans_color
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_bKGD
name|png_handle_bKGD
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_size_t
name|truelen
decl_stmt|;
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_bKGD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before bKGD"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bKGD after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before bKGD"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_bKGD
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate bKGD chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|truelen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
name|truelen
operator|=
literal|6
expr_stmt|;
else|else
name|truelen
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|truelen
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect bKGD chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|truelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* We convert the index value into RGB components so that we can allow     * arbitrary RGB values for background when we have transparency, and     * so it is easy to determine the RGB values of the background color     * from the info_ptr struct.     */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_ptr
operator|->
name|background
operator|.
name|index
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|&&
name|info_ptr
operator|->
name|num_palette
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|>=
name|info_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect bKGD chunk index value"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
operator|(
name|png_uint_16
operator|)
name|png_ptr
operator|->
name|palette
index|[
name|buf
index|[
literal|0
index|]
index|]
operator|.
name|red
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
operator|(
name|png_uint_16
operator|)
name|png_ptr
operator|->
name|palette
index|[
name|buf
index|[
literal|0
index|]
index|]
operator|.
name|green
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|png_ptr
operator|->
name|palette
index|[
name|buf
index|[
literal|0
index|]
index|]
operator|.
name|blue
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
condition|)
comment|/* GRAY */
block|{
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
name|png_ptr
operator|->
name|background
operator|.
name|gray
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|background
operator|.
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|background
operator|.
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|png_set_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|background
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_hIST
name|png_handle_hIST
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|unsigned
name|int
name|num
decl_stmt|,
name|i
decl_stmt|;
name|png_uint_16
name|readbuf
index|[
name|PNG_MAX_PALETTE_LENGTH
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_hIST"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before hIST"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid hIST after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing PLTE before hIST"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_hIST
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate hIST chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|=
name|length
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|num
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|png_ptr
operator|->
name|num_palette
operator|||
name|num
operator|>
operator|(
name|unsigned
name|int
operator|)
name|PNG_MAX_PALETTE_LENGTH
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect hIST chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|readbuf
index|[
name|i
index|]
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|png_set_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_pHYs
name|png_handle_pHYs
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_uint_32
name|res_x
decl_stmt|,
name|res_y
decl_stmt|;
name|int
name|unit_type
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_pHYs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before pHYs"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pHYs after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pHYs
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate pHYs chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|9
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect pHYs chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|res_x
operator|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|res_y
operator|=
name|png_get_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|unit_type
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|png_set_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|res_x
argument_list|,
name|res_y
argument_list|,
name|unit_type
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_oFFs
name|png_handle_oFFs
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_int_32
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|int
name|unit_type
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_oFFs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before oFFs"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid oFFs after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_oFFs
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate oFFs chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|9
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect oFFs chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|offset_x
operator|=
name|png_get_int_32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|offset_y
operator|=
name|png_get_int_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|unit_type
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|png_set_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|,
name|unit_type
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the pCAL chunk (described in the PNG Extensions document) */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_pCAL
name|png_handle_pCAL
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_int_32
name|X0
decl_stmt|,
name|X1
decl_stmt|;
name|png_byte
name|type
decl_stmt|,
name|nparams
decl_stmt|;
name|png_charp
name|buf
decl_stmt|,
name|units
decl_stmt|,
name|endptr
decl_stmt|;
name|png_charpp
name|params
decl_stmt|;
name|png_size_t
name|slength
decl_stmt|;
name|int
name|i
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_pCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before pCAL"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pCAL after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pCAL
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate pCAL chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"Allocating and reading pCAL chunk data (%u bytes)"
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No memory for pCAL purpose"
argument_list|)
expr_stmt|;
return|return;
block|}
name|slength
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|chunkdata
index|[
name|slength
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/* Null terminate the last string */
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Finding end of pCAL purpose string"
argument_list|)
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|png_ptr
operator|->
name|chunkdata
init|;
operator|*
name|buf
condition|;
name|buf
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
name|endptr
operator|=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|slength
expr_stmt|;
comment|/* We need to have at least 12 bytes after the purpose string     * in order to get the parameter information.     */
if|if
condition|(
name|endptr
operator|<=
name|buf
operator|+
literal|12
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pCAL data"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Reading pCAL X0, X1, type, nparams, and units"
argument_list|)
expr_stmt|;
name|X0
operator|=
name|png_get_int_32
argument_list|(
operator|(
name|png_bytep
operator|)
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|X1
operator|=
name|png_get_int_32
argument_list|(
operator|(
name|png_bytep
operator|)
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
name|type
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|nparams
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
name|units
operator|=
name|buf
operator|+
literal|11
expr_stmt|;
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Checking pCAL equation type and number of parameters"
argument_list|)
expr_stmt|;
comment|/* Check that we have the right number of parameters for known     * equation types.     */
if|if
condition|(
operator|(
name|type
operator|==
name|PNG_EQUATION_LINEAR
operator|&&
name|nparams
operator|!=
literal|2
operator|)
operator|||
operator|(
name|type
operator|==
name|PNG_EQUATION_BASE_E
operator|&&
name|nparams
operator|!=
literal|3
operator|)
operator|||
operator|(
name|type
operator|==
name|PNG_EQUATION_ARBITRARY
operator|&&
name|nparams
operator|!=
literal|3
operator|)
operator|||
operator|(
name|type
operator|==
name|PNG_EQUATION_HYPERBOLIC
operator|&&
name|nparams
operator|!=
literal|4
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pCAL parameters for equation type"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|PNG_EQUATION_LAST
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unrecognized equation type for pCAL chunk"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|buf
operator|=
name|units
init|;
operator|*
name|buf
condition|;
name|buf
operator|++
control|)
comment|/* Empty loop to move past the units string. */
empty_stmt|;
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Allocating pCAL parameters array"
argument_list|)
expr_stmt|;
name|params
operator|=
operator|(
name|png_charpp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|nparams
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No memory for pCAL params"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get pointers to the start of each parameter string. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|++
expr_stmt|;
comment|/* Skip the null string terminator from previous parameter. */
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"Reading pCAL parameter %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|params
index|[
name|i
index|]
operator|=
name|buf
init|;
name|buf
operator|<=
name|endptr
operator|&&
operator|*
name|buf
operator|!=
literal|0x00
condition|;
name|buf
operator|++
control|)
comment|/* Empty loop to move past each parameter string */
empty_stmt|;
comment|/* Make sure we haven't run out of data yet */
if|if
condition|(
name|buf
operator|>
name|endptr
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid pCAL data"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|png_set_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|X0
argument_list|,
name|X1
argument_list|,
name|type
argument_list|,
name|nparams
argument_list|,
name|units
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the sCAL chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sCAL
name|png_handle_sCAL
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_size_t
name|slength
decl_stmt|,
name|i
decl_stmt|;
name|int
name|state
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before sCAL"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL after IDAT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sCAL
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate sCAL chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"Allocating and reading sCAL chunk data (%u bytes)"
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of memory while processing sCAL chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|slength
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
index|[
name|slength
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/* Null terminate the last string */
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* Validate the unit. */
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
index|[
literal|0
index|]
operator|!=
literal|1
operator|&&
name|png_ptr
operator|->
name|chunkdata
index|[
literal|0
index|]
operator|!=
literal|2
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL ignored: invalid unit"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* Validate the ASCII numbers, need two ASCII numbers separated by     * a '\0' and they need to fit exactly in the chunk data.     */
name|i
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
index|[
literal|1
index|]
operator|==
literal|45
comment|/* negative width */
operator|||
operator|!
name|png_check_fp_number
argument_list|(
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|i
argument_list|)
operator|||
name|i
operator|>=
name|slength
operator|||
name|png_ptr
operator|->
name|chunkdata
index|[
name|i
operator|++
index|]
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL chunk ignored: bad width format"
argument_list|)
expr_stmt|;
else|else
block|{
name|png_size_t
name|heighti
init|=
name|i
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
index|[
name|i
index|]
operator|==
literal|45
comment|/* negative height */
operator|||
operator|!
name|png_check_fp_number
argument_list|(
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|i
argument_list|)
operator|||
name|i
operator|!=
name|slength
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sCAL chunk ignored: bad height format"
argument_list|)
expr_stmt|;
else|else
comment|/* This is the (only) success case. */
name|png_set_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
index|[
literal|0
index|]
argument_list|,
name|png_ptr
operator|->
name|chunkdata
operator|+
literal|1
argument_list|,
name|png_ptr
operator|->
name|chunkdata
operator|+
name|heighti
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up - just free the temporarily allocated buffer. */
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_tIME
name|png_handle_tIME
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|7
index|]
decl_stmt|;
name|png_time
name|mod_time
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_tIME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of place tIME chunk"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tIME
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Duplicate tIME chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|7
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Incorrect tIME chunk length"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|mod_time
operator|.
name|second
operator|=
name|buf
index|[
literal|6
index|]
expr_stmt|;
name|mod_time
operator|.
name|minute
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
name|mod_time
operator|.
name|hour
operator|=
name|buf
index|[
literal|4
index|]
expr_stmt|;
name|mod_time
operator|.
name|day
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|mod_time
operator|.
name|month
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|mod_time
operator|.
name|year
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|png_set_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|mod_time
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Note: this does not properly handle chunks that are> 64K under DOS */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_tEXt
name|png_handle_tEXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_textp
name|text_ptr
decl_stmt|;
name|png_charp
name|key
decl_stmt|;
name|png_charp
name|text
decl_stmt|;
name|png_uint_32
name|skip
init|=
literal|0
decl_stmt|;
name|png_size_t
name|slength
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_tEXt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No space in chunk cache for tEXt"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before tEXt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"tEXt chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|skip
operator|=
name|length
operator|-
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
name|length
operator|=
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
block|}
endif|#
directive|endif
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No memory to process text chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|slength
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|skip
argument_list|)
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|key
operator|=
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
name|key
index|[
name|slength
index|]
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|text
operator|=
name|key
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
comment|/* Empty loop to find end of key */
empty_stmt|;
if|if
condition|(
name|text
operator|!=
name|key
operator|+
name|slength
condition|)
name|text
operator|++
expr_stmt|;
name|text_ptr
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_ptr
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough memory to process text chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|text_ptr
operator|->
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
name|text_ptr
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|text_ptr
operator|->
name|lang
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|lang_key
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|itxt_length
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|text_ptr
operator|->
name|text_length
operator|=
name|png_strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to process text chunk"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Note: this does not correctly handle chunks that are> 64K under DOS */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_zTXt
name|png_handle_zTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_textp
name|text_ptr
decl_stmt|;
name|png_charp
name|text
decl_stmt|;
name|int
name|comp_type
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|png_size_t
name|slength
decl_stmt|,
name|prefix_len
decl_stmt|,
name|data_len
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_zTXt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No space in chunk cache for zTXt"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before zTXt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
comment|/* We will no doubt have problems with chunks even half this size, but     * there is no hard and fast rule to tell us where to stop.     */
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"zTXt chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of memory processing zTXt chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|slength
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|chunkdata
index|[
name|slength
index|]
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|text
operator|=
name|png_ptr
operator|->
name|chunkdata
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
comment|/* zTXt must have some text after the chunkdataword */
if|if
condition|(
name|text
operator|>=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|slength
operator|-
literal|2
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncated zTXt chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
else|else
block|{
name|comp_type
operator|=
operator|*
operator|(
operator|++
name|text
operator|)
expr_stmt|;
if|if
condition|(
name|comp_type
operator|!=
name|PNG_TEXT_COMPRESSION_zTXt
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown compression type in zTXt chunk"
argument_list|)
expr_stmt|;
name|comp_type
operator|=
name|PNG_TEXT_COMPRESSION_zTXt
expr_stmt|;
block|}
name|text
operator|++
expr_stmt|;
comment|/* Skip the compression_method byte */
block|}
name|prefix_len
operator|=
name|text
operator|-
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
name|png_decompress_chunk
argument_list|(
name|png_ptr
argument_list|,
name|comp_type
argument_list|,
operator|(
name|png_size_t
operator|)
name|length
argument_list|,
name|prefix_len
argument_list|,
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|text_ptr
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_ptr
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough memory to process zTXt chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|text_ptr
operator|->
name|compression
operator|=
name|comp_type
expr_stmt|;
name|text_ptr
operator|->
name|key
operator|=
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
name|text_ptr
operator|->
name|lang
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|lang_key
operator|=
name|NULL
expr_stmt|;
name|text_ptr
operator|->
name|itxt_length
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|->
name|text
operator|=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_len
expr_stmt|;
name|text_ptr
operator|->
name|text_length
operator|=
name|data_len
expr_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to store zTXt chunk"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Note: this does not correctly handle chunks that are> 64K under DOS */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_iTXt
name|png_handle_iTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_textp
name|text_ptr
decl_stmt|;
name|png_charp
name|key
decl_stmt|,
name|lang
decl_stmt|,
name|text
decl_stmt|,
name|lang_key
decl_stmt|;
name|int
name|comp_flag
decl_stmt|;
name|int
name|comp_type
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|png_size_t
name|slength
decl_stmt|,
name|prefix_len
decl_stmt|,
name|data_len
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_iTXt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No space in chunk cache for iTXt"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Missing IHDR before iTXt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
comment|/* We will no doubt have problems with chunks even half this size, but     * there is no hard and fast rule to tell us where to stop.     */
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"iTXt chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunkdata
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No memory to process iTXt chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|slength
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|chunkdata
argument_list|,
name|slength
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|chunkdata
index|[
name|slength
index|]
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|lang
operator|=
name|png_ptr
operator|->
name|chunkdata
init|;
operator|*
name|lang
condition|;
name|lang
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
name|lang
operator|++
expr_stmt|;
comment|/* Skip NUL separator */
comment|/* iTXt must have a language tag (possibly empty), two compression bytes,     * translated keyword (possibly empty), and possibly some text after the     * keyword     */
if|if
condition|(
name|lang
operator|>=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|slength
operator|-
literal|3
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncated iTXt chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
else|else
block|{
name|comp_flag
operator|=
operator|*
name|lang
operator|++
expr_stmt|;
name|comp_type
operator|=
operator|*
name|lang
operator|++
expr_stmt|;
block|}
for|for
control|(
name|lang_key
operator|=
name|lang
init|;
operator|*
name|lang_key
condition|;
name|lang_key
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
name|lang_key
operator|++
expr_stmt|;
comment|/* Skip NUL separator */
if|if
condition|(
name|lang_key
operator|>=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|slength
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncated iTXt chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
for|for
control|(
name|text
operator|=
name|lang_key
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
name|text
operator|++
expr_stmt|;
comment|/* Skip NUL separator */
if|if
condition|(
name|text
operator|>=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|slength
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Malformed iTXt chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|prefix_len
operator|=
name|text
operator|-
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
name|key
operator|=
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
if|if
condition|(
name|comp_flag
condition|)
name|png_decompress_chunk
argument_list|(
name|png_ptr
argument_list|,
name|comp_type
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|,
name|prefix_len
argument_list|,
operator|&
name|data_len
argument_list|)
expr_stmt|;
else|else
name|data_len
operator|=
name|png_strlen
argument_list|(
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_len
argument_list|)
expr_stmt|;
name|text_ptr
operator|=
operator|(
name|png_textp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_text
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_ptr
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough memory to process iTXt chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|text_ptr
operator|->
name|compression
operator|=
operator|(
name|int
operator|)
name|comp_flag
operator|+
literal|1
expr_stmt|;
name|text_ptr
operator|->
name|lang_key
operator|=
name|png_ptr
operator|->
name|chunkdata
operator|+
operator|(
name|lang_key
operator|-
name|key
operator|)
expr_stmt|;
name|text_ptr
operator|->
name|lang
operator|=
name|png_ptr
operator|->
name|chunkdata
operator|+
operator|(
name|lang
operator|-
name|key
operator|)
expr_stmt|;
name|text_ptr
operator|->
name|itxt_length
operator|=
name|data_len
expr_stmt|;
name|text_ptr
operator|->
name|text_length
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|->
name|key
operator|=
name|png_ptr
operator|->
name|chunkdata
expr_stmt|;
name|text_ptr
operator|->
name|text
operator|=
name|png_ptr
operator|->
name|chunkdata
operator|+
name|prefix_len
expr_stmt|;
name|ret
operator|=
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|text_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunkdata
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunkdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to store iTXt chunk"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This function is called when we haven't found a handler for a  * chunk.  If there isn't a problem with the chunk itself (ie bad  * chunk name, CRC, or a critical chunk), the chunk is silently ignored  * -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which  * case it will be saved away to be written out later.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_unknown
name|png_handle_unknown
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_uint_32
name|skip
init|=
literal|0
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_unknown"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No space in chunk cache for unknown chunk"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
condition|)
block|{
name|PNG_IDAT
expr_stmt|;
if|if
condition|(
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IDAT
argument_list|,
literal|4
argument_list|)
condition|)
comment|/* Not an IDAT */
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
if|if
condition|(
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|!=
name|PNG_HANDLE_CHUNK_ALWAYS
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
operator|&&
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|==
name|NULL
endif|#
directive|endif
condition|)
endif|#
directive|endif
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown critical chunk"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_KEEP_UNKNOWN_CHUNKS
operator|)
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
operator|||
operator|(
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|!=
name|NULL
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|length
operator|>
operator|(
name|png_uint_32
operator|)
literal|65535L
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown chunk too large to fit in memory"
argument_list|)
expr_stmt|;
name|skip
operator|=
name|length
operator|-
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
name|length
operator|=
operator|(
name|png_uint_32
operator|)
literal|65535L
expr_stmt|;
block|}
endif|#
directive|endif
name|png_memcpy
argument_list|(
operator|(
name|png_charp
operator|)
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
argument_list|,
operator|(
name|png_charp
operator|)
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_sizeof
argument_list|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
index|[
name|png_sizeof
argument_list|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|size
operator|=
operator|(
name|png_size_t
operator|)
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|!=
name|NULL
condition|)
block|{
comment|/* Callback to user unknown chunk handler */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|)
operator|)
operator|(
name|png_ptr
operator|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"error in user chunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
if|if
condition|(
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|!=
name|PNG_HANDLE_CHUNK_ALWAYS
condition|)
endif|#
directive|endif
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown critical chunk"
argument_list|)
expr_stmt|;
block|}
name|png_set_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|png_set_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|skip
operator|=
name|length
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|skip
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_READ_USER_CHUNKS_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
comment|/* Quiet compiler warnings about unused info_ptr */
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* This function is called to verify that a chunk name is valid.  * This function can't have the "critical chunk check" incorporated  * into it, since in the future we will need to be able to call user  * functions to handle unknown critical chunks after we check that  * the chunk name itself is valid.  */
end_comment
begin_define
DECL|macro|isnonalpha
define|#
directive|define
name|isnonalpha
parameter_list|(
name|c
parameter_list|)
value|((c)< 65 || (c)> 122 || ((c)> 90&& (c)< 97))
end_define
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_check_chunk_name
name|png_check_chunk_name
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_name
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_check_chunk_name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnonalpha
argument_list|(
name|chunk_name
index|[
literal|0
index|]
argument_list|)
operator|||
name|isnonalpha
argument_list|(
name|chunk_name
index|[
literal|1
index|]
argument_list|)
operator|||
name|isnonalpha
argument_list|(
name|chunk_name
index|[
literal|2
index|]
argument_list|)
operator|||
name|isnonalpha
argument_list|(
name|chunk_name
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid chunk type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Combines the row recently read in with the existing pixels in the  * row.  This routine takes care of alpha and transparency if requested.  * This routine also handles the two methods of progressive display  * of interlaced images, depending on the mask value.  * The mask value describes which pixels are to be combined with  * the row.  The pattern always repeats every 8 pixels, so just 8  * bits are needed.  A one indicates the pixel is to be combined,  * a zero indicates the pixel is to be skipped.  This is in addition  * to any alpha or transparency value associated with the pixel.  If  * you want all pixels to be combined, pass 0xff (255) in mask.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_combine_row
name|png_combine_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_combine_row"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0xff
condition|)
block|{
name|png_memcpy
argument_list|(
name|row
argument_list|,
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
argument_list|,
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|png_bytep
name|sp
init|=
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|int
name|s_inc
decl_stmt|,
name|s_start
decl_stmt|,
name|s_end
decl_stmt|;
name|int
name|m
init|=
literal|0x80
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|png_ptr
operator|->
name|width
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
block|{
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|7
expr_stmt|;
name|s_inc
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|s_start
operator|=
literal|7
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|shift
operator|=
name|s_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|&
name|mask
condition|)
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x01
expr_stmt|;
operator|*
name|dp
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|0x7f7f
operator|>>
operator|(
literal|7
operator|-
name|shift
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|dp
operator||=
call|(
name|png_byte
call|)
argument_list|(
name|value
operator|<<
name|shift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
name|s_end
condition|)
block|{
name|shift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|+=
name|s_inc
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|1
condition|)
name|m
operator|=
literal|0x80
expr_stmt|;
else|else
name|m
operator|>>=
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|png_bytep
name|sp
init|=
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|int
name|m
init|=
literal|0x80
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|png_ptr
operator|->
name|width
decl_stmt|;
name|int
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
block|{
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|6
expr_stmt|;
name|s_inc
operator|=
literal|2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|s_start
operator|=
literal|6
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|shift
operator|=
name|s_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|&
name|mask
condition|)
block|{
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0x03
expr_stmt|;
operator|*
name|dp
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|0x3f3f
operator|>>
operator|(
literal|6
operator|-
name|shift
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|dp
operator||=
call|(
name|png_byte
call|)
argument_list|(
name|value
operator|<<
name|shift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
name|s_end
condition|)
block|{
name|shift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|+=
name|s_inc
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|1
condition|)
name|m
operator|=
literal|0x80
expr_stmt|;
else|else
name|m
operator|>>=
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|png_bytep
name|sp
init|=
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|int
name|m
init|=
literal|0x80
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|png_ptr
operator|->
name|width
decl_stmt|;
name|int
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
block|{
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|4
expr_stmt|;
name|s_inc
operator|=
literal|4
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|s_start
operator|=
literal|4
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|4
expr_stmt|;
block|}
name|shift
operator|=
name|s_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|&
name|mask
condition|)
block|{
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|dp
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|0xf0f
operator|>>
operator|(
literal|4
operator|-
name|shift
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|dp
operator||=
call|(
name|png_byte
call|)
argument_list|(
name|value
operator|<<
name|shift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|==
name|s_end
condition|)
block|{
name|shift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
else|else
name|shift
operator|+=
name|s_inc
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|1
condition|)
name|m
operator|=
literal|0x80
expr_stmt|;
else|else
name|m
operator|>>=
literal|1
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|png_bytep
name|sp
init|=
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
decl_stmt|;
name|png_size_t
name|pixel_bytes
init|=
operator|(
name|png_ptr
operator|->
name|row_info
operator|.
name|pixel_depth
operator|>>
literal|3
operator|)
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|png_ptr
operator|->
name|width
decl_stmt|;
name|png_byte
name|m
init|=
literal|0x80
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|&
name|mask
condition|)
block|{
name|png_memcpy
argument_list|(
name|dp
argument_list|,
name|sp
argument_list|,
name|pixel_bytes
argument_list|)
expr_stmt|;
block|}
name|sp
operator|+=
name|pixel_bytes
expr_stmt|;
name|dp
operator|+=
name|pixel_bytes
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|1
condition|)
name|m
operator|=
literal|0x80
expr_stmt|;
else|else
name|m
operator|>>=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_do_read_interlace
name|png_do_read_interlace
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_row_infop
name|row_info
init|=
operator|&
operator|(
name|png_ptr
operator|->
name|row_info
operator|)
decl_stmt|;
name|png_bytep
name|row
init|=
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
decl_stmt|;
name|int
name|pass
init|=
name|png_ptr
operator|->
name|pass
decl_stmt|;
name|png_uint_32
name|transformations
init|=
name|png_ptr
operator|->
name|transformations
decl_stmt|;
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Offset to next interlace block */
name|PNG_CONST
name|int
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_read_interlace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
name|NULL
operator|&&
name|row_info
operator|!=
name|NULL
condition|)
block|{
name|png_uint_32
name|final_width
decl_stmt|;
name|final_width
operator|=
name|row_info
operator|->
name|width
operator|*
name|png_pass_inc
index|[
name|pass
index|]
expr_stmt|;
switch|switch
condition|(
name|row_info
operator|->
name|pixel_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|-
literal|1
operator|)
operator|>>
literal|3
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|final_width
operator|-
literal|1
operator|)
operator|>>
literal|3
argument_list|)
decl_stmt|;
name|int
name|sshift
decl_stmt|,
name|dshift
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
name|png_byte
name|v
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|final_width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|7
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|sshift
operator|=
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|dshift
operator|=
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|final_width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|7
expr_stmt|;
name|s_inc
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|sshift
operator|)
operator|&
literal|0x01
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dp
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|0x7f7f
operator|>>
operator|(
literal|7
operator|-
name|dshift
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|dp
operator||=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|<<
name|dshift
argument_list|)
expr_stmt|;
if|if
condition|(
name|dshift
operator|==
name|s_end
condition|)
block|{
name|dshift
operator|=
name|s_start
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
else|else
name|dshift
operator|+=
name|s_inc
expr_stmt|;
block|}
if|if
condition|(
name|sshift
operator|==
name|s_end
condition|)
block|{
name|sshift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|sshift
operator|+=
name|s_inc
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
name|final_width
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
decl_stmt|;
name|int
name|sshift
decl_stmt|,
name|dshift
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|final_width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|6
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|3
operator|-
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|3
operator|-
operator|(
operator|(
name|final_width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|6
expr_stmt|;
name|s_inc
operator|=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|v
decl_stmt|;
name|int
name|j
decl_stmt|;
name|v
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|sshift
operator|)
operator|&
literal|0x03
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dp
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|0x3f3f
operator|>>
operator|(
literal|6
operator|-
name|dshift
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|dp
operator||=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|<<
name|dshift
argument_list|)
expr_stmt|;
if|if
condition|(
name|dshift
operator|==
name|s_end
condition|)
block|{
name|dshift
operator|=
name|s_start
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
else|else
name|dshift
operator|+=
name|s_inc
expr_stmt|;
block|}
if|if
condition|(
name|sshift
operator|==
name|s_end
condition|)
block|{
name|sshift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|sshift
operator|+=
name|s_inc
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|final_width
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|int
name|sshift
decl_stmt|,
name|dshift
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
name|transformations
operator|&
name|PNG_PACKSWAP
condition|)
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|final_width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|4
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|4
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
operator|(
operator|(
name|final_width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|4
expr_stmt|;
name|s_inc
operator|=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|v
init|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|sshift
operator|)
operator|&
literal|0xf
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|dp
operator|&=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|0xf0f
operator|>>
operator|(
literal|4
operator|-
name|dshift
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|dp
operator||=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|<<
name|dshift
argument_list|)
expr_stmt|;
if|if
condition|(
name|dshift
operator|==
name|s_end
condition|)
block|{
name|dshift
operator|=
name|s_start
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
else|else
name|dshift
operator|+=
name|s_inc
expr_stmt|;
block|}
if|if
condition|(
name|sshift
operator|==
name|s_end
condition|)
block|{
name|sshift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|sshift
operator|+=
name|s_inc
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|png_size_t
name|pixel_bytes
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|>>
literal|3
operator|)
decl_stmt|;
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|row_info
operator|->
name|width
operator|-
literal|1
argument_list|)
operator|*
name|pixel_bytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|final_width
operator|-
literal|1
argument_list|)
operator|*
name|pixel_bytes
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|v
index|[
literal|8
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
name|png_memcpy
argument_list|(
name|v
argument_list|,
name|sp
argument_list|,
name|pixel_bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
name|png_memcpy
argument_list|(
name|dp
argument_list|,
name|v
argument_list|,
name|pixel_bytes
argument_list|)
expr_stmt|;
name|dp
operator|-=
name|pixel_bytes
expr_stmt|;
block|}
name|sp
operator|-=
name|pixel_bytes
expr_stmt|;
block|}
break|break;
block|}
block|}
name|row_info
operator|->
name|width
operator|=
name|final_width
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|final_width
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PNG_READ_PACKSWAP_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|transformations
argument_list|)
comment|/* Silence compiler warning */
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_INTERLACING_SUPPORTED */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_filter_row
name|png_read_filter_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|prev_row
parameter_list|,
name|int
name|filter
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_filter_row"
argument_list|)
expr_stmt|;
name|png_debug2
argument_list|(
literal|2
argument_list|,
literal|"row = %u, filter = %d"
argument_list|,
name|png_ptr
operator|->
name|row_number
argument_list|,
name|filter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|PNG_FILTER_VALUE_NONE
case|:
break|break;
case|case
name|PNG_FILTER_VALUE_SUB
case|:
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_size_t
name|istop
init|=
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|unsigned
name|int
name|bpp
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|png_bytep
name|rp
init|=
name|row
operator|+
name|bpp
decl_stmt|;
name|png_bytep
name|lp
init|=
name|row
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bpp
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|lp
operator|++
argument_list|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|PNG_FILTER_VALUE_UP
case|:
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_size_t
name|istop
init|=
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|rp
init|=
name|row
decl_stmt|;
name|png_const_bytep
name|pp
init|=
name|prev_row
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|PNG_FILTER_VALUE_AVG
case|:
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_bytep
name|rp
init|=
name|row
decl_stmt|;
name|png_const_bytep
name|pp
init|=
name|prev_row
decl_stmt|;
name|png_bytep
name|lp
init|=
name|row
decl_stmt|;
name|unsigned
name|int
name|bpp
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|png_size_t
name|istop
init|=
name|row_info
operator|->
name|rowbytes
operator|-
name|bpp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|/
literal|2
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|pp
operator|++
operator|+
operator|*
name|lp
operator|++
argument_list|)
operator|/
literal|2
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|PNG_FILTER_VALUE_PAETH
case|:
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_bytep
name|rp
init|=
name|row
decl_stmt|;
name|png_const_bytep
name|pp
init|=
name|prev_row
decl_stmt|;
name|png_bytep
name|lp
init|=
name|row
decl_stmt|;
name|png_const_bytep
name|cp
init|=
name|prev_row
decl_stmt|;
name|unsigned
name|int
name|bpp
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|png_size_t
name|istop
init|=
name|row_info
operator|->
name|rowbytes
operator|-
name|bpp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
comment|/* Use leftover rp,pp */
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|pc
decl_stmt|,
name|p
decl_stmt|;
name|a
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|b
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|p
operator|=
name|b
operator|-
name|c
expr_stmt|;
name|pc
operator|=
name|a
operator|-
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USE_ABS
name|pa
operator|=
name|abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|+
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|p
operator|<
literal|0
condition|?
operator|-
name|p
else|:
name|p
expr_stmt|;
name|pb
operator|=
name|pc
operator|<
literal|0
condition|?
operator|-
name|pc
else|:
name|pc
expr_stmt|;
name|pc
operator|=
operator|(
name|p
operator|+
name|pc
operator|)
operator|<
literal|0
condition|?
operator|-
operator|(
name|p
operator|+
name|pc
operator|)
else|:
name|p
operator|+
name|pc
expr_stmt|;
endif|#
directive|endif
comment|/*                if (pa<= pb&& pa<= pc)                   p = a;                 else if (pb<= pc)                   p = b;                 else                   p = c;              */
name|p
operator|=
operator|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
operator|)
condition|?
name|a
else|:
operator|(
name|pb
operator|<=
name|pc
operator|)
condition|?
name|b
else|:
name|c
expr_stmt|;
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
name|p
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring bad adaptive filter type"
argument_list|)
expr_stmt|;
comment|/*NOT REACHED */
break|break;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_finish_row
name|png_read_finish_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
name|PNG_CONST
name|int
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
name|PNG_CONST
name|int
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
name|PNG_CONST
name|int
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
name|PNG_CONST
name|int
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* PNG_READ_INTERLACING_SUPPORTED */
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_finish_row"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|row_number
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|<
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
name|png_ptr
operator|->
name|row_number
operator|=
literal|0
expr_stmt|;
name|png_memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>=
literal|7
condition|)
break|break;
name|png_ptr
operator|->
name|iwidth
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
block|}
else|else
comment|/* if (png_ptr->transformations& PNG_INTERLACE) */
break|break;
comment|/* libpng deinterlacing sees every row */
block|}
do|while
condition|(
name|png_ptr
operator|->
name|num_rows
operator|==
literal|0
operator|||
name|png_ptr
operator|->
name|iwidth
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|7
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* PNG_READ_INTERLACING_SUPPORTED */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_FINISHED
operator|)
condition|)
block|{
name|PNG_IDAT
expr_stmt|;
name|char
name|extra
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
operator|(
name|Byte
operator|*
operator|)
operator|&
name|extra
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|png_ptr
operator|->
name|idat_size
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|=
name|png_read_chunk_header
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_memcmp
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|,
name|png_IDAT
argument_list|,
literal|4
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough image data"
argument_list|)
expr_stmt|;
block|}
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zbuf_size
operator|>
name|png_ptr
operator|->
name|idat_size
condition|)
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|idat_size
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|-=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
expr_stmt|;
block|}
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
operator|||
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|||
name|png_ptr
operator|->
name|idat_size
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compressed data"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_FINISHED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
condition|?
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
else|:
literal|"Decompression Error"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compressed data"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZLIB_FINISHED
expr_stmt|;
break|break;
block|}
block|}
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|idat_size
operator|||
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compression data"
argument_list|)
expr_stmt|;
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SEQUENTIAL_READ_SUPPORTED */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_start_row
name|png_read_start_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
name|PNG_CONST
name|int
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
name|PNG_CONST
name|int
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
name|PNG_CONST
name|int
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
name|PNG_CONST
name|int
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
endif|#
directive|endif
name|int
name|max_pixel_depth
decl_stmt|;
name|png_size_t
name|row_bytes
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_start_row"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|png_init_read_transformations
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
literal|0
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
literal|0
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
literal|0
index|]
expr_stmt|;
else|else
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|iwidth
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* PNG_READ_INTERLACING_SUPPORTED */
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|iwidth
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
block|}
name|max_pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACK_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
operator|)
operator|&&
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|max_pixel_depth
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<
literal|8
condition|)
name|max_pixel_depth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
condition|)
name|max_pixel_depth
operator|*=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
condition|)
block|{
name|max_pixel_depth
operator|*=
literal|4
expr_stmt|;
name|max_pixel_depth
operator|/=
literal|3
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_FILLER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_FILLER
operator|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|8
condition|)
name|max_pixel_depth
operator|=
literal|16
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|32
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|64
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GRAY_TO_RGB
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
operator|(
name|png_ptr
operator|->
name|num_trans
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|)
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_FILLER_SUPPORTED
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_FILLER
operator|)
operator|)
operator|||
endif|#
directive|endif
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|16
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|max_pixel_depth
operator|=
literal|64
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|48
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_USER_TRANSFORM_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_USER_TRANSFORM_PTR_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_USER_TRANSFORM
condition|)
block|{
name|int
name|user_pixel_depth
init|=
name|png_ptr
operator|->
name|user_transform_depth
operator|*
name|png_ptr
operator|->
name|user_transform_channels
decl_stmt|;
if|if
condition|(
name|user_pixel_depth
operator|>
name|max_pixel_depth
condition|)
name|max_pixel_depth
operator|=
name|user_pixel_depth
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Align the width on the next larger 8 pixels.  Mainly used     * for interlacing     */
name|row_bytes
operator|=
operator|(
operator|(
name|png_ptr
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
operator|~
operator|(
operator|(
name|png_uint_32
operator|)
literal|7
operator|)
operator|)
expr_stmt|;
comment|/* Calculate the maximum bytes needed, adding a byte and a pixel     * for safety's sake     */
name|row_bytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|max_pixel_depth
argument_list|,
name|row_bytes
argument_list|)
operator|+
literal|1
operator|+
operator|(
operator|(
name|max_pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|row_bytes
operator|>
operator|(
name|png_uint_32
operator|)
literal|65536L
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"This image requires a row greater than 64KB"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|row_bytes
operator|+
literal|48
operator|>
name|png_ptr
operator|->
name|old_big_row_buf_size
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|big_row_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
name|png_ptr
operator|->
name|big_row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|row_bytes
operator|+
literal|48
argument_list|)
expr_stmt|;
else|else
name|png_ptr
operator|->
name|big_row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|row_bytes
operator|+
literal|48
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|old_big_row_buf_size
operator|=
name|row_bytes
operator|+
literal|48
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_ALIGNED_MEMORY_SUPPORTED
comment|/* Use 16-byte aligned memory for row_buf with at least 16 bytes       * of padding before and after row_buf.       */
name|png_ptr
operator|->
name|row_buf
operator|=
name|png_ptr
operator|->
name|big_row_buf
operator|+
literal|32
operator|-
operator|(
operator|(
operator|(
name|png_alloc_size_t
operator|)
name|png_ptr
operator|->
name|big_row_buf
operator|+
literal|15
operator|)
operator|&
literal|0x0F
operator|)
expr_stmt|;
name|png_ptr
operator|->
name|old_big_row_buf_size
operator|=
name|row_bytes
operator|+
literal|48
expr_stmt|;
else|#
directive|else
comment|/* Use 32 bytes of padding before and 16 bytes after row_buf. */
name|png_ptr
operator|->
name|row_buf
operator|=
name|png_ptr
operator|->
name|big_row_buf
operator|+
literal|32
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|old_big_row_buf_size
operator|=
name|row_bytes
operator|+
literal|48
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|png_ptr
operator|->
name|rowbytes
operator|>
literal|65535
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"This image requires a row greater than 64KB"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|->
name|rowbytes
operator|>
operator|(
name|PNG_SIZE_MAX
operator|-
literal|1
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Row has too many bytes to allocate in memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|>
name|png_ptr
operator|->
name|old_prev_row_size
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|prev_row
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|prev_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|old_prev_row_size
operator|=
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
expr_stmt|;
block|}
name|png_memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"width = %u,"
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"height = %u,"
argument_list|,
name|png_ptr
operator|->
name|height
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"iwidth = %u,"
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"num_rows = %u,"
argument_list|,
name|png_ptr
operator|->
name|num_rows
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"rowbytes = %lu,"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|rowbytes
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"irowbytes = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ROW_INIT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_SUPPORTED */
end_comment
end_unit
