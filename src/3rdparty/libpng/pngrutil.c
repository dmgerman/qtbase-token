begin_unit
begin_comment
comment|/* pngrutil.c - utilities to read a PNG file  *  * Last changed in libpng 1.6.20 [December 3, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  *  * This file contains routines that are only called from within  * libpng itself during the course of reading an image.  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_get_uint_31
name|png_get_uint_31
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|uval
operator|>
name|PNG_UINT_31_MAX
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG unsigned integer out of range"
argument_list|)
expr_stmt|;
return|return
operator|(
name|uval
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_gAMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_cHRM_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* The following is a variation on the above for use with the fixed  * point values used for gAMA and cHRM.  Instead of png_error it  * issues a warning and returns (-1) - an invalid value because both  * gAMA and cHRM use *unsigned* integers for fixed point values.  */
end_comment
begin_define
DECL|macro|PNG_FIXED_ERROR
define|#
directive|define
name|PNG_FIXED_ERROR
value|(-1)
end_define
begin_function
specifier|static
name|png_fixed_point
comment|/* PRIVATE */
DECL|function|png_get_fixed_point
name|png_get_fixed_point
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|uval
operator|<=
name|PNG_UINT_31_MAX
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|uval
return|;
comment|/* known to be in range */
comment|/* The caller can turn off the warning by passing NULL. */
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG fixed point integer out of range"
argument_list|)
expr_stmt|;
return|return
name|PNG_FIXED_ERROR
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_INT_FUNCTIONS_SUPPORTED
end_ifdef
begin_comment
comment|/* NOTE: the read macros will obscure these definitions, so that if  * PNG_USE_READ_MACROS is set the library will not use them internally,  * but the APIs will still be available externally.  *  * The parentheses around "PNGAPI function_name" in the following three  * functions are necessary because they allow the macros to co-exist with  * these (unused but exported) functions.  */
end_comment
begin_comment
comment|/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
end_comment
begin_function
name|png_uint_32
function|(
name|PNGAPI
DECL|function|png_get_uint_32
name|png_get_uint_32
function|)
parameter_list|(
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|)
argument_list|)
operator|<<
literal|24
operator|)
operator|+
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
argument_list|)
operator|<<
literal|16
operator|)
operator|+
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|2
operator|)
argument_list|)
operator|<<
literal|8
operator|)
operator|+
operator|(
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|3
operator|)
argument_list|)
operator|)
decl_stmt|;
return|return
name|uval
return|;
block|}
end_function
begin_comment
comment|/* Grab a signed 32-bit integer from a buffer in big-endian format.  The  * data is stored in the PNG file in two's complement format and there  * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore  * the following code does a two's complement to native conversion.  */
end_comment
begin_function
name|png_int_32
function|(
name|PNGAPI
DECL|function|png_get_int_32
name|png_get_int_32
function|)
parameter_list|(
name|png_const_bytep
name|buf
parameter_list|)
block|{
name|png_uint_32
name|uval
init|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|uval
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
comment|/* non-negative */
return|return
name|uval
return|;
name|uval
operator|=
operator|(
name|uval
operator|^
literal|0xffffffff
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 2's complement: -x = ~x+1 */
if|if
condition|(
operator|(
name|uval
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
comment|/* no overflow */
return|return
operator|-
operator|(
name|png_int_32
operator|)
name|uval
return|;
comment|/* The following has to be safe; this function only gets called on PNG data     * and if we get here that data is invalid.  0 is the most safe value and     * if not then an attacker would surely just generate a PNG with 0 instead.     */
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
end_comment
begin_function
name|png_uint_16
function|(
name|PNGAPI
DECL|function|png_get_uint_16
name|png_get_uint_16
function|)
parameter_list|(
name|png_const_bytep
name|buf
parameter_list|)
block|{
comment|/* ANSI-C requires an int value to accomodate at least 16 bits so this     * works and allows the compiler not to worry about possible narrowing     * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller     * than 16 bits either.)     */
name|unsigned
name|int
name|val
init|=
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|buf
argument_list|)
operator|<<
literal|8
operator|)
operator|+
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|png_uint_16
operator|)
name|val
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_INT_FUNCTIONS */
end_comment
begin_comment
comment|/* Read and check the PNG file signature */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_sig
name|png_read_sig
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
name|png_size_t
name|num_checked
decl_stmt|,
name|num_to_check
decl_stmt|;
comment|/* Exit if the user application does not expect a signature. */
if|if
condition|(
name|png_ptr
operator|->
name|sig_bytes
operator|>=
literal|8
condition|)
return|return;
name|num_checked
operator|=
name|png_ptr
operator|->
name|sig_bytes
expr_stmt|;
name|num_to_check
operator|=
literal|8
operator|-
name|num_checked
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_SIGNATURE
expr_stmt|;
endif|#
directive|endif
comment|/* The signature must be serialized in a single I/O call. */
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
operator|&
operator|(
name|info_ptr
operator|->
name|signature
index|[
name|num_checked
index|]
operator|)
argument_list|,
name|num_to_check
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sig_bytes
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|num_checked
operator|<
literal|4
operator|&&
name|png_sig_cmp
argument_list|(
name|info_ptr
operator|->
name|signature
argument_list|,
name|num_checked
argument_list|,
name|num_to_check
operator|-
literal|4
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not a PNG file"
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"PNG file corrupted by ASCII conversion"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_checked
operator|<
literal|3
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PNG_SIGNATURE
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Read the chunk header (length + type name).  * Put the type name into png_ptr->chunk_name, and return the length.  */
end_comment
begin_function
name|png_uint_32
comment|/* PRIVATE */
DECL|function|png_read_chunk_header
name|png_read_chunk_header
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|png_uint_32
name|length
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_CHUNK_HDR
expr_stmt|;
endif|#
directive|endif
comment|/* Read the length and the chunk name.     * This must be performed in a single I/O call.     */
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|length
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Put the chunk name into png_ptr->chunk_name. */
name|png_ptr
operator|->
name|chunk_name
operator|=
name|PNG_CHUNK_FROM_STRING
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|png_debug2
argument_list|(
literal|0
argument_list|,
literal|"Reading %lx chunk, length = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|chunk_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
comment|/* Reset the crc and run it over the chunk name. */
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|buf
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Check to see if chunk name is valid. */
name|png_check_chunk_name
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_CHUNK_DATA
expr_stmt|;
endif|#
directive|endif
return|return
name|length
return|;
block|}
end_function
begin_comment
comment|/* Read data, and (optionally) run it through the CRC. */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_crc_read
name|png_crc_read
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|buf
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Optionally skip data and then check the CRC.  Depending on whether we  * are reading an ancillary or critical chunk, and how the program has set  * things up, we may calculate the CRC on the data and print a message.  * Returns '1' if there was a CRC error, '0' otherwise.  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_crc_finish
name|png_crc_finish
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|skip
parameter_list|)
block|{
comment|/* The size of the local buffer for inflate is a good guess as to a     * reasonable size to use for buffering reads from the application.     */
while|while
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
name|png_uint_32
name|len
decl_stmt|;
name|png_byte
name|tmpbuf
index|[
name|PNG_INFLATE_BUF_SIZE
index|]
decl_stmt|;
name|len
operator|=
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|skip
condition|)
name|len
operator|=
name|skip
expr_stmt|;
name|skip
operator|-=
name|len
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|tmpbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_crc_error
argument_list|(
name|png_ptr
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|PNG_CHUNK_ANCILLARY
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|!=
literal|0
condition|?
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
operator|==
literal|0
else|:
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_CRITICAL_USE
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
block|}
else|else
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/* Compare the CRC stored in the PNG file with that calculated by libpng from  * the data it has read thus far.  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_crc_error
name|png_crc_error
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|crc_bytes
index|[
literal|4
index|]
decl_stmt|;
name|png_uint_32
name|crc
decl_stmt|;
name|int
name|need_crc
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|PNG_CHUNK_ANCILLARY
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_MASK
operator|)
operator|==
operator|(
name|PNG_FLAG_CRC_ANCILLARY_USE
operator||
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* critical */
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_CRITICAL_IGNORE
operator|)
operator|!=
literal|0
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_READING
operator||
name|PNG_IO_CHUNK_CRC
expr_stmt|;
endif|#
directive|endif
comment|/* The chunk CRC must be serialized in a single I/O call. */
name|png_read_data
argument_list|(
name|png_ptr
argument_list|,
name|crc_bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_crc
operator|!=
literal|0
condition|)
block|{
name|crc
operator|=
name|png_get_uint_32
argument_list|(
name|crc_bytes
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|crc
operator|!=
name|png_ptr
operator|->
name|crc
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_iCCP_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_iTXt_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_pCAL_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_sCAL_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_sPLT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_tEXt_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_zTXt_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_SEQUENTIAL_READ_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Manage the read buffer; this simply reallocates the buffer if it is not small  * enough (or if it is not allocated).  The routine returns a pointer to the  * buffer; if an error occurs and 'warn' is set the routine returns NULL, else  * it will call png_error (via png_malloc) on failure.  (warn == 2 means  * 'silent').  */
end_comment
begin_function
specifier|static
name|png_bytep
DECL|function|png_read_buffer
name|png_read_buffer
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_alloc_size_t
name|new_size
parameter_list|,
name|int
name|warn
parameter_list|)
block|{
name|png_bytep
name|buffer
init|=
name|png_ptr
operator|->
name|read_buffer
decl_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
operator|&&
name|new_size
operator|>
name|png_ptr
operator|->
name|read_buffer_size
condition|)
block|{
name|png_ptr
operator|->
name|read_buffer
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|read_buffer
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|read_buffer_size
operator|=
literal|0
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|buffer
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
name|new_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|read_buffer
operator|=
name|buffer
expr_stmt|;
name|png_ptr
operator|->
name|read_buffer_size
operator|=
name|new_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn
operator|<
literal|2
condition|)
comment|/* else silent */
block|{
if|if
condition|(
name|warn
operator|!=
literal|0
condition|)
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"insufficient memory to read chunk"
argument_list|)
expr_stmt|;
else|else
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"insufficient memory to read chunk"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buffer
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */
end_comment
begin_comment
comment|/* png_inflate_claim: claim the zstream for some nefarious purpose that involves  * decompression.  Returns Z_OK on success, else a zlib error code.  It checks  * the owner but, in final release builds, just issues a warning if some other  * chunk apparently owns the stream.  Prior to release it does a png_error.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_inflate_claim
name|png_inflate_claim
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|owner
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|!=
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
name|PNG_STRING_FROM_CHUNK
argument_list|(
name|msg
argument_list|,
name|png_ptr
operator|->
name|zowner
argument_list|)
expr_stmt|;
comment|/* So the message that results is "<chunk> using zstream"; this is an        * internal error, but is very useful for debugging.  i18n requirements        * are minimal.        */
operator|(
name|void
operator|)
name|png_safecat
argument_list|(
name|msg
argument_list|,
operator|(
sizeof|sizeof
name|msg
operator|)
argument_list|,
literal|4
argument_list|,
literal|" using zstream"
argument_list|)
expr_stmt|;
if|#
directive|if
name|PNG_RELEASE_BUILD
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Implementation note: unlike 'png_deflate_claim' this internal function     * does not take the size of the data as an argument.  Some efficiency could     * be gained by using this when it is known *if* the zlib stream itself does     * not record the number; however, this is an illusion: the original writer     * of the PNG may have selected a lower window size, and we really must     * follow that because, for systems with with limited capabilities, we     * would otherwise reject the application's attempts to use a smaller window     * size (zlib doesn't have an interface to say "this or lower"!).     *     * inflateReset2 was added to zlib 1.2.4; before this the window could not be     * reset, therefore it is necessary to always allocate the maximum window     * size with earlier zlibs just in case later compressed chunks need it.     */
block|{
name|int
name|ret
decl_stmt|;
comment|/* zlib return code */
if|#
directive|if
name|PNG_ZLIB_VERNUM
operator|>=
literal|0x1240
if|#
directive|if
name|defined
argument_list|(
name|PNG_SET_OPTION_SUPPORTED
argument_list|)
operator|&&
name|defined
argument_list|(
name|PNG_MAXIMUM_INFLATE_WINDOW
argument_list|)
name|int
name|window_bits
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|png_ptr
operator|->
name|options
operator|>>
name|PNG_MAXIMUM_INFLATE_WINDOW
operator|)
operator|&
literal|3
operator|)
operator|==
name|PNG_OPTION_ON
condition|)
block|{
name|window_bits
operator|=
literal|15
expr_stmt|;
name|png_ptr
operator|->
name|zstream_start
operator|=
literal|0
expr_stmt|;
comment|/* fixed window size */
block|}
else|else
block|{
name|window_bits
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|zstream_start
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
define|#
directive|define
name|window_bits
value|0
endif|#
directive|endif
endif|#
directive|endif
comment|/* Set this for safety, just in case the previous owner left pointers to        * memory allocations.        */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_INITIALIZED
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|PNG_ZLIB_VERNUM
operator|<
literal|0x1240
name|ret
operator|=
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|inflateReset2
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|window_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|PNG_ZLIB_VERNUM
operator|<
literal|0x1240
name|ret
operator|=
name|inflateInit
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|window_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZSTREAM_INITIALIZED
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
name|png_ptr
operator|->
name|zowner
operator|=
name|owner
expr_stmt|;
else|else
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
ifdef|#
directive|ifdef
name|window_bits
DECL|macro|window_bits
undef|#
directive|undef
name|window_bits
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|PNG_ZLIB_VERNUM
operator|>=
literal|0x1240
end_if
begin_comment
comment|/* Handle the start of the inflate stream if we called inflateInit2(strm,0);  * in this case some zlib versions skip validation of the CINFO field and, in  * certain circumstances, libpng may end up displaying an invalid image, in  * contrast to implementations that call zlib in the normal way (e.g. libpng  * 1.5).  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_zlib_inflate
name|png_zlib_inflate
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zstream_start
operator|&&
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|>>
literal|4
operator|)
operator|>
literal|7
condition|)
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
literal|"invalid window size (libpng)"
expr_stmt|;
return|return
name|Z_DATA_ERROR
return|;
block|}
name|png_ptr
operator|->
name|zstream_start
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|inflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|flush
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Zlib>= 1.2.4 */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_COMPRESSED_TEXT_SUPPORTED
end_ifdef
begin_comment
comment|/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to  * allow the caller to do multiple calls if required.  If the 'finish' flag is  * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must  * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and  * Z_OK or Z_STREAM_END will be returned on success.  *  * The input and output sizes are updated to the actual amounts of data consumed  * or written, not the amount available (as in a z_stream).  The data pointers  * are not changed, so the next input is (data+input_size) and the next  * available output is (output+output_size).  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_inflate
name|png_inflate
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|owner
parameter_list|,
name|int
name|finish
parameter_list|,
comment|/* INPUT: */
name|png_const_bytep
name|input
parameter_list|,
name|png_uint_32p
name|input_size_ptr
parameter_list|,
comment|/* OUTPUT: */
name|png_bytep
name|output
parameter_list|,
name|png_alloc_size_t
modifier|*
name|output_size_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|==
name|owner
condition|)
comment|/* Else not claimed */
block|{
name|int
name|ret
decl_stmt|;
name|png_alloc_size_t
name|avail_out
init|=
operator|*
name|output_size_ptr
decl_stmt|;
name|png_uint_32
name|avail_in
init|=
operator|*
name|input_size_ptr
decl_stmt|;
comment|/* zlib can't necessarily handle more than 65535 bytes at once (i.e. it        * can't even necessarily handle 65536 bytes) because the type uInt is        * "16 bits or more".  Consequently it is necessary to chunk the input to        * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the        * maximum value that can be stored in a uInt.)  It is possible to set        * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have        * a performance advantage, because it reduces the amount of data accessed        * at each step and that may give the OS more time to page it in.        */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|PNGZ_INPUT_CAST
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|/* avail_in and avail_out are set below from 'size' */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
comment|/* Read directly into the output if it is available (this is set to        * a local buffer below if output is NULL).        */
if|if
condition|(
name|output
operator|!=
name|NULL
condition|)
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|output
expr_stmt|;
do|do
block|{
name|uInt
name|avail
decl_stmt|;
name|Byte
name|local_buffer
index|[
name|PNG_INFLATE_BUF_SIZE
index|]
decl_stmt|;
comment|/* zlib INPUT BUFFER */
comment|/* The setting of 'avail_in' used to be outside the loop; by setting it           * inside it is possible to chunk the input to zlib and simply rely on           * zlib to advance the 'next_in' pointer.  This allows arbitrary           * amounts of data to be passed through zlib at the unavoidable cost of           * requiring a window save (memcpy of up to 32768 output bytes)           * every ZLIB_IO_MAX input bytes.           */
name|avail_in
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
expr_stmt|;
comment|/* not consumed last time */
name|avail
operator|=
name|ZLIB_IO_MAX
expr_stmt|;
if|if
condition|(
name|avail_in
operator|<
name|avail
condition|)
name|avail
operator|=
operator|(
name|uInt
operator|)
name|avail_in
expr_stmt|;
comment|/* safe:< than ZLIB_IO_MAX */
name|avail_in
operator|-=
name|avail
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|avail
expr_stmt|;
comment|/* zlib OUTPUT BUFFER */
name|avail_out
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
comment|/* not written last time */
name|avail
operator|=
name|ZLIB_IO_MAX
expr_stmt|;
comment|/* maximum zlib can process */
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
comment|/* Reset the output buffer each time round if output is NULL and              * make available the full buffer, up to 'remaining_space'              */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|local_buffer
expr_stmt|;
if|if
condition|(
operator|(
sizeof|sizeof
name|local_buffer
operator|)
operator|<
name|avail
condition|)
name|avail
operator|=
operator|(
sizeof|sizeof
name|local_buffer
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|avail_out
operator|<
name|avail
condition|)
name|avail
operator|=
operator|(
name|uInt
operator|)
name|avail_out
expr_stmt|;
comment|/* safe:< ZLIB_IO_MAX */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|avail
expr_stmt|;
name|avail_out
operator|-=
name|avail
expr_stmt|;
comment|/* zlib inflate call */
comment|/* In fact 'avail_out' may be 0 at this point, that happens at the end           * of the read when the final LZ end code was not passed at the end of           * the previous chunk of input data.  Tell zlib if we have reached the           * end of the output buffer.           */
name|ret
operator|=
name|PNG_INFLATE
argument_list|(
name|png_ptr
argument_list|,
name|avail_out
operator|>
literal|0
condition|?
name|Z_NO_FLUSH
else|:
operator|(
name|finish
condition|?
name|Z_FINISH
else|:
name|Z_SYNC_FLUSH
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|Z_OK
condition|)
do|;
comment|/* For safety kill the local buffer pointer now */
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
comment|/* Claw back the 'size' and 'remaining_space' byte counts. */
name|avail_in
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
expr_stmt|;
name|avail_out
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
comment|/* Update the input and output sizes; the updated values are the amount        * consumed or written, effectively the inverse of what zlib uses.        */
if|if
condition|(
name|avail_out
operator|>
literal|0
condition|)
operator|*
name|output_size_ptr
operator|-=
name|avail_out
expr_stmt|;
if|if
condition|(
name|avail_in
operator|>
literal|0
condition|)
operator|*
name|input_size_ptr
operator|-=
name|avail_in
expr_stmt|;
comment|/* Ensure png_ptr->zstream.msg is set (even in the success case!) */
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
comment|/* This is a bad internal error.  The recovery assigns to the zstream msg        * pointer, which is not owned by the caller, but this is safe; it's only        * used on errors!        */
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"zstream unclaimed"
argument_list|)
expr_stmt|;
return|return
name|Z_STREAM_ERROR
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Decompress trailing data in a chunk.  The assumption is that read_buffer  * points at an allocated area holding the contents of a chunk with a  * trailing compressed part.  What we get back is an allocated area  * holding the original prefix part and an uncompressed version of the  * trailing part (the malloc area passed in is freed).  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_decompress_chunk
name|png_decompress_chunk
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunklength
parameter_list|,
name|png_uint_32
name|prefix_size
parameter_list|,
name|png_alloc_size_t
modifier|*
name|newlength
comment|/* must be initialized to the maximum! */
parameter_list|,
name|int
name|terminate
comment|/*add a '\0' to the end of the uncompressed data*/
parameter_list|)
block|{
comment|/* TODO: implement different limits for different types of chunk.     *     * The caller supplies *newlength set to the maximum length of the     * uncompressed data, but this routine allocates space for the prefix and     * maybe a '\0' terminator too.  We have to assume that 'prefix_size' is     * limited only by the maximum chunk size.     */
name|png_alloc_size_t
name|limit
init|=
name|PNG_SIZE_MAX
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|>
literal|0
operator|&&
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|<
name|limit
condition|)
name|limit
operator|=
name|png_ptr
operator|->
name|user_chunk_malloc_max
expr_stmt|;
elif|#
directive|elif
name|PNG_USER_CHUNK_MALLOC_MAX
operator|>
literal|0
if|if
condition|(
name|PNG_USER_CHUNK_MALLOC_MAX
operator|<
name|limit
condition|)
name|limit
operator|=
name|PNG_USER_CHUNK_MALLOC_MAX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|limit
operator|>=
name|prefix_size
operator|+
operator|(
name|terminate
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|limit
operator|-=
name|prefix_size
operator|+
operator|(
name|terminate
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|limit
operator|<
operator|*
name|newlength
condition|)
operator|*
name|newlength
operator|=
name|limit
expr_stmt|;
comment|/* Now try to claim the stream. */
name|ret
operator|=
name|png_inflate_claim
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
block|{
name|png_uint_32
name|lzsize
init|=
name|chunklength
operator|-
name|prefix_size
decl_stmt|;
name|ret
operator|=
name|png_inflate
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|,
literal|1
comment|/*finish*/
argument_list|,
comment|/* input: */
name|png_ptr
operator|->
name|read_buffer
operator|+
name|prefix_size
argument_list|,
operator|&
name|lzsize
argument_list|,
comment|/* output: */
name|NULL
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
comment|/* Use 'inflateReset' here, not 'inflateReset2' because this              * preserves the previously decided window size (otherwise it would              * be necessary to store the previous window size.)  In practice              * this doesn't matter anyway, because png_inflate will call inflate              * with Z_FINISH in almost all cases, so the window will not be              * maintained.              */
if|if
condition|(
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
operator|==
name|Z_OK
condition|)
block|{
comment|/* Because of the limit checks above we know that the new,                 * expanded, size will fit in a size_t (let alone an                 * png_alloc_size_t).  Use png_malloc_base here to avoid an                 * extra OOM message.                 */
name|png_alloc_size_t
name|new_size
init|=
operator|*
name|newlength
decl_stmt|;
name|png_alloc_size_t
name|buffer_size
init|=
name|prefix_size
operator|+
name|new_size
operator|+
operator|(
name|terminate
operator|!=
literal|0
operator|)
decl_stmt|;
name|png_bytep
name|text
init|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
name|buffer_size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|png_inflate
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|,
literal|1
comment|/*finish*/
argument_list|,
name|png_ptr
operator|->
name|read_buffer
operator|+
name|prefix_size
argument_list|,
operator|&
name|lzsize
argument_list|,
name|text
operator|+
name|prefix_size
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
if|if
condition|(
name|new_size
operator|==
operator|*
name|newlength
condition|)
block|{
if|if
condition|(
name|terminate
operator|!=
literal|0
condition|)
name|text
index|[
name|prefix_size
operator|+
operator|*
name|newlength
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prefix_size
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|text
argument_list|,
name|png_ptr
operator|->
name|read_buffer
argument_list|,
name|prefix_size
argument_list|)
expr_stmt|;
block|{
name|png_bytep
name|old_ptr
init|=
name|png_ptr
operator|->
name|read_buffer
decl_stmt|;
name|png_ptr
operator|->
name|read_buffer
operator|=
name|text
expr_stmt|;
name|png_ptr
operator|->
name|read_buffer_size
operator|=
name|buffer_size
expr_stmt|;
name|text
operator|=
name|old_ptr
expr_stmt|;
comment|/* freed below */
block|}
block|}
else|else
block|{
comment|/* The size changed on the second read, there can be no                          * guarantee that anything is correct at this point.                          * The 'msg' pointer has been set to "unexpected end of                          * LZ stream", which is fine, but return an error code                          * that the caller won't accept.                          */
name|ret
operator|=
name|PNG_UNEXPECTED_ZLIB_RETURN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
name|ret
operator|=
name|PNG_UNEXPECTED_ZLIB_RETURN
expr_stmt|;
comment|/* for safety */
comment|/* Free the text pointer (this is the old read_buffer on                    * success)                    */
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
comment|/* This really is very benign, but it's still an error because                    * the extra space may otherwise be used as a Trojan Horse.                    */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
operator|&&
name|chunklength
operator|-
name|prefix_size
operator|!=
name|lzsize
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"extra compressed data"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Out of memory allocating the buffer */
name|ret
operator|=
name|Z_MEM_ERROR
expr_stmt|;
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* inflateReset failed, store the error message */
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
name|ret
operator|=
name|PNG_UNEXPECTED_ZLIB_RETURN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
name|ret
operator|=
name|PNG_UNEXPECTED_ZLIB_RETURN
expr_stmt|;
comment|/* Release the claimed stream */
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
comment|/* the claim failed */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
comment|/* impossible! */
name|ret
operator|=
name|PNG_UNEXPECTED_ZLIB_RETURN
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
comment|/* Application/configuration limits exceeded */
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_COMPRESSED_TEXT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
end_ifdef
begin_comment
comment|/* Perform a partial read and decompress, producing 'avail_out' bytes and  * reading from the current chunk as required.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_inflate_read
name|png_inflate_read
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|read_buffer
parameter_list|,
name|uInt
name|read_size
parameter_list|,
name|png_uint_32p
name|chunk_bytes
parameter_list|,
name|png_bytep
name|next_out
parameter_list|,
name|png_alloc_size_t
modifier|*
name|out_size
parameter_list|,
name|int
name|finish
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|==
name|png_ptr
operator|->
name|chunk_name
condition|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* next_in and avail_in must have been initialized by the caller. */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|next_out
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
comment|/* set in the loop */
do|do
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|read_size
operator|>
operator|*
name|chunk_bytes
condition|)
name|read_size
operator|=
operator|(
name|uInt
operator|)
operator|*
name|chunk_bytes
expr_stmt|;
operator|*
name|chunk_bytes
operator|-=
name|read_size
expr_stmt|;
if|if
condition|(
name|read_size
operator|>
literal|0
condition|)
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|read_buffer
argument_list|,
name|read_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|read_buffer
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|read_size
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|uInt
name|avail
init|=
name|ZLIB_IO_MAX
decl_stmt|;
if|if
condition|(
name|avail
operator|>
operator|*
name|out_size
condition|)
name|avail
operator|=
operator|(
name|uInt
operator|)
operator|*
name|out_size
expr_stmt|;
operator|*
name|out_size
operator|-=
name|avail
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|avail
expr_stmt|;
block|}
comment|/* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all           * the available output is produced; this allows reading of truncated           * streams.           */
name|ret
operator|=
name|PNG_INFLATE
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|chunk_bytes
operator|>
literal|0
condition|?
name|Z_NO_FLUSH
else|:
operator|(
name|finish
condition|?
name|Z_FINISH
else|:
name|Z_SYNC_FLUSH
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|Z_OK
operator|&&
operator|(
operator|*
name|out_size
operator|>
literal|0
operator|||
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|>
literal|0
operator|)
condition|)
do|;
operator|*
name|out_size
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
comment|/* Should not be required, but is safe */
comment|/* Ensure the error message pointer is always set: */
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"zstream unclaimed"
argument_list|)
expr_stmt|;
return|return
name|Z_STREAM_ERROR
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Read and check the IDHR chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_IHDR
name|png_handle_IHDR
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|13
index|]
decl_stmt|;
name|png_uint_32
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|bit_depth
decl_stmt|,
name|color_type
decl_stmt|,
name|compression_type
decl_stmt|,
name|filter_type
decl_stmt|;
name|int
name|interlace_type
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_IHDR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|!=
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
comment|/* Check the length */
if|if
condition|(
name|length
operator|!=
literal|13
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IHDR
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|width
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|height
operator|=
name|png_get_uint_31
argument_list|(
name|png_ptr
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bit_depth
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|color_type
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|compression_type
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
name|filter_type
operator|=
name|buf
index|[
literal|11
index|]
expr_stmt|;
name|interlace_type
operator|=
name|buf
index|[
literal|12
index|]
expr_stmt|;
comment|/* Set internal variables */
name|png_ptr
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|png_ptr
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|png_ptr
operator|->
name|bit_depth
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|interlaced
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
name|png_ptr
operator|->
name|color_type
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
name|png_ptr
operator|->
name|filter_type
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|compression_type
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
comment|/* Find number of channels */
switch|switch
condition|(
name|png_ptr
operator|->
name|color_type
condition|)
block|{
default|default:
comment|/* invalid, png_set_IHDR calls png_error */
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Set up other useful info */
name|png_ptr
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|png_ptr
operator|->
name|bit_depth
operator|*
name|png_ptr
operator|->
name|channels
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"bit_depth = %d"
argument_list|,
name|png_ptr
operator|->
name|bit_depth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"channels = %d"
argument_list|,
name|png_ptr
operator|->
name|channels
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"rowbytes = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|rowbytes
argument_list|)
expr_stmt|;
name|png_set_IHDR
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bit_depth
argument_list|,
name|color_type
argument_list|,
name|interlace_type
argument_list|,
name|compression_type
argument_list|,
name|filter_type
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Read and check the palette */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_PLTE
name|png_handle_PLTE
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_color
name|palette
index|[
name|PNG_MAX_PALETTE_LENGTH
index|]
decl_stmt|;
name|int
name|max_palette_length
decl_stmt|,
name|num
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
name|png_colorp
name|pal_ptr
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
comment|/* Moved to before the 'after IDAT' check below because otherwise duplicate     * PLTE chunks are potentially ignored (the spec says there shall not be more     * than one PLTE, the error is not treated as benign, so this check trumps     * the requirement that PLTE appears before IDAT.)     */
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|!=
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This is benign because the non-benign error happened before, when an        * IDAT was encountered in a color-mapped image with no PLTE.        */
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ignored in grayscale PNG"
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|PNG_READ_OPT_PLTE_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|length
operator|>
literal|3
operator|*
name|PNG_MAX_PALETTE_LENGTH
operator|||
name|length
operator|%
literal|3
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|!=
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
else|else
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */
name|num
operator|=
operator|(
name|int
operator|)
name|length
operator|/
literal|3
expr_stmt|;
comment|/* If the palette has 256 or fewer entries but is too large for the bit     * depth, we don't issue an error, to preserve the behavior of previous     * libpng versions. We silently truncate the unused extra palette entries     * here.     */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|max_palette_length
operator|=
operator|(
literal|1
operator|<<
name|png_ptr
operator|->
name|bit_depth
operator|)
expr_stmt|;
else|else
name|max_palette_length
operator|=
name|PNG_MAX_PALETTE_LENGTH
expr_stmt|;
if|if
condition|(
name|num
operator|>
name|max_palette_length
condition|)
name|num
operator|=
name|max_palette_length
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pal_ptr
operator|=
name|palette
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|pal_ptr
operator|++
control|)
block|{
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pal_ptr
operator|->
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|pal_ptr
operator|->
name|green
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|pal_ptr
operator|->
name|blue
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Don't depend upon png_color being any order */
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we actually need the PLTE chunk (ie for a paletted image), we do     * whatever the normal CRC configuration tells us.  However, if we     * have an RGB image, the PLTE can be considered ancillary, so     * we will act as though it is.     */
ifndef|#
directive|ifndef
name|PNG_READ_OPT_PLTE_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
endif|#
directive|endif
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|int
operator|)
name|length
operator|-
name|num
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PNG_READ_OPT_PLTE_SUPPORTED
elseif|else
if|if
condition|(
name|png_crc_error
argument_list|(
name|png_ptr
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Only if we have a CRC error */
block|{
comment|/* If we don't want to use the data from an ancillary chunk,        * we have two options: an error abort, or a warning and we        * ignore the data in this chunk (which should be OK, since        * it's considered ancillary for a RGB or RGBA image).        *        * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the        * chunk type to determine whether to check the ancillary or the critical        * flags.        */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_USE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
operator|!=
literal|0
condition|)
return|return;
else|else
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we (optionally) emit a warning and use the chunk. */
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
operator|==
literal|0
condition|)
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"CRC error"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its     * own copy of the palette.  This has the side effect that when png_start_row     * is called (this happens after any call to png_read_update_info) the     * info_ptr palette gets changed.  This is extremely unexpected and     * confusing.     *     * Fix this by not sharing the palette in this way.     */
name|png_set_PLTE
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|palette
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before     * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely     * checked the apparent validity of a tRNS chunk inserted before PLTE on a     * palette PNG.  1.6.0 attempts to rigorously follow the standard and     * therefore does a benign error if the erroneous condition is detected *and*     * cancels the tRNS if the benign error returns.  The alternative is to     * amend the standard since it would be rather hypocritical of the standards     * maintainers to ignore it.     */
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|>
literal|0
operator|||
operator|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Cancel this because otherwise it would be used if the transforms        * require it.  Don't cancel the 'valid' flag because this would prevent        * detection of duplicate chunks.        */
name|png_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
name|info_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"tRNS must be after"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_hIST
operator|)
operator|!=
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"hIST must be after"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_bKGD
operator|)
operator|!=
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bKGD must be after"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_IEND
name|png_handle_IEND
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_IEND"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
operator|(
name|PNG_AFTER_IDAT
operator||
name|PNG_HAVE_IEND
operator|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_gAMA
name|png_handle_gAMA
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_fixed_point
name|igamma
decl_stmt|;
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_gAMA"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
operator|(
name|PNG_HAVE_IDAT
operator||
name|PNG_HAVE_PLTE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|4
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|igamma
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|png_colorspace_set_gamma
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|colorspace
argument_list|,
name|igamma
argument_list|)
expr_stmt|;
name|png_colorspace_sync
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sBIT_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sBIT
name|png_handle_sBIT
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|unsigned
name|int
name|truelen
decl_stmt|,
name|i
decl_stmt|;
name|png_byte
name|sample_depth
decl_stmt|;
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sBIT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
operator|(
name|PNG_HAVE_IDAT
operator||
name|PNG_HAVE_PLTE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sBIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|truelen
operator|=
literal|3
expr_stmt|;
name|sample_depth
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|truelen
operator|=
name|png_ptr
operator|->
name|channels
expr_stmt|;
name|sample_depth
operator|=
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
name|truelen
operator|||
name|length
operator|>
literal|4
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|3
index|]
operator|=
name|sample_depth
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|truelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|truelen
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|buf
index|[
name|i
index|]
operator|>
name|sample_depth
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|alpha
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|sig_bit
operator|.
name|gray
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|sig_bit
operator|.
name|alpha
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
block|}
name|png_set_sBIT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|sig_bit
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_cHRM_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_cHRM
name|png_handle_cHRM
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|png_xy
name|xy
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_cHRM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
operator|(
name|PNG_HAVE_IDAT
operator||
name|PNG_HAVE_PLTE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|32
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|xy
operator|.
name|whitex
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|xy
operator|.
name|whitey
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|xy
operator|.
name|redx
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|8
argument_list|)
expr_stmt|;
name|xy
operator|.
name|redy
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|12
argument_list|)
expr_stmt|;
name|xy
operator|.
name|greenx
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|16
argument_list|)
expr_stmt|;
name|xy
operator|.
name|greeny
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|20
argument_list|)
expr_stmt|;
name|xy
operator|.
name|bluex
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|24
argument_list|)
expr_stmt|;
name|xy
operator|.
name|bluey
operator|=
name|png_get_fixed_point
argument_list|(
name|NULL
argument_list|,
name|buf
operator|+
literal|28
argument_list|)
expr_stmt|;
if|if
condition|(
name|xy
operator|.
name|whitex
operator|==
name|PNG_FIXED_ERROR
operator|||
name|xy
operator|.
name|whitey
operator|==
name|PNG_FIXED_ERROR
operator|||
name|xy
operator|.
name|redx
operator|==
name|PNG_FIXED_ERROR
operator|||
name|xy
operator|.
name|redy
operator|==
name|PNG_FIXED_ERROR
operator|||
name|xy
operator|.
name|greenx
operator|==
name|PNG_FIXED_ERROR
operator|||
name|xy
operator|.
name|greeny
operator|==
name|PNG_FIXED_ERROR
operator|||
name|xy
operator|.
name|bluex
operator|==
name|PNG_FIXED_ERROR
operator|||
name|xy
operator|.
name|bluey
operator|==
name|PNG_FIXED_ERROR
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid values"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If a colorspace error has already been output skip this chunk */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_FROM_cHRM
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_colorspace_sync
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_FROM_cHRM
expr_stmt|;
operator|(
name|void
operator|)
name|png_colorspace_set_chromaticities
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|colorspace
argument_list|,
operator|&
name|xy
argument_list|,
literal|1
comment|/*prefer cHRM values*/
argument_list|)
expr_stmt|;
name|png_colorspace_sync
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sRGB_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sRGB
name|png_handle_sRGB
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|intent
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sRGB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
operator|(
name|PNG_HAVE_IDAT
operator||
name|PNG_HAVE_PLTE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|intent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* If a colorspace error has already been output skip this chunk */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect     * this.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_INTENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_colorspace_sync
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"too many profiles"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|png_colorspace_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|colorspace
argument_list|,
name|intent
argument_list|)
expr_stmt|;
name|png_colorspace_sync
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_sRGB */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_iCCP_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_iCCP
name|png_handle_iCCP
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
comment|/* Note: this does not properly handle profiles that are> 64K under DOS */
block|{
name|png_const_charp
name|errmsg
init|=
name|NULL
decl_stmt|;
comment|/* error message output, or no error */
name|int
name|finished
init|=
literal|0
decl_stmt|;
comment|/* crc checked */
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_iCCP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
operator|(
name|PNG_HAVE_IDAT
operator||
name|PNG_HAVE_PLTE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Consistent with all the above colorspace handling an obviously *invalid*     * chunk is just ignored, so does not invalidate the color space.  An     * alternative is to set the 'invalid' flags at the start of this routine     * and only clear them in they were not set before and all the tests pass.     * The minimum 'deflate' stream is assumed to be just the 2 byte header and     * 4 byte checksum.  The keyword must be at least one character and there is     * a terminator (0) byte and the compression method.     */
if|if
condition|(
name|length
operator|<
literal|9
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"too short"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If a colorspace error has already been output skip this chunk */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect     * this.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_INTENT
operator|)
operator|==
literal|0
condition|)
block|{
name|uInt
name|read_length
decl_stmt|,
name|keyword_length
decl_stmt|;
name|char
name|keyword
index|[
literal|81
index|]
decl_stmt|;
comment|/* Find the keyword; the keyword plus separator and compression method        * bytes can be at most 81 characters long.        */
name|read_length
operator|=
literal|81
expr_stmt|;
comment|/* maximum */
if|if
condition|(
name|read_length
operator|>
name|length
condition|)
name|read_length
operator|=
operator|(
name|uInt
operator|)
name|length
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|keyword
argument_list|,
name|read_length
argument_list|)
expr_stmt|;
name|length
operator|-=
name|read_length
expr_stmt|;
name|keyword_length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|keyword_length
operator|<
literal|80
operator|&&
name|keyword_length
operator|<
name|read_length
operator|&&
name|keyword
index|[
name|keyword_length
index|]
operator|!=
literal|0
condition|)
operator|++
name|keyword_length
expr_stmt|;
comment|/* TODO: make the keyword checking common */
if|if
condition|(
name|keyword_length
operator|>=
literal|1
operator|&&
name|keyword_length
operator|<=
literal|79
condition|)
block|{
comment|/* We only understand '0' compression - deflate - so if we get a           * different value we can't safely decode the chunk.           */
if|if
condition|(
name|keyword_length
operator|+
literal|1
operator|<
name|read_length
operator|&&
name|keyword
index|[
name|keyword_length
operator|+
literal|1
index|]
operator|==
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
name|read_length
operator|-=
name|keyword_length
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|png_inflate_claim
argument_list|(
name|png_ptr
argument_list|,
name|png_iCCP
argument_list|)
operator|==
name|Z_OK
condition|)
block|{
name|Byte
name|profile_header
index|[
literal|132
index|]
decl_stmt|;
name|Byte
name|local_buffer
index|[
name|PNG_INFLATE_BUF_SIZE
index|]
decl_stmt|;
name|png_alloc_size_t
name|size
init|=
operator|(
sizeof|sizeof
name|profile_header
operator|)
decl_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|keyword
operator|+
operator|(
name|keyword_length
operator|+
literal|2
operator|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|read_length
expr_stmt|;
operator|(
name|void
operator|)
name|png_inflate_read
argument_list|(
name|png_ptr
argument_list|,
name|local_buffer
argument_list|,
operator|(
sizeof|sizeof
name|local_buffer
operator|)
argument_list|,
operator|&
name|length
argument_list|,
name|profile_header
argument_list|,
operator|&
name|size
argument_list|,
literal|0
comment|/*finish: don't, because the output is too small*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* We have the ICC profile header; do the basic header checks.                    */
specifier|const
name|png_uint_32
name|profile_length
init|=
name|png_get_uint_32
argument_list|(
name|profile_header
argument_list|)
decl_stmt|;
if|if
condition|(
name|png_icc_check_length
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|colorspace
argument_list|,
name|keyword
argument_list|,
name|profile_length
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The length is apparently ok, so we can check the 132                       * byte header.                       */
if|if
condition|(
name|png_icc_check_header
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|colorspace
argument_list|,
name|keyword
argument_list|,
name|profile_length
argument_list|,
name|profile_header
argument_list|,
name|png_ptr
operator|->
name|color_type
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Now read the tag table; a variable size buffer is                          * needed at this point, allocate one for the whole                          * profile.  The header check has already validated                          * that none of these stuff will overflow.                          */
specifier|const
name|png_uint_32
name|tag_count
init|=
name|png_get_uint_32
argument_list|(
name|profile_header
operator|+
literal|128
argument_list|)
decl_stmt|;
name|png_bytep
name|profile
init|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|profile_length
argument_list|,
literal|2
comment|/*silent*/
argument_list|)
decl_stmt|;
if|if
condition|(
name|profile
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|profile
argument_list|,
name|profile_header
argument_list|,
operator|(
sizeof|sizeof
name|profile_header
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|12
operator|*
name|tag_count
expr_stmt|;
operator|(
name|void
operator|)
name|png_inflate_read
argument_list|(
name|png_ptr
argument_list|,
name|local_buffer
argument_list|,
operator|(
sizeof|sizeof
name|local_buffer
operator|)
argument_list|,
operator|&
name|length
argument_list|,
name|profile
operator|+
operator|(
sizeof|sizeof
name|profile_header
operator|)
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Still expect a buffer error because we expect                             * there to be some tag data!                             */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|png_icc_check_tag_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|colorspace
argument_list|,
name|keyword
argument_list|,
name|profile_length
argument_list|,
name|profile
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The profile has been validated for basic                                   * security issues, so read the whole thing in.                                   */
name|size
operator|=
name|profile_length
operator|-
operator|(
sizeof|sizeof
name|profile_header
operator|)
operator|-
literal|12
operator|*
name|tag_count
expr_stmt|;
operator|(
name|void
operator|)
name|png_inflate_read
argument_list|(
name|png_ptr
argument_list|,
name|local_buffer
argument_list|,
operator|(
sizeof|sizeof
name|local_buffer
operator|)
argument_list|,
operator|&
name|length
argument_list|,
name|profile
operator|+
operator|(
sizeof|sizeof
name|profile_header
operator|)
operator|+
literal|12
operator|*
name|tag_count
argument_list|,
operator|&
name|size
argument_list|,
literal|1
comment|/*finish*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_BENIGN_ERRORS_WARN
operator|)
condition|)
name|errmsg
operator|=
literal|"extra compressed data"
expr_stmt|;
comment|/* But otherwise allow extra data: */
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/* This can be handled completely, so                                         * keep going.                                         */
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"extra compressed data"
argument_list|)
expr_stmt|;
block|}
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|finished
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
comment|/* Check for a match against sRGB */
name|png_icc_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|colorspace
argument_list|,
name|profile
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|adler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Steal the profile for info_ptr. */
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ICCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|iccp_name
operator|=
name|png_voidcast
argument_list|(
name|char
operator|*
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
name|keyword_length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|iccp_name
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|info_ptr
operator|->
name|iccp_name
argument_list|,
name|keyword
argument_list|,
name|keyword_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|iccp_proflen
operator|=
name|profile_length
expr_stmt|;
name|info_ptr
operator|->
name|iccp_profile
operator|=
name|profile
expr_stmt|;
name|png_ptr
operator|->
name|read_buffer
operator|=
name|NULL
expr_stmt|;
comment|/*steal*/
name|info_ptr
operator|->
name|free_me
operator||=
name|PNG_FREE_ICCP
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_iCCP
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|errmsg
operator|=
literal|"out of memory"
expr_stmt|;
block|}
block|}
comment|/* else the profile remains in the read                                      * buffer which gets reused for subsequent                                      * chunks.                                      */
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
name|png_colorspace_sync
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|errmsg
operator|=
literal|"truncated"
expr_stmt|;
ifndef|#
directive|ifndef
name|__COVERITY__
else|else
name|errmsg
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* else png_icc_check_tag_table output an error */
block|}
else|else
comment|/* profile truncated */
name|errmsg
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
block|}
else|else
name|errmsg
operator|=
literal|"out of memory"
expr_stmt|;
block|}
comment|/* else png_icc_check_header output an error */
block|}
comment|/* else png_icc_check_length output an error */
block|}
else|else
comment|/* profile truncated */
name|errmsg
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
comment|/* Release the stream */
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* png_inflate_claim failed */
name|errmsg
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
block|}
else|else
name|errmsg
operator|=
literal|"bad compression method"
expr_stmt|;
comment|/* or missing */
block|}
else|else
name|errmsg
operator|=
literal|"bad keyword"
expr_stmt|;
block|}
else|else
name|errmsg
operator|=
literal|"too many profiles"
expr_stmt|;
comment|/* Failure: the reason is in 'errmsg' */
if|if
condition|(
name|finished
operator|==
literal|0
condition|)
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_colorspace_sync
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
comment|/* else already output */
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_iCCP */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sPLT_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sPLT
name|png_handle_sPLT
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
comment|/* Note: this does not properly handle chunks that are> 64K under DOS */
block|{
name|png_bytep
name|entry_start
decl_stmt|,
name|buffer
decl_stmt|;
name|png_sPLT_t
name|new_palette
decl_stmt|;
name|png_sPLT_entryp
name|pp
decl_stmt|;
name|png_uint_32
name|data_length
decl_stmt|;
name|int
name|entry_size
decl_stmt|,
name|i
decl_stmt|;
name|png_uint_32
name|skip
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|dl
decl_stmt|;
name|png_size_t
name|max_dl
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sPLT"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"No space in chunk cache for sPLT"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|length
operator|>
literal|65535U
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"too large to fit in memory"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|buffer
operator|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|2
comment|/*silent*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* WARNING: this may break if size_t is less than 32 bits; it is assumed     * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a     * potential breakage point if the types in pngconf.h aren't exactly right.     */
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|skip
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|buffer
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|entry_start
operator|=
name|buffer
init|;
operator|*
name|entry_start
condition|;
name|entry_start
operator|++
control|)
comment|/* Empty loop to find end of name */
empty_stmt|;
operator|++
name|entry_start
expr_stmt|;
comment|/* A sample depth should follow the separator, and we should be on it  */
if|if
condition|(
name|length
operator|<
literal|2U
operator|||
name|entry_start
operator|>
name|buffer
operator|+
operator|(
name|length
operator|-
literal|2U
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"malformed sPLT chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_palette
operator|.
name|depth
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|entry_size
operator|=
operator|(
name|new_palette
operator|.
name|depth
operator|==
literal|8
condition|?
literal|6
else|:
literal|10
operator|)
expr_stmt|;
comment|/* This must fit in a png_uint_32 because it is derived from the original     * chunk data length.     */
name|data_length
operator|=
name|length
operator|-
call|(
name|png_uint_32
call|)
argument_list|(
name|entry_start
operator|-
name|buffer
argument_list|)
expr_stmt|;
comment|/* Integrity-check the data length */
if|if
condition|(
operator|(
name|data_length
operator|%
name|entry_size
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT chunk has bad length"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dl
operator|=
call|(
name|png_int_32
call|)
argument_list|(
name|data_length
operator|/
name|entry_size
argument_list|)
expr_stmt|;
name|max_dl
operator|=
name|PNG_SIZE_MAX
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|dl
operator|>
name|max_dl
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT chunk too long"
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_palette
operator|.
name|nentries
operator|=
call|(
name|png_int_32
call|)
argument_list|(
name|data_length
operator|/
name|entry_size
argument_list|)
expr_stmt|;
name|new_palette
operator|.
name|entries
operator|=
operator|(
name|png_sPLT_entryp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|new_palette
operator|.
name|nentries
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_sPLT_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_palette
operator|.
name|entries
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT chunk requires too much memory"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_palette
operator|.
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
name|new_palette
operator|.
name|entries
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|new_palette
operator|.
name|depth
operator|==
literal|8
condition|)
block|{
name|pp
operator|->
name|red
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
operator|->
name|green
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
operator|->
name|blue
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
operator|->
name|alpha
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
operator|->
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
operator|->
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
operator|->
name|alpha
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
name|pp
operator|->
name|frequency
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
else|#
directive|else
name|pp
operator|=
name|new_palette
operator|.
name|entries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_palette
operator|.
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|new_palette
operator|.
name|depth
operator|==
literal|8
condition|)
block|{
name|pp
index|[
name|i
index|]
operator|.
name|red
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|green
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|blue
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|alpha
operator|=
operator|*
name|entry_start
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pp
index|[
name|i
index|]
operator|.
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|.
name|alpha
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
name|pp
index|[
name|i
index|]
operator|.
name|frequency
operator|=
name|png_get_uint_16
argument_list|(
name|entry_start
argument_list|)
expr_stmt|;
name|entry_start
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Discard all chunk data except the name and stash that */
name|new_palette
operator|.
name|name
operator|=
operator|(
name|png_charp
operator|)
name|buffer
expr_stmt|;
name|png_set_sPLT
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|new_palette
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_palette
operator|.
name|entries
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_sPLT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_tRNS_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_tRNS
name|png_handle_tRNS
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|readbuf
index|[
name|PNG_MAX_PALETTE_LENGTH
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_tRNS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tRNS
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
name|png_byte
name|buf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|length
operator|!=
literal|2
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_trans
operator|=
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|gray
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|length
operator|!=
literal|6
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_trans
operator|=
literal|1
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|trans_color
operator|.
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* TODO: is this actually an error in the ISO spec? */
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|>
operator|(
name|unsigned
name|int
operator|)
name|png_ptr
operator|->
name|num_palette
operator|||
name|length
operator|>
operator|(
name|unsigned
name|int
operator|)
name|PNG_MAX_PALETTE_LENGTH
operator|||
name|length
operator|==
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|readbuf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|num_trans
operator|=
operator|(
name|png_uint_16
operator|)
name|length
expr_stmt|;
block|}
else|else
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid with alpha channel"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* TODO: this is a horrible side effect in the palette case because the     * png_struct ends up with a pointer to the tRNS buffer owned by the     * png_info.  Fix this.     */
name|png_set_tRNS
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|readbuf
argument_list|,
name|png_ptr
operator|->
name|num_trans
argument_list|,
operator|&
operator|(
name|png_ptr
operator|->
name|trans_color
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_bKGD_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_bKGD
name|png_handle_bKGD
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|unsigned
name|int
name|truelen
decl_stmt|;
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|png_color_16
name|background
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_bKGD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|&&
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_bKGD
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|truelen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
name|truelen
operator|=
literal|6
expr_stmt|;
else|else
name|truelen
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|truelen
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
name|truelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* We convert the index value into RGB components so that we can allow     * arbitrary RGB values for background when we have transparency, and     * so it is easy to determine the RGB values of the background color     * from the info_ptr struct.     */
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|background
operator|.
name|index
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
name|info_ptr
operator|->
name|num_palette
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|>=
name|info_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid index"
argument_list|)
expr_stmt|;
return|return;
block|}
name|background
operator|.
name|red
operator|=
operator|(
name|png_uint_16
operator|)
name|png_ptr
operator|->
name|palette
index|[
name|buf
index|[
literal|0
index|]
index|]
operator|.
name|red
expr_stmt|;
name|background
operator|.
name|green
operator|=
operator|(
name|png_uint_16
operator|)
name|png_ptr
operator|->
name|palette
index|[
name|buf
index|[
literal|0
index|]
index|]
operator|.
name|green
expr_stmt|;
name|background
operator|.
name|blue
operator|=
operator|(
name|png_uint_16
operator|)
name|png_ptr
operator|->
name|palette
index|[
name|buf
index|[
literal|0
index|]
index|]
operator|.
name|blue
expr_stmt|;
block|}
else|else
name|background
operator|.
name|red
operator|=
name|background
operator|.
name|green
operator|=
name|background
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
name|background
operator|.
name|gray
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
condition|)
comment|/* GRAY */
block|{
name|background
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|background
operator|.
name|red
operator|=
name|background
operator|.
name|green
operator|=
name|background
operator|.
name|blue
operator|=
name|background
operator|.
name|gray
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|background
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|background
operator|.
name|red
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|background
operator|.
name|green
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|background
operator|.
name|blue
operator|=
name|png_get_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|background
operator|.
name|gray
operator|=
literal|0
expr_stmt|;
block|}
name|png_set_bKGD
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|background
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_hIST_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_hIST
name|png_handle_hIST
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|unsigned
name|int
name|num
decl_stmt|,
name|i
decl_stmt|;
name|png_uint_16
name|readbuf
index|[
name|PNG_MAX_PALETTE_LENGTH
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_hIST"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PLTE
operator|)
operator|==
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_hIST
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|=
name|length
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|num
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|png_ptr
operator|->
name|num_palette
operator|||
name|num
operator|>
operator|(
name|unsigned
name|int
operator|)
name|PNG_MAX_PALETTE_LENGTH
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|readbuf
index|[
name|i
index|]
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|png_set_hIST
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_pHYs_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_pHYs
name|png_handle_pHYs
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_uint_32
name|res_x
decl_stmt|,
name|res_y
decl_stmt|;
name|int
name|unit_type
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_pHYs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pHYs
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|9
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|res_x
operator|=
name|png_get_uint_32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|res_y
operator|=
name|png_get_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|unit_type
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|png_set_pHYs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|res_x
argument_list|,
name|res_y
argument_list|,
name|unit_type
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_oFFs_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_oFFs
name|png_handle_oFFs
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_int_32
name|offset_x
decl_stmt|,
name|offset_y
decl_stmt|;
name|int
name|unit_type
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_oFFs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_oFFs
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|!=
literal|9
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|offset_x
operator|=
name|png_get_int_32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|offset_y
operator|=
name|png_get_int_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|unit_type
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|png_set_oFFs
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|offset_x
argument_list|,
name|offset_y
argument_list|,
name|unit_type
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_pCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the pCAL chunk (described in the PNG Extensions document) */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_pCAL
name|png_handle_pCAL
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_int_32
name|X0
decl_stmt|,
name|X1
decl_stmt|;
name|png_byte
name|type
decl_stmt|,
name|nparams
decl_stmt|;
name|png_bytep
name|buffer
decl_stmt|,
name|buf
decl_stmt|,
name|units
decl_stmt|,
name|endptr
decl_stmt|;
name|png_charpp
name|params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_pCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_pCAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"Allocating and reading pCAL chunk data (%u bytes)"
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|2
comment|/*silent*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|buffer
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Null terminate the last string */
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Finding end of pCAL purpose string"
argument_list|)
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|buffer
init|;
operator|*
name|buf
condition|;
name|buf
operator|++
control|)
comment|/* Empty loop */
empty_stmt|;
name|endptr
operator|=
name|buffer
operator|+
name|length
expr_stmt|;
comment|/* We need to have at least 12 bytes after the purpose string     * in order to get the parameter information.     */
if|if
condition|(
name|endptr
operator|-
name|buf
operator|<=
literal|12
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Reading pCAL X0, X1, type, nparams, and units"
argument_list|)
expr_stmt|;
name|X0
operator|=
name|png_get_int_32
argument_list|(
operator|(
name|png_bytep
operator|)
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|X1
operator|=
name|png_get_int_32
argument_list|(
operator|(
name|png_bytep
operator|)
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
name|type
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|nparams
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
name|units
operator|=
name|buf
operator|+
literal|11
expr_stmt|;
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Checking pCAL equation type and number of parameters"
argument_list|)
expr_stmt|;
comment|/* Check that we have the right number of parameters for known     * equation types.     */
if|if
condition|(
operator|(
name|type
operator|==
name|PNG_EQUATION_LINEAR
operator|&&
name|nparams
operator|!=
literal|2
operator|)
operator|||
operator|(
name|type
operator|==
name|PNG_EQUATION_BASE_E
operator|&&
name|nparams
operator|!=
literal|3
operator|)
operator|||
operator|(
name|type
operator|==
name|PNG_EQUATION_ARBITRARY
operator|&&
name|nparams
operator|!=
literal|3
operator|)
operator|||
operator|(
name|type
operator|==
name|PNG_EQUATION_HYPERBOLIC
operator|&&
name|nparams
operator|!=
literal|4
operator|)
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid parameter count"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|PNG_EQUATION_LAST
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unrecognized equation type"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|buf
operator|=
name|units
init|;
operator|*
name|buf
condition|;
name|buf
operator|++
control|)
comment|/* Empty loop to move past the units string. */
empty_stmt|;
name|png_debug
argument_list|(
literal|3
argument_list|,
literal|"Allocating pCAL parameters array"
argument_list|)
expr_stmt|;
name|params
operator|=
name|png_voidcast
argument_list|(
name|png_charpp
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|nparams
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_charp
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get pointers to the start of each parameter string. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|++
expr_stmt|;
comment|/* Skip the null string terminator from previous parameter. */
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"Reading pCAL parameter %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|params
index|[
name|i
index|]
operator|=
operator|(
name|png_charp
operator|)
name|buf
init|;
name|buf
operator|<=
name|endptr
operator|&&
operator|*
name|buf
operator|!=
literal|0
condition|;
name|buf
operator|++
control|)
comment|/* Empty loop to move past each parameter string */
empty_stmt|;
comment|/* Make sure we haven't run out of data yet */
if|if
condition|(
name|buf
operator|>
name|endptr
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid data"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|png_set_pCAL
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|(
name|png_charp
operator|)
name|buffer
argument_list|,
name|X0
argument_list|,
name|X1
argument_list|,
name|type
argument_list|,
name|nparams
argument_list|,
operator|(
name|png_charp
operator|)
name|units
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Read the sCAL chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_sCAL
name|png_handle_sCAL
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_bytep
name|buffer
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|state
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_sCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of place"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_sCAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Need unit type, width, \0, height: minimum 4 bytes */
elseif|else
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"Allocating and reading sCAL chunk data (%u bytes)"
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|2
comment|/*silent*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|buffer
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Null terminate the last string */
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Validate the unit. */
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|!=
literal|1
operator|&&
name|buffer
index|[
literal|0
index|]
operator|!=
literal|2
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid unit"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Validate the ASCII numbers, need two ASCII numbers separated by     * a '\0' and they need to fit exactly in the chunk data.     */
name|i
operator|=
literal|1
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|png_check_fp_number
argument_list|(
operator|(
name|png_const_charp
operator|)
name|buffer
argument_list|,
name|length
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|||
name|i
operator|>=
name|length
operator|||
name|buffer
index|[
name|i
operator|++
index|]
operator|!=
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad width format"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PNG_FP_IS_POSITIVE
argument_list|(
name|state
argument_list|)
operator|==
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"non-positive width"
argument_list|)
expr_stmt|;
else|else
block|{
name|png_size_t
name|heighti
init|=
name|i
decl_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|png_check_fp_number
argument_list|(
operator|(
name|png_const_charp
operator|)
name|buffer
argument_list|,
name|length
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|||
name|i
operator|!=
name|length
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"bad height format"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PNG_FP_IS_POSITIVE
argument_list|(
name|state
argument_list|)
operator|==
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"non-positive height"
argument_list|)
expr_stmt|;
else|else
comment|/* This is the (only) success case. */
name|png_set_sCAL_s
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|,
operator|(
name|png_charp
operator|)
name|buffer
operator|+
literal|1
argument_list|,
operator|(
name|png_charp
operator|)
name|buffer
operator|+
name|heighti
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_tIME_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_tIME
name|png_handle_tIME
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|7
index|]
decl_stmt|;
name|png_time
name|mod_time
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_tIME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|info_ptr
operator|->
name|valid
operator|&
name|PNG_INFO_tIME
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|7
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|mod_time
operator|.
name|second
operator|=
name|buf
index|[
literal|6
index|]
expr_stmt|;
name|mod_time
operator|.
name|minute
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
name|mod_time
operator|.
name|hour
operator|=
name|buf
index|[
literal|4
index|]
expr_stmt|;
name|mod_time
operator|.
name|day
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|mod_time
operator|.
name|month
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|mod_time
operator|.
name|year
operator|=
name|png_get_uint_16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|png_set_tIME
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|mod_time
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_tEXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Note: this does not properly handle chunks that are> 64K under DOS */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_tEXt
name|png_handle_tEXt
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_text
name|text_info
decl_stmt|;
name|png_bytep
name|buffer
decl_stmt|;
name|png_charp
name|key
decl_stmt|;
name|png_charp
name|text
decl_stmt|;
name|png_uint_32
name|skip
init|=
literal|0
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_tEXt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no space in chunk cache"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|length
operator|>
literal|65535U
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"too large to fit in memory"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|buffer
operator|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|1
comment|/*warn*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|skip
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|key
operator|=
operator|(
name|png_charp
operator|)
name|buffer
expr_stmt|;
name|key
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|text
operator|=
name|key
init|;
operator|*
name|text
condition|;
name|text
operator|++
control|)
comment|/* Empty loop to find end of key */
empty_stmt|;
if|if
condition|(
name|text
operator|!=
name|key
operator|+
name|length
condition|)
name|text
operator|++
expr_stmt|;
name|text_info
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_NONE
expr_stmt|;
name|text_info
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|text_info
operator|.
name|lang
operator|=
name|NULL
expr_stmt|;
name|text_info
operator|.
name|lang_key
operator|=
name|NULL
expr_stmt|;
name|text_info
operator|.
name|itxt_length
operator|=
literal|0
expr_stmt|;
name|text_info
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|text_info
operator|.
name|text_length
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|text_info
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Insufficient memory to process text chunk"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_zTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Note: this does not correctly handle chunks that are> 64K under DOS */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_zTXt
name|png_handle_zTXt
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_const_charp
name|errmsg
init|=
name|NULL
decl_stmt|;
name|png_bytep
name|buffer
decl_stmt|;
name|png_uint_32
name|keyword_length
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_zTXt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no space in chunk cache"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|buffer
operator|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|,
literal|2
comment|/*silent*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* TODO: also check that the keyword contents match the spec! */
for|for
control|(
name|keyword_length
operator|=
literal|0
init|;
name|keyword_length
operator|<
name|length
operator|&&
name|buffer
index|[
name|keyword_length
index|]
operator|!=
literal|0
condition|;
operator|++
name|keyword_length
control|)
comment|/* Empty loop to find end of name */
empty_stmt|;
if|if
condition|(
name|keyword_length
operator|>
literal|79
operator|||
name|keyword_length
operator|<
literal|1
condition|)
name|errmsg
operator|=
literal|"bad keyword"
expr_stmt|;
comment|/* zTXt must have some LZ data after the keyword, although it may expand to     * zero bytes; we need a '\0' at the end of the keyword, the compression type     * then the LZ data:     */
elseif|else
if|if
condition|(
name|keyword_length
operator|+
literal|3
operator|>
name|length
condition|)
name|errmsg
operator|=
literal|"truncated"
expr_stmt|;
elseif|else
if|if
condition|(
name|buffer
index|[
name|keyword_length
operator|+
literal|1
index|]
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
name|errmsg
operator|=
literal|"unknown compression type"
expr_stmt|;
else|else
block|{
name|png_alloc_size_t
name|uncompressed_length
init|=
name|PNG_SIZE_MAX
decl_stmt|;
comment|/* TODO: at present png_decompress_chunk imposes a single application        * level memory limit, this should be split to different values for iCCP        * and text chunks.        */
if|if
condition|(
name|png_decompress_chunk
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|,
name|keyword_length
operator|+
literal|2
argument_list|,
operator|&
name|uncompressed_length
argument_list|,
literal|1
comment|/*terminate*/
argument_list|)
operator|==
name|Z_STREAM_END
condition|)
block|{
name|png_text
name|text
decl_stmt|;
comment|/* It worked; png_ptr->read_buffer now looks like a tEXt chunk except           * for the extra compression type byte and the fact that it isn't           * necessarily '\0' terminated.           */
name|buffer
operator|=
name|png_ptr
operator|->
name|read_buffer
expr_stmt|;
name|buffer
index|[
name|uncompressed_length
operator|+
operator|(
name|keyword_length
operator|+
literal|2
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|compression
operator|=
name|PNG_TEXT_COMPRESSION_zTXt
expr_stmt|;
name|text
operator|.
name|key
operator|=
operator|(
name|png_charp
operator|)
name|buffer
expr_stmt|;
name|text
operator|.
name|text
operator|=
call|(
name|png_charp
call|)
argument_list|(
name|buffer
operator|+
name|keyword_length
operator|+
literal|2
argument_list|)
expr_stmt|;
name|text
operator|.
name|text_length
operator|=
name|uncompressed_length
expr_stmt|;
name|text
operator|.
name|itxt_length
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|lang
operator|=
name|NULL
expr_stmt|;
name|text
operator|.
name|lang_key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|text
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|errmsg
operator|=
literal|"insufficient memory"
expr_stmt|;
block|}
else|else
name|errmsg
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
block|}
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_iTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Note: this does not correctly handle chunks that are> 64K under DOS */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_iTXt
name|png_handle_iTXt
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_const_charp
name|errmsg
init|=
name|NULL
decl_stmt|;
name|png_bytep
name|buffer
decl_stmt|;
name|png_uint_32
name|prefix_length
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_iTXt"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|--
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|==
literal|1
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no space in chunk cache"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IHDR
operator|)
operator|==
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"missing IHDR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|buffer
operator|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|length
operator|+
literal|1
argument_list|,
literal|1
comment|/*warn*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* First the keyword. */
for|for
control|(
name|prefix_length
operator|=
literal|0
init|;
name|prefix_length
operator|<
name|length
operator|&&
name|buffer
index|[
name|prefix_length
index|]
operator|!=
literal|0
condition|;
operator|++
name|prefix_length
control|)
comment|/* Empty loop */
empty_stmt|;
comment|/* Perform a basic check on the keyword length here. */
if|if
condition|(
name|prefix_length
operator|>
literal|79
operator|||
name|prefix_length
operator|<
literal|1
condition|)
name|errmsg
operator|=
literal|"bad keyword"
expr_stmt|;
comment|/* Expect keyword, compression flag, compression type, language, translated     * keyword (both may be empty but are 0 terminated) then the text, which may     * be empty.     */
elseif|else
if|if
condition|(
name|prefix_length
operator|+
literal|5
operator|>
name|length
condition|)
name|errmsg
operator|=
literal|"truncated"
expr_stmt|;
elseif|else
if|if
condition|(
name|buffer
index|[
name|prefix_length
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
operator|(
name|buffer
index|[
name|prefix_length
operator|+
literal|1
index|]
operator|==
literal|1
operator|&&
name|buffer
index|[
name|prefix_length
operator|+
literal|2
index|]
operator|==
name|PNG_COMPRESSION_TYPE_BASE
operator|)
condition|)
block|{
name|int
name|compressed
init|=
name|buffer
index|[
name|prefix_length
operator|+
literal|1
index|]
operator|!=
literal|0
decl_stmt|;
name|png_uint_32
name|language_offset
decl_stmt|,
name|translated_keyword_offset
decl_stmt|;
name|png_alloc_size_t
name|uncompressed_length
init|=
literal|0
decl_stmt|;
comment|/* Now the language tag */
name|prefix_length
operator|+=
literal|3
expr_stmt|;
name|language_offset
operator|=
name|prefix_length
expr_stmt|;
for|for
control|(
init|;
name|prefix_length
operator|<
name|length
operator|&&
name|buffer
index|[
name|prefix_length
index|]
operator|!=
literal|0
condition|;
operator|++
name|prefix_length
control|)
comment|/* Empty loop */
empty_stmt|;
comment|/* WARNING: the length may be invalid here, this is checked below. */
name|translated_keyword_offset
operator|=
operator|++
name|prefix_length
expr_stmt|;
for|for
control|(
init|;
name|prefix_length
operator|<
name|length
operator|&&
name|buffer
index|[
name|prefix_length
index|]
operator|!=
literal|0
condition|;
operator|++
name|prefix_length
control|)
comment|/* Empty loop */
empty_stmt|;
comment|/* prefix_length should now be at the trailing '\0' of the translated        * keyword, but it may already be over the end.  None of this arithmetic        * can overflow because chunks are at most 2^31 bytes long, but on 16-bit        * systems the available allocation may overflow.        */
operator|++
name|prefix_length
expr_stmt|;
if|if
condition|(
name|compressed
operator|==
literal|0
operator|&&
name|prefix_length
operator|<=
name|length
condition|)
name|uncompressed_length
operator|=
name|length
operator|-
name|prefix_length
expr_stmt|;
elseif|else
if|if
condition|(
name|compressed
operator|!=
literal|0
operator|&&
name|prefix_length
operator|<
name|length
condition|)
block|{
name|uncompressed_length
operator|=
name|PNG_SIZE_MAX
expr_stmt|;
comment|/* TODO: at present png_decompress_chunk imposes a single application           * level memory limit, this should be split to different values for           * iCCP and text chunks.           */
if|if
condition|(
name|png_decompress_chunk
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|,
name|prefix_length
argument_list|,
operator|&
name|uncompressed_length
argument_list|,
literal|1
comment|/*terminate*/
argument_list|)
operator|==
name|Z_STREAM_END
condition|)
name|buffer
operator|=
name|png_ptr
operator|->
name|read_buffer
expr_stmt|;
else|else
name|errmsg
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
block|}
else|else
name|errmsg
operator|=
literal|"truncated"
expr_stmt|;
if|if
condition|(
name|errmsg
operator|==
name|NULL
condition|)
block|{
name|png_text
name|text
decl_stmt|;
name|buffer
index|[
name|uncompressed_length
operator|+
name|prefix_length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compressed
operator|==
literal|0
condition|)
name|text
operator|.
name|compression
operator|=
name|PNG_ITXT_COMPRESSION_NONE
expr_stmt|;
else|else
name|text
operator|.
name|compression
operator|=
name|PNG_ITXT_COMPRESSION_zTXt
expr_stmt|;
name|text
operator|.
name|key
operator|=
operator|(
name|png_charp
operator|)
name|buffer
expr_stmt|;
name|text
operator|.
name|lang
operator|=
operator|(
name|png_charp
operator|)
name|buffer
operator|+
name|language_offset
expr_stmt|;
name|text
operator|.
name|lang_key
operator|=
operator|(
name|png_charp
operator|)
name|buffer
operator|+
name|translated_keyword_offset
expr_stmt|;
name|text
operator|.
name|text
operator|=
operator|(
name|png_charp
operator|)
name|buffer
operator|+
name|prefix_length
expr_stmt|;
name|text
operator|.
name|text_length
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|itxt_length
operator|=
name|uncompressed_length
expr_stmt|;
if|if
condition|(
name|png_set_text_2
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|text
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|errmsg
operator|=
literal|"insufficient memory"
expr_stmt|;
block|}
block|}
else|else
name|errmsg
operator|=
literal|"bad compression info"
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_comment
comment|/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_cache_unknown_chunk
name|png_cache_unknown_chunk
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_alloc_size_t
name|limit
init|=
name|PNG_SIZE_MAX
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|!=
name|NULL
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|>
literal|0
operator|&&
name|png_ptr
operator|->
name|user_chunk_malloc_max
operator|<
name|limit
condition|)
name|limit
operator|=
name|png_ptr
operator|->
name|user_chunk_malloc_max
expr_stmt|;
elif|#
directive|elif
name|PNG_USER_CHUNK_MALLOC_MAX
operator|>
literal|0
if|if
condition|(
name|PNG_USER_CHUNK_MALLOC_MAX
operator|<
name|limit
condition|)
name|limit
operator|=
name|PNG_USER_CHUNK_MALLOC_MAX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|length
operator|<=
name|limit
condition|)
block|{
name|PNG_CSTRING_FROM_CHUNK
argument_list|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|name
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
comment|/* The following is safe because of the PNG_SIZE_MAX init above */
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|size
operator|=
operator|(
name|png_size_t
operator|)
name|length
comment|/*SAFE*/
expr_stmt|;
comment|/* 'mode' is a flag array, only the bottom four bits matter here */
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|location
operator|=
operator|(
name|png_byte
operator|)
name|png_ptr
operator|->
name|mode
comment|/*SAFE*/
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Do a 'warn' here - it is handled below. */
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|png_voidcast
argument_list|(
name|png_bytep
argument_list|,
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|==
name|NULL
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
comment|/* This is benign because we clean up correctly */
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unknown chunk exceeds memory limits"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_UNKNOWN_CHUNKS */
end_comment
begin_comment
comment|/* Handle an unknown, or known but disabled, chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_handle_unknown
name|png_handle_unknown
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|length
parameter_list|,
name|int
name|keep
parameter_list|)
block|{
name|int
name|handled
init|=
literal|0
decl_stmt|;
comment|/* the chunk was handled */
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_handle_unknown"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
comment|/* NOTE: this code is based on the code in libpng-1.4.12 except for fixing     * the bug which meant that setting a non-default behavior for a specific     * chunk would be ignored (the default was always used unless a user     * callback was installed).     *     * 'keep' is the value from the png_chunk_unknown_handling, the setting for     * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it     * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.     * This is just an optimization to avoid multiple calls to the lookup     * function.     */
ifndef|#
directive|ifndef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
name|keep
operator|=
name|png_chunk_unknown_handling
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* One of the following methods will read the chunk or skip it (at least one     * of these is always defined because this is the only way to switch on     * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)     */
ifdef|#
directive|ifdef
name|PNG_READ_USER_CHUNKS_SUPPORTED
comment|/* The user callback takes precedence over the chunk keep value, but the     * keep value is still required to validate a save of a critical chunk.     */
if|if
condition|(
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|png_cache_unknown_chunk
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Callback to user unknown chunk handler */
name|int
name|ret
init|=
operator|(
operator|*
operator|(
name|png_ptr
operator|->
name|read_user_chunk_fn
operator|)
operator|)
operator|(
name|png_ptr
expr|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
operator|)
decl_stmt|;
comment|/* ret is:           * negative: An error occurred; png_chunk_error will be called.           *     zero: The chunk was not handled, the chunk will be discarded           *           unless png_set_keep_unknown_chunks has been used to set           *           a 'keep' behavior for this particular chunk, in which           *           case that will be used.  A critical chunk will cause an           *           error at this point unless it is to be saved.           * positive: The chunk was handled, libpng will ignore/discard it.           */
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"error in user chunk"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* If the keep value is 'default' or 'never' override it, but              * still error out on critical chunks unless the keep value is              * 'always'  While this is weird it is the behavior in 1.4.12.              * A possible improvement would be to obey the value set for the              * chunk, but this would be an API change that would probably              * damage some applications.              *              * The png_app_warning below catches the case that matters, where              * the application has not set specific save or ignore for this              * chunk or global save or ignore.              */
if|if
condition|(
name|keep
operator|<
name|PNG_HANDLE_CHUNK_IF_SAFE
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|unknown_default
operator|<
name|PNG_HANDLE_CHUNK_IF_SAFE
condition|)
block|{
name|png_chunk_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Saving unknown chunk:"
argument_list|)
expr_stmt|;
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"forcing save of an unhandled chunk;"
literal|" please call png_set_keep_unknown_chunks"
argument_list|)
expr_stmt|;
comment|/* with keep = PNG_HANDLE_CHUNK_IF_SAFE */
block|}
endif|#
directive|endif
name|keep
operator|=
name|PNG_HANDLE_CHUNK_IF_SAFE
expr_stmt|;
block|}
block|}
else|else
comment|/* chunk was handled */
block|{
name|handled
operator|=
literal|1
expr_stmt|;
comment|/* Critical chunks can be safely discarded at this point. */
name|keep
operator|=
name|PNG_HANDLE_CHUNK_NEVER
expr_stmt|;
block|}
block|}
else|else
name|keep
operator|=
name|PNG_HANDLE_CHUNK_NEVER
expr_stmt|;
comment|/* insufficient memory */
block|}
else|else
comment|/* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */
endif|#
directive|endif
comment|/* READ_USER_CHUNKS */
ifdef|#
directive|ifdef
name|PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
block|{
comment|/* keep is currently just the per-chunk setting, if there was no        * setting change it to the global default now (not that this may        * still be AS_DEFAULT) then obtain the cache of the chunk if required,        * if not simply skip the chunk.        */
if|if
condition|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_AS_DEFAULT
condition|)
name|keep
operator|=
name|png_ptr
operator|->
name|unknown_default
expr_stmt|;
if|if
condition|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|||
operator|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_IF_SAFE
operator|&&
name|PNG_CHUNK_ANCILLARY
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|png_cache_unknown_chunk
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
name|keep
operator|=
name|PNG_HANDLE_CHUNK_NEVER
expr_stmt|;
block|}
else|else
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifndef|#
directive|ifndef
name|PNG_READ_USER_CHUNKS_SUPPORTED
error|#
directive|error
error|no method to support READ_UNKNOWN_CHUNKS
endif|#
directive|endif
block|{
comment|/* If here there is no read callback pointer set and no support is        * compiled in to just save the unknown chunks, so simply skip this        * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then        * the app has erroneously asked for unknown chunk saving when there        * is no support.        */
if|if
condition|(
name|keep
operator|>
name|PNG_HANDLE_CHUNK_NEVER
condition|)
name|png_app_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no unknown chunk support available"
argument_list|)
expr_stmt|;
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
comment|/* Now store the chunk in the chunk list if appropriate, and if the limits     * permit it.     */
if|if
condition|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_ALWAYS
operator|||
operator|(
name|keep
operator|==
name|PNG_HANDLE_CHUNK_IF_SAFE
operator|&&
name|PNG_CHUNK_ANCILLARY
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
switch|switch
condition|(
name|png_ptr
operator|->
name|user_chunk_cache_max
condition|)
block|{
case|case
literal|2
case|:
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|=
literal|1
expr_stmt|;
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"no space in chunk cache"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|1
case|:
comment|/* NOTE: prior to 1.6.0 this case resulted in an unknown critical              * chunk being skipped, now there will be a hard error below.              */
break|break;
default|default:
comment|/* not at limit */
operator|--
operator|(
name|png_ptr
operator|->
name|user_chunk_cache_max
operator|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|0
case|:
comment|/* no limit */
endif|#
directive|endif
comment|/* USER_LIMITS */
comment|/* Here when the limit isn't reached or when limits are compiled              * out; store the chunk.              */
name|png_set_unknown_chunks
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|unknown_chunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
break|break;
block|}
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* no store support: the chunk must be handled by the user callback */
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
endif|#
directive|endif
comment|/* Regardless of the error handling below the cached data (if any) can be     * freed now.  Notice that the data is not freed if there is a png_error, but     * it will be freed by destroy_read_struct.     */
if|if
condition|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|!=
name|NULL
condition|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */
comment|/* There is no support to read an unknown chunk, so just skip it. */
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|info_ptr
argument_list|)
name|PNG_UNUSED
argument_list|(
argument|keep
argument_list|)
endif|#
directive|endif
comment|/* !READ_UNKNOWN_CHUNKS */
comment|/* Check for unhandled critical chunks */
if|if
condition|(
name|handled
operator|==
literal|0
operator|&&
name|PNG_CHUNK_CRITICAL
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|)
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"unhandled critical chunk"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This function is called to verify that a chunk name is valid.  * This function can't have the "critical chunk check" incorporated  * into it, since in the future we will need to be able to call user  * functions to handle unknown critical chunks after we check that  * the chunk name itself is valid.  */
end_comment
begin_comment
comment|/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:  *  * ((c)< 65 || (c)> 122 || ((c)> 90&& (c)< 97))  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_check_chunk_name
name|png_check_chunk_name
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_check_chunk_name"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|int
name|c
init|=
name|chunk_name
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|65
operator|||
name|c
operator|>
literal|122
operator|||
operator|(
name|c
operator|>
literal|90
operator|&&
name|c
operator|<
literal|97
operator|)
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid chunk type"
argument_list|)
expr_stmt|;
name|chunk_name
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Combines the row recently read in with the existing pixels in the row.  This  * routine takes care of alpha and transparency if requested.  This routine also  * handles the two methods of progressive display of interlaced images,  * depending on the 'display' value; if 'display' is true then the whole row  * (dp) is filled from the start by replicating the available pixels.  If  * 'display' is false only those pixels present in the pass are filled in.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_combine_row
name|png_combine_row
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|dp
parameter_list|,
name|int
name|display
parameter_list|)
block|{
name|unsigned
name|int
name|pixel_depth
init|=
name|png_ptr
operator|->
name|transformed_pixel_depth
decl_stmt|;
name|png_const_bytep
name|sp
init|=
name|png_ptr
operator|->
name|row_buf
operator|+
literal|1
decl_stmt|;
name|png_alloc_size_t
name|row_width
init|=
name|png_ptr
operator|->
name|width
decl_stmt|;
name|unsigned
name|int
name|pass
init|=
name|png_ptr
operator|->
name|pass
decl_stmt|;
name|png_bytep
name|end_ptr
init|=
literal|0
decl_stmt|;
name|png_byte
name|end_byte
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|end_mask
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_combine_row"
argument_list|)
expr_stmt|;
comment|/* Added in 1.5.6: it should not be possible to enter this routine until at     * least one row has been read from the PNG data and transformed.     */
if|if
condition|(
name|pixel_depth
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal row logic error"
argument_list|)
expr_stmt|;
comment|/* Added in 1.5.4: the pixel depth should match the information returned by     * any call to png_read_update_info at this point.  Do not continue if we got     * this wrong.     */
if|if
condition|(
name|png_ptr
operator|->
name|info_rowbytes
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|info_rowbytes
operator|!=
name|PNG_ROWBYTES
argument_list|(
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal row size calculation error"
argument_list|)
expr_stmt|;
comment|/* Don't expect this to ever happen: */
if|if
condition|(
name|row_width
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal row width error"
argument_list|)
expr_stmt|;
comment|/* Preserve the last byte in cases where only part of it will be overwritten,     * the multiply below may overflow, we don't care because ANSI-C guarantees     * we get the low bits.     */
name|end_mask
operator|=
operator|(
name|pixel_depth
operator|*
name|row_width
operator|)
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|end_mask
operator|!=
literal|0
condition|)
block|{
comment|/* end_ptr == NULL is a flag to say do nothing */
name|end_ptr
operator|=
name|dp
operator|+
name|PNG_ROWBYTES
argument_list|(
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
operator|-
literal|1
expr_stmt|;
name|end_byte
operator|=
operator|*
name|end_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
comment|/* little-endian byte */
name|end_mask
operator|=
literal|0xff
operator|<<
name|end_mask
expr_stmt|;
else|else
comment|/* big-endian byte */
endif|#
directive|endif
name|end_mask
operator|=
literal|0xff
operator|>>
name|end_mask
expr_stmt|;
comment|/* end_mask is now the bits to *keep* from the destination row */
block|}
comment|/* For non-interlaced images this reduces to a memcpy(). A memcpy()     * will also happen if interlacing isn't supported or if the application     * does not call png_set_interlace_handling().  In the latter cases the     * caller just gets a sequence of the unexpanded rows from each interlace     * pass.     */
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
operator|&&
name|pass
operator|<
literal|6
operator|&&
operator|(
name|display
operator|==
literal|0
operator|||
comment|/* The following copies everything for 'display' on passes 0, 2 and 4. */
operator|(
name|display
operator|==
literal|1
operator|&&
operator|(
name|pass
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Narrow images may have no bits in a pass; the caller should handle        * this, but this test is cheap:        */
if|if
condition|(
name|row_width
operator|<=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pixel_depth
operator|<
literal|8
condition|)
block|{
comment|/* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit           * into 32 bits, then a single loop over the bytes using the four byte           * values in the 32-bit mask can be used.  For the 'display' option the           * expanded mask may also not require any masking within a byte.  To           * make this work the PACKSWAP option must be taken into account - it           * simply requires the pixels to be reversed in each byte.           *           * The 'regular' case requires a mask for each of the first 6 passes,           * the 'display' case does a copy for the even passes in the range           * 0..6.  This has already been handled in the test above.           *           * The masks are arranged as four bytes with the first byte to use in           * the lowest bits (little-endian) regardless of the order (PACKSWAP or           * not) of the pixels in each byte.           *           * NOTE: the whole of this logic depends on the caller of this function           * only calling it on rows appropriate to the pass.  This function only           * understands the 'x' logic; the 'y' logic is handled by the caller.           *           * The following defines allow generation of compile time constant bit           * masks for each pixel depth and each possibility of swapped or not           * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,           * is in the range 0..7; and the result is 1 if the pixel is to be           * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'           * for the block method.           *           * With some compilers a compile time expression of the general form:           *           *    (shift>= 32) ? (a>> (shift-32)) : (b>> shift)           *           * Produces warnings with values of 'shift' in the range 33 to 63           * because the right hand side of the ?: expression is evaluated by           * the compiler even though it isn't used.  Microsoft Visual C (various           * versions) and the Intel C compiler are known to do this.  To avoid           * this the following macros are used in 1.5.6.  This is a temporary           * solution to avoid destabilizing the code during the release process.           */
if|#
directive|if
name|PNG_USE_COMPILE_TIME_MASKS
DECL|macro|PNG_LSR
define|#
directive|define
name|PNG_LSR
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((x)>>((s)& 0x1f))
DECL|macro|PNG_LSL
define|#
directive|define
name|PNG_LSL
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((x)<<((s)& 0x1f))
else|#
directive|else
define|#
directive|define
name|PNG_LSR
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((x)>>(s))
define|#
directive|define
name|PNG_LSL
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((x)<<(s))
endif|#
directive|endif
DECL|macro|S_COPY
define|#
directive|define
name|S_COPY
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|)
value|(((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\            PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x))))& 1)
DECL|macro|B_COPY
define|#
directive|define
name|B_COPY
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|)
value|(((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\            PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x))))& 1)
comment|/* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is           * little endian - the first pixel is at bit 0 - however the extra           * parameter 's' can be set to cause the mask position to be swapped           * within each byte, to match the PNG format.  This is done by XOR of           * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.           */
DECL|macro|PIXEL_MASK
define|#
directive|define
name|PIXEL_MASK
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
define|\
value|(PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))
comment|/* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.           */
DECL|macro|S_MASKx
define|#
directive|define
name|S_MASKx
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
value|(S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
DECL|macro|B_MASKx
define|#
directive|define
name|B_MASKx
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
value|(B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
comment|/* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp           * cases the result needs replicating, for the 4-bpp case the above           * generates a full 32 bits.           */
DECL|macro|MASK_EXPAND
define|#
directive|define
name|MASK_EXPAND
parameter_list|(
name|m
parameter_list|,
name|d
parameter_list|)
value|((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
DECL|macro|S_MASK
define|#
directive|define
name|S_MASK
parameter_list|(
name|p
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
value|MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\             S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\             S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
DECL|macro|B_MASK
define|#
directive|define
name|B_MASK
parameter_list|(
name|p
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
value|MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\             B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\             B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
if|#
directive|if
name|PNG_USE_COMPILE_TIME_MASKS
comment|/* Utility macros to construct all the masks for a depth/swap           * combination.  The 's' parameter says whether the format is PNG           * (big endian bytes) or not.  Only the three odd-numbered passes are           * required for the display/block algorithm.           */
DECL|macro|S_MASKS
define|#
directive|define
name|S_MASKS
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|{ S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\             S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
DECL|macro|B_MASKS
define|#
directive|define
name|B_MASKS
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|{ B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
DECL|macro|DEPTH_INDEX
define|#
directive|define
name|DEPTH_INDEX
parameter_list|(
name|d
parameter_list|)
value|((d)==1?0:((d)==2?1:2))
comment|/* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and           * then pass:           */
specifier|static
name|PNG_CONST
name|png_uint_32
name|row_mask
index|[
literal|2
comment|/*PACKSWAP*/
index|]
index|[
literal|3
comment|/*depth*/
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/* Little-endian byte masks for PACKSWAP */
block|{
name|S_MASKS
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|S_MASKS
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|S_MASKS
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* Normal (big-endian byte) masks - PNG format */
block|{
name|S_MASKS
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|S_MASKS
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
name|S_MASKS
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
block|}
block|}
decl_stmt|;
comment|/* display_mask has only three entries for the odd passes, so index by           * pass>>1.           */
specifier|static
name|PNG_CONST
name|png_uint_32
name|display_mask
index|[
literal|2
index|]
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
comment|/* Little-endian byte masks for PACKSWAP */
block|{
name|B_MASKS
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|B_MASKS
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|B_MASKS
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* Normal (big-endian byte) masks - PNG format */
block|{
name|B_MASKS
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
name|B_MASKS
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
name|B_MASKS
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
block|}
block|}
decl_stmt|;
DECL|macro|MASK
define|#
directive|define
name|MASK
parameter_list|(
name|pass
parameter_list|,
name|depth
parameter_list|,
name|display
parameter_list|,
name|png
parameter_list|)
define|\
value|((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\                row_mask[png][DEPTH_INDEX(depth)][pass])
else|#
directive|else
comment|/* !PNG_USE_COMPILE_TIME_MASKS */
comment|/* This is the runtime alternative: it seems unlikely that this will           * ever be either smaller or faster than the compile time approach.           */
define|#
directive|define
name|MASK
parameter_list|(
name|pass
parameter_list|,
name|depth
parameter_list|,
name|display
parameter_list|,
name|png
parameter_list|)
define|\
value|((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))
endif|#
directive|endif
comment|/* !USE_COMPILE_TIME_MASKS */
comment|/* Use the appropriate mask to copy the required bits.  In some cases           * the byte mask will be 0 or 0xff; optimize these cases.  row_width is           * the number of pixels, but the code copies bytes, so it is necessary           * to special case the end.           */
name|png_uint_32
name|pixels_per_byte
init|=
literal|8
operator|/
name|pixel_depth
decl_stmt|;
name|png_uint_32
name|mask
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
name|mask
operator|=
name|MASK
argument_list|(
name|pass
argument_list|,
name|pixel_depth
argument_list|,
name|display
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mask
operator|=
name|MASK
argument_list|(
name|pass
argument_list|,
name|pixel_depth
argument_list|,
name|display
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|png_uint_32
name|m
decl_stmt|;
comment|/* It doesn't matter in the following if png_uint_32 has more than              * 32 bits because the high bits always match those in m<<24; it is,              * however, essential to use OR here, not +, because of this.              */
name|m
operator|=
name|mask
expr_stmt|;
name|mask
operator|=
operator|(
name|m
operator|>>
literal|8
operator|)
operator||
operator|(
name|m
operator|<<
literal|24
operator|)
expr_stmt|;
comment|/* rotate right to good compilers */
name|m
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
comment|/* something to copy */
block|{
if|if
condition|(
name|m
operator|!=
literal|0xff
condition|)
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|dp
operator|&
operator|~
name|m
operator|)
operator||
operator|(
operator|*
name|sp
operator|&
name|m
operator|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|dp
operator|=
operator|*
name|sp
expr_stmt|;
block|}
comment|/* NOTE: this may overwrite the last byte with garbage if the image              * is not an exact number of bytes wide; libpng has always done              * this.              */
if|if
condition|(
name|row_width
operator|<=
name|pixels_per_byte
condition|)
break|break;
comment|/* May need to restore part of the last byte */
name|row_width
operator|-=
name|pixels_per_byte
expr_stmt|;
operator|++
name|dp
expr_stmt|;
operator|++
name|sp
expr_stmt|;
block|}
block|}
else|else
comment|/* pixel_depth>= 8 */
block|{
name|unsigned
name|int
name|bytes_to_copy
decl_stmt|,
name|bytes_to_jump
decl_stmt|;
comment|/* Validate the depth - it must be a multiple of 8 */
if|if
condition|(
name|pixel_depth
operator|&
literal|7
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid user transform pixel depth"
argument_list|)
expr_stmt|;
name|pixel_depth
operator|>>=
literal|3
expr_stmt|;
comment|/* now in bytes */
name|row_width
operator|*=
name|pixel_depth
expr_stmt|;
comment|/* Regardless of pass number the Adam 7 interlace always results in a           * fixed number of pixels to copy then to skip.  There may be a           * different number of pixels to skip at the start though.           */
block|{
name|unsigned
name|int
name|offset
init|=
name|PNG_PASS_START_COL
argument_list|(
name|pass
argument_list|)
operator|*
name|pixel_depth
decl_stmt|;
name|row_width
operator|-=
name|offset
expr_stmt|;
name|dp
operator|+=
name|offset
expr_stmt|;
name|sp
operator|+=
name|offset
expr_stmt|;
block|}
comment|/* Work out the bytes to copy. */
if|if
condition|(
name|display
operator|!=
literal|0
condition|)
block|{
comment|/* When doing the 'block' algorithm the pixel in the pass gets              * replicated to adjacent pixels.  This is why the even (0,2,4,6)              * passes are skipped above - the entire expanded row is copied.              */
name|bytes_to_copy
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|(
literal|6
operator|-
name|pass
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|*
name|pixel_depth
expr_stmt|;
comment|/* But don't allow this number to exceed the actual row width. */
if|if
condition|(
name|bytes_to_copy
operator|>
name|row_width
condition|)
name|bytes_to_copy
operator|=
operator|(
name|unsigned
name|int
operator|)
comment|/*SAFE*/
name|row_width
expr_stmt|;
block|}
else|else
comment|/* normal row; Adam7 only ever gives us one pixel to copy. */
name|bytes_to_copy
operator|=
name|pixel_depth
expr_stmt|;
comment|/* In Adam7 there is a constant offset between where the pixels go. */
name|bytes_to_jump
operator|=
name|PNG_PASS_COL_OFFSET
argument_list|(
name|pass
argument_list|)
operator|*
name|pixel_depth
expr_stmt|;
comment|/* And simply copy these bytes.  Some optimization is possible here,           * depending on the value of 'bytes_to_copy'.  Special case the low           * byte counts, which we know to be frequent.           *           * Notice that these cases all 'return' rather than 'break' - this           * avoids an unnecessary test on whether to restore the last byte           * below.           */
switch|switch
condition|(
name|bytes_to_copy
condition|)
block|{
case|case
literal|1
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|dp
operator|=
operator|*
name|sp
expr_stmt|;
if|if
condition|(
name|row_width
operator|<=
name|bytes_to_jump
condition|)
return|return;
name|dp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|sp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|row_width
operator|-=
name|bytes_to_jump
expr_stmt|;
block|}
case|case
literal|2
case|:
comment|/* There is a possibility of a partial copy at the end here; this                 * slows the code down somewhat.                 */
do|do
block|{
name|dp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|0
index|]
operator|,
name|dp
index|[
literal|1
index|]
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|row_width
operator|<=
name|bytes_to_jump
condition|)
return|return;
name|sp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|dp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|row_width
operator|-=
name|bytes_to_jump
expr_stmt|;
block|}
do|while
condition|(
name|row_width
operator|>
literal|1
condition|)
do|;
comment|/* And there can only be one byte left at this point: */
operator|*
name|dp
operator|=
operator|*
name|sp
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* This can only be the RGB case, so each copy is exactly one                 * pixel and it is not necessary to check for a partial copy.                 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|0
index|]
operator|,
name|dp
index|[
literal|1
index|]
operator|=
name|sp
index|[
literal|1
index|]
operator|,
name|dp
index|[
literal|2
index|]
operator|=
name|sp
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|row_width
operator|<=
name|bytes_to_jump
condition|)
return|return;
name|sp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|dp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|row_width
operator|-=
name|bytes_to_jump
expr_stmt|;
block|}
default|default:
if|#
directive|if
name|PNG_ALIGN_TYPE
operator|!=
name|PNG_ALIGN_NONE
comment|/* Check for double byte alignment and, if possible, use a                 * 16-bit copy.  Don't attempt this for narrow images - ones that                 * are less than an interlace panel wide.  Don't attempt it for                 * wide bytes_to_copy either - use the memcpy there.                 */
if|if
condition|(
name|bytes_to_copy
operator|<
literal|16
comment|/*else use memcpy*/
operator|&&
name|png_isaligned
argument_list|(
name|dp
argument_list|,
name|png_uint_16
argument_list|)
operator|&&
name|png_isaligned
argument_list|(
name|sp
argument_list|,
name|png_uint_16
argument_list|)
operator|&&
name|bytes_to_copy
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|bytes_to_jump
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Everything is aligned for png_uint_16 copies, but try for                    * png_uint_32 first.                    */
if|if
condition|(
name|png_isaligned
argument_list|(
name|dp
argument_list|,
name|png_uint_32
argument_list|)
operator|!=
literal|0
operator|&&
name|png_isaligned
argument_list|(
name|sp
argument_list|,
name|png_uint_32
argument_list|)
operator|!=
literal|0
operator|&&
name|bytes_to_copy
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_32
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|bytes_to_jump
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_32
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|png_uint_32p
name|dp32
init|=
name|png_aligncast
argument_list|(
name|png_uint_32p
argument_list|,
name|dp
argument_list|)
decl_stmt|;
name|png_const_uint_32p
name|sp32
init|=
name|png_aligncastconst
argument_list|(
name|png_const_uint_32p
argument_list|,
name|sp
argument_list|)
decl_stmt|;
name|size_t
name|skip
init|=
operator|(
name|bytes_to_jump
operator|-
name|bytes_to_copy
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_32
argument_list|)
operator|)
decl_stmt|;
do|do
block|{
name|size_t
name|c
init|=
name|bytes_to_copy
decl_stmt|;
do|do
block|{
operator|*
name|dp32
operator|++
operator|=
operator|*
name|sp32
operator|++
expr_stmt|;
name|c
operator|-=
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_32
argument_list|)
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|row_width
operator|<=
name|bytes_to_jump
condition|)
return|return;
name|dp32
operator|+=
name|skip
expr_stmt|;
name|sp32
operator|+=
name|skip
expr_stmt|;
name|row_width
operator|-=
name|bytes_to_jump
expr_stmt|;
block|}
do|while
condition|(
name|bytes_to_copy
operator|<=
name|row_width
condition|)
do|;
comment|/* Get to here when the row_width truncates the final copy.                       * There will be 1-3 bytes left to copy, so don't try the                       * 16-bit loop below.                       */
name|dp
operator|=
operator|(
name|png_bytep
operator|)
name|dp32
expr_stmt|;
name|sp
operator|=
operator|(
name|png_const_bytep
operator|)
name|sp32
expr_stmt|;
do|do
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|row_width
operator|>
literal|0
condition|)
do|;
return|return;
block|}
comment|/* Else do it in 16-bit quantities, but only if the size is                    * not too large.                    */
else|else
block|{
name|png_uint_16p
name|dp16
init|=
name|png_aligncast
argument_list|(
name|png_uint_16p
argument_list|,
name|dp
argument_list|)
decl_stmt|;
name|png_const_uint_16p
name|sp16
init|=
name|png_aligncastconst
argument_list|(
name|png_const_uint_16p
argument_list|,
name|sp
argument_list|)
decl_stmt|;
name|size_t
name|skip
init|=
operator|(
name|bytes_to_jump
operator|-
name|bytes_to_copy
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
decl_stmt|;
do|do
block|{
name|size_t
name|c
init|=
name|bytes_to_copy
decl_stmt|;
do|do
block|{
operator|*
name|dp16
operator|++
operator|=
operator|*
name|sp16
operator|++
expr_stmt|;
name|c
operator|-=
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|row_width
operator|<=
name|bytes_to_jump
condition|)
return|return;
name|dp16
operator|+=
name|skip
expr_stmt|;
name|sp16
operator|+=
name|skip
expr_stmt|;
name|row_width
operator|-=
name|bytes_to_jump
expr_stmt|;
block|}
do|while
condition|(
name|bytes_to_copy
operator|<=
name|row_width
condition|)
do|;
comment|/* End of row - 1 byte left, bytes_to_copy> row_width: */
name|dp
operator|=
operator|(
name|png_bytep
operator|)
name|dp16
expr_stmt|;
name|sp
operator|=
operator|(
name|png_const_bytep
operator|)
name|sp16
expr_stmt|;
do|do
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|row_width
operator|>
literal|0
condition|)
do|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* ALIGN_TYPE code */
comment|/* The true default - use a memcpy: */
for|for
control|(
init|;
condition|;
control|)
block|{
name|memcpy
argument_list|(
name|dp
argument_list|,
name|sp
argument_list|,
name|bytes_to_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|row_width
operator|<=
name|bytes_to_jump
condition|)
return|return;
name|sp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|dp
operator|+=
name|bytes_to_jump
expr_stmt|;
name|row_width
operator|-=
name|bytes_to_jump
expr_stmt|;
if|if
condition|(
name|bytes_to_copy
operator|>
name|row_width
condition|)
name|bytes_to_copy
operator|=
operator|(
name|unsigned
name|int
operator|)
comment|/*SAFE*/
name|row_width
expr_stmt|;
block|}
block|}
comment|/* NOT REACHED*/
block|}
comment|/* pixel_depth>= 8 */
comment|/* Here if pixel_depth< 8 to check 'end_ptr' below. */
block|}
else|else
endif|#
directive|endif
comment|/* READ_INTERLACING */
comment|/* If here then the switch above wasn't used so just memcpy the whole row     * from the temporary row buffer (notice that this overwrites the end of the     * destination row if it is a partial byte.)     */
name|memcpy
argument_list|(
name|dp
argument_list|,
name|sp
argument_list|,
name|PNG_ROWBYTES
argument_list|(
name|pixel_depth
argument_list|,
name|row_width
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the overwritten bits from the last byte if necessary. */
if|if
condition|(
name|end_ptr
operator|!=
name|NULL
condition|)
operator|*
name|end_ptr
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|end_byte
operator|&
name|end_mask
operator|)
operator||
operator|(
operator|*
name|end_ptr
operator|&
operator|~
name|end_mask
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_INTERLACING_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_do_read_interlace
name|png_do_read_interlace
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|int
name|pass
parameter_list|,
name|png_uint_32
name|transformations
comment|/* Because these may affect the byte layout */
parameter_list|)
block|{
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|int
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_read_interlace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
name|NULL
operator|&&
name|row_info
operator|!=
name|NULL
condition|)
block|{
name|png_uint_32
name|final_width
decl_stmt|;
name|final_width
operator|=
name|row_info
operator|->
name|width
operator|*
name|png_pass_inc
index|[
name|pass
index|]
expr_stmt|;
switch|switch
condition|(
name|row_info
operator|->
name|pixel_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|-
literal|1
operator|)
operator|>>
literal|3
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|final_width
operator|-
literal|1
operator|)
operator|>>
literal|3
argument_list|)
decl_stmt|;
name|int
name|sshift
decl_stmt|,
name|dshift
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
name|png_byte
name|v
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
operator|(
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|final_width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|7
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|sshift
operator|=
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|dshift
operator|=
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|final_width
operator|+
literal|7
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|7
expr_stmt|;
name|s_inc
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|sshift
operator|)
operator|&
literal|0x01
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|dp
operator|&
operator|(
literal|0x7f7f
operator|>>
operator|(
literal|7
operator|-
name|dshift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|v
operator|<<
name|dshift
expr_stmt|;
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|dshift
operator|==
name|s_end
condition|)
block|{
name|dshift
operator|=
name|s_start
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
else|else
name|dshift
operator|+=
name|s_inc
expr_stmt|;
block|}
if|if
condition|(
name|sshift
operator|==
name|s_end
condition|)
block|{
name|sshift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|sshift
operator|+=
name|s_inc
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_uint_32
call|)
argument_list|(
operator|(
name|final_width
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
decl_stmt|;
name|int
name|sshift
decl_stmt|,
name|dshift
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
operator|(
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|final_width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|6
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|3
operator|-
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|3
operator|-
operator|(
operator|(
name|final_width
operator|+
literal|3
operator|)
operator|&
literal|0x03
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|6
expr_stmt|;
name|s_inc
operator|=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|v
decl_stmt|;
name|int
name|j
decl_stmt|;
name|v
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|sshift
operator|)
operator|&
literal|0x03
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|dp
operator|&
operator|(
literal|0x3f3f
operator|>>
operator|(
literal|6
operator|-
name|dshift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|v
operator|<<
name|dshift
expr_stmt|;
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|dshift
operator|==
name|s_end
condition|)
block|{
name|dshift
operator|=
name|s_start
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
else|else
name|dshift
operator|+=
name|s_inc
expr_stmt|;
block|}
if|if
condition|(
name|sshift
operator|==
name|s_end
condition|)
block|{
name|sshift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|sshift
operator|+=
name|s_inc
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|row_info
operator|->
name|width
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
operator|(
name|final_width
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|int
name|sshift
decl_stmt|,
name|dshift
decl_stmt|;
name|int
name|s_start
decl_stmt|,
name|s_end
decl_stmt|,
name|s_inc
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_PACKSWAP_SUPPORTED
if|if
condition|(
operator|(
name|transformations
operator|&
name|PNG_PACKSWAP
operator|)
operator|!=
literal|0
condition|)
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|final_width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|4
expr_stmt|;
name|s_end
operator|=
literal|0
expr_stmt|;
name|s_inc
operator|=
operator|-
literal|4
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|sshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
operator|(
operator|(
name|row_info
operator|->
name|width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|dshift
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|1
operator|-
operator|(
operator|(
name|final_width
operator|+
literal|1
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|s_start
operator|=
literal|0
expr_stmt|;
name|s_end
operator|=
literal|4
expr_stmt|;
name|s_inc
operator|=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|v
init|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|*
name|sp
operator|>>
name|sshift
operator|)
operator|&
literal|0x0f
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|int
name|tmp
init|=
operator|*
name|dp
operator|&
operator|(
literal|0xf0f
operator|>>
operator|(
literal|4
operator|-
name|dshift
operator|)
operator|)
decl_stmt|;
name|tmp
operator||=
name|v
operator|<<
name|dshift
expr_stmt|;
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|tmp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|dshift
operator|==
name|s_end
condition|)
block|{
name|dshift
operator|=
name|s_start
expr_stmt|;
name|dp
operator|--
expr_stmt|;
block|}
else|else
name|dshift
operator|+=
name|s_inc
expr_stmt|;
block|}
if|if
condition|(
name|sshift
operator|==
name|s_end
condition|)
block|{
name|sshift
operator|=
name|s_start
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
else|else
name|sshift
operator|+=
name|s_inc
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|png_size_t
name|pixel_bytes
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|>>
literal|3
operator|)
decl_stmt|;
name|png_bytep
name|sp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|row_info
operator|->
name|width
operator|-
literal|1
argument_list|)
operator|*
name|pixel_bytes
decl_stmt|;
name|png_bytep
name|dp
init|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|final_width
operator|-
literal|1
argument_list|)
operator|*
name|pixel_bytes
decl_stmt|;
name|int
name|jstop
init|=
name|png_pass_inc
index|[
name|pass
index|]
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|width
condition|;
name|i
operator|++
control|)
block|{
name|png_byte
name|v
index|[
literal|8
index|]
decl_stmt|;
comment|/* SAFE; pixel_depth does not exceed 64 */
name|int
name|j
decl_stmt|;
name|memcpy
argument_list|(
name|v
argument_list|,
name|sp
argument_list|,
name|pixel_bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jstop
condition|;
name|j
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dp
argument_list|,
name|v
argument_list|,
name|pixel_bytes
argument_list|)
expr_stmt|;
name|dp
operator|-=
name|pixel_bytes
expr_stmt|;
block|}
name|sp
operator|-=
name|pixel_bytes
expr_stmt|;
block|}
break|break;
block|}
block|}
name|row_info
operator|->
name|width
operator|=
name|final_width
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|final_width
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PNG_READ_PACKSWAP_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|transformations
argument_list|)
comment|/* Silence compiler warning */
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_INTERLACING */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_read_filter_row_sub
name|png_read_filter_row_sub
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|prev_row
parameter_list|)
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_size_t
name|istop
init|=
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|unsigned
name|int
name|bpp
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|png_bytep
name|rp
init|=
name|row
operator|+
name|bpp
decl_stmt|;
name|PNG_UNUSED
argument_list|(
argument|prev_row
argument_list|)
for|for
control|(
name|i
operator|=
name|bpp
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|rp
operator|-
name|bpp
operator|)
argument_list|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|png_read_filter_row_up
name|png_read_filter_row_up
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|prev_row
parameter_list|)
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_size_t
name|istop
init|=
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|png_bytep
name|rp
init|=
name|row
decl_stmt|;
name|png_const_bytep
name|pp
init|=
name|prev_row
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|png_read_filter_row_avg
name|png_read_filter_row_avg
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|prev_row
parameter_list|)
block|{
name|png_size_t
name|i
decl_stmt|;
name|png_bytep
name|rp
init|=
name|row
decl_stmt|;
name|png_const_bytep
name|pp
init|=
name|prev_row
decl_stmt|;
name|unsigned
name|int
name|bpp
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|png_size_t
name|istop
init|=
name|row_info
operator|->
name|rowbytes
operator|-
name|bpp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|/
literal|2
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|rp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|rp
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|pp
operator|++
operator|+
operator|*
operator|(
name|rp
operator|-
name|bpp
operator|)
argument_list|)
operator|/
literal|2
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|png_read_filter_row_paeth_1byte_pixel
name|png_read_filter_row_paeth_1byte_pixel
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|prev_row
parameter_list|)
block|{
name|png_bytep
name|rp_end
init|=
name|row
operator|+
name|row_info
operator|->
name|rowbytes
decl_stmt|;
name|int
name|a
decl_stmt|,
name|c
decl_stmt|;
comment|/* First pixel/byte */
name|c
operator|=
operator|*
name|prev_row
operator|++
expr_stmt|;
name|a
operator|=
operator|*
name|row
operator|+
name|c
expr_stmt|;
operator|*
name|row
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|a
expr_stmt|;
comment|/* Remainder */
while|while
condition|(
name|row
operator|<
name|rp_end
condition|)
block|{
name|int
name|b
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|pc
decl_stmt|,
name|p
decl_stmt|;
name|a
operator|&=
literal|0xff
expr_stmt|;
comment|/* From previous iteration or start */
name|b
operator|=
operator|*
name|prev_row
operator|++
expr_stmt|;
name|p
operator|=
name|b
operator|-
name|c
expr_stmt|;
name|pc
operator|=
name|a
operator|-
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USE_ABS
name|pa
operator|=
name|abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|+
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|p
operator|<
literal|0
condition|?
operator|-
name|p
else|:
name|p
expr_stmt|;
name|pb
operator|=
name|pc
operator|<
literal|0
condition|?
operator|-
name|pc
else|:
name|pc
expr_stmt|;
name|pc
operator|=
operator|(
name|p
operator|+
name|pc
operator|)
operator|<
literal|0
condition|?
operator|-
operator|(
name|p
operator|+
name|pc
operator|)
else|:
name|p
operator|+
name|pc
expr_stmt|;
endif|#
directive|endif
comment|/* Find the best predictor, the least of pa, pb, pc favoring the earlier        * ones in the case of a tie.        */
if|if
condition|(
name|pb
operator|<
name|pa
condition|)
name|pa
operator|=
name|pb
operator|,
name|a
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|pa
condition|)
name|a
operator|=
name|c
expr_stmt|;
comment|/* Calculate the current pixel in a, and move the previous row pixel to c        * for the next time round the loop        */
name|c
operator|=
name|b
expr_stmt|;
name|a
operator|+=
operator|*
name|row
expr_stmt|;
operator|*
name|row
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|a
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|png_read_filter_row_paeth_multibyte_pixel
name|png_read_filter_row_paeth_multibyte_pixel
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|prev_row
parameter_list|)
block|{
name|int
name|bpp
init|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|png_bytep
name|rp_end
init|=
name|row
operator|+
name|bpp
decl_stmt|;
comment|/* Process the first pixel in the row completely (this is the same as 'up'     * because there is only one candidate predictor for the first row).     */
while|while
condition|(
name|row
operator|<
name|rp_end
condition|)
block|{
name|int
name|a
init|=
operator|*
name|row
operator|+
operator|*
name|prev_row
operator|++
decl_stmt|;
operator|*
name|row
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|a
expr_stmt|;
block|}
comment|/* Remainder */
name|rp_end
operator|+=
name|row_info
operator|->
name|rowbytes
operator|-
name|bpp
expr_stmt|;
while|while
condition|(
name|row
operator|<
name|rp_end
condition|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|pc
decl_stmt|,
name|p
decl_stmt|;
name|c
operator|=
operator|*
operator|(
name|prev_row
operator|-
name|bpp
operator|)
expr_stmt|;
name|a
operator|=
operator|*
operator|(
name|row
operator|-
name|bpp
operator|)
expr_stmt|;
name|b
operator|=
operator|*
name|prev_row
operator|++
expr_stmt|;
name|p
operator|=
name|b
operator|-
name|c
expr_stmt|;
name|pc
operator|=
name|a
operator|-
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USE_ABS
name|pa
operator|=
name|abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|+
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|p
operator|<
literal|0
condition|?
operator|-
name|p
else|:
name|p
expr_stmt|;
name|pb
operator|=
name|pc
operator|<
literal|0
condition|?
operator|-
name|pc
else|:
name|pc
expr_stmt|;
name|pc
operator|=
operator|(
name|p
operator|+
name|pc
operator|)
operator|<
literal|0
condition|?
operator|-
operator|(
name|p
operator|+
name|pc
operator|)
else|:
name|p
operator|+
name|pc
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pb
operator|<
name|pa
condition|)
name|pa
operator|=
name|pb
operator|,
name|a
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|pa
condition|)
name|a
operator|=
name|c
expr_stmt|;
name|a
operator|+=
operator|*
name|row
expr_stmt|;
operator|*
name|row
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|a
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|png_init_filter_functions
name|png_init_filter_functions
parameter_list|(
name|png_structrp
name|pp
parameter_list|)
comment|/* This function is called once for every PNG image (except for PNG images     * that only use PNG_FILTER_VALUE_NONE for all rows) to set the     * implementations required to reverse the filtering of PNG rows.  Reversing     * the filter is the first transformation performed on the row data.  It is     * performed in place, therefore an implementation can be selected based on     * the image pixel format.  If the implementation depends on image width then     * take care to ensure that it works correctly if the image is interlaced -     * interlacing causes the actual row width to vary.     */
block|{
name|unsigned
name|int
name|bpp
init|=
operator|(
name|pp
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|pp
operator|->
name|read_filter
index|[
name|PNG_FILTER_VALUE_SUB
operator|-
literal|1
index|]
operator|=
name|png_read_filter_row_sub
expr_stmt|;
name|pp
operator|->
name|read_filter
index|[
name|PNG_FILTER_VALUE_UP
operator|-
literal|1
index|]
operator|=
name|png_read_filter_row_up
expr_stmt|;
name|pp
operator|->
name|read_filter
index|[
name|PNG_FILTER_VALUE_AVG
operator|-
literal|1
index|]
operator|=
name|png_read_filter_row_avg
expr_stmt|;
if|if
condition|(
name|bpp
operator|==
literal|1
condition|)
name|pp
operator|->
name|read_filter
index|[
name|PNG_FILTER_VALUE_PAETH
operator|-
literal|1
index|]
operator|=
name|png_read_filter_row_paeth_1byte_pixel
expr_stmt|;
else|else
name|pp
operator|->
name|read_filter
index|[
name|PNG_FILTER_VALUE_PAETH
operator|-
literal|1
index|]
operator|=
name|png_read_filter_row_paeth_multibyte_pixel
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_FILTER_OPTIMIZATIONS
comment|/* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to     * call to install hardware optimizations for the above functions; simply     * replace whatever elements of the pp->read_filter[] array with a hardware     * specific (or, for that matter, generic) optimization.     *     * To see an example of this examine what configure.ac does when     * --enable-arm-neon is specified on the command line.     */
name|PNG_FILTER_OPTIMIZATIONS
argument_list|(
name|pp
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_filter_row
name|png_read_filter_row
parameter_list|(
name|png_structrp
name|pp
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|png_const_bytep
name|prev_row
parameter_list|,
name|int
name|filter
parameter_list|)
block|{
comment|/* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define     * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic     * implementations.  See png_init_filter_functions above.     */
if|if
condition|(
name|filter
operator|>
name|PNG_FILTER_VALUE_NONE
operator|&&
name|filter
operator|<
name|PNG_FILTER_VALUE_LAST
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|read_filter
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|png_init_filter_functions
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|read_filter
index|[
name|filter
operator|-
literal|1
index|]
operator|(
name|row_info
operator|,
name|row
operator|,
name|prev_row
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SEQUENTIAL_READ_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_IDAT_data
name|png_read_IDAT_data
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|output
parameter_list|,
name|png_alloc_size_t
name|avail_out
parameter_list|)
block|{
comment|/* Loop reading IDATs and decompressing the result into output[avail_out] */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|output
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
comment|/* safety: set below */
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
name|avail_out
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|ret
decl_stmt|;
name|png_byte
name|tmpbuf
index|[
name|PNG_INFLATE_BUF_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|uInt
name|avail_in
decl_stmt|;
name|png_bytep
name|buffer
decl_stmt|;
while|while
condition|(
name|png_ptr
operator|->
name|idat_size
operator|==
literal|0
condition|)
block|{
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|=
name|png_read_chunk_header
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
comment|/* This is an error even in the 'check' case because the code just              * consumed a non-IDAT header.              */
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
operator|!=
name|png_IDAT
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough image data"
argument_list|)
expr_stmt|;
block|}
name|avail_in
operator|=
name|png_ptr
operator|->
name|IDAT_read_size
expr_stmt|;
if|if
condition|(
name|avail_in
operator|>
name|png_ptr
operator|->
name|idat_size
condition|)
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|idat_size
expr_stmt|;
comment|/* A PNG with a gradually increasing IDAT size will defeat this attempt           * to minimize memory usage by causing lots of re-allocs, but           * realistically doing IDAT_read_size re-allocs is not likely to be a           * big problem.           */
name|buffer
operator|=
name|png_read_buffer
argument_list|(
name|png_ptr
argument_list|,
name|avail_in
argument_list|,
literal|0
comment|/*error*/
argument_list|)
expr_stmt|;
name|png_crc_read
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|,
name|avail_in
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|idat_size
operator|-=
name|avail_in
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|buffer
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|avail_in
expr_stmt|;
block|}
comment|/* And set up the output side. */
if|if
condition|(
name|output
operator|!=
name|NULL
condition|)
comment|/* standard read */
block|{
name|uInt
name|out
init|=
name|ZLIB_IO_MAX
decl_stmt|;
if|if
condition|(
name|out
operator|>
name|avail_out
condition|)
name|out
operator|=
operator|(
name|uInt
operator|)
name|avail_out
expr_stmt|;
name|avail_out
operator|-=
name|out
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|out
expr_stmt|;
block|}
else|else
comment|/* after last row, checking for end */
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|tmpbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
expr_stmt|;
block|}
comment|/* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the        * process.  If the LZ stream is truncated the sequential reader will        * terminally damage the stream, above, by reading the chunk header of the        * following chunk (it then exits with png_error).        *        * TODO: deal more elegantly with truncated IDAT lists.        */
name|ret
operator|=
name|PNG_INFLATE
argument_list|(
name|png_ptr
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
comment|/* Take the unconsumed output back. */
if|if
condition|(
name|output
operator|!=
name|NULL
condition|)
name|avail_out
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
else|else
comment|/* avail_out counts the extra bytes */
name|avail_out
operator|+=
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
comment|/* Do this for safety; we won't read any more into this row. */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZSTREAM_ENDED
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|>
literal|0
operator|||
name|png_ptr
operator|->
name|idat_size
operator|>
literal|0
condition|)
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Extra compressed data"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|!=
name|NULL
condition|)
name|png_chunk_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
else|else
comment|/* checking */
block|{
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
do|while
condition|(
name|avail_out
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|avail_out
operator|>
literal|0
condition|)
block|{
comment|/* The stream ended before the image; this is the same as too few IDATs so        * should be handled the same way.        */
if|if
condition|(
name|output
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Not enough image data"
argument_list|)
expr_stmt|;
else|else
comment|/* the deflate stream contained extra data */
name|png_chunk_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too much image data"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_finish_IDAT
name|png_read_finish_IDAT
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* We don't need any more data and the stream should have ended, however the     * LZ end code may actually not have been processed.  In this case we must     * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk     * may still remain to be consumed.     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_ENDED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* The NULL causes png_read_IDAT_data to swallow any remaining bytes in        * the compressed stream, but the stream may be damaged too, so even after        * this call we may need to terminate the zstream ownership.        */
name|png_read_IDAT_data
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
comment|/* safety */
comment|/* Now clear everything out for safety; the following may not have been        * done.        */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_ENDED
operator|)
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_AFTER_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZSTREAM_ENDED
expr_stmt|;
block|}
block|}
comment|/* If the zstream has not been released do it now *and* terminate the reading     * of the final IDAT chunk.     */
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|==
name|png_IDAT
condition|)
block|{
comment|/* Always do this; the pointers otherwise point into the read buffer. */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* Now we no longer own the zstream. */
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
comment|/* The slightly weird semantics of the sequential IDAT reading is that we        * are always in or at the end of an IDAT chunk, so we always need to do a        * crc_finish here.  If idat_size is non-zero we also need to read the        * spurious bytes at the end of the chunk now.        */
operator|(
name|void
operator|)
name|png_crc_finish
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|idat_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_finish_row
name|png_read_finish_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_finish_row"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|row_number
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|<
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|row_number
operator|=
literal|0
expr_stmt|;
comment|/* TO DO: don't do this if prev_row isn't needed (requires        * read-ahead of the next row's filter byte.        */
name|memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>=
literal|7
condition|)
break|break;
name|png_ptr
operator|->
name|iwidth
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
block|}
else|else
comment|/* if (png_ptr->transformations& PNG_INTERLACE) */
break|break;
comment|/* libpng deinterlacing sees every row */
block|}
do|while
condition|(
name|png_ptr
operator|->
name|num_rows
operator|==
literal|0
operator|||
name|png_ptr
operator|->
name|iwidth
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|7
condition|)
return|return;
block|}
comment|/* Here after at the end of the last row of the last pass. */
name|png_read_finish_IDAT
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SEQUENTIAL_READ */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_read_start_row
name|png_read_start_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
name|int
name|max_pixel_depth
decl_stmt|;
name|png_size_t
name|row_bytes
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_read_start_row"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_TRANSFORMS_SUPPORTED
name|png_init_read_transformations
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|==
literal|0
condition|)
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
literal|0
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
literal|0
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
literal|0
index|]
expr_stmt|;
else|else
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|iwidth
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|iwidth
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
block|}
name|max_pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
comment|/* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of     * calculations to calculate the final pixel depth, then     * png_do_read_transforms actually does the transforms.  This means that the     * code which effectively calculates this value is actually repeated in three     * separate places.  They must all match.  Innocent changes to the order of     * transformations can and will break libpng in a way that causes memory     * overwrites.     *     * TODO: fix this.     */
ifdef|#
directive|ifdef
name|PNG_READ_PACK_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_PACK
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|max_pixel_depth
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|!=
literal|0
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<
literal|8
condition|)
name|max_pixel_depth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|!=
literal|0
condition|)
name|max_pixel_depth
operator|*=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|num_trans
operator|!=
literal|0
condition|)
block|{
name|max_pixel_depth
operator|*=
literal|4
expr_stmt|;
name|max_pixel_depth
operator|/=
literal|3
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_16_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND_16
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
comment|/* In fact it is an error if it isn't supported, but checking is        * the safe way.        */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|16
condition|)
name|max_pixel_depth
operator|*=
literal|2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|png_ptr
operator|->
name|transformations
operator|&=
operator|~
name|PNG_EXPAND_16
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_FILLER_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_FILLER
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|8
condition|)
name|max_pixel_depth
operator|=
literal|16
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|32
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|64
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_GRAY_TO_RGB_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_GRAY_TO_RGB
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|PNG_READ_EXPAND_SUPPORTED
operator|(
name|png_ptr
operator|->
name|num_trans
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_EXPAND
operator|)
operator|!=
literal|0
operator|)
operator|||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_READ_FILLER_SUPPORTED
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_FILLER
operator|)
operator|)
operator|!=
literal|0
operator|||
endif|#
directive|endif
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|16
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_pixel_depth
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|max_pixel_depth
operator|=
literal|32
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
condition|)
name|max_pixel_depth
operator|=
literal|64
expr_stmt|;
else|else
name|max_pixel_depth
operator|=
literal|48
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_USER_TRANSFORM_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_USER_TRANSFORM_PTR_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_USER_TRANSFORM
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|user_pixel_depth
init|=
name|png_ptr
operator|->
name|user_transform_depth
operator|*
name|png_ptr
operator|->
name|user_transform_channels
decl_stmt|;
if|if
condition|(
name|user_pixel_depth
operator|>
name|max_pixel_depth
condition|)
name|max_pixel_depth
operator|=
name|user_pixel_depth
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* This value is stored in png_struct and double checked in the row read     * code.     */
name|png_ptr
operator|->
name|maximum_pixel_depth
operator|=
operator|(
name|png_byte
operator|)
name|max_pixel_depth
expr_stmt|;
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|=
literal|0
expr_stmt|;
comment|/* calculated on demand */
comment|/* Align the width on the next larger 8 pixels.  Mainly used     * for interlacing     */
name|row_bytes
operator|=
operator|(
operator|(
name|png_ptr
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
operator|~
operator|(
operator|(
name|png_uint_32
operator|)
literal|7
operator|)
operator|)
expr_stmt|;
comment|/* Calculate the maximum bytes needed, adding a byte and a pixel     * for safety's sake     */
name|row_bytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|max_pixel_depth
argument_list|,
name|row_bytes
argument_list|)
operator|+
literal|1
operator|+
operator|(
operator|(
name|max_pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|row_bytes
operator|>
operator|(
name|png_uint_32
operator|)
literal|65536L
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"This image requires a row greater than 64KB"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|row_bytes
operator|+
literal|48
operator|>
name|png_ptr
operator|->
name|old_big_row_buf_size
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|big_row_buf
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|big_prev_row
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
condition|)
name|png_ptr
operator|->
name|big_row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|row_bytes
operator|+
literal|48
argument_list|)
expr_stmt|;
else|else
name|png_ptr
operator|->
name|big_row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|row_bytes
operator|+
literal|48
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|big_prev_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|row_bytes
operator|+
literal|48
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_ALIGNED_MEMORY_SUPPORTED
comment|/* Use 16-byte aligned memory for row_buf with at least 16 bytes       * of padding before and after row_buf; treat prev_row similarly.       * NOTE: the alignment is to the start of the pixels, one beyond the start       * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this       * was incorrect; the filter byte was aligned, which had the exact       * opposite effect of that intended.       */
block|{
name|png_bytep
name|temp
init|=
name|png_ptr
operator|->
name|big_row_buf
operator|+
literal|32
decl_stmt|;
name|int
name|extra
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|temp
operator|-
operator|(
name|png_bytep
operator|)
literal|0
operator|)
operator|&
literal|0x0f
argument_list|)
decl_stmt|;
name|png_ptr
operator|->
name|row_buf
operator|=
name|temp
operator|-
name|extra
operator|-
literal|1
comment|/*filter byte*/
expr_stmt|;
name|temp
operator|=
name|png_ptr
operator|->
name|big_prev_row
operator|+
literal|32
expr_stmt|;
name|extra
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|temp
operator|-
operator|(
name|png_bytep
operator|)
literal|0
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|prev_row
operator|=
name|temp
operator|-
name|extra
operator|-
literal|1
comment|/*filter byte*/
expr_stmt|;
block|}
else|#
directive|else
comment|/* Use 31 bytes of padding before and 17 bytes after row_buf. */
name|png_ptr
operator|->
name|row_buf
operator|=
name|png_ptr
operator|->
name|big_row_buf
operator|+
literal|31
expr_stmt|;
name|png_ptr
operator|->
name|prev_row
operator|=
name|png_ptr
operator|->
name|big_prev_row
operator|+
literal|31
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|old_big_row_buf_size
operator|=
name|row_bytes
operator|+
literal|48
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_MAX_MALLOC_64K
if|if
condition|(
name|png_ptr
operator|->
name|rowbytes
operator|>
literal|65535
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"This image requires a row greater than 64KB"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|->
name|rowbytes
operator|>
operator|(
name|PNG_SIZE_MAX
operator|-
literal|1
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Row has too many bytes to allocate in memory"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"width = %u,"
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"height = %u,"
argument_list|,
name|png_ptr
operator|->
name|height
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"iwidth = %u,"
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"num_rows = %u,"
argument_list|,
name|png_ptr
operator|->
name|num_rows
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"rowbytes = %lu,"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|png_ptr
operator|->
name|rowbytes
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"irowbytes = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|png_ptr
operator|->
name|iwidth
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* The sequential reader needs a buffer for IDAT, but the progressive reader     * does not, so free the read buffer now regardless; the sequential reader     * reallocates it on demand.     */
if|if
condition|(
name|png_ptr
operator|->
name|read_buffer
operator|!=
literal|0
condition|)
block|{
name|png_bytep
name|buffer
init|=
name|png_ptr
operator|->
name|read_buffer
decl_stmt|;
name|png_ptr
operator|->
name|read_buffer_size
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|read_buffer
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Finally claim the zstream for the inflate of the IDAT data, use the bits     * value from the stream (note that this will result in a fatal error if the     * IDAT stream has a bogus deflate header window_bits value, but this should     * not be happening any longer!)     */
if|if
condition|(
name|png_inflate_claim
argument_list|(
name|png_ptr
argument_list|,
name|png_IDAT
argument_list|)
operator|!=
name|Z_OK
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ROW_INIT
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ */
end_comment
end_unit
