begin_unit
begin_comment
comment|/* png.c - location for general purpose libpng functions  *  * Last changed in libpng 1.6.19 [November 12, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_comment
comment|/* Generate a compiler error if there is an old png.h in the search path. */
end_comment
begin_typedef
DECL|typedef|Your_png_h_is_not_version_1_6_19
typedef|typedef
name|png_libpng_version_1_6_19
name|Your_png_h_is_not_version_1_6_19
typedef|;
end_typedef
begin_comment
comment|/* Tells libpng that we have already handled the first "num_bytes" bytes  * of the PNG file signature.  If the PNG data is embedded into another  * stream we can set num_bytes = 8 so that libpng will not attempt to read  * or write any of the magic bytes before it starts on the IHDR.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sig_bytes
name|png_set_sig_bytes
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|num_bytes
parameter_list|)
block|{
name|unsigned
name|int
name|nb
init|=
operator|(
name|unsigned
name|int
operator|)
name|num_bytes
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_sig_bytes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|num_bytes
operator|<
literal|0
condition|)
name|nb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nb
operator|>
literal|8
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many bytes for PNG signature"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sig_bytes
operator|=
operator|(
name|png_byte
operator|)
name|nb
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Checks whether the supplied bytes match the PNG signature.  We allow  * checking less than the full 8-byte signature so that those apps that  * already read the first few bytes of a file to determine the file type  * can simply check the remaining bytes for extra assurance.  Returns  * an integer less than, equal to, or greater than zero if sig is found,  * respectively, to be less than, to match, or be greater than the correct  * PNG signature (this is the same behavior as strcmp, memcmp, etc).  */
end_comment
begin_function
name|int
name|PNGAPI
DECL|function|png_sig_cmp
name|png_sig_cmp
parameter_list|(
name|png_const_bytep
name|sig
parameter_list|,
name|png_size_t
name|start
parameter_list|,
name|png_size_t
name|num_to_check
parameter_list|)
block|{
name|png_byte
name|png_signature
index|[
literal|8
index|]
init|=
block|{
literal|137
block|,
literal|80
block|,
literal|78
block|,
literal|71
block|,
literal|13
block|,
literal|10
block|,
literal|26
block|,
literal|10
block|}
decl_stmt|;
if|if
condition|(
name|num_to_check
operator|>
literal|8
condition|)
name|num_to_check
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|num_to_check
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|start
operator|>
literal|7
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|start
operator|+
name|num_to_check
operator|>
literal|8
condition|)
name|num_to_check
operator|=
literal|8
operator|-
name|start
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|memcmp
argument_list|(
operator|&
name|sig
index|[
name|start
index|]
argument_list|,
operator|&
name|png_signature
index|[
name|start
index|]
argument_list|,
name|num_to_check
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Function to allocate memory for zlib */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|voidpf
comment|/* PRIVATE */
argument_list|,
argument|png_zalloc
argument_list|,
argument|(voidpf png_ptr, uInt items, uInt size)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_alloc_size_t
name|num_bytes
init|=
name|size
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|items
operator|>=
operator|(
operator|~
operator|(
name|png_alloc_size_t
operator|)
literal|0
operator|)
operator|/
name|size
condition|)
block|{
name|png_warning
argument_list|(
name|png_voidcast
argument_list|(
name|png_structrp
argument_list|,
name|png_ptr
argument_list|)
argument_list|,
literal|"Potential overflow in png_zalloc()"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|num_bytes
operator|*=
name|items
expr_stmt|;
return|return
name|png_malloc_warn
argument_list|(
name|png_voidcast
argument_list|(
name|png_structrp
argument_list|,
name|png_ptr
argument_list|)
argument_list|,
name|num_bytes
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* Function to free memory for zlib */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_zfree
name|png_zfree
parameter_list|(
name|voidpf
name|png_ptr
parameter_list|,
name|voidpf
name|ptr
parameter_list|)
block|{
name|png_free
argument_list|(
name|png_voidcast
argument_list|(
name|png_const_structrp
argument_list|,
name|png_ptr
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Reset the CRC variable to 32 bits of 1's.  Care must be taken  * in case CRC is> 32 bits to leave the top bits 0.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_reset_crc
name|png_reset_crc
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* The cast is safe because the crc is a 32-bit value. */
name|png_ptr
operator|->
name|crc
operator|=
operator|(
name|png_uint_32
operator|)
name|crc32
argument_list|(
literal|0
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Calculate the CRC over a section of data.  We can only pass as  * much data to this routine as the largest single buffer size.  We  * also check that this data will actually be used before going to the  * trouble of calculating it.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_calculate_crc
name|png_calculate_crc
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|ptr
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|int
name|need_crc
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|PNG_CHUNK_ANCILLARY
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_MASK
operator|)
operator|==
operator|(
name|PNG_FLAG_CRC_ANCILLARY_USE
operator||
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* critical */
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_CRITICAL_IGNORE
operator|)
operator|!=
literal|0
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 'uLong' is defined in zlib.h as unsigned long; this means that on some     * systems it is a 64-bit value.  crc32, however, returns 32 bits so the     * following cast is safe.  'uInt' may be no more than 16 bits, so it is     * necessary to perform a loop here.     */
if|if
condition|(
name|need_crc
operator|!=
literal|0
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
name|uLong
name|crc
init|=
name|png_ptr
operator|->
name|crc
decl_stmt|;
comment|/* Should never issue a warning */
do|do
block|{
name|uInt
name|safe_length
init|=
operator|(
name|uInt
operator|)
name|length
decl_stmt|;
ifndef|#
directive|ifndef
name|__COVERITY__
if|if
condition|(
name|safe_length
operator|==
literal|0
condition|)
name|safe_length
operator|=
operator|(
name|uInt
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* evil, but safe */
endif|#
directive|endif
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
name|ptr
argument_list|,
name|safe_length
argument_list|)
expr_stmt|;
comment|/* The following should never issue compiler warnings; if they do the           * target system has characteristics that will probably violate other           * assumptions within the libpng code.           */
name|ptr
operator|+=
name|safe_length
expr_stmt|;
name|length
operator|-=
name|safe_length
expr_stmt|;
block|}
do|while
condition|(
name|length
operator|>
literal|0
condition|)
do|;
comment|/* And the following is always safe because the crc is only 32 bits. */
name|png_ptr
operator|->
name|crc
operator|=
operator|(
name|png_uint_32
operator|)
name|crc
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Check a user supplied version number, called from both read and write  * functions that create a png_struct.  */
end_comment
begin_function
name|int
DECL|function|png_user_version_check
name|png_user_version_check
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|user_png_ver
parameter_list|)
block|{
comment|/* Libpng versions 1.0.0 and later are binary compatible if the version       * string matches through the second '.'; we must recompile any       * applications that use any older library version.       */
if|if
condition|(
name|user_png_ver
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|found_dots
init|=
literal|0
decl_stmt|;
do|do
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|user_png_ver
index|[
name|i
index|]
operator|!=
name|PNG_LIBPNG_VER_STRING
index|[
name|i
index|]
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_LIBRARY_MISMATCH
expr_stmt|;
if|if
condition|(
name|user_png_ver
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
name|found_dots
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|found_dots
operator|<
literal|2
operator|&&
name|user_png_ver
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|PNG_LIBPNG_VER_STRING
index|[
name|i
index|]
operator|!=
literal|0
condition|)
do|;
block|}
else|else
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_LIBRARY_MISMATCH
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_LIBRARY_MISMATCH
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|m
index|[
literal|128
index|]
decl_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
operator|(
sizeof|sizeof
name|m
operator|)
argument_list|,
name|pos
argument_list|,
literal|"Application built with libpng-"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
operator|(
sizeof|sizeof
name|m
operator|)
argument_list|,
name|pos
argument_list|,
name|user_png_ver
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
operator|(
sizeof|sizeof
name|m
operator|)
argument_list|,
name|pos
argument_list|,
literal|" but running with "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
operator|(
sizeof|sizeof
name|m
operator|)
argument_list|,
name|pos
argument_list|,
name|PNG_LIBPNG_VER_STRING
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|pos
argument_list|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
name|png_ptr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* Success return. */
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* Generic function to create a png_struct for either read or write - this  * contains the common initialization.  */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_structp
comment|/* PRIVATE */
argument_list|,
argument|png_create_png_struct
argument_list|,
argument|(png_const_charp user_png_ver, png_voidp error_ptr,     png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,     png_malloc_ptr malloc_fn, png_free_ptr free_fn)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_struct
name|create_struct
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|jmp_buf
name|create_jmp_buf
decl_stmt|;
endif|#
directive|endif
comment|/* This temporary stack-allocated structure is used to provide a place to     * build enough context to allow the user provided memory allocator (if any)     * to be called.     */
name|memset
argument_list|(
operator|&
name|create_struct
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
name|create_struct
operator|)
argument_list|)
expr_stmt|;
comment|/* Added at libpng-1.2.6 */
ifdef|#
directive|ifdef
name|PNG_USER_LIMITS_SUPPORTED
name|create_struct
operator|.
name|user_width_max
operator|=
name|PNG_USER_WIDTH_MAX
expr_stmt|;
name|create_struct
operator|.
name|user_height_max
operator|=
name|PNG_USER_HEIGHT_MAX
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_CHUNK_CACHE_MAX
comment|/* Added at libpng-1.2.43 and 1.4.0 */
name|create_struct
operator|.
name|user_chunk_cache_max
operator|=
name|PNG_USER_CHUNK_CACHE_MAX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_USER_CHUNK_MALLOC_MAX
comment|/* Added at libpng-1.2.43 and 1.4.1, required only for read but exists        * in png_struct regardless.        */
name|create_struct
operator|.
name|user_chunk_malloc_max
operator|=
name|PNG_USER_CHUNK_MALLOC_MAX
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* The following two API calls simply set fields in png_struct, so it is safe     * to do them now even though error handling is not yet set up.     */
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_set_mem_fn
argument_list|(
operator|&
name|create_struct
argument_list|,
name|mem_ptr
argument_list|,
name|malloc_fn
argument_list|,
name|free_fn
argument_list|)
expr_stmt|;
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|mem_ptr
argument_list|)
name|PNG_UNUSED
argument_list|(
argument|malloc_fn
argument_list|)
name|PNG_UNUSED
argument_list|(
argument|free_fn
argument_list|)
endif|#
directive|endif
comment|/* (*error_fn) can return control to the caller after the error_ptr is set,     * this will result in a memory leak unless the error_fn does something     * extremely sophisticated.  The design lacks merit but is implicit in the     * API.     */
name|png_set_error_fn
argument_list|(
operator|&
name|create_struct
argument_list|,
name|error_ptr
argument_list|,
name|error_fn
argument_list|,
name|warn_fn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|create_jmp_buf
argument_list|)
condition|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* Temporarily fake out the longjmp information until we have           * successfully completed this function.  This only works if we have           * setjmp() support compiled in, but it is safe - this stuff should           * never happen.           */
name|create_struct
operator|.
name|jmp_buf_ptr
operator|=
operator|&
name|create_jmp_buf
expr_stmt|;
name|create_struct
operator|.
name|jmp_buf_size
operator|=
literal|0
expr_stmt|;
comment|/*stack allocation*/
name|create_struct
operator|.
name|longjmp_fn
operator|=
name|longjmp
expr_stmt|;
endif|#
directive|endif
comment|/* Call the general version checker (shared with read and write code):           */
if|if
condition|(
name|png_user_version_check
argument_list|(
operator|&
name|create_struct
argument_list|,
name|user_png_ver
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|png_structrp
name|png_ptr
init|=
name|png_voidcast
argument_list|(
name|png_structrp
argument_list|,
name|png_malloc_warn
argument_list|(
operator|&
name|create_struct
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|png_ptr
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* png_ptr->zstream holds a back-pointer to the png_struct, so                 * this can only be done now:                 */
name|create_struct
operator|.
name|zstream
operator|.
name|zalloc
operator|=
name|png_zalloc
expr_stmt|;
name|create_struct
operator|.
name|zstream
operator|.
name|zfree
operator|=
name|png_zfree
expr_stmt|;
name|create_struct
operator|.
name|zstream
operator|.
name|opaque
operator|=
name|png_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
comment|/* Eliminate the local error handling: */
name|create_struct
operator|.
name|jmp_buf_ptr
operator|=
name|NULL
expr_stmt|;
name|create_struct
operator|.
name|jmp_buf_size
operator|=
literal|0
expr_stmt|;
name|create_struct
operator|.
name|longjmp_fn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|*
name|png_ptr
operator|=
name|create_struct
expr_stmt|;
comment|/* This is the successful return point */
return|return
name|png_ptr
return|;
block|}
block|}
block|}
comment|/* A longjmp because of a bug in the application storage allocator or a     * simple failure to allocate the png_struct.     */
return|return
name|NULL
return|;
block|}
end_block
begin_comment
comment|/* Allocate the memory for an info_struct for the application. */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_infop
argument_list|,
argument|PNGAPI png_create_info_struct
argument_list|,
argument|(png_const_structrp png_ptr)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_inforp
name|info_ptr
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_create_info_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Use the internal API that does not (or at least should not) error out, so     * that this call always returns ok.  The application typically sets up the     * error handling *after* creating the info_struct because this is the way it     * has always been done in 'example.c'.     */
name|info_ptr
operator|=
name|png_voidcast
argument_list|(
name|png_inforp
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|info_ptr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|info_ptr
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_block
begin_comment
comment|/* This function frees the memory associated with a single info struct.  * Normally, one would use either png_destroy_read_struct() or  * png_destroy_write_struct() to free an info struct, but this may be  * useful for some applications.  From libpng 1.6.0 this function is also used  * internally to implement the png_info release part of the 'struct' destroy  * APIs.  This ensures that all possible approaches free the same data (all of  * it).  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_destroy_info_struct
name|png_destroy_info_struct
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_infopp
name|info_ptr_ptr
parameter_list|)
block|{
name|png_inforp
name|info_ptr
init|=
name|NULL
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_destroy_info_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|info_ptr_ptr
operator|!=
name|NULL
condition|)
name|info_ptr
operator|=
operator|*
name|info_ptr_ptr
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Do this first in case of an error below; if the app implements its own        * memory management this can lead to png_free calling png_error, which        * will abort this routine and return control to the app error handler.        * An infinite loop may result if it then tries to free the same info        * ptr.        */
operator|*
name|info_ptr_ptr
operator|=
name|NULL
expr_stmt|;
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ALL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|info_ptr
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Initialize the info structure.  This is now an internal function (0.89)  * and applications using it are urged to use png_create_info_struct()  * instead.  Use deprecated in 1.6.0, internal use removed (used internally it  * is just a memset).  *  * NOTE: it is almost inconceivable that this API is used because it bypasses  * the user-memory mechanism and the user error handling/warning mechanisms in  * those cases where it does anything other than a memset.  */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|void
argument_list|,
argument|PNGAPI png_info_init_3
argument_list|,
argument|(png_infopp ptr_ptr, png_size_t png_info_struct_size)
argument_list|,
argument|PNG_DEPRECATED
argument_list|)
end_macro
begin_block
block|{
name|png_inforp
name|info_ptr
init|=
operator|*
name|ptr_ptr
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_info_init_3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|png_info
argument_list|)
operator|)
operator|>
name|png_info_struct_size
condition|)
block|{
operator|*
name|ptr_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* The following line is why this API should not be used: */
name|free
argument_list|(
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|=
name|png_voidcast
argument_list|(
name|png_inforp
argument_list|,
name|png_malloc_base
argument_list|(
name|NULL
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|info_ptr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
operator|*
name|ptr_ptr
operator|=
name|info_ptr
expr_stmt|;
block|}
comment|/* Set everything to 0 */
name|memset
argument_list|(
name|info_ptr
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|info_ptr
operator|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* The following API is not called internally */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_data_freer
name|png_data_freer
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|int
name|freer
parameter_list|,
name|png_uint_32
name|mask
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_data_freer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|freer
operator|==
name|PNG_DESTROY_WILL_FREE_DATA
condition|)
name|info_ptr
operator|->
name|free_me
operator||=
name|mask
expr_stmt|;
elseif|else
if|if
condition|(
name|freer
operator|==
name|PNG_USER_WILL_FREE_DATA
condition|)
name|info_ptr
operator|->
name|free_me
operator|&=
operator|~
name|mask
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown freer parameter in png_data_freer"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_free_data
name|png_free_data
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|,
name|png_uint_32
name|mask
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_free_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* Free text item num or (if num == -1) all text items */
if|if
condition|(
name|info_ptr
operator|->
name|text
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_TEXT
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_text
condition|;
name|i
operator|++
control|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|num_text
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
comment|/* Free any tRNS entry */
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_TRNS
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_tRNS
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|trans_alpha
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|trans_alpha
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|num_trans
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
comment|/* Free any sCAL entry */
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_SCAL
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_width
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_height
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_width
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_height
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_sCAL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
comment|/* Free any pCAL entry */
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_PCAL
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_purpose
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_units
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_purpose
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|pcal_units
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_params
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|pcal_nparams
condition|;
name|i
operator|++
control|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_params
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
operator|=
name|NULL
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_pCAL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
comment|/* Free any profile entry */
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_ICCP
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_name
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_profile
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|iccp_name
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|iccp_profile
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_iCCP
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
comment|/* Free a given sPLT entry, or (if num == -1) all sPLT entries */
if|if
condition|(
name|info_ptr
operator|->
name|splt_palettes
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_SPLT
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|entries
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|splt_palettes_num
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|i
index|]
operator|.
name|entries
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes_num
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_sPLT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_UNKN
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|num
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|num
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|unknown_chunks_num
condition|;
name|i
operator|++
control|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|i
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks_num
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
comment|/* Free any hIST entry */
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_HIST
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|hist
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|hist
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_hIST
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Free any PLTE entry that was internally allocated */
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_PLTE
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|palette
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|palette
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_PLTE
expr_stmt|;
name|info_ptr
operator|->
name|num_palette
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
comment|/* Free any image bits attached to the info structure */
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|PNG_FREE_ROWS
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|row_pointers
operator|!=
literal|0
condition|)
block|{
name|png_uint_32
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|info_ptr
operator|->
name|height
condition|;
name|row
operator|++
control|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
index|[
name|row
index|]
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|row_pointers
operator|=
name|NULL
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_IDAT
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
name|mask
operator|&=
operator|~
name|PNG_FREE_MUL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ || WRITE */
end_comment
begin_comment
comment|/* This function returns a pointer to the io_ptr associated with the user  * functions.  The application should free any memory associated with this  * pointer before png_write_destroy() or png_read_destroy() are called.  */
end_comment
begin_function
name|png_voidp
name|PNGAPI
DECL|function|png_get_io_ptr
name|png_get_io_ptr
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|png_ptr
operator|->
name|io_ptr
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
end_ifdef
begin_comment
comment|/* Initialize the default input/output functions for the PNG file.  If you  * use your own read or write routines, you can call either png_set_read_fn()  * or png_set_write_fn() instead of png_init_io().  If you have defined  * PNG_NO_STDIO or otherwise disabled PNG_STDIO_SUPPORTED, you must use a  * function of your own because "FILE *" isn't necessarily available.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_init_io
name|png_init_io
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_FILE_p
name|fp
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_init_io"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|io_ptr
operator|=
operator|(
name|png_voidp
operator|)
name|fp
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SAVE_INT_32_SUPPORTED
end_ifdef
begin_comment
comment|/* PNG signed integers are saved in 32-bit 2's complement format.  ANSI C-90  * defines a cast of a signed integer to an unsigned integer either to preserve  * the value, if it is positive, or to calculate:  *  *     (UNSIGNED_MAX+1) + integer  *  * Where UNSIGNED_MAX is the appropriate maximum unsigned value, so when the  * negative integral value is added the result will be an unsigned value  * correspnding to the 2's complement representation.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_save_int_32
name|png_save_int_32
parameter_list|(
name|png_bytep
name|buf
parameter_list|,
name|png_int_32
name|i
parameter_list|)
block|{
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
end_ifdef
begin_comment
comment|/* Convert the supplied time into an RFC 1123 string suitable for use in  * a "Creation Time" or other text-based time string.  */
end_comment
begin_function
name|int
name|PNGAPI
DECL|function|png_convert_to_rfc1123_buffer
name|png_convert_to_rfc1123_buffer
parameter_list|(
name|char
name|out
index|[
literal|29
index|]
parameter_list|,
name|png_const_timep
name|ptime
parameter_list|)
block|{
specifier|static
name|PNG_CONST
name|char
name|short_months
index|[
literal|12
index|]
index|[
literal|4
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptime
operator|->
name|year
operator|>
literal|9999
comment|/* RFC1123 limitation */
operator|||
name|ptime
operator|->
name|month
operator|==
literal|0
operator|||
name|ptime
operator|->
name|month
operator|>
literal|12
operator|||
name|ptime
operator|->
name|day
operator|==
literal|0
operator|||
name|ptime
operator|->
name|day
operator|>
literal|31
operator|||
name|ptime
operator|->
name|hour
operator|>
literal|23
operator|||
name|ptime
operator|->
name|minute
operator|>
literal|59
operator|||
name|ptime
operator|->
name|second
operator|>
literal|60
condition|)
return|return
literal|0
return|;
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|number_buf
index|[
literal|5
index|]
decl_stmt|;
comment|/* enough for a four-digit year */
DECL|macro|APPEND_STRING
define|#
directive|define
name|APPEND_STRING
parameter_list|(
name|string
parameter_list|)
value|pos = png_safecat(out, 29, pos, (string))
DECL|macro|APPEND_NUMBER
define|#
directive|define
name|APPEND_NUMBER
parameter_list|(
name|format
parameter_list|,
name|value
parameter_list|)
define|\
value|APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
DECL|macro|APPEND
define|#
directive|define
name|APPEND
parameter_list|(
name|ch
parameter_list|)
value|if (pos< 28) out[pos++] = (ch)
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|day
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|APPEND_STRING
argument_list|(
name|short_months
index|[
operator|(
name|ptime
operator|->
name|month
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_u
argument_list|,
name|ptime
operator|->
name|year
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_02u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|hour
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_02u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|minute
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_02u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|second
argument_list|)
expr_stmt|;
name|APPEND_STRING
argument_list|(
literal|" +0000"
argument_list|)
expr_stmt|;
comment|/* This reliably terminates the buffer */
name|PNG_UNUSED
argument_list|(
argument|pos
argument_list|)
DECL|macro|APPEND
undef|#
directive|undef
name|APPEND
DECL|macro|APPEND_NUMBER
undef|#
directive|undef
name|APPEND_NUMBER
DECL|macro|APPEND_STRING
undef|#
directive|undef
name|APPEND_STRING
block|}
return|return
literal|1
return|;
block|}
end_function
begin_if
if|#
directive|if
name|PNG_LIBPNG_VER
operator|<
literal|10700
end_if
begin_comment
comment|/* To do: remove the following from libpng-1.7 */
end_comment
begin_comment
comment|/* Original API that uses a private buffer in png_struct.  * Deprecated because it causes png_struct to carry a spurious temporary  * buffer (png_struct::time_buffer), better to have the caller pass this in.  */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_convert_to_rfc1123
name|png_convert_to_rfc1123
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_timep
name|ptime
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* The only failure above if png_ptr != NULL is from an invalid ptime */
if|if
condition|(
name|png_convert_to_rfc1123_buffer
argument_list|(
name|png_ptr
operator|->
name|time_buffer
argument_list|,
name|ptime
argument_list|)
operator|==
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring invalid time value"
argument_list|)
expr_stmt|;
else|else
return|return
name|png_ptr
operator|->
name|time_buffer
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LIBPNG_VER< 10700 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TIME_RFC1123 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ || WRITE */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_copyright
name|png_get_copyright
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|)
block|{
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
ifdef|#
directive|ifdef
name|PNG_STRING_COPYRIGHT
return|return
name|PNG_STRING_COPYRIGHT
else|#
directive|else
ifdef|#
directive|ifdef
name|__STDC__
return|return
name|PNG_STRING_NEWLINE
expr|\
literal|"libpng version 1.6.19 - November 12, 2015"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1998-2015 Glenn Randers-Pehrson"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1996-1997 Andreas Dilger"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc."
expr|\
name|PNG_STRING_NEWLINE
return|;
else|#
directive|else
return|return
literal|"libpng version 1.6.19 - November 12, 2015\       Copyright (c) 1998-2015 Glenn Randers-Pehrson\       Copyright (c) 1996-1997 Andreas Dilger\       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc."
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* The following return the library version as a short string in the  * format 1.0.0 through 99.99.99zz.  To get the version of *.h files  * used with your application, print out PNG_LIBPNG_VER_STRING, which  * is defined in png.h.  * Note: now there is no difference between png_get_libpng_ver() and  * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,  * it is guaranteed that png.c uses the correct version of png.h.  */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_libpng_ver
name|png_get_libpng_ver
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Version of *.c files used when building libpng */
return|return
name|png_get_header_ver
argument_list|(
name|png_ptr
argument_list|)
return|;
block|}
end_function
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_header_ver
name|png_get_header_ver
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Version of *.h files used when building libpng */
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
return|return
name|PNG_LIBPNG_VER_STRING
return|;
block|}
end_function
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_header_version
name|png_get_header_version
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Returns longer string containing both version and date */
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
ifdef|#
directive|ifdef
name|__STDC__
return|return
name|PNG_HEADER_VERSION_STRING
ifndef|#
directive|ifndef
name|PNG_READ_SUPPORTED
literal|" (NO READ SUPPORT)"
endif|#
directive|endif
name|PNG_STRING_NEWLINE
return|;
else|#
directive|else
return|return
name|PNG_HEADER_VERSION_STRING
return|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
end_ifdef
begin_comment
comment|/* NOTE: this routine is not used internally! */
end_comment
begin_comment
comment|/* Build a grayscale palette.  Palette is assumed to be 1<< bit_depth  * large of png_color.  This lets grayscale images be treated as  * paletted.  Most useful for gamma correction and simplification  * of code.  This API is not used internally.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_build_grayscale_palette
name|png_build_grayscale_palette
parameter_list|(
name|int
name|bit_depth
parameter_list|,
name|png_colorp
name|palette
parameter_list|)
block|{
name|int
name|num_palette
decl_stmt|;
name|int
name|color_inc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_build_grayscale_palette"
argument_list|)
expr_stmt|;
if|if
condition|(
name|palette
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
name|num_palette
operator|=
literal|2
expr_stmt|;
name|color_inc
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|num_palette
operator|=
literal|4
expr_stmt|;
name|color_inc
operator|=
literal|0x55
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|num_palette
operator|=
literal|16
expr_stmt|;
name|color_inc
operator|=
literal|0x11
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|num_palette
operator|=
literal|256
expr_stmt|;
name|color_inc
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|num_palette
operator|=
literal|0
expr_stmt|;
name|color_inc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
literal|0
init|;
name|i
operator|<
name|num_palette
condition|;
name|i
operator|++
operator|,
name|v
operator|+=
name|color_inc
control|)
block|{
name|palette
index|[
name|i
index|]
operator|.
name|red
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|green
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|palette
index|[
name|i
index|]
operator|.
name|blue
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|v
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
end_ifdef
begin_function
name|int
name|PNGAPI
DECL|function|png_handle_as_unknown
name|png_handle_as_unknown
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_name
parameter_list|)
block|{
comment|/* Check chunk_name and return "keep" value if it's on the list, else 0 */
name|png_const_bytep
name|p
decl_stmt|,
name|p_end
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|chunk_name
operator|==
name|NULL
operator|||
name|png_ptr
operator|->
name|num_chunk_list
operator|==
literal|0
condition|)
return|return
name|PNG_HANDLE_CHUNK_AS_DEFAULT
return|;
name|p_end
operator|=
name|png_ptr
operator|->
name|chunk_list
expr_stmt|;
name|p
operator|=
name|p_end
operator|+
name|png_ptr
operator|->
name|num_chunk_list
operator|*
literal|5
expr_stmt|;
comment|/* beyond end */
comment|/* The code is the fifth byte after each four byte string.  Historically this     * code was always searched from the end of the list, this is no longer     * necessary because the 'set' routine handles duplicate entries correcty.     */
do|do
comment|/* num_chunk_list> 0, so at least one */
block|{
name|p
operator|-=
literal|5
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|chunk_name
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
index|[
literal|4
index|]
return|;
block|}
do|while
condition|(
name|p
operator|>
name|p_end
condition|)
do|;
comment|/* This means that known chunks should be processed and unknown chunks should     * be handled according to the value of png_ptr->unknown_default; this can be     * confusing because, as a result, there are two levels of defaulting for     * unknown chunks.     */
return|return
name|PNG_HANDLE_CHUNK_AS_DEFAULT
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
argument_list|)
end_if
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_chunk_unknown_handling
name|png_chunk_unknown_handling
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|)
block|{
name|png_byte
name|chunk_string
index|[
literal|5
index|]
decl_stmt|;
name|PNG_CSTRING_FROM_CHUNK
argument_list|(
name|chunk_string
argument_list|,
name|chunk_name
argument_list|)
expr_stmt|;
return|return
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|chunk_string
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SET_UNKNOWN_CHUNKS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* This function, added to libpng-1.0.6g, is untested. */
end_comment
begin_function
name|int
name|PNGAPI
DECL|function|png_reset_zstream
name|png_reset_zstream
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* WARNING: this resets the window bits to the maximum! */
return|return
operator|(
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ */
end_comment
begin_comment
comment|/* This function was added to libpng-1.0.7 */
end_comment
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_access_version_number
name|png_access_version_number
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Version of *.c files used when building libpng */
return|return
operator|(
operator|(
name|png_uint_32
operator|)
name|PNG_LIBPNG_VER
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Ensure that png_ptr->zstream.msg holds some appropriate error message string.  * If it doesn't 'ret' is used to set it to something appropriate, even in cases  * like Z_OK or Z_STREAM_END where the error code is apparently a success code.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_zstream_error
name|png_zstream_error
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
comment|/* Translate 'ret' into an appropriate error string, priority is given to the     * one in zstream if set.  This always returns a string, even in cases like     * Z_OK or Z_STREAM_END where the error code is a success code.     */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|ret
condition|)
block|{
default|default:
case|case
name|Z_OK
case|:
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"unexpected zlib return code"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_STREAM_END
case|:
comment|/* Normal exit */
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"unexpected end of LZ stream"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_NEED_DICT
case|:
comment|/* This means the deflate stream did not have a dictionary; this           * indicates a bogus PNG.           */
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"missing LZ dictionary"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_ERRNO
case|:
comment|/* gz APIs only: should not happen */
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"zlib IO error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_STREAM_ERROR
case|:
comment|/* internal libpng error */
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"bad parameters to zlib"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_DATA_ERROR
case|:
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"damaged LZ stream"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"insufficient memory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_BUF_ERROR
case|:
comment|/* End of input or output; not a problem if the caller is doing           * incremental read or write.           */
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"truncated"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_VERSION_ERROR
case|:
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"unsupported zlib version"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_UNEXPECTED_ZLIB_RETURN
case|:
comment|/* Compile errors here mean that zlib now uses the value co-opted in           * pngpriv.h for PNG_UNEXPECTED_ZLIB_RETURN; update the switch above           * and change pngpriv.h.  Note that this message is "... return",           * whereas the default/Z_OK one is "... return code".           */
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"unexpected zlib return"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/* png_convert_size: a PNGAPI but no longer in png.h, so deleted  * at libpng 1.5.5!  */
end_comment
begin_comment
comment|/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* always set if COLORSPACE */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_colorspace_check_gamma
name|png_colorspace_check_gamma
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_fixed_point
name|gAMA
parameter_list|,
name|int
name|from
parameter_list|)
comment|/* This is called to check a new gamma value against an existing one.  The     * routine returns false if the new gamma value should not be written.     *     * 'from' says where the new gamma value comes from:     *     *    0: the new gamma value is the libpng estimate for an ICC profile     *    1: the new gamma value comes from a gAMA chunk     *    2: the new gamma value comes from an sRGB chunk     */
block|{
name|png_fixed_point
name|gtest
decl_stmt|;
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_GAMMA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_muldiv
argument_list|(
operator|&
name|gtest
argument_list|,
name|colorspace
operator|->
name|gamma
argument_list|,
name|PNG_FP_1
argument_list|,
name|gAMA
argument_list|)
operator|==
literal|0
operator|||
name|png_gamma_significant
argument_list|(
name|gtest
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Either this is an sRGB image, in which case the calculated gamma        * approximation should match, or this is an image with a profile and the        * value libpng calculates for the gamma of the profile does not match the        * value recorded in the file.  The former, sRGB, case is an error, the        * latter is just a warning.        */
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_FROM_sRGB
operator|)
operator|!=
literal|0
operator|||
name|from
operator|==
literal|2
condition|)
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"gamma value does not match sRGB"
argument_list|,
name|PNG_CHUNK_ERROR
argument_list|)
expr_stmt|;
comment|/* Do not overwrite an sRGB value */
return|return
name|from
operator|==
literal|2
return|;
block|}
else|else
comment|/* sRGB tag not involved */
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"gamma value does not match libpng estimate"
argument_list|,
name|PNG_CHUNK_WARNING
argument_list|)
expr_stmt|;
return|return
name|from
operator|==
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_colorspace_set_gamma
name|png_colorspace_set_gamma
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_fixed_point
name|gAMA
parameter_list|)
block|{
comment|/* Changed in libpng-1.5.4 to limit the values to ensure overflow can't     * occur.  Since the fixed point representation is asymetrical it is     * possible for 1/gamma to overflow the limit of 21474 and this means the     * gamma value must be at least 5/100000 and hence at most 20000.0.  For     * safety the limits here are a little narrower.  The values are 0.00016 to     * 6250.0, which are truly ridiculous gamma values (and will produce     * displays that are all black or all white.)     *     * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk     * handling code, which only required the value to be>0.     */
name|png_const_charp
name|errmsg
decl_stmt|;
if|if
condition|(
name|gAMA
operator|<
literal|16
operator|||
name|gAMA
operator|>
literal|625000000
condition|)
name|errmsg
operator|=
literal|"gamma value out of range"
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_READ_gAMA_SUPPORTED
comment|/* Allow the application to set the gamma value more than once */
elseif|else
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_IS_READ_STRUCT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_FROM_gAMA
operator|)
operator|!=
literal|0
condition|)
name|errmsg
operator|=
literal|"duplicate"
expr_stmt|;
endif|#
directive|endif
comment|/* Do nothing if the colorspace is already invalid */
elseif|else
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
return|return;
else|else
block|{
if|if
condition|(
name|png_colorspace_check_gamma
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|gAMA
argument_list|,
literal|1
comment|/*from gAMA*/
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Store this gamma value. */
name|colorspace
operator|->
name|gamma
operator|=
name|gAMA
expr_stmt|;
name|colorspace
operator|->
name|flags
operator||=
operator|(
name|PNG_COLORSPACE_HAVE_GAMMA
operator||
name|PNG_COLORSPACE_FROM_gAMA
operator|)
expr_stmt|;
block|}
comment|/* At present if the check_gamma test fails the gamma of the colorspace is        * not updated however the colorspace is not invalidated.  This        * corresponds to the case where the existing gamma comes from an sRGB        * chunk or profile.  An error message has already been output.        */
return|return;
block|}
comment|/* Error exit - errmsg has been set. */
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
name|errmsg
argument_list|,
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_colorspace_sync_info
name|png_colorspace_sync_info
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Everything is invalid */
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
operator|(
name|PNG_INFO_gAMA
operator||
name|PNG_INFO_cHRM
operator||
name|PNG_INFO_sRGB
operator||
name|PNG_INFO_iCCP
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_COLORSPACE_SUPPORTED
comment|/* Clean up the iCCP profile now if it won't be used. */
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ICCP
argument_list|,
operator|-
literal|1
comment|/*not used*/
argument_list|)
expr_stmt|;
else|#
directive|else
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_COLORSPACE_SUPPORTED
comment|/* Leave the INFO_iCCP flag set if the pngset.c code has already set        * it; this allows a PNG to contain a profile which matches sRGB and        * yet still have that profile retrievable by the application.        */
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_MATCHES_sRGB
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_sRGB
expr_stmt|;
else|else
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_sRGB
expr_stmt|;
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_ENDPOINTS
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_cHRM
expr_stmt|;
else|else
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_cHRM
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|info_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_GAMMA
operator|)
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|valid
operator||=
name|PNG_INFO_gAMA
expr_stmt|;
else|else
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_gAMA
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_colorspace_sync
name|png_colorspace_sync
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_inforp
name|info_ptr
parameter_list|)
block|{
if|if
condition|(
name|info_ptr
operator|==
name|NULL
condition|)
comment|/* reduce code size; check here not in the caller */
return|return;
name|info_ptr
operator|->
name|colorspace
operator|=
name|png_ptr
operator|->
name|colorspace
expr_stmt|;
name|png_colorspace_sync_info
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* GAMMA */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_COLORSPACE_SUPPORTED
end_ifdef
begin_comment
comment|/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for  * cHRM, as opposed to using chromaticities.  These internal APIs return  * non-zero on a parameter error.  The X, Y and Z values are required to be  * positive and less than 1.0.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_xy_from_XYZ
name|png_xy_from_XYZ
parameter_list|(
name|png_xy
modifier|*
name|xy
parameter_list|,
specifier|const
name|png_XYZ
modifier|*
name|XYZ
parameter_list|)
block|{
name|png_int_32
name|d
decl_stmt|,
name|dwhite
decl_stmt|,
name|whiteX
decl_stmt|,
name|whiteY
decl_stmt|;
name|d
operator|=
name|XYZ
operator|->
name|red_X
operator|+
name|XYZ
operator|->
name|red_Y
operator|+
name|XYZ
operator|->
name|red_Z
expr_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|redx
argument_list|,
name|XYZ
operator|->
name|red_X
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|redy
argument_list|,
name|XYZ
operator|->
name|red_Y
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|dwhite
operator|=
name|d
expr_stmt|;
name|whiteX
operator|=
name|XYZ
operator|->
name|red_X
expr_stmt|;
name|whiteY
operator|=
name|XYZ
operator|->
name|red_Y
expr_stmt|;
name|d
operator|=
name|XYZ
operator|->
name|green_X
operator|+
name|XYZ
operator|->
name|green_Y
operator|+
name|XYZ
operator|->
name|green_Z
expr_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|greenx
argument_list|,
name|XYZ
operator|->
name|green_X
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|greeny
argument_list|,
name|XYZ
operator|->
name|green_Y
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|dwhite
operator|+=
name|d
expr_stmt|;
name|whiteX
operator|+=
name|XYZ
operator|->
name|green_X
expr_stmt|;
name|whiteY
operator|+=
name|XYZ
operator|->
name|green_Y
expr_stmt|;
name|d
operator|=
name|XYZ
operator|->
name|blue_X
operator|+
name|XYZ
operator|->
name|blue_Y
operator|+
name|XYZ
operator|->
name|blue_Z
expr_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|bluex
argument_list|,
name|XYZ
operator|->
name|blue_X
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|bluey
argument_list|,
name|XYZ
operator|->
name|blue_Y
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|dwhite
operator|+=
name|d
expr_stmt|;
name|whiteX
operator|+=
name|XYZ
operator|->
name|blue_X
expr_stmt|;
name|whiteY
operator|+=
name|XYZ
operator|->
name|blue_Y
expr_stmt|;
comment|/* The reference white is simply the sum of the end-point (X,Y,Z) vectors,     * thus:     */
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|whitex
argument_list|,
name|whiteX
argument_list|,
name|PNG_FP_1
argument_list|,
name|dwhite
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|whitey
argument_list|,
name|whiteY
argument_list|,
name|PNG_FP_1
argument_list|,
name|dwhite
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_XYZ_from_xy
name|png_XYZ_from_xy
parameter_list|(
name|png_XYZ
modifier|*
name|XYZ
parameter_list|,
specifier|const
name|png_xy
modifier|*
name|xy
parameter_list|)
block|{
name|png_fixed_point
name|red_inverse
decl_stmt|,
name|green_inverse
decl_stmt|,
name|blue_scale
decl_stmt|;
name|png_fixed_point
name|left
decl_stmt|,
name|right
decl_stmt|,
name|denominator
decl_stmt|;
comment|/* Check xy and, implicitly, z.  Note that wide gamut color spaces typically     * have end points with 0 tristimulus values (these are impossible end     * points, but they are used to cover the possible colors).  We check     * xy->whitey against 5, not 0, to avoid a possible integer overflow.     */
if|if
condition|(
name|xy
operator|->
name|redx
operator|<
literal|0
operator|||
name|xy
operator|->
name|redx
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|->
name|redy
operator|<
literal|0
operator|||
name|xy
operator|->
name|redy
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|->
name|redx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|->
name|greenx
operator|<
literal|0
operator|||
name|xy
operator|->
name|greenx
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|->
name|greeny
operator|<
literal|0
operator|||
name|xy
operator|->
name|greeny
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|->
name|greenx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|->
name|bluex
operator|<
literal|0
operator|||
name|xy
operator|->
name|bluex
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|->
name|bluey
operator|<
literal|0
operator|||
name|xy
operator|->
name|bluey
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|->
name|bluex
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|->
name|whitex
operator|<
literal|0
operator|||
name|xy
operator|->
name|whitex
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|->
name|whitey
operator|<
literal|5
operator|||
name|xy
operator|->
name|whitey
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|->
name|whitex
condition|)
return|return
literal|1
return|;
comment|/* The reverse calculation is more difficult because the original tristimulus     * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8     * derived values were recorded in the cHRM chunk;     * (red,green,blue,white)x(x,y).  This loses one degree of freedom and     * therefore an arbitrary ninth value has to be introduced to undo the     * original transformations.     *     * Think of the original end-points as points in (X,Y,Z) space.  The     * chromaticity values (c) have the property:     *     *           C     *   c = ---------     *       X + Y + Z     *     * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the     * three chromaticity values (x,y,z) for each end-point obey the     * relationship:     *     *   x + y + z = 1     *     * This describes the plane in (X,Y,Z) space that intersects each axis at the     * value 1.0; call this the chromaticity plane.  Thus the chromaticity     * calculation has scaled each end-point so that it is on the x+y+z=1 plane     * and chromaticity is the intersection of the vector from the origin to the     * (X,Y,Z) value with the chromaticity plane.     *     * To fully invert the chromaticity calculation we would need the three     * end-point scale factors, (red-scale, green-scale, blue-scale), but these     * were not recorded.  Instead we calculated the reference white (X,Y,Z) and     * recorded the chromaticity of this.  The reference white (X,Y,Z) would have     * given all three of the scale factors since:     *     *    color-C = color-c * color-scale     *    white-C = red-C + green-C + blue-C     *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale     *     * But cHRM records only white-x and white-y, so we have lost the white scale     * factor:     *     *    white-C = white-c*white-scale     *     * To handle this the inverse transformation makes an arbitrary assumption     * about white-scale:     *     *    Assume: white-Y = 1.0     *    Hence:  white-scale = 1/white-y     *    Or:     red-Y + green-Y + blue-Y = 1.0     *     * Notice the last statement of the assumption gives an equation in three of     * the nine values we want to calculate.  8 more equations come from the     * above routine as summarised at the top above (the chromaticity     * calculation):     *     *    Given: color-x = color-X / (color-X + color-Y + color-Z)     *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0     *     * This is 9 simultaneous equations in the 9 variables "color-C" and can be     * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix     * determinants, however this is not as bad as it seems because only 28 of     * the total of 90 terms in the various matrices are non-zero.  Nevertheless     * Cramer's rule is notoriously numerically unstable because the determinant     * calculation involves the difference of large, but similar, numbers.  It is     * difficult to be sure that the calculation is stable for real world values     * and it is certain that it becomes unstable where the end points are close     * together.     *     * So this code uses the perhaps slightly less optimal but more     * understandable and totally obvious approach of calculating color-scale.     *     * This algorithm depends on the precision in white-scale and that is     * (1/white-y), so we can immediately see that as white-y approaches 0 the     * accuracy inherent in the cHRM chunk drops off substantially.     *     * libpng arithmetic: a simple inversion of the above equations     * ------------------------------------------------------------     *     *    white_scale = 1/white-y     *    white-X = white-x * white-scale     *    white-Y = 1.0     *    white-Z = (1 - white-x - white-y) * white_scale     *     *    white-C = red-C + green-C + blue-C     *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale     *     * This gives us three equations in (red-scale,green-scale,blue-scale) where     * all the coefficients are now known:     *     *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale     *       = white-x/white-y     *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1     *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale     *       = (1 - white-x - white-y)/white-y     *     * In the last equation color-z is (1 - color-x - color-y) so we can add all     * three equations together to get an alternative third:     *     *    red-scale + green-scale + blue-scale = 1/white-y = white-scale     *     * So now we have a Cramer's rule solution where the determinants are just     * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve     * multiplication of three coefficients so we can't guarantee to avoid     * overflow in the libpng fixed point representation.  Using Cramer's rule in     * floating point is probably a good choice here, but it's not an option for     * fixed point.  Instead proceed to simplify the first two equations by     * eliminating what is likely to be the largest value, blue-scale:     *     *    blue-scale = white-scale - red-scale - green-scale     *     * Hence:     *     *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =     *                (white-x - blue-x)*white-scale     *     *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =     *                1 - blue-y*white-scale     *     * And now we can trivially solve for (red-scale,green-scale):     *     *    green-scale =     *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale     *                -----------------------------------------------------------     *                                  green-x - blue-x     *     *    red-scale =     *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale     *                ---------------------------------------------------------     *                                  red-y - blue-y     *     * Hence:     *     *    red-scale =     *          ( (green-x - blue-x) * (white-y - blue-y) -     *            (green-y - blue-y) * (white-x - blue-x) ) / white-y     * -------------------------------------------------------------------------     *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)     *     *    green-scale =     *          ( (red-y - blue-y) * (white-x - blue-x) -     *            (red-x - blue-x) * (white-y - blue-y) ) / white-y     * -------------------------------------------------------------------------     *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)     *     * Accuracy:     * The input values have 5 decimal digits of accuracy.  The values are all in     * the range 0< value< 1, so simple products are in the same range but may     * need up to 10 decimal digits to preserve the original precision and avoid     * underflow.  Because we are using a 32-bit signed representation we cannot     * match this; the best is a little over 9 decimal digits, less than 10.     *     * The approach used here is to preserve the maximum precision within the     * signed representation.  Because the red-scale calculation above uses the     * difference between two products of values that must be in the range -1..+1     * it is sufficient to divide the product by 7; ceil(100,000/32767*2).  The     * factor is irrelevant in the calculation because it is applied to both     * numerator and denominator.     *     * Note that the values of the differences of the products of the     * chromaticities in the above equations tend to be small, for example for     * the sRGB chromaticities they are:     *     * red numerator:    -0.04751     * green numerator:  -0.08788     * denominator:      -0.2241 (without white-y multiplication)     *     *  The resultant Y coefficients from the chromaticities of some widely used     *  color space definitions are (to 15 decimal places):     *     *  sRGB     *    0.212639005871510 0.715168678767756 0.072192315360734     *  Kodak ProPhoto     *    0.288071128229293 0.711843217810102 0.000085653960605     *  Adobe RGB     *    0.297344975250536 0.627363566255466 0.075291458493998     *  Adobe Wide Gamut RGB     *    0.258728243040113 0.724682314948566 0.016589442011321     */
comment|/* By the argument, above overflow should be impossible here. The return     * value of 2 indicates an internal error to the caller.     */
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|left
argument_list|,
name|xy
operator|->
name|greenx
operator|-
name|xy
operator|->
name|bluex
argument_list|,
name|xy
operator|->
name|redy
operator|-
name|xy
operator|->
name|bluey
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|right
argument_list|,
name|xy
operator|->
name|greeny
operator|-
name|xy
operator|->
name|bluey
argument_list|,
name|xy
operator|->
name|redx
operator|-
name|xy
operator|->
name|bluex
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
name|denominator
operator|=
name|left
operator|-
name|right
expr_stmt|;
comment|/* Now find the red numerator. */
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|left
argument_list|,
name|xy
operator|->
name|greenx
operator|-
name|xy
operator|->
name|bluex
argument_list|,
name|xy
operator|->
name|whitey
operator|-
name|xy
operator|->
name|bluey
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|right
argument_list|,
name|xy
operator|->
name|greeny
operator|-
name|xy
operator|->
name|bluey
argument_list|,
name|xy
operator|->
name|whitex
operator|-
name|xy
operator|->
name|bluex
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
comment|/* Overflow is possible here and it indicates an extreme set of PNG cHRM     * chunk values.  This calculation actually returns the reciprocal of the     * scale value because this allows us to delay the multiplication of white-y     * into the denominator, which tends to produce a small number.     */
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|red_inverse
argument_list|,
name|xy
operator|->
name|whitey
argument_list|,
name|denominator
argument_list|,
name|left
operator|-
name|right
argument_list|)
operator|==
literal|0
operator|||
name|red_inverse
operator|<=
name|xy
operator|->
name|whitey
comment|/* r+g+b scales = white scale */
condition|)
return|return
literal|1
return|;
comment|/* Similarly for green_inverse: */
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|left
argument_list|,
name|xy
operator|->
name|redy
operator|-
name|xy
operator|->
name|bluey
argument_list|,
name|xy
operator|->
name|whitex
operator|-
name|xy
operator|->
name|bluex
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|right
argument_list|,
name|xy
operator|->
name|redx
operator|-
name|xy
operator|->
name|bluex
argument_list|,
name|xy
operator|->
name|whitey
operator|-
name|xy
operator|->
name|bluey
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|green_inverse
argument_list|,
name|xy
operator|->
name|whitey
argument_list|,
name|denominator
argument_list|,
name|left
operator|-
name|right
argument_list|)
operator|==
literal|0
operator|||
name|green_inverse
operator|<=
name|xy
operator|->
name|whitey
condition|)
return|return
literal|1
return|;
comment|/* And the blue scale, the checks above guarantee this can't overflow but it     * can still produce 0 for extreme cHRM values.     */
name|blue_scale
operator|=
name|png_reciprocal
argument_list|(
name|xy
operator|->
name|whitey
argument_list|)
operator|-
name|png_reciprocal
argument_list|(
name|red_inverse
argument_list|)
operator|-
name|png_reciprocal
argument_list|(
name|green_inverse
argument_list|)
expr_stmt|;
if|if
condition|(
name|blue_scale
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* And fill in the png_XYZ: */
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|red_X
argument_list|,
name|xy
operator|->
name|redx
argument_list|,
name|PNG_FP_1
argument_list|,
name|red_inverse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|red_Y
argument_list|,
name|xy
operator|->
name|redy
argument_list|,
name|PNG_FP_1
argument_list|,
name|red_inverse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|red_Z
argument_list|,
name|PNG_FP_1
operator|-
name|xy
operator|->
name|redx
operator|-
name|xy
operator|->
name|redy
argument_list|,
name|PNG_FP_1
argument_list|,
name|red_inverse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|green_X
argument_list|,
name|xy
operator|->
name|greenx
argument_list|,
name|PNG_FP_1
argument_list|,
name|green_inverse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|green_Y
argument_list|,
name|xy
operator|->
name|greeny
argument_list|,
name|PNG_FP_1
argument_list|,
name|green_inverse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|green_Z
argument_list|,
name|PNG_FP_1
operator|-
name|xy
operator|->
name|greenx
operator|-
name|xy
operator|->
name|greeny
argument_list|,
name|PNG_FP_1
argument_list|,
name|green_inverse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blue_X
argument_list|,
name|xy
operator|->
name|bluex
argument_list|,
name|blue_scale
argument_list|,
name|PNG_FP_1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blue_Y
argument_list|,
name|xy
operator|->
name|bluey
argument_list|,
name|blue_scale
argument_list|,
name|PNG_FP_1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blue_Z
argument_list|,
name|PNG_FP_1
operator|-
name|xy
operator|->
name|bluex
operator|-
name|xy
operator|->
name|bluey
argument_list|,
name|blue_scale
argument_list|,
name|PNG_FP_1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/*success*/
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_XYZ_normalize
name|png_XYZ_normalize
parameter_list|(
name|png_XYZ
modifier|*
name|XYZ
parameter_list|)
block|{
name|png_int_32
name|Y
decl_stmt|;
if|if
condition|(
name|XYZ
operator|->
name|red_Y
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|green_Y
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|blue_Y
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|red_X
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|green_X
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|blue_X
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|red_Z
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|green_Z
operator|<
literal|0
operator|||
name|XYZ
operator|->
name|blue_Z
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.     * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore     * relying on addition of two positive values producing a negative one is not     * safe.     */
name|Y
operator|=
name|XYZ
operator|->
name|red_Y
expr_stmt|;
if|if
condition|(
literal|0x7fffffff
operator|-
name|Y
operator|<
name|XYZ
operator|->
name|green_X
condition|)
return|return
literal|1
return|;
name|Y
operator|+=
name|XYZ
operator|->
name|green_Y
expr_stmt|;
if|if
condition|(
literal|0x7fffffff
operator|-
name|Y
operator|<
name|XYZ
operator|->
name|blue_X
condition|)
return|return
literal|1
return|;
name|Y
operator|+=
name|XYZ
operator|->
name|blue_Y
expr_stmt|;
if|if
condition|(
name|Y
operator|!=
name|PNG_FP_1
condition|)
block|{
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|red_X
argument_list|,
name|XYZ
operator|->
name|red_X
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|red_Y
argument_list|,
name|XYZ
operator|->
name|red_Y
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|red_Z
argument_list|,
name|XYZ
operator|->
name|red_Z
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|green_X
argument_list|,
name|XYZ
operator|->
name|green_X
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|green_Y
argument_list|,
name|XYZ
operator|->
name|green_Y
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|green_Z
argument_list|,
name|XYZ
operator|->
name|green_Z
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blue_X
argument_list|,
name|XYZ
operator|->
name|blue_X
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blue_Y
argument_list|,
name|XYZ
operator|->
name|blue_Y
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blue_Z
argument_list|,
name|XYZ
operator|->
name|blue_Z
argument_list|,
name|PNG_FP_1
argument_list|,
name|Y
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_colorspace_endpoints_match
name|png_colorspace_endpoints_match
parameter_list|(
specifier|const
name|png_xy
modifier|*
name|xy1
parameter_list|,
specifier|const
name|png_xy
modifier|*
name|xy2
parameter_list|,
name|int
name|delta
parameter_list|)
block|{
comment|/* Allow an error of +/-0.01 (absolute value) on each chromaticity */
if|if
condition|(
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|whitex
argument_list|,
name|xy2
operator|->
name|whitex
argument_list|,
name|delta
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|whitey
argument_list|,
name|xy2
operator|->
name|whitey
argument_list|,
name|delta
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|redx
argument_list|,
name|xy2
operator|->
name|redx
argument_list|,
name|delta
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|redy
argument_list|,
name|xy2
operator|->
name|redy
argument_list|,
name|delta
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|greenx
argument_list|,
name|xy2
operator|->
name|greenx
argument_list|,
name|delta
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|greeny
argument_list|,
name|xy2
operator|->
name|greeny
argument_list|,
name|delta
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|bluex
argument_list|,
name|xy2
operator|->
name|bluex
argument_list|,
name|delta
argument_list|)
operator|||
name|PNG_OUT_OF_RANGE
argument_list|(
name|xy1
operator|->
name|bluey
argument_list|,
name|xy2
operator|->
name|bluey
argument_list|,
name|delta
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM  * chunk chromaticities.  Earlier checks used to simply look for the overflow  * condition (where the determinant of the matrix to solve for XYZ ends up zero  * because the chromaticity values are not all distinct.)  Despite this it is  * theoretically possible to produce chromaticities that are apparently valid  * but that rapidly degrade to invalid, potentially crashing, sets because of  * arithmetic inaccuracies when calculations are performed on them.  The new  * check is to round-trip xy -> XYZ -> xy and then check that the result is  * within a small percentage of the original.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_colorspace_check_xy
name|png_colorspace_check_xy
parameter_list|(
name|png_XYZ
modifier|*
name|XYZ
parameter_list|,
specifier|const
name|png_xy
modifier|*
name|xy
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|png_xy
name|xy_test
decl_stmt|;
comment|/* As a side-effect this routine also returns the XYZ endpoints. */
name|result
operator|=
name|png_XYZ_from_xy
argument_list|(
name|XYZ
argument_list|,
name|xy
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
name|result
operator|=
name|png_xy_from_XYZ
argument_list|(
operator|&
name|xy_test
argument_list|,
name|XYZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
name|png_colorspace_endpoints_match
argument_list|(
name|xy
argument_list|,
operator|&
name|xy_test
argument_list|,
literal|5
comment|/*actually, the math is pretty accurate*/
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Too much slip */
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* This is the check going the other way.  The XYZ is modified to normalize it  * (another side-effect) and the xy chromaticities are returned.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_colorspace_check_XYZ
name|png_colorspace_check_XYZ
parameter_list|(
name|png_xy
modifier|*
name|xy
parameter_list|,
name|png_XYZ
modifier|*
name|XYZ
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|png_XYZ
name|XYZtemp
decl_stmt|;
name|result
operator|=
name|png_XYZ_normalize
argument_list|(
name|XYZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
name|result
operator|=
name|png_xy_from_XYZ
argument_list|(
name|xy
argument_list|,
name|XYZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
name|XYZtemp
operator|=
operator|*
name|XYZ
expr_stmt|;
return|return
name|png_colorspace_check_xy
argument_list|(
operator|&
name|XYZtemp
argument_list|,
name|xy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Used to check for an endpoint match against sRGB */
end_comment
begin_decl_stmt
DECL|variable|sRGB_xy
specifier|static
specifier|const
name|png_xy
name|sRGB_xy
init|=
comment|/* From ITU-R BT.709-3 */
block|{
comment|/* color      x       y */
comment|/* red   */
literal|64000
block|,
literal|33000
block|,
comment|/* green */
literal|30000
block|,
literal|60000
block|,
comment|/* blue  */
literal|15000
block|,
literal|6000
block|,
comment|/* white */
literal|31270
block|,
literal|32900
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|int
DECL|function|png_colorspace_set_xy_and_XYZ
name|png_colorspace_set_xy_and_XYZ
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
specifier|const
name|png_xy
modifier|*
name|xy
parameter_list|,
specifier|const
name|png_XYZ
modifier|*
name|XYZ
parameter_list|,
name|int
name|preferred
parameter_list|)
block|{
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* The consistency check is performed on the chromaticities; this factors out     * variations because of the normalization (or not) of the end point Y     * values.     */
if|if
condition|(
name|preferred
operator|<
literal|2
operator|&&
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_ENDPOINTS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The end points must be reasonably close to any we already have.  The        * following allows an error of up to +/-.001        */
if|if
condition|(
name|png_colorspace_endpoints_match
argument_list|(
name|xy
argument_list|,
operator|&
name|colorspace
operator|->
name|end_points_xy
argument_list|,
literal|100
argument_list|)
operator|==
literal|0
condition|)
block|{
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"inconsistent chromaticities"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* failed */
block|}
comment|/* Only overwrite with preferred values */
if|if
condition|(
name|preferred
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* ok, but no change */
block|}
name|colorspace
operator|->
name|end_points_xy
operator|=
operator|*
name|xy
expr_stmt|;
name|colorspace
operator|->
name|end_points_XYZ
operator|=
operator|*
name|XYZ
expr_stmt|;
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_HAVE_ENDPOINTS
expr_stmt|;
comment|/* The end points are normally quoted to two decimal digits, so allow +/-0.01     * on this test.     */
if|if
condition|(
name|png_colorspace_endpoints_match
argument_list|(
name|xy
argument_list|,
operator|&
name|sRGB_xy
argument_list|,
literal|1000
argument_list|)
operator|!=
literal|0
condition|)
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB
expr_stmt|;
else|else
name|colorspace
operator|->
name|flags
operator|&=
name|PNG_COLORSPACE_CANCEL
argument_list|(
name|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
comment|/* ok and changed */
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_colorspace_set_chromaticities
name|png_colorspace_set_chromaticities
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
specifier|const
name|png_xy
modifier|*
name|xy
parameter_list|,
name|int
name|preferred
parameter_list|)
block|{
comment|/* We must check the end points to ensure they are reasonable - in the past     * color management systems have crashed as a result of getting bogus     * colorant values, while this isn't the fault of libpng it is the     * responsibility of libpng because PNG carries the bomb and libpng is in a     * position to protect against it.     */
name|png_XYZ
name|XYZ
decl_stmt|;
switch|switch
condition|(
name|png_colorspace_check_xy
argument_list|(
operator|&
name|XYZ
argument_list|,
name|xy
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* success */
return|return
name|png_colorspace_set_xy_and_XYZ
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|xy
argument_list|,
operator|&
name|XYZ
argument_list|,
name|preferred
argument_list|)
return|;
case|case
literal|1
case|:
comment|/* We can't invert the chromaticities so we can't produce value XYZ           * values.  Likely as not a color management system will fail too.           */
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid chromaticities"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* libpng is broken; this should be a warning but if it happens we           * want error reports so for the moment it is an error.           */
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal error checking chromaticities"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* failed */
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_colorspace_set_endpoints
name|png_colorspace_set_endpoints
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
specifier|const
name|png_XYZ
modifier|*
name|XYZ_in
parameter_list|,
name|int
name|preferred
parameter_list|)
block|{
name|png_XYZ
name|XYZ
init|=
operator|*
name|XYZ_in
decl_stmt|;
name|png_xy
name|xy
decl_stmt|;
switch|switch
condition|(
name|png_colorspace_check_XYZ
argument_list|(
operator|&
name|xy
argument_list|,
operator|&
name|XYZ
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|png_colorspace_set_xy_and_XYZ
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
operator|&
name|xy
argument_list|,
operator|&
name|XYZ
argument_list|,
name|preferred
argument_list|)
return|;
case|case
literal|1
case|:
comment|/* End points are invalid. */
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid end points"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal error checking chromaticities"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* failed */
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_sRGB_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_iCCP_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Error message generation */
end_comment
begin_function
specifier|static
name|char
DECL|function|png_icc_tag_char
name|png_icc_tag_char
parameter_list|(
name|png_uint_32
name|byte
parameter_list|)
block|{
name|byte
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|byte
operator|>=
literal|32
operator|&&
name|byte
operator|<=
literal|126
condition|)
return|return
operator|(
name|char
operator|)
name|byte
return|;
else|else
return|return
literal|'?'
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|png_icc_tag_name
name|png_icc_tag_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|png_uint_32
name|tag
parameter_list|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\''
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|png_icc_tag_char
argument_list|(
name|tag
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|png_icc_tag_char
argument_list|(
name|tag
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|name
index|[
literal|3
index|]
operator|=
name|png_icc_tag_char
argument_list|(
name|tag
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|name
index|[
literal|4
index|]
operator|=
name|png_icc_tag_char
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|name
index|[
literal|5
index|]
operator|=
literal|'\''
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|is_ICC_signature_char
name|is_ICC_signature_char
parameter_list|(
name|png_alloc_size_t
name|it
parameter_list|)
block|{
return|return
name|it
operator|==
literal|32
operator|||
operator|(
name|it
operator|>=
literal|48
operator|&&
name|it
operator|<=
literal|57
operator|)
operator|||
operator|(
name|it
operator|>=
literal|65
operator|&&
name|it
operator|<=
literal|90
operator|)
operator|||
operator|(
name|it
operator|>=
literal|97
operator|&&
name|it
operator|<=
literal|122
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|is_ICC_signature
name|is_ICC_signature
parameter_list|(
name|png_alloc_size_t
name|it
parameter_list|)
block|{
return|return
name|is_ICC_signature_char
argument_list|(
name|it
operator|>>
literal|24
argument_list|)
comment|/* checks all the top bits */
operator|&&
name|is_ICC_signature_char
argument_list|(
operator|(
name|it
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
operator|&&
name|is_ICC_signature_char
argument_list|(
operator|(
name|it
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
operator|&&
name|is_ICC_signature_char
argument_list|(
name|it
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|png_icc_profile_error
name|png_icc_profile_error
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|png_alloc_size_t
name|value
parameter_list|,
name|png_const_charp
name|reason
parameter_list|)
block|{
name|size_t
name|pos
decl_stmt|;
name|char
name|message
index|[
literal|196
index|]
decl_stmt|;
comment|/* see below for calculation */
if|if
condition|(
name|colorspace
operator|!=
name|NULL
condition|)
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_INVALID
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|message
argument_list|,
operator|(
sizeof|sizeof
name|message
operator|)
argument_list|,
literal|0
argument_list|,
literal|"profile '"
argument_list|)
expr_stmt|;
comment|/* 9 chars */
name|pos
operator|=
name|png_safecat
argument_list|(
name|message
argument_list|,
name|pos
operator|+
literal|79
argument_list|,
name|pos
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Truncate to 79 chars */
name|pos
operator|=
name|png_safecat
argument_list|(
name|message
argument_list|,
operator|(
sizeof|sizeof
name|message
operator|)
argument_list|,
name|pos
argument_list|,
literal|"': "
argument_list|)
expr_stmt|;
comment|/* +2 = 90 */
if|if
condition|(
name|is_ICC_signature
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* So 'value' is at most 4 bytes and the following cast is safe */
name|png_icc_tag_name
argument_list|(
name|message
operator|+
name|pos
argument_list|,
operator|(
name|png_uint_32
operator|)
name|value
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|6
expr_stmt|;
comment|/* total +8; less than the else clause */
name|message
index|[
name|pos
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|message
index|[
name|pos
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
else|else
block|{
name|char
name|number
index|[
name|PNG_NUMBER_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* +24 = 114*/
name|pos
operator|=
name|png_safecat
argument_list|(
name|message
argument_list|,
operator|(
sizeof|sizeof
name|message
operator|)
argument_list|,
name|pos
argument_list|,
name|png_format_number
argument_list|(
name|number
argument_list|,
name|number
operator|+
operator|(
sizeof|sizeof
name|number
operator|)
argument_list|,
name|PNG_NUMBER_FORMAT_x
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|message
argument_list|,
operator|(
sizeof|sizeof
name|message
operator|)
argument_list|,
name|pos
argument_list|,
literal|"h: "
argument_list|)
expr_stmt|;
comment|/*+2 = 116*/
block|}
endif|#
directive|endif
comment|/* The 'reason' is an arbitrary message, allow +79 maximum 195 */
name|pos
operator|=
name|png_safecat
argument_list|(
name|message
argument_list|,
operator|(
sizeof|sizeof
name|message
operator|)
argument_list|,
name|pos
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|PNG_UNUSED
argument_list|(
argument|pos
argument_list|)
comment|/* This is recoverable, but make it unconditionally an app_error on write to     * avoid writing invalid ICC profiles into PNG files (i.e., we handle them     * on read, with a warning, but on write unless the app turns off     * application errors the PNG won't be written.)     */
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
name|message
argument_list|,
operator|(
name|colorspace
operator|!=
name|NULL
operator|)
condition|?
name|PNG_CHUNK_ERROR
else|:
name|PNG_CHUNK_WRITE_ERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* sRGB || iCCP */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
end_ifdef
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_colorspace_set_sRGB
name|png_colorspace_set_sRGB
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|int
name|intent
parameter_list|)
block|{
comment|/* sRGB sets known gamma, end points and (from the chunk) intent. */
comment|/* IMPORTANT: these are not necessarily the values found in an ICC profile     * because ICC profiles store values adapted to a D50 environment; it is     * expected that the ICC profile mediaWhitePointTag will be D50; see the     * checks and code elsewhere to understand this better.     *     * These XYZ values, which are accurate to 5dp, produce rgb to gray     * coefficients of (6968,23435,2366), which are reduced (because they add up     * to 32769 not 32768) to (6968,23434,2366).  These are the values that     * libpng has traditionally used (and are the best values given the 15bit     * algorithm used by the rgb to gray code.)     */
specifier|static
specifier|const
name|png_XYZ
name|sRGB_XYZ
init|=
comment|/* D65 XYZ (*not* the D50 adapted values!) */
block|{
comment|/* color      X      Y      Z */
comment|/* red   */
literal|41239
block|,
literal|21264
block|,
literal|1933
block|,
comment|/* green */
literal|35758
block|,
literal|71517
block|,
literal|11919
block|,
comment|/* blue  */
literal|18048
block|,
literal|7219
block|,
literal|95053
block|}
decl_stmt|;
comment|/* Do nothing if the colorspace is already invalidated. */
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check the intent, then check for existing settings.  It is valid for the     * PNG file to have cHRM or gAMA chunks along with sRGB, but the values must     * be consistent with the correct values.  If, however, this function is     * called below because an iCCP chunk matches sRGB then it is quite     * conceivable that an older app recorded incorrect gAMA and cHRM because of     * an incorrect calculation based on the values in the profile - this does     * *not* invalidate the profile (though it still produces an error, which can     * be ignored.)     */
if|if
condition|(
name|intent
operator|<
literal|0
operator|||
name|intent
operator|>=
name|PNG_sRGB_INTENT_LAST
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
literal|"sRGB"
argument_list|,
operator|(
name|unsigned
operator|)
name|intent
argument_list|,
literal|"invalid sRGB rendering intent"
argument_list|)
return|;
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_INTENT
operator|)
operator|!=
literal|0
operator|&&
name|colorspace
operator|->
name|rendering_intent
operator|!=
name|intent
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
literal|"sRGB"
argument_list|,
operator|(
name|unsigned
operator|)
name|intent
argument_list|,
literal|"inconsistent rendering intents"
argument_list|)
return|;
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_FROM_sRGB
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_benign_error
argument_list|(
name|png_ptr
argument_list|,
literal|"duplicate sRGB information ignored"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If the standard sRGB cHRM chunk does not match the one from the PNG file     * warn but overwrite the value with the correct one.     */
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_ENDPOINTS
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|png_colorspace_endpoints_match
argument_list|(
operator|&
name|sRGB_xy
argument_list|,
operator|&
name|colorspace
operator|->
name|end_points_xy
argument_list|,
literal|100
argument_list|)
condition|)
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"cHRM chunk does not match sRGB"
argument_list|,
name|PNG_CHUNK_ERROR
argument_list|)
expr_stmt|;
comment|/* This check is just done for the error reporting - the routine always     * returns true when the 'from' argument corresponds to sRGB (2).     */
operator|(
name|void
operator|)
name|png_colorspace_check_gamma
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|PNG_GAMMA_sRGB_INVERSE
argument_list|,
literal|2
comment|/*from sRGB*/
argument_list|)
expr_stmt|;
comment|/* intent: bugs in GCC force 'int' to be used as the parameter type. */
name|colorspace
operator|->
name|rendering_intent
operator|=
operator|(
name|png_uint_16
operator|)
name|intent
expr_stmt|;
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_HAVE_INTENT
expr_stmt|;
comment|/* endpoints */
name|colorspace
operator|->
name|end_points_xy
operator|=
name|sRGB_xy
expr_stmt|;
name|colorspace
operator|->
name|end_points_XYZ
operator|=
name|sRGB_XYZ
expr_stmt|;
name|colorspace
operator|->
name|flags
operator||=
operator|(
name|PNG_COLORSPACE_HAVE_ENDPOINTS
operator||
name|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB
operator|)
expr_stmt|;
comment|/* gamma */
name|colorspace
operator|->
name|gamma
operator|=
name|PNG_GAMMA_sRGB_INVERSE
expr_stmt|;
name|colorspace
operator|->
name|flags
operator||=
name|PNG_COLORSPACE_HAVE_GAMMA
expr_stmt|;
comment|/* Finally record that we have an sRGB profile */
name|colorspace
operator|->
name|flags
operator||=
operator|(
name|PNG_COLORSPACE_MATCHES_sRGB
operator||
name|PNG_COLORSPACE_FROM_sRGB
operator|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* set */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* sRGB */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
end_ifdef
begin_comment
comment|/* Encoded value of D50 as an ICC XYZNumber.  From the ICC 2010 spec the value  * is XYZ(0.9642,1.0,0.8249), which scales to:  *  *    (63189.8112, 65536, 54060.6464)  */
end_comment
begin_decl_stmt
DECL|variable|D50_nCIEXYZ
specifier|static
specifier|const
name|png_byte
name|D50_nCIEXYZ
index|[
literal|12
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xf6
block|,
literal|0xd6
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xd3
block|,
literal|0x2d
block|}
decl_stmt|;
end_decl_stmt
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_icc_check_length
name|png_icc_check_length
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|png_uint_32
name|profile_length
parameter_list|)
block|{
if|if
condition|(
name|profile_length
operator|<
literal|132
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|profile_length
argument_list|,
literal|"too short"
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_icc_check_header
name|png_icc_check_header
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|png_uint_32
name|profile_length
parameter_list|,
name|png_const_bytep
name|profile
comment|/* first 132 bytes only */
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
name|png_uint_32
name|temp
decl_stmt|;
comment|/* Length check; this cannot be ignored in this code because profile_length     * is used later to check the tag table, so even if the profile seems over     * long profile_length from the caller must be correct.  The caller can fix     * this up on read or write by just passing in the profile header length.     */
name|temp
operator|=
name|png_get_uint_32
argument_list|(
name|profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|profile_length
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"length does not match profile"
argument_list|)
return|;
name|temp
operator|=
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|profile
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|3
operator|&&
operator|(
name|profile_length
operator|&
literal|3
operator|)
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|profile_length
argument_list|,
literal|"invalid length"
argument_list|)
return|;
name|temp
operator|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|128
argument_list|)
expr_stmt|;
comment|/* tag count: 12 bytes/tag */
if|if
condition|(
name|temp
operator|>
literal|357913930
operator|||
comment|/* (2^32-4-132)/12: maximum possible tag count */
name|profile_length
operator|<
literal|132
operator|+
literal|12
operator|*
name|temp
condition|)
comment|/* truncated tag table */
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"tag count too large"
argument_list|)
return|;
comment|/* The 'intent' must be valid or we can't store it, ICC limits the intent to     * 16 bits.     */
name|temp
operator|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
literal|0xffff
condition|)
comment|/* The ICC limit */
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"invalid rendering intent"
argument_list|)
return|;
comment|/* This is just a warning because the profile may be valid in future     * versions.     */
if|if
condition|(
name|temp
operator|>=
name|PNG_sRGB_INTENT_LAST
condition|)
operator|(
name|void
operator|)
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"intent outside defined range"
argument_list|)
expr_stmt|;
comment|/* At this point the tag table can't be checked because it hasn't necessarily     * been loaded; however, various header fields can be checked.  These checks     * are for values permitted by the PNG spec in an ICC profile; the PNG spec     * restricts the profiles that can be passed in an iCCP chunk (they must be     * appropriate to processing PNG data!)     */
comment|/* Data checks (could be skipped).  These checks must be independent of the     * version number; however, the version number doesn't accomodate changes in     * the header fields (just the known tags and the interpretation of the     * data.)     */
name|temp
operator|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|36
argument_list|)
expr_stmt|;
comment|/* signature 'ascp' */
if|if
condition|(
name|temp
operator|!=
literal|0x61637370
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"invalid signature"
argument_list|)
return|;
comment|/* Currently the PCS illuminant/adopted white point (the computational     * white point) are required to be D50,     * however the profile contains a record of the illuminant so perhaps ICC     * expects to be able to change this in the future (despite the rationale in     * the introduction for using a fixed PCS adopted white.)  Consequently the     * following is just a warning.     */
if|if
condition|(
name|memcmp
argument_list|(
name|profile
operator|+
literal|68
argument_list|,
name|D50_nCIEXYZ
argument_list|,
literal|12
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
literal|0
comment|/*no tag value*/
argument_list|,
literal|"PCS illuminant is not D50"
argument_list|)
expr_stmt|;
comment|/* The PNG spec requires this:     * "If the iCCP chunk is present, the image samples conform to the colour     * space represented by the embedded ICC profile as defined by the     * International Color Consortium [ICC]. The colour space of the ICC profile     * shall be an RGB colour space for colour images (PNG colour types 2, 3, and     * 6), or a greyscale colour space for greyscale images (PNG colour types 0     * and 4)."     *     * This checking code ensures the embedded profile (on either read or write)     * conforms to the specification requirements.  Notice that an ICC 'gray'     * color-space profile contains the information to transform the monochrome     * data to XYZ or L*a*b (according to which PCS the profile uses) and this     * should be used in preference to the standard libpng K channel replication     * into R, G and B channels.     *     * Previously it was suggested that an RGB profile on grayscale data could be     * handled.  However it it is clear that using an RGB profile in this context     * must be an error - there is no specification of what it means.  Thus it is     * almost certainly more correct to ignore the profile.     */
name|temp
operator|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* data colour space field */
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|0x52474220
case|:
comment|/* 'RGB ' */
if|if
condition|(
operator|(
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"RGB color space not permitted on grayscale PNG"
argument_list|)
return|;
break|break;
case|case
literal|0x47524159
case|:
comment|/* 'GRAY' */
if|if
condition|(
operator|(
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"Gray color space not permitted on RGB PNG"
argument_list|)
return|;
break|break;
default|default:
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"invalid ICC profile color space"
argument_list|)
return|;
block|}
comment|/* It is up to the application to check that the profile class matches the     * application requirements; the spec provides no guidance, but it's pretty     * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer     * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these     * cases.  Issue an error for device link or abstract profiles - these don't     * contain the records necessary to transform the color-space to anything     * other than the target device (and not even that for an abstract profile).     * Profiles of these classes may not be embedded in images.     */
name|temp
operator|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* profile/device class */
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|0x73636e72
case|:
comment|/* 'scnr' */
case|case
literal|0x6d6e7472
case|:
comment|/* 'mntr' */
case|case
literal|0x70727472
case|:
comment|/* 'prtr' */
case|case
literal|0x73706163
case|:
comment|/* 'spac' */
comment|/* All supported */
break|break;
case|case
literal|0x61627374
case|:
comment|/* 'abst' */
comment|/* May not be embedded in an image */
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"invalid embedded Abstract ICC profile"
argument_list|)
return|;
case|case
literal|0x6c696e6b
case|:
comment|/* 'link' */
comment|/* DeviceLink profiles cannot be interpreted in a non-device specific           * fashion, if an app uses the AToB0Tag in the profile the results are           * undefined unless the result is sent to the intended device,           * therefore a DeviceLink profile should not be found embedded in a           * PNG.           */
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"unexpected DeviceLink ICC profile class"
argument_list|)
return|;
case|case
literal|0x6e6d636c
case|:
comment|/* 'nmcl' */
comment|/* A NamedColor profile is also device specific, however it doesn't           * contain an AToB0 tag that is open to misinterpretation.  Almost           * certainly it will fail the tests below.           */
operator|(
name|void
operator|)
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"unexpected NamedColor ICC profile class"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* To allow for future enhancements to the profile accept unrecognized           * profile classes with a warning, these then hit the test below on the           * tag content to ensure they are backward compatible with one of the           * understood profiles.           */
operator|(
name|void
operator|)
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"unrecognized ICC profile class"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* For any profile other than a device link one the PCS must be encoded     * either in XYZ or Lab.     */
name|temp
operator|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|20
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|0x58595a20
case|:
comment|/* 'XYZ ' */
case|case
literal|0x4c616220
case|:
comment|/* 'Lab ' */
break|break;
default|default:
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|temp
argument_list|,
literal|"unexpected ICC PCS encoding"
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_icc_check_tag_table
name|png_icc_check_tag_table
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|png_uint_32
name|profile_length
parameter_list|,
name|png_const_bytep
name|profile
comment|/* header plus whole tag table */
parameter_list|)
block|{
name|png_uint_32
name|tag_count
init|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|128
argument_list|)
decl_stmt|;
name|png_uint_32
name|itag
decl_stmt|;
name|png_const_bytep
name|tag
init|=
name|profile
operator|+
literal|132
decl_stmt|;
comment|/* The first tag */
comment|/* First scan all the tags in the table and add bits to the icc_info value     * (temporarily in 'tags').     */
for|for
control|(
name|itag
operator|=
literal|0
init|;
name|itag
operator|<
name|tag_count
condition|;
operator|++
name|itag
operator|,
name|tag
operator|+=
literal|12
control|)
block|{
name|png_uint_32
name|tag_id
init|=
name|png_get_uint_32
argument_list|(
name|tag
operator|+
literal|0
argument_list|)
decl_stmt|;
name|png_uint_32
name|tag_start
init|=
name|png_get_uint_32
argument_list|(
name|tag
operator|+
literal|4
argument_list|)
decl_stmt|;
comment|/* must be aligned */
name|png_uint_32
name|tag_length
init|=
name|png_get_uint_32
argument_list|(
name|tag
operator|+
literal|8
argument_list|)
decl_stmt|;
comment|/* not padded */
comment|/* The ICC specification does not exclude zero length tags, therefore the        * start might actually be anywhere if there is no data, but this would be        * a clear abuse of the intent of the standard so the start is checked for        * being in range.  All defined tag types have an 8 byte header - a 4 byte        * type signature then 0.        */
if|if
condition|(
operator|(
name|tag_start
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* CNHP730S.icc shipped with Microsoft Windows 64 violates this, it is           * only a warning here because libpng does not care about the           * alignment.           */
operator|(
name|void
operator|)
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|tag_id
argument_list|,
literal|"ICC profile tag start not a multiple of 4"
argument_list|)
expr_stmt|;
block|}
comment|/* This is a hard error; potentially it can cause read outside the        * profile.        */
if|if
condition|(
name|tag_start
operator|>
name|profile_length
operator|||
name|tag_length
operator|>
name|profile_length
operator|-
name|tag_start
condition|)
return|return
name|png_icc_profile_error
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|tag_id
argument_list|,
literal|"ICC profile tag outside profile"
argument_list|)
return|;
block|}
return|return
literal|1
return|;
comment|/* success, maybe with warnings */
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
end_ifdef
begin_if
if|#
directive|if
name|PNG_sRGB_PROFILE_CHECKS
operator|>=
literal|0
end_if
begin_comment
comment|/* Information about the known ICC sRGB profiles */
end_comment
begin_struct
specifier|static
specifier|const
struct|struct
block|{
DECL|member|adler
DECL|member|crc
DECL|member|length
name|png_uint_32
name|adler
decl_stmt|,
name|crc
decl_stmt|,
name|length
decl_stmt|;
DECL|member|md5
name|png_uint_32
name|md5
index|[
literal|4
index|]
decl_stmt|;
DECL|member|have_md5
name|png_byte
name|have_md5
decl_stmt|;
DECL|member|is_broken
name|png_byte
name|is_broken
decl_stmt|;
DECL|member|intent
name|png_uint_16
name|intent
decl_stmt|;
DECL|macro|PNG_MD5
define|#
directive|define
name|PNG_MD5
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|{ a, b, c, d }, (a!=0)||(b!=0)||(c!=0)||(d!=0)
DECL|macro|PNG_ICC_CHECKSUM
define|#
directive|define
name|PNG_ICC_CHECKSUM
parameter_list|(
name|adler
parameter_list|,
name|crc
parameter_list|,
name|md5
parameter_list|,
name|intent
parameter_list|,
name|broke
parameter_list|,
name|date
parameter_list|,
name|length
parameter_list|,
name|fname
parameter_list|)
define|\
value|{ adler, crc, length, md5, broke, intent },
block|}
DECL|variable|png_sRGB_checks
name|png_sRGB_checks
index|[]
init|=
block|{
comment|/* This data comes from contrib/tools/checksum-icc run on downloads of     * all four ICC sRGB profiles from www.color.org.     */
comment|/* adler32, crc32, MD5[4], intent, date, length, file-name */
name|PNG_ICC_CHECKSUM
argument_list|(
literal|0x0a3fd9f6
argument_list|,
literal|0x3b8772b9
argument_list|,
argument|PNG_MD5(
literal|0x29f83dde
argument|,
literal|0xaff255ae
argument|,
literal|0x7842fae4
argument|,
literal|0xca83390d
argument|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"2009/03/27 21:36:31"
argument_list|,
literal|3048
argument_list|,
literal|"sRGB_IEC61966-2-1_black_scaled.icc"
argument_list|)
comment|/* ICC sRGB v2 perceptual no black-compensation: */
name|PNG_ICC_CHECKSUM
argument_list|(
literal|0x4909e5e1
argument_list|,
literal|0x427ebb21
argument_list|,
argument|PNG_MD5(
literal|0xc95bd637
argument|,
literal|0xe95d8a3b
argument|,
literal|0x0df38f99
argument|,
literal|0xc1320389
argument|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"2009/03/27 21:37:45"
argument_list|,
literal|3052
argument_list|,
literal|"sRGB_IEC61966-2-1_no_black_scaling.icc"
argument_list|)
name|PNG_ICC_CHECKSUM
argument_list|(
literal|0xfd2144a1
argument_list|,
literal|0x306fd8ae
argument_list|,
argument|PNG_MD5(
literal|0xfc663378
argument|,
literal|0x37e2886b
argument|,
literal|0xfd72e983
argument|,
literal|0x8228f1b8
argument|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"2009/08/10 17:28:01"
argument_list|,
literal|60988
argument_list|,
literal|"sRGB_v4_ICC_preference_displayclass.icc"
argument_list|)
comment|/* ICC sRGB v4 perceptual */
name|PNG_ICC_CHECKSUM
argument_list|(
literal|0x209c35d2
argument_list|,
literal|0xbbef7812
argument_list|,
argument|PNG_MD5(
literal|0x34562abf
argument|,
literal|0x994ccd06
argument|,
literal|0x6d2c5721
argument|,
literal|0xd0d68c5d
argument|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"2007/07/25 00:05:37"
argument_list|,
literal|60960
argument_list|,
literal|"sRGB_v4_ICC_preference.icc"
argument_list|)
comment|/* The following profiles have no known MD5 checksum. If there is a match     * on the (empty) MD5 the other fields are used to attempt a match and     * a warning is produced.  The first two of these profiles have a 'cprt' tag     * which suggests that they were also made by Hewlett Packard.     */
name|PNG_ICC_CHECKSUM
argument_list|(
literal|0xa054d762
argument_list|,
literal|0x5d5129ce
argument_list|,
argument|PNG_MD5(
literal|0x00000000
argument|,
literal|0x00000000
argument|,
literal|0x00000000
argument|,
literal|0x00000000
argument|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"2004/07/21 18:57:42"
argument_list|,
literal|3024
argument_list|,
literal|"sRGB_IEC61966-2-1_noBPC.icc"
argument_list|)
comment|/* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not     * match the D50 PCS illuminant in the header (it is in fact the D65 values,     * so the white point is recorded as the un-adapted value.)  The profiles     * below only differ in one byte - the intent - and are basically the same as     * the previous profile except for the mediaWhitePointTag error and a missing     * chromaticAdaptationTag.     */
name|PNG_ICC_CHECKSUM
argument_list|(
literal|0xf784f3fb
argument_list|,
literal|0x182ea552
argument_list|,
argument|PNG_MD5(
literal|0x00000000
argument|,
literal|0x00000000
argument|,
literal|0x00000000
argument|,
literal|0x00000000
argument|)
argument_list|,
literal|0
argument_list|,
literal|1
comment|/*broken*/
argument_list|,
literal|"1998/02/09 06:49:00"
argument_list|,
literal|3144
argument_list|,
literal|"HP-Microsoft sRGB v2 perceptual"
argument_list|)
name|PNG_ICC_CHECKSUM
argument_list|(
literal|0x0398f3fc
argument_list|,
literal|0xf29e526d
argument_list|,
argument|PNG_MD5(
literal|0x00000000
argument|,
literal|0x00000000
argument|,
literal|0x00000000
argument|,
literal|0x00000000
argument|)
argument_list|,
literal|1
argument_list|,
literal|1
comment|/*broken*/
argument_list|,
literal|"1998/02/09 06:49:00"
argument_list|,
literal|3144
argument_list|,
literal|"HP-Microsoft sRGB v2 media-relative"
argument_list|)
block|}
struct|;
end_struct
begin_function
specifier|static
name|int
DECL|function|png_compare_ICC_profile_with_sRGB
name|png_compare_ICC_profile_with_sRGB
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|profile
parameter_list|,
name|uLong
name|adler
parameter_list|)
block|{
comment|/* The quick check is to verify just the MD5 signature and trust the     * rest of the data.  Because the profile has already been verified for     * correctness this is safe.  png_colorspace_set_sRGB will check the 'intent'     * field too, so if the profile has been edited with an intent not defined     * by sRGB (but maybe defined by a later ICC specification) the read of     * the profile will fail at that point.     */
name|png_uint_32
name|length
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|intent
init|=
literal|0x10000
decl_stmt|;
comment|/* invalid */
if|#
directive|if
name|PNG_sRGB_PROFILE_CHECKS
operator|>
literal|1
name|uLong
name|crc
init|=
literal|0
decl_stmt|;
comment|/* the value for 0 length data */
endif|#
directive|endif
name|unsigned
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_SET_OPTION_SUPPORTED
comment|/* First see if PNG_SKIP_sRGB_CHECK_PROFILE has been set to "on" */
if|if
condition|(
operator|(
operator|(
name|png_ptr
operator|->
name|options
operator|>>
name|PNG_SKIP_sRGB_CHECK_PROFILE
operator|)
operator|&
literal|3
operator|)
operator|==
name|PNG_OPTION_ON
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
name|png_sRGB_checks
operator|)
operator|/
operator|(
sizeof|sizeof
name|png_sRGB_checks
index|[
literal|0
index|]
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|84
argument_list|)
operator|==
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|md5
index|[
literal|0
index|]
operator|&&
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|88
argument_list|)
operator|==
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|md5
index|[
literal|1
index|]
operator|&&
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|92
argument_list|)
operator|==
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|md5
index|[
literal|2
index|]
operator|&&
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|96
argument_list|)
operator|==
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|md5
index|[
literal|3
index|]
condition|)
block|{
comment|/* This may be one of the old HP profiles without an MD5, in that           * case we can only use the length and Adler32 (note that these           * are not used by default if there is an MD5!)           */
if|#
directive|if
name|PNG_sRGB_PROFILE_CHECKS
operator|==
literal|0
if|if
condition|(
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|have_md5
operator|!=
literal|0
condition|)
return|return
literal|1
operator|+
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|is_broken
return|;
endif|#
directive|endif
comment|/* Profile is unsigned or more checks have been configured in. */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|length
operator|=
name|png_get_uint_32
argument_list|(
name|profile
argument_list|)
expr_stmt|;
name|intent
operator|=
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
comment|/* Length *and* intent must match */
if|if
condition|(
name|length
operator|==
operator|(
name|png_uint_32
operator|)
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|length
operator|&&
name|intent
operator|==
operator|(
name|png_uint_32
operator|)
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|intent
condition|)
block|{
comment|/* Now calculate the adler32 if not done already. */
if|if
condition|(
name|adler
operator|==
literal|0
condition|)
block|{
name|adler
operator|=
name|adler32
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adler
operator|=
name|adler32
argument_list|(
name|adler
argument_list|,
name|profile
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adler
operator|==
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|adler
condition|)
block|{
comment|/* These basic checks suggest that the data has not been                 * modified, but if the check level is more than 1 perform                 * our own crc32 checksum on the data.                 */
if|#
directive|if
name|PNG_sRGB_PROFILE_CHECKS
operator|>
literal|1
if|if
condition|(
name|crc
operator|==
literal|0
condition|)
block|{
name|crc
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
name|profile
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* So this check must pass for the 'return' below to happen.                    */
if|if
condition|(
name|crc
operator|==
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|crc
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|is_broken
operator|!=
literal|0
condition|)
block|{
comment|/* These profiles are known to have bad data that may cause                       * problems if they are used, therefore attempt to                       * discourage their use, skip the 'have_md5' warning below,                       * which is made irrelevant by this error.                       */
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"known incorrect sRGB profile"
argument_list|,
name|PNG_CHUNK_ERROR
argument_list|)
expr_stmt|;
block|}
comment|/* Warn that this being done; this isn't even an error since                    * the profile is perfectly valid, but it would be nice if                    * people used the up-to-date ones.                    */
elseif|else
if|if
condition|(
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|have_md5
operator|==
literal|0
condition|)
block|{
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"out-of-date sRGB profile with no signature"
argument_list|,
name|PNG_CHUNK_WARNING
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
operator|+
name|png_sRGB_checks
index|[
name|i
index|]
operator|.
name|is_broken
return|;
block|}
block|}
if|#
directive|if
name|PNG_sRGB_PROFILE_CHECKS
operator|>
literal|0
comment|/* The signature matched, but the profile had been changed in some           * way.  This probably indicates a data error or uninformed hacking.           * Fall through to "no match".           */
name|png_chunk_report
argument_list|(
name|png_ptr
argument_list|,
literal|"Not recognizing known sRGB profile that has been edited"
argument_list|,
name|PNG_CHUNK_WARNING
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
return|return
literal|0
return|;
comment|/* no match */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_sRGB_PROFILE_CHECKS>= 0 */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_icc_set_sRGB
name|png_icc_set_sRGB
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_const_bytep
name|profile
parameter_list|,
name|uLong
name|adler
parameter_list|)
block|{
comment|/* Is this profile one of the known ICC sRGB profiles?  If it is, just set     * the sRGB information.     */
if|#
directive|if
name|PNG_sRGB_PROFILE_CHECKS
operator|>=
literal|0
if|if
condition|(
name|png_compare_ICC_profile_with_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|profile
argument_list|,
name|adler
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|png_colorspace_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
operator|(
name|int
operator|)
comment|/*already checked*/
name|png_get_uint_32
argument_list|(
name|profile
operator|+
literal|64
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* sRGB */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_colorspace_set_ICC
name|png_colorspace_set_ICC
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_colorspacerp
name|colorspace
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|png_uint_32
name|profile_length
parameter_list|,
name|png_const_bytep
name|profile
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|colorspace
operator|->
name|flags
operator|&
name|PNG_COLORSPACE_INVALID
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|png_icc_check_length
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|profile_length
argument_list|)
operator|!=
literal|0
operator|&&
name|png_icc_check_header
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|profile_length
argument_list|,
name|profile
argument_list|,
name|color_type
argument_list|)
operator|!=
literal|0
operator|&&
name|png_icc_check_tag_table
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|name
argument_list|,
name|profile_length
argument_list|,
name|profile
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_sRGB_SUPPORTED
comment|/* If no sRGB support, don't try storing sRGB information */
name|png_icc_set_sRGB
argument_list|(
name|png_ptr
argument_list|,
name|colorspace
argument_list|,
name|profile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/* Failure case */
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* iCCP */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
end_ifdef
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_colorspace_set_rgb_coefficients
name|png_colorspace_set_rgb_coefficients
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Set the rgb_to_gray coefficients from the colorspace. */
if|if
condition|(
name|png_ptr
operator|->
name|rgb_to_gray_coefficients_set
operator|==
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|flags
operator|&
name|PNG_COLORSPACE_HAVE_ENDPOINTS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* png_set_background has not been called, get the coefficients from the Y        * values of the colorspace colorants.        */
name|png_fixed_point
name|r
init|=
name|png_ptr
operator|->
name|colorspace
operator|.
name|end_points_XYZ
operator|.
name|red_Y
decl_stmt|;
name|png_fixed_point
name|g
init|=
name|png_ptr
operator|->
name|colorspace
operator|.
name|end_points_XYZ
operator|.
name|green_Y
decl_stmt|;
name|png_fixed_point
name|b
init|=
name|png_ptr
operator|->
name|colorspace
operator|.
name|end_points_XYZ
operator|.
name|blue_Y
decl_stmt|;
name|png_fixed_point
name|total
init|=
name|r
operator|+
name|g
operator|+
name|b
decl_stmt|;
if|if
condition|(
name|total
operator|>
literal|0
operator|&&
name|r
operator|>=
literal|0
operator|&&
name|png_muldiv
argument_list|(
operator|&
name|r
argument_list|,
name|r
argument_list|,
literal|32768
argument_list|,
name|total
argument_list|)
operator|&&
name|r
operator|>=
literal|0
operator|&&
name|r
operator|<=
literal|32768
operator|&&
name|g
operator|>=
literal|0
operator|&&
name|png_muldiv
argument_list|(
operator|&
name|g
argument_list|,
name|g
argument_list|,
literal|32768
argument_list|,
name|total
argument_list|)
operator|&&
name|g
operator|>=
literal|0
operator|&&
name|g
operator|<=
literal|32768
operator|&&
name|b
operator|>=
literal|0
operator|&&
name|png_muldiv
argument_list|(
operator|&
name|b
argument_list|,
name|b
argument_list|,
literal|32768
argument_list|,
name|total
argument_list|)
operator|&&
name|b
operator|>=
literal|0
operator|&&
name|b
operator|<=
literal|32768
operator|&&
name|r
operator|+
name|g
operator|+
name|b
operator|<=
literal|32769
condition|)
block|{
comment|/* We allow 0 coefficients here.  r+g+b may be 32769 if two or           * all of the coefficients were rounded up.  Handle this by           * reducing the *largest* coefficient by 1; this matches the           * approach used for the default coefficients in pngrtran.c           */
name|int
name|add
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|r
operator|+
name|g
operator|+
name|b
operator|>
literal|32768
condition|)
name|add
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|+
name|g
operator|+
name|b
operator|<
literal|32768
condition|)
name|add
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|add
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|g
operator|>=
name|r
operator|&&
name|g
operator|>=
name|b
condition|)
name|g
operator|+=
name|add
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|>=
name|g
operator|&&
name|r
operator|>=
name|b
condition|)
name|r
operator|+=
name|add
expr_stmt|;
else|else
name|b
operator|+=
name|add
expr_stmt|;
block|}
comment|/* Check for an internal error. */
if|if
condition|(
name|r
operator|+
name|g
operator|+
name|b
operator|!=
literal|32768
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal error handling cHRM coefficients"
argument_list|)
expr_stmt|;
else|else
block|{
name|png_ptr
operator|->
name|rgb_to_gray_red_coeff
operator|=
operator|(
name|png_uint_16
operator|)
name|r
expr_stmt|;
name|png_ptr
operator|->
name|rgb_to_gray_green_coeff
operator|=
operator|(
name|png_uint_16
operator|)
name|g
expr_stmt|;
block|}
block|}
comment|/* This is a png_error at present even though it could be ignored -        * it should never happen, but it is important that if it does, the        * bug is fixed.        */
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal error handling cHRM->XYZ"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_RGB_TO_GRAY */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COLORSPACE */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef
begin_comment
comment|/* This exists solely to work round a warning from GNU C. */
end_comment
begin_function
specifier|static
name|int
comment|/* PRIVATE */
DECL|function|png_gt
name|png_gt
parameter_list|(
name|size_t
name|a
parameter_list|,
name|size_t
name|b
parameter_list|)
block|{
return|return
name|a
operator|>
name|b
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|png_gt
define|#
directive|define
name|png_gt
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_check_IHDR
name|png_check_IHDR
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|width
parameter_list|,
name|png_uint_32
name|height
parameter_list|,
name|int
name|bit_depth
parameter_list|,
name|int
name|color_type
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|int
name|filter_type
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check for width and height valid values */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image width is zero in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image width in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|png_gt
argument_list|(
operator|(
operator|(
name|width
operator|+
literal|7
operator|)
operator|&
operator|(
operator|~
literal|7
operator|)
operator|)
argument_list|,
operator|(
operator|(
name|PNG_SIZE_MAX
operator|-
literal|48
comment|/* big_row_buf hack */
operator|-
literal|1
operator|)
comment|/* filter byte */
operator|/
literal|8
operator|)
comment|/* 8-byte RGBA pixels */
operator|-
literal|1
argument_list|)
condition|)
comment|/* extra max_pixel_depth pad */
block|{
comment|/* The size of the row must be within the limits of this architecture.        * Because the read code can perform arbitrary transformations the        * maximum size is checked here.  Because the code in png_read_start_row        * adds extra space "for safety's sake" in several places a conservative        * limit is used here.        *        * NOTE: it would be far better to check the size that is actually used,        * but the effect in the real world is minor and the changes are more        * extensive, therefore much more dangerous and much more difficult to        * write in a way that avoids compiler warnings.        */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image width is too large for this architecture"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|width
operator|>
name|png_ptr
operator|->
name|user_width_max
condition|)
else|#
directive|else
if|if
condition|(
name|width
operator|>
name|PNG_USER_WIDTH_MAX
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image width exceeds user limit in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image height is zero in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|>
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image height in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|height
operator|>
name|png_ptr
operator|->
name|user_height_max
condition|)
else|#
directive|else
if|if
condition|(
name|height
operator|>
name|PNG_USER_HEIGHT_MAX
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image height exceeds user limit in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check other values */
if|if
condition|(
name|bit_depth
operator|!=
literal|1
operator|&&
name|bit_depth
operator|!=
literal|2
operator|&&
name|bit_depth
operator|!=
literal|4
operator|&&
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|color_type
operator|<
literal|0
operator|||
name|color_type
operator|==
literal|1
operator|||
name|color_type
operator|==
literal|5
operator|||
name|color_type
operator|>
literal|6
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid color type in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
operator|&&
name|bit_depth
operator|>
literal|8
operator|)
operator|||
operator|(
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|&&
name|bit_depth
operator|<
literal|8
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid color type/bit depth combination in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|interlace_type
operator|>=
name|PNG_INTERLACE_LAST
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown interlace method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|compression_type
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown compression method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
comment|/* Accept filter_method 64 (intrapixel differencing) only if     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and     * 2. Libpng did not read a PNG signature (this filter_method is only     *    used in PNG datastreams that are embedded in MNG datastreams) and     * 3. The application called png_permit_mng_features with a mask that     *    included PNG_FLAG_MNG_FILTER_64 and     * 4. The filter_method is 64 and     * 5. The color_type is RGB or RGBA     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|!=
literal|0
operator|&&
name|png_ptr
operator|->
name|mng_features_permitted
operator|!=
literal|0
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"MNG features are not allowed in a PNG datastream"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|1
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid IHDR data"
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_pCAL_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* ASCII to fp functions */
end_comment
begin_comment
comment|/* Check an ASCII formated floating point value, see the more detailed  * comments in pngpriv.h  */
end_comment
begin_comment
comment|/* The following is used internally to preserve the sticky flags */
end_comment
begin_define
DECL|macro|png_fp_add
define|#
directive|define
name|png_fp_add
parameter_list|(
name|state
parameter_list|,
name|flags
parameter_list|)
value|((state) |= (flags))
end_define
begin_define
DECL|macro|png_fp_set
define|#
directive|define
name|png_fp_set
parameter_list|(
name|state
parameter_list|,
name|value
parameter_list|)
value|((state) = (value) | ((state)& PNG_FP_STICKY))
end_define
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_check_fp_number
name|png_check_fp_number
parameter_list|(
name|png_const_charp
name|string
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|int
modifier|*
name|statep
parameter_list|,
name|png_size_tp
name|whereami
parameter_list|)
block|{
name|int
name|state
init|=
operator|*
name|statep
decl_stmt|;
name|png_size_t
name|i
init|=
operator|*
name|whereami
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|int
name|type
decl_stmt|;
comment|/* First find the type of the next character */
switch|switch
condition|(
name|string
index|[
name|i
index|]
condition|)
block|{
case|case
literal|43
case|:
name|type
operator|=
name|PNG_FP_SAW_SIGN
expr_stmt|;
break|break;
case|case
literal|45
case|:
name|type
operator|=
name|PNG_FP_SAW_SIGN
operator|+
name|PNG_FP_NEGATIVE
expr_stmt|;
break|break;
case|case
literal|46
case|:
name|type
operator|=
name|PNG_FP_SAW_DOT
expr_stmt|;
break|break;
case|case
literal|48
case|:
name|type
operator|=
name|PNG_FP_SAW_DIGIT
expr_stmt|;
break|break;
case|case
literal|49
case|:
case|case
literal|50
case|:
case|case
literal|51
case|:
case|case
literal|52
case|:
case|case
literal|53
case|:
case|case
literal|54
case|:
case|case
literal|55
case|:
case|case
literal|56
case|:
case|case
literal|57
case|:
name|type
operator|=
name|PNG_FP_SAW_DIGIT
operator|+
name|PNG_FP_NONZERO
expr_stmt|;
break|break;
case|case
literal|69
case|:
case|case
literal|101
case|:
name|type
operator|=
name|PNG_FP_SAW_E
expr_stmt|;
break|break;
default|default:
goto|goto
name|PNG_FP_End
goto|;
block|}
comment|/* Now deal with this type according to the current        * state, the type is arranged to not overlap the        * bits of the PNG_FP_STATE.        */
switch|switch
condition|(
operator|(
name|state
operator|&
name|PNG_FP_STATE
operator|)
operator|+
operator|(
name|type
operator|&
name|PNG_FP_SAW_ANY
operator|)
condition|)
block|{
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_SIGN
case|:
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_ANY
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
comment|/* not a part of the number */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_DOT
case|:
comment|/* Ok as trailer, ok as lead of fraction. */
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DOT
operator|)
operator|!=
literal|0
condition|)
comment|/* two dots */
goto|goto
name|PNG_FP_End
goto|;
elseif|else
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|!=
literal|0
condition|)
comment|/* trailing dot? */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_FRACTION
operator||
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_DIGIT
case|:
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DOT
operator|)
operator|!=
literal|0
condition|)
comment|/* delayed fraction */
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_FRACTION
operator||
name|PNG_FP_SAW_DOT
argument_list|)
expr_stmt|;
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
operator||
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_E
case|:
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_EXPONENT
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:          goto PNG_FP_End; ** no sign in fraction */
comment|/* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:          goto PNG_FP_End; ** Because SAW_DOT is always set */
case|case
name|PNG_FP_FRACTION
operator|+
name|PNG_FP_SAW_DIGIT
case|:
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
operator||
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_FRACTION
operator|+
name|PNG_FP_SAW_E
case|:
comment|/* This is correct because the trailing '.' on an           * integer is handled above - so we can only get here           * with the sequence ".E" (with no preceding digits).           */
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_EXPONENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_EXPONENT
operator|+
name|PNG_FP_SAW_SIGN
case|:
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_ANY
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
comment|/* not a part of the number */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_SIGN
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:          goto PNG_FP_End; */
case|case
name|PNG_FP_EXPONENT
operator|+
name|PNG_FP_SAW_DIGIT
case|:
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_DIGIT
operator||
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:          goto PNG_FP_End; */
default|default:
goto|goto
name|PNG_FP_End
goto|;
comment|/* I.e. break 2 */
block|}
comment|/* The character seems ok, continue. */
operator|++
name|i
expr_stmt|;
block|}
name|PNG_FP_End
label|:
comment|/* Here at the end, update the state and return the correct     * return code.     */
operator|*
name|statep
operator|=
name|state
expr_stmt|;
operator|*
name|whereami
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/* The same but for a complete string. */
end_comment
begin_function
name|int
DECL|function|png_check_fp_string
name|png_check_fp_string
parameter_list|(
name|png_const_charp
name|string
parameter_list|,
name|png_size_t
name|size
parameter_list|)
block|{
name|int
name|state
init|=
literal|0
decl_stmt|;
name|png_size_t
name|char_index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_check_fp_number
argument_list|(
name|string
argument_list|,
name|size
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|char_index
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|char_index
operator|==
name|size
operator|||
name|string
index|[
name|char_index
index|]
operator|==
literal|0
operator|)
condition|)
return|return
name|state
comment|/* must be non-zero - see above */
return|;
return|return
literal|0
return|;
comment|/* i.e. fail */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* pCAL || sCAL */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* Utility used below - a simple accurate power of ten from an integral  * exponent.  */
end_comment
begin_function
specifier|static
name|double
DECL|function|png_pow10
name|png_pow10
parameter_list|(
name|int
name|power
parameter_list|)
block|{
name|int
name|recip
init|=
literal|0
decl_stmt|;
name|double
name|d
init|=
literal|1
decl_stmt|;
comment|/* Handle negative exponent with a reciprocal at the end because     * 10 is exact whereas .1 is inexact in base 2     */
if|if
condition|(
name|power
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|power
operator|<
name|DBL_MIN_10_EXP
condition|)
return|return
literal|0
return|;
name|recip
operator|=
literal|1
operator|,
name|power
operator|=
operator|-
name|power
expr_stmt|;
block|}
if|if
condition|(
name|power
operator|>
literal|0
condition|)
block|{
comment|/* Decompose power bitwise. */
name|double
name|mult
init|=
literal|10
decl_stmt|;
do|do
block|{
if|if
condition|(
name|power
operator|&
literal|1
condition|)
name|d
operator|*=
name|mult
expr_stmt|;
name|mult
operator|*=
name|mult
expr_stmt|;
name|power
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|power
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|recip
operator|!=
literal|0
condition|)
name|d
operator|=
literal|1
operator|/
name|d
expr_stmt|;
block|}
comment|/* else power is 0 and d is 1 */
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/* Function to format a floating point value in ASCII with a given  * precision.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_ascii_from_fp
name|png_ascii_from_fp
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_charp
name|ascii
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|double
name|fp
parameter_list|,
name|unsigned
name|int
name|precision
parameter_list|)
block|{
comment|/* We use standard functions from math.h, but not printf because     * that would require stdio.  The caller must supply a buffer of     * sufficient size or we will png_error.  The tests on size and     * the space in ascii[] consumed are indicated below.     */
if|if
condition|(
name|precision
operator|<
literal|1
condition|)
name|precision
operator|=
name|DBL_DIG
expr_stmt|;
comment|/* Enforce the limit of the implementation precision too. */
if|if
condition|(
name|precision
operator|>
name|DBL_DIG
operator|+
literal|1
condition|)
name|precision
operator|=
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
comment|/* Basic sanity checks */
if|if
condition|(
name|size
operator|>=
name|precision
operator|+
literal|5
condition|)
comment|/* See the requirements below. */
block|{
if|if
condition|(
name|fp
operator|<
literal|0
condition|)
block|{
name|fp
operator|=
operator|-
name|fp
expr_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|45
expr_stmt|;
comment|/* '-'  PLUS 1 TOTAL 1 */
operator|--
name|size
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|>=
name|DBL_MIN
operator|&&
name|fp
operator|<=
name|DBL_MAX
condition|)
block|{
name|int
name|exp_b10
decl_stmt|;
comment|/* A base 10 exponent */
name|double
name|base
decl_stmt|;
comment|/* 10^exp_b10 */
comment|/* First extract a base 10 exponent of the number,           * the calculation below rounds down when converting           * from base 2 to base 10 (multiply by log10(2) -           * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to           * be increased.  Note that the arithmetic shift           * performs a floor() unlike C arithmetic - using a           * C multiply would break the following for negative           * exponents.           */
operator|(
name|void
operator|)
name|frexp
argument_list|(
name|fp
argument_list|,
operator|&
name|exp_b10
argument_list|)
expr_stmt|;
comment|/* exponent to base 2 */
name|exp_b10
operator|=
operator|(
name|exp_b10
operator|*
literal|77
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/*<= exponent to base 10 */
comment|/* Avoid underflow here. */
name|base
operator|=
name|png_pow10
argument_list|(
name|exp_b10
argument_list|)
expr_stmt|;
comment|/* May underflow */
while|while
condition|(
name|base
operator|<
name|DBL_MIN
operator|||
name|base
operator|<
name|fp
condition|)
block|{
comment|/* And this may overflow. */
name|double
name|test
init|=
name|png_pow10
argument_list|(
name|exp_b10
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|<=
name|DBL_MAX
condition|)
operator|++
name|exp_b10
operator|,
name|base
operator|=
name|test
expr_stmt|;
else|else
break|break;
block|}
comment|/* Normalize fp and correct exp_b10, after this fp is in the           * range [.1,1) and exp_b10 is both the exponent and the digit           * *before* which the decimal point should be inserted           * (starting with 0 for the first digit).  Note that this           * works even if 10^exp_b10 is out of range because of the           * test on DBL_MAX above.           */
name|fp
operator|/=
name|base
expr_stmt|;
while|while
condition|(
name|fp
operator|>=
literal|1
condition|)
name|fp
operator|/=
literal|10
operator|,
operator|++
name|exp_b10
expr_stmt|;
comment|/* Because of the code above fp may, at this point, be           * less than .1, this is ok because the code below can           * handle the leading zeros this generates, so no attempt           * is made to correct that here.           */
block|{
name|unsigned
name|int
name|czero
decl_stmt|,
name|clead
decl_stmt|,
name|cdigits
decl_stmt|;
name|char
name|exponent
index|[
literal|10
index|]
decl_stmt|;
comment|/* Allow up to two leading zeros - this will not lengthen              * the number compared to using E-n.              */
if|if
condition|(
name|exp_b10
operator|<
literal|0
operator|&&
name|exp_b10
operator|>
operator|-
literal|3
condition|)
comment|/* PLUS 3 TOTAL 4 */
block|{
name|czero
operator|=
operator|-
name|exp_b10
expr_stmt|;
comment|/* PLUS 2 digits: TOTAL 3 */
name|exp_b10
operator|=
literal|0
expr_stmt|;
comment|/* Dot added below before first output. */
block|}
else|else
name|czero
operator|=
literal|0
expr_stmt|;
comment|/* No zeros to add */
comment|/* Generate the digit list, stripping trailing zeros and              * inserting a '.' before a digit if the exponent is 0.              */
name|clead
operator|=
name|czero
expr_stmt|;
comment|/* Count of leading zeros */
name|cdigits
operator|=
literal|0
expr_stmt|;
comment|/* Count of digits in list. */
do|do
block|{
name|double
name|d
decl_stmt|;
name|fp
operator|*=
literal|10
expr_stmt|;
comment|/* Use modf here, not floor and subtract, so that                 * the separation is done in one step.  At the end                 * of the loop don't break the number into parts so                 * that the final digit is rounded.                 */
if|if
condition|(
name|cdigits
operator|+
name|czero
operator|+
literal|1
operator|<
name|precision
operator|+
name|clead
condition|)
name|fp
operator|=
name|modf
argument_list|(
name|fp
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|=
name|floor
argument_list|(
name|fp
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|9
condition|)
block|{
comment|/* Rounding up to 10, handle that here. */
if|if
condition|(
name|czero
operator|>
literal|0
condition|)
block|{
operator|--
name|czero
operator|,
name|d
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdigits
operator|==
literal|0
condition|)
operator|--
name|clead
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|cdigits
operator|>
literal|0
operator|&&
name|d
operator|>
literal|9
condition|)
block|{
name|int
name|ch
init|=
operator|*
operator|--
name|ascii
decl_stmt|;
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
operator|++
name|exp_b10
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|46
condition|)
block|{
name|ch
operator|=
operator|*
operator|--
name|ascii
operator|,
operator|++
name|size
expr_stmt|;
comment|/* Advance exp_b10 to '1', so that the                                * decimal point happens after the                                * previous digit.                                */
name|exp_b10
operator|=
literal|1
expr_stmt|;
block|}
operator|--
name|cdigits
expr_stmt|;
name|d
operator|=
name|ch
operator|-
literal|47
expr_stmt|;
comment|/* I.e. 1+(ch-48) */
block|}
comment|/* Did we reach the beginning? If so adjust the                          * exponent but take into account the leading                          * decimal point.                          */
if|if
condition|(
name|d
operator|>
literal|9
condition|)
comment|/* cdigits == 0 */
block|{
if|if
condition|(
name|exp_b10
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Leading decimal point (plus zeros?), if                                * we lose the decimal point here it must                                * be reentered below.                                */
name|int
name|ch
init|=
operator|*
operator|--
name|ascii
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|46
condition|)
operator|++
name|size
operator|,
name|exp_b10
operator|=
literal|1
expr_stmt|;
comment|/* Else lost a leading zero, so 'exp_b10' is                                * still ok at (-1)                                */
block|}
else|else
operator|++
name|exp_b10
expr_stmt|;
comment|/* In all cases we output a '1' */
name|d
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|fp
operator|=
literal|0
expr_stmt|;
comment|/* Guarantees termination below. */
block|}
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
operator|++
name|czero
expr_stmt|;
if|if
condition|(
name|cdigits
operator|==
literal|0
condition|)
operator|++
name|clead
expr_stmt|;
block|}
else|else
block|{
comment|/* Included embedded zeros in the digit count. */
name|cdigits
operator|+=
name|czero
operator|-
name|clead
expr_stmt|;
name|clead
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|czero
operator|>
literal|0
condition|)
block|{
comment|/* exp_b10 == (-1) means we just output the decimal                       * place - after the DP don't adjust 'exp_b10' any                       * more!                       */
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|exp_b10
operator|==
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|46
operator|,
operator|--
name|size
expr_stmt|;
comment|/* PLUS 1: TOTAL 4 */
operator|--
name|exp_b10
expr_stmt|;
block|}
operator|*
name|ascii
operator|++
operator|=
literal|48
operator|,
operator|--
name|czero
expr_stmt|;
block|}
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|exp_b10
operator|==
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|46
operator|,
operator|--
name|size
expr_stmt|;
comment|/* counted above */
operator|--
name|exp_b10
expr_stmt|;
block|}
operator|*
name|ascii
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
operator|(
name|int
operator|)
name|d
argument_list|)
operator|,
operator|++
name|cdigits
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cdigits
operator|+
name|czero
operator|<
name|precision
operator|+
name|clead
operator|&&
name|fp
operator|>
name|DBL_MIN
condition|)
do|;
comment|/* The total output count (max) is now 4+precision */
comment|/* Check for an exponent, if we don't need one we are              * done and just need to terminate the string.  At              * this point exp_b10==(-1) is effectively if flag - it got              * to '-1' because of the decrement after outputting              * the decimal point above (the exponent required is              * *not* -1!)              */
if|if
condition|(
name|exp_b10
operator|>=
operator|(
operator|-
literal|1
operator|)
operator|&&
name|exp_b10
operator|<=
literal|2
condition|)
block|{
comment|/* The following only happens if we didn't output the                 * leading zeros above for negative exponent, so this                 * doesn't add to the digit requirement.  Note that the                 * two zeros here can only be output if the two leading                 * zeros were *not* output, so this doesn't increase                 * the output count.                 */
while|while
condition|(
operator|--
name|exp_b10
operator|>=
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
comment|/* Total buffer requirement (including the '\0') is                 * 5+precision - see check at the start.                 */
return|return;
block|}
comment|/* Here if an exponent is required, adjust size for              * the digits we output but did not count.  The total              * digit output here so far is at most 1+precision - no              * decimal point and no leading or trailing zeros have              * been output.              */
name|size
operator|-=
name|cdigits
expr_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|69
operator|,
operator|--
name|size
expr_stmt|;
comment|/* 'E': PLUS 1 TOTAL 2+precision */
comment|/* The following use of an unsigned temporary avoids ambiguities in              * the signed arithmetic on exp_b10 and permits GCC at least to do              * better optimization.              */
block|{
name|unsigned
name|int
name|uexp_b10
decl_stmt|;
if|if
condition|(
name|exp_b10
operator|<
literal|0
condition|)
block|{
operator|*
name|ascii
operator|++
operator|=
literal|45
operator|,
operator|--
name|size
expr_stmt|;
comment|/* '-': PLUS 1 TOTAL 3+precision */
name|uexp_b10
operator|=
operator|-
name|exp_b10
expr_stmt|;
block|}
else|else
name|uexp_b10
operator|=
name|exp_b10
expr_stmt|;
name|cdigits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|uexp_b10
operator|>
literal|0
condition|)
block|{
name|exponent
index|[
name|cdigits
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
name|uexp_b10
operator|%
literal|10
argument_list|)
expr_stmt|;
name|uexp_b10
operator|/=
literal|10
expr_stmt|;
block|}
block|}
comment|/* Need another size check here for the exponent digits, so              * this need not be considered above.              */
if|if
condition|(
name|size
operator|>
name|cdigits
condition|)
block|{
while|while
condition|(
name|cdigits
operator|>
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
name|exponent
index|[
operator|--
name|cdigits
index|]
expr_stmt|;
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|fp
operator|>=
name|DBL_MIN
operator|)
condition|)
block|{
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
comment|/* '0' */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|*
name|ascii
operator|++
operator|=
literal|105
expr_stmt|;
comment|/* 'i' */
operator|*
name|ascii
operator|++
operator|=
literal|110
expr_stmt|;
comment|/* 'n' */
operator|*
name|ascii
operator|++
operator|=
literal|102
expr_stmt|;
comment|/* 'f' */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Here on buffer too small. */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ASCII conversion buffer too small"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* Function to format a fixed point value in ASCII.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_ascii_from_fixed
name|png_ascii_from_fixed
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_charp
name|ascii
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|png_fixed_point
name|fp
parameter_list|)
block|{
comment|/* Require space for 10 decimal digits, a decimal point, a minus sign and a     * trailing \0, 13 characters:     */
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
name|png_uint_32
name|num
decl_stmt|;
comment|/* Avoid overflow here on the minimum integer. */
if|if
condition|(
name|fp
operator|<
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|45
operator|,
name|num
operator|=
operator|-
name|fp
expr_stmt|;
else|else
name|num
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0x80000000
condition|)
comment|/* else overflowed */
block|{
name|unsigned
name|int
name|ndigits
init|=
literal|0
decl_stmt|,
name|first
init|=
literal|16
comment|/* flag value */
decl_stmt|;
name|char
name|digits
index|[
literal|10
index|]
decl_stmt|;
while|while
condition|(
name|num
condition|)
block|{
comment|/* Split the low digit off num: */
name|unsigned
name|int
name|tmp
init|=
name|num
operator|/
literal|10
decl_stmt|;
name|num
operator|-=
name|tmp
operator|*
literal|10
expr_stmt|;
name|digits
index|[
name|ndigits
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
name|num
argument_list|)
expr_stmt|;
comment|/* Record the first non-zero digit, note that this is a number              * starting at 1, it's not actually the array index.              */
if|if
condition|(
name|first
operator|==
literal|16
operator|&&
name|num
operator|>
literal|0
condition|)
name|first
operator|=
name|ndigits
expr_stmt|;
name|num
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|ndigits
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|ndigits
operator|>
literal|5
condition|)
operator|*
name|ascii
operator|++
operator|=
name|digits
index|[
operator|--
name|ndigits
index|]
expr_stmt|;
comment|/* The remaining digits are fractional digits, ndigits is '5' or              * smaller at this point.  It is certainly not zero.  Check for a              * non-zero fractional digit:              */
if|if
condition|(
name|first
operator|<=
literal|5
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|46
expr_stmt|;
comment|/* decimal point */
comment|/* ndigits may be<5 for small numbers, output leading zeros                 * then ndigits digits to first:                 */
name|i
operator|=
literal|5
expr_stmt|;
while|while
condition|(
name|ndigits
operator|<
name|i
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|48
operator|,
operator|--
name|i
expr_stmt|;
while|while
condition|(
name|ndigits
operator|>=
name|first
condition|)
operator|*
name|ascii
operator|++
operator|=
name|digits
index|[
operator|--
name|ndigits
index|]
expr_stmt|;
comment|/* Don't output the trailing zeros! */
block|}
block|}
else|else
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
comment|/* And null terminate the string: */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Here on buffer too small. */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ASCII conversion buffer too small"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FIXED_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SCAL */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|PNG_FIXED_POINT_MACRO_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|PNG_gAMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_cHRM_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
argument_list|)
operator|)
end_if
begin_function
name|png_fixed_point
DECL|function|png_fixed
name|png_fixed
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|double
name|fp
parameter_list|,
name|png_const_charp
name|text
parameter_list|)
block|{
name|double
name|r
init|=
name|floor
argument_list|(
literal|100000
operator|*
name|fp
operator|+
literal|.5
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|>
literal|2147483647.
operator|||
name|r
operator|<
operator|-
literal|2147483648.
condition|)
name|png_fixed_error
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_ERROR_TEXT_SUPPORTED
name|PNG_UNUSED
argument_list|(
argument|text
argument_list|)
endif|#
directive|endif
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_GAMMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_COLORSPACE_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_READ_pHYs_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* muldiv functions */
end_comment
begin_comment
comment|/* This API takes signed arguments and rounds the result to the nearest  * integer (or, for a fixed point number - the standard argument - to  * the nearest .00001).  Overflow and divide by zero are signalled in  * the result, a boolean - true on success, false on overflow.  */
end_comment
begin_function
name|int
DECL|function|png_muldiv
name|png_muldiv
parameter_list|(
name|png_fixed_point_p
name|res
parameter_list|,
name|png_fixed_point
name|a
parameter_list|,
name|png_int_32
name|times
parameter_list|,
name|png_int_32
name|divisor
parameter_list|)
block|{
comment|/* Return a * times / divisor, rounded. */
if|if
condition|(
name|divisor
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|times
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|a
decl_stmt|;
name|r
operator|*=
name|times
expr_stmt|;
name|r
operator|/=
name|divisor
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
comment|/* A png_fixed_point is a 32-bit integer. */
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
block|{
operator|*
name|res
operator|=
operator|(
name|png_fixed_point
operator|)
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
else|#
directive|else
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|A
decl_stmt|,
name|T
decl_stmt|,
name|D
decl_stmt|;
name|png_uint_32
name|s16
decl_stmt|,
name|s32
decl_stmt|,
name|s00
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|negative
operator|=
literal|1
operator|,
name|A
operator|=
operator|-
name|a
expr_stmt|;
else|else
name|A
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|times
operator|<
literal|0
condition|)
name|negative
operator|=
operator|!
name|negative
operator|,
name|T
operator|=
operator|-
name|times
expr_stmt|;
else|else
name|T
operator|=
name|times
expr_stmt|;
if|if
condition|(
name|divisor
operator|<
literal|0
condition|)
name|negative
operator|=
operator|!
name|negative
operator|,
name|D
operator|=
operator|-
name|divisor
expr_stmt|;
else|else
name|D
operator|=
name|divisor
expr_stmt|;
comment|/* Following can't overflow because the arguments only           * have 31 bits each, however the result may be 32 bits.           */
name|s16
operator|=
operator|(
name|A
operator|>>
literal|16
operator|)
operator|*
operator|(
name|T
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|A
operator|&
literal|0xffff
operator|)
operator|*
operator|(
name|T
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* Can't overflow because the a*times bit is only 30           * bits at most.           */
name|s32
operator|=
operator|(
name|A
operator|>>
literal|16
operator|)
operator|*
operator|(
name|T
operator|>>
literal|16
operator|)
operator|+
operator|(
name|s16
operator|>>
literal|16
operator|)
expr_stmt|;
name|s00
operator|=
operator|(
name|A
operator|&
literal|0xffff
operator|)
operator|*
operator|(
name|T
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|s16
operator|=
operator|(
name|s16
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
expr_stmt|;
name|s00
operator|+=
name|s16
expr_stmt|;
if|if
condition|(
name|s00
operator|<
name|s16
condition|)
operator|++
name|s32
expr_stmt|;
comment|/* carry */
if|if
condition|(
name|s32
operator|<
name|D
condition|)
comment|/* else overflow */
block|{
comment|/* s32.s00 is now the 64-bit product, do a standard              * division, we know that s32< D, so the maximum              * required shift is 31.              */
name|int
name|bitshift
init|=
literal|32
decl_stmt|;
name|png_fixed_point
name|result
init|=
literal|0
decl_stmt|;
comment|/* NOTE: signed */
while|while
condition|(
operator|--
name|bitshift
operator|>=
literal|0
condition|)
block|{
name|png_uint_32
name|d32
decl_stmt|,
name|d00
decl_stmt|;
if|if
condition|(
name|bitshift
operator|>
literal|0
condition|)
name|d32
operator|=
name|D
operator|>>
operator|(
literal|32
operator|-
name|bitshift
operator|)
operator|,
name|d00
operator|=
name|D
operator|<<
name|bitshift
expr_stmt|;
else|else
name|d32
operator|=
literal|0
operator|,
name|d00
operator|=
name|D
expr_stmt|;
if|if
condition|(
name|s32
operator|>
name|d32
condition|)
block|{
if|if
condition|(
name|s00
operator|<
name|d00
condition|)
operator|--
name|s32
expr_stmt|;
comment|/* carry */
name|s32
operator|-=
name|d32
operator|,
name|s00
operator|-=
name|d00
operator|,
name|result
operator|+=
literal|1
operator|<<
name|bitshift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s32
operator|==
name|d32
operator|&&
name|s00
operator|>=
name|d00
condition|)
name|s32
operator|=
literal|0
operator|,
name|s00
operator|-=
name|d00
operator|,
name|result
operator|+=
literal|1
operator|<<
name|bitshift
expr_stmt|;
block|}
comment|/* Handle the rounding. */
if|if
condition|(
name|s00
operator|>=
operator|(
name|D
operator|>>
literal|1
operator|)
condition|)
operator|++
name|result
expr_stmt|;
if|if
condition|(
name|negative
operator|!=
literal|0
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
comment|/* Check for overflow. */
if|if
condition|(
operator|(
name|negative
operator|!=
literal|0
operator|&&
name|result
operator|<=
literal|0
operator|)
operator|||
operator|(
name|negative
operator|==
literal|0
operator|&&
name|result
operator|>=
literal|0
operator|)
condition|)
block|{
operator|*
name|res
operator|=
name|result
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA || INCH_CONVERSIONS */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* The following is for when the caller doesn't much care about the  * result.  */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_muldiv_warn
name|png_muldiv_warn
parameter_list|(
name|png_const_structrp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|a
parameter_list|,
name|png_int_32
name|times
parameter_list|,
name|png_int_32
name|divisor
parameter_list|)
block|{
name|png_fixed_point
name|result
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|result
argument_list|,
name|a
argument_list|,
name|times
argument_list|,
name|divisor
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|result
return|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"fixed point overflow ignored"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* more fixed point functions for gamma */
end_comment
begin_comment
comment|/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_reciprocal
name|png_reciprocal
parameter_list|(
name|png_fixed_point
name|a
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|floor
argument_list|(
literal|1E10
operator|/
name|a
operator|+
literal|.5
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
literal|100000
argument_list|,
literal|100000
argument_list|,
name|a
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|res
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* error/overflow */
block|}
end_function
begin_comment
comment|/* This is the shared test on whether a gamma value is 'significant' - whether  * it is worth doing gamma correction.  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_gamma_significant
name|png_gamma_significant
parameter_list|(
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
return|return
name|gamma_val
operator|<
name|PNG_FP_1
operator|-
name|PNG_GAMMA_THRESHOLD_FIXED
operator|||
name|gamma_val
operator|>
name|PNG_FP_1
operator|+
name|PNG_GAMMA_THRESHOLD_FIXED
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
end_ifdef
begin_comment
comment|/* A local convenience routine. */
end_comment
begin_function
specifier|static
name|png_fixed_point
DECL|function|png_product2
name|png_product2
parameter_list|(
name|png_fixed_point
name|a
parameter_list|,
name|png_fixed_point
name|b
parameter_list|)
block|{
comment|/* The required result is 1/a * 1/b; the following preserves accuracy. */
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|a
operator|*
literal|1E
operator|-
literal|5
decl_stmt|;
name|r
operator|*=
name|b
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
literal|100000
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|res
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* overflow */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 16BIT */
end_comment
begin_comment
comment|/* The inverse of the above. */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_reciprocal2
name|png_reciprocal2
parameter_list|(
name|png_fixed_point
name|a
parameter_list|,
name|png_fixed_point
name|b
parameter_list|)
block|{
comment|/* The required result is 1/a * 1/b; the following preserves accuracy. */
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
if|if
condition|(
name|a
operator|!=
literal|0
operator|&&
name|b
operator|!=
literal|0
condition|)
block|{
name|double
name|r
init|=
literal|1E15
operator|/
name|a
decl_stmt|;
name|r
operator|/=
name|b
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
block|}
else|#
directive|else
comment|/* This may overflow because the range of png_fixed_point isn't symmetric,     * but this API is only used for the product of file and screen gamma so it     * doesn't matter that the smallest number it can produce is 1/21474, not     * 1/100000     */
name|png_fixed_point
name|res
init|=
name|png_product2
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|png_reciprocal
argument_list|(
name|res
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* overflow */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* gamma table code */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
end_ifndef
begin_comment
comment|/* Fixed point gamma.  *  * The code to calculate the tables used below can be found in the shell script  * contrib/tools/intgamma.sh  *  * To calculate gamma this code implements fast log() and exp() calls using only  * fixed point arithmetic.  This code has sufficient precision for either 8-bit  * or 16-bit sample values.  *  * The tables used here were calculated using simple 'bc' programs, but C double  * precision floating point arithmetic would work fine.  *  * 8-bit log table  *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to  *   255, so it's the base 2 logarithm of a normalized 8-bit floating point  *   mantissa.  The numbers are 32-bit fractions.  */
end_comment
begin_decl_stmt
specifier|static
specifier|const
name|png_uint_32
DECL|variable|png_8bit_l2
name|png_8bit_l2
index|[
literal|128
index|]
init|=
block|{
literal|4270715492U
block|,
literal|4222494797U
block|,
literal|4174646467U
block|,
literal|4127164793U
block|,
literal|4080044201U
block|,
literal|4033279239U
block|,
literal|3986864580U
block|,
literal|3940795015U
block|,
literal|3895065449U
block|,
literal|3849670902U
block|,
literal|3804606499U
block|,
literal|3759867474U
block|,
literal|3715449162U
block|,
literal|3671346997U
block|,
literal|3627556511U
block|,
literal|3584073329U
block|,
literal|3540893168U
block|,
literal|3498011834U
block|,
literal|3455425220U
block|,
literal|3413129301U
block|,
literal|3371120137U
block|,
literal|3329393864U
block|,
literal|3287946700U
block|,
literal|3246774933U
block|,
literal|3205874930U
block|,
literal|3165243125U
block|,
literal|3124876025U
block|,
literal|3084770202U
block|,
literal|3044922296U
block|,
literal|3005329011U
block|,
literal|2965987113U
block|,
literal|2926893432U
block|,
literal|2888044853U
block|,
literal|2849438323U
block|,
literal|2811070844U
block|,
literal|2772939474U
block|,
literal|2735041326U
block|,
literal|2697373562U
block|,
literal|2659933400U
block|,
literal|2622718104U
block|,
literal|2585724991U
block|,
literal|2548951424U
block|,
literal|2512394810U
block|,
literal|2476052606U
block|,
literal|2439922311U
block|,
literal|2404001468U
block|,
literal|2368287663U
block|,
literal|2332778523U
block|,
literal|2297471715U
block|,
literal|2262364947U
block|,
literal|2227455964U
block|,
literal|2192742551U
block|,
literal|2158222529U
block|,
literal|2123893754U
block|,
literal|2089754119U
block|,
literal|2055801552U
block|,
literal|2022034013U
block|,
literal|1988449497U
block|,
literal|1955046031U
block|,
literal|1921821672U
block|,
literal|1888774511U
block|,
literal|1855902668U
block|,
literal|1823204291U
block|,
literal|1790677560U
block|,
literal|1758320682U
block|,
literal|1726131893U
block|,
literal|1694109454U
block|,
literal|1662251657U
block|,
literal|1630556815U
block|,
literal|1599023271U
block|,
literal|1567649391U
block|,
literal|1536433567U
block|,
literal|1505374214U
block|,
literal|1474469770U
block|,
literal|1443718700U
block|,
literal|1413119487U
block|,
literal|1382670639U
block|,
literal|1352370686U
block|,
literal|1322218179U
block|,
literal|1292211689U
block|,
literal|1262349810U
block|,
literal|1232631153U
block|,
literal|1203054352U
block|,
literal|1173618059U
block|,
literal|1144320946U
block|,
literal|1115161701U
block|,
literal|1086139034U
block|,
literal|1057251672U
block|,
literal|1028498358U
block|,
literal|999877854U
block|,
literal|971388940U
block|,
literal|943030410U
block|,
literal|914801076U
block|,
literal|886699767U
block|,
literal|858725327U
block|,
literal|830876614U
block|,
literal|803152505U
block|,
literal|775551890U
block|,
literal|748073672U
block|,
literal|720716771U
block|,
literal|693480120U
block|,
literal|666362667U
block|,
literal|639363374U
block|,
literal|612481215U
block|,
literal|585715177U
block|,
literal|559064263U
block|,
literal|532527486U
block|,
literal|506103872U
block|,
literal|479792461U
block|,
literal|453592303U
block|,
literal|427502463U
block|,
literal|401522014U
block|,
literal|375650043U
block|,
literal|349885648U
block|,
literal|324227938U
block|,
literal|298676034U
block|,
literal|273229066U
block|,
literal|247886176U
block|,
literal|222646516U
block|,
literal|197509248U
block|,
literal|172473545U
block|,
literal|147538590U
block|,
literal|122703574U
block|,
literal|97967701U
block|,
literal|73330182U
block|,
literal|48790236U
block|,
literal|24347096U
block|,
literal|0U
if|#
directive|if
literal|0
comment|/* The following are the values for 16-bit tables - these work fine for the     * 8-bit conversions but produce very slightly larger errors in the 16-bit     * log (about 1.2 as opposed to 0.7 absolute error in the final value).  To     * use these all the shifts below must be adjusted appropriately.     */
block|65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,    57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,    50170, 49542, 48918, 48298, 47682, 47070, 46462, 45858, 45257, 44661, 44068,    43479, 42894, 42312, 41733, 41159, 40587, 40020, 39455, 38894, 38336, 37782,    37230, 36682, 36137, 35595, 35057, 34521, 33988, 33459, 32932, 32408, 31887,    31369, 30854, 30341, 29832, 29325, 28820, 28319, 27820, 27324, 26830, 26339,    25850, 25364, 24880, 24399, 23920, 23444, 22970, 22499, 22029, 21562, 21098,    20636, 20175, 19718, 19262, 18808, 18357, 17908, 17461, 17016, 16573, 16132,    15694, 15257, 14822, 14390, 13959, 13530, 13103, 12678, 12255, 11834, 11415,    10997, 10582, 10168, 9756, 9346, 8937, 8531, 8126, 7723, 7321, 6921, 6523,    6127, 5732, 5339, 4947, 4557, 4169, 3782, 3397, 3014, 2632, 2251, 1872, 1495,    1119, 744, 372
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|png_int_32
DECL|function|png_log8bit
name|png_log8bit
parameter_list|(
name|unsigned
name|int
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|lg2
init|=
literal|0
decl_stmt|;
comment|/* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,     * because the log is actually negate that means adding 1.  The final     * returned value thus has the range 0 (for 255 input) to 7.994 (for 1     * input), return -1 for the overflow (log 0) case, - so the result is     * always at most 19 bits.     */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0xff
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|=
literal|4
operator|,
name|x
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xc0
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|2
operator|,
name|x
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|1
operator|,
name|x
operator|<<=
literal|1
expr_stmt|;
comment|/* result is at most 19 bits, so this cast is safe: */
return|return
call|(
name|png_int_32
call|)
argument_list|(
operator|(
name|lg2
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|png_8bit_l2
index|[
name|x
operator|-
literal|128
index|]
operator|+
literal|32768
operator|)
operator|>>
literal|16
operator|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* The above gives exact (to 16 binary places) log2 values for 8-bit images,  * for 16-bit images we use the most significant 8 bits of the 16-bit value to  * get an approximation then multiply the approximation by a correction factor  * determined by the remaining up to 8 bits.  This requires an additional step  * in the 16-bit case.  *  * We want log2(value/65535), we have log2(v'/255), where:  *  *    value = v' * 256 + v''  *          = v' * f  *  * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128  * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less  * than 258.  The final factor also needs to correct for the fact that our 8-bit  * value is scaled by 255, whereas the 16-bit values must be scaled by 65535.  *  * This gives a final formula using a calculated value 'x' which is value/v' and  * scaling by 65536 to match the above table:  *  *   log2(x/257) * 65536  *  * Since these numbers are so close to '1' we can use simple linear  * interpolation between the two end values 256/257 (result -368.61) and 258/257  * (result 367.179).  The values used below are scaled by a further 64 to give  * 16-bit precision in the interpolation:  *  * Start (256): -23591  * Zero  (257):      0  * End   (258):  23499  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
end_ifdef
begin_function
specifier|static
name|png_int_32
DECL|function|png_log16bit
name|png_log16bit
parameter_list|(
name|png_uint_32
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|lg2
init|=
literal|0
decl_stmt|;
comment|/* As above, but now the input has 16 bits. */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|=
literal|8
operator|,
name|x
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xf000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|4
operator|,
name|x
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xc000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|2
operator|,
name|x
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|1
operator|,
name|x
operator|<<=
literal|1
expr_stmt|;
comment|/* Calculate the base logarithm from the top 8 bits as a 28-bit fractional     * value.     */
name|lg2
operator|<<=
literal|28
expr_stmt|;
name|lg2
operator|+=
operator|(
name|png_8bit_l2
index|[
operator|(
name|x
operator|>>
literal|8
operator|)
operator|-
literal|128
index|]
operator|+
literal|8
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* Now we need to interpolate the factor, this requires a division by the top     * 8 bits.  Do this with maximum precision.     */
name|x
operator|=
operator|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator|+
operator|(
name|x
operator|>>
literal|9
operator|)
operator|)
operator|/
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,     * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly     * 16 bits to interpolate to get the low bits of the result.  Round the     * answer.  Note that the end point values are scaled by 64 to retain overall     * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust     * the overall scaling by 6-12.  Round at every step.     */
name|x
operator|-=
literal|1U
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|65536U
condition|)
comment|/*<= '257' */
name|lg2
operator|+=
operator|(
operator|(
literal|23591U
operator|*
operator|(
literal|65536U
operator|-
name|x
operator|)
operator|)
operator|+
operator|(
literal|1U
operator|<<
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|)
expr_stmt|;
else|else
name|lg2
operator|-=
operator|(
operator|(
literal|23499U
operator|*
operator|(
name|x
operator|-
literal|65536U
operator|)
operator|)
operator|+
operator|(
literal|1U
operator|<<
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|)
expr_stmt|;
comment|/* Safe, because the result can't have more than 20 bits: */
return|return
call|(
name|png_int_32
call|)
argument_list|(
operator|(
name|lg2
operator|+
literal|2048
operator|)
operator|>>
literal|12
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 16BIT */
end_comment
begin_comment
comment|/* The 'exp()' case must invert the above, taking a 20-bit fixed point  * logarithmic value and returning a 16 or 8-bit number as appropriate.  In  * each case only the low 16 bits are relevant - the fraction - since the  * integer bits (the top 4) simply determine a shift.  *  * The worst case is the 16-bit distinction between 65535 and 65534. This  * requires perhaps spurious accuracy in the decoding of the logarithm to  * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance  * of getting this accuracy in practice.  *  * To deal with this the following exp() function works out the exponent of the  * frational part of the logarithm by using an accurate 32-bit value from the  * top four fractional bits then multiplying in the remaining bits.  */
end_comment
begin_decl_stmt
specifier|static
specifier|const
name|png_uint_32
DECL|variable|png_32bit_exp
name|png_32bit_exp
index|[
literal|16
index|]
init|=
block|{
comment|/* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
literal|4294967295U
block|,
literal|4112874773U
block|,
literal|3938502376U
block|,
literal|3771522796U
block|,
literal|3611622603U
block|,
literal|3458501653U
block|,
literal|3311872529U
block|,
literal|3171459999U
block|,
literal|3037000500U
block|,
literal|2908241642U
block|,
literal|2784941738U
block|,
literal|2666869345U
block|,
literal|2553802834U
block|,
literal|2445529972U
block|,
literal|2341847524U
block|,
literal|2242560872U
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Adjustment table; provided to explain the numbers in the code below. */
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|for (i=11;i>=0;--i){ print i, " ", (1 - e(-(2^i)/65536*l(2))) * 2^(32-i), "\n"}    11 44937.64284865548751208448    10 45180.98734845585101160448     9 45303.31936980687359311872     8 45364.65110595323018870784     7 45395.35850361789624614912     6 45410.72259715102037508096     5 45418.40724413220722311168     4 45422.25021786898173001728     3 45424.17186732298419044352     2 45425.13273269940811464704     1 45425.61317555035558641664     0 45425.85339951654943850496
endif|#
directive|endif
end_endif
begin_function
specifier|static
name|png_uint_32
DECL|function|png_exp
name|png_exp
parameter_list|(
name|png_fixed_point
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|>
literal|0
operator|&&
name|x
operator|<=
literal|0xfffff
condition|)
comment|/* Else overflow or zero (underflow) */
block|{
comment|/* Obtain a 4-bit approximation */
name|png_uint_32
name|e
init|=
name|png_32bit_exp
index|[
operator|(
name|x
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
index|]
decl_stmt|;
comment|/* Incorporate the low 12 bits - these decrease the returned value by        * multiplying by a number less than 1 if the bit is set.  The multiplier        * is determined by the above table and the shift. Notice that the values        * converge on 45426 and this is used to allow linear interpolation of the        * low bits.        */
if|if
condition|(
name|x
operator|&
literal|0x800
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|44938U
operator|)
operator|+
literal|16U
operator|)
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x400
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45181U
operator|)
operator|+
literal|32U
operator|)
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x200
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45303U
operator|)
operator|+
literal|64U
operator|)
operator|>>
literal|7
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x100
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45365U
operator|)
operator|+
literal|128U
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x080
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45395U
operator|)
operator|+
literal|256U
operator|)
operator|>>
literal|9
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x040
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45410U
operator|)
operator|+
literal|512U
operator|)
operator|>>
literal|10
expr_stmt|;
comment|/* And handle the low 6 bits in a single block. */
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|355U
operator|*
operator|(
name|x
operator|&
literal|0x3fU
operator|)
operator|)
operator|+
literal|256U
operator|)
operator|>>
literal|9
expr_stmt|;
comment|/* Handle the upper bits of x. */
name|e
operator|>>=
name|x
operator|>>
literal|16
expr_stmt|;
return|return
name|e
return|;
block|}
comment|/* Check for overflow */
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
return|return
name|png_32bit_exp
index|[
literal|0
index|]
return|;
comment|/* Else underflow */
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|png_byte
DECL|function|png_exp8bit
name|png_exp8bit
parameter_list|(
name|png_fixed_point
name|lg2
parameter_list|)
block|{
comment|/* Get a 32-bit value: */
name|png_uint_32
name|x
init|=
name|png_exp
argument_list|(
name|lg2
argument_list|)
decl_stmt|;
comment|/* Convert the 32-bit value to 0..255 by multiplying by 256-1. Note that the     * second, rounding, step can't overflow because of the first, subtraction,     * step.     */
name|x
operator|-=
name|x
operator|>>
literal|8
expr_stmt|;
return|return
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|x
operator|+
literal|0x7fffffU
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
end_ifdef
begin_function
specifier|static
name|png_uint_16
DECL|function|png_exp16bit
name|png_exp16bit
parameter_list|(
name|png_fixed_point
name|lg2
parameter_list|)
block|{
comment|/* Get a 32-bit value: */
name|png_uint_32
name|x
init|=
name|png_exp
argument_list|(
name|lg2
argument_list|)
decl_stmt|;
comment|/* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
name|x
operator|-=
name|x
operator|>>
literal|16
expr_stmt|;
return|return
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|x
operator|+
literal|32767U
operator|)
operator|>>
literal|16
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 16BIT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_ARITHMETIC */
end_comment
begin_function
name|png_byte
DECL|function|png_gamma_8bit_correct
name|png_gamma_8bit_correct
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|<
literal|255
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
comment|/* 'value' is unsigned, ANSI-C90 requires the compiler to correctly           * convert this to a floating point value.  This includes values that           * would overflow if 'value' were to be converted to 'int'.           *           * Apparently GCC, however, does an intermediate conversion to (int)           * on some (ARM) but not all (x86) platforms, possibly because of           * hardware FP limitations.  (E.g. if the hardware conversion always           * assumes the integer register contains a signed value.)  This results           * in ANSI-C undefined behavior for large values.           *           * Other implementations on the same machine might actually be ANSI-C90           * conformant and therefore compile spurious extra code for the large           * values.           *           * We can be reasonably sure that an unsigned to float conversion           * won't be faster than an int to float one.  Therefore this code           * assumes responsibility for the undefined behavior, which it knows           * can't happen because of the check above.           *           * Note the argument to this routine is an (unsigned int) because, on           * 16-bit platforms, it is assigned a value which might be out of           * range for an (int); that would result in undefined behavior in the           * caller if the *argument* ('value') were to be declared (int).           */
name|double
name|r
init|=
name|floor
argument_list|(
literal|255
operator|*
name|pow
argument_list|(
operator|(
name|int
operator|)
comment|/*SAFE*/
name|value
operator|/
literal|255.
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|png_byte
operator|)
name|r
return|;
else|#
directive|else
name|png_int_32
name|lg2
init|=
name|png_log8bit
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|gamma_val
argument_list|,
name|lg2
argument_list|,
name|PNG_FP_1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|png_exp8bit
argument_list|(
name|res
argument_list|)
return|;
comment|/* Overflow. */
name|value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
call|(
name|png_byte
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
end_ifdef
begin_function
name|png_uint_16
DECL|function|png_gamma_16bit_correct
name|png_gamma_16bit_correct
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|<
literal|65535
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
comment|/* The same (unsigned int)->(double) constraints apply here as above,           * however in this case the (unsigned int) to (int) conversion can           * overflow on an ANSI-C90 compliant system so the cast needs to ensure           * that this is not possible.           */
name|double
name|r
init|=
name|floor
argument_list|(
literal|65535
operator|*
name|pow
argument_list|(
operator|(
name|png_int_32
operator|)
name|value
operator|/
literal|65535.
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|png_uint_16
operator|)
name|r
return|;
else|#
directive|else
name|png_int_32
name|lg2
init|=
name|png_log16bit
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|gamma_val
argument_list|,
name|lg2
argument_list|,
name|PNG_FP_1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|png_exp16bit
argument_list|(
name|res
argument_list|)
return|;
comment|/* Overflow. */
name|value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|png_uint_16
operator|)
name|value
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 16BIT */
end_comment
begin_comment
comment|/* This does the right thing based on the bit_depth field of the  * png_struct, interpreting values as 8-bit or 16-bit.  While the result  * is nominally a 16-bit value if bit depth is 8 then the result is  * 8-bit (as are the arguments.)  */
end_comment
begin_function
name|png_uint_16
comment|/* PRIVATE */
DECL|function|png_gamma_correct
name|png_gamma_correct
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|8
condition|)
return|return
name|png_gamma_8bit_correct
argument_list|(
name|value
argument_list|,
name|gamma_val
argument_list|)
return|;
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
else|else
return|return
name|png_gamma_16bit_correct
argument_list|(
name|value
argument_list|,
name|gamma_val
argument_list|)
return|;
else|#
directive|else
comment|/* should not reach this */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* 16BIT */
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
end_ifdef
begin_comment
comment|/* Internal function to build a single 16-bit table - the table consists of  * 'num' 256 entry subtables, where 'num' is determined by 'shift' - the amount  * to shift the input values right (or 16-number_of_signifiant_bits).  *  * The caller is responsible for ensuring that the table gets cleaned up on  * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument  * should be somewhere that will be cleaned.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_16bit_table
name|png_build_16bit_table
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_16pp
modifier|*
name|ptable
parameter_list|,
name|PNG_CONST
name|unsigned
name|int
name|shift
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
comment|/* Various values derived from 'shift': */
name|PNG_CONST
name|unsigned
name|int
name|num
init|=
literal|1U
operator|<<
operator|(
literal|8U
operator|-
name|shift
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
comment|/* CSE the division and work round wacky GCC warnings (see the comments     * in png_gamma_8bit_correct for where these come from.)     */
name|PNG_CONST
name|double
name|fmax
init|=
literal|1.
operator|/
operator|(
operator|(
operator|(
name|png_int_32
operator|)
literal|1
operator|<<
operator|(
literal|16U
operator|-
name|shift
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
endif|#
directive|endif
name|PNG_CONST
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
operator|(
literal|16U
operator|-
name|shift
operator|)
operator|)
operator|-
literal|1U
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max_by_2
init|=
literal|1U
operator|<<
operator|(
literal|15U
operator|-
name|shift
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|png_uint_16pp
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_uint_16pp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|num
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16p
argument_list|)
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16p
name|sub_table
init|=
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
argument_list|)
decl_stmt|;
comment|/* The 'threshold' test is repeated here because it can arise for one of        * the 16-bit tables even if the others don't hit it.        */
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|gamma_val
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The old code would overflow at the end and this would cause the           * 'pow' function to return a result>1, resulting in an           * arithmetic error.  This code follows the spec exactly; ig is           * the recovered input sample, it always has 8-16 bits.           *           * We want input * 65535/max, rounded, the arithmetic fits in 32           * bits (unsigned) so long as max<= 32767.           */
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|png_uint_32
name|ig
init|=
operator|(
name|j
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|+
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
comment|/* Inline the 'max' scaling operation: */
comment|/* See png_gamma_8bit_correct for why the cast to (int) is                 * required here.                 */
name|double
name|d
init|=
name|floor
argument_list|(
literal|65535.
operator|*
name|pow
argument_list|(
name|ig
operator|*
name|fmax
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|d
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
name|ig
operator|=
operator|(
name|ig
operator|*
literal|65535U
operator|+
name|max_by_2
operator|)
operator|/
name|max
expr_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
name|png_gamma_16bit_correct
argument_list|(
name|ig
argument_list|,
name|gamma_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* We must still build a table, but do it the fast way. */
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|png_uint_32
name|ig
init|=
operator|(
name|j
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
name|ig
operator|=
operator|(
name|ig
operator|*
literal|65535U
operator|+
name|max_by_2
operator|)
operator|/
name|max
expr_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|ig
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* NOTE: this function expects the *inverse* of the overall gamma transformation  * required.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_16to8_table
name|png_build_16to8_table
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_16pp
modifier|*
name|ptable
parameter_list|,
name|PNG_CONST
name|unsigned
name|int
name|shift
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
name|PNG_CONST
name|unsigned
name|int
name|num
init|=
literal|1U
operator|<<
operator|(
literal|8U
operator|-
name|shift
operator|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
operator|(
literal|16U
operator|-
name|shift
operator|)
operator|)
operator|-
literal|1U
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|png_uint_32
name|last
decl_stmt|;
name|png_uint_16pp
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_uint_16pp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|num
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16p
argument_list|)
operator|)
argument_list|)
decl_stmt|;
comment|/* 'num' is the number of tables and also the number of low bits of low     * bits of the input 16-bit value used to select a table.  Each table is     * itself indexed by the high 8 bits of the value.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_uint_16
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 'gamma_val' is set to the reciprocal of the value calculated above, so     * pow(out,g) is an *input* value.  'last' is the last input value set.     *     * In the loop 'i' is used to find output values.  Since the output is     * 8-bit there are only 256 possible values.  The tables are set up to     * select the closest possible output value for each input by finding     * the input value at the boundary between each pair of output values     * and filling the table up to that boundary with the lower output     * value.     *     * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit     * values the code below uses a 16-bit value in i; the values start at     * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last     * entries are filled with 255).  Start i at 128 and fill all 'last'     * table entries<= 'max'     */
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|255
condition|;
operator|++
name|i
control|)
comment|/* 8-bit output value */
block|{
comment|/* Find the corresponding maximum input value */
name|png_uint_16
name|out
init|=
call|(
name|png_uint_16
call|)
argument_list|(
name|i
operator|*
literal|257U
argument_list|)
decl_stmt|;
comment|/* 16-bit output value */
comment|/* Find the boundary value in 16 bits: */
name|png_uint_32
name|bound
init|=
name|png_gamma_16bit_correct
argument_list|(
name|out
operator|+
literal|128U
argument_list|,
name|gamma_val
argument_list|)
decl_stmt|;
comment|/* Adjust (round) to (16-shift) bits: */
name|bound
operator|=
operator|(
name|bound
operator|*
name|max
operator|+
literal|32768U
operator|)
operator|/
literal|65535U
operator|+
literal|1U
expr_stmt|;
while|while
condition|(
name|last
operator|<
name|bound
condition|)
block|{
name|table
index|[
name|last
operator|&
operator|(
literal|0xffU
operator|>>
name|shift
operator|)
index|]
index|[
name|last
operator|>>
operator|(
literal|8U
operator|-
name|shift
operator|)
index|]
operator|=
name|out
expr_stmt|;
name|last
operator|++
expr_stmt|;
block|}
block|}
comment|/* And fill in the final entries. */
while|while
condition|(
name|last
operator|<
operator|(
name|num
operator|<<
literal|8
operator|)
condition|)
block|{
name|table
index|[
name|last
operator|&
operator|(
literal|0xff
operator|>>
name|shift
operator|)
index|]
index|[
name|last
operator|>>
operator|(
literal|8U
operator|-
name|shift
operator|)
index|]
operator|=
literal|65535U
expr_stmt|;
name|last
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 16BIT */
end_comment
begin_comment
comment|/* Build a single 8-bit table: same as the 16-bit case but much simpler (and  * typically much faster).  Note that libpng currently does no sBIT processing  * (apparently contrary to the spec) so a 256-entry table is always generated.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_8bit_table
name|png_build_8bit_table
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytepp
name|ptable
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|png_bytep
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
argument_list|)
decl_stmt|;
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|gamma_val
argument_list|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|i
argument_list|,
name|gamma_val
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|table
index|[
name|i
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Used from png_read_destroy and below to release the memory used by the gamma  * tables.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_destroy_gamma_table
name|png_destroy_gamma_table
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_table
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_table
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_table
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|png_ptr
operator|->
name|gamma_shift
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_table
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_16_table
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 16BIT */
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_from_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_from_1
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_to_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_to_1
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_from_1
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|png_ptr
operator|->
name|gamma_shift
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_from_1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_from_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_16_from_1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_to_1
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|png_ptr
operator|->
name|gamma_shift
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_to_1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_to_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_16_to_1
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 16BIT */
endif|#
directive|endif
comment|/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
block|}
end_function
begin_comment
comment|/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit  * tables, we don't make a full table if we are reducing to 8-bit in  * the future.  Note also how the gamma_16 tables are segmented so that  * we don't need to allocate> 64K chunks for a full 16-bit table.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_build_gamma_table
name|png_build_gamma_table
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|bit_depth
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_build_gamma_table"
argument_list|)
expr_stmt|;
comment|/* Remove any existing table; this copes with multiple calls to    * png_read_update_info.  The warning is because building the gamma tables    * multiple times is a performance hit - it's harmless but the ability to call    * png_read_update_info() multiple times is new in 1.5.6 so it seems sensible    * to warn if the app introduces such a hit.    */
if|if
condition|(
name|png_ptr
operator|->
name|gamma_table
operator|!=
name|NULL
operator|||
name|png_ptr
operator|->
name|gamma_16_table
operator|!=
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"gamma table being rebuilt"
argument_list|)
expr_stmt|;
name|png_destroy_gamma_table
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bit_depth
operator|<=
literal|8
condition|)
block|{
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_table
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_COMPOSE
operator||
name|PNG_RGB_TO_GRAY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_to_1
argument_list|,
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_from_1
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
comment|/* Probably doing rgb_to_gray */
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
block|}
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
else|else
block|{
name|png_byte
name|shift
decl_stmt|,
name|sig_bit
decl_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
operator|>
name|sig_bit
condition|)
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
operator|>
name|sig_bit
condition|)
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
expr_stmt|;
block|}
else|else
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|gray
expr_stmt|;
comment|/* 16-bit gamma code uses this equation:       *       *   ov = table[(iv& 0xff)>> gamma_shift][iv>> 8]       *       * Where 'iv' is the input color value and 'ov' is the output value -       * pow(iv, gamma).       *       * Thus the gamma table consists of up to 256 256-entry tables.  The table       * is selected by the (8-gamma_shift) most significant of the low 8 bits of       * the color value then indexed by the upper 8 bits:       *       *   table[low bits][high 8 bits]       *       * So the table 'n' corresponds to all those 'iv' of:       *       *<all high 8-bit values><n<< gamma_shift>..<(n+1<< gamma_shift)-1>       *       */
if|if
condition|(
name|sig_bit
operator|>
literal|0
operator|&&
name|sig_bit
operator|<
literal|16U
condition|)
comment|/* shift == insignificant bits */
name|shift
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
literal|16U
operator|-
name|sig_bit
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|shift
operator|=
literal|0
expr_stmt|;
comment|/* keep all 16 bits */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_16_TO_8
operator||
name|PNG_SCALE_16_TO_8
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively          * the significant bits in the *input* when the output will          * eventually be 8 bits.  By default it is 11.          */
if|if
condition|(
name|shift
operator|<
operator|(
literal|16U
operator|-
name|PNG_MAX_GAMMA_8
operator|)
condition|)
name|shift
operator|=
operator|(
literal|16U
operator|-
name|PNG_MAX_GAMMA_8
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|>
literal|8U
condition|)
name|shift
operator|=
literal|8U
expr_stmt|;
comment|/* Guarantees at least one table! */
name|png_ptr
operator|->
name|gamma_shift
operator|=
name|shift
expr_stmt|;
comment|/* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now       * PNG_COMPOSE).  This effectively smashed the background calculation for       * 16-bit output because the 8-bit table assumes the result will be reduced       * to 8 bits.       */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_16_TO_8
operator||
name|PNG_SCALE_16_TO_8
operator|)
operator|)
operator|!=
literal|0
condition|)
name|png_build_16to8_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_table
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_product2
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
else|else
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_table
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_COMPOSE
operator||
name|PNG_RGB_TO_GRAY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_to_1
argument_list|,
name|shift
argument_list|,
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notice that the '16 from 1' table should be full precision, however          * the lookup on this table still uses gamma_shift, so it can't be.          * TODO: fix this.          */
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_from_1
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|png_ptr
operator|->
name|colorspace
operator|.
name|gamma
comment|/* Probably doing rgb_to_gray */
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
block|}
endif|#
directive|endif
comment|/* 16BIT */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA */
end_comment
begin_comment
comment|/* HARDWARE OR SOFTWARE OPTION SUPPORT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SET_OPTION_SUPPORTED
end_ifdef
begin_function
name|int
name|PNGAPI
DECL|function|png_set_option
name|png_set_option
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|option
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|!=
name|NULL
operator|&&
name|option
operator|>=
literal|0
operator|&&
name|option
operator|<
name|PNG_OPTION_NEXT
operator|&&
operator|(
name|option
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|mask
init|=
literal|3
operator|<<
name|option
decl_stmt|;
name|int
name|setting
init|=
operator|(
literal|2
operator|+
operator|(
name|onoff
operator|!=
literal|0
operator|)
operator|)
operator|<<
name|option
decl_stmt|;
name|int
name|current
init|=
name|png_ptr
operator|->
name|options
decl_stmt|;
name|png_ptr
operator|->
name|options
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|current
operator|&
operator|~
name|mask
operator|)
operator||
name|setting
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
name|current
operator|&
name|mask
operator|)
operator|>>
name|option
return|;
block|}
return|return
name|PNG_OPTION_INVALID
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* sRGB support */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_READ_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* sRGB conversion tables; these are machine generated with the code in  * contrib/tools/makesRGB.c.  The actual sRGB transfer curve defined in the  * specification (see the article at http://en.wikipedia.org/wiki/SRGB)  * is used, not the gamma=1/2.2 approximation use elsewhere in libpng.  * The sRGB to linear table is exact (to the nearest 16-bit linear fraction).  * The inverse (linear to sRGB) table has accuracies as follows:  *  * For all possible (255*65535+1) input values:  *  *    error: -0.515566 - 0.625971, 79441 (0.475369%) of readings inexact  *  * For the input values corresponding to the 65536 16-bit values:  *  *    error: -0.513727 - 0.607759, 308 (0.469978%) of readings inexact  *  * In all cases the inexact readings are only off by one.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* The convert-to-sRGB table is only currently required for read. */
end_comment
begin_decl_stmt
DECL|variable|png_sRGB_table
specifier|const
name|png_uint_16
name|png_sRGB_table
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|20
block|,
literal|40
block|,
literal|60
block|,
literal|80
block|,
literal|99
block|,
literal|119
block|,
literal|139
block|,
literal|159
block|,
literal|179
block|,
literal|199
block|,
literal|219
block|,
literal|241
block|,
literal|264
block|,
literal|288
block|,
literal|313
block|,
literal|340
block|,
literal|367
block|,
literal|396
block|,
literal|427
block|,
literal|458
block|,
literal|491
block|,
literal|526
block|,
literal|562
block|,
literal|599
block|,
literal|637
block|,
literal|677
block|,
literal|718
block|,
literal|761
block|,
literal|805
block|,
literal|851
block|,
literal|898
block|,
literal|947
block|,
literal|997
block|,
literal|1048
block|,
literal|1101
block|,
literal|1156
block|,
literal|1212
block|,
literal|1270
block|,
literal|1330
block|,
literal|1391
block|,
literal|1453
block|,
literal|1517
block|,
literal|1583
block|,
literal|1651
block|,
literal|1720
block|,
literal|1790
block|,
literal|1863
block|,
literal|1937
block|,
literal|2013
block|,
literal|2090
block|,
literal|2170
block|,
literal|2250
block|,
literal|2333
block|,
literal|2418
block|,
literal|2504
block|,
literal|2592
block|,
literal|2681
block|,
literal|2773
block|,
literal|2866
block|,
literal|2961
block|,
literal|3058
block|,
literal|3157
block|,
literal|3258
block|,
literal|3360
block|,
literal|3464
block|,
literal|3570
block|,
literal|3678
block|,
literal|3788
block|,
literal|3900
block|,
literal|4014
block|,
literal|4129
block|,
literal|4247
block|,
literal|4366
block|,
literal|4488
block|,
literal|4611
block|,
literal|4736
block|,
literal|4864
block|,
literal|4993
block|,
literal|5124
block|,
literal|5257
block|,
literal|5392
block|,
literal|5530
block|,
literal|5669
block|,
literal|5810
block|,
literal|5953
block|,
literal|6099
block|,
literal|6246
block|,
literal|6395
block|,
literal|6547
block|,
literal|6700
block|,
literal|6856
block|,
literal|7014
block|,
literal|7174
block|,
literal|7335
block|,
literal|7500
block|,
literal|7666
block|,
literal|7834
block|,
literal|8004
block|,
literal|8177
block|,
literal|8352
block|,
literal|8528
block|,
literal|8708
block|,
literal|8889
block|,
literal|9072
block|,
literal|9258
block|,
literal|9445
block|,
literal|9635
block|,
literal|9828
block|,
literal|10022
block|,
literal|10219
block|,
literal|10417
block|,
literal|10619
block|,
literal|10822
block|,
literal|11028
block|,
literal|11235
block|,
literal|11446
block|,
literal|11658
block|,
literal|11873
block|,
literal|12090
block|,
literal|12309
block|,
literal|12530
block|,
literal|12754
block|,
literal|12980
block|,
literal|13209
block|,
literal|13440
block|,
literal|13673
block|,
literal|13909
block|,
literal|14146
block|,
literal|14387
block|,
literal|14629
block|,
literal|14874
block|,
literal|15122
block|,
literal|15371
block|,
literal|15623
block|,
literal|15878
block|,
literal|16135
block|,
literal|16394
block|,
literal|16656
block|,
literal|16920
block|,
literal|17187
block|,
literal|17456
block|,
literal|17727
block|,
literal|18001
block|,
literal|18277
block|,
literal|18556
block|,
literal|18837
block|,
literal|19121
block|,
literal|19407
block|,
literal|19696
block|,
literal|19987
block|,
literal|20281
block|,
literal|20577
block|,
literal|20876
block|,
literal|21177
block|,
literal|21481
block|,
literal|21787
block|,
literal|22096
block|,
literal|22407
block|,
literal|22721
block|,
literal|23038
block|,
literal|23357
block|,
literal|23678
block|,
literal|24002
block|,
literal|24329
block|,
literal|24658
block|,
literal|24990
block|,
literal|25325
block|,
literal|25662
block|,
literal|26001
block|,
literal|26344
block|,
literal|26688
block|,
literal|27036
block|,
literal|27386
block|,
literal|27739
block|,
literal|28094
block|,
literal|28452
block|,
literal|28813
block|,
literal|29176
block|,
literal|29542
block|,
literal|29911
block|,
literal|30282
block|,
literal|30656
block|,
literal|31033
block|,
literal|31412
block|,
literal|31794
block|,
literal|32179
block|,
literal|32567
block|,
literal|32957
block|,
literal|33350
block|,
literal|33745
block|,
literal|34143
block|,
literal|34544
block|,
literal|34948
block|,
literal|35355
block|,
literal|35764
block|,
literal|36176
block|,
literal|36591
block|,
literal|37008
block|,
literal|37429
block|,
literal|37852
block|,
literal|38278
block|,
literal|38706
block|,
literal|39138
block|,
literal|39572
block|,
literal|40009
block|,
literal|40449
block|,
literal|40891
block|,
literal|41337
block|,
literal|41785
block|,
literal|42236
block|,
literal|42690
block|,
literal|43147
block|,
literal|43606
block|,
literal|44069
block|,
literal|44534
block|,
literal|45002
block|,
literal|45473
block|,
literal|45947
block|,
literal|46423
block|,
literal|46903
block|,
literal|47385
block|,
literal|47871
block|,
literal|48359
block|,
literal|48850
block|,
literal|49344
block|,
literal|49841
block|,
literal|50341
block|,
literal|50844
block|,
literal|51349
block|,
literal|51858
block|,
literal|52369
block|,
literal|52884
block|,
literal|53401
block|,
literal|53921
block|,
literal|54445
block|,
literal|54971
block|,
literal|55500
block|,
literal|56032
block|,
literal|56567
block|,
literal|57105
block|,
literal|57646
block|,
literal|58190
block|,
literal|58737
block|,
literal|59287
block|,
literal|59840
block|,
literal|60396
block|,
literal|60955
block|,
literal|61517
block|,
literal|62082
block|,
literal|62650
block|,
literal|63221
block|,
literal|63795
block|,
literal|64372
block|,
literal|64952
block|,
literal|65535
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SIMPLIFIED_READ */
end_comment
begin_comment
comment|/* The base/delta tables are required for both read and write (but currently  * only the simplified versions.)  */
end_comment
begin_decl_stmt
DECL|variable|png_sRGB_base
specifier|const
name|png_uint_16
name|png_sRGB_base
index|[
literal|512
index|]
init|=
block|{
literal|128
block|,
literal|1782
block|,
literal|3383
block|,
literal|4644
block|,
literal|5675
block|,
literal|6564
block|,
literal|7357
block|,
literal|8074
block|,
literal|8732
block|,
literal|9346
block|,
literal|9921
block|,
literal|10463
block|,
literal|10977
block|,
literal|11466
block|,
literal|11935
block|,
literal|12384
block|,
literal|12816
block|,
literal|13233
block|,
literal|13634
block|,
literal|14024
block|,
literal|14402
block|,
literal|14769
block|,
literal|15125
block|,
literal|15473
block|,
literal|15812
block|,
literal|16142
block|,
literal|16466
block|,
literal|16781
block|,
literal|17090
block|,
literal|17393
block|,
literal|17690
block|,
literal|17981
block|,
literal|18266
block|,
literal|18546
block|,
literal|18822
block|,
literal|19093
block|,
literal|19359
block|,
literal|19621
block|,
literal|19879
block|,
literal|20133
block|,
literal|20383
block|,
literal|20630
block|,
literal|20873
block|,
literal|21113
block|,
literal|21349
block|,
literal|21583
block|,
literal|21813
block|,
literal|22041
block|,
literal|22265
block|,
literal|22487
block|,
literal|22707
block|,
literal|22923
block|,
literal|23138
block|,
literal|23350
block|,
literal|23559
block|,
literal|23767
block|,
literal|23972
block|,
literal|24175
block|,
literal|24376
block|,
literal|24575
block|,
literal|24772
block|,
literal|24967
block|,
literal|25160
block|,
literal|25352
block|,
literal|25542
block|,
literal|25730
block|,
literal|25916
block|,
literal|26101
block|,
literal|26284
block|,
literal|26465
block|,
literal|26645
block|,
literal|26823
block|,
literal|27000
block|,
literal|27176
block|,
literal|27350
block|,
literal|27523
block|,
literal|27695
block|,
literal|27865
block|,
literal|28034
block|,
literal|28201
block|,
literal|28368
block|,
literal|28533
block|,
literal|28697
block|,
literal|28860
block|,
literal|29021
block|,
literal|29182
block|,
literal|29341
block|,
literal|29500
block|,
literal|29657
block|,
literal|29813
block|,
literal|29969
block|,
literal|30123
block|,
literal|30276
block|,
literal|30429
block|,
literal|30580
block|,
literal|30730
block|,
literal|30880
block|,
literal|31028
block|,
literal|31176
block|,
literal|31323
block|,
literal|31469
block|,
literal|31614
block|,
literal|31758
block|,
literal|31902
block|,
literal|32045
block|,
literal|32186
block|,
literal|32327
block|,
literal|32468
block|,
literal|32607
block|,
literal|32746
block|,
literal|32884
block|,
literal|33021
block|,
literal|33158
block|,
literal|33294
block|,
literal|33429
block|,
literal|33564
block|,
literal|33697
block|,
literal|33831
block|,
literal|33963
block|,
literal|34095
block|,
literal|34226
block|,
literal|34357
block|,
literal|34486
block|,
literal|34616
block|,
literal|34744
block|,
literal|34873
block|,
literal|35000
block|,
literal|35127
block|,
literal|35253
block|,
literal|35379
block|,
literal|35504
block|,
literal|35629
block|,
literal|35753
block|,
literal|35876
block|,
literal|35999
block|,
literal|36122
block|,
literal|36244
block|,
literal|36365
block|,
literal|36486
block|,
literal|36606
block|,
literal|36726
block|,
literal|36845
block|,
literal|36964
block|,
literal|37083
block|,
literal|37201
block|,
literal|37318
block|,
literal|37435
block|,
literal|37551
block|,
literal|37668
block|,
literal|37783
block|,
literal|37898
block|,
literal|38013
block|,
literal|38127
block|,
literal|38241
block|,
literal|38354
block|,
literal|38467
block|,
literal|38580
block|,
literal|38692
block|,
literal|38803
block|,
literal|38915
block|,
literal|39026
block|,
literal|39136
block|,
literal|39246
block|,
literal|39356
block|,
literal|39465
block|,
literal|39574
block|,
literal|39682
block|,
literal|39790
block|,
literal|39898
block|,
literal|40005
block|,
literal|40112
block|,
literal|40219
block|,
literal|40325
block|,
literal|40431
block|,
literal|40537
block|,
literal|40642
block|,
literal|40747
block|,
literal|40851
block|,
literal|40955
block|,
literal|41059
block|,
literal|41163
block|,
literal|41266
block|,
literal|41369
block|,
literal|41471
block|,
literal|41573
block|,
literal|41675
block|,
literal|41777
block|,
literal|41878
block|,
literal|41979
block|,
literal|42079
block|,
literal|42179
block|,
literal|42279
block|,
literal|42379
block|,
literal|42478
block|,
literal|42577
block|,
literal|42676
block|,
literal|42775
block|,
literal|42873
block|,
literal|42971
block|,
literal|43068
block|,
literal|43165
block|,
literal|43262
block|,
literal|43359
block|,
literal|43456
block|,
literal|43552
block|,
literal|43648
block|,
literal|43743
block|,
literal|43839
block|,
literal|43934
block|,
literal|44028
block|,
literal|44123
block|,
literal|44217
block|,
literal|44311
block|,
literal|44405
block|,
literal|44499
block|,
literal|44592
block|,
literal|44685
block|,
literal|44778
block|,
literal|44870
block|,
literal|44962
block|,
literal|45054
block|,
literal|45146
block|,
literal|45238
block|,
literal|45329
block|,
literal|45420
block|,
literal|45511
block|,
literal|45601
block|,
literal|45692
block|,
literal|45782
block|,
literal|45872
block|,
literal|45961
block|,
literal|46051
block|,
literal|46140
block|,
literal|46229
block|,
literal|46318
block|,
literal|46406
block|,
literal|46494
block|,
literal|46583
block|,
literal|46670
block|,
literal|46758
block|,
literal|46846
block|,
literal|46933
block|,
literal|47020
block|,
literal|47107
block|,
literal|47193
block|,
literal|47280
block|,
literal|47366
block|,
literal|47452
block|,
literal|47538
block|,
literal|47623
block|,
literal|47709
block|,
literal|47794
block|,
literal|47879
block|,
literal|47964
block|,
literal|48048
block|,
literal|48133
block|,
literal|48217
block|,
literal|48301
block|,
literal|48385
block|,
literal|48468
block|,
literal|48552
block|,
literal|48635
block|,
literal|48718
block|,
literal|48801
block|,
literal|48884
block|,
literal|48966
block|,
literal|49048
block|,
literal|49131
block|,
literal|49213
block|,
literal|49294
block|,
literal|49376
block|,
literal|49458
block|,
literal|49539
block|,
literal|49620
block|,
literal|49701
block|,
literal|49782
block|,
literal|49862
block|,
literal|49943
block|,
literal|50023
block|,
literal|50103
block|,
literal|50183
block|,
literal|50263
block|,
literal|50342
block|,
literal|50422
block|,
literal|50501
block|,
literal|50580
block|,
literal|50659
block|,
literal|50738
block|,
literal|50816
block|,
literal|50895
block|,
literal|50973
block|,
literal|51051
block|,
literal|51129
block|,
literal|51207
block|,
literal|51285
block|,
literal|51362
block|,
literal|51439
block|,
literal|51517
block|,
literal|51594
block|,
literal|51671
block|,
literal|51747
block|,
literal|51824
block|,
literal|51900
block|,
literal|51977
block|,
literal|52053
block|,
literal|52129
block|,
literal|52205
block|,
literal|52280
block|,
literal|52356
block|,
literal|52432
block|,
literal|52507
block|,
literal|52582
block|,
literal|52657
block|,
literal|52732
block|,
literal|52807
block|,
literal|52881
block|,
literal|52956
block|,
literal|53030
block|,
literal|53104
block|,
literal|53178
block|,
literal|53252
block|,
literal|53326
block|,
literal|53400
block|,
literal|53473
block|,
literal|53546
block|,
literal|53620
block|,
literal|53693
block|,
literal|53766
block|,
literal|53839
block|,
literal|53911
block|,
literal|53984
block|,
literal|54056
block|,
literal|54129
block|,
literal|54201
block|,
literal|54273
block|,
literal|54345
block|,
literal|54417
block|,
literal|54489
block|,
literal|54560
block|,
literal|54632
block|,
literal|54703
block|,
literal|54774
block|,
literal|54845
block|,
literal|54916
block|,
literal|54987
block|,
literal|55058
block|,
literal|55129
block|,
literal|55199
block|,
literal|55269
block|,
literal|55340
block|,
literal|55410
block|,
literal|55480
block|,
literal|55550
block|,
literal|55620
block|,
literal|55689
block|,
literal|55759
block|,
literal|55828
block|,
literal|55898
block|,
literal|55967
block|,
literal|56036
block|,
literal|56105
block|,
literal|56174
block|,
literal|56243
block|,
literal|56311
block|,
literal|56380
block|,
literal|56448
block|,
literal|56517
block|,
literal|56585
block|,
literal|56653
block|,
literal|56721
block|,
literal|56789
block|,
literal|56857
block|,
literal|56924
block|,
literal|56992
block|,
literal|57059
block|,
literal|57127
block|,
literal|57194
block|,
literal|57261
block|,
literal|57328
block|,
literal|57395
block|,
literal|57462
block|,
literal|57529
block|,
literal|57595
block|,
literal|57662
block|,
literal|57728
block|,
literal|57795
block|,
literal|57861
block|,
literal|57927
block|,
literal|57993
block|,
literal|58059
block|,
literal|58125
block|,
literal|58191
block|,
literal|58256
block|,
literal|58322
block|,
literal|58387
block|,
literal|58453
block|,
literal|58518
block|,
literal|58583
block|,
literal|58648
block|,
literal|58713
block|,
literal|58778
block|,
literal|58843
block|,
literal|58908
block|,
literal|58972
block|,
literal|59037
block|,
literal|59101
block|,
literal|59165
block|,
literal|59230
block|,
literal|59294
block|,
literal|59358
block|,
literal|59422
block|,
literal|59486
block|,
literal|59549
block|,
literal|59613
block|,
literal|59677
block|,
literal|59740
block|,
literal|59804
block|,
literal|59867
block|,
literal|59930
block|,
literal|59993
block|,
literal|60056
block|,
literal|60119
block|,
literal|60182
block|,
literal|60245
block|,
literal|60308
block|,
literal|60370
block|,
literal|60433
block|,
literal|60495
block|,
literal|60558
block|,
literal|60620
block|,
literal|60682
block|,
literal|60744
block|,
literal|60806
block|,
literal|60868
block|,
literal|60930
block|,
literal|60992
block|,
literal|61054
block|,
literal|61115
block|,
literal|61177
block|,
literal|61238
block|,
literal|61300
block|,
literal|61361
block|,
literal|61422
block|,
literal|61483
block|,
literal|61544
block|,
literal|61605
block|,
literal|61666
block|,
literal|61727
block|,
literal|61788
block|,
literal|61848
block|,
literal|61909
block|,
literal|61969
block|,
literal|62030
block|,
literal|62090
block|,
literal|62150
block|,
literal|62211
block|,
literal|62271
block|,
literal|62331
block|,
literal|62391
block|,
literal|62450
block|,
literal|62510
block|,
literal|62570
block|,
literal|62630
block|,
literal|62689
block|,
literal|62749
block|,
literal|62808
block|,
literal|62867
block|,
literal|62927
block|,
literal|62986
block|,
literal|63045
block|,
literal|63104
block|,
literal|63163
block|,
literal|63222
block|,
literal|63281
block|,
literal|63340
block|,
literal|63398
block|,
literal|63457
block|,
literal|63515
block|,
literal|63574
block|,
literal|63632
block|,
literal|63691
block|,
literal|63749
block|,
literal|63807
block|,
literal|63865
block|,
literal|63923
block|,
literal|63981
block|,
literal|64039
block|,
literal|64097
block|,
literal|64155
block|,
literal|64212
block|,
literal|64270
block|,
literal|64328
block|,
literal|64385
block|,
literal|64443
block|,
literal|64500
block|,
literal|64557
block|,
literal|64614
block|,
literal|64672
block|,
literal|64729
block|,
literal|64786
block|,
literal|64843
block|,
literal|64900
block|,
literal|64956
block|,
literal|65013
block|,
literal|65070
block|,
literal|65126
block|,
literal|65183
block|,
literal|65239
block|,
literal|65296
block|,
literal|65352
block|,
literal|65409
block|,
literal|65465
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|png_sRGB_delta
specifier|const
name|png_byte
name|png_sRGB_delta
index|[
literal|512
index|]
init|=
block|{
literal|207
block|,
literal|201
block|,
literal|158
block|,
literal|129
block|,
literal|113
block|,
literal|100
block|,
literal|90
block|,
literal|82
block|,
literal|77
block|,
literal|72
block|,
literal|68
block|,
literal|64
block|,
literal|61
block|,
literal|59
block|,
literal|56
block|,
literal|54
block|,
literal|52
block|,
literal|50
block|,
literal|49
block|,
literal|47
block|,
literal|46
block|,
literal|45
block|,
literal|43
block|,
literal|42
block|,
literal|41
block|,
literal|40
block|,
literal|39
block|,
literal|39
block|,
literal|38
block|,
literal|37
block|,
literal|36
block|,
literal|36
block|,
literal|35
block|,
literal|34
block|,
literal|34
block|,
literal|33
block|,
literal|33
block|,
literal|32
block|,
literal|32
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|29
block|,
literal|29
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|26
block|,
literal|26
block|,
literal|26
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SIMPLIFIED READ/WRITE sRGB support */
end_comment
begin_comment
comment|/* SIMPLIFIED READ/WRITE SUPPORT */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_SIMPLIFIED_READ_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
argument_list|)
end_if
begin_function
specifier|static
name|int
DECL|function|png_image_free_function
name|png_image_free_function
parameter_list|(
name|png_voidp
name|argument
parameter_list|)
block|{
name|png_imagep
name|image
init|=
name|png_voidcast
argument_list|(
name|png_imagep
argument_list|,
name|argument
argument_list|)
decl_stmt|;
name|png_controlp
name|cp
init|=
name|image
operator|->
name|opaque
decl_stmt|;
name|png_control
name|c
decl_stmt|;
comment|/* Double check that we have a png_ptr - it should be impossible to get here     * without one.     */
if|if
condition|(
name|cp
operator|->
name|png_ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* First free any data held in the control structure. */
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
if|if
condition|(
name|cp
operator|->
name|owned_file
operator|!=
literal|0
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|png_voidcast
argument_list|(
name|FILE
operator|*
argument_list|,
name|cp
operator|->
name|png_ptr
operator|->
name|io_ptr
argument_list|)
decl_stmt|;
name|cp
operator|->
name|owned_file
operator|=
literal|0
expr_stmt|;
comment|/* Ignore errors here. */
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|->
name|png_ptr
operator|->
name|io_ptr
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Copy the control structure so that the original, allocated, version can be     * safely freed.  Notice that a png_error here stops the remainder of the     * cleanup, but this is probably fine because that would indicate bad memory     * problems anyway.     */
name|c
operator|=
operator|*
name|cp
expr_stmt|;
name|image
operator|->
name|opaque
operator|=
operator|&
name|c
expr_stmt|;
name|png_free
argument_list|(
name|c
operator|.
name|png_ptr
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Then the structures, calling the correct API. */
if|if
condition|(
name|c
operator|.
name|for_write
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_WRITE_SUPPORTED
name|png_destroy_write_struct
argument_list|(
operator|&
name|c
operator|.
name|png_ptr
argument_list|,
operator|&
name|c
operator|.
name|info_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_error
argument_list|(
name|c
operator|.
name|png_ptr
argument_list|,
literal|"simplified write not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_SIMPLIFIED_READ_SUPPORTED
name|png_destroy_read_struct
argument_list|(
operator|&
name|c
operator|.
name|png_ptr
argument_list|,
operator|&
name|c
operator|.
name|info_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_error
argument_list|(
name|c
operator|.
name|png_ptr
argument_list|,
literal|"simplified read not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Success. */
return|return
literal|1
return|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_image_free
name|png_image_free
parameter_list|(
name|png_imagep
name|image
parameter_list|)
block|{
comment|/* Safely call the real function, but only if doing so is safe at this point     * (if not inside an error handling context).  Otherwise assume     * png_safe_execute will call this API after the return.     */
if|if
condition|(
name|image
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|opaque
operator|!=
name|NULL
operator|&&
name|image
operator|->
name|opaque
operator|->
name|error_buf
operator|==
name|NULL
condition|)
block|{
comment|/* Ignore errors here: */
operator|(
name|void
operator|)
name|png_safe_execute
argument_list|(
name|image
argument_list|,
name|png_image_free_function
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_image_error
name|png_image_error
parameter_list|(
name|png_imagep
name|image
parameter_list|,
name|png_const_charp
name|error_message
parameter_list|)
block|{
comment|/* Utility to log an error. */
name|png_safecat
argument_list|(
name|image
operator|->
name|message
argument_list|,
operator|(
sizeof|sizeof
name|image
operator|->
name|message
operator|)
argument_list|,
literal|0
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
name|image
operator|->
name|warning_or_error
operator||=
name|PNG_IMAGE_ERROR
expr_stmt|;
name|png_image_free
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SIMPLIFIED READ/WRITE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ || WRITE */
end_comment
end_unit
