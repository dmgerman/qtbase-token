begin_unit
begin_comment
comment|/* png.c - location for general purpose libpng functions  *  * Last changed in libpng 1.5.10 [March 8, 2012]  * Copyright (c) 1998-2012 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_comment
comment|/* Generate a compiler error if there is an old png.h in the search path. */
end_comment
begin_typedef
DECL|typedef|Your_png_h_is_not_version_1_5_10
typedef|typedef
name|png_libpng_version_1_5_10
name|Your_png_h_is_not_version_1_5_10
typedef|;
end_typedef
begin_comment
comment|/* Tells libpng that we have already handled the first "num_bytes" bytes  * of the PNG file signature.  If the PNG data is embedded into another  * stream we can set num_bytes = 8 so that libpng will not attempt to read  * or write any of the magic bytes before it starts on the IHDR.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sig_bytes
name|png_set_sig_bytes
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|num_bytes
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_sig_bytes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|num_bytes
operator|>
literal|8
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many bytes for PNG signature"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sig_bytes
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|num_bytes
operator|<
literal|0
condition|?
literal|0
else|:
name|num_bytes
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Checks whether the supplied bytes match the PNG signature.  We allow  * checking less than the full 8-byte signature so that those apps that  * already read the first few bytes of a file to determine the file type  * can simply check the remaining bytes for extra assurance.  Returns  * an integer less than, equal to, or greater than zero if sig is found,  * respectively, to be less than, to match, or be greater than the correct  * PNG signature (this is the same behavior as strcmp, memcmp, etc).  */
end_comment
begin_function
name|int
name|PNGAPI
DECL|function|png_sig_cmp
name|png_sig_cmp
parameter_list|(
name|png_const_bytep
name|sig
parameter_list|,
name|png_size_t
name|start
parameter_list|,
name|png_size_t
name|num_to_check
parameter_list|)
block|{
name|png_byte
name|png_signature
index|[
literal|8
index|]
init|=
block|{
literal|137
block|,
literal|80
block|,
literal|78
block|,
literal|71
block|,
literal|13
block|,
literal|10
block|,
literal|26
block|,
literal|10
block|}
decl_stmt|;
if|if
condition|(
name|num_to_check
operator|>
literal|8
condition|)
name|num_to_check
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|num_to_check
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|start
operator|>
literal|7
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|start
operator|+
name|num_to_check
operator|>
literal|8
condition|)
name|num_to_check
operator|=
literal|8
operator|-
name|start
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|png_memcmp
argument_list|(
operator|&
name|sig
index|[
name|start
index|]
argument_list|,
operator|&
name|png_signature
index|[
name|start
index|]
argument_list|,
name|num_to_check
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_SUPPORTED */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Function to allocate memory for zlib */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|voidpf
comment|/* PRIVATE */
argument_list|,
argument|png_zalloc
argument_list|,
argument|(voidpf png_ptr, uInt items, uInt size)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_voidp
name|ptr
decl_stmt|;
name|png_structp
name|p
init|=
operator|(
name|png_structp
operator|)
name|png_ptr
decl_stmt|;
name|png_uint_32
name|save_flags
init|=
name|p
operator|->
name|flags
decl_stmt|;
name|png_alloc_size_t
name|num_bytes
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|items
operator|>
name|PNG_UINT_32_MAX
operator|/
name|size
condition|)
block|{
name|png_warning
argument_list|(
name|p
argument_list|,
literal|"Potential overflow in png_zalloc()"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|num_bytes
operator|=
operator|(
name|png_alloc_size_t
operator|)
name|items
operator|*
name|size
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PNG_FLAG_MALLOC_NULL_MEM_OK
expr_stmt|;
name|ptr
operator|=
operator|(
name|png_voidp
operator|)
name|png_malloc
argument_list|(
operator|(
name|png_structp
operator|)
name|png_ptr
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|save_flags
expr_stmt|;
return|return
operator|(
operator|(
name|voidpf
operator|)
name|ptr
operator|)
return|;
block|}
end_block
begin_comment
comment|/* Function to free memory for zlib */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_zfree
name|png_zfree
parameter_list|(
name|voidpf
name|png_ptr
parameter_list|,
name|voidpf
name|ptr
parameter_list|)
block|{
name|png_free
argument_list|(
operator|(
name|png_structp
operator|)
name|png_ptr
argument_list|,
operator|(
name|png_voidp
operator|)
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Reset the CRC variable to 32 bits of 1's.  Care must be taken  * in case CRC is> 32 bits to leave the top bits 0.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_reset_crc
name|png_reset_crc
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
comment|/* The cast is safe because the crc is a 32 bit value. */
name|png_ptr
operator|->
name|crc
operator|=
operator|(
name|png_uint_32
operator|)
name|crc32
argument_list|(
literal|0
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Calculate the CRC over a section of data.  We can only pass as  * much data to this routine as the largest single buffer size.  We  * also check that this data will actually be used before going to the  * trouble of calculating it.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_calculate_crc
name|png_calculate_crc
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|ptr
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|int
name|need_crc
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|PNG_CHUNK_ANCILLIARY
argument_list|(
name|png_ptr
operator|->
name|chunk_name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_MASK
operator|)
operator|==
operator|(
name|PNG_FLAG_CRC_ANCILLARY_USE
operator||
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* critical */
block|{
if|if
condition|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_CRITICAL_IGNORE
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 'uLong' is defined as unsigned long, this means that on some systems it is     * a 64 bit value.  crc32, however, returns 32 bits so the following cast is     * safe.  'uInt' may be no more than 16 bits, so it is necessary to perform a     * loop here.     */
if|if
condition|(
name|need_crc
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
name|uLong
name|crc
init|=
name|png_ptr
operator|->
name|crc
decl_stmt|;
comment|/* Should never issue a warning */
do|do
block|{
name|uInt
name|safeLength
init|=
operator|(
name|uInt
operator|)
name|length
decl_stmt|;
if|if
condition|(
name|safeLength
operator|==
literal|0
condition|)
name|safeLength
operator|=
operator|(
name|uInt
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* evil, but safe */
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
name|ptr
argument_list|,
name|safeLength
argument_list|)
expr_stmt|;
comment|/* The following should never issue compiler warnings, if they do the           * target system has characteristics that will probably violate other           * assumptions within the libpng code.           */
name|ptr
operator|+=
name|safeLength
expr_stmt|;
name|length
operator|-=
name|safeLength
expr_stmt|;
block|}
do|while
condition|(
name|length
operator|>
literal|0
condition|)
do|;
comment|/* And the following is always safe because the crc is only 32 bits. */
name|png_ptr
operator|->
name|crc
operator|=
operator|(
name|png_uint_32
operator|)
name|crc
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Check a user supplied version number, called from both read and write  * functions that create a png_struct  */
end_comment
begin_function
name|int
DECL|function|png_user_version_check
name|png_user_version_check
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|user_png_ver
parameter_list|)
block|{
if|if
condition|(
name|user_png_ver
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|user_png_ver
index|[
name|i
index|]
operator|!=
name|png_libpng_ver
index|[
name|i
index|]
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_LIBRARY_MISMATCH
expr_stmt|;
block|}
do|while
condition|(
name|png_libpng_ver
index|[
name|i
operator|++
index|]
condition|)
do|;
block|}
else|else
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_LIBRARY_MISMATCH
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_LIBRARY_MISMATCH
condition|)
block|{
comment|/* Libpng 0.90 and later are binary incompatible with libpng 0.89, so       * we must recompile any applications that use any older library version.       * For versions after libpng 1.0, we will be compatible, so we need       * only check the first digit.       */
if|if
condition|(
name|user_png_ver
operator|==
name|NULL
operator|||
name|user_png_ver
index|[
literal|0
index|]
operator|!=
name|png_libpng_ver
index|[
literal|0
index|]
operator|||
operator|(
name|user_png_ver
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|user_png_ver
index|[
literal|2
index|]
operator|!=
name|png_libpng_ver
index|[
literal|2
index|]
operator|)
operator|||
operator|(
name|user_png_ver
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|user_png_ver
index|[
literal|2
index|]
operator|<
literal|'9'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|m
index|[
literal|128
index|]
decl_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|pos
argument_list|,
literal|"Application built with libpng-"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|pos
argument_list|,
name|user_png_ver
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|pos
argument_list|,
literal|" but running with "
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|pos
argument_list|,
name|png_libpng_ver
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_ERROR_NUMBERS_SUPPORTED
name|png_ptr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
comment|/* Success return. */
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* Allocate the memory for an info_struct for the application.  We don't  * really need the png_ptr, but it could potentially be useful in the  * future.  This should be used in favour of malloc(png_sizeof(png_info))  * and png_info_init() so that applications that want to use a shared  * libpng don't have to be recompiled if png_info changes size.  */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_infop
argument_list|,
argument|PNGAPI png_create_info_struct
argument_list|,
argument|(png_structp png_ptr)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_infop
name|info_ptr
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_create_info_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|info_ptr
operator|=
operator|(
name|png_infop
operator|)
name|png_create_struct_2
argument_list|(
name|PNG_STRUCT_INFO
argument_list|,
name|png_ptr
operator|->
name|malloc_fn
argument_list|,
name|png_ptr
operator|->
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|info_ptr
operator|=
operator|(
name|png_infop
operator|)
name|png_create_struct
argument_list|(
name|PNG_STRUCT_INFO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
name|png_info_init_3
argument_list|(
operator|&
name|info_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|info_ptr
operator|)
return|;
block|}
end_block
begin_comment
comment|/* This function frees the memory associated with a single info struct.  * Normally, one would use either png_destroy_read_struct() or  * png_destroy_write_struct() to free an info struct, but this may be  * useful for some applications.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_destroy_info_struct
name|png_destroy_info_struct
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infopp
name|info_ptr_ptr
parameter_list|)
block|{
name|png_infop
name|info_ptr
init|=
name|NULL
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_destroy_info_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|info_ptr_ptr
operator|!=
name|NULL
condition|)
name|info_ptr
operator|=
operator|*
name|info_ptr_ptr
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_info_destroy
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|free_fn
argument_list|,
name|png_ptr
operator|->
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|info_ptr_ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Initialize the info structure.  This is now an internal function (0.89)  * and applications using it are urged to use png_create_info_struct()  * instead.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_info_init_3
name|png_info_init_3
parameter_list|(
name|png_infopp
name|ptr_ptr
parameter_list|,
name|png_size_t
name|png_info_struct_size
parameter_list|)
block|{
name|png_infop
name|info_ptr
init|=
operator|*
name|ptr_ptr
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_info_init_3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
operator|>
name|png_info_struct_size
condition|)
block|{
name|png_destroy_struct
argument_list|(
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|=
operator|(
name|png_infop
operator|)
name|png_create_struct
argument_list|(
name|PNG_STRUCT_INFO
argument_list|)
expr_stmt|;
operator|*
name|ptr_ptr
operator|=
name|info_ptr
expr_stmt|;
block|}
comment|/* Set everything to 0 */
name|png_memset
argument_list|(
name|info_ptr
argument_list|,
literal|0
argument_list|,
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_data_freer
name|png_data_freer
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|freer
parameter_list|,
name|png_uint_32
name|mask
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_data_freer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|freer
operator|==
name|PNG_DESTROY_WILL_FREE_DATA
condition|)
name|info_ptr
operator|->
name|free_me
operator||=
name|mask
expr_stmt|;
elseif|else
if|if
condition|(
name|freer
operator|==
name|PNG_USER_WILL_FREE_DATA
condition|)
name|info_ptr
operator|->
name|free_me
operator|&=
operator|~
name|mask
expr_stmt|;
else|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown freer parameter in png_data_freer"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_free_data
name|png_free_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|mask
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_free_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* Free text item num or (if num == -1) all text items */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_TEXT
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|text
operator|&&
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_text
condition|;
name|i
operator|++
control|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_TEXT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|num_text
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
comment|/* Free any tRNS entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_TRNS
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|trans_alpha
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|trans_alpha
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_tRNS
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
comment|/* Free any sCAL entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_SCAL
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_width
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_height
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_width
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_height
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_sCAL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
comment|/* Free any pCAL entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_PCAL
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_purpose
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_units
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_purpose
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|pcal_units
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_params
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|pcal_nparams
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_params
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
operator|=
name|NULL
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_pCAL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
comment|/* Free any iCCP entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_ICCP
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_name
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_profile
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|iccp_name
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|iccp_profile
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_iCCP
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
comment|/* Free a given sPLT entry, or (if num == -1) all sPLT entries */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_SPLT
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|splt_palettes
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|entries
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|info_ptr
operator|->
name|splt_palettes_num
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|splt_palettes_num
condition|;
name|i
operator|++
control|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_SPLT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes_num
operator|=
literal|0
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_sPLT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_UNKN
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|num
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|num
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks_num
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|unknown_chunks_num
condition|;
name|i
operator|++
control|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_UNKN
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks_num
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
comment|/* Free any hIST entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_HIST
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|hist
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|hist
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_hIST
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Free any PLTE entry that was internally allocated */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_PLTE
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_zfree
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|palette
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|palette
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_PLTE
expr_stmt|;
name|info_ptr
operator|->
name|num_palette
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
comment|/* Free any image bits attached to the info structure */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_ROWS
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|row_pointers
condition|)
block|{
name|int
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|height
condition|;
name|row
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
index|[
name|row
index|]
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|row_pointers
index|[
name|row
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|row_pointers
operator|=
name|NULL
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_IDAT
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
name|mask
operator|&=
operator|~
name|PNG_FREE_MUL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is an internal routine to free any memory that the info struct is  * pointing to before re-using it or freeing the struct itself.  Recall  * that png_free() checks for NULL pointers for us.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_info_destroy
name|png_info_destroy
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_info_destroy"
argument_list|)
expr_stmt|;
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ALL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|num_chunk_list
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_list
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|num_chunk_list
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|png_info_init_3
argument_list|(
operator|&
name|info_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
end_comment
begin_comment
comment|/* This function returns a pointer to the io_ptr associated with the user  * functions.  The application should free any memory associated with this  * pointer before png_write_destroy() or png_read_destroy() are called.  */
end_comment
begin_function
name|png_voidp
name|PNGAPI
DECL|function|png_get_io_ptr
name|png_get_io_ptr
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|png_ptr
operator|->
name|io_ptr
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
end_ifdef
begin_comment
comment|/* Initialize the default input/output functions for the PNG file.  If you  * use your own read or write routines, you can call either png_set_read_fn()  * or png_set_write_fn() instead of png_init_io().  If you have defined  * PNG_NO_STDIO or otherwise disabled PNG_STDIO_SUPPORTED, you must use a  * function of your own because "FILE *" isn't necessarily available.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_init_io
name|png_init_io
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_FILE_p
name|fp
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_init_io"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|io_ptr
operator|=
operator|(
name|png_voidp
operator|)
name|fp
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
end_ifdef
begin_comment
comment|/* Convert the supplied time into an RFC 1123 string suitable for use in  * a "Creation Time" or other text-based time string.  */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_convert_to_rfc1123
name|png_convert_to_rfc1123
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_timep
name|ptime
parameter_list|)
block|{
specifier|static
name|PNG_CONST
name|char
name|short_months
index|[
literal|12
index|]
index|[
literal|4
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ptime
operator|->
name|year
operator|>
literal|9999
comment|/* RFC1123 limitation */
operator|||
name|ptime
operator|->
name|month
operator|==
literal|0
operator|||
name|ptime
operator|->
name|month
operator|>
literal|12
operator|||
name|ptime
operator|->
name|day
operator|==
literal|0
operator|||
name|ptime
operator|->
name|day
operator|>
literal|31
operator|||
name|ptime
operator|->
name|hour
operator|>
literal|23
operator|||
name|ptime
operator|->
name|minute
operator|>
literal|59
operator|||
name|ptime
operator|->
name|second
operator|>
literal|60
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring invalid time value"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|number_buf
index|[
literal|5
index|]
decl_stmt|;
comment|/* enough for a four-digit year */
DECL|macro|APPEND_STRING
define|#
directive|define
name|APPEND_STRING
parameter_list|(
name|string
parameter_list|)
define|\
value|pos = png_safecat(png_ptr->time_buffer, sizeof png_ptr->time_buffer,\             pos, (string))
DECL|macro|APPEND_NUMBER
define|#
directive|define
name|APPEND_NUMBER
parameter_list|(
name|format
parameter_list|,
name|value
parameter_list|)
define|\
value|APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
DECL|macro|APPEND
define|#
directive|define
name|APPEND
parameter_list|(
name|ch
parameter_list|)
define|\
value|if (pos< (sizeof png_ptr->time_buffer)-1)\             png_ptr->time_buffer[pos++] = (ch)
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|day
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|APPEND_STRING
argument_list|(
name|short_months
index|[
operator|(
name|ptime
operator|->
name|month
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_u
argument_list|,
name|ptime
operator|->
name|year
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_02u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|hour
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_02u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|minute
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|APPEND_NUMBER
argument_list|(
name|PNG_NUMBER_FORMAT_02u
argument_list|,
operator|(
name|unsigned
operator|)
name|ptime
operator|->
name|second
argument_list|)
expr_stmt|;
name|APPEND_STRING
argument_list|(
literal|" +0000"
argument_list|)
expr_stmt|;
comment|/* This reliably terminates the buffer */
DECL|macro|APPEND
undef|#
directive|undef
name|APPEND
DECL|macro|APPEND_NUMBER
undef|#
directive|undef
name|APPEND_NUMBER
DECL|macro|APPEND_STRING
undef|#
directive|undef
name|APPEND_STRING
block|}
return|return
name|png_ptr
operator|->
name|time_buffer
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_TIME_RFC1123_SUPPORTED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_copyright
name|png_get_copyright
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
ifdef|#
directive|ifdef
name|PNG_STRING_COPYRIGHT
return|return
name|PNG_STRING_COPYRIGHT
else|#
directive|else
ifdef|#
directive|ifdef
name|__STDC__
return|return
name|PNG_STRING_NEWLINE
expr|\
literal|"libpng version 1.5.10 - March 29, 2012"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1998-2011 Glenn Randers-Pehrson"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1996-1997 Andreas Dilger"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc."
expr|\
name|PNG_STRING_NEWLINE
return|;
else|#
directive|else
return|return
literal|"libpng version 1.5.10 - March 29, 2012\       Copyright (c) 1998-2011 Glenn Randers-Pehrson\       Copyright (c) 1996-1997 Andreas Dilger\       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc."
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* The following return the library version as a short string in the  * format 1.0.0 through 99.99.99zz.  To get the version of *.h files  * used with your application, print out PNG_LIBPNG_VER_STRING, which  * is defined in png.h.  * Note: now there is no difference between png_get_libpng_ver() and  * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,  * it is guaranteed that png.c uses the correct version of png.h.  */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_libpng_ver
name|png_get_libpng_ver
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Version of *.c files used when building libpng */
return|return
name|png_get_header_ver
argument_list|(
name|png_ptr
argument_list|)
return|;
block|}
end_function
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_header_ver
name|png_get_header_ver
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Version of *.h files used when building libpng */
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
return|return
name|PNG_LIBPNG_VER_STRING
return|;
block|}
end_function
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_header_version
name|png_get_header_version
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Returns longer string containing both version and date */
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
ifdef|#
directive|ifdef
name|__STDC__
return|return
name|PNG_HEADER_VERSION_STRING
ifndef|#
directive|ifndef
name|PNG_READ_SUPPORTED
literal|"     (NO READ SUPPORT)"
endif|#
directive|endif
name|PNG_STRING_NEWLINE
return|;
else|#
directive|else
return|return
name|PNG_HEADER_VERSION_STRING
return|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
end_ifdef
begin_function
name|int
name|PNGAPI
DECL|function|png_handle_as_unknown
name|png_handle_as_unknown
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_name
parameter_list|)
block|{
comment|/* Check chunk_name and return "keep" value if it's on the list, else 0 */
name|png_const_bytep
name|p
decl_stmt|,
name|p_end
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|chunk_name
operator|==
name|NULL
operator|||
name|png_ptr
operator|->
name|num_chunk_list
operator|<=
literal|0
condition|)
return|return
name|PNG_HANDLE_CHUNK_AS_DEFAULT
return|;
name|p_end
operator|=
name|png_ptr
operator|->
name|chunk_list
expr_stmt|;
name|p
operator|=
name|p_end
operator|+
name|png_ptr
operator|->
name|num_chunk_list
operator|*
literal|5
expr_stmt|;
comment|/* beyond end */
comment|/* The code is the fifth byte after each four byte string.  Historically this     * code was always searched from the end of the list, so it should continue     * to do so in case there are duplicated entries.     */
do|do
comment|/* num_chunk_list> 0, so at least one */
block|{
name|p
operator|-=
literal|5
expr_stmt|;
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|chunk_name
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|p
index|[
literal|4
index|]
return|;
block|}
do|while
condition|(
name|p
operator|>
name|p_end
condition|)
do|;
return|return
name|PNG_HANDLE_CHUNK_AS_DEFAULT
return|;
block|}
end_function
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_chunk_unknown_handling
name|png_chunk_unknown_handling
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|)
block|{
name|png_byte
name|chunk_string
index|[
literal|5
index|]
decl_stmt|;
name|PNG_CSTRING_FROM_CHUNK
argument_list|(
name|chunk_string
argument_list|,
name|chunk_name
argument_list|)
expr_stmt|;
return|return
name|png_handle_as_unknown
argument_list|(
name|png_ptr
argument_list|,
name|chunk_string
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* This function, added to libpng-1.0.6g, is untested. */
end_comment
begin_function
name|int
name|PNGAPI
DECL|function|png_reset_zstream
name|png_reset_zstream
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
return|return
operator|(
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_SUPPORTED */
end_comment
begin_comment
comment|/* This function was added to libpng-1.0.7 */
end_comment
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_access_version_number
name|png_access_version_number
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Version of *.c files used when building libpng */
return|return
operator|(
operator|(
name|png_uint_32
operator|)
name|PNG_LIBPNG_VER
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* png_convert_size: a PNGAPI but no longer in png.h, so deleted  * at libpng 1.5.5!  */
end_comment
begin_comment
comment|/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CHECK_cHRM_SUPPORTED
end_ifdef
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_check_cHRM_fixed
name|png_check_cHRM_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|white_x
parameter_list|,
name|png_fixed_point
name|white_y
parameter_list|,
name|png_fixed_point
name|red_x
parameter_list|,
name|png_fixed_point
name|red_y
parameter_list|,
name|png_fixed_point
name|green_x
parameter_list|,
name|png_fixed_point
name|green_y
parameter_list|,
name|png_fixed_point
name|blue_x
parameter_list|,
name|png_fixed_point
name|blue_y
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|xy_hi
decl_stmt|,
name|xy_lo
decl_stmt|,
name|yx_hi
decl_stmt|,
name|yx_lo
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in function png_check_cHRM_fixed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* (x,y,z) values are first limited to 0..100000 (PNG_FP_1), the white     * y must also be greater than 0.  To test for the upper limit calculate     * (PNG_FP_1-y) - x must be<= to this for z to be>= 0 (and the expression     * cannot overflow.)  At this point we know x and y are>= 0 and (x+y) is     *<= PNG_FP_1.  The previous test on PNG_MAX_UINT_31 is removed because it     * pointless (and it produces compiler warnings!)     */
if|if
condition|(
name|white_x
operator|<
literal|0
operator|||
name|white_y
operator|<=
literal|0
operator|||
name|red_x
operator|<
literal|0
operator|||
name|red_y
operator|<
literal|0
operator|||
name|green_x
operator|<
literal|0
operator|||
name|green_y
operator|<
literal|0
operator|||
name|blue_x
operator|<
literal|0
operator|||
name|blue_y
operator|<
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to set negative chromaticity value"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
comment|/* And (x+y) must be<= PNG_FP_1 (so z is>= 0) */
if|if
condition|(
name|white_x
operator|>
name|PNG_FP_1
operator|-
name|white_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM white point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|red_x
operator|>
name|PNG_FP_1
operator|-
name|red_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM red point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|green_x
operator|>
name|PNG_FP_1
operator|-
name|green_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM green point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|blue_x
operator|>
name|PNG_FP_1
operator|-
name|blue_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM blue point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|png_64bit_product
argument_list|(
name|green_x
operator|-
name|red_x
argument_list|,
name|blue_y
operator|-
name|red_y
argument_list|,
operator|&
name|xy_hi
argument_list|,
operator|&
name|xy_lo
argument_list|)
expr_stmt|;
name|png_64bit_product
argument_list|(
name|green_y
operator|-
name|red_y
argument_list|,
name|blue_x
operator|-
name|red_x
argument_list|,
operator|&
name|yx_hi
argument_list|,
operator|&
name|yx_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|xy_hi
operator|==
name|yx_hi
operator|&&
name|xy_lo
operator|==
name|yx_lo
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to set cHRM RGB triangle with zero area"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_CHECK_cHRM_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_cHRM_SUPPORTED
end_ifdef
begin_comment
comment|/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for  * cHRM, as opposed to using chromaticities.  These internal APIs return  * non-zero on a parameter error.  The X, Y and Z values are required to be  * positive and less than 1.0.  */
end_comment
begin_function
DECL|function|png_xy_from_XYZ
name|int
name|png_xy_from_XYZ
parameter_list|(
name|png_xy
modifier|*
name|xy
parameter_list|,
name|png_XYZ
name|XYZ
parameter_list|)
block|{
name|png_int_32
name|d
decl_stmt|,
name|dwhite
decl_stmt|,
name|whiteX
decl_stmt|,
name|whiteY
decl_stmt|;
name|d
operator|=
name|XYZ
operator|.
name|redX
operator|+
name|XYZ
operator|.
name|redY
operator|+
name|XYZ
operator|.
name|redZ
expr_stmt|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|redx
argument_list|,
name|XYZ
operator|.
name|redX
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|redy
argument_list|,
name|XYZ
operator|.
name|redY
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|1
return|;
name|dwhite
operator|=
name|d
expr_stmt|;
name|whiteX
operator|=
name|XYZ
operator|.
name|redX
expr_stmt|;
name|whiteY
operator|=
name|XYZ
operator|.
name|redY
expr_stmt|;
name|d
operator|=
name|XYZ
operator|.
name|greenX
operator|+
name|XYZ
operator|.
name|greenY
operator|+
name|XYZ
operator|.
name|greenZ
expr_stmt|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|greenx
argument_list|,
name|XYZ
operator|.
name|greenX
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|greeny
argument_list|,
name|XYZ
operator|.
name|greenY
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|1
return|;
name|dwhite
operator|+=
name|d
expr_stmt|;
name|whiteX
operator|+=
name|XYZ
operator|.
name|greenX
expr_stmt|;
name|whiteY
operator|+=
name|XYZ
operator|.
name|greenY
expr_stmt|;
name|d
operator|=
name|XYZ
operator|.
name|blueX
operator|+
name|XYZ
operator|.
name|blueY
operator|+
name|XYZ
operator|.
name|blueZ
expr_stmt|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|bluex
argument_list|,
name|XYZ
operator|.
name|blueX
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|bluey
argument_list|,
name|XYZ
operator|.
name|blueY
argument_list|,
name|PNG_FP_1
argument_list|,
name|d
argument_list|)
condition|)
return|return
literal|1
return|;
name|dwhite
operator|+=
name|d
expr_stmt|;
name|whiteX
operator|+=
name|XYZ
operator|.
name|blueX
expr_stmt|;
name|whiteY
operator|+=
name|XYZ
operator|.
name|blueY
expr_stmt|;
comment|/* The reference white is simply the same of the end-point (X,Y,Z) vectors,     * thus:     */
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|whitex
argument_list|,
name|whiteX
argument_list|,
name|PNG_FP_1
argument_list|,
name|dwhite
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|xy
operator|->
name|whitey
argument_list|,
name|whiteY
argument_list|,
name|PNG_FP_1
argument_list|,
name|dwhite
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|png_XYZ_from_xy
name|int
name|png_XYZ_from_xy
parameter_list|(
name|png_XYZ
modifier|*
name|XYZ
parameter_list|,
name|png_xy
name|xy
parameter_list|)
block|{
name|png_fixed_point
name|red_inverse
decl_stmt|,
name|green_inverse
decl_stmt|,
name|blue_scale
decl_stmt|;
name|png_fixed_point
name|left
decl_stmt|,
name|right
decl_stmt|,
name|denominator
decl_stmt|;
comment|/* Check xy and, implicitly, z.  Note that wide gamut color spaces typically     * have end points with 0 tristimulus values (these are impossible end     * points, but they are used to cover the possible colors.)     */
if|if
condition|(
name|xy
operator|.
name|redx
operator|<
literal|0
operator|||
name|xy
operator|.
name|redx
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|.
name|redy
operator|<
literal|0
operator|||
name|xy
operator|.
name|redy
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|.
name|redx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|.
name|greenx
operator|<
literal|0
operator|||
name|xy
operator|.
name|greenx
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|.
name|greeny
operator|<
literal|0
operator|||
name|xy
operator|.
name|greeny
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|.
name|greenx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|.
name|bluex
operator|<
literal|0
operator|||
name|xy
operator|.
name|bluex
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|.
name|bluey
operator|<
literal|0
operator|||
name|xy
operator|.
name|bluey
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|.
name|bluex
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|.
name|whitex
operator|<
literal|0
operator|||
name|xy
operator|.
name|whitex
operator|>
name|PNG_FP_1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|xy
operator|.
name|whitey
operator|<
literal|0
operator|||
name|xy
operator|.
name|whitey
operator|>
name|PNG_FP_1
operator|-
name|xy
operator|.
name|whitex
condition|)
return|return
literal|1
return|;
comment|/* The reverse calculation is more difficult because the original tristimulus     * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8     * derived values were recorded in the cHRM chunk;     * (red,green,blue,white)x(x,y).  This loses one degree of freedom and     * therefore an arbitrary ninth value has to be introduced to undo the     * original transformations.     *     * Think of the original end-points as points in (X,Y,Z) space.  The     * chromaticity values (c) have the property:     *     *           C     *   c = ---------     *       X + Y + Z     *     * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the     * three chromaticity values (x,y,z) for each end-point obey the     * relationship:     *     *   x + y + z = 1     *     * This describes the plane in (X,Y,Z) space that intersects each axis at the     * value 1.0; call this the chromaticity plane.  Thus the chromaticity     * calculation has scaled each end-point so that it is on the x+y+z=1 plane     * and chromaticity is the intersection of the vector from the origin to the     * (X,Y,Z) value with the chromaticity plane.     *     * To fully invert the chromaticity calculation we would need the three     * end-point scale factors, (red-scale, green-scale, blue-scale), but these     * were not recorded.  Instead we calculated the reference white (X,Y,Z) and     * recorded the chromaticity of this.  The reference white (X,Y,Z) would have     * given all three of the scale factors since:     *     *    color-C = color-c * color-scale     *    white-C = red-C + green-C + blue-C     *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale     *     * But cHRM records only white-x and white-y, so we have lost the white scale     * factor:     *     *    white-C = white-c*white-scale     *     * To handle this the inverse transformation makes an arbitrary assumption     * about white-scale:     *     *    Assume: white-Y = 1.0     *    Hence:  white-scale = 1/white-y     *    Or:     red-Y + green-Y + blue-Y = 1.0     *     * Notice the last statement of the assumption gives an equation in three of     * the nine values we want to calculate.  8 more equations come from the     * above routine as summarised at the top above (the chromaticity     * calculation):     *     *    Given: color-x = color-X / (color-X + color-Y + color-Z)     *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0     *     * This is 9 simultaneous equations in the 9 variables "color-C" and can be     * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix     * determinants, however this is not as bad as it seems because only 28 of     * the total of 90 terms in the various matrices are non-zero.  Nevertheless     * Cramer's rule is notoriously numerically unstable because the determinant     * calculation involves the difference of large, but similar, numbers.  It is     * difficult to be sure that the calculation is stable for real world values     * and it is certain that it becomes unstable where the end points are close     * together.     *     * So this code uses the perhaps slighly less optimal but more understandable     * and totally obvious approach of calculating color-scale.     *     * This algorithm depends on the precision in white-scale and that is     * (1/white-y), so we can immediately see that as white-y approaches 0 the     * accuracy inherent in the cHRM chunk drops off substantially.     *     * libpng arithmetic: a simple invertion of the above equations     * ------------------------------------------------------------     *     *    white_scale = 1/white-y     *    white-X = white-x * white-scale     *    white-Y = 1.0     *    white-Z = (1 - white-x - white-y) * white_scale     *     *    white-C = red-C + green-C + blue-C     *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale     *     * This gives us three equations in (red-scale,green-scale,blue-scale) where     * all the coefficients are now known:     *     *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale     *       = white-x/white-y     *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1     *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale     *       = (1 - white-x - white-y)/white-y     *     * In the last equation color-z is (1 - color-x - color-y) so we can add all     * three equations together to get an alternative third:     *     *    red-scale + green-scale + blue-scale = 1/white-y = white-scale     *     * So now we have a Cramer's rule solution where the determinants are just     * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve     * multiplication of three coefficients so we can't guarantee to avoid     * overflow in the libpng fixed point representation.  Using Cramer's rule in     * floating point is probably a good choice here, but it's not an option for     * fixed point.  Instead proceed to simplify the first two equations by     * eliminating what is likely to be the largest value, blue-scale:     *     *    blue-scale = white-scale - red-scale - green-scale     *     * Hence:     *     *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =     *                (white-x - blue-x)*white-scale     *     *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =     *                1 - blue-y*white-scale     *     * And now we can trivially solve for (red-scale,green-scale):     *     *    green-scale =     *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale     *                -----------------------------------------------------------     *                                  green-x - blue-x     *     *    red-scale =     *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale     *                ---------------------------------------------------------     *                                  red-y - blue-y     *     * Hence:     *     *    red-scale =     *          ( (green-x - blue-x) * (white-y - blue-y) -     *            (green-y - blue-y) * (white-x - blue-x) ) / white-y     * -------------------------------------------------------------------------     *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)     *     *    green-scale =     *          ( (red-y - blue-y) * (white-x - blue-x) -     *            (red-x - blue-x) * (white-y - blue-y) ) / white-y     * -------------------------------------------------------------------------     *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)     *     * Accuracy:     * The input values have 5 decimal digits of accuracy.  The values are all in     * the range 0< value< 1, so simple products are in the same range but may     * need up to 10 decimal digits to preserve the original precision and avoid     * underflow.  Because we are using a 32-bit signed representation we cannot     * match this; the best is a little over 9 decimal digits, less than 10.     *     * The approach used here is to preserve the maximum precision within the     * signed representation.  Because the red-scale calculation above uses the     * difference between two products of values that must be in the range -1..+1     * it is sufficient to divide the product by 7; ceil(100,000/32767*2).  The     * factor is irrelevant in the calculation because it is applied to both     * numerator and denominator.     *     * Note that the values of the differences of the products of the     * chromaticities in the above equations tend to be small, for example for     * the sRGB chromaticities they are:     *     * red numerator:    -0.04751     * green numerator:  -0.08788     * denominator:      -0.2241 (without white-y multiplication)     *     *  The resultant Y coefficients from the chromaticities of some widely used     *  color space definitions are (to 15 decimal places):     *     *  sRGB     *    0.212639005871510 0.715168678767756 0.072192315360734     *  Kodak ProPhoto     *    0.288071128229293 0.711843217810102 0.000085653960605     *  Adobe RGB     *    0.297344975250536 0.627363566255466 0.075291458493998     *  Adobe Wide Gamut RGB     *    0.258728243040113 0.724682314948566 0.016589442011321     */
comment|/* By the argument, above overflow should be impossible here. The return     * value of 2 indicates an internal error to the caller.     */
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|left
argument_list|,
name|xy
operator|.
name|greenx
operator|-
name|xy
operator|.
name|bluex
argument_list|,
name|xy
operator|.
name|redy
operator|-
name|xy
operator|.
name|bluey
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|right
argument_list|,
name|xy
operator|.
name|greeny
operator|-
name|xy
operator|.
name|bluey
argument_list|,
name|xy
operator|.
name|redx
operator|-
name|xy
operator|.
name|bluex
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|2
return|;
name|denominator
operator|=
name|left
operator|-
name|right
expr_stmt|;
comment|/* Now find the red numerator. */
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|left
argument_list|,
name|xy
operator|.
name|greenx
operator|-
name|xy
operator|.
name|bluex
argument_list|,
name|xy
operator|.
name|whitey
operator|-
name|xy
operator|.
name|bluey
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|right
argument_list|,
name|xy
operator|.
name|greeny
operator|-
name|xy
operator|.
name|bluey
argument_list|,
name|xy
operator|.
name|whitex
operator|-
name|xy
operator|.
name|bluex
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|2
return|;
comment|/* Overflow is possible here and it indicates an extreme set of PNG cHRM     * chunk values.  This calculation actually returns the reciprocal of the     * scale value because this allows us to delay the multiplication of white-y     * into the denominator, which tends to produce a small number.     */
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|red_inverse
argument_list|,
name|xy
operator|.
name|whitey
argument_list|,
name|denominator
argument_list|,
name|left
operator|-
name|right
argument_list|)
operator|||
name|red_inverse
operator|<=
name|xy
operator|.
name|whitey
comment|/* r+g+b scales = white scale */
condition|)
return|return
literal|1
return|;
comment|/* Similarly for green_inverse: */
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|left
argument_list|,
name|xy
operator|.
name|redy
operator|-
name|xy
operator|.
name|bluey
argument_list|,
name|xy
operator|.
name|whitex
operator|-
name|xy
operator|.
name|bluex
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|right
argument_list|,
name|xy
operator|.
name|redx
operator|-
name|xy
operator|.
name|bluex
argument_list|,
name|xy
operator|.
name|whitey
operator|-
name|xy
operator|.
name|bluey
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|green_inverse
argument_list|,
name|xy
operator|.
name|whitey
argument_list|,
name|denominator
argument_list|,
name|left
operator|-
name|right
argument_list|)
operator|||
name|green_inverse
operator|<=
name|xy
operator|.
name|whitey
condition|)
return|return
literal|1
return|;
comment|/* And the blue scale, the checks above guarantee this can't overflow but it     * can still produce 0 for extreme cHRM values.     */
name|blue_scale
operator|=
name|png_reciprocal
argument_list|(
name|xy
operator|.
name|whitey
argument_list|)
operator|-
name|png_reciprocal
argument_list|(
name|red_inverse
argument_list|)
operator|-
name|png_reciprocal
argument_list|(
name|green_inverse
argument_list|)
expr_stmt|;
if|if
condition|(
name|blue_scale
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* And fill in the png_XYZ: */
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|redX
argument_list|,
name|xy
operator|.
name|redx
argument_list|,
name|PNG_FP_1
argument_list|,
name|red_inverse
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|redY
argument_list|,
name|xy
operator|.
name|redy
argument_list|,
name|PNG_FP_1
argument_list|,
name|red_inverse
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|redZ
argument_list|,
name|PNG_FP_1
operator|-
name|xy
operator|.
name|redx
operator|-
name|xy
operator|.
name|redy
argument_list|,
name|PNG_FP_1
argument_list|,
name|red_inverse
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|greenX
argument_list|,
name|xy
operator|.
name|greenx
argument_list|,
name|PNG_FP_1
argument_list|,
name|green_inverse
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|greenY
argument_list|,
name|xy
operator|.
name|greeny
argument_list|,
name|PNG_FP_1
argument_list|,
name|green_inverse
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|greenZ
argument_list|,
name|PNG_FP_1
operator|-
name|xy
operator|.
name|greenx
operator|-
name|xy
operator|.
name|greeny
argument_list|,
name|PNG_FP_1
argument_list|,
name|green_inverse
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blueX
argument_list|,
name|xy
operator|.
name|bluex
argument_list|,
name|blue_scale
argument_list|,
name|PNG_FP_1
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blueY
argument_list|,
name|xy
operator|.
name|bluey
argument_list|,
name|blue_scale
argument_list|,
name|PNG_FP_1
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|png_muldiv
argument_list|(
operator|&
name|XYZ
operator|->
name|blueZ
argument_list|,
name|PNG_FP_1
operator|-
name|xy
operator|.
name|bluex
operator|-
name|xy
operator|.
name|bluey
argument_list|,
name|blue_scale
argument_list|,
name|PNG_FP_1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/*success*/
block|}
end_function
begin_function
DECL|function|png_XYZ_from_xy_checked
name|int
name|png_XYZ_from_xy_checked
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_XYZ
modifier|*
name|XYZ
parameter_list|,
name|png_xy
name|xy
parameter_list|)
block|{
switch|switch
condition|(
name|png_XYZ_from_xy
argument_list|(
name|XYZ
argument_list|,
name|xy
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* success */
return|return
literal|1
return|;
case|case
literal|1
case|:
comment|/* The chunk may be technically valid, but we got png_fixed_point           * overflow while trying to get XYZ values out of it.  This is           * entirely benign - the cHRM chunk is pretty extreme.           */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"extreme cHRM chunk cannot be converted to tristimulus values"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* libpng is broken; this should be a warning but if it happens we           * want error reports so for the moment it is an error.           */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"internal error in png_XYZ_from_xy"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* ERROR RETURN */
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_check_IHDR
name|png_check_IHDR
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|width
parameter_list|,
name|png_uint_32
name|height
parameter_list|,
name|int
name|bit_depth
parameter_list|,
name|int
name|color_type
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|int
name|filter_type
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check for width and height valid values */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image width is zero in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image height is zero in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|width
operator|>
name|png_ptr
operator|->
name|user_width_max
condition|)
else|#
directive|else
if|if
condition|(
name|width
operator|>
name|PNG_USER_WIDTH_MAX
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image width exceeds user limit in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|height
operator|>
name|png_ptr
operator|->
name|user_height_max
condition|)
else|#
directive|else
if|if
condition|(
name|height
operator|>
name|PNG_USER_HEIGHT_MAX
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image height exceeds user limit in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image width in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|>
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image height in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
operator|(
name|PNG_UINT_32_MAX
operator|>>
literal|3
operator|)
comment|/* 8-byte RGBA pixels */
operator|-
literal|48
comment|/* bigrowbuf hack */
operator|-
literal|1
comment|/* filter byte */
operator|-
literal|7
operator|*
literal|8
comment|/* rounding of width to multiple of 8 pixels */
operator|-
literal|8
condition|)
comment|/* extra max_pixel_depth pad */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Width is too large for libpng to process pixels"
argument_list|)
expr_stmt|;
comment|/* Check other values */
if|if
condition|(
name|bit_depth
operator|!=
literal|1
operator|&&
name|bit_depth
operator|!=
literal|2
operator|&&
name|bit_depth
operator|!=
literal|4
operator|&&
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|color_type
operator|<
literal|0
operator|||
name|color_type
operator|==
literal|1
operator|||
name|color_type
operator|==
literal|5
operator|||
name|color_type
operator|>
literal|6
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid color type in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
operator|&&
name|bit_depth
operator|>
literal|8
operator|)
operator|||
operator|(
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|&&
name|bit_depth
operator|<
literal|8
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid color type/bit depth combination in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|interlace_type
operator|>=
name|PNG_INTERLACE_LAST
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown interlace method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|compression_type
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown compression method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
comment|/* Accept filter_method 64 (intrapixel differencing) only if     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and     * 2. Libpng did not read a PNG signature (this filter_method is only     *    used in PNG datastreams that are embedded in MNG datastreams) and     * 3. The application called png_permit_mng_features with a mask that     *    included PNG_FLAG_MNG_FILTER_64 and     * 4. The filter_method is 64 and     * 5. The color_type is RGB or RGBA     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|&&
name|png_ptr
operator|->
name|mng_features_permitted
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"MNG features are not allowed in a PNG datastream"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|&&
operator|(
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|1
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid IHDR data"
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_pCAL_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* ASCII to fp functions */
end_comment
begin_comment
comment|/* Check an ASCII formated floating point value, see the more detailed  * comments in pngpriv.h  */
end_comment
begin_comment
comment|/* The following is used internally to preserve the sticky flags */
end_comment
begin_define
DECL|macro|png_fp_add
define|#
directive|define
name|png_fp_add
parameter_list|(
name|state
parameter_list|,
name|flags
parameter_list|)
value|((state) |= (flags))
end_define
begin_define
DECL|macro|png_fp_set
define|#
directive|define
name|png_fp_set
parameter_list|(
name|state
parameter_list|,
name|value
parameter_list|)
value|((state) = (value) | ((state)& PNG_FP_STICKY))
end_define
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_check_fp_number
name|png_check_fp_number
parameter_list|(
name|png_const_charp
name|string
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|int
modifier|*
name|statep
parameter_list|,
name|png_size_tp
name|whereami
parameter_list|)
block|{
name|int
name|state
init|=
operator|*
name|statep
decl_stmt|;
name|png_size_t
name|i
init|=
operator|*
name|whereami
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|int
name|type
decl_stmt|;
comment|/* First find the type of the next character */
switch|switch
condition|(
name|string
index|[
name|i
index|]
condition|)
block|{
case|case
literal|43
case|:
name|type
operator|=
name|PNG_FP_SAW_SIGN
expr_stmt|;
break|break;
case|case
literal|45
case|:
name|type
operator|=
name|PNG_FP_SAW_SIGN
operator|+
name|PNG_FP_NEGATIVE
expr_stmt|;
break|break;
case|case
literal|46
case|:
name|type
operator|=
name|PNG_FP_SAW_DOT
expr_stmt|;
break|break;
case|case
literal|48
case|:
name|type
operator|=
name|PNG_FP_SAW_DIGIT
expr_stmt|;
break|break;
case|case
literal|49
case|:
case|case
literal|50
case|:
case|case
literal|51
case|:
case|case
literal|52
case|:
case|case
literal|53
case|:
case|case
literal|54
case|:
case|case
literal|55
case|:
case|case
literal|56
case|:
case|case
literal|57
case|:
name|type
operator|=
name|PNG_FP_SAW_DIGIT
operator|+
name|PNG_FP_NONZERO
expr_stmt|;
break|break;
case|case
literal|69
case|:
case|case
literal|101
case|:
name|type
operator|=
name|PNG_FP_SAW_E
expr_stmt|;
break|break;
default|default:
goto|goto
name|PNG_FP_End
goto|;
block|}
comment|/* Now deal with this type according to the current        * state, the type is arranged to not overlap the        * bits of the PNG_FP_STATE.        */
switch|switch
condition|(
operator|(
name|state
operator|&
name|PNG_FP_STATE
operator|)
operator|+
operator|(
name|type
operator|&
name|PNG_FP_SAW_ANY
operator|)
condition|)
block|{
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_SIGN
case|:
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_ANY
condition|)
goto|goto
name|PNG_FP_End
goto|;
comment|/* not a part of the number */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_DOT
case|:
comment|/* Ok as trailer, ok as lead of fraction. */
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_DOT
condition|)
comment|/* two dots */
goto|goto
name|PNG_FP_End
goto|;
elseif|else
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
condition|)
comment|/* trailing dot? */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_FRACTION
operator||
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_DIGIT
case|:
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_DOT
condition|)
comment|/* delayed fraction */
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_FRACTION
operator||
name|PNG_FP_SAW_DOT
argument_list|)
expr_stmt|;
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
operator||
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SAW_E
case|:
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_EXPONENT
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:          goto PNG_FP_End; ** no sign in fraction */
comment|/* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:          goto PNG_FP_End; ** Because SAW_DOT is always set */
case|case
name|PNG_FP_FRACTION
operator|+
name|PNG_FP_SAW_DIGIT
case|:
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|type
operator||
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_FRACTION
operator|+
name|PNG_FP_SAW_E
case|:
comment|/* This is correct because the trailing '.' on an           * integer is handled above - so we can only get here           * with the sequence ".E" (with no preceding digits).           */
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_EXPONENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_EXPONENT
operator|+
name|PNG_FP_SAW_SIGN
case|:
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_ANY
condition|)
goto|goto
name|PNG_FP_End
goto|;
comment|/* not a part of the number */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_SIGN
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:          goto PNG_FP_End; */
case|case
name|PNG_FP_EXPONENT
operator|+
name|PNG_FP_SAW_DIGIT
case|:
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_DIGIT
operator||
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:          goto PNG_FP_End; */
default|default:
goto|goto
name|PNG_FP_End
goto|;
comment|/* I.e. break 2 */
block|}
comment|/* The character seems ok, continue. */
operator|++
name|i
expr_stmt|;
block|}
name|PNG_FP_End
label|:
comment|/* Here at the end, update the state and return the correct     * return code.     */
operator|*
name|statep
operator|=
name|state
expr_stmt|;
operator|*
name|whereami
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/* The same but for a complete string. */
end_comment
begin_function
name|int
DECL|function|png_check_fp_string
name|png_check_fp_string
parameter_list|(
name|png_const_charp
name|string
parameter_list|,
name|png_size_t
name|size
parameter_list|)
block|{
name|int
name|state
init|=
literal|0
decl_stmt|;
name|png_size_t
name|char_index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|png_check_fp_number
argument_list|(
name|string
argument_list|,
name|size
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|char_index
argument_list|)
operator|&&
operator|(
name|char_index
operator|==
name|size
operator|||
name|string
index|[
name|char_index
index|]
operator|==
literal|0
operator|)
condition|)
return|return
name|state
comment|/* must be non-zero - see above */
return|;
return|return
literal|0
return|;
comment|/* i.e. fail */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* pCAL or sCAL */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* Utility used below - a simple accurate power of ten from an integral  * exponent.  */
end_comment
begin_function
specifier|static
name|double
DECL|function|png_pow10
name|png_pow10
parameter_list|(
name|int
name|power
parameter_list|)
block|{
name|int
name|recip
init|=
literal|0
decl_stmt|;
name|double
name|d
init|=
literal|1.0
decl_stmt|;
comment|/* Handle negative exponent with a reciprocal at the end because     * 10 is exact whereas .1 is inexact in base 2     */
if|if
condition|(
name|power
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|power
operator|<
name|DBL_MIN_10_EXP
condition|)
return|return
literal|0
return|;
name|recip
operator|=
literal|1
operator|,
name|power
operator|=
operator|-
name|power
expr_stmt|;
block|}
if|if
condition|(
name|power
operator|>
literal|0
condition|)
block|{
comment|/* Decompose power bitwise. */
name|double
name|mult
init|=
literal|10.0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|power
operator|&
literal|1
condition|)
name|d
operator|*=
name|mult
expr_stmt|;
name|mult
operator|*=
name|mult
expr_stmt|;
name|power
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|power
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|recip
condition|)
name|d
operator|=
literal|1
operator|/
name|d
expr_stmt|;
block|}
comment|/* else power is 0 and d is 1 */
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/* Function to format a floating point value in ASCII with a given  * precision.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_ascii_from_fp
name|png_ascii_from_fp
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_charp
name|ascii
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|double
name|fp
parameter_list|,
name|unsigned
name|int
name|precision
parameter_list|)
block|{
comment|/* We use standard functions from math.h, but not printf because     * that would require stdio.  The caller must supply a buffer of     * sufficient size or we will png_error.  The tests on size and     * the space in ascii[] consumed are indicated below.     */
if|if
condition|(
name|precision
operator|<
literal|1
condition|)
name|precision
operator|=
name|DBL_DIG
expr_stmt|;
comment|/* Enforce the limit of the implementation precision too. */
if|if
condition|(
name|precision
operator|>
name|DBL_DIG
operator|+
literal|1
condition|)
name|precision
operator|=
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
comment|/* Basic sanity checks */
if|if
condition|(
name|size
operator|>=
name|precision
operator|+
literal|5
condition|)
comment|/* See the requirements below. */
block|{
if|if
condition|(
name|fp
operator|<
literal|0
condition|)
block|{
name|fp
operator|=
operator|-
name|fp
expr_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|45
expr_stmt|;
comment|/* '-'  PLUS 1 TOTAL 1 */
operator|--
name|size
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|>=
name|DBL_MIN
operator|&&
name|fp
operator|<=
name|DBL_MAX
condition|)
block|{
name|int
name|exp_b10
decl_stmt|;
comment|/* A base 10 exponent */
name|double
name|base
decl_stmt|;
comment|/* 10^exp_b10 */
comment|/* First extract a base 10 exponent of the number,           * the calculation below rounds down when converting           * from base 2 to base 10 (multiply by log10(2) -           * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to           * be increased.  Note that the arithmetic shift           * performs a floor() unlike C arithmetic - using a           * C multiply would break the following for negative           * exponents.           */
operator|(
name|void
operator|)
name|frexp
argument_list|(
name|fp
argument_list|,
operator|&
name|exp_b10
argument_list|)
expr_stmt|;
comment|/* exponent to base 2 */
name|exp_b10
operator|=
operator|(
name|exp_b10
operator|*
literal|77
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/*<= exponent to base 10 */
comment|/* Avoid underflow here. */
name|base
operator|=
name|png_pow10
argument_list|(
name|exp_b10
argument_list|)
expr_stmt|;
comment|/* May underflow */
while|while
condition|(
name|base
operator|<
name|DBL_MIN
operator|||
name|base
operator|<
name|fp
condition|)
block|{
comment|/* And this may overflow. */
name|double
name|test
init|=
name|png_pow10
argument_list|(
name|exp_b10
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|<=
name|DBL_MAX
condition|)
operator|++
name|exp_b10
operator|,
name|base
operator|=
name|test
expr_stmt|;
else|else
break|break;
block|}
comment|/* Normalize fp and correct exp_b10, after this fp is in the           * range [.1,1) and exp_b10 is both the exponent and the digit           * *before* which the decimal point should be inserted           * (starting with 0 for the first digit).  Note that this           * works even if 10^exp_b10 is out of range because of the           * test on DBL_MAX above.           */
name|fp
operator|/=
name|base
expr_stmt|;
while|while
condition|(
name|fp
operator|>=
literal|1
condition|)
name|fp
operator|/=
literal|10
operator|,
operator|++
name|exp_b10
expr_stmt|;
comment|/* Because of the code above fp may, at this point, be           * less than .1, this is ok because the code below can           * handle the leading zeros this generates, so no attempt           * is made to correct that here.           */
block|{
name|int
name|czero
decl_stmt|,
name|clead
decl_stmt|,
name|cdigits
decl_stmt|;
name|char
name|exponent
index|[
literal|10
index|]
decl_stmt|;
comment|/* Allow up to two leading zeros - this will not lengthen              * the number compared to using E-n.              */
if|if
condition|(
name|exp_b10
operator|<
literal|0
operator|&&
name|exp_b10
operator|>
operator|-
literal|3
condition|)
comment|/* PLUS 3 TOTAL 4 */
block|{
name|czero
operator|=
operator|-
name|exp_b10
expr_stmt|;
comment|/* PLUS 2 digits: TOTAL 3 */
name|exp_b10
operator|=
literal|0
expr_stmt|;
comment|/* Dot added below before first output. */
block|}
else|else
name|czero
operator|=
literal|0
expr_stmt|;
comment|/* No zeros to add */
comment|/* Generate the digit list, stripping trailing zeros and              * inserting a '.' before a digit if the exponent is 0.              */
name|clead
operator|=
name|czero
expr_stmt|;
comment|/* Count of leading zeros */
name|cdigits
operator|=
literal|0
expr_stmt|;
comment|/* Count of digits in list. */
do|do
block|{
name|double
name|d
decl_stmt|;
name|fp
operator|*=
literal|10.0
expr_stmt|;
comment|/* Use modf here, not floor and subtract, so that                 * the separation is done in one step.  At the end                 * of the loop don't break the number into parts so                 * that the final digit is rounded.                 */
if|if
condition|(
name|cdigits
operator|+
name|czero
operator|-
name|clead
operator|+
literal|1
operator|<
operator|(
name|int
operator|)
name|precision
condition|)
name|fp
operator|=
name|modf
argument_list|(
name|fp
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|=
name|floor
argument_list|(
name|fp
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|9.0
condition|)
block|{
comment|/* Rounding up to 10, handle that here. */
if|if
condition|(
name|czero
operator|>
literal|0
condition|)
block|{
operator|--
name|czero
operator|,
name|d
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdigits
operator|==
literal|0
condition|)
operator|--
name|clead
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|cdigits
operator|>
literal|0
operator|&&
name|d
operator|>
literal|9.0
condition|)
block|{
name|int
name|ch
init|=
operator|*
operator|--
name|ascii
decl_stmt|;
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
operator|++
name|exp_b10
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|46
condition|)
block|{
name|ch
operator|=
operator|*
operator|--
name|ascii
operator|,
operator|++
name|size
expr_stmt|;
comment|/* Advance exp_b10 to '1', so that the                                * decimal point happens after the                                * previous digit.                                */
name|exp_b10
operator|=
literal|1
expr_stmt|;
block|}
operator|--
name|cdigits
expr_stmt|;
name|d
operator|=
name|ch
operator|-
literal|47
expr_stmt|;
comment|/* I.e. 1+(ch-48) */
block|}
comment|/* Did we reach the beginning? If so adjust the                          * exponent but take into account the leading                          * decimal point.                          */
if|if
condition|(
name|d
operator|>
literal|9.0
condition|)
comment|/* cdigits == 0 */
block|{
if|if
condition|(
name|exp_b10
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Leading decimal point (plus zeros?), if                                * we lose the decimal point here it must                                * be reentered below.                                */
name|int
name|ch
init|=
operator|*
operator|--
name|ascii
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|46
condition|)
operator|++
name|size
operator|,
name|exp_b10
operator|=
literal|1
expr_stmt|;
comment|/* Else lost a leading zero, so 'exp_b10' is                                * still ok at (-1)                                */
block|}
else|else
operator|++
name|exp_b10
expr_stmt|;
comment|/* In all cases we output a '1' */
name|d
operator|=
literal|1.0
expr_stmt|;
block|}
block|}
block|}
name|fp
operator|=
literal|0
expr_stmt|;
comment|/* Guarantees termination below. */
block|}
if|if
condition|(
name|d
operator|==
literal|0.0
condition|)
block|{
operator|++
name|czero
expr_stmt|;
if|if
condition|(
name|cdigits
operator|==
literal|0
condition|)
operator|++
name|clead
expr_stmt|;
block|}
else|else
block|{
comment|/* Included embedded zeros in the digit count. */
name|cdigits
operator|+=
name|czero
operator|-
name|clead
expr_stmt|;
name|clead
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|czero
operator|>
literal|0
condition|)
block|{
comment|/* exp_b10 == (-1) means we just output the decimal                       * place - after the DP don't adjust 'exp_b10' any                       * more!                       */
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|exp_b10
operator|==
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|46
operator|,
operator|--
name|size
expr_stmt|;
comment|/* PLUS 1: TOTAL 4 */
operator|--
name|exp_b10
expr_stmt|;
block|}
operator|*
name|ascii
operator|++
operator|=
literal|48
operator|,
operator|--
name|czero
expr_stmt|;
block|}
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|exp_b10
operator|==
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|46
operator|,
operator|--
name|size
expr_stmt|;
comment|/* counted                                                                  above */
operator|--
name|exp_b10
expr_stmt|;
block|}
operator|*
name|ascii
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
operator|(
name|int
operator|)
name|d
argument_list|)
operator|,
operator|++
name|cdigits
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cdigits
operator|+
name|czero
operator|-
name|clead
operator|<
operator|(
name|int
operator|)
name|precision
operator|&&
name|fp
operator|>
name|DBL_MIN
condition|)
do|;
comment|/* The total output count (max) is now 4+precision */
comment|/* Check for an exponent, if we don't need one we are              * done and just need to terminate the string.  At              * this point exp_b10==(-1) is effectively if flag - it got              * to '-1' because of the decrement after outputing              * the decimal point above (the exponent required is              * *not* -1!)              */
if|if
condition|(
name|exp_b10
operator|>=
operator|(
operator|-
literal|1
operator|)
operator|&&
name|exp_b10
operator|<=
literal|2
condition|)
block|{
comment|/* The following only happens if we didn't output the                 * leading zeros above for negative exponent, so this                 * doest add to the digit requirement.  Note that the                 * two zeros here can only be output if the two leading                 * zeros were *not* output, so this doesn't increase                 * the output count.                 */
while|while
condition|(
operator|--
name|exp_b10
operator|>=
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
comment|/* Total buffer requirement (including the '\0') is                 * 5+precision - see check at the start.                 */
return|return;
block|}
comment|/* Here if an exponent is required, adjust size for              * the digits we output but did not count.  The total              * digit output here so far is at most 1+precision - no              * decimal point and no leading or trailing zeros have              * been output.              */
name|size
operator|-=
name|cdigits
expr_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|69
operator|,
operator|--
name|size
expr_stmt|;
comment|/* 'E': PLUS 1 TOTAL 2+precision */
comment|/* The following use of an unsigned temporary avoids ambiguities in              * the signed arithmetic on exp_b10 and permits GCC at least to do              * better optimization.              */
block|{
name|unsigned
name|int
name|uexp_b10
decl_stmt|;
if|if
condition|(
name|exp_b10
operator|<
literal|0
condition|)
block|{
operator|*
name|ascii
operator|++
operator|=
literal|45
operator|,
operator|--
name|size
expr_stmt|;
comment|/* '-': PLUS 1 TOTAL 3+precision */
name|uexp_b10
operator|=
operator|-
name|exp_b10
expr_stmt|;
block|}
else|else
name|uexp_b10
operator|=
name|exp_b10
expr_stmt|;
name|cdigits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|uexp_b10
operator|>
literal|0
condition|)
block|{
name|exponent
index|[
name|cdigits
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
name|uexp_b10
operator|%
literal|10
argument_list|)
expr_stmt|;
name|uexp_b10
operator|/=
literal|10
expr_stmt|;
block|}
block|}
comment|/* Need another size check here for the exponent digits, so              * this need not be considered above.              */
if|if
condition|(
operator|(
name|int
operator|)
name|size
operator|>
name|cdigits
condition|)
block|{
while|while
condition|(
name|cdigits
operator|>
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
name|exponent
index|[
operator|--
name|cdigits
index|]
expr_stmt|;
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|fp
operator|>=
name|DBL_MIN
operator|)
condition|)
block|{
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
comment|/* '0' */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|*
name|ascii
operator|++
operator|=
literal|105
expr_stmt|;
comment|/* 'i' */
operator|*
name|ascii
operator|++
operator|=
literal|110
expr_stmt|;
comment|/* 'n' */
operator|*
name|ascii
operator|++
operator|=
literal|102
expr_stmt|;
comment|/* 'f' */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Here on buffer too small. */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ASCII conversion buffer too small"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* Function to format a fixed point value in ASCII.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_ascii_from_fixed
name|png_ascii_from_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_charp
name|ascii
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|png_fixed_point
name|fp
parameter_list|)
block|{
comment|/* Require space for 10 decimal digits, a decimal point, a minus sign and a     * trailing \0, 13 characters:     */
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
name|png_uint_32
name|num
decl_stmt|;
comment|/* Avoid overflow here on the minimum integer. */
if|if
condition|(
name|fp
operator|<
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|45
operator|,
operator|--
name|size
operator|,
name|num
operator|=
operator|-
name|fp
expr_stmt|;
else|else
name|num
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0x80000000
condition|)
comment|/* else overflowed */
block|{
name|unsigned
name|int
name|ndigits
init|=
literal|0
decl_stmt|,
name|first
init|=
literal|16
comment|/* flag value */
decl_stmt|;
name|char
name|digits
index|[
literal|10
index|]
decl_stmt|;
while|while
condition|(
name|num
condition|)
block|{
comment|/* Split the low digit off num: */
name|unsigned
name|int
name|tmp
init|=
name|num
operator|/
literal|10
decl_stmt|;
name|num
operator|-=
name|tmp
operator|*
literal|10
expr_stmt|;
name|digits
index|[
name|ndigits
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
name|num
argument_list|)
expr_stmt|;
comment|/* Record the first non-zero digit, note that this is a number              * starting at 1, it's not actually the array index.              */
if|if
condition|(
name|first
operator|==
literal|16
operator|&&
name|num
operator|>
literal|0
condition|)
name|first
operator|=
name|ndigits
expr_stmt|;
name|num
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|ndigits
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|ndigits
operator|>
literal|5
condition|)
operator|*
name|ascii
operator|++
operator|=
name|digits
index|[
operator|--
name|ndigits
index|]
expr_stmt|;
comment|/* The remaining digits are fractional digits, ndigits is '5' or              * smaller at this point.  It is certainly not zero.  Check for a              * non-zero fractional digit:              */
if|if
condition|(
name|first
operator|<=
literal|5
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|46
expr_stmt|;
comment|/* decimal point */
comment|/* ndigits may be<5 for small numbers, output leading zeros                 * then ndigits digits to first:                 */
name|i
operator|=
literal|5
expr_stmt|;
while|while
condition|(
name|ndigits
operator|<
name|i
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|48
operator|,
operator|--
name|i
expr_stmt|;
while|while
condition|(
name|ndigits
operator|>=
name|first
condition|)
operator|*
name|ascii
operator|++
operator|=
name|digits
index|[
operator|--
name|ndigits
index|]
expr_stmt|;
comment|/* Don't output the trailing zeros! */
block|}
block|}
else|else
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
comment|/* And null terminate the string: */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Here on buffer too small. */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ASCII conversion buffer too small"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FIXED_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_SCAL */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|PNG_FIXED_POINT_MACRO_SUPPORTED
argument_list|)
end_if
begin_function
name|png_fixed_point
DECL|function|png_fixed
name|png_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|double
name|fp
parameter_list|,
name|png_const_charp
name|text
parameter_list|)
block|{
name|double
name|r
init|=
name|floor
argument_list|(
literal|100000
operator|*
name|fp
operator|+
literal|.5
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|>
literal|2147483647.
operator|||
name|r
operator|<
operator|-
literal|2147483648.
condition|)
name|png_fixed_error
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG__READ_pHYs_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* muldiv functions */
end_comment
begin_comment
comment|/* This API takes signed arguments and rounds the result to the nearest  * integer (or, for a fixed point number - the standard argument - to  * the nearest .00001).  Overflow and divide by zero are signalled in  * the result, a boolean - true on success, false on overflow.  */
end_comment
begin_function
name|int
DECL|function|png_muldiv
name|png_muldiv
parameter_list|(
name|png_fixed_point_p
name|res
parameter_list|,
name|png_fixed_point
name|a
parameter_list|,
name|png_int_32
name|times
parameter_list|,
name|png_int_32
name|divisor
parameter_list|)
block|{
comment|/* Return a * times / divisor, rounded. */
if|if
condition|(
name|divisor
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|times
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|a
decl_stmt|;
name|r
operator|*=
name|times
expr_stmt|;
name|r
operator|/=
name|divisor
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
comment|/* A png_fixed_point is a 32-bit integer. */
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
block|{
operator|*
name|res
operator|=
operator|(
name|png_fixed_point
operator|)
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
else|#
directive|else
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|A
decl_stmt|,
name|T
decl_stmt|,
name|D
decl_stmt|;
name|png_uint_32
name|s16
decl_stmt|,
name|s32
decl_stmt|,
name|s00
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|negative
operator|=
literal|1
operator|,
name|A
operator|=
operator|-
name|a
expr_stmt|;
else|else
name|A
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|times
operator|<
literal|0
condition|)
name|negative
operator|=
operator|!
name|negative
operator|,
name|T
operator|=
operator|-
name|times
expr_stmt|;
else|else
name|T
operator|=
name|times
expr_stmt|;
if|if
condition|(
name|divisor
operator|<
literal|0
condition|)
name|negative
operator|=
operator|!
name|negative
operator|,
name|D
operator|=
operator|-
name|divisor
expr_stmt|;
else|else
name|D
operator|=
name|divisor
expr_stmt|;
comment|/* Following can't overflow because the arguments only           * have 31 bits each, however the result may be 32 bits.           */
name|s16
operator|=
operator|(
name|A
operator|>>
literal|16
operator|)
operator|*
operator|(
name|T
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|A
operator|&
literal|0xffff
operator|)
operator|*
operator|(
name|T
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* Can't overflow because the a*times bit is only 30           * bits at most.           */
name|s32
operator|=
operator|(
name|A
operator|>>
literal|16
operator|)
operator|*
operator|(
name|T
operator|>>
literal|16
operator|)
operator|+
operator|(
name|s16
operator|>>
literal|16
operator|)
expr_stmt|;
name|s00
operator|=
operator|(
name|A
operator|&
literal|0xffff
operator|)
operator|*
operator|(
name|T
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|s16
operator|=
operator|(
name|s16
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
expr_stmt|;
name|s00
operator|+=
name|s16
expr_stmt|;
if|if
condition|(
name|s00
operator|<
name|s16
condition|)
operator|++
name|s32
expr_stmt|;
comment|/* carry */
if|if
condition|(
name|s32
operator|<
name|D
condition|)
comment|/* else overflow */
block|{
comment|/* s32.s00 is now the 64-bit product, do a standard              * division, we know that s32< D, so the maximum              * required shift is 31.              */
name|int
name|bitshift
init|=
literal|32
decl_stmt|;
name|png_fixed_point
name|result
init|=
literal|0
decl_stmt|;
comment|/* NOTE: signed */
while|while
condition|(
operator|--
name|bitshift
operator|>=
literal|0
condition|)
block|{
name|png_uint_32
name|d32
decl_stmt|,
name|d00
decl_stmt|;
if|if
condition|(
name|bitshift
operator|>
literal|0
condition|)
name|d32
operator|=
name|D
operator|>>
operator|(
literal|32
operator|-
name|bitshift
operator|)
operator|,
name|d00
operator|=
name|D
operator|<<
name|bitshift
expr_stmt|;
else|else
name|d32
operator|=
literal|0
operator|,
name|d00
operator|=
name|D
expr_stmt|;
if|if
condition|(
name|s32
operator|>
name|d32
condition|)
block|{
if|if
condition|(
name|s00
operator|<
name|d00
condition|)
operator|--
name|s32
expr_stmt|;
comment|/* carry */
name|s32
operator|-=
name|d32
operator|,
name|s00
operator|-=
name|d00
operator|,
name|result
operator|+=
literal|1
operator|<<
name|bitshift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s32
operator|==
name|d32
operator|&&
name|s00
operator|>=
name|d00
condition|)
name|s32
operator|=
literal|0
operator|,
name|s00
operator|-=
name|d00
operator|,
name|result
operator|+=
literal|1
operator|<<
name|bitshift
expr_stmt|;
block|}
comment|/* Handle the rounding. */
if|if
condition|(
name|s00
operator|>=
operator|(
name|D
operator|>>
literal|1
operator|)
condition|)
operator|++
name|result
expr_stmt|;
if|if
condition|(
name|negative
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
comment|/* Check for overflow. */
if|if
condition|(
operator|(
name|negative
operator|&&
name|result
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|!
name|negative
operator|&&
name|result
operator|>=
literal|0
operator|)
condition|)
block|{
operator|*
name|res
operator|=
name|result
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA || INCH_CONVERSIONS */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* The following is for when the caller doesn't much care about the  * result.  */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_muldiv_warn
name|png_muldiv_warn
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|a
parameter_list|,
name|png_int_32
name|times
parameter_list|,
name|png_int_32
name|divisor
parameter_list|)
block|{
name|png_fixed_point
name|result
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|result
argument_list|,
name|a
argument_list|,
name|times
argument_list|,
name|divisor
argument_list|)
condition|)
return|return
name|result
return|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"fixed point overflow ignored"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* more fixed point functions for gammma */
end_comment
begin_comment
comment|/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_reciprocal
name|png_reciprocal
parameter_list|(
name|png_fixed_point
name|a
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|floor
argument_list|(
literal|1E10
operator|/
name|a
operator|+
literal|.5
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
literal|100000
argument_list|,
literal|100000
argument_list|,
name|a
argument_list|)
condition|)
return|return
name|res
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* error/overflow */
block|}
end_function
begin_comment
comment|/* A local convenience routine. */
end_comment
begin_function
specifier|static
name|png_fixed_point
DECL|function|png_product2
name|png_product2
parameter_list|(
name|png_fixed_point
name|a
parameter_list|,
name|png_fixed_point
name|b
parameter_list|)
block|{
comment|/* The required result is 1/a * 1/b; the following preserves accuracy. */
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|a
operator|*
literal|1E
operator|-
literal|5
decl_stmt|;
name|r
operator|*=
name|b
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
literal|100000
argument_list|)
condition|)
return|return
name|res
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* overflow */
block|}
end_function
begin_comment
comment|/* The inverse of the above. */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_reciprocal2
name|png_reciprocal2
parameter_list|(
name|png_fixed_point
name|a
parameter_list|,
name|png_fixed_point
name|b
parameter_list|)
block|{
comment|/* The required result is 1/a * 1/b; the following preserves accuracy. */
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
literal|1E15
operator|/
name|a
decl_stmt|;
name|r
operator|/=
name|b
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
comment|/* This may overflow because the range of png_fixed_point isn't symmetric,     * but this API is only used for the product of file and screen gamma so it     * doesn't matter that the smallest number it can produce is 1/21474, not     * 1/100000     */
name|png_fixed_point
name|res
init|=
name|png_product2
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|png_reciprocal
argument_list|(
name|res
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* overflow */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CHECK_cHRM_SUPPORTED
end_ifdef
begin_comment
comment|/* Added at libpng version 1.2.34 (Dec 8, 2008) and 1.4.0 (Jan 2,  * 2010: moved from pngset.c) */
end_comment
begin_comment
comment|/*  *    Multiply two 32-bit numbers, V1 and V2, using 32-bit  *    arithmetic, to produce a 64-bit result in the HI/LO words.  *  *                  A B  *                x C D  *               ------  *              AD || BD  *        AC || CB || 0  *  *    where A and B are the high and low 16-bit words of V1,  *    C and D are the 16-bit words of V2, AD is the product of  *    A and D, and X || Y is (X<< 16) + Y. */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_64bit_product
name|png_64bit_product
parameter_list|(
name|long
name|v1
parameter_list|,
name|long
name|v2
parameter_list|,
name|unsigned
name|long
modifier|*
name|hi_product
parameter_list|,
name|unsigned
name|long
modifier|*
name|lo_product
parameter_list|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|long
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|a
operator|=
operator|(
name|v1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|b
operator|=
name|v1
operator|&
literal|0xffff
expr_stmt|;
name|c
operator|=
operator|(
name|v2
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|d
operator|=
name|v2
operator|&
literal|0xffff
expr_stmt|;
name|lo
operator|=
name|b
operator|*
name|d
expr_stmt|;
comment|/* BD */
name|x
operator|=
name|a
operator|*
name|d
operator|+
name|c
operator|*
name|b
expr_stmt|;
comment|/* AD + CB */
name|y
operator|=
operator|(
operator|(
name|lo
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|+
name|x
expr_stmt|;
name|lo
operator|=
operator|(
name|lo
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|y
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|hi
operator|=
operator|(
name|y
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|hi
operator|+=
name|a
operator|*
name|c
expr_stmt|;
comment|/* AC */
operator|*
name|hi_product
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hi
expr_stmt|;
operator|*
name|lo_product
operator|=
operator|(
name|unsigned
name|long
operator|)
name|lo
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CHECK_cHRM */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* gamma table code */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
end_ifndef
begin_comment
comment|/* Fixed point gamma.  *  * To calculate gamma this code implements fast log() and exp() calls using only  * fixed point arithmetic.  This code has sufficient precision for either 8-bit  * or 16-bit sample values.  *  * The tables used here were calculated using simple 'bc' programs, but C double  * precision floating point arithmetic would work fine.  The programs are given  * at the head of each table.  *  * 8-bit log table  *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to  *   255, so it's the base 2 logarithm of a normalized 8-bit floating point  *   mantissa.  The numbers are 32-bit fractions.  */
end_comment
begin_decl_stmt
specifier|static
name|png_uint_32
DECL|variable|png_8bit_l2
name|png_8bit_l2
index|[
literal|128
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|PNG_DO_BC
for|for
control|(
name|i
operator|=
literal|128
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
literal|.5
operator|-
name|l
argument_list|(
name|i
operator|/
literal|255
argument_list|)
operator|/
name|l
argument_list|(
literal|2
argument_list|)
operator|*
literal|65536
operator|*
literal|65536
expr_stmt|;
block|}
else|#
directive|else
literal|4270715492U
operator|,
literal|4222494797U
operator|,
literal|4174646467U
operator|,
literal|4127164793U
operator|,
literal|4080044201U
operator|,
literal|4033279239U
operator|,
literal|3986864580U
operator|,
literal|3940795015U
operator|,
literal|3895065449U
operator|,
literal|3849670902U
operator|,
literal|3804606499U
operator|,
literal|3759867474U
operator|,
literal|3715449162U
operator|,
literal|3671346997U
operator|,
literal|3627556511U
operator|,
literal|3584073329U
operator|,
literal|3540893168U
operator|,
literal|3498011834U
operator|,
literal|3455425220U
operator|,
literal|3413129301U
operator|,
literal|3371120137U
operator|,
literal|3329393864U
operator|,
literal|3287946700U
operator|,
literal|3246774933U
operator|,
literal|3205874930U
operator|,
literal|3165243125U
operator|,
literal|3124876025U
operator|,
literal|3084770202U
operator|,
literal|3044922296U
operator|,
literal|3005329011U
operator|,
literal|2965987113U
operator|,
literal|2926893432U
operator|,
literal|2888044853U
operator|,
literal|2849438323U
operator|,
literal|2811070844U
operator|,
literal|2772939474U
operator|,
literal|2735041326U
operator|,
literal|2697373562U
operator|,
literal|2659933400U
operator|,
literal|2622718104U
operator|,
literal|2585724991U
operator|,
literal|2548951424U
operator|,
literal|2512394810U
operator|,
literal|2476052606U
operator|,
literal|2439922311U
operator|,
literal|2404001468U
operator|,
literal|2368287663U
operator|,
literal|2332778523U
operator|,
literal|2297471715U
operator|,
literal|2262364947U
operator|,
literal|2227455964U
operator|,
literal|2192742551U
operator|,
literal|2158222529U
operator|,
literal|2123893754U
operator|,
literal|2089754119U
operator|,
literal|2055801552U
operator|,
literal|2022034013U
operator|,
literal|1988449497U
operator|,
literal|1955046031U
operator|,
literal|1921821672U
operator|,
literal|1888774511U
operator|,
literal|1855902668U
operator|,
literal|1823204291U
operator|,
literal|1790677560U
operator|,
literal|1758320682U
operator|,
literal|1726131893U
operator|,
literal|1694109454U
operator|,
literal|1662251657U
operator|,
literal|1630556815U
operator|,
literal|1599023271U
operator|,
literal|1567649391U
operator|,
literal|1536433567U
operator|,
literal|1505374214U
operator|,
literal|1474469770U
operator|,
literal|1443718700U
operator|,
literal|1413119487U
operator|,
literal|1382670639U
operator|,
literal|1352370686U
operator|,
literal|1322218179U
operator|,
literal|1292211689U
operator|,
literal|1262349810U
operator|,
literal|1232631153U
operator|,
literal|1203054352U
operator|,
literal|1173618059U
operator|,
literal|1144320946U
operator|,
literal|1115161701U
operator|,
literal|1086139034U
operator|,
literal|1057251672U
operator|,
literal|1028498358U
operator|,
literal|999877854U
operator|,
literal|971388940U
operator|,
literal|943030410U
operator|,
literal|914801076U
operator|,
literal|886699767U
operator|,
literal|858725327U
operator|,
literal|830876614U
operator|,
literal|803152505U
operator|,
literal|775551890U
operator|,
literal|748073672U
operator|,
literal|720716771U
operator|,
literal|693480120U
operator|,
literal|666362667U
operator|,
literal|639363374U
operator|,
literal|612481215U
operator|,
literal|585715177U
operator|,
literal|559064263U
operator|,
literal|532527486U
operator|,
literal|506103872U
operator|,
literal|479792461U
operator|,
literal|453592303U
operator|,
literal|427502463U
operator|,
literal|401522014U
operator|,
literal|375650043U
operator|,
literal|349885648U
operator|,
literal|324227938U
operator|,
literal|298676034U
operator|,
literal|273229066U
operator|,
literal|247886176U
operator|,
literal|222646516U
operator|,
literal|197509248U
operator|,
literal|172473545U
operator|,
literal|147538590U
operator|,
literal|122703574U
operator|,
literal|97967701U
operator|,
literal|73330182U
operator|,
literal|48790236U
operator|,
literal|24347096U
operator|,
literal|0U
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* The following are the values for 16-bit tables - these work fine for the     * 8-bit conversions but produce very slightly larger errors in the 16-bit     * log (about 1.2 as opposed to 0.7 absolute error in the final value).  To     * use these all the shifts below must be adjusted appropriately.     */
block|65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,    57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,    50170, 49542, 48918, 48298, 47682, 47070, 46462, 45858, 45257, 44661, 44068,    43479, 42894, 42312, 41733, 41159, 40587, 40020, 39455, 38894, 38336, 37782,    37230, 36682, 36137, 35595, 35057, 34521, 33988, 33459, 32932, 32408, 31887,    31369, 30854, 30341, 29832, 29325, 28820, 28319, 27820, 27324, 26830, 26339,    25850, 25364, 24880, 24399, 23920, 23444, 22970, 22499, 22029, 21562, 21098,    20636, 20175, 19718, 19262, 18808, 18357, 17908, 17461, 17016, 16573, 16132,    15694, 15257, 14822, 14390, 13959, 13530, 13103, 12678, 12255, 11834, 11415,    10997, 10582, 10168, 9756, 9346, 8937, 8531, 8126, 7723, 7321, 6921, 6523,    6127, 5732, 5339, 4947, 4557, 4169, 3782, 3397, 3014, 2632, 2251, 1872, 1495,    1119, 744, 372
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt
begin_function
name|PNG_STATIC
name|png_int_32
DECL|function|png_log8bit
name|png_log8bit
parameter_list|(
name|unsigned
name|int
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|lg2
init|=
literal|0
decl_stmt|;
comment|/* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,     * because the log is actually negate that means adding 1.  The final     * returned value thus has the range 0 (for 255 input) to 7.994 (for 1     * input), return 7.99998 for the overflow (log 0) case - so the result is     * always at most 19 bits.     */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0xff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0xffffffff
return|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|=
literal|4
operator|,
name|x
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xc0
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|2
operator|,
name|x
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|1
operator|,
name|x
operator|<<=
literal|1
expr_stmt|;
comment|/* result is at most 19 bits, so this cast is safe: */
return|return
call|(
name|png_int_32
call|)
argument_list|(
operator|(
name|lg2
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|png_8bit_l2
index|[
name|x
operator|-
literal|128
index|]
operator|+
literal|32768
operator|)
operator|>>
literal|16
operator|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* The above gives exact (to 16 binary places) log2 values for 8-bit images,  * for 16-bit images we use the most significant 8 bits of the 16-bit value to  * get an approximation then multiply the approximation by a correction factor  * determined by the remaining up to 8 bits.  This requires an additional step  * in the 16-bit case.  *  * We want log2(value/65535), we have log2(v'/255), where:  *  *    value = v' * 256 + v''  *          = v' * f  *  * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128  * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less  * than 258.  The final factor also needs to correct for the fact that our 8-bit  * value is scaled by 255, whereas the 16-bit values must be scaled by 65535.  *  * This gives a final formula using a calculated value 'x' which is value/v' and  * scaling by 65536 to match the above table:  *  *   log2(x/257) * 65536  *  * Since these numbers are so close to '1' we can use simple linear  * interpolation between the two end values 256/257 (result -368.61) and 258/257  * (result 367.179).  The values used below are scaled by a further 64 to give  * 16-bit precision in the interpolation:  *  * Start (256): -23591  * Zero  (257):      0  * End   (258):  23499  */
end_comment
begin_function
name|PNG_STATIC
name|png_int_32
DECL|function|png_log16bit
name|png_log16bit
parameter_list|(
name|png_uint_32
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|lg2
init|=
literal|0
decl_stmt|;
comment|/* As above, but now the input has 16 bits. */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0xffffffff
return|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|=
literal|8
operator|,
name|x
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xf000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|4
operator|,
name|x
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xc000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|2
operator|,
name|x
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|1
operator|,
name|x
operator|<<=
literal|1
expr_stmt|;
comment|/* Calculate the base logarithm from the top 8 bits as a 28-bit fractional     * value.     */
name|lg2
operator|<<=
literal|28
expr_stmt|;
name|lg2
operator|+=
operator|(
name|png_8bit_l2
index|[
operator|(
name|x
operator|>>
literal|8
operator|)
operator|-
literal|128
index|]
operator|+
literal|8
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* Now we need to interpolate the factor, this requires a division by the top     * 8 bits.  Do this with maximum precision.     */
name|x
operator|=
operator|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator|+
operator|(
name|x
operator|>>
literal|9
operator|)
operator|)
operator|/
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,     * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly     * 16 bits to interpolate to get the low bits of the result.  Round the     * answer.  Note that the end point values are scaled by 64 to retain overall     * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust     * the overall scaling by 6-12.  Round at every step.     */
name|x
operator|-=
literal|1U
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|65536U
condition|)
comment|/*<= '257' */
name|lg2
operator|+=
operator|(
operator|(
literal|23591U
operator|*
operator|(
literal|65536U
operator|-
name|x
operator|)
operator|)
operator|+
operator|(
literal|1U
operator|<<
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|)
expr_stmt|;
else|else
name|lg2
operator|-=
operator|(
operator|(
literal|23499U
operator|*
operator|(
name|x
operator|-
literal|65536U
operator|)
operator|)
operator|+
operator|(
literal|1U
operator|<<
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|)
expr_stmt|;
comment|/* Safe, because the result can't have more than 20 bits: */
return|return
call|(
name|png_int_32
call|)
argument_list|(
operator|(
name|lg2
operator|+
literal|2048
operator|)
operator|>>
literal|12
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* The 'exp()' case must invert the above, taking a 20-bit fixed point  * logarithmic value and returning a 16 or 8-bit number as appropriate.  In  * each case only the low 16 bits are relevant - the fraction - since the  * integer bits (the top 4) simply determine a shift.  *  * The worst case is the 16-bit distinction between 65535 and 65534, this  * requires perhaps spurious accuracy in the decoding of the logarithm to  * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance  * of getting this accuracy in practice.  *  * To deal with this the following exp() function works out the exponent of the  * frational part of the logarithm by using an accurate 32-bit value from the  * top four fractional bits then multiplying in the remaining bits.  */
end_comment
begin_decl_stmt
specifier|static
name|png_uint_32
DECL|variable|png_32bit_exp
name|png_32bit_exp
index|[
literal|16
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|PNG_DO_BC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
literal|.5
operator|+
name|e
argument_list|(
operator|-
name|i
operator|/
literal|16
operator|*
name|l
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|*
literal|2
operator|^
literal|32
expr_stmt|;
block|}
else|#
directive|else
comment|/* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
literal|4294967295U
operator|,
literal|4112874773U
operator|,
literal|3938502376U
operator|,
literal|3771522796U
operator|,
literal|3611622603U
operator|,
literal|3458501653U
operator|,
literal|3311872529U
operator|,
literal|3171459999U
operator|,
literal|3037000500U
operator|,
literal|2908241642U
operator|,
literal|2784941738U
operator|,
literal|2666869345U
operator|,
literal|2553802834U
operator|,
literal|2445529972U
operator|,
literal|2341847524U
operator|,
literal|2242560872U
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Adjustment table; provided to explain the numbers in the code below. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_DO_BC
end_ifdef
begin_for
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|print
name|i
decl_stmt|, " ",
argument_list|(
literal|1
operator|-
name|e
argument_list|(
operator|-
operator|(
literal|2
operator|^
name|i
operator|)
operator|/
literal|65536
operator|*
name|l
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
modifier|*
decl_stmt|2
modifier|^
argument_list|(
literal|32
operator|-
name|i
argument_list|)
decl_stmt|, "\n"
block|}
end_for
begin_expr_stmt
literal|11
literal|44937.64284865548751208448
literal|10
literal|45180.98734845585101160448
literal|9
literal|45303.31936980687359311872
literal|8
literal|45364.65110595323018870784
literal|7
literal|45395.35850361789624614912
literal|6
literal|45410.72259715102037508096
literal|5
literal|45418.40724413220722311168
literal|4
literal|45422.25021786898173001728
literal|3
literal|45424.17186732298419044352
literal|2
literal|45425.13273269940811464704
literal|1
literal|45425.61317555035558641664
literal|0
literal|45425.85339951654943850496
endif|#
directive|endif
name|PNG_STATIC
name|png_uint_32
DECL|function|png_exp
name|png_exp
argument_list|(
argument|png_fixed_point x
argument_list|)
block|{
if|if
condition|(
name|x
operator|>
literal|0
operator|&&
name|x
operator|<=
literal|0xfffff
condition|)
comment|/* Else overflow or zero (underflow) */
block|{
comment|/* Obtain a 4-bit approximation */
name|png_uint_32
name|e
init|=
name|png_32bit_exp
index|[
operator|(
name|x
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
decl_stmt|;
comment|/* Incorporate the low 12 bits - these decrease the returned value by        * multiplying by a number less than 1 if the bit is set.  The multiplier        * is determined by the above table and the shift. Notice that the values        * converge on 45426 and this is used to allow linear interpolation of the        * low bits.        */
if|if
condition|(
name|x
operator|&
literal|0x800
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|44938U
operator|)
operator|+
literal|16U
operator|)
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x400
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45181U
operator|)
operator|+
literal|32U
operator|)
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x200
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45303U
operator|)
operator|+
literal|64U
operator|)
operator|>>
literal|7
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x100
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45365U
operator|)
operator|+
literal|128U
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x080
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45395U
operator|)
operator|+
literal|256U
operator|)
operator|>>
literal|9
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x040
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45410U
operator|)
operator|+
literal|512U
operator|)
operator|>>
literal|10
expr_stmt|;
comment|/* And handle the low 6 bits in a single block. */
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|355U
operator|*
operator|(
name|x
operator|&
literal|0x3fU
operator|)
operator|)
operator|+
literal|256U
operator|)
operator|>>
literal|9
expr_stmt|;
comment|/* Handle the upper bits of x. */
name|e
operator|>>=
name|x
operator|>>
literal|16
expr_stmt|;
return|return
name|e
return|;
block|}
end_expr_stmt
begin_comment
comment|/* Check for overflow */
end_comment
begin_if
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
return|return
name|png_32bit_exp
index|[
literal|0
index|]
return|;
end_if
begin_comment
comment|/* Else underflow */
end_comment
begin_return
return|return
literal|0
return|;
end_return
begin_function
unit|}  PNG_STATIC
name|png_byte
DECL|function|png_exp8bit
name|png_exp8bit
parameter_list|(
name|png_fixed_point
name|lg2
parameter_list|)
block|{
comment|/* Get a 32-bit value: */
name|png_uint_32
name|x
init|=
name|png_exp
argument_list|(
name|lg2
argument_list|)
decl_stmt|;
comment|/* Convert the 32-bit value to 0..255 by multiplying by 256-1, note that the     * second, rounding, step can't overflow because of the first, subtraction,     * step.     */
name|x
operator|-=
name|x
operator|>>
literal|8
expr_stmt|;
return|return
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|x
operator|+
literal|0x7fffffU
operator|)
operator|>>
literal|24
argument_list|)
return|;
block|}
end_function
begin_function
name|PNG_STATIC
name|png_uint_16
DECL|function|png_exp16bit
name|png_exp16bit
parameter_list|(
name|png_fixed_point
name|lg2
parameter_list|)
block|{
comment|/* Get a 32-bit value: */
name|png_uint_32
name|x
init|=
name|png_exp
argument_list|(
name|lg2
argument_list|)
decl_stmt|;
comment|/* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
name|x
operator|-=
name|x
operator|>>
literal|16
expr_stmt|;
return|return
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|x
operator|+
literal|32767U
operator|)
operator|>>
literal|16
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_ARITHMETIC */
end_comment
begin_function
name|png_byte
DECL|function|png_gamma_8bit_correct
name|png_gamma_8bit_correct
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|<
literal|255
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|floor
argument_list|(
literal|255
operator|*
name|pow
argument_list|(
name|value
operator|/
literal|255.
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|png_byte
operator|)
name|r
return|;
else|#
directive|else
name|png_int_32
name|lg2
init|=
name|png_log8bit
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|gamma_val
argument_list|,
name|lg2
argument_list|,
name|PNG_FP_1
argument_list|)
condition|)
return|return
name|png_exp8bit
argument_list|(
name|res
argument_list|)
return|;
comment|/* Overflow. */
name|value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|png_byte
operator|)
name|value
return|;
block|}
end_function
begin_function
name|png_uint_16
DECL|function|png_gamma_16bit_correct
name|png_gamma_16bit_correct
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|<
literal|65535
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|floor
argument_list|(
literal|65535
operator|*
name|pow
argument_list|(
name|value
operator|/
literal|65535.
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|png_uint_16
operator|)
name|r
return|;
else|#
directive|else
name|png_int_32
name|lg2
init|=
name|png_log16bit
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|gamma_val
argument_list|,
name|lg2
argument_list|,
name|PNG_FP_1
argument_list|)
condition|)
return|return
name|png_exp16bit
argument_list|(
name|res
argument_list|)
return|;
comment|/* Overflow. */
name|value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|png_uint_16
operator|)
name|value
return|;
block|}
end_function
begin_comment
comment|/* This does the right thing based on the bit_depth field of the  * png_struct, interpreting values as 8-bit or 16-bit.  While the result  * is nominally a 16-bit value if bit depth is 8 then the result is  * 8-bit (as are the arguments.)  */
end_comment
begin_function
name|png_uint_16
comment|/* PRIVATE */
DECL|function|png_gamma_correct
name|png_gamma_correct
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|8
condition|)
return|return
name|png_gamma_8bit_correct
argument_list|(
name|value
argument_list|,
name|gamma_val
argument_list|)
return|;
else|else
return|return
name|png_gamma_16bit_correct
argument_list|(
name|value
argument_list|,
name|gamma_val
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* This is the shared test on whether a gamma value is 'significant' - whether  * it is worth doing gamma correction.  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_gamma_significant
name|png_gamma_significant
parameter_list|(
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
return|return
name|gamma_val
operator|<
name|PNG_FP_1
operator|-
name|PNG_GAMMA_THRESHOLD_FIXED
operator|||
name|gamma_val
operator|>
name|PNG_FP_1
operator|+
name|PNG_GAMMA_THRESHOLD_FIXED
return|;
block|}
end_function
begin_comment
comment|/* Internal function to build a single 16-bit table - the table consists of  * 'num' 256-entry subtables, where 'num' is determined by 'shift' - the amount  * to shift the input values right (or 16-number_of_signifiant_bits).  *  * The caller is responsible for ensuring that the table gets cleaned up on  * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument  * should be somewhere that will be cleaned.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_16bit_table
name|png_build_16bit_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_16pp
modifier|*
name|ptable
parameter_list|,
name|PNG_CONST
name|unsigned
name|int
name|shift
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
comment|/* Various values derived from 'shift': */
name|PNG_CONST
name|unsigned
name|int
name|num
init|=
literal|1U
operator|<<
operator|(
literal|8U
operator|-
name|shift
operator|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
operator|(
literal|16U
operator|-
name|shift
operator|)
operator|)
operator|-
literal|1U
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max_by_2
init|=
literal|1U
operator|<<
operator|(
literal|15U
operator|-
name|shift
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|png_uint_16pp
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_uint_16pp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|num
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16p
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16p
name|sub_table
init|=
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The 'threshold' test is repeated here because it can arise for one of        * the 16-bit tables even if the others don't hit it.        */
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|gamma_val
argument_list|)
condition|)
block|{
comment|/* The old code would overflow at the end and this would cause the           * 'pow' function to return a result>1, resulting in an           * arithmetic error.  This code follows the spec exactly; ig is           * the recovered input sample, it always has 8-16 bits.           *           * We want input * 65535/max, rounded, the arithmetic fits in 32           * bits (unsigned) so long as max<= 32767.           */
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|png_uint_32
name|ig
init|=
operator|(
name|j
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|+
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
comment|/* Inline the 'max' scaling operation: */
name|double
name|d
init|=
name|floor
argument_list|(
literal|65535
operator|*
name|pow
argument_list|(
name|ig
operator|/
operator|(
name|double
operator|)
name|max
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|d
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|shift
condition|)
name|ig
operator|=
operator|(
name|ig
operator|*
literal|65535U
operator|+
name|max_by_2
operator|)
operator|/
name|max
expr_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
name|png_gamma_16bit_correct
argument_list|(
name|ig
argument_list|,
name|gamma_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* We must still build a table, but do it the fast way. */
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|png_uint_32
name|ig
init|=
operator|(
name|j
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|shift
condition|)
name|ig
operator|=
operator|(
name|ig
operator|*
literal|65535U
operator|+
name|max_by_2
operator|)
operator|/
name|max
expr_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|ig
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* NOTE: this function expects the *inverse* of the overall gamma transformation  * required.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_16to8_table
name|png_build_16to8_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_16pp
modifier|*
name|ptable
parameter_list|,
name|PNG_CONST
name|unsigned
name|int
name|shift
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
name|PNG_CONST
name|unsigned
name|int
name|num
init|=
literal|1U
operator|<<
operator|(
literal|8U
operator|-
name|shift
operator|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
operator|(
literal|16U
operator|-
name|shift
operator|)
operator|)
operator|-
literal|1U
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|png_uint_32
name|last
decl_stmt|;
name|png_uint_16pp
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_uint_16pp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|num
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16p
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 'num' is the number of tables and also the number of low bits of the     * input 16-bit value used to select a table.  Each table is itself indexed     * by the high 8 bits of the value.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 'gamma_val' is set to the reciprocal of the value calculated above, so     * pow(out,g) is an *input* value.  'last' is the last input value set.     *     * In the loop 'i' is used to find output values.  Since the output is     * 8-bit there are only 256 possible values.  The tables are set up to     * select the closest possible output value for each input by finding     * the input value at the boundary between each pair of output values     * and filling the table up to that boundary with the lower output     * value.     *     * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit     * values the code below uses a 16-bit value in i; the values start at     * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last     * entries are filled with 255).  Start i at 128 and fill all 'last'     * table entries<= 'max'     */
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|255
condition|;
operator|++
name|i
control|)
comment|/* 8-bit output value */
block|{
comment|/* Find the corresponding maximum input value */
name|png_uint_16
name|out
init|=
call|(
name|png_uint_16
call|)
argument_list|(
name|i
operator|*
literal|257U
argument_list|)
decl_stmt|;
comment|/* 16-bit output value */
comment|/* Find the boundary value in 16 bits: */
name|png_uint_32
name|bound
init|=
name|png_gamma_16bit_correct
argument_list|(
name|out
operator|+
literal|128U
argument_list|,
name|gamma_val
argument_list|)
decl_stmt|;
comment|/* Adjust (round) to (16-shift) bits: */
name|bound
operator|=
operator|(
name|bound
operator|*
name|max
operator|+
literal|32768U
operator|)
operator|/
literal|65535U
operator|+
literal|1U
expr_stmt|;
while|while
condition|(
name|last
operator|<
name|bound
condition|)
block|{
name|table
index|[
name|last
operator|&
operator|(
literal|0xffU
operator|>>
name|shift
operator|)
index|]
index|[
name|last
operator|>>
operator|(
literal|8U
operator|-
name|shift
operator|)
index|]
operator|=
name|out
expr_stmt|;
name|last
operator|++
expr_stmt|;
block|}
block|}
comment|/* And fill in the final entries. */
while|while
condition|(
name|last
operator|<
operator|(
name|num
operator|<<
literal|8
operator|)
condition|)
block|{
name|table
index|[
name|last
operator|&
operator|(
literal|0xff
operator|>>
name|shift
operator|)
index|]
index|[
name|last
operator|>>
operator|(
literal|8U
operator|-
name|shift
operator|)
index|]
operator|=
literal|65535U
expr_stmt|;
name|last
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Build a single 8-bit table: same as the 16-bit case but much simpler (and  * typically much faster).  Note that libpng currently does no sBIT processing  * (apparently contrary to the spec) so a 256-entry table is always generated.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_8bit_table
name|png_build_8bit_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytepp
name|ptable
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|png_bytep
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
argument_list|)
decl_stmt|;
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|gamma_val
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|i
argument_list|,
name|gamma_val
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Used from png_read_destroy and below to release the memory used by the gamma  * tables.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_destroy_gamma_table
name|png_destroy_gamma_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_table
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_table
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_table
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|png_ptr
operator|->
name|gamma_shift
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_table
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_16_table
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_from_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_from_1
operator|=
name|NULL
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_to_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_to_1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_from_1
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|png_ptr
operator|->
name|gamma_shift
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_from_1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_from_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_16_from_1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|gamma_16_to_1
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|istop
init|=
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|png_ptr
operator|->
name|gamma_shift
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|istop
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_to_1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|gamma_16_to_1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|gamma_16_to_1
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
block|}
end_function
begin_comment
comment|/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit  * tables, we don't make a full table if we are reducing to 8-bit in  * the future.  Note also how the gamma_16 tables are segmented so that  * we don't need to allocate> 64K chunks for a full 16-bit table.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_build_gamma_table
name|png_build_gamma_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|bit_depth
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_build_gamma_table"
argument_list|)
expr_stmt|;
comment|/* Remove any existing table; this copes with multiple calls to    * png_read_update_info.  The warning is because building the gamma tables    * multiple times is a performance hit - it's harmless but the ability to call    * png_read_update_info() multiple times is new in 1.5.6 so it seems sensible    * to warn if the app introduces such a hit.    */
if|if
condition|(
name|png_ptr
operator|->
name|gamma_table
operator|!=
name|NULL
operator|||
name|png_ptr
operator|->
name|gamma_16_table
operator|!=
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"gamma table being rebuilt"
argument_list|)
expr_stmt|;
name|png_destroy_gamma_table
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bit_depth
operator|<=
literal|8
condition|)
block|{
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_table
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_COMPOSE
operator||
name|PNG_RGB_TO_GRAY
operator|)
condition|)
block|{
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_to_1
argument_list|,
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_from_1
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|png_ptr
operator|->
name|gamma
comment|/* Probably doing rgb_to_gray */
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
block|}
else|else
block|{
name|png_byte
name|shift
decl_stmt|,
name|sig_bit
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
block|{
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
operator|>
name|sig_bit
condition|)
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
operator|>
name|sig_bit
condition|)
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
expr_stmt|;
block|}
else|else
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|gray
expr_stmt|;
comment|/* 16-bit gamma code uses this equation:       *       *   ov = table[(iv& 0xff)>> gamma_shift][iv>> 8]       *       * Where 'iv' is the input color value and 'ov' is the output value -       * pow(iv, gamma).       *       * Thus the gamma table consists of up to 256 256-entry tables.  The table       * is selected by the (8-gamma_shift) most significant of the low 8 bits of       * the color value then indexed by the upper 8 bits:       *       *   table[low bits][high 8 bits]       *       * So the table 'n' corresponds to all those 'iv' of:       *       *<all high 8-bit values><n<< gamma_shift>..<(n+1<< gamma_shift)-1>       *       */
if|if
condition|(
name|sig_bit
operator|>
literal|0
operator|&&
name|sig_bit
operator|<
literal|16U
condition|)
name|shift
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|16U
operator|-
name|sig_bit
argument_list|)
expr_stmt|;
comment|/* shift == insignificant bits */
else|else
name|shift
operator|=
literal|0
expr_stmt|;
comment|/* keep all 16 bits */
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_16_TO_8
operator||
name|PNG_SCALE_16_TO_8
operator|)
condition|)
block|{
comment|/* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively          * the significant bits in the *input* when the output will          * eventually be 8 bits.  By default it is 11.          */
if|if
condition|(
name|shift
operator|<
operator|(
literal|16U
operator|-
name|PNG_MAX_GAMMA_8
operator|)
condition|)
name|shift
operator|=
operator|(
literal|16U
operator|-
name|PNG_MAX_GAMMA_8
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|>
literal|8U
condition|)
name|shift
operator|=
literal|8U
expr_stmt|;
comment|/* Guarantees at least one table! */
name|png_ptr
operator|->
name|gamma_shift
operator|=
name|shift
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
comment|/* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now       * PNG_COMPOSE).  This effectively smashed the background calculation for       * 16-bit output because the 8-bit table assumes the result will be reduced       * to 8 bits.       */
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_16_TO_8
operator||
name|PNG_SCALE_16_TO_8
operator|)
condition|)
endif|#
directive|endif
name|png_build_16to8_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_table
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_product2
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
else|else
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_table
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_ALPHA_MODE_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_COMPOSE
operator||
name|PNG_RGB_TO_GRAY
operator|)
condition|)
block|{
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_to_1
argument_list|,
name|shift
argument_list|,
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notice that the '16 from 1' table should be full precision, however          * the lookup on this table still uses gamma_shift, so it can't be.          * TODO: fix this.          */
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_from_1
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|png_ptr
operator|->
name|gamma
comment|/* Probably doing rgb_to_gray */
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
end_comment
end_unit
