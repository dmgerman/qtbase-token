begin_unit
begin_comment
comment|/* png.c - location for general purpose libpng functions  *  * Last changed in libpng 1.5.1 [February 3, 2011]  * Copyright (c) 1998-2011 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_comment
comment|/* Generate a compiler error if there is an old png.h in the search path. */
end_comment
begin_typedef
DECL|typedef|Your_png_h_is_not_version_1_5_1
typedef|typedef
name|png_libpng_version_1_5_1
name|Your_png_h_is_not_version_1_5_1
typedef|;
end_typedef
begin_comment
comment|/* Tells libpng that we have already handled the first "num_bytes" bytes  * of the PNG file signature.  If the PNG data is embedded into another  * stream we can set num_bytes = 8 so that libpng will not attempt to read  * or write any of the magic bytes before it starts on the IHDR.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_function
name|void
name|PNGAPI
DECL|function|png_set_sig_bytes
name|png_set_sig_bytes
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|num_bytes
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_set_sig_bytes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|num_bytes
operator|>
literal|8
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Too many bytes for PNG signature"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sig_bytes
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|num_bytes
operator|<
literal|0
condition|?
literal|0
else|:
name|num_bytes
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Checks whether the supplied bytes match the PNG signature.  We allow  * checking less than the full 8-byte signature so that those apps that  * already read the first few bytes of a file to determine the file type  * can simply check the remaining bytes for extra assurance.  Returns  * an integer less than, equal to, or greater than zero if sig is found,  * respectively, to be less than, to match, or be greater than the correct  * PNG signature (this is the same behaviour as strcmp, memcmp, etc).  */
end_comment
begin_function
name|int
name|PNGAPI
DECL|function|png_sig_cmp
name|png_sig_cmp
parameter_list|(
name|png_const_bytep
name|sig
parameter_list|,
name|png_size_t
name|start
parameter_list|,
name|png_size_t
name|num_to_check
parameter_list|)
block|{
name|png_byte
name|png_signature
index|[
literal|8
index|]
init|=
block|{
literal|137
block|,
literal|80
block|,
literal|78
block|,
literal|71
block|,
literal|13
block|,
literal|10
block|,
literal|26
block|,
literal|10
block|}
decl_stmt|;
if|if
condition|(
name|num_to_check
operator|>
literal|8
condition|)
name|num_to_check
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|num_to_check
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|start
operator|>
literal|7
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|start
operator|+
name|num_to_check
operator|>
literal|8
condition|)
name|num_to_check
operator|=
literal|8
operator|-
name|start
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|png_memcmp
argument_list|(
operator|&
name|sig
index|[
name|start
index|]
argument_list|,
operator|&
name|png_signature
index|[
name|start
index|]
argument_list|,
name|num_to_check
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_SUPPORTED */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Function to allocate memory for zlib */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|voidpf
comment|/* PRIVATE */
argument_list|,
argument|png_zalloc
argument_list|,
argument|(voidpf png_ptr, uInt items, uInt size)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_voidp
name|ptr
decl_stmt|;
name|png_structp
name|p
init|=
operator|(
name|png_structp
operator|)
name|png_ptr
decl_stmt|;
name|png_uint_32
name|save_flags
init|=
name|p
operator|->
name|flags
decl_stmt|;
name|png_alloc_size_t
name|num_bytes
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|items
operator|>
name|PNG_UINT_32_MAX
operator|/
name|size
condition|)
block|{
name|png_warning
argument_list|(
name|p
argument_list|,
literal|"Potential overflow in png_zalloc()"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|num_bytes
operator|=
operator|(
name|png_alloc_size_t
operator|)
name|items
operator|*
name|size
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|PNG_FLAG_MALLOC_NULL_MEM_OK
expr_stmt|;
name|ptr
operator|=
operator|(
name|png_voidp
operator|)
name|png_malloc
argument_list|(
operator|(
name|png_structp
operator|)
name|png_ptr
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|save_flags
expr_stmt|;
return|return
operator|(
operator|(
name|voidpf
operator|)
name|ptr
operator|)
return|;
block|}
end_block
begin_comment
comment|/* Function to free memory for zlib */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_zfree
name|png_zfree
parameter_list|(
name|voidpf
name|png_ptr
parameter_list|,
name|voidpf
name|ptr
parameter_list|)
block|{
name|png_free
argument_list|(
operator|(
name|png_structp
operator|)
name|png_ptr
argument_list|,
operator|(
name|png_voidp
operator|)
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Reset the CRC variable to 32 bits of 1's.  Care must be taken  * in case CRC is> 32 bits to leave the top bits 0.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_reset_crc
name|png_reset_crc
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_ptr
operator|->
name|crc
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Calculate the CRC over a section of data.  We can only pass as  * much data to this routine as the largest single buffer size.  We  * also check that this data will actually be used before going to the  * trouble of calculating it.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_calculate_crc
name|png_calculate_crc
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|ptr
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|int
name|need_crc
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|chunk_name
index|[
literal|0
index|]
operator|&
literal|0x20
condition|)
comment|/* ancillary */
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_ANCILLARY_MASK
operator|)
operator|==
operator|(
name|PNG_FLAG_CRC_ANCILLARY_USE
operator||
name|PNG_FLAG_CRC_ANCILLARY_NOWARN
operator|)
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* critical */
block|{
if|if
condition|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_CRC_CRITICAL_IGNORE
condition|)
name|need_crc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|need_crc
condition|)
name|png_ptr
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|png_ptr
operator|->
name|crc
argument_list|,
name|ptr
argument_list|,
operator|(
name|uInt
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Allocate the memory for an info_struct for the application.  We don't  * really need the png_ptr, but it could potentially be useful in the  * future.  This should be used in favour of malloc(png_sizeof(png_info))  * and png_info_init() so that applications that want to use a shared  * libpng don't have to be recompiled if png_info changes size.  */
end_comment
begin_macro
DECL|function|PNG_FUNCTION
name|PNG_FUNCTION
argument_list|(
argument|png_infop
argument_list|,
argument|PNGAPI png_create_info_struct
argument_list|,
argument|(png_structp png_ptr)
argument_list|,
argument|PNG_ALLOCATED
argument_list|)
end_macro
begin_block
block|{
name|png_infop
name|info_ptr
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_create_info_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|info_ptr
operator|=
operator|(
name|png_infop
operator|)
name|png_create_struct_2
argument_list|(
name|PNG_STRUCT_INFO
argument_list|,
name|png_ptr
operator|->
name|malloc_fn
argument_list|,
name|png_ptr
operator|->
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|info_ptr
operator|=
operator|(
name|png_infop
operator|)
name|png_create_struct
argument_list|(
name|PNG_STRUCT_INFO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
name|png_info_init_3
argument_list|(
operator|&
name|info_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|info_ptr
operator|)
return|;
block|}
end_block
begin_comment
comment|/* This function frees the memory associated with a single info struct.  * Normally, one would use either png_destroy_read_struct() or  * png_destroy_write_struct() to free an info struct, but this may be  * useful for some applications.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_destroy_info_struct
name|png_destroy_info_struct
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infopp
name|info_ptr_ptr
parameter_list|)
block|{
name|png_infop
name|info_ptr
init|=
name|NULL
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_destroy_info_struct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|info_ptr_ptr
operator|!=
name|NULL
condition|)
name|info_ptr
operator|=
operator|*
name|info_ptr_ptr
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_info_destroy
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USER_MEM_SUPPORTED
name|png_destroy_struct_2
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|,
name|png_ptr
operator|->
name|free_fn
argument_list|,
name|png_ptr
operator|->
name|mem_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_destroy_struct
argument_list|(
operator|(
name|png_voidp
operator|)
name|info_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|info_ptr_ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Initialize the info structure.  This is now an internal function (0.89)  * and applications using it are urged to use png_create_info_struct()  * instead.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_info_init_3
name|png_info_init_3
parameter_list|(
name|png_infopp
name|ptr_ptr
parameter_list|,
name|png_size_t
name|png_info_struct_size
parameter_list|)
block|{
name|png_infop
name|info_ptr
init|=
operator|*
name|ptr_ptr
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_info_init_3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
operator|>
name|png_info_struct_size
condition|)
block|{
name|png_destroy_struct
argument_list|(
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|=
operator|(
name|png_infop
operator|)
name|png_create_struct
argument_list|(
name|PNG_STRUCT_INFO
argument_list|)
expr_stmt|;
operator|*
name|ptr_ptr
operator|=
name|info_ptr
expr_stmt|;
block|}
comment|/* Set everything to 0 */
name|png_memset
argument_list|(
name|info_ptr
argument_list|,
literal|0
argument_list|,
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_data_freer
name|png_data_freer
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|int
name|freer
parameter_list|,
name|png_uint_32
name|mask
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_data_freer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|freer
operator|==
name|PNG_DESTROY_WILL_FREE_DATA
condition|)
name|info_ptr
operator|->
name|free_me
operator||=
name|mask
expr_stmt|;
elseif|else
if|if
condition|(
name|freer
operator|==
name|PNG_USER_WILL_FREE_DATA
condition|)
name|info_ptr
operator|->
name|free_me
operator|&=
operator|~
name|mask
expr_stmt|;
else|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown freer parameter in png_data_freer"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_free_data
name|png_free_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|,
name|png_uint_32
name|mask
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_free_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|info_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_TEXT_SUPPORTED
comment|/* Free text item num or (if num == -1) all text items */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_TEXT
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|text
operator|&&
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|text
index|[
name|num
index|]
operator|.
name|key
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|num_text
condition|;
name|i
operator|++
control|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_TEXT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|text
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|num_text
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_tRNS_SUPPORTED
comment|/* Free any tRNS entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_TRNS
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|trans_alpha
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|trans_alpha
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_tRNS
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sCAL_SUPPORTED
comment|/* Free any sCAL entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_SCAL
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PNG_FIXED_POINT_SUPPORTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_width
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|scal_s_height
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_width
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|scal_s_height
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_sCAL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_pCAL_SUPPORTED
comment|/* Free any pCAL entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_PCAL
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_purpose
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_units
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_purpose
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|pcal_units
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|pcal_params
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|pcal_nparams
condition|;
name|i
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|pcal_params
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pcal_params
operator|=
name|NULL
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_pCAL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_iCCP_SUPPORTED
comment|/* Free any iCCP entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_ICCP
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_name
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|iccp_profile
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|iccp_name
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|iccp_profile
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_iCCP
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_sPLT_SUPPORTED
comment|/* Free a given sPLT entry, or (if num == -1) all sPLT entries */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_SPLT
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|splt_palettes
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|entries
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
index|[
name|num
index|]
operator|.
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|info_ptr
operator|->
name|splt_palettes_num
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|splt_palettes_num
condition|;
name|i
operator|++
control|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_SPLT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|splt_palettes
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|splt_palettes_num
operator|=
literal|0
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_sPLT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_UNKNOWN_CHUNKS_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|unknown_chunk
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_UNKN
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|num
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
index|[
name|num
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|unknown_chunks_num
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_ptr
operator|->
name|unknown_chunks_num
condition|;
name|i
operator|++
control|)
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_UNKN
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|unknown_chunks
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|unknown_chunks_num
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNG_hIST_SUPPORTED
comment|/* Free any hIST entry */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_HIST
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|hist
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|hist
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_hIST
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Free any PLTE entry that was internally allocated */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_PLTE
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
name|png_zfree
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|palette
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|palette
operator|=
name|NULL
expr_stmt|;
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_PLTE
expr_stmt|;
name|info_ptr
operator|->
name|num_palette
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_INFO_IMAGE_SUPPORTED
comment|/* Free any image bits attached to the info structure */
if|if
condition|(
operator|(
name|mask
operator|&
name|PNG_FREE_ROWS
operator|)
operator|&
name|info_ptr
operator|->
name|free_me
condition|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|row_pointers
condition|)
block|{
name|int
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
operator|(
name|int
operator|)
name|info_ptr
operator|->
name|height
condition|;
name|row
operator|++
control|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
index|[
name|row
index|]
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|row_pointers
index|[
name|row
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
operator|->
name|row_pointers
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|row_pointers
operator|=
name|NULL
expr_stmt|;
block|}
name|info_ptr
operator|->
name|valid
operator|&=
operator|~
name|PNG_INFO_IDAT
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
name|mask
operator|&=
operator|~
name|PNG_FREE_MUL
expr_stmt|;
name|info_ptr
operator|->
name|free_me
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is an internal routine to free any memory that the info struct is  * pointing to before re-using it or freeing the struct itself.  Recall  * that png_free() checks for NULL pointers for us.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_info_destroy
name|png_info_destroy
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_infop
name|info_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_info_destroy"
argument_list|)
expr_stmt|;
name|png_free_data
argument_list|(
name|png_ptr
argument_list|,
name|info_ptr
argument_list|,
name|PNG_FREE_ALL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|num_chunk_list
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|chunk_list
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|num_chunk_list
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|png_info_init_3
argument_list|(
operator|&
name|info_ptr
argument_list|,
name|png_sizeof
argument_list|(
name|png_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
end_comment
begin_comment
comment|/* This function returns a pointer to the io_ptr associated with the user  * functions.  The application should free any memory associated with this  * pointer before png_write_destroy() or png_read_destroy() are called.  */
end_comment
begin_function
name|png_voidp
name|PNGAPI
DECL|function|png_get_io_ptr
name|png_get_io_ptr
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|png_ptr
operator|->
name|io_ptr
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_STDIO_SUPPORTED
end_ifdef
begin_comment
comment|/* Initialize the default input/output functions for the PNG file.  If you  * use your own read or write routines, you can call either png_set_read_fn()  * or png_set_write_fn() instead of png_init_io().  If you have defined  * PNG_NO_STDIO, you must use a function of your own because "FILE *" isn't  * necessarily available.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_init_io
name|png_init_io
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_FILE_p
name|fp
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_init_io"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
name|png_ptr
operator|->
name|io_ptr
operator|=
operator|(
name|png_voidp
operator|)
name|fp
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_TIME_RFC1123_SUPPORTED
end_ifdef
begin_comment
comment|/* Convert the supplied time into an RFC 1123 string suitable for use in  * a "Creation Time" or other text-based time string.  */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_convert_to_rfc1123
name|png_convert_to_rfc1123
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_timep
name|ptime
parameter_list|)
block|{
specifier|static
name|PNG_CONST
name|char
name|short_months
index|[
literal|12
index|]
index|[
literal|4
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|png_ptr
operator|->
name|time_buffer
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|time_buffer
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
literal|29
operator|*
name|png_sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_FAR_KEYWORD
block|{
name|char
name|near_time_buf
index|[
literal|29
index|]
decl_stmt|;
name|png_snprintf6
argument_list|(
name|near_time_buf
argument_list|,
literal|29
argument_list|,
literal|"%d %s %d %02d:%02d:%02d +0000"
argument_list|,
name|ptime
operator|->
name|day
operator|%
literal|32
argument_list|,
name|short_months
index|[
operator|(
name|ptime
operator|->
name|month
operator|-
literal|1
operator|)
operator|%
literal|12
index|]
argument_list|,
name|ptime
operator|->
name|year
argument_list|,
name|ptime
operator|->
name|hour
operator|%
literal|24
argument_list|,
name|ptime
operator|->
name|minute
operator|%
literal|60
argument_list|,
name|ptime
operator|->
name|second
operator|%
literal|61
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|png_ptr
operator|->
name|time_buffer
argument_list|,
name|near_time_buf
argument_list|,
literal|29
operator|*
name|png_sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|png_snprintf6
argument_list|(
name|png_ptr
operator|->
name|time_buffer
argument_list|,
literal|29
argument_list|,
literal|"%d %s %d %02d:%02d:%02d +0000"
argument_list|,
name|ptime
operator|->
name|day
operator|%
literal|32
argument_list|,
name|short_months
index|[
operator|(
name|ptime
operator|->
name|month
operator|-
literal|1
operator|)
operator|%
literal|12
index|]
argument_list|,
name|ptime
operator|->
name|year
argument_list|,
name|ptime
operator|->
name|hour
operator|%
literal|24
argument_list|,
name|ptime
operator|->
name|minute
operator|%
literal|60
argument_list|,
name|ptime
operator|->
name|second
operator|%
literal|61
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|png_ptr
operator|->
name|time_buffer
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_TIME_RFC1123_SUPPORTED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_copyright
name|png_get_copyright
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
ifdef|#
directive|ifdef
name|PNG_STRING_COPYRIGHT
return|return
name|PNG_STRING_COPYRIGHT
else|#
directive|else
ifdef|#
directive|ifdef
name|__STDC__
return|return
name|PNG_STRING_NEWLINE
expr|\
literal|"libpng version 1.5.1 - February 3, 2011"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1998-2011 Glenn Randers-Pehrson"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1996-1997 Andreas Dilger"
name|PNG_STRING_NEWLINE
expr|\
literal|"Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc."
expr|\
name|PNG_STRING_NEWLINE
return|;
else|#
directive|else
return|return
literal|"libpng version 1.5.1 - February 3, 2011\       Copyright (c) 1998-2011 Glenn Randers-Pehrson\       Copyright (c) 1996-1997 Andreas Dilger\       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc."
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* The following return the library version as a short string in the  * format 1.0.0 through 99.99.99zz.  To get the version of *.h files  * used with your application, print out PNG_LIBPNG_VER_STRING, which  * is defined in png.h.  * Note: now there is no difference between png_get_libpng_ver() and  * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,  * it is guaranteed that png.c uses the correct version of png.h.  */
end_comment
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_libpng_ver
name|png_get_libpng_ver
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Version of *.c files used when building libpng */
return|return
name|png_get_header_ver
argument_list|(
name|png_ptr
argument_list|)
return|;
block|}
end_function
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_header_ver
name|png_get_header_ver
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Version of *.h files used when building libpng */
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
return|return
name|PNG_LIBPNG_VER_STRING
return|;
block|}
end_function
begin_function
name|png_const_charp
name|PNGAPI
DECL|function|png_get_header_version
name|png_get_header_version
parameter_list|(
name|png_const_structp
name|png_ptr
parameter_list|)
block|{
comment|/* Returns longer string containing both version and date */
name|PNG_UNUSED
argument_list|(
argument|png_ptr
argument_list|)
comment|/* Silence compiler warning about unused png_ptr */
ifdef|#
directive|ifdef
name|__STDC__
return|return
name|PNG_HEADER_VERSION_STRING
ifndef|#
directive|ifndef
name|PNG_READ_SUPPORTED
literal|"     (NO READ SUPPORT)"
endif|#
directive|endif
name|PNG_STRING_NEWLINE
return|;
else|#
directive|else
return|return
name|PNG_HEADER_VERSION_STRING
return|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_HANDLE_AS_UNKNOWN_SUPPORTED
end_ifdef
begin_function
name|int
name|PNGAPI
DECL|function|png_handle_as_unknown
name|png_handle_as_unknown
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_name
parameter_list|)
block|{
comment|/* Check chunk_name and return "keep" value if it's on the list, else 0 */
name|int
name|i
decl_stmt|;
name|png_bytep
name|p
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
operator|||
name|chunk_name
operator|==
name|NULL
operator|||
name|png_ptr
operator|->
name|num_chunk_list
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|png_ptr
operator|->
name|chunk_list
operator|+
name|png_ptr
operator|->
name|num_chunk_list
operator|*
literal|5
operator|-
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
name|png_ptr
operator|->
name|num_chunk_list
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|p
operator|-=
literal|5
control|)
if|if
condition|(
operator|!
name|png_memcmp
argument_list|(
name|chunk_name
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|p
operator|+
literal|4
operator|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_SUPPORTED
end_ifdef
begin_comment
comment|/* This function, added to libpng-1.0.6g, is untested. */
end_comment
begin_function
name|int
name|PNGAPI
DECL|function|png_reset_zstream
name|png_reset_zstream
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
return|return
operator|(
name|inflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_READ_SUPPORTED */
end_comment
begin_comment
comment|/* This function was added to libpng-1.0.7 */
end_comment
begin_function
name|png_uint_32
name|PNGAPI
DECL|function|png_access_version_number
name|png_access_version_number
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Version of *.c files used when building libpng */
return|return
operator|(
operator|(
name|png_uint_32
operator|)
name|PNG_LIBPNG_VER
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_SUPPORTED
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SIZE_T
end_ifdef
begin_comment
comment|/* Added at libpng version 1.2.6 */
end_comment
begin_decl_stmt
name|PNG_EXTERN
name|png_size_t
name|PNGAPI
name|png_convert_size
name|PNGARG
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
name|png_size_t
name|PNGAPI
DECL|function|png_convert_size
name|png_convert_size
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
operator|(
name|png_size_t
operator|)
operator|-
literal|1
condition|)
name|PNG_ABORT
argument_list|()
expr_stmt|;
comment|/* We haven't got access to png_ptr, so no png_error() */
return|return
operator|(
operator|(
name|png_size_t
operator|)
name|size
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_SIZE_T */
end_comment
begin_comment
comment|/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CHECK_cHRM_SUPPORTED
end_ifdef
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_check_cHRM_fixed
name|png_check_cHRM_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|white_x
parameter_list|,
name|png_fixed_point
name|white_y
parameter_list|,
name|png_fixed_point
name|red_x
parameter_list|,
name|png_fixed_point
name|red_y
parameter_list|,
name|png_fixed_point
name|green_x
parameter_list|,
name|png_fixed_point
name|green_y
parameter_list|,
name|png_fixed_point
name|blue_x
parameter_list|,
name|png_fixed_point
name|blue_y
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|xy_hi
decl_stmt|,
name|xy_lo
decl_stmt|,
name|yx_hi
decl_stmt|,
name|yx_lo
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in function png_check_cHRM_fixed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|white_x
operator|<
literal|0
operator|||
name|white_y
operator|<=
literal|0
operator|||
name|red_x
operator|<
literal|0
operator|||
name|red_y
operator|<
literal|0
operator|||
name|green_x
operator|<
literal|0
operator|||
name|green_y
operator|<
literal|0
operator|||
name|blue_x
operator|<
literal|0
operator|||
name|blue_y
operator|<
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to set negative chromaticity value"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|white_x
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
operator|||
name|white_y
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
operator|||
name|red_x
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
operator|||
name|red_y
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
operator|||
name|green_x
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
operator|||
name|green_y
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
operator|||
name|blue_x
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
operator|||
name|blue_y
operator|>
operator|(
name|png_fixed_point
operator|)
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to set chromaticity value exceeding 21474.83"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|white_x
operator|>
literal|100000L
operator|-
name|white_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM white point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|red_x
operator|>
literal|100000L
operator|-
name|red_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM red point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|green_x
operator|>
literal|100000L
operator|-
name|green_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM green point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|blue_x
operator|>
literal|100000L
operator|-
name|blue_y
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid cHRM blue point"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|png_64bit_product
argument_list|(
name|green_x
operator|-
name|red_x
argument_list|,
name|blue_y
operator|-
name|red_y
argument_list|,
operator|&
name|xy_hi
argument_list|,
operator|&
name|xy_lo
argument_list|)
expr_stmt|;
name|png_64bit_product
argument_list|(
name|green_y
operator|-
name|red_y
argument_list|,
name|blue_x
operator|-
name|red_x
argument_list|,
operator|&
name|yx_hi
argument_list|,
operator|&
name|yx_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|xy_hi
operator|==
name|yx_hi
operator|&&
name|xy_lo
operator|==
name|yx_lo
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to set cHRM RGB triangle with zero area"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_CHECK_cHRM_SUPPORTED */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_check_IHDR
name|png_check_IHDR
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|width
parameter_list|,
name|png_uint_32
name|height
parameter_list|,
name|int
name|bit_depth
parameter_list|,
name|int
name|color_type
parameter_list|,
name|int
name|interlace_type
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|int
name|filter_type
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check for width and height valid values */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image width is zero in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image height is zero in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|width
operator|>
name|png_ptr
operator|->
name|user_width_max
operator|||
name|width
operator|>
name|PNG_USER_WIDTH_MAX
condition|)
else|#
directive|else
if|if
condition|(
name|width
operator|>
name|PNG_USER_WIDTH_MAX
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image width exceeds user limit in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_SET_USER_LIMITS_SUPPORTED
if|if
condition|(
name|height
operator|>
name|png_ptr
operator|->
name|user_height_max
operator|||
name|height
operator|>
name|PNG_USER_HEIGHT_MAX
condition|)
else|#
directive|else
if|if
condition|(
name|height
operator|>
name|PNG_USER_HEIGHT_MAX
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Image height exceeds user limit in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image width in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|>
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image height in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
operator|(
name|PNG_UINT_32_MAX
operator|>>
literal|3
operator|)
comment|/* 8-byte RGBA pixels */
operator|-
literal|48
comment|/* bigrowbuf hack */
operator|-
literal|1
comment|/* filter byte */
operator|-
literal|7
operator|*
literal|8
comment|/* rounding of width to multiple of 8 pixels */
operator|-
literal|8
condition|)
comment|/* extra max_pixel_depth pad */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Width is too large for libpng to process pixels"
argument_list|)
expr_stmt|;
comment|/* Check other values */
if|if
condition|(
name|bit_depth
operator|!=
literal|1
operator|&&
name|bit_depth
operator|!=
literal|2
operator|&&
name|bit_depth
operator|!=
literal|4
operator|&&
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|color_type
operator|<
literal|0
operator|||
name|color_type
operator|==
literal|1
operator|||
name|color_type
operator|==
literal|5
operator|||
name|color_type
operator|>
literal|6
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid color type in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|)
operator|&&
name|bit_depth
operator|>
literal|8
operator|)
operator|||
operator|(
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|&&
name|bit_depth
operator|<
literal|8
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid color type/bit depth combination in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|interlace_type
operator|>=
name|PNG_INTERLACE_LAST
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown interlace method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|compression_type
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown compression method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
comment|/* Accept filter_method 64 (intrapixel differencing) only if     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and     * 2. Libpng did not read a PNG signature (this filter_method is only     *    used in PNG datastreams that are embedded in MNG datastreams) and     * 3. The application called png_permit_mng_features with a mask that     *    included PNG_FLAG_MNG_FILTER_64 and     * 4. The filter_method is 64 and     * 5. The color_type is RGB or RGBA     */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|&&
name|png_ptr
operator|->
name|mng_features_permitted
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"MNG features are not allowed in a PNG datastream"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|&&
operator|(
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown filter method in IHDR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|1
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid IHDR data"
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_sCAL_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_pCAL_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* ASCII to fp functions */
end_comment
begin_comment
comment|/* Check an ASCII formated floating point value, see the more detailed  * comments in pngpriv.h  */
end_comment
begin_comment
comment|/* The following is used internally to preserve the 'valid' flag */
end_comment
begin_define
DECL|macro|png_fp_add
define|#
directive|define
name|png_fp_add
parameter_list|(
name|state
parameter_list|,
name|flags
parameter_list|)
value|((state) |= (flags))
end_define
begin_define
DECL|macro|png_fp_set
define|#
directive|define
name|png_fp_set
parameter_list|(
name|state
parameter_list|,
name|value
parameter_list|)
define|\
value|((state) = (value) | ((state)& PNG_FP_WAS_VALID))
end_define
begin_comment
comment|/* Internal type codes: bits above the base state! */
end_comment
begin_define
DECL|macro|PNG_FP_SIGN
define|#
directive|define
name|PNG_FP_SIGN
value|0
end_define
begin_comment
DECL|macro|PNG_FP_SIGN
comment|/* [+-] */
end_comment
begin_define
DECL|macro|PNG_FP_DOT
define|#
directive|define
name|PNG_FP_DOT
value|4
end_define
begin_comment
DECL|macro|PNG_FP_DOT
comment|/* . */
end_comment
begin_define
DECL|macro|PNG_FP_DIGIT
define|#
directive|define
name|PNG_FP_DIGIT
value|8
end_define
begin_comment
DECL|macro|PNG_FP_DIGIT
comment|/* [0123456789] */
end_comment
begin_define
DECL|macro|PNG_FP_E
define|#
directive|define
name|PNG_FP_E
value|12
end_define
begin_comment
DECL|macro|PNG_FP_E
comment|/* [Ee] */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_check_fp_number
name|png_check_fp_number
parameter_list|(
name|png_const_charp
name|string
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|int
modifier|*
name|statep
parameter_list|,
name|png_size_tp
name|whereami
parameter_list|)
block|{
name|int
name|state
init|=
operator|*
name|statep
decl_stmt|;
name|png_size_t
name|i
init|=
operator|*
name|whereami
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|int
name|type
decl_stmt|;
comment|/* First find the type of the next character */
block|{
name|char
name|ch
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|48
operator|&&
name|ch
operator|<=
literal|57
condition|)
name|type
operator|=
name|PNG_FP_DIGIT
expr_stmt|;
else|else
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|43
case|:
case|case
literal|45
case|:
name|type
operator|=
name|PNG_FP_SIGN
expr_stmt|;
break|break;
case|case
literal|46
case|:
name|type
operator|=
name|PNG_FP_DOT
expr_stmt|;
break|break;
case|case
literal|69
case|:
case|case
literal|101
case|:
name|type
operator|=
name|PNG_FP_E
expr_stmt|;
break|break;
default|default:
goto|goto
name|PNG_FP_End
goto|;
block|}
block|}
comment|/* Now deal with this type according to the current        * state, the type is arranged to not overlap the        * bits of the PNG_FP_STATE.        */
switch|switch
condition|(
operator|(
name|state
operator|&
name|PNG_FP_STATE
operator|)
operator|+
name|type
condition|)
block|{
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_SIGN
case|:
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_ANY
condition|)
goto|goto
name|PNG_FP_End
goto|;
comment|/* not a part of the number */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_SIGN
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_DOT
case|:
comment|/* Ok as trailer, ok as lead of fraction. */
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_DOT
condition|)
comment|/* two dots */
goto|goto
name|PNG_FP_End
goto|;
elseif|else
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
condition|)
comment|/* trailing dot? */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_DOT
argument_list|)
expr_stmt|;
else|else
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_FRACTION
operator||
name|PNG_FP_SAW_DOT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_DIGIT
case|:
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_DOT
condition|)
comment|/* delayed fraction */
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_FRACTION
operator||
name|PNG_FP_SAW_DOT
argument_list|)
expr_stmt|;
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_DIGIT
operator|+
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_INTEGER
operator|+
name|PNG_FP_E
case|:
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_EXPONENT
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_FRACTION + PNG_FP_SIGN:          goto PNG_FP_End; ** no sign in exponent */
comment|/* case PNG_FP_FRACTION + PNG_FP_DOT:          goto PNG_FP_End; ** Because SAW_DOT is always set */
case|case
name|PNG_FP_FRACTION
operator|+
name|PNG_FP_DIGIT
case|:
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_DIGIT
operator|+
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_FRACTION
operator|+
name|PNG_FP_E
case|:
comment|/* This is correct because the trailing '.' on an           * integer is handled above - so we can only get here           * with the sequence ".E" (with no preceding digits).           */
if|if
condition|(
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|PNG_FP_End
goto|;
name|png_fp_set
argument_list|(
name|state
argument_list|,
name|PNG_FP_EXPONENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_FP_EXPONENT
operator|+
name|PNG_FP_SIGN
case|:
if|if
condition|(
name|state
operator|&
name|PNG_FP_SAW_ANY
condition|)
goto|goto
name|PNG_FP_End
goto|;
comment|/* not a part of the number */
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_SIGN
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_EXPONENT + PNG_FP_DOT:          goto PNG_FP_End; */
case|case
name|PNG_FP_EXPONENT
operator|+
name|PNG_FP_DIGIT
case|:
name|png_fp_add
argument_list|(
name|state
argument_list|,
name|PNG_FP_SAW_DIGIT
operator|+
name|PNG_FP_WAS_VALID
argument_list|)
expr_stmt|;
break|break;
comment|/* case PNG_FP_EXPONEXT + PNG_FP_E:          goto PNG_FP_End; */
default|default:
goto|goto
name|PNG_FP_End
goto|;
comment|/* I.e. break 2 */
block|}
comment|/* The character seems ok, continue. */
operator|++
name|i
expr_stmt|;
block|}
name|PNG_FP_End
label|:
comment|/* Here at the end, update the state and return the correct     * return code.     */
operator|*
name|statep
operator|=
name|state
expr_stmt|;
operator|*
name|whereami
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|state
operator|&
name|PNG_FP_SAW_DIGIT
operator|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/* The same but for a complete string. */
end_comment
begin_function
name|int
DECL|function|png_check_fp_string
name|png_check_fp_string
parameter_list|(
name|png_const_charp
name|string
parameter_list|,
name|png_size_t
name|size
parameter_list|)
block|{
name|int
name|state
init|=
literal|0
decl_stmt|;
name|png_size_t
name|char_index
init|=
literal|0
decl_stmt|;
return|return
name|png_check_fp_number
argument_list|(
name|string
argument_list|,
name|size
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|char_index
argument_list|)
operator|&&
operator|(
name|char_index
operator|==
name|size
operator|||
name|string
index|[
name|char_index
index|]
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* pCAL or sCAL */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_sCAL_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FLOATING_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* Utility used below - a simple accurate power of ten from an integral  * exponent.  */
end_comment
begin_function
specifier|static
name|double
DECL|function|png_pow10
name|png_pow10
parameter_list|(
name|int
name|power
parameter_list|)
block|{
name|int
name|recip
init|=
literal|0
decl_stmt|;
name|double
name|d
init|=
literal|1
decl_stmt|;
comment|/* Handle negative exponent with a reciprocal at the end because     * 10 is exact whereas .1 is inexact in base 2     */
if|if
condition|(
name|power
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|power
operator|<
name|DBL_MIN_10_EXP
condition|)
return|return
literal|0
return|;
name|recip
operator|=
literal|1
operator|,
name|power
operator|=
operator|-
name|power
expr_stmt|;
block|}
if|if
condition|(
name|power
operator|>
literal|0
condition|)
block|{
comment|/* Decompose power bitwise. */
name|double
name|mult
init|=
literal|10
decl_stmt|;
do|do
block|{
if|if
condition|(
name|power
operator|&
literal|1
condition|)
name|d
operator|*=
name|mult
expr_stmt|;
name|mult
operator|*=
name|mult
expr_stmt|;
name|power
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|power
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|recip
condition|)
name|d
operator|=
literal|1
operator|/
name|d
expr_stmt|;
block|}
comment|/* else power is 0 and d is 1 */
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/* Function to format a floating point value in ASCII with a given  * precision.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_ascii_from_fp
name|png_ascii_from_fp
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_charp
name|ascii
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|double
name|fp
parameter_list|,
name|unsigned
name|int
name|precision
parameter_list|)
block|{
comment|/* We use standard functions from math.h, but not printf because     * that would require stdio.  The caller must supply a buffer of     * sufficient size or we will png_error.  The tests on size and     * the space in ascii[] consumed are indicated below.     */
if|if
condition|(
name|precision
operator|<
literal|1
condition|)
name|precision
operator|=
name|DBL_DIG
expr_stmt|;
comment|/* Enforce the limit of the implementation precision too. */
if|if
condition|(
name|precision
operator|>
name|DBL_DIG
operator|+
literal|1
condition|)
name|precision
operator|=
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
comment|/* Basic sanity checks */
if|if
condition|(
name|size
operator|>=
name|precision
operator|+
literal|5
condition|)
comment|/* See the requirements below. */
block|{
if|if
condition|(
name|fp
operator|<
literal|0
condition|)
block|{
name|fp
operator|=
operator|-
name|fp
expr_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|45
expr_stmt|;
comment|/* '-'  PLUS 1 TOTAL 1*/
operator|--
name|size
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|>=
name|DBL_MIN
operator|&&
name|fp
operator|<=
name|DBL_MAX
condition|)
block|{
name|int
name|exp_b10
decl_stmt|;
comment|/* A base 10 exponent */
name|double
name|base
decl_stmt|;
comment|/* 10^exp_b10 */
comment|/* First extract a base 10 exponent of the number,           * the calculation below rounds down when converting           * from base 2 to base 10 (multiply by log10(2) -           * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to           * be increased.  Note that the arithmetic shift           * performs a floor() unlike C arithmetic - using a           * C multiply would break the following for negative           * exponents.           */
operator|(
name|void
operator|)
name|frexp
argument_list|(
name|fp
argument_list|,
operator|&
name|exp_b10
argument_list|)
expr_stmt|;
comment|/* exponent to base 2 */
name|exp_b10
operator|=
operator|(
name|exp_b10
operator|*
literal|77
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/*<= exponent to base 10 */
comment|/* Avoid underflow here. */
name|base
operator|=
name|png_pow10
argument_list|(
name|exp_b10
argument_list|)
expr_stmt|;
comment|/* May underflow */
while|while
condition|(
name|base
operator|<
name|DBL_MIN
operator|||
name|base
operator|<
name|fp
condition|)
block|{
comment|/* And this may overflow. */
name|double
name|test
init|=
name|png_pow10
argument_list|(
name|exp_b10
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|<=
name|DBL_MAX
condition|)
operator|++
name|exp_b10
operator|,
name|base
operator|=
name|test
expr_stmt|;
else|else
break|break;
block|}
comment|/* Normalize fp and correct exp_b10, after this fp is in the           * range [.1,1) and exp_b10 is both the exponent and the digit           * *before* which the decimal point should be inserted           * (starting with 0 for the first digit).  Note that this           * works even if 10^exp_b10 is out of range because of the           * test on DBL_MAX above.           */
name|fp
operator|/=
name|base
expr_stmt|;
while|while
condition|(
name|fp
operator|>=
literal|1
condition|)
name|fp
operator|/=
literal|10
operator|,
operator|++
name|exp_b10
expr_stmt|;
comment|/* Because of the code above fp may, at this point, be           * less than .1, this is ok because the code below can           * handle the leading zeros this generates, so no attempt           * is made to correct that here.           */
block|{
name|int
name|czero
decl_stmt|,
name|clead
decl_stmt|,
name|cdigits
decl_stmt|;
name|char
name|exponent
index|[
literal|10
index|]
decl_stmt|;
comment|/* Allow up to two leading zeros - this will not lengthen              * the number compared to using E-n.              */
if|if
condition|(
name|exp_b10
operator|<
literal|0
operator|&&
name|exp_b10
operator|>
operator|-
literal|3
condition|)
comment|/* PLUS 3 TOTAL 4 */
block|{
name|czero
operator|=
operator|-
name|exp_b10
expr_stmt|;
comment|/* PLUS 2 digits: TOTAL 3 */
name|exp_b10
operator|=
literal|0
expr_stmt|;
comment|/* Dot added below before first output. */
block|}
else|else
name|czero
operator|=
literal|0
expr_stmt|;
comment|/* No zeros to add */
comment|/* Generate the digit list, stripping trailing zeros and              * inserting a '.' before a digit if the exponent is 0.              */
name|clead
operator|=
name|czero
expr_stmt|;
comment|/* Count of leading zeros */
name|cdigits
operator|=
literal|0
expr_stmt|;
comment|/* Count of digits in list. */
do|do
block|{
name|double
name|d
decl_stmt|;
name|fp
operator|*=
literal|10
expr_stmt|;
comment|/* Use modf here, not floor and subtract, so that                 * the separation is done in one step.  At the end                 * of the loop don't break the number into parts so                 * that the final digit is rounded.                 */
if|if
condition|(
name|cdigits
operator|+
name|czero
operator|-
name|clead
operator|+
literal|1
operator|<
operator|(
name|int
operator|)
name|precision
condition|)
name|fp
operator|=
name|modf
argument_list|(
name|fp
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|=
name|floor
argument_list|(
name|fp
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|9
condition|)
block|{
comment|/* Rounding up to 10, handle that here. */
if|if
condition|(
name|czero
operator|>
literal|0
condition|)
block|{
operator|--
name|czero
operator|,
name|d
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cdigits
operator|==
literal|0
condition|)
operator|--
name|clead
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|cdigits
operator|>
literal|0
operator|&&
name|d
operator|>
literal|9
condition|)
block|{
name|int
name|ch
init|=
operator|*
operator|--
name|ascii
decl_stmt|;
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
operator|++
name|exp_b10
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|46
condition|)
block|{
name|ch
operator|=
operator|*
operator|--
name|ascii
operator|,
operator|++
name|size
expr_stmt|;
comment|/* Advance exp_b10 to '1', so that the                                * decimal point happens after the                                * previous digit.                                */
name|exp_b10
operator|=
literal|1
expr_stmt|;
block|}
operator|--
name|cdigits
expr_stmt|;
name|d
operator|=
name|ch
operator|-
literal|47
expr_stmt|;
comment|/* I.e. 1+(ch-48) */
block|}
comment|/* Did we reach the beginning? If so adjust the                          * exponent but take into account the leading                          * decimal point.                          */
if|if
condition|(
name|d
operator|>
literal|9
condition|)
comment|/* cdigits == 0 */
block|{
if|if
condition|(
name|exp_b10
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Leading decimal point (plus zeros?), if                                * we lose the decimal point here it must                                * be reentered below.                                */
name|int
name|ch
init|=
operator|*
operator|--
name|ascii
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|46
condition|)
operator|++
name|size
operator|,
name|exp_b10
operator|=
literal|1
expr_stmt|;
comment|/* Else lost a leading zero, so 'exp_b10' is                                * still ok at (-1)                                */
block|}
else|else
operator|++
name|exp_b10
expr_stmt|;
comment|/* In all cases we output a '1' */
name|d
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|fp
operator|=
literal|0
expr_stmt|;
comment|/* Guarantees termination below. */
block|}
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
operator|++
name|czero
expr_stmt|;
if|if
condition|(
name|cdigits
operator|==
literal|0
condition|)
operator|++
name|clead
expr_stmt|;
block|}
else|else
block|{
comment|/* Included embedded zeros in the digit count. */
name|cdigits
operator|+=
name|czero
operator|-
name|clead
expr_stmt|;
name|clead
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|czero
operator|>
literal|0
condition|)
block|{
comment|/* exp_b10 == (-1) means we just output the decimal                       * place - after the DP don't adjust 'exp_b10' any                       * more!                       */
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|exp_b10
operator|==
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|46
operator|,
operator|--
name|size
expr_stmt|;
comment|/* PLUS 1: TOTAL 4 */
operator|--
name|exp_b10
expr_stmt|;
block|}
operator|*
name|ascii
operator|++
operator|=
literal|48
operator|,
operator|--
name|czero
expr_stmt|;
block|}
if|if
condition|(
name|exp_b10
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|exp_b10
operator|==
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|46
operator|,
operator|--
name|size
expr_stmt|;
comment|/* counted                                                                  above */
operator|--
name|exp_b10
expr_stmt|;
block|}
operator|*
name|ascii
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
operator|(
name|int
operator|)
name|d
argument_list|)
operator|,
operator|++
name|cdigits
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cdigits
operator|+
name|czero
operator|-
name|clead
operator|<
operator|(
name|int
operator|)
name|precision
operator|&&
name|fp
operator|>
name|DBL_MIN
condition|)
do|;
comment|/* The total output count (max) is now 4+precision */
comment|/* Check for an exponent, if we don't need one we are              * done and just need to terminate the string.  At              * this point exp_b10==(-1) is effectively if flag - it got              * to '-1' because of the decrement after outputing              * the decimal point above (the exponent required is              * *not* -1!)              */
if|if
condition|(
name|exp_b10
operator|>=
operator|(
operator|-
literal|1
operator|)
operator|&&
name|exp_b10
operator|<=
literal|2
condition|)
block|{
comment|/* The following only happens if we didn't output the                 * leading zeros above for negative exponent, so this                 * doest add to the digit requirement.  Note that the                 * two zeros here can only be output if the two leading                 * zeros were *not* output, so this doesn't increase                 * the output count.                 */
while|while
condition|(
operator|--
name|exp_b10
operator|>=
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
comment|/* Total buffer requirement (including the '\0') is                 * 5+precision - see check at the start.                 */
return|return;
block|}
comment|/* Here if an exponent is required, adjust size for              * the digits we output but did not count.  The total              * digit output here so far is at most 1+precision - no              * decimal point and no leading or trailing zeros have              * been output.              */
name|size
operator|-=
name|cdigits
expr_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|69
operator|,
operator|--
name|size
expr_stmt|;
comment|/* 'E': PLUS 1 TOTAL 2+precision*/
if|if
condition|(
name|exp_b10
operator|<
literal|0
condition|)
block|{
operator|*
name|ascii
operator|++
operator|=
literal|45
operator|,
operator|--
name|size
expr_stmt|;
comment|/* '-': PLUS 1 TOTAL 3+precision */
name|exp_b10
operator|=
operator|-
name|exp_b10
expr_stmt|;
block|}
name|cdigits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|exp_b10
operator|>
literal|0
condition|)
block|{
name|exponent
index|[
name|cdigits
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
name|exp_b10
operator|%
literal|10
argument_list|)
expr_stmt|;
name|exp_b10
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Need another size check here for the exponent digits, so              * this need not be considered above.              */
if|if
condition|(
operator|(
name|int
operator|)
name|size
operator|>
name|cdigits
condition|)
block|{
while|while
condition|(
name|cdigits
operator|>
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
name|exponent
index|[
operator|--
name|cdigits
index|]
expr_stmt|;
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|fp
operator|>=
name|DBL_MIN
operator|)
condition|)
block|{
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
comment|/* '0' */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|*
name|ascii
operator|++
operator|=
literal|105
expr_stmt|;
comment|/* 'i' */
operator|*
name|ascii
operator|++
operator|=
literal|110
expr_stmt|;
comment|/* 'n' */
operator|*
name|ascii
operator|++
operator|=
literal|102
expr_stmt|;
comment|/* 'f' */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Here on buffer too small. */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ASCII conversion buffer too small"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_POINT */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_FIXED_POINT_SUPPORTED
end_ifdef
begin_comment
comment|/* Function to format a fixed point value in ASCII.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_ascii_from_fixed
name|png_ascii_from_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_charp
name|ascii
parameter_list|,
name|png_size_t
name|size
parameter_list|,
name|png_fixed_point
name|fp
parameter_list|)
block|{
comment|/* Require space for 10 decimal digits, a decimal point, a minus sign and a     * trailing \0, 13 characters:     */
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
name|png_uint_32
name|num
decl_stmt|;
comment|/* Avoid overflow here on the minimum integer. */
if|if
condition|(
name|fp
operator|<
literal|0
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|45
operator|,
operator|--
name|size
operator|,
name|num
operator|=
operator|-
name|fp
expr_stmt|;
else|else
name|num
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0x80000000U
condition|)
comment|/* else overflowed */
block|{
name|unsigned
name|int
name|ndigits
init|=
literal|0
decl_stmt|,
name|first
init|=
literal|16
comment|/*flag value*/
decl_stmt|;
name|char
name|digits
index|[
literal|10
index|]
decl_stmt|;
while|while
condition|(
name|num
condition|)
block|{
comment|/* Split the low digit off num: */
name|unsigned
name|int
name|tmp
init|=
name|num
operator|/
literal|10
decl_stmt|;
name|num
operator|-=
name|tmp
operator|*
literal|10
expr_stmt|;
name|digits
index|[
name|ndigits
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|48
operator|+
name|num
argument_list|)
expr_stmt|;
comment|/* Record the first non-zero digit, note that this is a number              * starting at 1, it's not actually the array index.              */
if|if
condition|(
name|first
operator|==
literal|16
operator|&&
name|num
operator|>
literal|0
condition|)
name|first
operator|=
name|ndigits
expr_stmt|;
name|num
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|ndigits
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|ndigits
operator|>
literal|5
condition|)
operator|*
name|ascii
operator|++
operator|=
name|digits
index|[
operator|--
name|ndigits
index|]
expr_stmt|;
comment|/* The remaining digits are fractional digits, ndigits is '5' or              * smaller at this point.  It is certainly not zero.  Check for a              * non-zero fractional digit:              */
if|if
condition|(
name|first
operator|<=
literal|5
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
operator|*
name|ascii
operator|++
operator|=
literal|46
expr_stmt|;
comment|/* decimal point */
comment|/* ndigits may be<5 for small numbers, output leading zeros                 * then ndigits digits to first:                 */
name|i
operator|=
literal|5
expr_stmt|;
while|while
condition|(
name|ndigits
operator|<
name|i
condition|)
operator|*
name|ascii
operator|++
operator|=
literal|48
operator|,
operator|--
name|i
expr_stmt|;
while|while
condition|(
name|ndigits
operator|>=
name|first
condition|)
operator|*
name|ascii
operator|++
operator|=
name|digits
index|[
operator|--
name|ndigits
index|]
expr_stmt|;
comment|/* Don't output the trailing zeros! */
block|}
block|}
else|else
operator|*
name|ascii
operator|++
operator|=
literal|48
expr_stmt|;
comment|/* And null terminate the string: */
operator|*
name|ascii
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Here on buffer too small. */
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ASCII conversion buffer too small"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FIXED_POINT */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_SCAL */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_FLOATING_POINT_SUPPORTED
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|PNG_FIXED_POINT_MACRO_SUPPORTED
argument_list|)
end_if
begin_function
name|png_fixed_point
DECL|function|png_fixed
name|png_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|double
name|fp
parameter_list|,
name|png_const_charp
name|text
parameter_list|)
block|{
name|double
name|r
init|=
name|floor
argument_list|(
literal|100000
operator|*
name|fp
operator|+
literal|.5
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|>
literal|2147483647.
operator|||
name|r
operator|<
operator|-
literal|2147483648.
condition|)
name|png_fixed_error
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG__READ_pHYs_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* muldiv functions */
end_comment
begin_comment
comment|/* This API takes signed arguments and rounds the result to the nearest  * integer (or, for a fixed point number - the standard argument - to  * the nearest .00001).  Overflow and divide by zero are signalled in  * the result, a boolean - true on success, false on overflow.  */
end_comment
begin_function
name|int
DECL|function|png_muldiv
name|png_muldiv
parameter_list|(
name|png_fixed_point_p
name|res
parameter_list|,
name|png_fixed_point
name|a
parameter_list|,
name|png_int_32
name|times
parameter_list|,
name|png_int_32
name|divisor
parameter_list|)
block|{
comment|/* Return a * times / divisor, rounded. */
if|if
condition|(
name|divisor
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|times
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|a
decl_stmt|;
name|r
operator|*=
name|times
expr_stmt|;
name|r
operator|/=
name|divisor
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
comment|/* A png_fixed_point is a 32 bit integer. */
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
block|{
operator|*
name|res
operator|=
operator|(
name|png_fixed_point
operator|)
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
else|#
directive|else
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|png_uint_32
name|A
decl_stmt|,
name|T
decl_stmt|,
name|D
decl_stmt|;
name|png_uint_32
name|s16
decl_stmt|,
name|s32
decl_stmt|,
name|s00
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|negative
operator|=
literal|1
operator|,
name|A
operator|=
operator|-
name|a
expr_stmt|;
else|else
name|A
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|times
operator|<
literal|0
condition|)
name|negative
operator|=
operator|!
name|negative
operator|,
name|T
operator|=
operator|-
name|times
expr_stmt|;
else|else
name|T
operator|=
name|times
expr_stmt|;
if|if
condition|(
name|divisor
operator|<
literal|0
condition|)
name|negative
operator|=
operator|!
name|negative
operator|,
name|D
operator|=
operator|-
name|divisor
expr_stmt|;
else|else
name|D
operator|=
name|divisor
expr_stmt|;
comment|/* Following can't overflow because the arguments only           * have 31 bits each, however the result may be 32 bits.           */
name|s16
operator|=
operator|(
name|A
operator|>>
literal|16
operator|)
operator|*
operator|(
name|T
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|A
operator|&
literal|0xffff
operator|)
operator|*
operator|(
name|T
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* Can't overflow because the a*times bit is only 30           * bits at most.           */
name|s32
operator|=
operator|(
name|A
operator|>>
literal|16
operator|)
operator|*
operator|(
name|T
operator|>>
literal|16
operator|)
operator|+
operator|(
name|s16
operator|>>
literal|16
operator|)
expr_stmt|;
name|s00
operator|=
operator|(
name|A
operator|&
literal|0xffff
operator|)
operator|*
operator|(
name|T
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|s16
operator|=
operator|(
name|s16
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
expr_stmt|;
name|s00
operator|+=
name|s16
expr_stmt|;
if|if
condition|(
name|s00
operator|<
name|s16
condition|)
operator|++
name|s32
expr_stmt|;
comment|/* carry */
if|if
condition|(
name|s32
operator|<
name|D
condition|)
comment|/* else overflow */
block|{
comment|/* s32.s00 is now the 64 bit product, do a standard              * division, we know that s32< D, so the maximum              * required shift is 31.              */
name|int
name|bitshift
init|=
literal|32
decl_stmt|;
name|png_fixed_point
name|result
init|=
literal|0
decl_stmt|;
comment|/* NOTE: signed */
while|while
condition|(
operator|--
name|bitshift
operator|>=
literal|0
condition|)
block|{
name|png_uint_32
name|d32
decl_stmt|,
name|d00
decl_stmt|;
if|if
condition|(
name|bitshift
operator|>
literal|0
condition|)
name|d32
operator|=
name|D
operator|>>
operator|(
literal|32
operator|-
name|bitshift
operator|)
operator|,
name|d00
operator|=
name|D
operator|<<
name|bitshift
expr_stmt|;
else|else
name|d32
operator|=
literal|0
operator|,
name|d00
operator|=
name|D
expr_stmt|;
if|if
condition|(
name|s32
operator|>
name|d32
condition|)
block|{
if|if
condition|(
name|s00
operator|<
name|d00
condition|)
operator|--
name|s32
expr_stmt|;
comment|/* carry */
name|s32
operator|-=
name|d32
operator|,
name|s00
operator|-=
name|d00
operator|,
name|result
operator|+=
literal|1
operator|<<
name|bitshift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s32
operator|==
name|d32
operator|&&
name|s00
operator|>=
name|d00
condition|)
name|s32
operator|=
literal|0
operator|,
name|s00
operator|-=
name|d00
operator|,
name|result
operator|+=
literal|1
operator|<<
name|bitshift
expr_stmt|;
block|}
comment|/* Handle the rounding. */
if|if
condition|(
name|s00
operator|>=
operator|(
name|D
operator|>>
literal|1
operator|)
condition|)
operator|++
name|result
expr_stmt|;
if|if
condition|(
name|negative
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
comment|/* Check for overflow. */
if|if
condition|(
operator|(
name|negative
operator|&&
name|result
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|!
name|negative
operator|&&
name|result
operator|>=
literal|0
operator|)
condition|)
block|{
operator|*
name|res
operator|=
name|result
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA || INCH_CONVERSIONS */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_GAMMA_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_INCH_CONVERSIONS_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* The following is for when the caller doesn't much care about the  * result.  */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_muldiv_warn
name|png_muldiv_warn
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|a
parameter_list|,
name|png_int_32
name|times
parameter_list|,
name|png_int_32
name|divisor
parameter_list|)
block|{
name|png_fixed_point
name|result
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|result
argument_list|,
name|a
argument_list|,
name|times
argument_list|,
name|divisor
argument_list|)
condition|)
return|return
name|result
return|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"fixed point overflow ignored"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* more fixed point functions for gammma */
end_comment
begin_comment
comment|/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_reciprocal
name|png_reciprocal
parameter_list|(
name|png_fixed_point
name|a
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|floor
argument_list|(
literal|1E10
operator|/
name|a
operator|+
literal|.5
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
literal|100000
argument_list|,
literal|100000
argument_list|,
name|a
argument_list|)
condition|)
return|return
name|res
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* error/overflow */
block|}
end_function
begin_comment
comment|/* A local convenience routine. */
end_comment
begin_function
specifier|static
name|png_fixed_point
DECL|function|png_product2
name|png_product2
parameter_list|(
name|png_fixed_point
name|a
parameter_list|,
name|png_fixed_point
name|b
parameter_list|)
block|{
comment|/* The required result is 1/a * 1/b; the following preserves accuracy. */
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|a
operator|*
literal|1E
operator|-
literal|5
decl_stmt|;
name|r
operator|*=
name|b
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
literal|100000
argument_list|)
condition|)
return|return
name|res
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* overflow */
block|}
end_function
begin_comment
comment|/* The inverse of the above. */
end_comment
begin_function
name|png_fixed_point
DECL|function|png_reciprocal2
name|png_reciprocal2
parameter_list|(
name|png_fixed_point
name|a
parameter_list|,
name|png_fixed_point
name|b
parameter_list|)
block|{
comment|/* The required result is 1/a * 1/b; the following preserves accuracy. */
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
literal|1E15
operator|/
name|a
decl_stmt|;
name|r
operator|/=
name|b
expr_stmt|;
name|r
operator|=
name|floor
argument_list|(
name|r
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|2147483647.
operator|&&
name|r
operator|>=
operator|-
literal|2147483648.
condition|)
return|return
operator|(
name|png_fixed_point
operator|)
name|r
return|;
else|#
directive|else
comment|/* This may overflow because the range of png_fixed_point isn't symmetric,     * but this API is only used for the product of file and screen gamma so it     * doesn't matter that the smallest number it can produce is 1/21474, not     * 1/100000     */
name|png_fixed_point
name|res
init|=
name|png_product2
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|png_reciprocal
argument_list|(
name|res
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* overflow */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_CHECK_cHRM_SUPPORTED
end_ifdef
begin_comment
comment|/* Added at libpng version 1.2.34 (Dec 8, 2008) and 1.4.0 (Jan 2,  * 2010: moved from pngset.c) */
end_comment
begin_comment
comment|/*  *    Multiply two 32-bit numbers, V1 and V2, using 32-bit  *    arithmetic, to produce a 64 bit result in the HI/LO words.  *  *                  A B  *                x C D  *               ------  *              AD || BD  *        AC || CB || 0  *  *    where A and B are the high and low 16-bit words of V1,  *    C and D are the 16-bit words of V2, AD is the product of  *    A and D, and X || Y is (X<< 16) + Y. */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_64bit_product
name|png_64bit_product
parameter_list|(
name|long
name|v1
parameter_list|,
name|long
name|v2
parameter_list|,
name|unsigned
name|long
modifier|*
name|hi_product
parameter_list|,
name|unsigned
name|long
modifier|*
name|lo_product
parameter_list|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|long
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|a
operator|=
operator|(
name|v1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|b
operator|=
name|v1
operator|&
literal|0xffff
expr_stmt|;
name|c
operator|=
operator|(
name|v2
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|d
operator|=
name|v2
operator|&
literal|0xffff
expr_stmt|;
name|lo
operator|=
name|b
operator|*
name|d
expr_stmt|;
comment|/* BD */
name|x
operator|=
name|a
operator|*
name|d
operator|+
name|c
operator|*
name|b
expr_stmt|;
comment|/* AD + CB */
name|y
operator|=
operator|(
operator|(
name|lo
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|+
name|x
expr_stmt|;
name|lo
operator|=
operator|(
name|lo
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|y
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|hi
operator|=
operator|(
name|y
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|hi
operator|+=
name|a
operator|*
name|c
expr_stmt|;
comment|/* AC */
operator|*
name|hi_product
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hi
expr_stmt|;
operator|*
name|lo_product
operator|=
operator|(
name|unsigned
name|long
operator|)
name|lo
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CHECK_cHRM */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_READ_GAMMA_SUPPORTED
end_ifdef
begin_comment
comment|/* gamma table code */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
end_ifndef
begin_comment
comment|/* Fixed point gamma.  *  * To calculate gamma this code implements fast log() and exp() calls using only  * fixed point arithmetic.  This code has sufficient precision for either 8 or  * 16 bit sample values.  *  * The tables used here were calculated using simple 'bc' programs, but C double  * precision floating point arithmetic would work fine.  The programs are given  * at the head of each table.  *  * 8 bit log table  *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to  *   255, so it's the base 2 logarithm of a normalized 8 bit floating point  *   mantissa.  The numbers are 32 bit fractions.  */
end_comment
begin_decl_stmt
specifier|static
name|png_uint_32
DECL|variable|png_8bit_l2
name|png_8bit_l2
index|[
literal|128
index|]
init|=
block|{
if|#
directive|if
name|PNG_DO_BC
for|for
control|(
name|i
operator|=
literal|128
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
literal|.5
operator|-
name|l
argument_list|(
name|i
operator|/
literal|255
argument_list|)
operator|/
name|l
argument_list|(
literal|2
argument_list|)
operator|*
literal|65536
operator|*
literal|65536
expr_stmt|;
block|}
endif|#
directive|endif
literal|4270715492U
operator|,
literal|4222494797U
operator|,
literal|4174646467U
operator|,
literal|4127164793U
operator|,
literal|4080044201U
operator|,
literal|4033279239U
operator|,
literal|3986864580U
operator|,
literal|3940795015U
operator|,
literal|3895065449U
operator|,
literal|3849670902U
operator|,
literal|3804606499U
operator|,
literal|3759867474U
operator|,
literal|3715449162U
operator|,
literal|3671346997U
operator|,
literal|3627556511U
operator|,
literal|3584073329U
operator|,
literal|3540893168U
operator|,
literal|3498011834U
operator|,
literal|3455425220U
operator|,
literal|3413129301U
operator|,
literal|3371120137U
operator|,
literal|3329393864U
operator|,
literal|3287946700U
operator|,
literal|3246774933U
operator|,
literal|3205874930U
operator|,
literal|3165243125U
operator|,
literal|3124876025U
operator|,
literal|3084770202U
operator|,
literal|3044922296U
operator|,
literal|3005329011U
operator|,
literal|2965987113U
operator|,
literal|2926893432U
operator|,
literal|2888044853U
operator|,
literal|2849438323U
operator|,
literal|2811070844U
operator|,
literal|2772939474U
operator|,
literal|2735041326U
operator|,
literal|2697373562U
operator|,
literal|2659933400U
operator|,
literal|2622718104U
operator|,
literal|2585724991U
operator|,
literal|2548951424U
operator|,
literal|2512394810U
operator|,
literal|2476052606U
operator|,
literal|2439922311U
operator|,
literal|2404001468U
operator|,
literal|2368287663U
operator|,
literal|2332778523U
operator|,
literal|2297471715U
operator|,
literal|2262364947U
operator|,
literal|2227455964U
operator|,
literal|2192742551U
operator|,
literal|2158222529U
operator|,
literal|2123893754U
operator|,
literal|2089754119U
operator|,
literal|2055801552U
operator|,
literal|2022034013U
operator|,
literal|1988449497U
operator|,
literal|1955046031U
operator|,
literal|1921821672U
operator|,
literal|1888774511U
operator|,
literal|1855902668U
operator|,
literal|1823204291U
operator|,
literal|1790677560U
operator|,
literal|1758320682U
operator|,
literal|1726131893U
operator|,
literal|1694109454U
operator|,
literal|1662251657U
operator|,
literal|1630556815U
operator|,
literal|1599023271U
operator|,
literal|1567649391U
operator|,
literal|1536433567U
operator|,
literal|1505374214U
operator|,
literal|1474469770U
operator|,
literal|1443718700U
operator|,
literal|1413119487U
operator|,
literal|1382670639U
operator|,
literal|1352370686U
operator|,
literal|1322218179U
operator|,
literal|1292211689U
operator|,
literal|1262349810U
operator|,
literal|1232631153U
operator|,
literal|1203054352U
operator|,
literal|1173618059U
operator|,
literal|1144320946U
operator|,
literal|1115161701U
operator|,
literal|1086139034U
operator|,
literal|1057251672U
operator|,
literal|1028498358U
operator|,
literal|999877854U
operator|,
literal|971388940U
operator|,
literal|943030410U
operator|,
literal|914801076U
operator|,
literal|886699767U
operator|,
literal|858725327U
operator|,
literal|830876614U
operator|,
literal|803152505U
operator|,
literal|775551890U
operator|,
literal|748073672U
operator|,
literal|720716771U
operator|,
literal|693480120U
operator|,
literal|666362667U
operator|,
literal|639363374U
operator|,
literal|612481215U
operator|,
literal|585715177U
operator|,
literal|559064263U
operator|,
literal|532527486U
operator|,
literal|506103872U
operator|,
literal|479792461U
operator|,
literal|453592303U
operator|,
literal|427502463U
operator|,
literal|401522014U
operator|,
literal|375650043U
operator|,
literal|349885648U
operator|,
literal|324227938U
operator|,
literal|298676034U
operator|,
literal|273229066U
operator|,
literal|247886176U
operator|,
literal|222646516U
operator|,
literal|197509248U
operator|,
literal|172473545U
operator|,
literal|147538590U
operator|,
literal|122703574U
operator|,
literal|97967701U
operator|,
literal|73330182U
operator|,
literal|48790236U
operator|,
literal|24347096U
operator|,
literal|0U
if|#
directive|if
literal|0
comment|/* The following are the values for 16 bit tables - these work fine for the 8     * bit conversions but produce very slightly larger errors in the 16 bit log     * (about 1.2 as opposed to 0.7 absolute error in the final value).  To use     * these all the shifts below must be adjusted appropriately.     */
block|65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,    57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,    50170, 49542, 48918, 48298, 47682, 47070, 46462, 45858, 45257, 44661, 44068,    43479, 42894, 42312, 41733, 41159, 40587, 40020, 39455, 38894, 38336, 37782,    37230, 36682, 36137, 35595, 35057, 34521, 33988, 33459, 32932, 32408, 31887,    31369, 30854, 30341, 29832, 29325, 28820, 28319, 27820, 27324, 26830, 26339,    25850, 25364, 24880, 24399, 23920, 23444, 22970, 22499, 22029, 21562, 21098,    20636, 20175, 19718, 19262, 18808, 18357, 17908, 17461, 17016, 16573, 16132,    15694, 15257, 14822, 14390, 13959, 13530, 13103, 12678, 12255, 11834, 11415,    10997, 10582, 10168, 9756, 9346, 8937, 8531, 8126, 7723, 7321, 6921, 6523,    6127, 5732, 5339, 4947, 4557, 4169, 3782, 3397, 3014, 2632, 2251, 1872, 1495,    1119, 744, 372
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|png_int_32
DECL|function|png_log8bit
name|png_log8bit
parameter_list|(
name|unsigned
name|int
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|lg2
init|=
literal|0
decl_stmt|;
comment|/* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,     * because the log is actually negate that means adding 1.  The final     * returned value thus has the range 0 (for 255 input) to 7.994 (for 1     * input), return 7.99998 for the overflow (log 0) case - so the result is     * always at most 19 bits.     */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0xff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0xffffffff
return|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|=
literal|4
operator|,
name|x
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xc0
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|2
operator|,
name|x
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|1
operator|,
name|x
operator|<<=
literal|1
expr_stmt|;
comment|/* result is at most 19 bits, so this cast is safe: */
return|return
call|(
name|png_int_32
call|)
argument_list|(
operator|(
name|lg2
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|png_8bit_l2
index|[
name|x
operator|-
literal|128
index|]
operator|+
literal|32768
operator|)
operator|>>
literal|16
operator|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* The above gives exact (to 16 binary places) log2 values for 8 bit images,  * for 16 bit images we use the most significant 8 bits of the 16 bit value to  * get an approximation then multiply the approximation by a correction factor  * determined by the remaining up to 8 bits.  This requires an additional step  * in the 16 bit case.  *  * We want log2(value/65535), we have log2(v'/255), where:  *  *    value = v' * 256 + v''  *          = v' * f  *  * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128  * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less  * than 258.  The final factor also needs to correct for the fact that our 8 bit  * value is scaled by 255, whereas the 16 bit values must be scaled by 65535.  *  * This gives a final formula using a calculated value 'x' which is value/v' and  * scaling by 65536 to match the above table:  *  *   log2(x/257) * 65536  *  * Since these numbers are so close to '1' we can use simple linear  * interpolation between the two end values 256/257 (result -368.61) and 258/257  * (result 367.179).  The values used below are scaled by a further 64 to give  * 16 bit precision in the interpolation:  *  * Start (256): -23591  * Zero  (257):      0  * End   (258):  23499  */
end_comment
begin_function
specifier|static
name|png_int_32
DECL|function|png_log16bit
name|png_log16bit
parameter_list|(
name|png_uint_32
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|lg2
init|=
literal|0
decl_stmt|;
comment|/* As above, but now the input has 16 bits. */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0xffffffff
return|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|=
literal|8
operator|,
name|x
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xf000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|4
operator|,
name|x
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0xc000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|2
operator|,
name|x
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
name|lg2
operator|+=
literal|1
operator|,
name|x
operator|<<=
literal|1
expr_stmt|;
comment|/* Calculate the base logarithm from the top 8 bits as a 28 bit fractional     * value.     */
name|lg2
operator|<<=
literal|28
expr_stmt|;
name|lg2
operator|+=
operator|(
name|png_8bit_l2
index|[
operator|(
name|x
operator|>>
literal|8
operator|)
operator|-
literal|128
index|]
operator|+
literal|8
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* Now we need to interpolate the factor, this requires a division by the top     * 8 bits.  Do this with maximum precision.     */
name|x
operator|=
operator|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator|+
operator|(
name|x
operator|>>
literal|9
operator|)
operator|)
operator|/
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,     * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly     * 16 bits to interpolate to get the low bits of the result.  Round the     * answer.  Note that the end point values are scaled by 64 to retain overall     * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust     * the overall scaling by 6-12.  Round at every step.     */
name|x
operator|-=
literal|1U
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|65536U
condition|)
comment|/*<= '257' */
name|lg2
operator|+=
operator|(
operator|(
literal|23591U
operator|*
operator|(
literal|65536U
operator|-
name|x
operator|)
operator|)
operator|+
operator|(
literal|1U
operator|<<
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|)
expr_stmt|;
else|else
name|lg2
operator|-=
operator|(
operator|(
literal|23499U
operator|*
operator|(
name|x
operator|-
literal|65536U
operator|)
operator|)
operator|+
operator|(
literal|1U
operator|<<
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
operator|(
literal|16
operator|+
literal|6
operator|-
literal|12
operator|)
expr_stmt|;
comment|/* Safe, because the result can't have more than 20 bits: */
return|return
call|(
name|png_int_32
call|)
argument_list|(
operator|(
name|lg2
operator|+
literal|2048
operator|)
operator|>>
literal|12
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* The 'exp()' case must invert the above, taking a 20 bit fixed point  * logarithmic value and returning a 16 or 8 bit number as appropriate.  In  * each case only the low 16 bits are relevant - the fraction - since the  * integer bits (the top 4) simply determine a shift.  *  * The worst case is the 16 bit distinction between 65535 and 65534, this  * requires perhaps spurious accuracty in the decoding of the logarithm to  * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance  * of getting this accuracy in practice.  *  * To deal with this the following exp() function works out the exponent of the  * frational part of the logarithm by using an accurate 32 bit value from the  * top four fractional bits then multiplying in the remaining bits.  */
end_comment
begin_decl_stmt
specifier|static
name|png_uint_32
DECL|variable|png_32bit_exp
name|png_32bit_exp
index|[
literal|16
index|]
init|=
block|{
if|#
directive|if
name|PNG_DO_BC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
literal|.5
operator|+
name|e
argument_list|(
operator|-
name|i
operator|/
literal|16
operator|*
name|l
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|*
literal|2
operator|^
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTE: the first entry is deliberately set to the maximum 32 bit value. */
literal|4294967295U
operator|,
literal|4112874773U
operator|,
literal|3938502376U
operator|,
literal|3771522796U
operator|,
literal|3611622603U
operator|,
literal|3458501653U
operator|,
literal|3311872529U
operator|,
literal|3171459999U
operator|,
literal|3037000500U
operator|,
literal|2908241642U
operator|,
literal|2784941738U
operator|,
literal|2666869345U
operator|,
literal|2553802834U
operator|,
literal|2445529972U
operator|,
literal|2341847524U
operator|,
literal|2242560872U
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Adjustment table; provided to explain the numbers in the code below. */
end_comment
begin_if
if|#
directive|if
name|PNG_DO_BC
end_if
begin_for
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|print
name|i
decl_stmt|, " ",
argument_list|(
literal|1
operator|-
name|e
argument_list|(
operator|-
operator|(
literal|2
operator|^
name|i
operator|)
operator|/
literal|65536
operator|*
name|l
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
modifier|*
decl_stmt|2
modifier|^
argument_list|(
literal|32
operator|-
name|i
argument_list|)
decl_stmt|, "\n"
block|}
end_for
begin_expr_stmt
literal|11
literal|44937.64284865548751208448
literal|10
literal|45180.98734845585101160448
literal|9
literal|45303.31936980687359311872
literal|8
literal|45364.65110595323018870784
literal|7
literal|45395.35850361789624614912
literal|6
literal|45410.72259715102037508096
literal|5
literal|45418.40724413220722311168
literal|4
literal|45422.25021786898173001728
literal|3
literal|45424.17186732298419044352
literal|2
literal|45425.13273269940811464704
literal|1
literal|45425.61317555035558641664
literal|0
literal|45425.85339951654943850496
endif|#
directive|endif
specifier|static
name|png_uint_32
DECL|function|png_exp
name|png_exp
argument_list|(
argument|png_fixed_point x
argument_list|)
block|{
if|if
condition|(
name|x
operator|>
literal|0
operator|&&
name|x
operator|<=
literal|0xfffff
condition|)
comment|/* Else overflow or zero (underflow) */
block|{
comment|/* Obtain a 4 bit approximation */
name|png_uint_32
name|e
init|=
name|png_32bit_exp
index|[
operator|(
name|x
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
decl_stmt|;
comment|/* Incorporate the low 12 bits - these decrease the returned value by        * multiplying by a number less than 1 if the bit is set.  The multiplier        * is determined by the above table and the shift. Notice that the values        * converge on 45426 and this is used to allow linear interpolation of the        * low bits.        */
if|if
condition|(
name|x
operator|&
literal|0x800
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|44938U
operator|)
operator|+
literal|16U
operator|)
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x400
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45181U
operator|)
operator|+
literal|32U
operator|)
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x200
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45303U
operator|)
operator|+
literal|64U
operator|)
operator|>>
literal|7
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x100
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45365U
operator|)
operator|+
literal|128U
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x080
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45395U
operator|)
operator|+
literal|256U
operator|)
operator|>>
literal|9
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x040
condition|)
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|45410U
operator|)
operator|+
literal|512U
operator|)
operator|>>
literal|10
expr_stmt|;
comment|/* And handle the low 6 bits in a single block. */
name|e
operator|-=
operator|(
operator|(
operator|(
name|e
operator|>>
literal|16
operator|)
operator|*
literal|355U
operator|*
operator|(
name|x
operator|&
literal|0x3fU
operator|)
operator|)
operator|+
literal|256U
operator|)
operator|>>
literal|9
expr_stmt|;
comment|/* Handle the upper bits of x. */
name|e
operator|>>=
name|x
operator|>>
literal|16
expr_stmt|;
return|return
name|e
return|;
block|}
end_expr_stmt
begin_comment
comment|/* Check for overflow */
end_comment
begin_if
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
return|return
name|png_32bit_exp
index|[
literal|0
index|]
return|;
end_if
begin_comment
comment|/* Else underflow */
end_comment
begin_return
return|return
literal|0
return|;
end_return
begin_function
unit|}  static
name|png_byte
DECL|function|png_exp8bit
name|png_exp8bit
parameter_list|(
name|png_fixed_point
name|lg2
parameter_list|)
block|{
comment|/* Get a 32 bit value: */
name|png_uint_32
name|x
init|=
name|png_exp
argument_list|(
name|lg2
argument_list|)
decl_stmt|;
comment|/* Convert the 32 bit value to 0..255 by multiplying by 256-1, note that the     * second, rounding, step can't overflow because of the first, subtraction,     * step.     */
name|x
operator|-=
name|x
operator|>>
literal|8
expr_stmt|;
return|return
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|x
operator|+
literal|0x7fffffU
operator|)
operator|>>
literal|24
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|png_uint_16
DECL|function|png_exp16bit
name|png_exp16bit
parameter_list|(
name|png_fixed_point
name|lg2
parameter_list|)
block|{
comment|/* Get a 32 bit value: */
name|png_uint_32
name|x
init|=
name|png_exp
argument_list|(
name|lg2
argument_list|)
decl_stmt|;
comment|/* Convert the 32 bit value to 0..65535 by multiplying by 65536-1: */
name|x
operator|-=
name|x
operator|>>
literal|16
expr_stmt|;
return|return
call|(
name|png_uint_16
call|)
argument_list|(
operator|(
name|x
operator|+
literal|32767U
operator|)
operator|>>
literal|16
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FLOATING_ARITHMETIC */
end_comment
begin_function
name|png_byte
DECL|function|png_gamma_8bit_correct
name|png_gamma_8bit_correct
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|<
literal|255
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|floor
argument_list|(
literal|255
operator|*
name|pow
argument_list|(
name|value
operator|/
literal|255.
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|png_byte
operator|)
name|r
return|;
else|#
directive|else
name|png_int_32
name|lg2
init|=
name|png_log8bit
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|gamma_val
argument_list|,
name|lg2
argument_list|,
name|PNG_FP_1
argument_list|)
condition|)
return|return
name|png_exp8bit
argument_list|(
name|res
argument_list|)
return|;
comment|/* Overflow. */
name|value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|png_byte
operator|)
name|value
return|;
block|}
end_function
begin_function
name|png_uint_16
DECL|function|png_gamma_16bit_correct
name|png_gamma_16bit_correct
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
literal|0
operator|&&
name|value
operator|<
literal|65535
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
name|double
name|r
init|=
name|floor
argument_list|(
literal|65535
operator|*
name|pow
argument_list|(
name|value
operator|/
literal|65535.
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|png_uint_16
operator|)
name|r
return|;
else|#
directive|else
name|png_int_32
name|lg2
init|=
name|png_log16bit
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|png_fixed_point
name|res
decl_stmt|;
if|if
condition|(
name|png_muldiv
argument_list|(
operator|&
name|res
argument_list|,
name|gamma_val
argument_list|,
name|lg2
argument_list|,
name|PNG_FP_1
argument_list|)
condition|)
return|return
name|png_exp16bit
argument_list|(
name|res
argument_list|)
return|;
comment|/* Overflow. */
name|value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|png_uint_16
operator|)
name|value
return|;
block|}
end_function
begin_comment
comment|/* This does the right thing based on the bit_depth field of the  * png_struct, interpreting values as 8 or 16 bit.  While the result  * is nominally a 16 bit value if bit depth is 8 then the result is  * 8 bit (as are the arguments.)  */
end_comment
begin_function
name|png_uint_16
comment|/* PRIVATE */
DECL|function|png_gamma_correct
name|png_gamma_correct
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|,
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|8
condition|)
return|return
name|png_gamma_8bit_correct
argument_list|(
name|value
argument_list|,
name|gamma_val
argument_list|)
return|;
else|else
return|return
name|png_gamma_16bit_correct
argument_list|(
name|value
argument_list|,
name|gamma_val
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* This is the shared test on whether a gamma value is 'significant' - whether  * it is worth doing gamma correction.  */
end_comment
begin_function
name|int
comment|/* PRIVATE */
DECL|function|png_gamma_significant
name|png_gamma_significant
parameter_list|(
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
return|return
name|gamma_val
operator|<
name|PNG_FP_1
operator|-
name|PNG_GAMMA_THRESHOLD_FIXED
operator|||
name|gamma_val
operator|>
name|PNG_FP_1
operator|+
name|PNG_GAMMA_THRESHOLD_FIXED
return|;
block|}
end_function
begin_comment
comment|/* Internal function to build a single 16 bit table - the table consists of  * 'num' 256 entry subtables, where 'num' is determined by 'shift' - the amount  * to shift the input values right (or 16-number_of_signifiant_bits).  *  * The caller is responsible for ensuring that the table gets cleaned up on  * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument  * should be somewhere that will be cleaned.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_16bit_table
name|png_build_16bit_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_16pp
modifier|*
name|ptable
parameter_list|,
name|PNG_CONST
name|unsigned
name|int
name|shift
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
comment|/* Various values derived from 'shift': */
name|PNG_CONST
name|unsigned
name|int
name|num
init|=
literal|1U
operator|<<
operator|(
literal|8U
operator|-
name|shift
operator|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
operator|(
literal|16U
operator|-
name|shift
operator|)
operator|)
operator|-
literal|1U
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max_by_2
init|=
literal|1U
operator|<<
operator|(
literal|15U
operator|-
name|shift
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|png_uint_16pp
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_uint_16pp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|num
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16p
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|png_uint_16p
name|sub_table
init|=
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The 'threshold' test is repeated here because it can arise for one of        * the 16 bit tables even if the others don't hit it.        */
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|gamma_val
argument_list|)
condition|)
block|{
comment|/* The old code would overflow at the end and this would cause the           * 'pow' function to return a result>1, resulting in an           * arithmetic error.  This code follows the spec exactly; ig is           * the recovered input sample, it always has 8-16 bits.           *           * We want input * 65535/max, rounded, the arithmetic fits in 32           * bits (unsigned) so long as max<= 32767.           */
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|png_uint_32
name|ig
init|=
operator|(
name|j
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|+
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_FLOATING_ARITHMETIC_SUPPORTED
comment|/* Inline the 'max' scaling operation: */
name|double
name|d
init|=
name|floor
argument_list|(
literal|65535
operator|*
name|pow
argument_list|(
name|ig
operator|/
operator|(
name|double
operator|)
name|max
argument_list|,
name|gamma_val
operator|*
literal|.00001
argument_list|)
operator|+
literal|.5
argument_list|)
decl_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|d
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|shift
condition|)
name|ig
operator|=
operator|(
name|ig
operator|*
literal|65535U
operator|+
name|max_by_2
operator|)
operator|/
name|max
expr_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
name|png_gamma_16bit_correct
argument_list|(
name|ig
argument_list|,
name|gamma_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* We must still build a table, but do it the fast way. */
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|png_uint_32
name|ig
init|=
operator|(
name|j
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|shift
condition|)
name|ig
operator|=
operator|(
name|ig
operator|*
literal|65535U
operator|+
name|max_by_2
operator|)
operator|/
name|max
expr_stmt|;
name|sub_table
index|[
name|j
index|]
operator|=
operator|(
name|png_uint_16
operator|)
name|ig
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* NOTE: this function expects the *inverse* of the overall gamma transformation  * required.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_16to8_table
name|png_build_16to8_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_16pp
modifier|*
name|ptable
parameter_list|,
name|PNG_CONST
name|unsigned
name|int
name|shift
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
name|PNG_CONST
name|unsigned
name|int
name|num
init|=
literal|1U
operator|<<
operator|(
literal|8U
operator|-
name|shift
operator|)
decl_stmt|;
name|PNG_CONST
name|unsigned
name|int
name|max
init|=
operator|(
literal|1U
operator|<<
operator|(
literal|16U
operator|-
name|shift
operator|)
operator|)
operator|-
literal|1U
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|png_uint_32
name|last
decl_stmt|;
name|png_uint_16pp
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_uint_16pp
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|num
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16p
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 'num' is the number of tables and also the number of low bits of low     * bits of the input 16 bit value used to select a table.  Each table is     * itself index by the high 8 bits of the value.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_uint_16p
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
operator|*
name|png_sizeof
argument_list|(
name|png_uint_16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 'gamma_val' is set to the reciprocal of the value calculated above, so     * pow(out,g) is an *input* value.  'last' is the last input value set.     *     * In the loop 'i' is used to find output values.  Since the output is 8     * bit there are only 256 possible values.  The tables are set up to     * select the closest possible output value for each input by finding     * the input value at the boundary between each pair of output values     * and filling the table up to that boundary with the lower output     * value.     *     * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9 bit     * values the code below uses a 16 bit value in i; the values start at     * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last     * entries are filled with 255).  Start i at 128 and fill all 'last'     * table entries<= 'max'     */
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|255
condition|;
operator|++
name|i
control|)
comment|/* 8 bit output value */
block|{
comment|/* Find the corresponding maximum input value */
name|png_uint_16
name|out
init|=
call|(
name|png_uint_16
call|)
argument_list|(
name|i
operator|*
literal|257U
argument_list|)
decl_stmt|;
comment|/* 16 bit output value */
comment|/* Find the boundary value in 16 bits: */
name|png_uint_32
name|bound
init|=
name|png_gamma_16bit_correct
argument_list|(
name|out
operator|+
literal|128U
argument_list|,
name|gamma_val
argument_list|)
decl_stmt|;
comment|/* Adjust (round) to (16-shift) bits: */
name|bound
operator|=
operator|(
name|bound
operator|*
name|max
operator|+
literal|32768U
operator|)
operator|/
literal|65535U
operator|+
literal|1U
expr_stmt|;
while|while
condition|(
name|last
operator|<
name|bound
condition|)
block|{
name|table
index|[
name|last
operator|&
operator|(
literal|0xffU
operator|>>
name|shift
operator|)
index|]
index|[
name|last
operator|>>
operator|(
literal|8U
operator|-
name|shift
operator|)
index|]
operator|=
name|out
expr_stmt|;
name|last
operator|++
expr_stmt|;
block|}
block|}
comment|/* And fill in the final entries. */
while|while
condition|(
name|last
operator|<
operator|(
name|num
operator|<<
literal|8
operator|)
condition|)
block|{
name|table
index|[
name|last
operator|&
operator|(
literal|0xff
operator|>>
name|shift
operator|)
index|]
index|[
name|last
operator|>>
operator|(
literal|8U
operator|-
name|shift
operator|)
index|]
operator|=
literal|65535U
expr_stmt|;
name|last
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Build a single 8 bit table: same as the 16 bit case but much simpler (and  * typically much faster).  Note that libpng currently does no sBIT processing  * (apparently contrary to the spec) so a 256 entry table is always generated.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_build_8bit_table
name|png_build_8bit_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytepp
name|ptable
parameter_list|,
name|PNG_CONST
name|png_fixed_point
name|gamma_val
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|png_bytep
name|table
init|=
operator|*
name|ptable
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
literal|256
argument_list|)
decl_stmt|;
if|if
condition|(
name|png_gamma_significant
argument_list|(
name|gamma_val
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
name|png_gamma_8bit_correct
argument_list|(
name|i
argument_list|,
name|gamma_val
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|table
index|[
name|i
index|]
operator|=
operator|(
name|png_byte
operator|)
name|i
expr_stmt|;
block|}
end_function
begin_comment
comment|/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit  * tables, we don't make a full table if we are reducing to 8-bit in  * the future.  Note also how the gamma_16 tables are segmented so that  * we don't need to allocate> 64K chunks for a full 16-bit table.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_build_gamma_table
name|png_build_gamma_table
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|bit_depth
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_build_gamma_table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_depth
operator|<=
literal|8
condition|)
block|{
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_table
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
operator|(
name|PNG_BACKGROUND
operator|)
operator||
name|PNG_RGB_TO_GRAY
operator|)
condition|)
block|{
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_to_1
argument_list|,
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
name|png_build_8bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_from_1
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|png_ptr
operator|->
name|gamma
comment|/* Probably doing rgb_to_gray */
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
block|}
else|else
block|{
name|png_byte
name|shift
decl_stmt|,
name|sig_bit
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
block|{
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|red
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
operator|>
name|sig_bit
condition|)
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|green
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
operator|>
name|sig_bit
condition|)
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|blue
expr_stmt|;
block|}
else|else
name|sig_bit
operator|=
name|png_ptr
operator|->
name|sig_bit
operator|.
name|gray
expr_stmt|;
comment|/* 16 bit gamma code uses this equation:       *       *   ov = table[(iv& 0xff)>> gamma_shift][iv>> 8]       *       * Where 'iv' is the input color value and 'ov' is the output value -       * pow(iv, gamma).       *       * Thus the gamma table consists of up to 256 256 entry tables.  The table       * is selected by the (8-gamma_shift) most significant of the low 8 bits of       * the color value then indexed by the upper 8 bits:       *       *   table[low bits][high 8 bits]       *       * So the table 'n' corresponds to all those 'iv' of:       *       *<all high 8 bit values><n<< gamma_shift>..<(n+1<< gamma_shift)-1>       *       */
if|if
condition|(
name|sig_bit
operator|>
literal|0
operator|&&
name|sig_bit
operator|<
literal|16U
condition|)
name|shift
operator|=
call|(
name|png_byte
call|)
argument_list|(
literal|16U
operator|-
name|sig_bit
argument_list|)
expr_stmt|;
comment|/* shift == insignificant bits */
else|else
name|shift
operator|=
literal|0
expr_stmt|;
comment|/* keep all 16 bits */
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_16_TO_8
condition|)
block|{
comment|/* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively          * the significant bits in the *input* when the output will          * eventually be 8 bits.  By default it is 11.          */
if|if
condition|(
name|shift
operator|<
operator|(
literal|16U
operator|-
name|PNG_MAX_GAMMA_8
operator|)
condition|)
name|shift
operator|=
operator|(
literal|16U
operator|-
name|PNG_MAX_GAMMA_8
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|>
literal|8U
condition|)
name|shift
operator|=
literal|8U
expr_stmt|;
comment|/* Guarantees at least one table! */
name|png_ptr
operator|->
name|gamma_shift
operator|=
name|shift
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_16_TO_8
operator||
name|PNG_BACKGROUND
operator|)
condition|)
endif|#
directive|endif
name|png_build_16to8_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_table
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_product2
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_16BIT_SUPPORTED
else|else
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_table
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal2
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|PNG_FP_1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PNG_READ_BACKGROUND_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_READ_RGB_TO_GRAY_SUPPORTED
argument_list|)
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
operator|(
name|PNG_BACKGROUND
operator||
name|PNG_RGB_TO_GRAY
operator|)
condition|)
block|{
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_to_1
argument_list|,
name|shift
argument_list|,
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notice that the '16 from 1' table should be full precision, however          * the lookup on this table still uses gamma_shift, so it can't be.          * TODO: fix this.          */
name|png_build_16bit_table
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|gamma_16_from_1
argument_list|,
name|shift
argument_list|,
name|png_ptr
operator|->
name|screen_gamma
operator|>
literal|0
condition|?
name|png_reciprocal
argument_list|(
name|png_ptr
operator|->
name|screen_gamma
argument_list|)
else|:
name|png_ptr
operator|->
name|gamma
comment|/* Probably doing rgb_to_gray */
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* READ_GAMMA */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
end_comment
end_unit
