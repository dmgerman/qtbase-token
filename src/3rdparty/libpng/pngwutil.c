begin_unit
begin_comment
comment|/* pngwutil.c - utilities to write a PNG file  *  * Last changed in libpng 1.6.17 [March 26, 2015]  * Copyright (c) 1998-2015 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_INT_FUNCTIONS_SUPPORTED
end_ifdef
begin_comment
comment|/* Place a 32-bit number into a buffer in PNG byte order.  We work  * with unsigned numbers for convenience, although one supported  * ancillary chunk uses signed (two's complement) numbers.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_save_uint_32
name|png_save_uint_32
parameter_list|(
name|png_bytep
name|buf
parameter_list|,
name|png_uint_32
name|i
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Place a 16-bit number into a buffer in PNG byte order.  * The parameter is declared unsigned int, not png_uint_16,  * just to avoid potential problems on pre-ANSI C compilers.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_save_uint_16
name|png_save_uint_16
parameter_list|(
name|png_bytep
name|buf
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Simple function to write the signature.  If we have already written  * the magic bytes of the signature, or more likely, the PNG stream is  * being embedded into another stream and doesn't need its own signature,  * we should call png_set_sig_bytes() to tell libpng how many of the  * bytes have already been written.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_sig
name|png_write_sig
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|png_signature
index|[
literal|8
index|]
init|=
block|{
literal|137
block|,
literal|80
block|,
literal|78
block|,
literal|71
block|,
literal|13
block|,
literal|10
block|,
literal|26
block|,
literal|10
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that the signature is being written */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_SIGNATURE
expr_stmt|;
endif|#
directive|endif
comment|/* Write the rest of the 8 byte signature */
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_signature
index|[
name|png_ptr
operator|->
name|sig_bytes
index|]
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
literal|8
operator|-
name|png_ptr
operator|->
name|sig_bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bytes
operator|<
literal|3
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PNG_SIGNATURE
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write the start of a PNG chunk.  The type is the chunk type.  * The total_length is the sum of the lengths of all the data you will be  * passing in png_write_chunk_data().  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_chunk_header
name|png_write_chunk_header
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_DEBUG
argument_list|)
operator|&&
operator|(
name|PNG_DEBUG
operator|>
literal|0
operator|)
name|PNG_CSTRING_FROM_CHUNK
argument_list|(
name|buf
argument_list|,
name|chunk_name
argument_list|)
expr_stmt|;
name|png_debug2
argument_list|(
literal|0
argument_list|,
literal|"Writing %s chunk, length = %lu"
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that the chunk header is being written.     * PNG_IO_CHUNK_HDR requires a single I/O call.     */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_CHUNK_HDR
expr_stmt|;
endif|#
directive|endif
comment|/* Write the length and the chunk name */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|chunk_name
argument_list|)
expr_stmt|;
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Put the chunk name into png_ptr->chunk_name */
name|png_ptr
operator|->
name|chunk_name
operator|=
name|chunk_name
expr_stmt|;
comment|/* Reset the crc and run it over the chunk name */
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|buf
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that chunk data will (possibly) be written.     * PNG_IO_CHUNK_DATA does NOT require a specific number of I/O calls.     */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_CHUNK_DATA
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk_start
name|png_write_chunk_start
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_string
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|PNG_CHUNK_FROM_STRING
argument_list|(
name|chunk_string
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write the data of a PNG chunk started with png_write_chunk_header().  * Note that multiple calls to this function are allowed, and that the  * sum of the lengths from these calls *must* add up to the total_length  * given to png_write_chunk_header().  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk_data
name|png_write_chunk_data
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
comment|/* Write the data, and run the CRC over it */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|data
operator|!=
name|NULL
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Update the CRC after writing the data,        * in case the user I/O routine alters it.        */
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Finish a chunk started with png_write_chunk_header(). */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk_end
name|png_write_chunk_end
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that the chunk CRC is being written.     * PNG_IO_CHUNK_CRC requires a single I/O function call.     */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_CHUNK_CRC
expr_stmt|;
endif|#
directive|endif
comment|/* Write the crc in a single operation */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|png_ptr
operator|->
name|crc
argument_list|)
expr_stmt|;
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write a PNG chunk all at once.  The type is an array of ASCII characters  * representing the chunk name.  The array must be at least 4 bytes in  * length, and does not need to be null terminated.  To be safe, pass the  * pre-defined chunk names here, and if you need a new one, define it  * where the others are defined.  The length is the length of the data.  * All the data must be present.  If that is not possible, use the  * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()  * functions instead.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_complete_chunk
name|png_write_complete_chunk
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|,
name|png_const_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* On 64 bit architectures 'length' may not fit in a png_uint_32. */
if|if
condition|(
name|length
operator|>
name|PNG_UINT_31_MAX
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"length exceeds PNG maximum"
argument_list|)
expr_stmt|;
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|,
operator|(
name|png_uint_32
operator|)
name|length
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is the API that calls the internal function above. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk
name|png_write_chunk
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_string
parameter_list|,
name|png_const_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|PNG_CHUNK_FROM_STRING
argument_list|(
name|chunk_string
argument_list|)
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is used below to find the size of an image to pass to png_deflate_claim,  * so it only needs to be accurate if the size is less than 16384 bytes (the  * point at which a lower LZ window size can be used.)  */
end_comment
begin_function
specifier|static
name|png_alloc_size_t
DECL|function|png_image_size
name|png_image_size
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
comment|/* Only return sizes up to the maximum of a png_uint_32; do this by limiting     * the width and height used to 15 bits.     */
name|png_uint_32
name|h
init|=
name|png_ptr
operator|->
name|height
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|rowbytes
operator|<
literal|32768
operator|&&
name|h
operator|<
literal|32768
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
condition|)
block|{
comment|/* Interlacing makes the image larger because of the replication of           * both the filter byte and the padding to a byte boundary.           */
name|png_uint_32
name|w
init|=
name|png_ptr
operator|->
name|width
decl_stmt|;
name|unsigned
name|int
name|pd
init|=
name|png_ptr
operator|->
name|pixel_depth
decl_stmt|;
name|png_alloc_size_t
name|cb_base
decl_stmt|;
name|int
name|pass
decl_stmt|;
for|for
control|(
name|cb_base
operator|=
literal|0
operator|,
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|6
condition|;
operator|++
name|pass
control|)
block|{
name|png_uint_32
name|pw
init|=
name|PNG_PASS_COLS
argument_list|(
name|w
argument_list|,
name|pass
argument_list|)
decl_stmt|;
if|if
condition|(
name|pw
operator|>
literal|0
condition|)
name|cb_base
operator|+=
operator|(
name|PNG_ROWBYTES
argument_list|(
name|pd
argument_list|,
name|pw
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|PNG_PASS_ROWS
argument_list|(
name|h
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
return|return
name|cb_base
return|;
block|}
else|else
return|return
operator|(
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
operator|)
operator|*
name|h
return|;
block|}
else|else
return|return
literal|0xffffffffU
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
end_ifdef
begin_comment
comment|/* This is the code to hack the first two bytes of the deflate stream (the     * deflate header) to correct the windowBits value to match the actual data     * size.  Note that the second argument is the *uncompressed* size but the     * first argument is the *compressed* data (and it must be deflate     * compressed.)     */
end_comment
begin_function
specifier|static
name|void
DECL|function|optimize_cmf
name|optimize_cmf
parameter_list|(
name|png_bytep
name|data
parameter_list|,
name|png_alloc_size_t
name|data_size
parameter_list|)
block|{
comment|/* Optimize the CMF field in the zlib stream.  The resultant zlib stream is     * still compliant to the stream specification.     */
if|if
condition|(
name|data_size
operator|<=
literal|16384
condition|)
comment|/* else windowBits must be 15 */
block|{
name|unsigned
name|int
name|z_cmf
init|=
name|data
index|[
literal|0
index|]
decl_stmt|;
comment|/* zlib compression method and flags */
if|if
condition|(
operator|(
name|z_cmf
operator|&
literal|0x0f
operator|)
operator|==
literal|8
operator|&&
operator|(
name|z_cmf
operator|&
literal|0xf0
operator|)
operator|<=
literal|0x70
condition|)
block|{
name|unsigned
name|int
name|z_cinfo
decl_stmt|;
name|unsigned
name|int
name|half_z_window_size
decl_stmt|;
name|z_cinfo
operator|=
name|z_cmf
operator|>>
literal|4
expr_stmt|;
name|half_z_window_size
operator|=
literal|1U
operator|<<
operator|(
name|z_cinfo
operator|+
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|data_size
operator|<=
name|half_z_window_size
condition|)
comment|/* else no change */
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
do|do
block|{
name|half_z_window_size
operator|>>=
literal|1
expr_stmt|;
operator|--
name|z_cinfo
expr_stmt|;
block|}
do|while
condition|(
name|z_cinfo
operator|>
literal|0
operator|&&
name|data_size
operator|<=
name|half_z_window_size
condition|)
do|;
name|z_cmf
operator|=
operator|(
name|z_cmf
operator|&
literal|0x0f
operator|)
operator||
operator|(
name|z_cinfo
operator|<<
literal|4
operator|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|z_cmf
expr_stmt|;
name|tmp
operator|=
name|data
index|[
literal|1
index|]
operator|&
literal|0xe0
expr_stmt|;
name|tmp
operator|+=
literal|0x1f
operator|-
operator|(
operator|(
name|z_cmf
operator|<<
literal|8
operator|)
operator|+
name|tmp
operator|)
operator|%
literal|0x1f
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|tmp
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_OPTIMIZE_CMF */
end_comment
begin_comment
comment|/* Initialize the compressor for the appropriate type of compression. */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_deflate_claim
name|png_deflate_claim
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|owner
parameter_list|,
name|png_alloc_size_t
name|data_size
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PNG_WARNINGS_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_ERROR_TEXT_SUPPORTED
argument_list|)
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
name|PNG_STRING_FROM_CHUNK
argument_list|(
name|msg
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|msg
index|[
literal|4
index|]
operator|=
literal|':'
expr_stmt|;
name|msg
index|[
literal|5
index|]
operator|=
literal|' '
expr_stmt|;
name|PNG_STRING_FROM_CHUNK
argument_list|(
name|msg
operator|+
literal|6
argument_list|,
name|png_ptr
operator|->
name|zowner
argument_list|)
expr_stmt|;
comment|/* So the message that results is "<chunk> using zstream"; this is an        * internal error, but is very useful for debugging.  i18n requirements        * are minimal.        */
operator|(
name|void
operator|)
name|png_safecat
argument_list|(
name|msg
argument_list|,
operator|(
sizeof|sizeof
name|msg
operator|)
argument_list|,
literal|10
argument_list|,
literal|" using zstream"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|PNG_LIBPNG_BUILD_BASE_TYPE
operator|>=
name|PNG_LIBPNG_BUILD_RC
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Attempt sane error recovery */
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|==
name|png_IDAT
condition|)
comment|/* don't steal from IDAT */
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"in use by IDAT"
argument_list|)
expr_stmt|;
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|{
name|int
name|level
init|=
name|png_ptr
operator|->
name|zlib_level
decl_stmt|;
name|int
name|method
init|=
name|png_ptr
operator|->
name|zlib_method
decl_stmt|;
name|int
name|windowBits
init|=
name|png_ptr
operator|->
name|zlib_window_bits
decl_stmt|;
name|int
name|memLevel
init|=
name|png_ptr
operator|->
name|zlib_mem_level
decl_stmt|;
name|int
name|strategy
decl_stmt|;
comment|/* set below */
name|int
name|ret
decl_stmt|;
comment|/* zlib return code */
if|if
condition|(
name|owner
operator|==
name|png_IDAT
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_CUSTOM_STRATEGY
operator|)
operator|!=
literal|0
condition|)
name|strategy
operator|=
name|png_ptr
operator|->
name|zlib_strategy
expr_stmt|;
elseif|else
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|!=
name|PNG_FILTER_NONE
condition|)
name|strategy
operator|=
name|PNG_Z_DEFAULT_STRATEGY
expr_stmt|;
else|else
name|strategy
operator|=
name|PNG_Z_DEFAULT_NOFILTER_STRATEGY
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
name|level
operator|=
name|png_ptr
operator|->
name|zlib_text_level
expr_stmt|;
name|method
operator|=
name|png_ptr
operator|->
name|zlib_text_method
expr_stmt|;
name|windowBits
operator|=
name|png_ptr
operator|->
name|zlib_text_window_bits
expr_stmt|;
name|memLevel
operator|=
name|png_ptr
operator|->
name|zlib_text_mem_level
expr_stmt|;
name|strategy
operator|=
name|png_ptr
operator|->
name|zlib_text_strategy
expr_stmt|;
else|#
directive|else
comment|/* If customization is not supported the values all come from the              * IDAT values except for the strategy, which is fixed to the              * default.  (This is the pre-1.6.0 behavior too, although it was              * implemented in a very different way.)              */
name|strategy
operator|=
name|Z_DEFAULT_STRATEGY
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Adjust 'windowBits' down if larger than 'data_size'; to stop this        * happening just pass 32768 as the data_size parameter.  Notice that zlib        * requires an extra 262 bytes in the window in addition to the data to be        * able to see the whole of the data, so if data_size+262 takes us to the        * next windowBits size we need to fix up the value later.  (Because even        * though deflate needs the extra window, inflate does not!)        */
if|if
condition|(
name|data_size
operator|<=
literal|16384
condition|)
block|{
comment|/* IMPLEMENTATION NOTE: this 'half_window_size' stuff is only here to           * work round a Microsoft Visual C misbehavior which, contrary to C-90,           * widens the result of the following shift to 64-bits if (and,           * apparently, only if) it is used in a test.           */
name|unsigned
name|int
name|half_window_size
init|=
literal|1U
operator|<<
operator|(
name|windowBits
operator|-
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|data_size
operator|+
literal|262
operator|<=
name|half_window_size
condition|)
block|{
name|half_window_size
operator|>>=
literal|1
expr_stmt|;
operator|--
name|windowBits
expr_stmt|;
block|}
block|}
comment|/* Check against the previous initialized values, if any. */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_INITIALIZED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|png_ptr
operator|->
name|zlib_set_level
operator|!=
name|level
operator|||
name|png_ptr
operator|->
name|zlib_set_method
operator|!=
name|method
operator|||
name|png_ptr
operator|->
name|zlib_set_window_bits
operator|!=
name|windowBits
operator|||
name|png_ptr
operator|->
name|zlib_set_mem_level
operator|!=
name|memLevel
operator|||
name|png_ptr
operator|->
name|zlib_set_strategy
operator|!=
name|strategy
operator|)
condition|)
block|{
if|if
condition|(
name|deflateEnd
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
operator|!=
name|Z_OK
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"deflateEnd failed (ignored)"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|flags
operator|&=
operator|~
name|PNG_FLAG_ZSTREAM_INITIALIZED
expr_stmt|;
block|}
comment|/* For safety clear out the input and output pointers (currently zlib        * doesn't use them on Init, but it might in the future).        */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
comment|/* Now initialize if required, setting the new parameters, otherwise just        * to a simple reset to the previous parameters.        */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZSTREAM_INITIALIZED
operator|)
operator|!=
literal|0
condition|)
name|ret
operator|=
name|deflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|deflateInit2
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|level
argument_list|,
name|method
argument_list|,
name|windowBits
argument_list|,
name|memLevel
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
name|png_ptr
operator|->
name|flags
operator||=
name|PNG_FLAG_ZSTREAM_INITIALIZED
expr_stmt|;
block|}
comment|/* The return code is from either deflateReset or deflateInit2; they have        * pretty much the same set of error codes.        */
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
name|png_ptr
operator|->
name|zowner
operator|=
name|owner
expr_stmt|;
else|else
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function
begin_comment
comment|/* Clean up (or trim) a linked list of compression buffers. */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_free_buffer_list
name|png_free_buffer_list
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_compression_bufferp
modifier|*
name|listp
parameter_list|)
block|{
name|png_compression_bufferp
name|list
init|=
operator|*
name|listp
decl_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
operator|*
name|listp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|png_compression_bufferp
name|next
init|=
name|list
operator|->
name|next
decl_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|list
operator|!=
name|NULL
condition|)
do|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
end_ifdef
begin_comment
comment|/* This pair of functions encapsulates the operation of (a) compressing a  * text string, and (b) issuing it later as a series of chunk data writes.  * The compression_state structure is shared context for these functions  * set up by the caller to allow access to the relevant local variables.  *  * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size  * temporary buffers.  From 1.6.0 it is retained in png_struct so that it will  * be correctly freed in the event of a write error (previous implementations  * just leaked memory.)  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|input
name|png_const_bytep
name|input
decl_stmt|;
comment|/* The uncompressed input data */
DECL|member|input_len
name|png_alloc_size_t
name|input_len
decl_stmt|;
comment|/* Its length */
DECL|member|output_len
name|png_uint_32
name|output_len
decl_stmt|;
comment|/* Final compressed length */
DECL|member|output
name|png_byte
name|output
index|[
literal|1024
index|]
decl_stmt|;
comment|/* First block of output */
block|}
DECL|typedef|compression_state
name|compression_state
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|png_text_compress_init
name|png_text_compress_init
parameter_list|(
name|compression_state
modifier|*
name|comp
parameter_list|,
name|png_const_bytep
name|input
parameter_list|,
name|png_alloc_size_t
name|input_len
parameter_list|)
block|{
name|comp
operator|->
name|input
operator|=
name|input
expr_stmt|;
name|comp
operator|->
name|input_len
operator|=
name|input_len
expr_stmt|;
name|comp
operator|->
name|output_len
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Compress the data in the compression state input */
end_comment
begin_function
specifier|static
name|int
DECL|function|png_text_compress
name|png_text_compress
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|,
name|compression_state
modifier|*
name|comp
parameter_list|,
name|png_uint_32
name|prefix_len
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* To find the length of the output it is necessary to first compress the     * input. The result is buffered rather than using the two-pass algorithm     * that is used on the inflate side; deflate is assumed to be slower and a     * PNG writer is assumed to have more memory available than a PNG reader.     *     * IMPLEMENTATION NOTE: the zlib API deflateBound() can be used to find an     * upper limit on the output size, but it is always bigger than the input     * size so it is likely to be more efficient to use this linked-list     * approach.     */
name|ret
operator|=
name|png_deflate_claim
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|,
name|comp
operator|->
name|input_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
return|return
name|ret
return|;
comment|/* Set up the compression buffers, we need a loop here to avoid overflowing a     * uInt.  Use ZLIB_IO_MAX to limit the input.  The output is always limited     * by the output buffer size, so there is no need to check that.  Since this     * is ANSI-C we know that an 'int', hence a uInt, is always at least 16 bits     * in size.     */
block|{
name|png_compression_bufferp
modifier|*
name|end
init|=
operator|&
name|png_ptr
operator|->
name|zbuffer_list
decl_stmt|;
name|png_alloc_size_t
name|input_len
init|=
name|comp
operator|->
name|input_len
decl_stmt|;
comment|/* may be zero! */
name|png_uint_32
name|output_len
decl_stmt|;
comment|/* zlib updates these for us: */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|PNGZ_INPUT_CAST
argument_list|(
name|comp
operator|->
name|input
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* Set below */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|comp
operator|->
name|output
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
sizeof|sizeof
name|comp
operator|->
name|output
operator|)
expr_stmt|;
name|output_len
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
do|do
block|{
name|uInt
name|avail_in
init|=
name|ZLIB_IO_MAX
decl_stmt|;
if|if
condition|(
name|avail_in
operator|>
name|input_len
condition|)
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|input_len
expr_stmt|;
name|input_len
operator|-=
name|avail_in
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|avail_in
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|png_compression_buffer
modifier|*
name|next
decl_stmt|;
comment|/* Chunk data is limited to 2^31 bytes in length, so the prefix              * length must be counted here.              */
if|if
condition|(
name|output_len
operator|+
name|prefix_len
operator|>
name|PNG_UINT_31_MAX
condition|)
block|{
name|ret
operator|=
name|Z_MEM_ERROR
expr_stmt|;
break|break;
block|}
comment|/* Need a new (malloc'ed) buffer, but there may be one present              * already.              */
name|next
operator|=
operator|*
name|end
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|next
operator|=
name|png_voidcast
argument_list|(
name|png_compression_bufferp
argument_list|,
name|png_malloc_base
argument_list|(
name|png_ptr
argument_list|,
name|PNG_COMPRESSION_BUFFER_SIZE
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|Z_MEM_ERROR
expr_stmt|;
break|break;
block|}
comment|/* Link in this buffer (so that it will be freed later) */
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|end
operator|=
name|next
expr_stmt|;
block|}
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|next
operator|->
name|output
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|png_ptr
operator|->
name|zbuffer_size
expr_stmt|;
name|output_len
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
comment|/* Move 'end' to the next buffer pointer. */
name|end
operator|=
operator|&
name|next
operator|->
name|next
expr_stmt|;
block|}
comment|/* Compress the data */
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|input_len
operator|>
literal|0
condition|?
name|Z_NO_FLUSH
else|:
name|Z_FINISH
argument_list|)
expr_stmt|;
comment|/* Claw back input data that was not consumed (because avail_in is           * reset above every time round the loop).           */
name|input_len
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* safety */
block|}
do|while
condition|(
name|ret
operator|==
name|Z_OK
condition|)
do|;
comment|/* There may be some space left in the last output buffer. This needs to        * be subtracted from output_len.        */
name|output_len
operator|-=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
comment|/* safety */
name|comp
operator|->
name|output_len
operator|=
name|output_len
expr_stmt|;
comment|/* Now double check the output length, put in a custom message if it is        * too long.  Otherwise ensure the z_stream::msg pointer is set to        * something.        */
if|if
condition|(
name|output_len
operator|+
name|prefix_len
operator|>=
name|PNG_UINT_31_MAX
condition|)
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|=
name|PNGZ_MSG_CAST
argument_list|(
literal|"compressed data too long"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|Z_MEM_ERROR
expr_stmt|;
block|}
else|else
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Reset zlib for another zTXt/iTXt or image data */
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
comment|/* The only success case is Z_STREAM_END, input_len must be 0; if not this        * is an internal error.        */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
operator|&&
name|input_len
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
comment|/* Fix up the deflate header, if required */
name|optimize_cmf
argument_list|(
name|comp
operator|->
name|output
argument_list|,
name|comp
operator|->
name|input_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* But Z_OK is returned, not Z_STREAM_END; this allows the claim           * function above to return Z_STREAM_END on an error (though it never           * does in the current versions of zlib.)           */
return|return
name|Z_OK
return|;
block|}
else|else
return|return
name|ret
return|;
block|}
block|}
end_function
begin_comment
comment|/* Ship the compressed text out via chunk writes */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_compressed_data_out
name|png_write_compressed_data_out
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|compression_state
modifier|*
name|comp
parameter_list|)
block|{
name|png_uint_32
name|output_len
init|=
name|comp
operator|->
name|output_len
decl_stmt|;
name|png_const_bytep
name|output
init|=
name|comp
operator|->
name|output
decl_stmt|;
name|png_uint_32
name|avail
init|=
operator|(
sizeof|sizeof
name|comp
operator|->
name|output
operator|)
decl_stmt|;
name|png_compression_buffer
modifier|*
name|next
init|=
name|png_ptr
operator|->
name|zbuffer_list
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|avail
operator|>
name|output_len
condition|)
name|avail
operator|=
name|output_len
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|output
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|output_len
operator|-=
name|avail
expr_stmt|;
if|if
condition|(
name|output_len
operator|==
literal|0
operator|||
name|next
operator|==
name|NULL
condition|)
break|break;
name|avail
operator|=
name|png_ptr
operator|->
name|zbuffer_size
expr_stmt|;
name|output
operator|=
name|next
operator|->
name|output
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
comment|/* This is an internal error; 'next' must have been NULL! */
if|if
condition|(
name|output_len
operator|>
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"error writing ancillary chunked compressed data"
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_COMPRESSED_TEXT */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_TEXT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_pCAL_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_iCCP_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_sPLT_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,  * and if invalid, correct the keyword rather than discarding the entire  * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in  * length, forbids leading or trailing whitespace, multiple internal spaces,  * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.  *  * The 'new_key' buffer must be 80 characters in size (for the keyword plus a  * trailing '\0').  If this routine returns 0 then there was no keyword, or a  * valid one could not be generated, and the caller must png_error.  */
end_comment
begin_function
specifier|static
name|png_uint_32
DECL|function|png_check_keyword
name|png_check_keyword
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_bytep
name|new_key
parameter_list|)
block|{
name|png_const_charp
name|orig_key
init|=
name|key
decl_stmt|;
name|png_uint_32
name|key_len
init|=
literal|0
decl_stmt|;
name|int
name|bad_character
init|=
literal|0
decl_stmt|;
name|int
name|space
init|=
literal|1
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_check_keyword"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
operator|*
name|new_key
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|*
name|key
operator|&&
name|key_len
operator|<
literal|79
condition|)
block|{
name|png_byte
name|ch
init|=
operator|(
name|png_byte
operator|)
operator|*
name|key
operator|++
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>
literal|32
operator|&&
name|ch
operator|<=
literal|126
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|161
comment|/*&& ch<= 255*/
operator|)
condition|)
operator|*
name|new_key
operator|++
operator|=
name|ch
operator|,
operator|++
name|key_len
operator|,
name|space
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
comment|/* A space or an invalid character when one wasn't seen immediately           * before; output just a space.           */
operator|*
name|new_key
operator|++
operator|=
literal|32
operator|,
operator|++
name|key_len
operator|,
name|space
operator|=
literal|1
expr_stmt|;
comment|/* If the character was not a space then it is invalid. */
if|if
condition|(
name|ch
operator|!=
literal|32
condition|)
name|bad_character
operator|=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bad_character
operator|==
literal|0
condition|)
name|bad_character
operator|=
name|ch
expr_stmt|;
comment|/* just skip it, record the first error */
block|}
if|if
condition|(
name|key_len
operator|>
literal|0
operator|&&
name|space
operator|!=
literal|0
condition|)
comment|/* trailing space */
block|{
operator|--
name|key_len
operator|,
operator|--
name|new_key
expr_stmt|;
if|if
condition|(
name|bad_character
operator|==
literal|0
condition|)
name|bad_character
operator|=
literal|32
expr_stmt|;
block|}
comment|/* Terminate the keyword */
operator|*
name|new_key
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|key_len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|PNG_WARNINGS_SUPPORTED
comment|/* Try to only output one warning per keyword: */
if|if
condition|(
operator|*
name|key
operator|!=
literal|0
condition|)
comment|/* keyword too long */
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"keyword truncated"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bad_character
operator|!=
literal|0
condition|)
block|{
name|PNG_WARNING_PARAMETERS
argument_list|(
argument|p
argument_list|)
name|png_warning_parameter
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|orig_key
argument_list|)
expr_stmt|;
name|png_warning_parameter_signed
argument_list|(
name|p
argument_list|,
literal|2
argument_list|,
name|PNG_NUMBER_FORMAT_02x
argument_list|,
name|bad_character
argument_list|)
expr_stmt|;
name|png_formatted_warning
argument_list|(
name|png_ptr
argument_list|,
name|p
argument_list|,
literal|"keyword \"@1\": bad character '0x@2'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WARNINGS */
return|return
name|key_len
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE_TEXT || WRITE_pCAL || WRITE_iCCP || WRITE_sPLT */
end_comment
begin_comment
comment|/* Write the IHDR chunk, and update the png_struct with the necessary  * information.  Note that the rest of this code depends upon this  * information being correct.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_IHDR
name|png_write_IHDR
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|width
parameter_list|,
name|png_uint_32
name|height
parameter_list|,
name|int
name|bit_depth
parameter_list|,
name|int
name|color_type
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|int
name|filter_type
parameter_list|,
name|int
name|interlace_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|13
index|]
decl_stmt|;
comment|/* Buffer to store the IHDR info */
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_IHDR"
argument_list|)
expr_stmt|;
comment|/* Check that we have valid input data from the application info */
switch|switch
condition|(
name|color_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
switch|switch
condition|(
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
case|case
literal|16
case|:
endif|#
directive|endif
name|png_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for grayscale image"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PNG_COLOR_TYPE_RGB
case|:
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
else|#
directive|else
if|if
condition|(
name|bit_depth
operator|!=
literal|8
condition|)
endif|#
directive|endif
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for RGB image"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
switch|switch
condition|(
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for paletted image"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
if|if
condition|(
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for grayscale+alpha image"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
else|#
directive|else
if|if
condition|(
name|bit_depth
operator|!=
literal|8
condition|)
endif|#
directive|endif
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for RGBA image"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image color type specified"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compression_type
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid compression type specified"
argument_list|)
expr_stmt|;
name|compression_type
operator|=
name|PNG_COMPRESSION_TYPE_BASE
expr_stmt|;
block|}
comment|/* Write filter_method 64 (intrapixel differencing) only if     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and     * 2. Libpng did not write a PNG signature (this filter_method is only     *    used in PNG datastreams that are embedded in MNG datastreams) and     * 3. The application called png_permit_mng_features with a mask that     *    included PNG_FLAG_MNG_FILTER_64 and     * 4. The filter_method is 64 and     * 5. The color_type is RGB or RGBA     */
if|if
condition|(
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
operator|!
operator|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|&&
operator|(
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
operator|)
operator|&&
endif|#
directive|endif
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid filter type specified"
argument_list|)
expr_stmt|;
name|filter_type
operator|=
name|PNG_FILTER_TYPE_BASE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
if|if
condition|(
name|interlace_type
operator|!=
name|PNG_INTERLACE_NONE
operator|&&
name|interlace_type
operator|!=
name|PNG_INTERLACE_ADAM7
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid interlace type specified"
argument_list|)
expr_stmt|;
name|interlace_type
operator|=
name|PNG_INTERLACE_ADAM7
expr_stmt|;
block|}
else|#
directive|else
name|interlace_type
operator|=
name|PNG_INTERLACE_NONE
expr_stmt|;
endif|#
directive|endif
comment|/* Save the relevant information */
name|png_ptr
operator|->
name|bit_depth
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|color_type
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
name|png_ptr
operator|->
name|interlaced
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
name|png_ptr
operator|->
name|filter_type
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|compression_type
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
name|png_ptr
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|png_ptr
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|png_ptr
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|bit_depth
operator|*
name|png_ptr
operator|->
name|channels
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* Set the usr info, so any transformations can modify it */
name|png_ptr
operator|->
name|usr_width
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
name|png_ptr
operator|->
name|usr_bit_depth
operator|=
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|usr_channels
operator|=
name|png_ptr
operator|->
name|channels
expr_stmt|;
comment|/* Pack the header information into the buffer */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
name|buf
index|[
literal|10
index|]
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
name|buf
index|[
literal|11
index|]
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
name|buf
index|[
literal|12
index|]
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
comment|/* Write the chunk */
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_IHDR
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|13
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|)
operator|==
name|PNG_NO_FILTERS
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|||
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_NONE
expr_stmt|;
else|else
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_ALL_FILTERS
expr_stmt|;
block|}
name|png_ptr
operator|->
name|mode
operator|=
name|PNG_HAVE_IHDR
expr_stmt|;
comment|/* not READY_FOR_ZTXT */
block|}
end_function
begin_comment
comment|/* Write the palette.  We are careful not to trust png_color to be in the  * correct order for PNG, so people can redefine it to any convenient  * structure.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_PLTE
name|png_write_PLTE
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_colorp
name|palette
parameter_list|,
name|png_uint_32
name|num_pal
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
name|png_const_colorp
name|pal_ptr
decl_stmt|;
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_EMPTY_PLTE
operator|)
operator|==
literal|0
operator|&&
endif|#
directive|endif
name|num_pal
operator|==
literal|0
operator|)
operator|||
name|num_pal
operator|>
literal|256
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of colors in palette"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of colors in palette"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring request to write a PLTE chunk in grayscale PNG"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|num_palette
operator|=
operator|(
name|png_uint_16
operator|)
name|num_pal
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"num_palette = %d"
argument_list|,
name|png_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_PLTE
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_pal
operator|*
literal|3
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pal_ptr
operator|=
name|palette
init|;
name|i
operator|<
name|num_pal
condition|;
name|i
operator|++
operator|,
name|pal_ptr
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|pal_ptr
operator|->
name|red
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|pal_ptr
operator|->
name|green
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|pal_ptr
operator|->
name|blue
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|3
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* This is a little slower but some buggy compilers need to do this     * instead     */
name|pal_ptr
operator|=
name|palette
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pal
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|pal_ptr
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|pal_ptr
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|pal_ptr
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is similar to png_text_compress, above, except that it does not require  * all of the data at once and, instead of buffering the compressed result,  * writes it as IDAT chunks.  Unlike png_text_compress it *can* png_error out  * because it calls the write interface.  As a result it does its own error  * reporting and does not return an error code.  In the event of error it will  * just call png_error.  The input data length may exceed 32-bits.  The 'flush'  * parameter is exactly the same as that to deflate, with the following  * meanings:  *  * Z_NO_FLUSH: normal incremental output of compressed data  * Z_SYNC_FLUSH: do a SYNC_FLUSH, used by png_write_flush  * Z_FINISH: this is the end of the input, do a Z_FINISH and clean up  *  * The routine manages the acquire and release of the png_ptr->zstream by  * checking and (at the end) clearing png_ptr->zowner; it does some sanity  * checks on the 'mode' flags while doing this.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_compress_IDAT
name|png_compress_IDAT
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|input
parameter_list|,
name|png_alloc_size_t
name|input_len
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zowner
operator|!=
name|png_IDAT
condition|)
block|{
comment|/* First time.   Ensure we have a temporary buffer for compression and        * trim the buffer list if it has more than one entry to free memory.        * If 'WRITE_COMPRESSED_TEXT' is not set the list will never have been        * created at this point, but the check here is quick and safe.        */
if|if
condition|(
name|png_ptr
operator|->
name|zbuffer_list
operator|==
name|NULL
condition|)
block|{
name|png_ptr
operator|->
name|zbuffer_list
operator|=
name|png_voidcast
argument_list|(
name|png_compression_bufferp
argument_list|,
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|PNG_COMPRESSION_BUFFER_SIZE
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zbuffer_list
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|png_free_buffer_list
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_ptr
operator|->
name|zbuffer_list
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* It is a terminal error if we can't claim the zstream. */
if|if
condition|(
name|png_deflate_claim
argument_list|(
name|png_ptr
argument_list|,
name|png_IDAT
argument_list|,
name|png_image_size
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
operator|!=
name|Z_OK
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
comment|/* The output state is maintained in png_ptr->zstream, so it must be        * initialized here after the claim.        */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuffer_list
operator|->
name|output
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|png_ptr
operator|->
name|zbuffer_size
expr_stmt|;
block|}
comment|/* Now loop reading and writing until all the input is consumed or an error     * terminates the operation.  The _out values are maintained across calls to     * this function, but the input must be reset each time.     */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|PNGZ_INPUT_CAST
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* set below */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* INPUT: from the row data */
name|uInt
name|avail
init|=
name|ZLIB_IO_MAX
decl_stmt|;
if|if
condition|(
name|avail
operator|>
name|input_len
condition|)
name|avail
operator|=
operator|(
name|uInt
operator|)
name|input_len
expr_stmt|;
comment|/* safe because of the check */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|avail
expr_stmt|;
name|input_len
operator|-=
name|avail
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|input_len
operator|>
literal|0
condition|?
name|Z_NO_FLUSH
else|:
name|flush
argument_list|)
expr_stmt|;
comment|/* Include as-yet unconsumed input */
name|input_len
operator|+=
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* OUTPUT: write complete IDAT chunks when avail_out drops to zero. Note        * that these two zstream fields are preserved across the calls, therefore        * there is no need to set these up on entry to the loop.        */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|png_bytep
name|data
init|=
name|png_ptr
operator|->
name|zbuffer_list
operator|->
name|output
decl_stmt|;
name|uInt
name|size
init|=
name|png_ptr
operator|->
name|zbuffer_size
decl_stmt|;
comment|/* Write an IDAT containing the data then reset the buffer.  The           * first IDAT may need deflate header optimization.           */
ifdef|#
directive|ifdef
name|PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|compression_type
operator|==
name|PNG_COMPRESSION_TYPE_BASE
condition|)
name|optimize_cmf
argument_list|(
name|data
argument_list|,
name|png_image_size
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_IDAT
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|data
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
comment|/* For SYNC_FLUSH or FINISH it is essential to keep calling zlib with           * the same flush parameter until it has finished output, for NO_FLUSH           * it doesn't matter.           */
if|if
condition|(
name|ret
operator|==
name|Z_OK
operator|&&
name|flush
operator|!=
name|Z_NO_FLUSH
condition|)
continue|continue;
block|}
comment|/* The order of these checks doesn't matter much; it just affects which        * possible error might be detected if multiple things go wrong at once.        */
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
comment|/* most likely return code! */
block|{
comment|/* If all the input has been consumed then just return.  If Z_FINISH           * was used as the flush parameter something has gone wrong if we get           * here.           */
if|if
condition|(
name|input_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flush
operator|==
name|Z_FINISH
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Z_OK on Z_FINISH with output space"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
operator|&&
name|flush
operator|==
name|Z_FINISH
condition|)
block|{
comment|/* This is the end of the IDAT data; any pending output must be           * flushed.  For small PNG files we may still be at the beginning.           */
name|png_bytep
name|data
init|=
name|png_ptr
operator|->
name|zbuffer_list
operator|->
name|output
decl_stmt|;
name|uInt
name|size
init|=
name|png_ptr
operator|->
name|zbuffer_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|==
literal|0
operator|&&
name|png_ptr
operator|->
name|compression_type
operator|==
name|PNG_COMPRESSION_TYPE_BASE
condition|)
name|optimize_cmf
argument_list|(
name|data
argument_list|,
name|png_image_size
argument_list|(
name|png_ptr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_IDAT
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
operator||
name|PNG_AFTER_IDAT
expr_stmt|;
name|png_ptr
operator|->
name|zowner
operator|=
literal|0
expr_stmt|;
comment|/* Release the stream */
return|return;
block|}
else|else
block|{
comment|/* This is an error condition. */
name|png_zstream_error
argument_list|(
name|png_ptr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Write an IEND chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_IEND
name|png_write_IEND
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_IEND"
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_IEND
argument_list|,
name|NULL
argument_list|,
operator|(
name|png_size_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IEND
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_gAMA_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a gAMA chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_gAMA_fixed
name|png_write_gAMA_fixed
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|file_gamma
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_gAMA"
argument_list|)
expr_stmt|;
comment|/* file_gamma is saved in 1/100,000ths */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
operator|(
name|png_uint_32
operator|)
name|file_gamma
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_gAMA
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sRGB_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a sRGB chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sRGB
name|png_write_sRGB
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|srgb_intent
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sRGB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srgb_intent
operator|>=
name|PNG_sRGB_INTENT_LAST
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sRGB rendering intent specified"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|srgb_intent
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_sRGB
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_iCCP_SUPPORTED
end_ifdef
begin_comment
comment|/* Write an iCCP chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_iCCP
name|png_write_iCCP
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|png_const_bytep
name|profile
parameter_list|)
block|{
name|png_uint_32
name|name_len
decl_stmt|;
name|png_uint_32
name|profile_len
decl_stmt|;
name|png_byte
name|new_name
index|[
literal|81
index|]
decl_stmt|;
comment|/* 1 byte for the compression byte */
name|compression_state
name|comp
decl_stmt|;
name|png_uint_32
name|temp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_iCCP"
argument_list|)
expr_stmt|;
comment|/* These are all internal problems: the profile should have been checked     * before when it was stored.     */
if|if
condition|(
name|profile
operator|==
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"No profile for iCCP chunk"
argument_list|)
expr_stmt|;
comment|/* internal error */
name|profile_len
operator|=
name|png_get_uint_32
argument_list|(
name|profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_len
operator|<
literal|132
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ICC profile too short"
argument_list|)
expr_stmt|;
name|temp
operator|=
call|(
name|png_uint_32
call|)
argument_list|(
operator|*
operator|(
name|profile
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|3
operator|&&
operator|(
name|profile_len
operator|&
literal|0x03
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"ICC profile length invalid (not a multiple of 4)"
argument_list|)
expr_stmt|;
block|{
name|png_uint_32
name|embedded_profile_len
init|=
name|png_get_uint_32
argument_list|(
name|profile
argument_list|)
decl_stmt|;
if|if
condition|(
name|profile_len
operator|!=
name|embedded_profile_len
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Profile length does not match profile"
argument_list|)
expr_stmt|;
block|}
name|name_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"iCCP: invalid keyword"
argument_list|)
expr_stmt|;
name|new_name
index|[
operator|++
name|name_len
index|]
operator|=
name|PNG_COMPRESSION_TYPE_BASE
expr_stmt|;
comment|/* Make sure we include the NULL after the name and the compression type */
operator|++
name|name_len
expr_stmt|;
name|png_text_compress_init
argument_list|(
operator|&
name|comp
argument_list|,
name|profile
argument_list|,
name|profile_len
argument_list|)
expr_stmt|;
comment|/* Allow for keyword terminator and compression byte */
if|if
condition|(
name|png_text_compress
argument_list|(
name|png_ptr
argument_list|,
name|png_iCCP
argument_list|,
operator|&
name|comp
argument_list|,
name|name_len
argument_list|)
operator|!=
name|Z_OK
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_iCCP
argument_list|,
name|name_len
operator|+
name|comp
operator|.
name|output_len
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|new_name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|png_write_compressed_data_out
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|comp
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sPLT_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a sPLT chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sPLT
name|png_write_sPLT
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_sPLT_tp
name|spalette
parameter_list|)
block|{
name|png_uint_32
name|name_len
decl_stmt|;
name|png_byte
name|new_name
index|[
literal|80
index|]
decl_stmt|;
name|png_byte
name|entrybuf
index|[
literal|10
index|]
decl_stmt|;
name|png_size_t
name|entry_size
init|=
operator|(
name|spalette
operator|->
name|depth
operator|==
literal|8
condition|?
literal|6
else|:
literal|10
operator|)
decl_stmt|;
name|png_size_t
name|palette_size
init|=
name|entry_size
operator|*
name|spalette
operator|->
name|nentries
decl_stmt|;
name|png_sPLT_entryp
name|ep
decl_stmt|;
ifndef|#
directive|ifndef
name|PNG_POINTER_INDEXING_SUPPORTED
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sPLT"
argument_list|)
expr_stmt|;
name|name_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|spalette
operator|->
name|name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"sPLT: invalid keyword"
argument_list|)
expr_stmt|;
comment|/* Make sure we include the NULL after the name */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_sPLT
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|name_len
operator|+
literal|2
operator|+
name|palette_size
argument_list|)
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|new_name
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|name_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|spalette
operator|->
name|depth
argument_list|,
operator|(
name|png_size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Loop through each palette entry, writing appropriately */
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|ep
operator|=
name|spalette
operator|->
name|entries
init|;
name|ep
operator|<
name|spalette
operator|->
name|entries
operator|+
name|spalette
operator|->
name|nentries
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|spalette
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
name|entrybuf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|red
expr_stmt|;
name|entrybuf
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|green
expr_stmt|;
name|entrybuf
index|[
literal|2
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|blue
expr_stmt|;
name|entrybuf
index|[
literal|3
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|alpha
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|0
argument_list|,
name|ep
operator|->
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|2
argument_list|,
name|ep
operator|->
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
operator|->
name|blue
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|6
argument_list|,
name|ep
operator|->
name|alpha
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|8
argument_list|,
name|ep
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|entrybuf
argument_list|,
name|entry_size
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ep
operator|=
name|spalette
operator|->
name|entries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|>
name|spalette
operator|->
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spalette
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
name|entrybuf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|entrybuf
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|entrybuf
index|[
literal|2
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
name|entrybuf
index|[
literal|3
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|alpha
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|frequency
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|0
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|2
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|6
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|alpha
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|8
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|frequency
argument_list|)
expr_stmt|;
block|}
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|entrybuf
argument_list|,
name|entry_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sBIT_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the sBIT chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sBIT
name|png_write_sBIT
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_color_8p
name|sbit
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_size_t
name|size
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sBIT"
argument_list|)
expr_stmt|;
comment|/* Make sure we don't depend upon the order of PNG_COLOR_8 */
if|if
condition|(
operator|(
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_byte
name|maxbits
decl_stmt|;
name|maxbits
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|?
literal|8
else|:
name|png_ptr
operator|->
name|usr_bit_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbit
operator|->
name|red
operator|==
literal|0
operator|||
name|sbit
operator|->
name|red
operator|>
name|maxbits
operator|||
name|sbit
operator|->
name|green
operator|==
literal|0
operator|||
name|sbit
operator|->
name|green
operator|>
name|maxbits
operator|||
name|sbit
operator|->
name|blue
operator|==
literal|0
operator|||
name|sbit
operator|->
name|blue
operator|>
name|maxbits
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sBIT depth specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|sbit
operator|->
name|red
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|sbit
operator|->
name|green
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|sbit
operator|->
name|blue
expr_stmt|;
name|size
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sbit
operator|->
name|gray
operator|==
literal|0
operator|||
name|sbit
operator|->
name|gray
operator|>
name|png_ptr
operator|->
name|usr_bit_depth
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sBIT depth specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|sbit
operator|->
name|gray
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sbit
operator|->
name|alpha
operator|==
literal|0
operator|||
name|sbit
operator|->
name|alpha
operator|>
name|png_ptr
operator|->
name|usr_bit_depth
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sBIT depth specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
name|size
operator|++
index|]
operator|=
name|sbit
operator|->
name|alpha
expr_stmt|;
block|}
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_sBIT
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_cHRM_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the cHRM chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_cHRM_fixed
name|png_write_cHRM_fixed
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
specifier|const
name|png_xy
modifier|*
name|xy
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_cHRM"
argument_list|)
expr_stmt|;
comment|/* Each value is saved in 1/100,000ths */
name|png_save_int_32
argument_list|(
name|buf
argument_list|,
name|xy
operator|->
name|whitex
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|xy
operator|->
name|whitey
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
name|xy
operator|->
name|redx
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|12
argument_list|,
name|xy
operator|->
name|redy
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
name|xy
operator|->
name|greenx
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|20
argument_list|,
name|xy
operator|->
name|greeny
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|24
argument_list|,
name|xy
operator|->
name|bluex
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|28
argument_list|,
name|xy
operator|->
name|bluey
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_cHRM
argument_list|,
name|buf
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_tRNS_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the tRNS chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_tRNS
name|png_write_tRNS
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|trans_alpha
parameter_list|,
name|png_const_color_16p
name|tran
parameter_list|,
name|int
name|num_trans
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_tRNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|num_trans
operator|<=
literal|0
operator|||
name|num_trans
operator|>
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of transparent colors specified"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write the chunk out as it is */
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tRNS
argument_list|,
name|trans_alpha
argument_list|,
operator|(
name|png_size_t
operator|)
name|num_trans
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
comment|/* One 16 bit value */
if|if
condition|(
name|tran
operator|->
name|gray
operator|>=
operator|(
literal|1
operator|<<
name|png_ptr
operator|->
name|bit_depth
operator|)
condition|)
block|{
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write tRNS chunk out-of-range for bit_depth"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|tran
operator|->
name|gray
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tRNS
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
comment|/* Three 16 bit values */
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|tran
operator|->
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|tran
operator|->
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|tran
operator|->
name|blue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
operator|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tRNS
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_app_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't write tRNS with an alpha channel"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_bKGD_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the background chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_bKGD
name|png_write_bKGD
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_color_16p
name|back
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_bKGD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
operator|(
name|png_ptr
operator|->
name|num_palette
operator|!=
literal|0
operator|||
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_EMPTY_PLTE
operator|)
operator|==
literal|0
operator|)
operator|&&
endif|#
directive|endif
name|back
operator|->
name|index
operator|>=
name|png_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid background palette index"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|back
operator|->
name|index
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_bKGD
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|back
operator|->
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|back
operator|->
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|back
operator|->
name|blue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
operator|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_bKGD
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|back
operator|->
name|gray
operator|>=
operator|(
literal|1
operator|<<
name|png_ptr
operator|->
name|bit_depth
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write bKGD chunk out-of-range for bit_depth"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|back
operator|->
name|gray
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_bKGD
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_hIST_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the histogram */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_hIST
name|png_write_hIST
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_uint_16p
name|hist
parameter_list|,
name|int
name|num_hist
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_hIST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_hist
operator|>
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_debug2
argument_list|(
literal|3
argument_list|,
literal|"num_hist = %d, num_palette = %d"
argument_list|,
name|num_hist
argument_list|,
name|png_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of histogram entries specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_hIST
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_hist
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hist
condition|;
name|i
operator|++
control|)
block|{
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|hist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_tEXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a tEXt chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_tEXt
name|png_write_tEXt
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_const_charp
name|text
parameter_list|,
name|png_size_t
name|text_len
parameter_list|)
block|{
name|png_uint_32
name|key_len
decl_stmt|;
name|png_byte
name|new_key
index|[
literal|80
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_tEXt"
argument_list|)
expr_stmt|;
name|key_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_len
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"tEXt: invalid keyword"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
operator|||
operator|*
name|text
operator|==
literal|'\0'
condition|)
name|text_len
operator|=
literal|0
expr_stmt|;
else|else
name|text_len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_len
operator|>
name|PNG_UINT_31_MAX
operator|-
operator|(
name|key_len
operator|+
literal|1
operator|)
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"tEXt: text too long"
argument_list|)
expr_stmt|;
comment|/* Make sure we include the 0 after the key */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_tEXt
argument_list|,
call|(
name|png_uint_32
call|)
comment|/*checked above*/
argument_list|(
name|key_len
operator|+
name|text_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     * We leave it to the application to meet PNG-1.0 requirements on the     * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of     * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.     * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.     */
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|,
name|key_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_len
operator|!=
literal|0
condition|)
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_zTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a compressed text chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_zTXt
name|png_write_zTXt
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_const_charp
name|text
parameter_list|,
name|int
name|compression
parameter_list|)
block|{
name|png_uint_32
name|key_len
decl_stmt|;
name|png_byte
name|new_key
index|[
literal|81
index|]
decl_stmt|;
name|compression_state
name|comp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_zTXt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
block|{
name|png_write_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|,
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|compression
operator|!=
name|PNG_TEXT_COMPRESSION_zTXt
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zTXt: invalid compression type"
argument_list|)
expr_stmt|;
name|key_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_len
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zTXt: invalid keyword"
argument_list|)
expr_stmt|;
comment|/* Add the compression method and 1 for the keyword separator. */
name|new_key
index|[
operator|++
name|key_len
index|]
operator|=
name|PNG_COMPRESSION_TYPE_BASE
expr_stmt|;
operator|++
name|key_len
expr_stmt|;
comment|/* Compute the compressed data; do it now for the length */
name|png_text_compress_init
argument_list|(
operator|&
name|comp
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|text
argument_list|,
name|text
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_text_compress
argument_list|(
name|png_ptr
argument_list|,
name|png_zTXt
argument_list|,
operator|&
name|comp
argument_list|,
name|key_len
argument_list|)
operator|!=
name|Z_OK
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
comment|/* Write start of chunk */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_zTXt
argument_list|,
name|key_len
operator|+
name|comp
operator|.
name|output_len
argument_list|)
expr_stmt|;
comment|/* Write key */
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Write the compressed data */
name|png_write_compressed_data_out
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|comp
argument_list|)
expr_stmt|;
comment|/* Close the chunk */
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_iTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Write an iTXt chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_iTXt
name|png_write_iTXt
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|compression
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_const_charp
name|lang
parameter_list|,
name|png_const_charp
name|lang_key
parameter_list|,
name|png_const_charp
name|text
parameter_list|)
block|{
name|png_uint_32
name|key_len
decl_stmt|,
name|prefix_len
decl_stmt|;
name|png_size_t
name|lang_len
decl_stmt|,
name|lang_key_len
decl_stmt|;
name|png_byte
name|new_key
index|[
literal|82
index|]
decl_stmt|;
name|compression_state
name|comp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_iTXt"
argument_list|)
expr_stmt|;
name|key_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_len
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"iTXt: invalid keyword"
argument_list|)
expr_stmt|;
comment|/* Set the compression flag */
switch|switch
condition|(
name|compression
condition|)
block|{
case|case
name|PNG_ITXT_COMPRESSION_NONE
case|:
case|case
name|PNG_TEXT_COMPRESSION_NONE
case|:
name|compression
operator|=
name|new_key
index|[
operator|++
name|key_len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no compression */
break|break;
case|case
name|PNG_TEXT_COMPRESSION_zTXt
case|:
case|case
name|PNG_ITXT_COMPRESSION_zTXt
case|:
name|compression
operator|=
name|new_key
index|[
operator|++
name|key_len
index|]
operator|=
literal|1
expr_stmt|;
comment|/* compressed */
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"iTXt: invalid compression"
argument_list|)
expr_stmt|;
block|}
name|new_key
index|[
operator|++
name|key_len
index|]
operator|=
name|PNG_COMPRESSION_TYPE_BASE
expr_stmt|;
operator|++
name|key_len
expr_stmt|;
comment|/* for the keywod separator */
comment|/* We leave it to the application to meet PNG-1.0 requirements on the     * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of     * any non-Latin-1 characters except for NEWLINE.  ISO PNG, however,     * specifies that the text is UTF-8 and this really doesn't require any     * checking.     *     * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.     *     * TODO: validate the language tag correctly (see the spec.)     */
if|if
condition|(
name|lang
operator|==
name|NULL
condition|)
name|lang
operator|=
literal|""
expr_stmt|;
comment|/* empty language is valid */
name|lang_len
operator|=
name|strlen
argument_list|(
name|lang
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lang_key
operator|==
name|NULL
condition|)
name|lang_key
operator|=
literal|""
expr_stmt|;
comment|/* may be empty */
name|lang_key_len
operator|=
name|strlen
argument_list|(
name|lang_key
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
name|text
operator|=
literal|""
expr_stmt|;
comment|/* may be empty */
name|prefix_len
operator|=
name|key_len
expr_stmt|;
if|if
condition|(
name|lang_len
operator|>
name|PNG_UINT_31_MAX
operator|-
name|prefix_len
condition|)
name|prefix_len
operator|=
name|PNG_UINT_31_MAX
expr_stmt|;
else|else
name|prefix_len
operator|=
call|(
name|png_uint_32
call|)
argument_list|(
name|prefix_len
operator|+
name|lang_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang_key_len
operator|>
name|PNG_UINT_31_MAX
operator|-
name|prefix_len
condition|)
name|prefix_len
operator|=
name|PNG_UINT_31_MAX
expr_stmt|;
else|else
name|prefix_len
operator|=
call|(
name|png_uint_32
call|)
argument_list|(
name|prefix_len
operator|+
name|lang_key_len
argument_list|)
expr_stmt|;
name|png_text_compress_init
argument_list|(
operator|&
name|comp
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compression
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|png_text_compress
argument_list|(
name|png_ptr
argument_list|,
name|png_iTXt
argument_list|,
operator|&
name|comp
argument_list|,
name|prefix_len
argument_list|)
operator|!=
name|Z_OK
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|comp
operator|.
name|input_len
operator|>
name|PNG_UINT_31_MAX
operator|-
name|prefix_len
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"iTXt: uncompressed text too long"
argument_list|)
expr_stmt|;
comment|/* So the string will fit in a chunk: */
name|comp
operator|.
name|output_len
operator|=
operator|(
name|png_uint_32
operator|)
comment|/*SAFE*/
name|comp
operator|.
name|input_len
expr_stmt|;
block|}
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_iTXt
argument_list|,
name|comp
operator|.
name|output_len
operator|+
name|prefix_len
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|lang
argument_list|,
name|lang_len
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|lang_key
argument_list|,
name|lang_key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|compression
operator|!=
literal|0
condition|)
name|png_write_compressed_data_out
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|comp
argument_list|)
expr_stmt|;
else|else
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|text
argument_list|,
name|comp
operator|.
name|output_len
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_oFFs_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the oFFs chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_oFFs
name|png_write_oFFs
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_int_32
name|x_offset
parameter_list|,
name|png_int_32
name|y_offset
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_oFFs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit_type
operator|>=
name|PNG_OFFSET_LAST
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unrecognized unit type for oFFs chunk"
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
argument_list|,
name|x_offset
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|y_offset
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_oFFs
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|9
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_pCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the pCAL chunk (described in the PNG extensions document) */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_pCAL
name|png_write_pCAL
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_charp
name|purpose
parameter_list|,
name|png_int_32
name|X0
parameter_list|,
name|png_int_32
name|X1
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|nparams
parameter_list|,
name|png_const_charp
name|units
parameter_list|,
name|png_charpp
name|params
parameter_list|)
block|{
name|png_uint_32
name|purpose_len
decl_stmt|;
name|png_size_t
name|units_len
decl_stmt|,
name|total_len
decl_stmt|;
name|png_size_tp
name|params_len
decl_stmt|;
name|png_byte
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|png_byte
name|new_purpose
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in png_write_pCAL (%d parameters)"
argument_list|,
name|nparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|PNG_EQUATION_LAST
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Unrecognized equation type for pCAL chunk"
argument_list|)
expr_stmt|;
name|purpose_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|purpose
argument_list|,
name|new_purpose
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose_len
operator|==
literal|0
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"pCAL: invalid keyword"
argument_list|)
expr_stmt|;
operator|++
name|purpose_len
expr_stmt|;
comment|/* terminator */
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"pCAL purpose length = %d"
argument_list|,
operator|(
name|int
operator|)
name|purpose_len
argument_list|)
expr_stmt|;
name|units_len
operator|=
name|strlen
argument_list|(
name|units
argument_list|)
operator|+
operator|(
name|nparams
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"pCAL units length = %d"
argument_list|,
operator|(
name|int
operator|)
name|units_len
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|purpose_len
operator|+
name|units_len
operator|+
literal|10
expr_stmt|;
name|params_len
operator|=
operator|(
name|png_size_tp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_alloc_size_t
call|)
argument_list|(
name|nparams
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|png_size_t
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the length of each parameter, making sure we don't count the     * null terminator for the last parameter.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|params_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
operator|+
operator|(
name|i
operator|==
name|nparams
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|png_debug2
argument_list|(
literal|3
argument_list|,
literal|"pCAL parameter %d length = %lu"
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|params_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|total_len
operator|+=
name|params_len
index|[
name|i
index|]
expr_stmt|;
block|}
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"pCAL total length = %d"
argument_list|,
operator|(
name|int
operator|)
name|total_len
argument_list|)
expr_stmt|;
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_pCAL
argument_list|,
operator|(
name|png_uint_32
operator|)
name|total_len
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|new_purpose
argument_list|,
name|purpose_len
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
argument_list|,
name|X0
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|X1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|type
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
operator|(
name|png_byte
operator|)
name|nparams
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|10
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|units
argument_list|,
operator|(
name|png_size_t
operator|)
name|units_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|params
index|[
name|i
index|]
argument_list|,
name|params_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|params_len
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the sCAL chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sCAL_s
name|png_write_sCAL_s
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|png_const_charp
name|width
parameter_list|,
name|png_const_charp
name|height
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|png_size_t
name|wlen
decl_stmt|,
name|hlen
decl_stmt|,
name|total_len
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sCAL_s"
argument_list|)
expr_stmt|;
name|wlen
operator|=
name|strlen
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|strlen
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|wlen
operator|+
name|hlen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|total_len
operator|>
literal|64
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't write sCAL (buffer too small)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|unit
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|width
argument_list|,
name|wlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Append the '\0' here */
name|memcpy
argument_list|(
name|buf
operator|+
name|wlen
operator|+
literal|2
argument_list|,
name|height
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* Do NOT append the '\0' here */
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"sCAL total length = %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|total_len
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_sCAL
argument_list|,
name|buf
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_pHYs_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the pHYs chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_pHYs
name|png_write_pHYs
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_uint_32
name|x_pixels_per_unit
parameter_list|,
name|png_uint_32
name|y_pixels_per_unit
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_pHYs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit_type
operator|>=
name|PNG_RESOLUTION_LAST
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unrecognized unit type for pHYs chunk"
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|x_pixels_per_unit
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|y_pixels_per_unit
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_pHYs
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|9
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_tIME_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the tIME chunk.  Use either png_convert_from_struct_tm()  * or png_convert_from_time_t(), or fill in the structure yourself.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_tIME
name|png_write_tIME
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_const_timep
name|mod_time
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|7
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_tIME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_time
operator|->
name|month
operator|>
literal|12
operator|||
name|mod_time
operator|->
name|month
operator|<
literal|1
operator|||
name|mod_time
operator|->
name|day
operator|>
literal|31
operator|||
name|mod_time
operator|->
name|day
operator|<
literal|1
operator|||
name|mod_time
operator|->
name|hour
operator|>
literal|23
operator|||
name|mod_time
operator|->
name|second
operator|>
literal|60
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid time specified for tIME chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|mod_time
operator|->
name|year
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|mod_time
operator|->
name|month
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|mod_time
operator|->
name|day
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|mod_time
operator|->
name|hour
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|mod_time
operator|->
name|minute
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|mod_time
operator|->
name|second
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tIME
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|7
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Initializes the row writing capability of libpng */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_start_row
name|png_write_start_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
endif|#
directive|endif
name|png_alloc_size_t
name|buf_size
decl_stmt|;
name|int
name|usr_pixel_depth
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_start_row"
argument_list|)
expr_stmt|;
name|usr_pixel_depth
operator|=
name|png_ptr
operator|->
name|usr_channels
operator|*
name|png_ptr
operator|->
name|usr_bit_depth
expr_stmt|;
name|buf_size
operator|=
name|PNG_ROWBYTES
argument_list|(
name|usr_pixel_depth
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 1.5.6: added to allow checking in the row write code. */
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
name|png_ptr
operator|->
name|maximum_pixel_depth
operator|=
operator|(
name|png_byte
operator|)
name|usr_pixel_depth
expr_stmt|;
comment|/* Set up row buffer */
name|png_ptr
operator|->
name|row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
comment|/* Set up filtering buffer, if using this filter */
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_SUB
condition|)
block|{
name|png_ptr
operator|->
name|sub_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sub_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_SUB
expr_stmt|;
block|}
comment|/* We only need to keep the previous row if we are using one of these. */
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
operator|(
name|PNG_FILTER_AVG
operator||
name|PNG_FILTER_UP
operator||
name|PNG_FILTER_PAETH
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Set up previous row buffer */
name|png_ptr
operator|->
name|prev_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_UP
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|up_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|up_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_UP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_AVG
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|avg_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|avg_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_AVG
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_PAETH
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|paeth_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|paeth_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_PAETH
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* WRITE_FILTER */
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* If interlaced, we need to set up width and height of pass */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|==
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
literal|0
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
literal|0
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|usr_width
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
literal|0
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
literal|0
index|]
operator|)
operator|/
name|png_pass_inc
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|usr_width
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|usr_width
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Internal use only.  Called when finished processing a row of data. */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_finish_row
name|png_write_finish_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_finish_row"
argument_list|)
expr_stmt|;
comment|/* Next row */
name|png_ptr
operator|->
name|row_number
operator|++
expr_stmt|;
comment|/* See if we are done */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|<
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* If interlaced, go to next pass */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|row_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Loop until we find a non-zero width or height pass */
do|do
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>=
literal|7
condition|)
break|break;
name|png_ptr
operator|->
name|usr_width
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
do|while
condition|(
name|png_ptr
operator|->
name|usr_width
operator|==
literal|0
operator|||
name|png_ptr
operator|->
name|num_rows
operator|==
literal|0
condition|)
do|;
block|}
comment|/* Reset the row above the image for the next pass */
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|7
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|usr_channels
operator|*
name|png_ptr
operator|->
name|usr_bit_depth
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* If we get here, we've just written the last row, so we need       to flush the compressor */
name|png_compress_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
end_ifdef
begin_comment
comment|/* Pick out the correct pixels for the interlace pass.  * The basic idea here is to go through the row with a source  * pointer and a destination pointer (sp and dp), and copy the  * correct pixels for the pass.  As the row gets compacted,  * sp will always be>= dp, so we should never overwrite anything.  * See the default: case for the easiest code to understand.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_do_write_interlace
name|png_do_write_interlace
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_write_interlace"
argument_list|)
expr_stmt|;
comment|/* We don't have to do anything on the last pass (6) */
if|if
condition|(
name|pass
operator|<
literal|6
condition|)
block|{
comment|/* Each pixel depth is handled separately */
switch|switch
condition|(
name|row_info
operator|->
name|pixel_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|value
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|i
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|sp
operator|>>
operator|(
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x07
argument_list|)
operator|)
argument_list|)
operator|&
literal|0x01
expr_stmt|;
name|d
operator||=
operator|(
name|value
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|7
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|shift
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
literal|7
condition|)
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|value
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|6
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
operator|(
operator|(
literal|3
operator|-
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x03
argument_list|)
operator|)
operator|<<
literal|1
operator|)
operator|)
operator|&
literal|0x03
expr_stmt|;
name|d
operator||=
operator|(
name|value
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|6
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
literal|6
condition|)
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
break|break;
block|}
case|case
literal|4
case|:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|value
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|i
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
operator|(
operator|(
literal|1
operator|-
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x01
argument_list|)
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|d
operator||=
operator|(
name|value
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
literal|4
condition|)
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_size_t
name|pixel_bytes
decl_stmt|;
comment|/* Start at the beginning */
name|dp
operator|=
name|row
expr_stmt|;
comment|/* Find out how many bytes each pixel takes up */
name|pixel_bytes
operator|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|>>
literal|3
operator|)
expr_stmt|;
comment|/* Loop through the row, only looking at the pixels that matter */
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
comment|/* Find out where the original pixel is */
name|sp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|i
operator|*
name|pixel_bytes
expr_stmt|;
comment|/* Move the pixel */
if|if
condition|(
name|dp
operator|!=
name|sp
condition|)
name|memcpy
argument_list|(
name|dp
argument_list|,
name|sp
argument_list|,
name|pixel_bytes
argument_list|)
expr_stmt|;
comment|/* Next pixel */
name|dp
operator|+=
name|pixel_bytes
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Set new row width */
name|row_info
operator|->
name|width
operator|=
operator|(
name|row_info
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|pass
index|]
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_info
operator|->
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This filters the row, chooses which filter to use, if it has not already  * been specified by the application, and then writes the row out with the  * chosen filter.  */
end_comment
begin_function_decl
specifier|static
name|void
comment|/* PRIVATE */
name|png_write_filtered_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|filtered_row
parameter_list|,
name|png_size_t
name|row_bytes
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|PNG_MAXSUM
define|#
directive|define
name|PNG_MAXSUM
value|(((png_uint_32)(-1))>> 1)
end_define
begin_define
DECL|macro|PNG_HISHIFT
define|#
directive|define
name|PNG_HISHIFT
value|10
end_define
begin_define
DECL|macro|PNG_LOMASK
define|#
directive|define
name|PNG_LOMASK
value|((png_uint_32)0xffffL)
end_define
begin_define
DECL|macro|PNG_HIMASK
define|#
directive|define
name|PNG_HIMASK
value|((png_uint_32)(~PNG_LOMASK>> PNG_HISHIFT))
end_define
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_find_filter
name|png_write_find_filter
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|)
block|{
name|png_bytep
name|best_row
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
name|png_bytep
name|prev_row
decl_stmt|,
name|row_buf
decl_stmt|;
name|png_uint_32
name|mins
decl_stmt|,
name|bpp
decl_stmt|;
name|png_byte
name|filter_to_do
init|=
name|png_ptr
operator|->
name|do_filter
decl_stmt|;
name|png_size_t
name|row_bytes
init|=
name|row_info
operator|->
name|rowbytes
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
name|int
name|num_p_filters
init|=
name|png_ptr
operator|->
name|num_prev_filters
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_find_filter"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|==
literal|0
operator|&&
name|filter_to_do
operator|==
name|PNG_ALL_FILTERS
condition|)
block|{
comment|/* These will never be selected so we need not test them. */
name|filter_to_do
operator|&=
operator|~
operator|(
name|PNG_FILTER_UP
operator||
name|PNG_FILTER_PAETH
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Find out how many bytes offset each pixel is */
name|bpp
operator|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|prev_row
operator|=
name|png_ptr
operator|->
name|prev_row
expr_stmt|;
endif|#
directive|endif
name|best_row
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
name|row_buf
operator|=
name|best_row
expr_stmt|;
name|mins
operator|=
name|PNG_MAXSUM
expr_stmt|;
comment|/* The prediction method we use is to find which method provides the     * smallest value when summing the absolute values of the distances     * from zero, using anything>= 128 as negative numbers.  This is known     * as the "minimum sum of absolute differences" heuristic.  Other     * heuristics are the "weighted minimum sum of absolute differences"     * (experimental and can in theory improve compression), and the "zlib     * predictive" method (not implemented yet), which does test compressions     * of lines using different filter methods, and then chooses the     * (series of) filter(s) that give minimum compressed data size (VERY     * computationally expensive).     *     * GRR 980525:  consider also     *     *   (1) minimum sum of absolute differences from running average (i.e.,     *       keep running sum of non-absolute differences& count of bytes)     *       [track dispersion, too?  restart average if dispersion too large?]     *     *  (1b) minimum sum of absolute differences from sliding average, probably     *       with window size<= deflate window (usually 32K)     *     *   (2) minimum sum of squared differences from zero or running average     *       (i.e., ~ root-mean-square approach)     */
comment|/* We don't need to test the 'no filter' case if this is the only filter     * that has been chosen, as it doesn't actually do anything to the data.     */
if|if
condition|(
operator|(
name|filter_to_do
operator|&
name|PNG_FILTER_NONE
operator|)
operator|!=
literal|0
operator|&&
name|filter_to_do
operator|!=
name|PNG_FILTER_NONE
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|rp
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|int
name|j
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
comment|/* Gives us some footroom */
comment|/* Reduce the sum if we match any of the previous rows */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_NONE
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
comment|/* Factor in the cost of this filter (this is here for completeness,           * but it makes no sense to have a "cost" for the NONE filter, as           * it has the minimum possible computational cost - none).           */
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_NONE
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_NONE
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
name|mins
operator|=
name|sum
expr_stmt|;
block|}
comment|/* Sub filter */
if|if
condition|(
name|filter_to_do
operator|==
name|PNG_FILTER_SUB
condition|)
comment|/* It's the only filter so no testing is needed */
block|{
name|png_bytep
name|rp
decl_stmt|,
name|lp
decl_stmt|,
name|dp
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|sub_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
operator|*
name|rp
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|lp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|-
operator|(
name|int
operator|)
operator|*
name|lp
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|sub_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|filter_to_do
operator|&
name|PNG_FILTER_SUB
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* We temporarily increase the "minimum sum" by the factor we        * would reduce the sum of this filter, so that we can do the        * early exit comparison without scaling the sum each time.        */
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_SUB
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|sub_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|=
operator|*
name|rp
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|lp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|-
operator|(
name|int
operator|)
operator|*
name|lp
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_SUB
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|mins
operator|=
name|sum
expr_stmt|;
name|best_row
operator|=
name|png_ptr
operator|->
name|sub_row
expr_stmt|;
block|}
block|}
comment|/* Up filter */
if|if
condition|(
name|filter_to_do
operator|==
name|PNG_FILTER_UP
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|up_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|pp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|up_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|filter_to_do
operator|&
name|PNG_FILTER_UP
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_UP
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|up_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_UP
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|mins
operator|=
name|sum
expr_stmt|;
name|best_row
operator|=
name|png_ptr
operator|->
name|up_row
expr_stmt|;
block|}
block|}
comment|/* Avg filter */
if|if
condition|(
name|filter_to_do
operator|==
name|PNG_FILTER_AVG
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|avg_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|+
operator|(
name|int
operator|)
operator|*
name|lp
operator|++
operator|)
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|avg_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|filter_to_do
operator|&
name|PNG_FILTER_AVG
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_AVG
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|avg_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|+
operator|(
name|int
operator|)
operator|*
name|lp
operator|++
operator|)
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_NONE
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|mins
operator|=
name|sum
expr_stmt|;
name|best_row
operator|=
name|png_ptr
operator|->
name|avg_row
expr_stmt|;
block|}
block|}
comment|/* Paeth filter */
if|if
condition|(
operator|(
name|filter_to_do
operator|==
name|PNG_FILTER_PAETH
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|cp
decl_stmt|,
name|lp
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|paeth_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|cp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|pc
decl_stmt|,
name|p
decl_stmt|;
name|b
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|a
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|p
operator|=
name|b
operator|-
name|c
expr_stmt|;
name|pc
operator|=
name|a
operator|-
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USE_ABS
name|pa
operator|=
name|abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|+
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|p
operator|<
literal|0
condition|?
operator|-
name|p
else|:
name|p
expr_stmt|;
name|pb
operator|=
name|pc
operator|<
literal|0
condition|?
operator|-
name|pc
else|:
name|pc
expr_stmt|;
name|pc
operator|=
operator|(
name|p
operator|+
name|pc
operator|)
operator|<
literal|0
condition|?
operator|-
operator|(
name|p
operator|+
name|pc
operator|)
else|:
name|p
operator|+
name|pc
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
operator|)
condition|?
name|a
else|:
operator|(
name|pb
operator|<=
name|pc
operator|)
condition|?
name|b
else|:
name|c
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|paeth_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|filter_to_do
operator|&
name|PNG_FILTER_PAETH
operator|)
operator|!=
literal|0
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|cp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_PAETH
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|paeth_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|cp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|pc
decl_stmt|,
name|p
decl_stmt|;
name|b
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|a
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_SLOW_PAETH
name|p
operator|=
name|b
operator|-
name|c
expr_stmt|;
name|pc
operator|=
name|a
operator|-
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USE_ABS
name|pa
operator|=
name|abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|+
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|p
operator|<
literal|0
condition|?
operator|-
name|p
else|:
name|p
expr_stmt|;
name|pb
operator|=
name|pc
operator|<
literal|0
condition|?
operator|-
name|pc
else|:
name|pc
expr_stmt|;
name|pc
operator|=
operator|(
name|p
operator|+
name|pc
operator|)
operator|<
literal|0
condition|?
operator|-
operator|(
name|p
operator|+
name|pc
operator|)
else|:
name|p
operator|+
name|pc
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
operator|)
condition|?
name|a
else|:
operator|(
name|pb
operator|<=
name|pc
operator|)
condition|?
name|b
else|:
name|c
expr_stmt|;
else|#
directive|else
comment|/* SLOW_PAETH */
name|p
operator|=
name|a
operator|+
name|b
operator|-
name|c
expr_stmt|;
name|pa
operator|=
name|abs
argument_list|(
name|p
operator|-
name|a
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|p
operator|-
name|b
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|-
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
condition|)
name|p
operator|=
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|pb
operator|<=
name|pc
condition|)
name|p
operator|=
name|b
expr_stmt|;
else|else
name|p
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
comment|/* SLOW_PAETH */
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
name|p
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_PAETH
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|best_row
operator|=
name|png_ptr
operator|->
name|paeth_row
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* WRITE_FILTER */
comment|/* Do the actual writing of the filtered row data from the chosen filter. */
name|png_write_filtered_row
argument_list|(
name|png_ptr
argument_list|,
name|best_row
argument_list|,
name|row_info
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* Save the type of filter we picked this time for future calculations */
if|if
condition|(
name|png_ptr
operator|->
name|num_prev_filters
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|=
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|=
name|best_row
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* WRITE_FILTER */
block|}
end_function
begin_comment
comment|/* Do the actual writing of a previously filtered row. */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_filtered_row
name|png_write_filtered_row
parameter_list|(
name|png_structrp
name|png_ptr
parameter_list|,
name|png_bytep
name|filtered_row
parameter_list|,
name|png_size_t
name|full_row_length
comment|/*includes filter byte*/
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_filtered_row"
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"filter = %d"
argument_list|,
name|filtered_row
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|png_compress_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|filtered_row
argument_list|,
name|full_row_length
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
comment|/* Swap the current and previous rows */
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|!=
name|NULL
condition|)
block|{
name|png_bytep
name|tptr
decl_stmt|;
name|tptr
operator|=
name|png_ptr
operator|->
name|prev_row
expr_stmt|;
name|png_ptr
operator|->
name|prev_row
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
name|png_ptr
operator|->
name|row_buf
operator|=
name|tptr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WRITE_FILTER */
comment|/* Finish row - updates counters and flushes zlib if last row */
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
name|png_ptr
operator|->
name|flush_rows
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|flush_dist
operator|>
literal|0
operator|&&
name|png_ptr
operator|->
name|flush_rows
operator|>=
name|png_ptr
operator|->
name|flush_dist
condition|)
block|{
name|png_write_flush
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WRITE_FLUSH */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WRITE */
end_comment
end_unit
