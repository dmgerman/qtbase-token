begin_unit
begin_comment
comment|/* pngwutil.c - utilities to write a PNG file  *  * Last changed in libpng 1.5.10 [March 8, 2012]  * Copyright (c) 1998-2012 Glenn Randers-Pehrson  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)  *  * This code is released under the libpng license.  * For conditions of distribution and use, see the disclaimer  * and license in png.h  */
end_comment
begin_include
include|#
directive|include
file|"pngpriv.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_SUPPORTED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_INT_FUNCTIONS_SUPPORTED
end_ifdef
begin_comment
comment|/* Place a 32-bit number into a buffer in PNG byte order.  We work  * with unsigned numbers for convenience, although one supported  * ancillary chunk uses signed (two's complement) numbers.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_save_uint_32
name|png_save_uint_32
parameter_list|(
name|png_bytep
name|buf
parameter_list|,
name|png_uint_32
name|i
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_SAVE_INT_32_SUPPORTED
end_ifdef
begin_comment
comment|/* The png_save_int_32 function assumes integers are stored in two's  * complement format.  If this isn't the case, then this routine needs to  * be modified to write data in two's complement format.  Note that,  * the following works correctly even if png_int_32 has more than 32 bits  * (compare the more complex code required on read for sign extention.)  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_save_int_32
name|png_save_int_32
parameter_list|(
name|png_bytep
name|buf
parameter_list|,
name|png_int_32
name|i
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Place a 16-bit number into a buffer in PNG byte order.  * The parameter is declared unsigned int, not png_uint_16,  * just to avoid potential problems on pre-ANSI C compilers.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_save_uint_16
name|png_save_uint_16
parameter_list|(
name|png_bytep
name|buf
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Simple function to write the signature.  If we have already written  * the magic bytes of the signature, or more likely, the PNG stream is  * being embedded into another stream and doesn't need its own signature,  * we should call png_set_sig_bytes() to tell libpng how many of the  * bytes have already been written.  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_sig
name|png_write_sig
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|png_signature
index|[
literal|8
index|]
init|=
block|{
literal|137
block|,
literal|80
block|,
literal|78
block|,
literal|71
block|,
literal|13
block|,
literal|10
block|,
literal|26
block|,
literal|10
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that the signature is being written */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_SIGNATURE
expr_stmt|;
endif|#
directive|endif
comment|/* Write the rest of the 8 byte signature */
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|png_signature
index|[
name|png_ptr
operator|->
name|sig_bytes
index|]
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
literal|8
operator|-
name|png_ptr
operator|->
name|sig_bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|sig_bytes
operator|<
literal|3
condition|)
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PNG_SIGNATURE
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write the start of a PNG chunk.  The type is the chunk type.  * The total_length is the sum of the lengths of all the data you will be  * passing in png_write_chunk_data().  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_chunk_header
name|png_write_chunk_header
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PNG_DEBUG
argument_list|)
operator|&&
operator|(
name|PNG_DEBUG
operator|>
literal|0
operator|)
name|PNG_CSTRING_FROM_CHUNK
argument_list|(
name|buf
argument_list|,
name|chunk_name
argument_list|)
expr_stmt|;
name|png_debug2
argument_list|(
literal|0
argument_list|,
literal|"Writing %s chunk, length = %lu"
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that the chunk header is being written.     * PNG_IO_CHUNK_HDR requires a single I/O call.     */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_CHUNK_HDR
expr_stmt|;
endif|#
directive|endif
comment|/* Write the length and the chunk name */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|chunk_name
argument_list|)
expr_stmt|;
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Put the chunk name into png_ptr->chunk_name */
name|png_ptr
operator|->
name|chunk_name
operator|=
name|chunk_name
expr_stmt|;
comment|/* Reset the crc and run it over the chunk name */
name|png_reset_crc
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|buf
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that chunk data will (possibly) be written.     * PNG_IO_CHUNK_DATA does NOT require a specific number of I/O calls.     */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_CHUNK_DATA
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk_start
name|png_write_chunk_start
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_string
parameter_list|,
name|png_uint_32
name|length
parameter_list|)
block|{
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|PNG_CHUNK_FROM_STRING
argument_list|(
name|chunk_string
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write the data of a PNG chunk started with png_write_chunk_header().  * Note that multiple calls to this function are allowed, and that the  * sum of the lengths from these calls *must* add up to the total_length  * given to png_write_chunk_header().  */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk_data
name|png_write_chunk_data
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
comment|/* Write the data, and run the CRC over it */
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|data
operator|!=
name|NULL
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Update the CRC after writing the data,        * in case that the user I/O routine alters it.        */
name|png_calculate_crc
argument_list|(
name|png_ptr
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Finish a chunk started with png_write_chunk_header(). */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk_end
name|png_write_chunk_end
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_IO_STATE_SUPPORTED
comment|/* Inform the I/O callback that the chunk CRC is being written.     * PNG_IO_CHUNK_CRC requires a single I/O function call.     */
name|png_ptr
operator|->
name|io_state
operator|=
name|PNG_IO_WRITING
operator||
name|PNG_IO_CHUNK_CRC
expr_stmt|;
endif|#
directive|endif
comment|/* Write the crc in a single operation */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|png_ptr
operator|->
name|crc
argument_list|)
expr_stmt|;
name|png_write_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write a PNG chunk all at once.  The type is an array of ASCII characters  * representing the chunk name.  The array must be at least 4 bytes in  * length, and does not need to be null terminated.  To be safe, pass the  * pre-defined chunk names here, and if you need a new one, define it  * where the others are defined.  The length is the length of the data.  * All the data must be present.  If that is not possible, use the  * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()  * functions instead.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_complete_chunk
name|png_write_complete_chunk
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|chunk_name
parameter_list|,
name|png_const_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* On 64 bit architectures 'length' may not fit in a png_uint_32. */
if|if
condition|(
name|length
operator|>
name|PNG_UINT_32_MAX
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"length exceeds PNG maxima"
argument_list|)
expr_stmt|;
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|chunk_name
argument_list|,
operator|(
name|png_uint_32
operator|)
name|length
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is the API that calls the internal function above. */
end_comment
begin_function
name|void
name|PNGAPI
DECL|function|png_write_chunk
name|png_write_chunk
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|chunk_string
parameter_list|,
name|png_const_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|PNG_CHUNK_FROM_STRING
argument_list|(
name|chunk_string
argument_list|)
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Initialize the compressor for the appropriate type of compression. */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_zlib_claim
name|png_zlib_claim
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zlib_state
operator|&
name|PNG_ZLIB_IN_USE
operator|)
condition|)
block|{
comment|/* If already initialized for 'state' do not re-init. */
if|if
condition|(
name|png_ptr
operator|->
name|zlib_state
operator|!=
name|state
condition|)
block|{
name|int
name|ret
init|=
name|Z_OK
decl_stmt|;
name|png_const_charp
name|who
init|=
literal|"-"
decl_stmt|;
comment|/* If actually initialized for another state do a deflateEnd. */
if|if
condition|(
name|png_ptr
operator|->
name|zlib_state
operator|!=
name|PNG_ZLIB_UNINITIALIZED
condition|)
block|{
name|ret
operator|=
name|deflateEnd
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
expr_stmt|;
name|who
operator|=
literal|"end"
expr_stmt|;
name|png_ptr
operator|->
name|zlib_state
operator|=
name|PNG_ZLIB_UNINITIALIZED
expr_stmt|;
block|}
comment|/* zlib itself detects an incomplete state on deflateEnd */
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
switch|switch
condition|(
name|state
condition|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
case|case
name|PNG_ZLIB_FOR_TEXT
case|:
name|ret
operator|=
name|deflateInit2
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|png_ptr
operator|->
name|zlib_text_level
argument_list|,
name|png_ptr
operator|->
name|zlib_text_method
argument_list|,
name|png_ptr
operator|->
name|zlib_text_window_bits
argument_list|,
name|png_ptr
operator|->
name|zlib_text_mem_level
argument_list|,
name|png_ptr
operator|->
name|zlib_text_strategy
argument_list|)
expr_stmt|;
name|who
operator|=
literal|"text"
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PNG_ZLIB_FOR_IDAT
case|:
name|ret
operator|=
name|deflateInit2
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|png_ptr
operator|->
name|zlib_level
argument_list|,
name|png_ptr
operator|->
name|zlib_method
argument_list|,
name|png_ptr
operator|->
name|zlib_window_bits
argument_list|,
name|png_ptr
operator|->
name|zlib_mem_level
argument_list|,
name|png_ptr
operator|->
name|zlib_strategy
argument_list|)
expr_stmt|;
name|who
operator|=
literal|"IDAT"
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"invalid zlib state"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
name|png_ptr
operator|->
name|zlib_state
operator|=
name|state
expr_stmt|;
else|else
comment|/* an error in deflateEnd or deflateInit2 */
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|pos
argument_list|,
literal|"zlib failed to initialize compressor ("
argument_list|)
expr_stmt|;
name|pos
operator|=
name|png_safecat
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|pos
argument_list|,
name|who
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_VERSION_ERROR
case|:
name|pos
operator|=
name|png_safecat
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|pos
argument_list|,
literal|") version error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_STREAM_ERROR
case|:
name|pos
operator|=
name|png_safecat
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|pos
argument_list|,
literal|") stream error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|pos
operator|=
name|png_safecat
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|pos
argument_list|,
literal|") memory error"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pos
operator|=
name|png_safecat
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|pos
argument_list|,
literal|") unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here on success, claim the zstream: */
name|png_ptr
operator|->
name|zlib_state
operator||=
name|PNG_ZLIB_IN_USE
expr_stmt|;
block|}
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zstream already in use (internal error)"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* The opposite: release the stream.  It is also reset, this API will warn on  * error but will not fail.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_zlib_release
name|png_zlib_release
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zlib_state
operator|&
name|PNG_ZLIB_IN_USE
condition|)
block|{
name|int
name|ret
init|=
name|deflateReset
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|)
decl_stmt|;
name|png_ptr
operator|->
name|zlib_state
operator|&=
operator|~
name|PNG_ZLIB_IN_USE
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|png_const_charp
name|err
decl_stmt|;
name|PNG_WARNING_PARAMETERS
argument_list|(
argument|p
argument_list|)
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_VERSION_ERROR
case|:
name|err
operator|=
literal|"version"
expr_stmt|;
break|break;
case|case
name|Z_STREAM_ERROR
case|:
name|err
operator|=
literal|"stream"
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|err
operator|=
literal|"memory"
expr_stmt|;
break|break;
default|default:
name|err
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|png_warning_parameter_signed
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|PNG_NUMBER_FORMAT_d
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|png_warning_parameter
argument_list|(
name|p
argument_list|,
literal|2
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
condition|)
name|err
operator|=
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
expr_stmt|;
else|else
name|err
operator|=
literal|"[no zlib message]"
expr_stmt|;
name|png_warning_parameter
argument_list|(
name|p
argument_list|,
literal|3
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|png_formatted_warning
argument_list|(
name|png_ptr
argument_list|,
name|p
argument_list|,
literal|"zlib failed to reset compressor: @1(@2): @3"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"zstream not in use (internal error)"
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
end_ifdef
begin_comment
comment|/* This pair of functions encapsulates the operation of (a) compressing a  * text string, and (b) issuing it later as a series of chunk data writes.  * The compression_state structure is shared context for these functions  * set up by the caller in order to make the whole mess thread-safe.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|input
name|png_const_bytep
name|input
decl_stmt|;
comment|/* The uncompressed input data */
DECL|member|input_len
name|png_size_t
name|input_len
decl_stmt|;
comment|/* Its length */
DECL|member|num_output_ptr
name|int
name|num_output_ptr
decl_stmt|;
comment|/* Number of output pointers used */
DECL|member|max_output_ptr
name|int
name|max_output_ptr
decl_stmt|;
comment|/* Size of output_ptr */
DECL|member|output_ptr
name|png_bytep
modifier|*
name|output_ptr
decl_stmt|;
comment|/* Array of pointers to output */
block|}
DECL|typedef|compression_state
name|compression_state
typedef|;
end_typedef
begin_comment
comment|/* Compress given text into storage in the png_ptr structure */
end_comment
begin_function
specifier|static
name|int
comment|/* PRIVATE */
DECL|function|png_text_compress
name|png_text_compress
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|text
parameter_list|,
name|png_size_t
name|text_len
parameter_list|,
name|int
name|compression
parameter_list|,
name|compression_state
modifier|*
name|comp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|comp
operator|->
name|num_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|->
name|max_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|->
name|output_ptr
operator|=
name|NULL
expr_stmt|;
name|comp
operator|->
name|input
operator|=
name|NULL
expr_stmt|;
name|comp
operator|->
name|input_len
operator|=
name|text_len
expr_stmt|;
comment|/* We may just want to pass the text right through */
if|if
condition|(
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
block|{
name|comp
operator|->
name|input
operator|=
operator|(
name|png_const_bytep
operator|)
name|text
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|text_len
operator|)
return|;
block|}
if|if
condition|(
name|compression
operator|>=
name|PNG_TEXT_COMPRESSION_LAST
condition|)
block|{
name|PNG_WARNING_PARAMETERS
argument_list|(
argument|p
argument_list|)
name|png_warning_parameter_signed
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|PNG_NUMBER_FORMAT_d
argument_list|,
name|compression
argument_list|)
expr_stmt|;
name|png_formatted_warning
argument_list|(
name|png_ptr
argument_list|,
name|p
argument_list|,
literal|"Unknown compression type @1"
argument_list|)
expr_stmt|;
block|}
comment|/* We can't write the chunk until we find out how much data we have,     * which means we need to run the compressor first and save the     * output.  This shouldn't be a problem, as the vast majority of     * comments should be reasonable, but we will set up an array of     * malloc'd pointers to be sure.     *     * If we knew the application was well behaved, we could simplify this     * greatly by assuming we can always malloc an output buffer large     * enough to hold the compressed text ((1001 * text_len / 1000) + 12)     * and malloc this directly.  The only time this would be a bad idea is     * if we can't malloc more than 64K and we have 64K of random input     * data, or if the input string is incredibly large (although this     * wouldn't cause a failure, just a slowdown due to swapping).     */
name|png_zlib_claim
argument_list|(
name|png_ptr
argument_list|,
name|PNG_ZLIB_FOR_TEXT
argument_list|)
expr_stmt|;
comment|/* Set up the compression buffers */
comment|/* TODO: the following cast hides a potential overflow problem. */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|text_len
expr_stmt|;
comment|/* NOTE: assume zlib doesn't overwrite the input */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|text
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
comment|/* This is the same compression loop as in png_write_row() */
do|do
block|{
comment|/* Compress the data */
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
comment|/* Error */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib error"
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see if we need more room */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
condition|)
block|{
comment|/* Make sure the output array has room */
if|if
condition|(
name|comp
operator|->
name|num_output_ptr
operator|>=
name|comp
operator|->
name|max_output_ptr
condition|)
block|{
name|int
name|old_max
decl_stmt|;
name|old_max
operator|=
name|comp
operator|->
name|max_output_ptr
expr_stmt|;
name|comp
operator|->
name|max_output_ptr
operator|=
name|comp
operator|->
name|num_output_ptr
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|output_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_bytepp
name|old_ptr
decl_stmt|;
name|old_ptr
operator|=
name|comp
operator|->
name|output_ptr
expr_stmt|;
name|comp
operator|->
name|output_ptr
operator|=
operator|(
name|png_bytepp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_alloc_size_t
call|)
argument_list|(
name|comp
operator|->
name|max_output_ptr
operator|*
name|png_sizeof
argument_list|(
name|png_charpp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|comp
operator|->
name|output_ptr
argument_list|,
name|old_ptr
argument_list|,
name|old_max
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|comp
operator|->
name|output_ptr
operator|=
operator|(
name|png_bytepp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_alloc_size_t
call|)
argument_list|(
name|comp
operator|->
name|max_output_ptr
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save the data */
name|comp
operator|->
name|output_ptr
index|[
name|comp
operator|->
name|num_output_ptr
index|]
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_alloc_size_t
operator|)
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|comp
operator|->
name|output_ptr
index|[
name|comp
operator|->
name|num_output_ptr
index|]
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
name|comp
operator|->
name|num_output_ptr
operator|++
expr_stmt|;
comment|/* and reset the buffer */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
block|}
comment|/* Continue until we don't have any more to compress */
block|}
do|while
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
condition|)
do|;
comment|/* Finish the compression */
do|do
block|{
comment|/* Tell zlib we are finished */
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
block|{
comment|/* Check to see if we need more room */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
condition|)
block|{
comment|/* Check to make sure our output array has room */
if|if
condition|(
name|comp
operator|->
name|num_output_ptr
operator|>=
name|comp
operator|->
name|max_output_ptr
condition|)
block|{
name|int
name|old_max
decl_stmt|;
name|old_max
operator|=
name|comp
operator|->
name|max_output_ptr
expr_stmt|;
name|comp
operator|->
name|max_output_ptr
operator|=
name|comp
operator|->
name|num_output_ptr
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|output_ptr
operator|!=
name|NULL
condition|)
block|{
name|png_bytepp
name|old_ptr
decl_stmt|;
name|old_ptr
operator|=
name|comp
operator|->
name|output_ptr
expr_stmt|;
comment|/* This could be optimized to realloc() */
name|comp
operator|->
name|output_ptr
operator|=
operator|(
name|png_bytepp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_alloc_size_t
call|)
argument_list|(
name|comp
operator|->
name|max_output_ptr
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|comp
operator|->
name|output_ptr
argument_list|,
name|old_ptr
argument_list|,
name|old_max
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|old_ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|comp
operator|->
name|output_ptr
operator|=
operator|(
name|png_bytepp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_alloc_size_t
call|)
argument_list|(
name|comp
operator|->
name|max_output_ptr
operator|*
name|png_sizeof
argument_list|(
name|png_charp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save the data */
name|comp
operator|->
name|output_ptr
index|[
name|comp
operator|->
name|num_output_ptr
index|]
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_alloc_size_t
operator|)
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
name|png_memcpy
argument_list|(
name|comp
operator|->
name|output_ptr
index|[
name|comp
operator|->
name|num_output_ptr
index|]
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
name|comp
operator|->
name|num_output_ptr
operator|++
expr_stmt|;
comment|/* and reset the buffer pointers */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
comment|/* We got an error */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib error"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
comment|/* Text length is number of buffers plus last buffer */
name|text_len
operator|=
name|png_ptr
operator|->
name|zbuf_size
operator|*
name|comp
operator|->
name|num_output_ptr
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|<
name|png_ptr
operator|->
name|zbuf_size
condition|)
name|text_len
operator|+=
name|png_ptr
operator|->
name|zbuf_size
operator|-
operator|(
name|png_size_t
operator|)
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|text_len
operator|)
return|;
block|}
end_function
begin_comment
comment|/* Ship the compressed text out via chunk writes */
end_comment
begin_function
specifier|static
name|void
comment|/* PRIVATE */
DECL|function|png_write_compressed_data_out
name|png_write_compressed_data_out
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|compression_state
modifier|*
name|comp
parameter_list|,
name|png_size_t
name|data_len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Handle the no-compression case */
if|if
condition|(
name|comp
operator|->
name|input
condition|)
block|{
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|comp
operator|->
name|input
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
comment|/* The zbuf_size test is because the code below doesn't work if zbuf_size is     * '1'; simply skip it to avoid memory overwrite.     */
if|if
condition|(
name|data_len
operator|>=
literal|2
operator|&&
name|comp
operator|->
name|input_len
operator|<
literal|16384
operator|&&
name|png_ptr
operator|->
name|zbuf_size
operator|>
literal|1
condition|)
block|{
name|unsigned
name|int
name|z_cmf
decl_stmt|;
comment|/* zlib compression method and flags */
comment|/* Optimize the CMF field in the zlib stream.  This hack of the zlib        * stream is compliant to the stream specification.        */
if|if
condition|(
name|comp
operator|->
name|num_output_ptr
condition|)
name|z_cmf
operator|=
name|comp
operator|->
name|output_ptr
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
else|else
name|z_cmf
operator|=
name|png_ptr
operator|->
name|zbuf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|z_cmf
operator|&
literal|0x0f
operator|)
operator|==
literal|8
operator|&&
operator|(
name|z_cmf
operator|&
literal|0xf0
operator|)
operator|<=
literal|0x70
condition|)
block|{
name|unsigned
name|int
name|z_cinfo
decl_stmt|;
name|unsigned
name|int
name|half_z_window_size
decl_stmt|;
name|png_size_t
name|uncompressed_text_size
init|=
name|comp
operator|->
name|input_len
decl_stmt|;
name|z_cinfo
operator|=
name|z_cmf
operator|>>
literal|4
expr_stmt|;
name|half_z_window_size
operator|=
literal|1
operator|<<
operator|(
name|z_cinfo
operator|+
literal|7
operator|)
expr_stmt|;
while|while
condition|(
name|uncompressed_text_size
operator|<=
name|half_z_window_size
operator|&&
name|half_z_window_size
operator|>=
literal|256
condition|)
block|{
name|z_cinfo
operator|--
expr_stmt|;
name|half_z_window_size
operator|>>=
literal|1
expr_stmt|;
block|}
name|z_cmf
operator|=
operator|(
name|z_cmf
operator|&
literal|0x0f
operator|)
operator||
operator|(
name|z_cinfo
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|num_output_ptr
condition|)
block|{
if|if
condition|(
name|comp
operator|->
name|output_ptr
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
name|z_cmf
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|comp
operator|->
name|output_ptr
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|z_cmf
expr_stmt|;
name|tmp
operator|=
name|comp
operator|->
name|output_ptr
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|&
literal|0xe0
expr_stmt|;
name|tmp
operator|+=
literal|0x1f
operator|-
operator|(
operator|(
name|z_cmf
operator|<<
literal|8
operator|)
operator|+
name|tmp
operator|)
operator|%
literal|0x1f
expr_stmt|;
name|comp
operator|->
name|output_ptr
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|tmp
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|tmp
decl_stmt|;
name|png_ptr
operator|->
name|zbuf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|z_cmf
expr_stmt|;
name|tmp
operator|=
name|png_ptr
operator|->
name|zbuf
index|[
literal|1
index|]
operator|&
literal|0xe0
expr_stmt|;
name|tmp
operator|+=
literal|0x1f
operator|-
operator|(
operator|(
name|z_cmf
operator|<<
literal|8
operator|)
operator|+
name|tmp
operator|)
operator|%
literal|0x1f
expr_stmt|;
name|png_ptr
operator|->
name|zbuf
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|tmp
expr_stmt|;
block|}
block|}
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid zlib compression method or flags in non-IDAT chunk"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PNG_WRITE_OPTIMIZE_CMF_SUPPORTED */
comment|/* Write saved output buffers, if any */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comp
operator|->
name|num_output_ptr
condition|;
name|i
operator|++
control|)
block|{
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|comp
operator|->
name|output_ptr
index|[
name|i
index|]
argument_list|,
operator|(
name|png_size_t
operator|)
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|comp
operator|->
name|output_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|->
name|max_output_ptr
operator|!=
literal|0
condition|)
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|comp
operator|->
name|output_ptr
argument_list|)
expr_stmt|;
comment|/* Write anything left in zbuf */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|<
operator|(
name|png_uint_32
operator|)
name|png_ptr
operator|->
name|zbuf_size
condition|)
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset zlib for another zTXt/iTXt or image data */
name|png_zlib_release
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_WRITE_COMPRESSED_TEXT_SUPPORTED */
end_comment
begin_comment
comment|/* Write the IHDR chunk, and update the png_struct with the necessary  * information.  Note that the rest of this code depends upon this  * information being correct.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_IHDR
name|png_write_IHDR
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|width
parameter_list|,
name|png_uint_32
name|height
parameter_list|,
name|int
name|bit_depth
parameter_list|,
name|int
name|color_type
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|int
name|filter_type
parameter_list|,
name|int
name|interlace_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|13
index|]
decl_stmt|;
comment|/* Buffer to store the IHDR info */
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_IHDR"
argument_list|)
expr_stmt|;
comment|/* Check that we have valid input data from the application info */
switch|switch
condition|(
name|color_type
condition|)
block|{
case|case
name|PNG_COLOR_TYPE_GRAY
case|:
switch|switch
condition|(
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
case|case
literal|16
case|:
endif|#
directive|endif
name|png_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for grayscale image"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PNG_COLOR_TYPE_RGB
case|:
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
else|#
directive|else
if|if
condition|(
name|bit_depth
operator|!=
literal|8
condition|)
endif|#
directive|endif
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for RGB image"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|channels
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_PALETTE
case|:
switch|switch
condition|(
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
name|png_ptr
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for paletted image"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PNG_COLOR_TYPE_GRAY_ALPHA
case|:
if|if
condition|(
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for grayscale+alpha image"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|bit_depth
operator|!=
literal|8
operator|&&
name|bit_depth
operator|!=
literal|16
condition|)
else|#
directive|else
if|if
condition|(
name|bit_depth
operator|!=
literal|8
condition|)
endif|#
directive|endif
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid bit depth for RGBA image"
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|channels
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid image color type specified"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compression_type
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid compression type specified"
argument_list|)
expr_stmt|;
name|compression_type
operator|=
name|PNG_COMPRESSION_TYPE_BASE
expr_stmt|;
block|}
comment|/* Write filter_method 64 (intrapixel differencing) only if     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and     * 2. Libpng did not write a PNG signature (this filter_method is only     *    used in PNG datastreams that are embedded in MNG datastreams) and     * 3. The application called png_permit_mng_features with a mask that     *    included PNG_FLAG_MNG_FILTER_64 and     * 4. The filter_method is 64 and     * 5. The color_type is RGB or RGBA     */
if|if
condition|(
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
operator|!
operator|(
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_FILTER_64
operator|)
operator|&&
operator|(
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_PNG_SIGNATURE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
operator|&&
operator|(
name|filter_type
operator|==
name|PNG_INTRAPIXEL_DIFFERENCING
operator|)
operator|)
operator|&&
endif|#
directive|endif
name|filter_type
operator|!=
name|PNG_FILTER_TYPE_BASE
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid filter type specified"
argument_list|)
expr_stmt|;
name|filter_type
operator|=
name|PNG_FILTER_TYPE_BASE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
if|if
condition|(
name|interlace_type
operator|!=
name|PNG_INTERLACE_NONE
operator|&&
name|interlace_type
operator|!=
name|PNG_INTERLACE_ADAM7
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid interlace type specified"
argument_list|)
expr_stmt|;
name|interlace_type
operator|=
name|PNG_INTERLACE_ADAM7
expr_stmt|;
block|}
else|#
directive|else
name|interlace_type
operator|=
name|PNG_INTERLACE_NONE
expr_stmt|;
endif|#
directive|endif
comment|/* Save the relevent information */
name|png_ptr
operator|->
name|bit_depth
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|color_type
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
name|png_ptr
operator|->
name|interlaced
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
name|png_ptr
operator|->
name|filter_type
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
endif|#
directive|endif
name|png_ptr
operator|->
name|compression_type
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
name|png_ptr
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|png_ptr
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|png_ptr
operator|->
name|pixel_depth
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|bit_depth
operator|*
name|png_ptr
operator|->
name|channels
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|pixel_depth
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* Set the usr info, so any transformations can modify it */
name|png_ptr
operator|->
name|usr_width
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
name|png_ptr
operator|->
name|usr_bit_depth
operator|=
name|png_ptr
operator|->
name|bit_depth
expr_stmt|;
name|png_ptr
operator|->
name|usr_channels
operator|=
name|png_ptr
operator|->
name|channels
expr_stmt|;
comment|/* Pack the header information into the buffer */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|bit_depth
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
operator|(
name|png_byte
operator|)
name|color_type
expr_stmt|;
name|buf
index|[
literal|10
index|]
operator|=
operator|(
name|png_byte
operator|)
name|compression_type
expr_stmt|;
name|buf
index|[
literal|11
index|]
operator|=
operator|(
name|png_byte
operator|)
name|filter_type
expr_stmt|;
name|buf
index|[
literal|12
index|]
operator|=
operator|(
name|png_byte
operator|)
name|interlace_type
expr_stmt|;
comment|/* Write the chunk */
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_IHDR
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|13
argument_list|)
expr_stmt|;
comment|/* Initialize zlib with PNG info */
name|png_ptr
operator|->
name|zstream
operator|.
name|zalloc
operator|=
name|png_zalloc
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|zfree
operator|=
name|png_zfree
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
name|png_ptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|do_filter
operator|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
operator|||
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|)
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_FILTER_NONE
expr_stmt|;
else|else
name|png_ptr
operator|->
name|do_filter
operator|=
name|PNG_ALL_FILTERS
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_CUSTOM_STRATEGY
operator|)
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|!=
name|PNG_FILTER_NONE
condition|)
name|png_ptr
operator|->
name|zlib_strategy
operator|=
name|Z_FILTERED
expr_stmt|;
else|else
name|png_ptr
operator|->
name|zlib_strategy
operator|=
name|Z_DEFAULT_STRATEGY
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_CUSTOM_LEVEL
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_mem_level
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_window_bits
operator|=
literal|15
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZLIB_CUSTOM_METHOD
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_method
operator|=
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZTXT_CUSTOM_STRATEGY
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_text_strategy
operator|=
name|Z_DEFAULT_STRATEGY
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZTXT_CUSTOM_LEVEL
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_text_level
operator|=
name|png_ptr
operator|->
name|zlib_level
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZTXT_CUSTOM_MEM_LEVEL
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_text_mem_level
operator|=
name|png_ptr
operator|->
name|zlib_mem_level
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZTXT_CUSTOM_WINDOW_BITS
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_text_window_bits
operator|=
name|png_ptr
operator|->
name|zlib_window_bits
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|flags
operator|&
name|PNG_FLAG_ZTXT_CUSTOM_METHOD
operator|)
condition|)
name|png_ptr
operator|->
name|zlib_text_method
operator|=
name|png_ptr
operator|->
name|zlib_method
expr_stmt|;
else|#
directive|else
name|png_ptr
operator|->
name|zlib_text_strategy
operator|=
name|Z_DEFAULT_STRATEGY
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_level
operator|=
name|png_ptr
operator|->
name|zlib_level
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_mem_level
operator|=
name|png_ptr
operator|->
name|zlib_mem_level
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_window_bits
operator|=
name|png_ptr
operator|->
name|zlib_window_bits
expr_stmt|;
name|png_ptr
operator|->
name|zlib_text_method
operator|=
name|png_ptr
operator|->
name|zlib_method
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED */
endif|#
directive|endif
comment|/* PNG_WRITE_COMPRESSED_TEXT_SUPPORTED */
comment|/* Record that the compressor has not yet been initialized. */
name|png_ptr
operator|->
name|zlib_state
operator|=
name|PNG_ZLIB_UNINITIALIZED
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator|=
name|PNG_HAVE_IHDR
expr_stmt|;
comment|/* not READY_FOR_ZTXT */
block|}
end_function
begin_comment
comment|/* Write the palette.  We are careful not to trust png_color to be in the  * correct order for PNG, so people can redefine it to any convenient  * structure.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_PLTE
name|png_write_PLTE
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_colorp
name|palette
parameter_list|,
name|png_uint_32
name|num_pal
parameter_list|)
block|{
name|png_uint_32
name|i
decl_stmt|;
name|png_const_colorp
name|pal_ptr
decl_stmt|;
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_PLTE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
operator|!
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_EMPTY_PLTE
operator|)
operator|&&
endif|#
directive|endif
name|num_pal
operator|==
literal|0
operator|)
operator|||
name|num_pal
operator|>
literal|256
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of colors in palette"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of colors in palette"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring request to write a PLTE chunk in grayscale PNG"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_ptr
operator|->
name|num_palette
operator|=
operator|(
name|png_uint_16
operator|)
name|num_pal
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"num_palette = %d"
argument_list|,
name|png_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_PLTE
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_pal
operator|*
literal|3
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pal_ptr
operator|=
name|palette
init|;
name|i
operator|<
name|num_pal
condition|;
name|i
operator|++
operator|,
name|pal_ptr
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|pal_ptr
operator|->
name|red
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|pal_ptr
operator|->
name|green
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|pal_ptr
operator|->
name|blue
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|3
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* This is a little slower but some buggy compilers need to do this     * instead     */
name|pal_ptr
operator|=
name|palette
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pal
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|pal_ptr
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|pal_ptr
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|pal_ptr
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_PLTE
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write an IDAT chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_IDAT
name|png_write_IDAT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_IDAT"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|mode
operator|&
name|PNG_HAVE_IDAT
operator|)
operator|&&
name|png_ptr
operator|->
name|compression_type
operator|==
name|PNG_COMPRESSION_TYPE_BASE
condition|)
block|{
comment|/* Optimize the CMF field in the zlib stream.  This hack of the zlib        * stream is compliant to the stream specification.        */
name|unsigned
name|int
name|z_cmf
init|=
name|data
index|[
literal|0
index|]
decl_stmt|;
comment|/* zlib compression method and flags */
if|if
condition|(
operator|(
name|z_cmf
operator|&
literal|0x0f
operator|)
operator|==
literal|8
operator|&&
operator|(
name|z_cmf
operator|&
literal|0xf0
operator|)
operator|<=
literal|0x70
condition|)
block|{
comment|/* Avoid memory underflows and multiplication overflows.           *           * The conditions below are practically always satisfied;           * however, they still must be checked.           */
if|if
condition|(
name|length
operator|>=
literal|2
operator|&&
name|png_ptr
operator|->
name|height
operator|<
literal|16384
operator|&&
name|png_ptr
operator|->
name|width
operator|<
literal|16384
condition|)
block|{
comment|/* Compute the maximum possible length of the datastream */
comment|/* Number of pixels, plus for each row a filter byte              * and possibly a padding byte, so increase the maximum              * size to account for these.              */
name|unsigned
name|int
name|z_cinfo
decl_stmt|;
name|unsigned
name|int
name|half_z_window_size
decl_stmt|;
name|png_uint_32
name|uncompressed_idat_size
init|=
name|png_ptr
operator|->
name|height
operator|*
operator|(
operator|(
name|png_ptr
operator|->
name|width
operator|*
name|png_ptr
operator|->
name|channels
operator|*
name|png_ptr
operator|->
name|bit_depth
operator|+
literal|15
operator|)
operator|>>
literal|3
operator|)
decl_stmt|;
comment|/* If it's interlaced, each block of 8 rows is sent as up to              * 14 rows, i.e., 6 additional rows, each with a filter byte              * and possibly a padding byte              */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
name|uncompressed_idat_size
operator|+=
operator|(
operator|(
name|png_ptr
operator|->
name|height
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
operator|(
name|png_ptr
operator|->
name|bit_depth
operator|<
literal|8
condition|?
literal|12
else|:
literal|6
operator|)
expr_stmt|;
name|z_cinfo
operator|=
name|z_cmf
operator|>>
literal|4
expr_stmt|;
name|half_z_window_size
operator|=
literal|1
operator|<<
operator|(
name|z_cinfo
operator|+
literal|7
operator|)
expr_stmt|;
while|while
condition|(
name|uncompressed_idat_size
operator|<=
name|half_z_window_size
operator|&&
name|half_z_window_size
operator|>=
literal|256
condition|)
block|{
name|z_cinfo
operator|--
expr_stmt|;
name|half_z_window_size
operator|>>=
literal|1
expr_stmt|;
block|}
name|z_cmf
operator|=
operator|(
name|z_cmf
operator|&
literal|0x0f
operator|)
operator||
operator|(
name|z_cinfo
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|!=
name|z_cmf
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|z_cmf
expr_stmt|;
name|tmp
operator|=
name|data
index|[
literal|1
index|]
operator|&
literal|0xe0
expr_stmt|;
name|tmp
operator|+=
literal|0x1f
operator|-
operator|(
operator|(
name|z_cmf
operator|<<
literal|8
operator|)
operator|+
name|tmp
operator|)
operator|%
literal|0x1f
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|tmp
expr_stmt|;
block|}
block|}
block|}
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid zlib compression method or flags in IDAT"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PNG_WRITE_OPTIMIZE_CMF_SUPPORTED */
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_IDAT
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IDAT
expr_stmt|;
comment|/* Prior to 1.5.4 this code was replicated in every caller (except at the     * end, where it isn't technically necessary).  Since this function has     * flushed the data we can safely reset the zlib output buffer here.     */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Write an IEND chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_IEND
name|png_write_IEND
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_IEND"
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_IEND
argument_list|,
name|NULL
argument_list|,
operator|(
name|png_size_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|mode
operator||=
name|PNG_HAVE_IEND
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_gAMA_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a gAMA chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_gAMA_fixed
name|png_write_gAMA_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|file_gamma
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_gAMA"
argument_list|)
expr_stmt|;
comment|/* file_gamma is saved in 1/100,000ths */
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
operator|(
name|png_uint_32
operator|)
name|file_gamma
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_gAMA
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sRGB_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a sRGB chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sRGB
name|png_write_sRGB
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|srgb_intent
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sRGB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srgb_intent
operator|>=
name|PNG_sRGB_INTENT_LAST
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sRGB rendering intent specified"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|srgb_intent
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_sRGB
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_iCCP_SUPPORTED
end_ifdef
begin_comment
comment|/* Write an iCCP chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_iCCP
name|png_write_iCCP
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|name
parameter_list|,
name|int
name|compression_type
parameter_list|,
name|png_const_charp
name|profile
parameter_list|,
name|int
name|profile_len
parameter_list|)
block|{
name|png_size_t
name|name_len
decl_stmt|;
name|png_charp
name|new_name
decl_stmt|;
name|compression_state
name|comp
decl_stmt|;
name|int
name|embedded_profile_len
init|=
literal|0
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_iCCP"
argument_list|)
expr_stmt|;
name|comp
operator|.
name|num_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|.
name|max_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|.
name|output_ptr
operator|=
name|NULL
expr_stmt|;
name|comp
operator|.
name|input
operator|=
name|NULL
expr_stmt|;
name|comp
operator|.
name|input_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|name_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|name
argument_list|,
operator|&
name|new_name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|compression_type
operator|!=
name|PNG_COMPRESSION_TYPE_BASE
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unknown compression type in iCCP chunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile
operator|==
name|NULL
condition|)
name|profile_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|profile_len
operator|>
literal|3
condition|)
name|embedded_profile_len
operator|=
operator|(
operator|(
operator|*
operator|(
operator|(
name|png_const_bytep
operator|)
name|profile
operator|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
operator|(
name|png_const_bytep
operator|)
name|profile
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
operator|(
name|png_const_bytep
operator|)
name|profile
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
operator|(
name|png_const_bytep
operator|)
name|profile
operator|+
literal|3
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|embedded_profile_len
operator|<
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Embedded profile length in iCCP chunk is negative"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|profile_len
operator|<
name|embedded_profile_len
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Embedded profile length too large in iCCP chunk"
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|profile_len
operator|>
name|embedded_profile_len
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Truncating profile to actual length in iCCP chunk"
argument_list|)
expr_stmt|;
name|profile_len
operator|=
name|embedded_profile_len
expr_stmt|;
block|}
if|if
condition|(
name|profile_len
condition|)
name|profile_len
operator|=
name|png_text_compress
argument_list|(
name|png_ptr
argument_list|,
name|profile
argument_list|,
operator|(
name|png_size_t
operator|)
name|profile_len
argument_list|,
name|PNG_COMPRESSION_TYPE_BASE
argument_list|,
operator|&
name|comp
argument_list|)
expr_stmt|;
comment|/* Make sure we include the NULL after the name and the compression type */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_iCCP
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|name_len
operator|+
name|profile_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|new_name
index|[
name|name_len
operator|+
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|new_name
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|name_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_len
condition|)
block|{
name|png_write_compressed_data_out
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|comp
argument_list|,
name|profile_len
argument_list|)
expr_stmt|;
block|}
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sPLT_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a sPLT chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sPLT
name|png_write_sPLT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_sPLT_tp
name|spalette
parameter_list|)
block|{
name|png_size_t
name|name_len
decl_stmt|;
name|png_charp
name|new_name
decl_stmt|;
name|png_byte
name|entrybuf
index|[
literal|10
index|]
decl_stmt|;
name|png_size_t
name|entry_size
init|=
operator|(
name|spalette
operator|->
name|depth
operator|==
literal|8
condition|?
literal|6
else|:
literal|10
operator|)
decl_stmt|;
name|png_size_t
name|palette_size
init|=
name|entry_size
operator|*
name|spalette
operator|->
name|nentries
decl_stmt|;
name|png_sPLT_entryp
name|ep
decl_stmt|;
ifndef|#
directive|ifndef
name|PNG_POINTER_INDEXING_SUPPORTED
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sPLT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|spalette
operator|->
name|name
argument_list|,
operator|&
name|new_name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Make sure we include the NULL after the name */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_sPLT
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|name_len
operator|+
literal|2
operator|+
name|palette_size
argument_list|)
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|new_name
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|name_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|spalette
operator|->
name|depth
argument_list|,
operator|(
name|png_size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Loop through each palette entry, writing appropriately */
ifdef|#
directive|ifdef
name|PNG_POINTER_INDEXING_SUPPORTED
for|for
control|(
name|ep
operator|=
name|spalette
operator|->
name|entries
init|;
name|ep
operator|<
name|spalette
operator|->
name|entries
operator|+
name|spalette
operator|->
name|nentries
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|spalette
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
name|entrybuf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|red
expr_stmt|;
name|entrybuf
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|green
expr_stmt|;
name|entrybuf
index|[
literal|2
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|blue
expr_stmt|;
name|entrybuf
index|[
literal|3
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
operator|->
name|alpha
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|0
argument_list|,
name|ep
operator|->
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|2
argument_list|,
name|ep
operator|->
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
operator|->
name|blue
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|6
argument_list|,
name|ep
operator|->
name|alpha
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|8
argument_list|,
name|ep
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|entrybuf
argument_list|,
operator|(
name|png_size_t
operator|)
name|entry_size
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ep
operator|=
name|spalette
operator|->
name|entries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|>
name|spalette
operator|->
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spalette
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
name|entrybuf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|red
expr_stmt|;
name|entrybuf
index|[
literal|1
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|green
expr_stmt|;
name|entrybuf
index|[
literal|2
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|blue
expr_stmt|;
name|entrybuf
index|[
literal|3
index|]
operator|=
operator|(
name|png_byte
operator|)
name|ep
index|[
name|i
index|]
operator|.
name|alpha
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|frequency
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|0
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|2
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|4
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|6
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|alpha
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|entrybuf
operator|+
literal|8
argument_list|,
name|ep
index|[
name|i
index|]
operator|.
name|frequency
argument_list|)
expr_stmt|;
block|}
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|entrybuf
argument_list|,
operator|(
name|png_size_t
operator|)
name|entry_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sBIT_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the sBIT chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sBIT
name|png_write_sBIT
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_color_8p
name|sbit
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|png_size_t
name|size
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sBIT"
argument_list|)
expr_stmt|;
comment|/* Make sure we don't depend upon the order of PNG_COLOR_8 */
if|if
condition|(
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
block|{
name|png_byte
name|maxbits
decl_stmt|;
name|maxbits
operator|=
call|(
name|png_byte
call|)
argument_list|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|?
literal|8
else|:
name|png_ptr
operator|->
name|usr_bit_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbit
operator|->
name|red
operator|==
literal|0
operator|||
name|sbit
operator|->
name|red
operator|>
name|maxbits
operator|||
name|sbit
operator|->
name|green
operator|==
literal|0
operator|||
name|sbit
operator|->
name|green
operator|>
name|maxbits
operator|||
name|sbit
operator|->
name|blue
operator|==
literal|0
operator|||
name|sbit
operator|->
name|blue
operator|>
name|maxbits
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sBIT depth specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|sbit
operator|->
name|red
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|sbit
operator|->
name|green
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|sbit
operator|->
name|blue
expr_stmt|;
name|size
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sbit
operator|->
name|gray
operator|==
literal|0
operator|||
name|sbit
operator|->
name|gray
operator|>
name|png_ptr
operator|->
name|usr_bit_depth
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sBIT depth specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|sbit
operator|->
name|gray
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|color_type
operator|&
name|PNG_COLOR_MASK_ALPHA
condition|)
block|{
if|if
condition|(
name|sbit
operator|->
name|alpha
operator|==
literal|0
operator|||
name|sbit
operator|->
name|alpha
operator|>
name|png_ptr
operator|->
name|usr_bit_depth
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid sBIT depth specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
name|size
operator|++
index|]
operator|=
name|sbit
operator|->
name|alpha
expr_stmt|;
block|}
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_sBIT
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_cHRM_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the cHRM chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_cHRM_fixed
name|png_write_cHRM_fixed
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_fixed_point
name|white_x
parameter_list|,
name|png_fixed_point
name|white_y
parameter_list|,
name|png_fixed_point
name|red_x
parameter_list|,
name|png_fixed_point
name|red_y
parameter_list|,
name|png_fixed_point
name|green_x
parameter_list|,
name|png_fixed_point
name|green_y
parameter_list|,
name|png_fixed_point
name|blue_x
parameter_list|,
name|png_fixed_point
name|blue_y
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_cHRM"
argument_list|)
expr_stmt|;
comment|/* Each value is saved in 1/100,000ths */
ifdef|#
directive|ifdef
name|PNG_CHECK_cHRM_SUPPORTED
if|if
condition|(
name|png_check_cHRM_fixed
argument_list|(
name|png_ptr
argument_list|,
name|white_x
argument_list|,
name|white_y
argument_list|,
name|red_x
argument_list|,
name|red_y
argument_list|,
name|green_x
argument_list|,
name|green_y
argument_list|,
name|blue_x
argument_list|,
name|blue_y
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
operator|(
name|png_uint_32
operator|)
name|white_x
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
operator|(
name|png_uint_32
operator|)
name|white_y
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
operator|(
name|png_uint_32
operator|)
name|red_x
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|12
argument_list|,
operator|(
name|png_uint_32
operator|)
name|red_y
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
operator|(
name|png_uint_32
operator|)
name|green_x
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|20
argument_list|,
operator|(
name|png_uint_32
operator|)
name|green_y
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|24
argument_list|,
operator|(
name|png_uint_32
operator|)
name|blue_x
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|28
argument_list|,
operator|(
name|png_uint_32
operator|)
name|blue_y
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_cHRM
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|32
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_tRNS_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the tRNS chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_tRNS
name|png_write_tRNS
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_bytep
name|trans_alpha
parameter_list|,
name|png_const_color_16p
name|tran
parameter_list|,
name|int
name|num_trans
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_tRNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
name|num_trans
operator|<=
literal|0
operator|||
name|num_trans
operator|>
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of transparent colors specified"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write the chunk out as it is */
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tRNS
argument_list|,
name|trans_alpha
argument_list|,
operator|(
name|png_size_t
operator|)
name|num_trans
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
comment|/* One 16 bit value */
if|if
condition|(
name|tran
operator|->
name|gray
operator|>=
operator|(
literal|1
operator|<<
name|png_ptr
operator|->
name|bit_depth
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write tRNS chunk out-of-range for bit_depth"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|tran
operator|->
name|gray
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tRNS
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
condition|)
block|{
comment|/* Three 16 bit values */
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|tran
operator|->
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|tran
operator|->
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|tran
operator|->
name|blue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tRNS
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't write tRNS with an alpha channel"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_bKGD_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the background chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_bKGD
name|png_write_bKGD
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_color_16p
name|back
parameter_list|,
name|int
name|color_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_bKGD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|PNG_MNG_FEATURES_SUPPORTED
operator|(
name|png_ptr
operator|->
name|num_palette
operator|||
operator|(
operator|!
operator|(
name|png_ptr
operator|->
name|mng_features_permitted
operator|&
name|PNG_FLAG_MNG_EMPTY_PLTE
operator|)
operator|)
operator|)
operator|&&
endif|#
directive|endif
name|back
operator|->
name|index
operator|>=
name|png_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid background palette index"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|back
operator|->
name|index
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_bKGD
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color_type
operator|&
name|PNG_COLOR_MASK_COLOR
condition|)
block|{
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|back
operator|->
name|red
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|back
operator|->
name|green
argument_list|)
expr_stmt|;
name|png_save_uint_16
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|back
operator|->
name|blue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_16BIT_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|bit_depth
operator|==
literal|8
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|2
index|]
operator||
name|buf
index|[
literal|4
index|]
condition|)
endif|#
directive|endif
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_bKGD
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|back
operator|->
name|gray
operator|>=
operator|(
literal|1
operator|<<
name|png_ptr
operator|->
name|bit_depth
operator|)
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Ignoring attempt to write bKGD chunk out-of-range for bit_depth"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|back
operator|->
name|gray
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_bKGD
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_hIST_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the histogram */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_hIST
name|png_write_hIST
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_uint_16p
name|hist
parameter_list|,
name|int
name|num_hist
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|png_byte
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_hIST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_hist
operator|>
operator|(
name|int
operator|)
name|png_ptr
operator|->
name|num_palette
condition|)
block|{
name|png_debug2
argument_list|(
literal|3
argument_list|,
literal|"num_hist = %d, num_palette = %d"
argument_list|,
name|num_hist
argument_list|,
name|png_ptr
operator|->
name|num_palette
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid number of histogram entries specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_hIST
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|num_hist
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hist
condition|;
name|i
operator|++
control|)
block|{
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|hist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|PNG_WRITE_TEXT_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_pCAL_SUPPORTED
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PNG_WRITE_iCCP_SUPPORTED
argument_list|)
operator|||
name|defined
argument_list|(
name|PNG_WRITE_sPLT_SUPPORTED
argument_list|)
end_if
begin_comment
comment|/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,  * and if invalid, correct the keyword rather than discarding the entire  * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in  * length, forbids leading or trailing whitespace, multiple internal spaces,  * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.  *  * The new_key is allocated to hold the corrected keyword and must be freed  * by the calling routine.  This avoids problems with trying to write to  * static keywords without having to have duplicate copies of the strings.  */
end_comment
begin_function
name|png_size_t
comment|/* PRIVATE */
DECL|function|png_check_keyword
name|png_check_keyword
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_charpp
name|new_key
parameter_list|)
block|{
name|png_size_t
name|key_len
decl_stmt|;
name|png_const_charp
name|ikp
decl_stmt|;
name|png_charp
name|kp
decl_stmt|,
name|dp
decl_stmt|;
name|int
name|kflag
decl_stmt|;
name|int
name|kwarn
init|=
literal|0
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_check_keyword"
argument_list|)
expr_stmt|;
operator|*
name|new_key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
operator|||
operator|(
name|key_len
operator|=
name|png_strlen
argument_list|(
name|key
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"zero length keyword"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|png_size_t
operator|)
literal|0
operator|)
return|;
block|}
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"Keyword to be checked is '%s'"
argument_list|,
name|key
argument_list|)
expr_stmt|;
operator|*
name|new_key
operator|=
operator|(
name|png_charp
operator|)
name|png_malloc_warn
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|key_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|new_key
operator|==
name|NULL
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Out of memory while procesing keyword"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|png_size_t
operator|)
literal|0
operator|)
return|;
block|}
comment|/* Replace non-printing characters with a blank and print a warning */
for|for
control|(
name|ikp
operator|=
name|key
operator|,
name|dp
operator|=
operator|*
name|new_key
init|;
operator|*
name|ikp
operator|!=
literal|'\0'
condition|;
name|ikp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|png_byte
operator|)
operator|*
name|ikp
operator|<
literal|0x20
operator|||
operator|(
operator|(
name|png_byte
operator|)
operator|*
name|ikp
operator|>
literal|0x7E
operator|&&
operator|(
name|png_byte
operator|)
operator|*
name|ikp
operator|<
literal|0xA1
operator|)
condition|)
block|{
name|PNG_WARNING_PARAMETERS
argument_list|(
argument|p
argument_list|)
name|png_warning_parameter_unsigned
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|PNG_NUMBER_FORMAT_02x
argument_list|,
operator|(
name|png_byte
operator|)
operator|*
name|ikp
argument_list|)
expr_stmt|;
name|png_formatted_warning
argument_list|(
name|png_ptr
argument_list|,
name|p
argument_list|,
literal|"invalid keyword character 0x@1"
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dp
operator|=
operator|*
name|ikp
expr_stmt|;
block|}
block|}
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove any trailing white space. */
name|kp
operator|=
operator|*
name|new_key
operator|+
name|key_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|kp
operator|==
literal|' '
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"trailing spaces removed from keyword"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|kp
operator|==
literal|' '
condition|)
block|{
operator|*
operator|(
name|kp
operator|--
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|key_len
operator|--
expr_stmt|;
block|}
block|}
comment|/* Remove any leading white space. */
name|kp
operator|=
operator|*
name|new_key
expr_stmt|;
if|if
condition|(
operator|*
name|kp
operator|==
literal|' '
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"leading spaces removed from keyword"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|kp
operator|==
literal|' '
condition|)
block|{
name|kp
operator|++
expr_stmt|;
name|key_len
operator|--
expr_stmt|;
block|}
block|}
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"Checking for multiple internal spaces in '%s'"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* Remove multiple internal spaces. */
for|for
control|(
name|kflag
operator|=
literal|0
operator|,
name|dp
operator|=
operator|*
name|new_key
init|;
operator|*
name|kp
operator|!=
literal|'\0'
condition|;
name|kp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|kp
operator|==
literal|' '
operator|&&
name|kflag
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
name|kp
expr_stmt|;
name|kflag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|kp
operator|==
literal|' '
condition|)
block|{
name|key_len
operator|--
expr_stmt|;
name|kwarn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|dp
operator|++
operator|)
operator|=
operator|*
name|kp
expr_stmt|;
name|kflag
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|kwarn
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"extra interior spaces removed from keyword"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_len
operator|==
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
operator|*
name|new_key
argument_list|)
expr_stmt|;
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Zero length keyword"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key_len
operator|>
literal|79
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"keyword length must be 1 - 79 characters"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|new_key
operator|)
index|[
literal|79
index|]
operator|=
literal|'\0'
expr_stmt|;
name|key_len
operator|=
literal|79
expr_stmt|;
block|}
return|return
operator|(
name|key_len
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_tEXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a tEXt chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_tEXt
name|png_write_tEXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_const_charp
name|text
parameter_list|,
name|png_size_t
name|text_len
parameter_list|)
block|{
name|png_size_t
name|key_len
decl_stmt|;
name|png_charp
name|new_key
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_tEXt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|,
operator|&
name|new_key
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|text
operator|==
name|NULL
operator|||
operator|*
name|text
operator|==
literal|'\0'
condition|)
name|text_len
operator|=
literal|0
expr_stmt|;
else|else
name|text_len
operator|=
name|png_strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
comment|/* Make sure we include the 0 after the key */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_tEXt
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|key_len
operator|+
name|text_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     * We leave it to the application to meet PNG-1.0 requirements on the     * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of     * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.     * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.     */
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|new_key
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|key_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_len
condition|)
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|text
argument_list|,
operator|(
name|png_size_t
operator|)
name|text_len
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_zTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Write a compressed text chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_zTXt
name|png_write_zTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_const_charp
name|text
parameter_list|,
name|png_size_t
name|text_len
parameter_list|,
name|int
name|compression
parameter_list|)
block|{
name|png_size_t
name|key_len
decl_stmt|;
name|png_byte
name|buf
decl_stmt|;
name|png_charp
name|new_key
decl_stmt|;
name|compression_state
name|comp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_zTXt"
argument_list|)
expr_stmt|;
name|comp
operator|.
name|num_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|.
name|max_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|.
name|output_ptr
operator|=
name|NULL
expr_stmt|;
name|comp
operator|.
name|input
operator|=
name|NULL
expr_stmt|;
name|comp
operator|.
name|input_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|key_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|,
operator|&
name|new_key
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|text
operator|==
name|NULL
operator|||
operator|*
name|text
operator|==
literal|'\0'
operator|||
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
block|{
name|png_write_tEXt
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|,
name|text
argument_list|,
operator|(
name|png_size_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
return|return;
block|}
name|text_len
operator|=
name|png_strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
comment|/* Compute the compressed data; do it now for the length */
name|text_len
operator|=
name|png_text_compress
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|,
name|compression
argument_list|,
operator|&
name|comp
argument_list|)
expr_stmt|;
comment|/* Write start of chunk */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_zTXt
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
name|key_len
operator|+
name|text_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write key */
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|new_key
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|key_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|png_byte
operator|)
name|compression
expr_stmt|;
comment|/* Write compression */
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Write the compressed data */
name|png_write_compressed_data_out
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|comp
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
comment|/* Close the chunk */
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_iTXt_SUPPORTED
end_ifdef
begin_comment
comment|/* Write an iTXt chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_iTXt
name|png_write_iTXt
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|compression
parameter_list|,
name|png_const_charp
name|key
parameter_list|,
name|png_const_charp
name|lang
parameter_list|,
name|png_const_charp
name|lang_key
parameter_list|,
name|png_const_charp
name|text
parameter_list|)
block|{
name|png_size_t
name|lang_len
decl_stmt|,
name|key_len
decl_stmt|,
name|lang_key_len
decl_stmt|,
name|text_len
decl_stmt|;
name|png_charp
name|new_lang
decl_stmt|;
name|png_charp
name|new_key
init|=
name|NULL
decl_stmt|;
name|png_byte
name|cbuf
index|[
literal|2
index|]
decl_stmt|;
name|compression_state
name|comp
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_iTXt"
argument_list|)
expr_stmt|;
name|comp
operator|.
name|num_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|.
name|max_output_ptr
operator|=
literal|0
expr_stmt|;
name|comp
operator|.
name|output_ptr
operator|=
name|NULL
expr_stmt|;
name|comp
operator|.
name|input
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|key_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|key
argument_list|,
operator|&
name|new_key
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|lang_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|lang
argument_list|,
operator|&
name|new_lang
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Empty language field in iTXt chunk"
argument_list|)
expr_stmt|;
name|new_lang
operator|=
name|NULL
expr_stmt|;
name|lang_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lang_key
operator|==
name|NULL
condition|)
name|lang_key_len
operator|=
literal|0
expr_stmt|;
else|else
name|lang_key_len
operator|=
name|png_strlen
argument_list|(
name|lang_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
name|text_len
operator|=
literal|0
expr_stmt|;
else|else
name|text_len
operator|=
name|png_strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
comment|/* Compute the compressed data; do it now for the length */
name|text_len
operator|=
name|png_text_compress
argument_list|(
name|png_ptr
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|,
name|compression
operator|-
literal|2
argument_list|,
operator|&
name|comp
argument_list|)
expr_stmt|;
comment|/* Make sure we include the compression flag, the compression byte,     * and the NULs after the key, lang, and lang_key parts     */
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_iTXt
argument_list|,
call|(
name|png_uint_32
call|)
argument_list|(
literal|5
comment|/* comp byte, comp flag, terminators for key, lang and lang_key */
operator|+
name|key_len
operator|+
name|lang_len
operator|+
name|lang_key_len
operator|+
name|text_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We leave it to the application to meet PNG-1.0 requirements on the     * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of     * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.     * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.     */
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_bytep
operator|)
name|new_key
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|key_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the compression flag */
if|if
condition|(
name|compression
operator|==
name|PNG_ITXT_COMPRESSION_NONE
operator|||
name|compression
operator|==
name|PNG_TEXT_COMPRESSION_NONE
condition|)
name|cbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
comment|/* compression == PNG_ITXT_COMPRESSION_zTXt */
name|cbuf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Set the compression method */
name|cbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|cbuf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
name|cbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|new_lang
condition|?
operator|(
name|png_const_bytep
operator|)
name|new_lang
else|:
name|cbuf
operator|)
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|lang_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|lang_key
condition|?
operator|(
name|png_const_bytep
operator|)
name|lang_key
else|:
name|cbuf
operator|)
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|lang_key_len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|png_write_compressed_data_out
argument_list|(
name|png_ptr
argument_list|,
operator|&
name|comp
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_key
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_lang
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_oFFs_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the oFFs chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_oFFs
name|png_write_oFFs
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_int_32
name|x_offset
parameter_list|,
name|png_int_32
name|y_offset
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_oFFs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit_type
operator|>=
name|PNG_OFFSET_LAST
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unrecognized unit type for oFFs chunk"
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
argument_list|,
name|x_offset
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|y_offset
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_oFFs
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|9
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_pCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the pCAL chunk (described in the PNG extensions document) */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_pCAL
name|png_write_pCAL
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_charp
name|purpose
parameter_list|,
name|png_int_32
name|X0
parameter_list|,
name|png_int_32
name|X1
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|nparams
parameter_list|,
name|png_const_charp
name|units
parameter_list|,
name|png_charpp
name|params
parameter_list|)
block|{
name|png_size_t
name|purpose_len
decl_stmt|,
name|units_len
decl_stmt|,
name|total_len
decl_stmt|;
name|png_size_tp
name|params_len
decl_stmt|;
name|png_byte
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|png_charp
name|new_purpose
decl_stmt|;
name|int
name|i
decl_stmt|;
name|png_debug1
argument_list|(
literal|1
argument_list|,
literal|"in png_write_pCAL (%d parameters)"
argument_list|,
name|nparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|PNG_EQUATION_LAST
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unrecognized equation type for pCAL chunk"
argument_list|)
expr_stmt|;
name|purpose_len
operator|=
name|png_check_keyword
argument_list|(
name|png_ptr
argument_list|,
name|purpose
argument_list|,
operator|&
name|new_purpose
argument_list|)
operator|+
literal|1
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"pCAL purpose length = %d"
argument_list|,
operator|(
name|int
operator|)
name|purpose_len
argument_list|)
expr_stmt|;
name|units_len
operator|=
name|png_strlen
argument_list|(
name|units
argument_list|)
operator|+
operator|(
name|nparams
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"pCAL units length = %d"
argument_list|,
operator|(
name|int
operator|)
name|units_len
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|purpose_len
operator|+
name|units_len
operator|+
literal|10
expr_stmt|;
name|params_len
operator|=
operator|(
name|png_size_tp
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
call|(
name|png_alloc_size_t
call|)
argument_list|(
name|nparams
operator|*
name|png_sizeof
argument_list|(
name|png_size_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the length of each parameter, making sure we don't count the     * null terminator for the last parameter.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|params_len
index|[
name|i
index|]
operator|=
name|png_strlen
argument_list|(
name|params
index|[
name|i
index|]
argument_list|)
operator|+
operator|(
name|i
operator|==
name|nparams
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|png_debug2
argument_list|(
literal|3
argument_list|,
literal|"pCAL parameter %d length = %lu"
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|params_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|total_len
operator|+=
name|params_len
index|[
name|i
index|]
expr_stmt|;
block|}
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"pCAL total length = %d"
argument_list|,
operator|(
name|int
operator|)
name|total_len
argument_list|)
expr_stmt|;
name|png_write_chunk_header
argument_list|(
name|png_ptr
argument_list|,
name|png_pCAL
argument_list|,
operator|(
name|png_uint_32
operator|)
name|total_len
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|new_purpose
argument_list|,
name|purpose_len
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
argument_list|,
name|X0
argument_list|)
expr_stmt|;
name|png_save_int_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|X1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|type
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
operator|(
name|png_byte
operator|)
name|nparams
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|10
argument_list|)
expr_stmt|;
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|units
argument_list|,
operator|(
name|png_size_t
operator|)
name|units_len
argument_list|)
expr_stmt|;
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|new_purpose
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|png_write_chunk_data
argument_list|(
name|png_ptr
argument_list|,
operator|(
name|png_const_bytep
operator|)
name|params
index|[
name|i
index|]
argument_list|,
name|params_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|png_free
argument_list|(
name|png_ptr
argument_list|,
name|params_len
argument_list|)
expr_stmt|;
name|png_write_chunk_end
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_sCAL_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the sCAL chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_sCAL_s
name|png_write_sCAL_s
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|int
name|unit
parameter_list|,
name|png_const_charp
name|width
parameter_list|,
name|png_const_charp
name|height
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|png_size_t
name|wlen
decl_stmt|,
name|hlen
decl_stmt|,
name|total_len
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_sCAL_s"
argument_list|)
expr_stmt|;
name|wlen
operator|=
name|png_strlen
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|png_strlen
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|wlen
operator|+
name|hlen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|total_len
operator|>
literal|64
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Can't write sCAL (buffer too small)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|png_byte
operator|)
name|unit
expr_stmt|;
name|png_memcpy
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|width
argument_list|,
name|wlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Append the '\0' here */
name|png_memcpy
argument_list|(
name|buf
operator|+
name|wlen
operator|+
literal|2
argument_list|,
name|height
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* Do NOT append the '\0' here */
name|png_debug1
argument_list|(
literal|3
argument_list|,
literal|"sCAL total length = %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|total_len
argument_list|)
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_sCAL
argument_list|,
name|buf
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_pHYs_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the pHYs chunk */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_pHYs
name|png_write_pHYs
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_uint_32
name|x_pixels_per_unit
parameter_list|,
name|png_uint_32
name|y_pixels_per_unit
parameter_list|,
name|int
name|unit_type
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_pHYs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit_type
operator|>=
name|PNG_RESOLUTION_LAST
condition|)
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Unrecognized unit type for pHYs chunk"
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
argument_list|,
name|x_pixels_per_unit
argument_list|)
expr_stmt|;
name|png_save_uint_32
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|y_pixels_per_unit
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
operator|(
name|png_byte
operator|)
name|unit_type
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_pHYs
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|9
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_tIME_SUPPORTED
end_ifdef
begin_comment
comment|/* Write the tIME chunk.  Use either png_convert_from_struct_tm()  * or png_convert_from_time_t(), or fill in the structure yourself.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_tIME
name|png_write_tIME
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_const_timep
name|mod_time
parameter_list|)
block|{
name|png_byte
name|buf
index|[
literal|7
index|]
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_tIME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_time
operator|->
name|month
operator|>
literal|12
operator|||
name|mod_time
operator|->
name|month
operator|<
literal|1
operator|||
name|mod_time
operator|->
name|day
operator|>
literal|31
operator|||
name|mod_time
operator|->
name|day
operator|<
literal|1
operator|||
name|mod_time
operator|->
name|hour
operator|>
literal|23
operator|||
name|mod_time
operator|->
name|second
operator|>
literal|60
condition|)
block|{
name|png_warning
argument_list|(
name|png_ptr
argument_list|,
literal|"Invalid time specified for tIME chunk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|png_save_uint_16
argument_list|(
name|buf
argument_list|,
name|mod_time
operator|->
name|year
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|mod_time
operator|->
name|month
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|mod_time
operator|->
name|day
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|mod_time
operator|->
name|hour
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|mod_time
operator|->
name|minute
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|mod_time
operator|->
name|second
expr_stmt|;
name|png_write_complete_chunk
argument_list|(
name|png_ptr
argument_list|,
name|png_tIME
argument_list|,
name|buf
argument_list|,
operator|(
name|png_size_t
operator|)
literal|7
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Initializes the row writing capability of libpng */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_start_row
name|png_write_start_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
endif|#
directive|endif
name|png_alloc_size_t
name|buf_size
decl_stmt|;
name|int
name|usr_pixel_depth
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_start_row"
argument_list|)
expr_stmt|;
name|usr_pixel_depth
operator|=
name|png_ptr
operator|->
name|usr_channels
operator|*
name|png_ptr
operator|->
name|usr_bit_depth
expr_stmt|;
name|buf_size
operator|=
name|PNG_ROWBYTES
argument_list|(
name|usr_pixel_depth
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 1.5.6: added to allow checking in the row write code. */
name|png_ptr
operator|->
name|transformed_pixel_depth
operator|=
name|png_ptr
operator|->
name|pixel_depth
expr_stmt|;
name|png_ptr
operator|->
name|maximum_pixel_depth
operator|=
operator|(
name|png_byte
operator|)
name|usr_pixel_depth
expr_stmt|;
comment|/* Set up row buffer */
name|png_ptr
operator|->
name|row_buf
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|row_buf
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
comment|/* Set up filtering buffer, if using this filter */
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_SUB
condition|)
block|{
name|png_ptr
operator|->
name|sub_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|sub_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_SUB
expr_stmt|;
block|}
comment|/* We only need to keep the previous row if we are using one of these. */
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|&
operator|(
name|PNG_FILTER_AVG
operator||
name|PNG_FILTER_UP
operator||
name|PNG_FILTER_PAETH
operator|)
condition|)
block|{
comment|/* Set up previous row buffer */
name|png_ptr
operator|->
name|prev_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_calloc
argument_list|(
name|png_ptr
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_UP
condition|)
block|{
name|png_ptr
operator|->
name|up_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|up_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_UP
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_AVG
condition|)
block|{
name|png_ptr
operator|->
name|avg_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|avg_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_AVG
expr_stmt|;
block|}
if|if
condition|(
name|png_ptr
operator|->
name|do_filter
operator|&
name|PNG_FILTER_PAETH
condition|)
block|{
name|png_ptr
operator|->
name|paeth_row
operator|=
operator|(
name|png_bytep
operator|)
name|png_malloc
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|paeth_row
index|[
literal|0
index|]
operator|=
name|PNG_FILTER_VALUE_PAETH
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PNG_WRITE_FILTER_SUPPORTED */
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* If interlaced, we need to set up width and height of pass */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
operator|)
condition|)
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
literal|0
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
literal|0
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
literal|0
index|]
expr_stmt|;
name|png_ptr
operator|->
name|usr_width
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
literal|0
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
literal|0
index|]
operator|)
operator|/
name|png_pass_inc
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|usr_width
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|png_ptr
operator|->
name|num_rows
operator|=
name|png_ptr
operator|->
name|height
expr_stmt|;
name|png_ptr
operator|->
name|usr_width
operator|=
name|png_ptr
operator|->
name|width
expr_stmt|;
block|}
name|png_zlib_claim
argument_list|(
name|png_ptr
argument_list|,
name|PNG_ZLIB_FOR_IDAT
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Internal use only.  Called when finished processing a row of data. */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_finish_row
name|png_write_finish_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Start of interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_ystart
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
comment|/* Offset to next interlace block in the y direction */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_yinc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
endif|#
directive|endif
name|int
name|ret
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_finish_row"
argument_list|)
expr_stmt|;
comment|/* Next row */
name|png_ptr
operator|->
name|row_number
operator|++
expr_stmt|;
comment|/* See if we are done */
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|<
name|png_ptr
operator|->
name|num_rows
condition|)
return|return;
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
comment|/* If interlaced, go to next pass */
if|if
condition|(
name|png_ptr
operator|->
name|interlaced
condition|)
block|{
name|png_ptr
operator|->
name|row_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
condition|)
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Loop until we find a non-zero width or height pass */
do|do
block|{
name|png_ptr
operator|->
name|pass
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|>=
literal|7
condition|)
break|break;
name|png_ptr
operator|->
name|usr_width
operator|=
operator|(
name|png_ptr
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
name|png_ptr
operator|->
name|num_rows
operator|=
operator|(
name|png_ptr
operator|->
name|height
operator|+
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_ystart
index|[
name|png_ptr
operator|->
name|pass
index|]
operator|)
operator|/
name|png_pass_yinc
index|[
name|png_ptr
operator|->
name|pass
index|]
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|transformations
operator|&
name|PNG_INTERLACE
condition|)
break|break;
block|}
do|while
condition|(
name|png_ptr
operator|->
name|usr_width
operator|==
literal|0
operator|||
name|png_ptr
operator|->
name|num_rows
operator|==
literal|0
condition|)
do|;
block|}
comment|/* Reset the row above the image for the next pass */
if|if
condition|(
name|png_ptr
operator|->
name|pass
operator|<
literal|7
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|!=
name|NULL
condition|)
name|png_memset
argument_list|(
name|png_ptr
operator|->
name|prev_row
argument_list|,
literal|0
argument_list|,
call|(
name|png_size_t
call|)
argument_list|(
name|PNG_ROWBYTES
argument_list|(
name|png_ptr
operator|->
name|usr_channels
operator|*
name|png_ptr
operator|->
name|usr_bit_depth
argument_list|,
name|png_ptr
operator|->
name|width
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* If we get here, we've just written the last row, so we need       to flush the compressor */
do|do
block|{
comment|/* Tell the compressor we are done */
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
comment|/* Check for an error */
if|if
condition|(
name|ret
operator|==
name|Z_OK
condition|)
block|{
comment|/* Check to see if we need more room */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
condition|)
block|{
name|png_write_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|png_ptr
operator|->
name|zbuf
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|png_ptr
operator|->
name|zbuf_size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib error"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
comment|/* Write any extra space */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|<
name|png_ptr
operator|->
name|zbuf_size
condition|)
block|{
name|png_write_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
operator|-
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
block|}
name|png_zlib_release
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|data_type
operator|=
name|Z_BINARY
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|PNG_WRITE_INTERLACING_SUPPORTED
end_ifdef
begin_comment
comment|/* Pick out the correct pixels for the interlace pass.  * The basic idea here is to go through the row with a source  * pointer and a destination pointer (sp and dp), and copy the  * correct pixels for the pass.  As the row gets compacted,  * sp will always be>= dp, so we should never overwrite anything.  * See the default: case for the easiest code to understand.  */
end_comment
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_do_write_interlace
name|png_do_write_interlace
parameter_list|(
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|row
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
comment|/* Start of interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_start
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
comment|/* Offset to next interlace block */
specifier|static
name|PNG_CONST
name|png_byte
name|png_pass_inc
index|[
literal|7
index|]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_do_write_interlace"
argument_list|)
expr_stmt|;
comment|/* We don't have to do anything on the last pass (6) */
if|if
condition|(
name|pass
operator|<
literal|6
condition|)
block|{
comment|/* Each pixel depth is handled separately */
switch|switch
condition|(
name|row_info
operator|->
name|pixel_depth
condition|)
block|{
case|case
literal|1
case|:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|value
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|i
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|sp
operator|>>
operator|(
literal|7
operator|-
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x07
argument_list|)
operator|)
argument_list|)
operator|&
literal|0x01
expr_stmt|;
name|d
operator||=
operator|(
name|value
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|7
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|shift
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
literal|7
condition|)
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|value
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|6
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
operator|(
operator|(
literal|3
operator|-
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x03
argument_list|)
operator|)
operator|<<
literal|1
operator|)
operator|)
operator|&
literal|0x03
expr_stmt|;
name|d
operator||=
operator|(
name|value
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|6
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
literal|6
condition|)
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
break|break;
block|}
case|case
literal|4
case|:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|value
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|dp
operator|=
name|row
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
name|sp
operator|=
name|row
operator|+
call|(
name|png_size_t
call|)
argument_list|(
name|i
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|*
name|sp
operator|>>
operator|(
operator|(
literal|1
operator|-
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x01
argument_list|)
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|d
operator||=
operator|(
name|value
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|shift
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
literal|4
condition|)
operator|*
name|dp
operator|=
operator|(
name|png_byte
operator|)
name|d
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|png_bytep
name|sp
decl_stmt|;
name|png_bytep
name|dp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
name|png_uint_32
name|row_width
init|=
name|row_info
operator|->
name|width
decl_stmt|;
name|png_size_t
name|pixel_bytes
decl_stmt|;
comment|/* Start at the beginning */
name|dp
operator|=
name|row
expr_stmt|;
comment|/* Find out how many bytes each pixel takes up */
name|pixel_bytes
operator|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|>>
literal|3
operator|)
expr_stmt|;
comment|/* Loop through the row, only looking at the pixels that matter */
for|for
control|(
name|i
operator|=
name|png_pass_start
index|[
name|pass
index|]
init|;
name|i
operator|<
name|row_width
condition|;
name|i
operator|+=
name|png_pass_inc
index|[
name|pass
index|]
control|)
block|{
comment|/* Find out where the original pixel is */
name|sp
operator|=
name|row
operator|+
operator|(
name|png_size_t
operator|)
name|i
operator|*
name|pixel_bytes
expr_stmt|;
comment|/* Move the pixel */
if|if
condition|(
name|dp
operator|!=
name|sp
condition|)
name|png_memcpy
argument_list|(
name|dp
argument_list|,
name|sp
argument_list|,
name|pixel_bytes
argument_list|)
expr_stmt|;
comment|/* Next pixel */
name|dp
operator|+=
name|pixel_bytes
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Set new row width */
name|row_info
operator|->
name|width
operator|=
operator|(
name|row_info
operator|->
name|width
operator|+
name|png_pass_inc
index|[
name|pass
index|]
operator|-
literal|1
operator|-
name|png_pass_start
index|[
name|pass
index|]
operator|)
operator|/
name|png_pass_inc
index|[
name|pass
index|]
expr_stmt|;
name|row_info
operator|->
name|rowbytes
operator|=
name|PNG_ROWBYTES
argument_list|(
name|row_info
operator|->
name|pixel_depth
argument_list|,
name|row_info
operator|->
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This filters the row, chooses which filter to use, if it has not already  * been specified by the application, and then writes the row out with the  * chosen filter.  */
end_comment
begin_function_decl
specifier|static
name|void
name|png_write_filtered_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|filtered_row
parameter_list|,
name|png_size_t
name|row_bytes
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|PNG_MAXSUM
define|#
directive|define
name|PNG_MAXSUM
value|(((png_uint_32)(-1))>> 1)
end_define
begin_define
DECL|macro|PNG_HISHIFT
define|#
directive|define
name|PNG_HISHIFT
value|10
end_define
begin_define
DECL|macro|PNG_LOMASK
define|#
directive|define
name|PNG_LOMASK
value|((png_uint_32)0xffffL)
end_define
begin_define
DECL|macro|PNG_HIMASK
define|#
directive|define
name|PNG_HIMASK
value|((png_uint_32)(~PNG_LOMASK>> PNG_HISHIFT))
end_define
begin_function
name|void
comment|/* PRIVATE */
DECL|function|png_write_find_filter
name|png_write_find_filter
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|)
block|{
name|png_bytep
name|best_row
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
name|png_bytep
name|prev_row
decl_stmt|,
name|row_buf
decl_stmt|;
name|png_uint_32
name|mins
decl_stmt|,
name|bpp
decl_stmt|;
name|png_byte
name|filter_to_do
init|=
name|png_ptr
operator|->
name|do_filter
decl_stmt|;
name|png_size_t
name|row_bytes
init|=
name|row_info
operator|->
name|rowbytes
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
name|int
name|num_p_filters
init|=
name|png_ptr
operator|->
name|num_prev_filters
decl_stmt|;
endif|#
directive|endif
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_find_filter"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|row_number
operator|==
literal|0
operator|&&
name|filter_to_do
operator|==
name|PNG_ALL_FILTERS
condition|)
block|{
comment|/* These will never be selected so we need not test them. */
name|filter_to_do
operator|&=
operator|~
operator|(
name|PNG_FILTER_UP
operator||
name|PNG_FILTER_PAETH
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Find out how many bytes offset each pixel is */
name|bpp
operator|=
operator|(
name|row_info
operator|->
name|pixel_depth
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|prev_row
operator|=
name|png_ptr
operator|->
name|prev_row
expr_stmt|;
endif|#
directive|endif
name|best_row
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
name|row_buf
operator|=
name|best_row
expr_stmt|;
name|mins
operator|=
name|PNG_MAXSUM
expr_stmt|;
comment|/* The prediction method we use is to find which method provides the     * smallest value when summing the absolute values of the distances     * from zero, using anything>= 128 as negative numbers.  This is known     * as the "minimum sum of absolute differences" heuristic.  Other     * heuristics are the "weighted minimum sum of absolute differences"     * (experimental and can in theory improve compression), and the "zlib     * predictive" method (not implemented yet), which does test compressions     * of lines using different filter methods, and then chooses the     * (series of) filter(s) that give minimum compressed data size (VERY     * computationally expensive).     *     * GRR 980525:  consider also     *     *   (1) minimum sum of absolute differences from running average (i.e.,     *       keep running sum of non-absolute differences& count of bytes)     *       [track dispersion, too?  restart average if dispersion too large?]     *     *  (1b) minimum sum of absolute differences from sliding average, probably     *       with window size<= deflate window (usually 32K)     *     *   (2) minimum sum of squared differences from zero or running average     *       (i.e., ~ root-mean-square approach)     */
comment|/* We don't need to test the 'no filter' case if this is the only filter     * that has been chosen, as it doesn't actually do anything to the data.     */
if|if
condition|(
operator|(
name|filter_to_do
operator|&
name|PNG_FILTER_NONE
operator|)
operator|&&
name|filter_to_do
operator|!=
name|PNG_FILTER_NONE
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|rp
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|int
name|j
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
comment|/* Gives us some footroom */
comment|/* Reduce the sum if we match any of the previous rows */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_NONE
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
comment|/* Factor in the cost of this filter (this is here for completeness,           * but it makes no sense to have a "cost" for the NONE filter, as           * it has the minimum possible computational cost - none).           */
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_NONE
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_NONE
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
name|mins
operator|=
name|sum
expr_stmt|;
block|}
comment|/* Sub filter */
if|if
condition|(
name|filter_to_do
operator|==
name|PNG_FILTER_SUB
condition|)
comment|/* It's the only filter so no testing is needed */
block|{
name|png_bytep
name|rp
decl_stmt|,
name|lp
decl_stmt|,
name|dp
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|sub_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
operator|*
name|rp
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|lp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|-
operator|(
name|int
operator|)
operator|*
name|lp
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|sub_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filter_to_do
operator|&
name|PNG_FILTER_SUB
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* We temporarily increase the "minimum sum" by the factor we        * would reduce the sum of this filter, so that we can do the        * early exit comparison without scaling the sum each time.        */
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_SUB
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|sub_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|=
operator|*
name|rp
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|lp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|-
operator|(
name|int
operator|)
operator|*
name|lp
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_SUB
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_SUB
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|mins
operator|=
name|sum
expr_stmt|;
name|best_row
operator|=
name|png_ptr
operator|->
name|sub_row
expr_stmt|;
block|}
block|}
comment|/* Up filter */
if|if
condition|(
name|filter_to_do
operator|==
name|PNG_FILTER_UP
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|up_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
operator|,
name|pp
operator|++
operator|,
name|dp
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|up_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filter_to_do
operator|&
name|PNG_FILTER_UP
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_UP
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|up_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_UP
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_UP
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|mins
operator|=
name|sum
expr_stmt|;
name|best_row
operator|=
name|png_ptr
operator|->
name|up_row
expr_stmt|;
block|}
block|}
comment|/* Avg filter */
if|if
condition|(
name|filter_to_do
operator|==
name|PNG_FILTER_AVG
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|avg_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|/
literal|2
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|+
operator|(
name|int
operator|)
operator|*
name|lp
operator|++
operator|)
operator|/
literal|2
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|avg_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filter_to_do
operator|&
name|PNG_FILTER_AVG
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_AVG
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|avg_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|/
literal|2
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
operator|(
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|+
operator|(
name|int
operator|)
operator|*
name|lp
operator|++
operator|)
operator|/
literal|2
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_NONE
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_AVG
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|mins
operator|=
name|sum
expr_stmt|;
name|best_row
operator|=
name|png_ptr
operator|->
name|avg_row
expr_stmt|;
block|}
block|}
comment|/* Paeth filter */
if|if
condition|(
name|filter_to_do
operator|==
name|PNG_FILTER_PAETH
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|cp
decl_stmt|,
name|lp
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|paeth_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|cp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|pc
decl_stmt|,
name|p
decl_stmt|;
name|b
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|a
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|p
operator|=
name|b
operator|-
name|c
expr_stmt|;
name|pc
operator|=
name|a
operator|-
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USE_ABS
name|pa
operator|=
name|abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|+
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|p
operator|<
literal|0
condition|?
operator|-
name|p
else|:
name|p
expr_stmt|;
name|pb
operator|=
name|pc
operator|<
literal|0
condition|?
operator|-
name|pc
else|:
name|pc
expr_stmt|;
name|pc
operator|=
operator|(
name|p
operator|+
name|pc
operator|)
operator|<
literal|0
condition|?
operator|-
operator|(
name|p
operator|+
name|pc
operator|)
else|:
name|p
operator|+
name|pc
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
operator|)
condition|?
name|a
else|:
operator|(
name|pb
operator|<=
name|pc
operator|)
condition|?
name|b
else|:
name|c
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
name|p
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|best_row
operator|=
name|png_ptr
operator|->
name|paeth_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filter_to_do
operator|&
name|PNG_FILTER_PAETH
condition|)
block|{
name|png_bytep
name|rp
decl_stmt|,
name|dp
decl_stmt|,
name|pp
decl_stmt|,
name|cp
decl_stmt|,
name|lp
decl_stmt|;
name|png_uint_32
name|sum
init|=
literal|0
decl_stmt|,
name|lmins
init|=
name|mins
decl_stmt|;
name|png_size_t
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|lmhi
decl_stmt|,
name|lmlo
decl_stmt|;
name|lmlo
operator|=
name|lmins
operator|&
name|PNG_LOMASK
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmins
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_PAETH
condition|)
block|{
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|lmlo
operator|=
operator|(
name|lmlo
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|lmhi
operator|=
operator|(
name|lmhi
operator|*
name|png_ptr
operator|->
name|inv_filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|lmhi
operator|>
name|PNG_HIMASK
condition|)
name|lmins
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|lmins
operator|=
operator|(
name|lmhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|lmlo
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|dp
operator|=
name|png_ptr
operator|->
name|paeth_row
operator|+
literal|1
operator|,
name|pp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|bpp
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
operator|(
name|int
operator|)
operator|*
name|pp
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|row_buf
operator|+
literal|1
operator|,
name|cp
operator|=
name|prev_row
operator|+
literal|1
init|;
name|i
operator|<
name|row_bytes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|pc
decl_stmt|,
name|p
decl_stmt|;
name|b
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|a
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|PNG_SLOW_PAETH
name|p
operator|=
name|b
operator|-
name|c
expr_stmt|;
name|pc
operator|=
name|a
operator|-
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_USE_ABS
name|pa
operator|=
name|abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|+
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pa
operator|=
name|p
operator|<
literal|0
condition|?
operator|-
name|p
else|:
name|p
expr_stmt|;
name|pb
operator|=
name|pc
operator|<
literal|0
condition|?
operator|-
name|pc
else|:
name|pc
expr_stmt|;
name|pc
operator|=
operator|(
name|p
operator|+
name|pc
operator|)
operator|<
literal|0
condition|?
operator|-
operator|(
name|p
operator|+
name|pc
operator|)
else|:
name|p
operator|+
name|pc
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
operator|)
condition|?
name|a
else|:
operator|(
name|pb
operator|<=
name|pc
operator|)
condition|?
name|b
else|:
name|c
expr_stmt|;
else|#
directive|else
comment|/* PNG_SLOW_PAETH */
name|p
operator|=
name|a
operator|+
name|b
operator|-
name|c
expr_stmt|;
name|pa
operator|=
name|abs
argument_list|(
name|p
operator|-
name|a
argument_list|)
expr_stmt|;
name|pb
operator|=
name|abs
argument_list|(
name|p
operator|-
name|b
argument_list|)
expr_stmt|;
name|pc
operator|=
name|abs
argument_list|(
name|p
operator|-
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
condition|)
name|p
operator|=
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|pb
operator|<=
name|pc
condition|)
name|p
operator|=
name|b
expr_stmt|;
else|else
name|p
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
comment|/* PNG_SLOW_PAETH */
name|v
operator|=
operator|*
name|dp
operator|++
operator|=
call|(
name|png_byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|rp
operator|++
operator|-
name|p
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|v
operator|<
literal|128
operator|)
condition|?
name|v
else|:
literal|256
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|lmins
condition|)
comment|/* We are already worse, don't continue. */
break|break;
block|}
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
if|if
condition|(
name|png_ptr
operator|->
name|heuristic_method
operator|==
name|PNG_FILTER_HEURISTIC_WEIGHTED
condition|)
block|{
name|int
name|j
decl_stmt|;
name|png_uint_32
name|sumhi
decl_stmt|,
name|sumlo
decl_stmt|;
name|sumlo
operator|=
name|sum
operator|&
name|PNG_LOMASK
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sum
operator|>>
name|PNG_HISHIFT
operator|)
operator|&
name|PNG_HIMASK
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|==
name|PNG_FILTER_VALUE_PAETH
condition|)
block|{
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_weights
index|[
name|j
index|]
operator|)
operator|>>
name|PNG_WEIGHT_SHIFT
expr_stmt|;
block|}
block|}
name|sumlo
operator|=
operator|(
name|sumlo
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
name|sumhi
operator|=
operator|(
name|sumhi
operator|*
name|png_ptr
operator|->
name|filter_costs
index|[
name|PNG_FILTER_VALUE_PAETH
index|]
operator|)
operator|>>
name|PNG_COST_SHIFT
expr_stmt|;
if|if
condition|(
name|sumhi
operator|>
name|PNG_HIMASK
condition|)
name|sum
operator|=
name|PNG_MAXSUM
expr_stmt|;
else|else
name|sum
operator|=
operator|(
name|sumhi
operator|<<
name|PNG_HISHIFT
operator|)
operator|+
name|sumlo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sum
operator|<
name|mins
condition|)
block|{
name|best_row
operator|=
name|png_ptr
operator|->
name|paeth_row
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PNG_WRITE_FILTER_SUPPORTED */
comment|/* Do the actual writing of the filtered row data from the chosen filter. */
name|png_write_filtered_row
argument_list|(
name|png_ptr
argument_list|,
name|best_row
argument_list|,
name|row_info
operator|->
name|rowbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FILTER_SUPPORTED
ifdef|#
directive|ifdef
name|PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
comment|/* Save the type of filter we picked this time for future calculations */
if|if
condition|(
name|png_ptr
operator|->
name|num_prev_filters
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|num_p_filters
condition|;
name|j
operator|++
control|)
block|{
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|=
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|png_ptr
operator|->
name|prev_filters
index|[
name|j
index|]
operator|=
name|best_row
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* PNG_WRITE_FILTER_SUPPORTED */
block|}
end_function
begin_comment
comment|/* Do the actual writing of a previously filtered row. */
end_comment
begin_function
specifier|static
name|void
DECL|function|png_write_filtered_row
name|png_write_filtered_row
parameter_list|(
name|png_structp
name|png_ptr
parameter_list|,
name|png_bytep
name|filtered_row
parameter_list|,
name|png_size_t
name|avail
comment|/*includes filter byte*/
parameter_list|)
block|{
name|png_debug
argument_list|(
literal|1
argument_list|,
literal|"in png_write_filtered_row"
argument_list|)
expr_stmt|;
name|png_debug1
argument_list|(
literal|2
argument_list|,
literal|"filter = %d"
argument_list|,
name|filtered_row
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Set up the zlib input buffer */
name|png_ptr
operator|->
name|zstream
operator|.
name|next_in
operator|=
name|filtered_row
expr_stmt|;
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* Repeat until we have compressed all the data */
do|do
block|{
name|int
name|ret
decl_stmt|;
comment|/* Return of zlib */
comment|/* Record the number of bytes available - zlib supports at least 65535        * bytes at one step, depending on the size of the zlib type 'uInt', the        * maximum size zlib can write at once is ZLIB_IO_MAX (from pngpriv.h).        * Use this because on 16 bit systems 'rowbytes' can be up to 65536 (i.e.        * one more than 16 bits) and, in this case 'rowbytes+1' can overflow a        * uInt.  ZLIB_IO_MAX can be safely reduced to cause zlib to be called        * with smaller chunks of data.        */
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|avail
operator|>
name|ZLIB_IO_MAX
condition|)
block|{
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|ZLIB_IO_MAX
expr_stmt|;
name|avail
operator|-=
name|ZLIB_IO_MAX
expr_stmt|;
block|}
else|else
block|{
comment|/* So this will fit in the available uInt space: */
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|avail
expr_stmt|;
name|avail
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Compress the data */
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|png_ptr
operator|->
name|zstream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
comment|/* Check for compression errors */
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
if|if
condition|(
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
operator|!=
name|NULL
condition|)
name|png_error
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zstream
operator|.
name|msg
argument_list|)
expr_stmt|;
else|else
name|png_error
argument_list|(
name|png_ptr
argument_list|,
literal|"zlib error"
argument_list|)
expr_stmt|;
block|}
comment|/* See if it is time to write another IDAT */
if|if
condition|(
operator|!
operator|(
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_out
operator|)
condition|)
block|{
comment|/* Write the IDAT and reset the zlib output buffer */
name|png_write_IDAT
argument_list|(
name|png_ptr
argument_list|,
name|png_ptr
operator|->
name|zbuf
argument_list|,
name|png_ptr
operator|->
name|zbuf_size
argument_list|)
expr_stmt|;
block|}
comment|/* Repeat until all data has been compressed */
block|}
do|while
condition|(
name|avail
operator|>
literal|0
operator|||
name|png_ptr
operator|->
name|zstream
operator|.
name|avail_in
operator|>
literal|0
condition|)
do|;
comment|/* Swap the current and previous rows */
if|if
condition|(
name|png_ptr
operator|->
name|prev_row
operator|!=
name|NULL
condition|)
block|{
name|png_bytep
name|tptr
decl_stmt|;
name|tptr
operator|=
name|png_ptr
operator|->
name|prev_row
expr_stmt|;
name|png_ptr
operator|->
name|prev_row
operator|=
name|png_ptr
operator|->
name|row_buf
expr_stmt|;
name|png_ptr
operator|->
name|row_buf
operator|=
name|tptr
expr_stmt|;
block|}
comment|/* Finish row - updates counters and flushes zlib if last row */
name|png_write_finish_row
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_WRITE_FLUSH_SUPPORTED
name|png_ptr
operator|->
name|flush_rows
operator|++
expr_stmt|;
if|if
condition|(
name|png_ptr
operator|->
name|flush_dist
operator|>
literal|0
operator|&&
name|png_ptr
operator|->
name|flush_rows
operator|>=
name|png_ptr
operator|->
name|flush_dist
condition|)
block|{
name|png_write_flush
argument_list|(
name|png_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PNG_WRITE_SUPPORTED */
end_comment
end_unit
