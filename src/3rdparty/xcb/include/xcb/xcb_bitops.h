begin_unit
begin_ifndef
ifndef|#
directive|ifndef
name|__XCB_BITOPS_H__
end_ifndef
begin_define
DECL|macro|__XCB_BITOPS_H__
define|#
directive|define
name|__XCB_BITOPS_H__
end_define
begin_comment
comment|/* Copyright (C) 2007 Bart Massey  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the authors or their  * institutions shall not be used in advertising or otherwise to promote the  * sale, use or other dealings in this Software without prior written  * authorization from the authors.  */
end_comment
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<inttypes.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xfuncproto.h>
end_include
begin_comment
comment|/**  * @defgroup xcb__bitops XCB Bit Operations  *  * Inline functions for common bit ops used in XCB and elsewhere.  *  * @{  */
end_comment
begin_comment
comment|/**  * Create a low-order bitmask.  * @param n Mask size.  * @return Mask.  *  * Create a bitmask with the lower @p n bits set and the  * rest of the word clear.  * @ingroup xcb__bitops  */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|uint32_t
DECL|function|xcb_mask
name|xcb_mask
parameter_list|(
name|uint32_t
name|n
parameter_list|)
block|{
return|return
name|n
operator|==
literal|32
condition|?
operator|~
literal|0
else|:
operator|(
literal|1
operator|<<
name|n
operator|)
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/**  * Population count.  * @param n Integer representing a bitset.  * @return Number of 1 bits in the bitset.  *  * This is a reasonably fast algorithm for counting the bits  * in a 32-bit word.  Currently a classic binary  * divide-and-conquer popcount: popcount_2() from  * http://en.wikipedia.org/wiki/Hamming_weight.  * @ingroup xcb__bitops  */
end_comment
begin_comment
comment|/* 15 ops, 3 long immediates, 14 stages, 9 alu ops, 9 alu stages */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|uint32_t
DECL|function|xcb_popcount
name|xcb_popcount
parameter_list|(
name|uint32_t
name|x
parameter_list|)
block|{
name|uint32_t
name|m1
init|=
literal|0x55555555
decl_stmt|;
name|uint32_t
name|m2
init|=
literal|0x33333333
decl_stmt|;
name|uint32_t
name|m4
init|=
literal|0x0f0f0f0f
decl_stmt|;
name|x
operator|-=
operator|(
name|x
operator|>>
literal|1
operator|)
operator|&
name|m1
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
name|m2
operator|)
operator|+
operator|(
operator|(
name|x
operator|>>
literal|2
operator|)
operator|&
name|m2
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|4
operator|)
operator|)
operator|&
name|m4
expr_stmt|;
name|x
operator|+=
name|x
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|16
operator|)
operator|)
operator|&
literal|0x3f
return|;
block|}
end_function
begin_comment
comment|/**  * Round up to the next power-of-two unit size.  * @param base Number to be rounded up.  * @param pad Multiple to be rounded to; must be a power of two.  * @return Rounded-up number.  *  * Rounds @p base up to a multiple of @p pad, where @p pad  * is a power of two.  The more general case is handled by  * xcb_roundup().  * @ingroup xcb__bitops  */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|uint32_t
DECL|function|xcb_roundup_2
name|xcb_roundup_2
parameter_list|(
name|uint32_t
name|base
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
return|return
operator|(
name|base
operator|+
name|pad
operator|-
literal|1
operator|)
operator|&
operator|-
name|pad
return|;
block|}
end_function
begin_comment
comment|/**  * Round down to the next power-of-two unit size.  * @param base Number to be rounded down.  * @param pad Multiple to be rounded to; must be a power of two.  * @return Rounded-down number.  *  * Rounds @p base down to a multiple of @p pad, where @p pad  * is a power of two.  The more general case is handled by  * xcb_rounddown().  * @ingroup xcb__bitops  */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|uint32_t
DECL|function|xcb_rounddown_2
name|xcb_rounddown_2
parameter_list|(
name|uint32_t
name|base
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
return|return
name|base
operator|&
operator|-
name|pad
return|;
block|}
end_function
begin_comment
comment|/**  * Round up to the next unit size.  * @param base Number to be rounded up.  * @param pad Multiple to be rounded to.  * @return Rounded-up number.  *  * This is a general routine for rounding @p base up  * to a multiple of @p pad.  If you know that @p pad  * is a power of two, you should probably call xcb_roundup_2()  * instead.  * @ingroup xcb__bitops  */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|uint32_t
DECL|function|xcb_roundup
name|xcb_roundup
parameter_list|(
name|uint32_t
name|base
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
name|uint32_t
name|b
init|=
name|base
operator|+
name|pad
operator|-
literal|1
decl_stmt|;
comment|/* faster if pad is a power of two */
if|if
condition|(
operator|(
operator|(
name|pad
operator|-
literal|1
operator|)
operator|&
name|pad
operator|)
operator|==
literal|0
condition|)
return|return
name|b
operator|&
operator|-
name|pad
return|;
return|return
name|b
operator|-
name|b
operator|%
name|pad
return|;
block|}
end_function
begin_comment
comment|/**  * Round down to the next unit size.  * @param base Number to be rounded down.  * @param pad Multiple to be rounded to.  * @return Rounded-down number.  *  * This is a general routine for rounding @p base down  * to a multiple of @p pad.  If you know that @p pad  * is a power of two, you should probably call xcb_rounddown_2()  * instead.  * @ingroup xcb__bitops  */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|uint32_t
DECL|function|xcb_rounddown
name|xcb_rounddown
parameter_list|(
name|uint32_t
name|base
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
comment|/* faster if pad is a power of two */
if|if
condition|(
operator|(
operator|(
name|pad
operator|-
literal|1
operator|)
operator|&
name|pad
operator|)
operator|==
literal|0
condition|)
return|return
name|base
operator|&
operator|-
name|pad
return|;
return|return
name|base
operator|-
name|base
operator|%
name|pad
return|;
block|}
end_function
begin_comment
comment|/**  * Reverse bits of word.  * @param x Target word.  * @param n Number of low-order bits to reverse.  * @return Word with low @p n bits reversed, all others 0.  *  * Reverses the bottom @p n bits of @p x.  * @ingroup xcb__bitops  */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|uint32_t
DECL|function|xcb_bit_reverse
name|xcb_bit_reverse
parameter_list|(
name|uint32_t
name|x
parameter_list|,
name|uint8_t
name|n
parameter_list|)
block|{
name|uint32_t
name|m1
init|=
literal|0x00ff00ff
decl_stmt|;
name|uint32_t
name|m2
init|=
literal|0x0f0f0f0f
decl_stmt|;
name|uint32_t
name|m3
init|=
literal|0x33333333
decl_stmt|;
name|uint32_t
name|m4
init|=
literal|0x55555555
decl_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
operator|(
name|x
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|&
name|m1
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
name|m1
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|&
name|m2
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|4
operator|)
operator|&
name|m2
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|&
name|m3
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|2
operator|)
operator|&
name|m3
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|&
name|m4
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|1
operator|)
operator|&
name|m4
operator|)
expr_stmt|;
name|x
operator|>>=
literal|32
operator|-
name|n
expr_stmt|;
return|return
name|x
return|;
block|}
end_function
begin_comment
comment|/**  * Host byte order.  * @return The byte order of the host.  *  * Tests the host's byte order and returns either  * XCB_IMAGE_ORDER_MSB_FIRST or XCB_IMAGE_ORDER_LSB_FIRST  * as appropriate.  * @ingroup xcb__bitops  */
end_comment
begin_function
name|_X_INLINE
specifier|static
name|xcb_image_order_t
DECL|function|xcb_host_byte_order
name|xcb_host_byte_order
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|endian_test
init|=
literal|0x01020304
decl_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
operator|&
name|endian_test
condition|)
block|{
case|case
literal|0x01
case|:
return|return
name|XCB_IMAGE_ORDER_MSB_FIRST
return|;
case|case
literal|0x04
case|:
return|return
name|XCB_IMAGE_ORDER_LSB_FIRST
return|;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __XCB_BITOPS_H__ */
end_comment
end_unit
