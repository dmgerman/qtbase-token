begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// debug.h: Debugging utilities.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|COMMON_DEBUG_H_
end_ifndef
begin_define
DECL|macro|COMMON_DEBUG_H_
define|#
directive|define
name|COMMON_DEBUG_H_
end_define
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<string>
end_include
begin_include
include|#
directive|include
file|"common/angleutils.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TRACE_OUTPUT_FILE
argument_list|)
end_if
begin_define
DECL|macro|TRACE_OUTPUT_FILE
define|#
directive|define
name|TRACE_OUTPUT_FILE
value|"debug.txt"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|namespace
name|gl
block|{
enum|enum
name|MessageType
block|{
name|MESSAGE_TRACE
block|,
name|MESSAGE_FIXME
block|,
name|MESSAGE_ERR
block|,
name|MESSAGE_EVENT
block|, }
enum|;
comment|// Outputs text to the debugging log, or the debugging window
name|void
name|trace
parameter_list|(
name|bool
name|traceInDebugOnly
parameter_list|,
name|MessageType
name|messageType
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|// Pairs a D3D begin event with an end event.
name|class
name|ScopedPerfEventHelper
range|:
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|ScopedPerfEventHelper
argument_list|(
specifier|const
name|char
operator|*
name|format
argument_list|,
operator|...
argument_list|)
block|;
operator|~
name|ScopedPerfEventHelper
argument_list|()
block|; }
decl_stmt|;
comment|// Wraps the D3D9/D3D11 debug annotation functions.
name|class
name|DebugAnnotator
range|:
name|angle
operator|::
name|NonCopyable
block|{
name|public
operator|:
name|DebugAnnotator
argument_list|()
block|{ }
block|;
name|virtual
operator|~
name|DebugAnnotator
argument_list|()
block|{ }
block|;
name|virtual
name|void
name|beginEvent
argument_list|(
specifier|const
name|std
operator|::
name|wstring
operator|&
name|eventName
argument_list|)
operator|=
literal|0
block|;
name|virtual
name|void
name|endEvent
argument_list|()
operator|=
literal|0
block|;
name|virtual
name|void
name|setMarker
argument_list|(
specifier|const
name|std
operator|::
name|wstring
operator|&
name|markerName
argument_list|)
operator|=
literal|0
block|;
name|virtual
name|bool
name|getStatus
argument_list|()
operator|=
literal|0
block|; }
decl_stmt|;
name|void
name|InitializeDebugAnnotations
parameter_list|(
name|DebugAnnotator
modifier|*
name|debugAnnotator
parameter_list|)
function_decl|;
name|void
name|UninitializeDebugAnnotations
parameter_list|()
function_decl|;
name|bool
name|DebugAnnotationsActive
parameter_list|()
function_decl|;
block|}
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_ENABLE_DEBUG_TRACE
argument_list|)
operator|||
name|defined
argument_list|(
name|ANGLE_ENABLE_DEBUG_ANNOTATIONS
argument_list|)
end_if
begin_define
DECL|macro|ANGLE_TRACE_ENABLED
define|#
directive|define
name|ANGLE_TRACE_ENABLED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro to output a trace of a function call and its arguments to the debugging log
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_TRACE_ENABLED
argument_list|)
end_if
begin_define
DECL|macro|TRACE
define|#
directive|define
name|TRACE
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|gl::trace(true, gl::MESSAGE_TRACE, "trace: %s(%d): " message "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|TRACE
define|#
directive|define
name|TRACE
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|(void(0))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro to output a function call and its arguments to the debugging log, to denote an item in need of fixing.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_TRACE_ENABLED
argument_list|)
end_if
begin_define
DECL|macro|FIXME
define|#
directive|define
name|FIXME
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|gl::trace(false, gl::MESSAGE_FIXME, "fixme: %s(%d): " message "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|FIXME
define|#
directive|define
name|FIXME
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|(void(0))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro to output a function call and its arguments to the debugging log, in case of error.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_TRACE_ENABLED
argument_list|)
end_if
begin_define
DECL|macro|ERR
define|#
directive|define
name|ERR
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|gl::trace(false, gl::MESSAGE_ERR, "err: %s(%d): " message "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ERR
define|#
directive|define
name|ERR
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|(void(0))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro to log a performance event around a scope.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_TRACE_ENABLED
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_define
DECL|macro|EVENT
define|#
directive|define
name|EVENT
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|gl::ScopedPerfEventHelper scopedPerfEventHelper ## __LINE__("%s" message "\n", __FUNCTION__, __VA_ARGS__);
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|EVENT
define|#
directive|define
name|EVENT
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|gl::ScopedPerfEventHelper scopedPerfEventHelper(message "\n", ##__VA_ARGS__);
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _MSC_VER
end_comment
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|EVENT
define|#
directive|define
name|EVENT
parameter_list|(
name|message
parameter_list|,
modifier|...
parameter_list|)
value|(void(0))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_TRACE_ENABLED
argument_list|)
end_if
begin_undef
DECL|macro|ANGLE_TRACE_ENABLED
undef|#
directive|undef
name|ANGLE_TRACE_ENABLED
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro asserting a condition and outputting failures to the debug log
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
end_if
begin_define
DECL|macro|ASSERT
define|#
directive|define
name|ASSERT
parameter_list|(
name|expression
parameter_list|)
value|do { \     if(!(expression)) \         ERR("\t! Assert failed in %s(%d): "#expression"\n", __FUNCTION__, __LINE__); \         assert(expression); \     } while(0)
end_define
begin_define
DECL|macro|UNUSED_ASSERTION_VARIABLE
define|#
directive|define
name|UNUSED_ASSERTION_VARIABLE
parameter_list|(
name|variable
parameter_list|)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ASSERT
define|#
directive|define
name|ASSERT
parameter_list|(
name|expression
parameter_list|)
value|(void(0))
end_define
begin_define
DECL|macro|UNUSED_ASSERTION_VARIABLE
define|#
directive|define
name|UNUSED_ASSERTION_VARIABLE
parameter_list|(
name|variable
parameter_list|)
value|((void)variable)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|ANGLE_ENABLE_DEBUG_TRACE
end_ifndef
begin_define
DECL|macro|UNUSED_TRACE_VARIABLE
define|#
directive|define
name|UNUSED_TRACE_VARIABLE
parameter_list|(
name|variable
parameter_list|)
value|((void)variable)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|UNUSED_TRACE_VARIABLE
define|#
directive|define
name|UNUSED_TRACE_VARIABLE
parameter_list|(
name|variable
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro to indicate unimplemented functionality
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANGLE_TEST_CONFIG
argument_list|)
end_if
begin_define
DECL|macro|NOASSERT_UNIMPLEMENTED
define|#
directive|define
name|NOASSERT_UNIMPLEMENTED
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Define NOASSERT_UNIMPLEMENTED to non zero to skip the assert fail in the unimplemented checks
end_comment
begin_comment
comment|// This will allow us to test with some automated test suites (eg dEQP) without crashing
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NOASSERT_UNIMPLEMENTED
end_ifndef
begin_define
DECL|macro|NOASSERT_UNIMPLEMENTED
define|#
directive|define
name|NOASSERT_UNIMPLEMENTED
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
end_if
begin_define
DECL|macro|UNIMPLEMENTED
define|#
directive|define
name|UNIMPLEMENTED
parameter_list|()
value|do { \     FIXME("\t! Unimplemented: %s(%d)\n", __FUNCTION__, __LINE__); \     assert(NOASSERT_UNIMPLEMENTED); \     } while(0)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|UNIMPLEMENTED
define|#
directive|define
name|UNIMPLEMENTED
parameter_list|()
value|FIXME("\t! Unimplemented: %s(%d)\n", __FUNCTION__, __LINE__)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro for code which is not expected to be reached under valid assumptions
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
end_if
begin_define
DECL|macro|UNREACHABLE
define|#
directive|define
name|UNREACHABLE
parameter_list|()
value|do { \     ERR("\t! Unreachable reached: %s(%d)\n", __FUNCTION__, __LINE__); \     assert(false); \     } while(0)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|UNREACHABLE
define|#
directive|define
name|UNREACHABLE
parameter_list|()
value|ERR("\t! Unreachable reached: %s(%d)\n", __FUNCTION__, __LINE__)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro that determines whether an object has a given runtime type.
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|_CPPRTTI
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|__GNUC__
operator|<
literal|4
operator|||
operator|(
name|__GNUC__
operator|==
literal|4
operator|&&
name|__GNUC_MINOR__
operator|<
literal|3
operator|)
operator|||
name|defined
argument_list|(
name|__GXX_RTTI
argument_list|)
operator|)
end_if
begin_define
DECL|macro|HAS_DYNAMIC_TYPE
define|#
directive|define
name|HAS_DYNAMIC_TYPE
parameter_list|(
name|type
parameter_list|,
name|obj
parameter_list|)
value|(dynamic_cast<type>(obj) != NULL)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HAS_DYNAMIC_TYPE
define|#
directive|define
name|HAS_DYNAMIC_TYPE
parameter_list|(
name|type
parameter_list|,
name|obj
parameter_list|)
value|true
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// COMMON_DEBUG_H_
end_comment
end_unit
