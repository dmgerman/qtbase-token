begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright 2015 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// string_utils:
end_comment
begin_comment
comment|//   String helper functions.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|"string_utils.h"
end_include
begin_include
include|#
directive|include
file|<fstream>
end_include
begin_include
include|#
directive|include
file|<sstream>
end_include
begin_namespace
DECL|namespace|angle
namespace|namespace
name|angle
block|{
DECL|member|kWhitespaceASCII
specifier|const
name|char
name|kWhitespaceASCII
index|[]
init|=
literal|" \f\n\r\t\v"
decl_stmt|;
DECL|function|SplitString
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|SplitString
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|input
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|delimiters
parameter_list|,
name|WhitespaceHandling
name|whitespace
parameter_list|,
name|SplitResult
name|resultType
parameter_list|)
block|{
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|input
operator|.
name|empty
argument_list|()
condition|)
block|{
return|return
name|result
return|;
block|}
name|std
operator|::
name|string
operator|::
name|size_type
name|start
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|auto
name|end
init|=
name|input
operator|.
name|find_first_of
argument_list|(
name|delimiters
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|piece
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|piece
operator|=
name|input
operator|.
name|substr
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
name|std
operator|::
name|string
operator|::
name|npos
expr_stmt|;
block|}
else|else
block|{
name|piece
operator|=
name|input
operator|.
name|substr
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|whitespace
operator|==
name|TRIM_WHITESPACE
condition|)
block|{
name|piece
operator|=
name|TrimString
argument_list|(
name|piece
argument_list|,
name|kWhitespaceASCII
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resultType
operator|==
name|SPLIT_WANT_ALL
operator|||
operator|!
name|piece
operator|.
name|empty
argument_list|()
condition|)
block|{
name|result
operator|.
name|push_back
argument_list|(
name|piece
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|function|SplitStringAlongWhitespace
name|void
name|SplitStringAlongWhitespace
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|input
parameter_list|,
name|std
operator|::
name|vector
argument_list|<
name|std
operator|::
name|string
argument_list|>
modifier|*
name|tokensOut
parameter_list|)
block|{
name|std
operator|::
name|istringstream
name|stream
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|line
decl_stmt|;
while|while
condition|(
name|std
operator|::
name|getline
argument_list|(
name|stream
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|size_t
name|prev
init|=
literal|0
decl_stmt|,
name|pos
decl_stmt|;
while|while
condition|(
operator|(
name|pos
operator|=
name|line
operator|.
name|find_first_of
argument_list|(
name|kWhitespaceASCII
argument_list|,
name|prev
argument_list|)
operator|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
if|if
condition|(
name|pos
operator|>
name|prev
condition|)
name|tokensOut
operator|->
name|push_back
argument_list|(
name|line
operator|.
name|substr
argument_list|(
name|prev
argument_list|,
name|pos
operator|-
name|prev
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|<
name|line
operator|.
name|length
argument_list|()
condition|)
name|tokensOut
operator|->
name|push_back
argument_list|(
name|line
operator|.
name|substr
argument_list|(
name|prev
argument_list|,
name|std
operator|::
name|string
operator|::
name|npos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|TrimString
name|std
operator|::
name|string
name|TrimString
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|input
parameter_list|,
specifier|const
name|std
operator|::
name|string
modifier|&
name|trimChars
parameter_list|)
block|{
name|auto
name|begin
init|=
name|input
operator|.
name|find_first_not_of
argument_list|(
name|trimChars
argument_list|)
decl_stmt|;
if|if
condition|(
name|begin
operator|==
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
return|return
literal|""
return|;
block|}
name|std
operator|::
name|string
operator|::
name|size_type
name|end
init|=
name|input
operator|.
name|find_last_not_of
argument_list|(
name|trimChars
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
return|return
name|input
operator|.
name|substr
argument_list|(
name|begin
argument_list|)
return|;
block|}
return|return
name|input
operator|.
name|substr
argument_list|(
name|begin
argument_list|,
name|end
operator|-
name|begin
operator|+
literal|1
argument_list|)
return|;
block|}
DECL|function|HexStringToUInt
name|bool
name|HexStringToUInt
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|input
parameter_list|,
name|unsigned
name|int
modifier|*
name|uintOut
parameter_list|)
block|{
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|input
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|&&
name|input
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|input
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|offset
operator|=
literal|2u
expr_stmt|;
block|}
comment|// Simple validity check
if|if
condition|(
name|input
operator|.
name|find_first_not_of
argument_list|(
literal|"0123456789ABCDEFabcdef"
argument_list|,
name|offset
argument_list|)
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
return|return
literal|false
return|;
block|}
name|std
operator|::
name|stringstream
name|inStream
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|inStream
operator|>>
name|std
operator|::
name|hex
operator|>>
operator|*
name|uintOut
expr_stmt|;
return|return
operator|!
name|inStream
operator|.
name|fail
argument_list|()
return|;
block|}
DECL|function|ReadFileToString
name|bool
name|ReadFileToString
parameter_list|(
specifier|const
name|std
operator|::
name|string
modifier|&
name|path
parameter_list|,
name|std
operator|::
name|string
modifier|*
name|stringOut
parameter_list|)
block|{
name|std
operator|::
name|ifstream
name|inFile
argument_list|(
name|path
operator|.
name|c_str
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inFile
operator|.
name|fail
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|inFile
operator|.
name|seekg
argument_list|(
literal|0
argument_list|,
name|std
operator|::
name|ios
operator|::
name|end
argument_list|)
expr_stmt|;
name|stringOut
operator|->
name|reserve
argument_list|(
cast|static_cast
argument_list|<
name|std
operator|::
name|string
operator|::
name|size_type
argument_list|>
argument_list|(
name|inFile
operator|.
name|tellg
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|inFile
operator|.
name|seekg
argument_list|(
literal|0
argument_list|,
name|std
operator|::
name|ios
operator|::
name|beg
argument_list|)
expr_stmt|;
name|stringOut
operator|->
name|assign
argument_list|(
name|std
operator|::
name|istreambuf_iterator
argument_list|<
name|char
argument_list|>
argument_list|(
name|inFile
argument_list|)
argument_list|,
name|std
operator|::
name|istreambuf_iterator
argument_list|<
name|char
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|!
name|inFile
operator|.
name|fail
argument_list|()
return|;
block|}
block|}
end_namespace
end_unit
