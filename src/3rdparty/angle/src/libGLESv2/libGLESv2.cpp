begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// libGLESv2.cpp: Implements the exported OpenGL ES 2.0 functions.
end_comment
begin_include
include|#
directive|include
file|"common/version.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Fence.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Query.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_function
DECL|function|validImageSize
name|bool
name|validImageSize
parameter_list|(
name|GLint
name|level
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|gl
operator|::
name|getContext
argument_list|()
operator|&&
name|gl
operator|::
name|getContext
argument_list|()
operator|->
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|&&
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// Verify that format/type are one of the combinations from table 3.4.
end_comment
begin_function
DECL|function|checkTextureFormatType
name|bool
name|checkTextureFormatType
parameter_list|(
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|)
block|{
comment|// validate<format> by itself (used as secondary key below)
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
case|case
name|GL_BGRA_EXT
case|:
case|case
name|GL_RGB
case|:
case|case
name|GL_ALPHA
case|:
case|case
name|GL_LUMINANCE
case|:
case|case
name|GL_LUMINANCE_ALPHA
case|:
case|case
name|GL_DEPTH_COMPONENT
case|:
case|case
name|GL_DEPTH_STENCIL_OES
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// invalid<type> -> sets INVALID_ENUM
comment|// invalid<format>+<type> combination -> sets INVALID_OPERATION
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
case|case
name|GL_BGRA_EXT
case|:
case|case
name|GL_RGB
case|:
case|case
name|GL_ALPHA
case|:
case|case
name|GL_LUMINANCE
case|:
case|case
name|GL_LUMINANCE_ALPHA
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
case|case
name|GL_FLOAT
case|:
case|case
name|GL_HALF_FLOAT_OES
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
case|case
name|GL_RGB
case|:
case|case
name|GL_ALPHA
case|:
case|case
name|GL_LUMINANCE
case|:
case|case
name|GL_LUMINANCE_ALPHA
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
case|case
name|GL_UNSIGNED_SHORT_4_4_4_4
case|:
case|case
name|GL_UNSIGNED_SHORT_5_5_5_1
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
case|case
name|GL_UNSIGNED_SHORT_5_6_5
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGB
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
case|case
name|GL_UNSIGNED_SHORT
case|:
case|case
name|GL_UNSIGNED_INT
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_DEPTH_COMPONENT
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
case|case
name|GL_UNSIGNED_INT_24_8_OES
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_DEPTH_STENCIL_OES
case|:
return|return
literal|true
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|validateSubImageParams2D
name|bool
name|validateSubImageParams2D
parameter_list|(
name|bool
name|compressed
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
parameter_list|)
block|{
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|compressed
operator|!=
name|texture
operator|->
name|isCompressed
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|format
operator|!=
name|GL_NONE
condition|)
block|{
name|GLenum
name|internalformat
init|=
name|gl
operator|::
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalformat
operator|!=
name|texture
operator|->
name|getInternalFormat
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|compressed
condition|)
block|{
if|if
condition|(
operator|(
name|width
operator|%
literal|4
operator|!=
literal|0
operator|&&
name|width
operator|!=
name|texture
operator|->
name|getWidth
argument_list|(
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|height
operator|%
literal|4
operator|!=
literal|0
operator|&&
name|height
operator|!=
name|texture
operator|->
name|getHeight
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|xoffset
operator|+
name|width
operator|>
name|texture
operator|->
name|getWidth
argument_list|(
name|level
argument_list|)
operator|||
name|yoffset
operator|+
name|height
operator|>
name|texture
operator|->
name|getHeight
argument_list|(
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|validateSubImageParamsCube
name|bool
name|validateSubImageParamsCube
parameter_list|(
name|bool
name|compressed
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texture
parameter_list|)
block|{
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|compressed
operator|!=
name|texture
operator|->
name|isCompressed
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|format
operator|!=
name|GL_NONE
condition|)
block|{
name|GLenum
name|internalformat
init|=
name|gl
operator|::
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalformat
operator|!=
name|texture
operator|->
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|compressed
condition|)
block|{
if|if
condition|(
operator|(
name|width
operator|%
literal|4
operator|!=
literal|0
operator|&&
name|width
operator|!=
name|texture
operator|->
name|getWidth
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|height
operator|%
literal|4
operator|!=
literal|0
operator|&&
name|height
operator|!=
name|texture
operator|->
name|getHeight
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|xoffset
operator|+
name|width
operator|>
name|texture
operator|->
name|getWidth
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
operator|||
name|yoffset
operator|+
name|height
operator|>
name|texture
operator|->
name|getHeight
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// check for combinations of format and type that are valid for ReadPixels
end_comment
begin_function
DECL|function|validReadFormatType
name|bool
name|validReadFormatType
parameter_list|(
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
case|case
name|GL_BGRA_EXT
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT
case|:
case|case
name|GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT
case|:
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|glActiveTexture
name|void
name|__stdcall
name|glActiveTexture
parameter_list|(
name|GLenum
name|texture
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum texture = 0x%X)"
argument_list|,
name|texture
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|texture
argument_list|<
name|GL_TEXTURE0
operator|||
name|texture
argument_list|>
name|GL_TEXTURE0
operator|+
name|context
operator|->
name|getMaximumCombinedTextureImageUnits
argument_list|()
operator|-
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|context
operator|->
name|setActiveSampler
argument_list|(
name|texture
operator|-
name|GL_TEXTURE0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glAttachShader
name|void
name|__stdcall
name|glAttachShader
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLuint
name|shader
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLuint shader = %d)"
argument_list|,
name|program
argument_list|,
name|shader
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getProgram
argument_list|(
name|shader
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|programObject
operator|->
name|attachShader
argument_list|(
name|shaderObject
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBeginQueryEXT
name|void
name|__stdcall
name|glBeginQueryEXT
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|id
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLuint %d)"
argument_list|,
name|target
argument_list|,
name|id
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|beginQuery
argument_list|(
name|target
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBindAttribLocation
name|void
name|__stdcall
name|glBindAttribLocation
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLuint index = %d, const GLchar* name = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"gl_"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|programObject
operator|->
name|bindAttributeLocation
argument_list|(
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBindBuffer
name|void
name|__stdcall
name|glBindBuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|buffer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLuint buffer = %d)"
argument_list|,
name|target
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
name|context
operator|->
name|bindArrayBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return;
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
name|context
operator|->
name|bindElementArrayBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBindFramebuffer
name|void
name|__stdcall
name|glBindFramebuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|framebuffer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLuint framebuffer = %d)"
argument_list|,
name|target
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|target
operator|!=
name|GL_FRAMEBUFFER
operator|&&
name|target
operator|!=
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|&&
name|target
operator|!=
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|target
operator|==
name|GL_READ_FRAMEBUFFER_ANGLE
operator|||
name|target
operator|==
name|GL_FRAMEBUFFER
condition|)
block|{
name|context
operator|->
name|bindReadFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|||
name|target
operator|==
name|GL_FRAMEBUFFER
condition|)
block|{
name|context
operator|->
name|bindDrawFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBindRenderbuffer
name|void
name|__stdcall
name|glBindRenderbuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLuint renderbuffer = %d)"
argument_list|,
name|target
argument_list|,
name|renderbuffer
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|target
operator|!=
name|GL_RENDERBUFFER
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|bindRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBindTexture
name|void
name|__stdcall
name|glBindTexture
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|texture
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLuint texture = %d)"
argument_list|,
name|target
argument_list|,
name|texture
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|textureObject
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureObject
operator|&&
name|textureObject
operator|->
name|getTarget
argument_list|()
operator|!=
name|target
operator|&&
name|texture
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|context
operator|->
name|bindTexture2D
argument_list|(
name|texture
argument_list|)
expr_stmt|;
return|return;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
name|context
operator|->
name|bindTextureCubeMap
argument_list|(
name|texture
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBlendColor
name|void
name|__stdcall
name|glBlendColor
parameter_list|(
name|GLclampf
name|red
parameter_list|,
name|GLclampf
name|green
parameter_list|,
name|GLclampf
name|blue
parameter_list|,
name|GLclampf
name|alpha
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLclampf red = %f, GLclampf green = %f, GLclampf blue = %f, GLclampf alpha = %f)"
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setBlendColor
argument_list|(
name|gl
operator|::
name|clamp01
argument_list|(
name|red
argument_list|)
argument_list|,
name|gl
operator|::
name|clamp01
argument_list|(
name|green
argument_list|)
argument_list|,
name|gl
operator|::
name|clamp01
argument_list|(
name|blue
argument_list|)
argument_list|,
name|gl
operator|::
name|clamp01
argument_list|(
name|alpha
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBlendEquation
name|void
name|__stdcall
name|glBlendEquation
parameter_list|(
name|GLenum
name|mode
parameter_list|)
block|{
name|glBlendEquationSeparate
argument_list|(
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
DECL|function|glBlendEquationSeparate
name|void
name|__stdcall
name|glBlendEquationSeparate
parameter_list|(
name|GLenum
name|modeRGB
parameter_list|,
name|GLenum
name|modeAlpha
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum modeRGB = 0x%X, GLenum modeAlpha = 0x%X)"
argument_list|,
name|modeRGB
argument_list|,
name|modeAlpha
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|modeRGB
condition|)
block|{
case|case
name|GL_FUNC_ADD
case|:
case|case
name|GL_FUNC_SUBTRACT
case|:
case|case
name|GL_FUNC_REVERSE_SUBTRACT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|modeAlpha
condition|)
block|{
case|case
name|GL_FUNC_ADD
case|:
case|case
name|GL_FUNC_SUBTRACT
case|:
case|case
name|GL_FUNC_REVERSE_SUBTRACT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setBlendEquation
argument_list|(
name|modeRGB
argument_list|,
name|modeAlpha
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBlendFunc
name|void
name|__stdcall
name|glBlendFunc
parameter_list|(
name|GLenum
name|sfactor
parameter_list|,
name|GLenum
name|dfactor
parameter_list|)
block|{
name|glBlendFuncSeparate
argument_list|(
name|sfactor
argument_list|,
name|dfactor
argument_list|,
name|sfactor
argument_list|,
name|dfactor
argument_list|)
expr_stmt|;
block|}
DECL|function|glBlendFuncSeparate
name|void
name|__stdcall
name|glBlendFuncSeparate
parameter_list|(
name|GLenum
name|srcRGB
parameter_list|,
name|GLenum
name|dstRGB
parameter_list|,
name|GLenum
name|srcAlpha
parameter_list|,
name|GLenum
name|dstAlpha
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum srcRGB = 0x%X, GLenum dstRGB = 0x%X, GLenum srcAlpha = 0x%X, GLenum dstAlpha = 0x%X)"
argument_list|,
name|srcRGB
argument_list|,
name|dstRGB
argument_list|,
name|srcAlpha
argument_list|,
name|dstAlpha
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|srcRGB
condition|)
block|{
case|case
name|GL_ZERO
case|:
case|case
name|GL_ONE
case|:
case|case
name|GL_SRC_COLOR
case|:
case|case
name|GL_ONE_MINUS_SRC_COLOR
case|:
case|case
name|GL_DST_COLOR
case|:
case|case
name|GL_ONE_MINUS_DST_COLOR
case|:
case|case
name|GL_SRC_ALPHA
case|:
case|case
name|GL_ONE_MINUS_SRC_ALPHA
case|:
case|case
name|GL_DST_ALPHA
case|:
case|case
name|GL_ONE_MINUS_DST_ALPHA
case|:
case|case
name|GL_CONSTANT_COLOR
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_COLOR
case|:
case|case
name|GL_CONSTANT_ALPHA
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_ALPHA
case|:
case|case
name|GL_SRC_ALPHA_SATURATE
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|dstRGB
condition|)
block|{
case|case
name|GL_ZERO
case|:
case|case
name|GL_ONE
case|:
case|case
name|GL_SRC_COLOR
case|:
case|case
name|GL_ONE_MINUS_SRC_COLOR
case|:
case|case
name|GL_DST_COLOR
case|:
case|case
name|GL_ONE_MINUS_DST_COLOR
case|:
case|case
name|GL_SRC_ALPHA
case|:
case|case
name|GL_ONE_MINUS_SRC_ALPHA
case|:
case|case
name|GL_DST_ALPHA
case|:
case|case
name|GL_ONE_MINUS_DST_ALPHA
case|:
case|case
name|GL_CONSTANT_COLOR
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_COLOR
case|:
case|case
name|GL_CONSTANT_ALPHA
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_ALPHA
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|srcAlpha
condition|)
block|{
case|case
name|GL_ZERO
case|:
case|case
name|GL_ONE
case|:
case|case
name|GL_SRC_COLOR
case|:
case|case
name|GL_ONE_MINUS_SRC_COLOR
case|:
case|case
name|GL_DST_COLOR
case|:
case|case
name|GL_ONE_MINUS_DST_COLOR
case|:
case|case
name|GL_SRC_ALPHA
case|:
case|case
name|GL_ONE_MINUS_SRC_ALPHA
case|:
case|case
name|GL_DST_ALPHA
case|:
case|case
name|GL_ONE_MINUS_DST_ALPHA
case|:
case|case
name|GL_CONSTANT_COLOR
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_COLOR
case|:
case|case
name|GL_CONSTANT_ALPHA
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_ALPHA
case|:
case|case
name|GL_SRC_ALPHA_SATURATE
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|dstAlpha
condition|)
block|{
case|case
name|GL_ZERO
case|:
case|case
name|GL_ONE
case|:
case|case
name|GL_SRC_COLOR
case|:
case|case
name|GL_ONE_MINUS_SRC_COLOR
case|:
case|case
name|GL_DST_COLOR
case|:
case|case
name|GL_ONE_MINUS_DST_COLOR
case|:
case|case
name|GL_SRC_ALPHA
case|:
case|case
name|GL_ONE_MINUS_SRC_ALPHA
case|:
case|case
name|GL_DST_ALPHA
case|:
case|case
name|GL_ONE_MINUS_DST_ALPHA
case|:
case|case
name|GL_CONSTANT_COLOR
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_COLOR
case|:
case|case
name|GL_CONSTANT_ALPHA
case|:
case|case
name|GL_ONE_MINUS_CONSTANT_ALPHA
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|bool
name|constantColorUsed
init|=
operator|(
name|srcRGB
operator|==
name|GL_CONSTANT_COLOR
operator|||
name|srcRGB
operator|==
name|GL_ONE_MINUS_CONSTANT_COLOR
operator|||
name|dstRGB
operator|==
name|GL_CONSTANT_COLOR
operator|||
name|dstRGB
operator|==
name|GL_ONE_MINUS_CONSTANT_COLOR
operator|)
decl_stmt|;
name|bool
name|constantAlphaUsed
init|=
operator|(
name|srcRGB
operator|==
name|GL_CONSTANT_ALPHA
operator|||
name|srcRGB
operator|==
name|GL_ONE_MINUS_CONSTANT_ALPHA
operator|||
name|dstRGB
operator|==
name|GL_CONSTANT_ALPHA
operator|||
name|dstRGB
operator|==
name|GL_ONE_MINUS_CONSTANT_ALPHA
operator|)
decl_stmt|;
if|if
condition|(
name|constantColorUsed
operator|&&
name|constantAlphaUsed
condition|)
block|{
name|ERR
argument_list|(
literal|"Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR invalid under WebGL"
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setBlendFactors
argument_list|(
name|srcRGB
argument_list|,
name|dstRGB
argument_list|,
name|srcAlpha
argument_list|,
name|dstAlpha
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBufferData
name|void
name|__stdcall
name|glBufferData
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|data
parameter_list|,
name|GLenum
name|usage
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLsizeiptr size = %d, const GLvoid* data = 0x%0.8p, GLenum usage = %d)"
argument_list|,
name|target
argument_list|,
name|size
argument_list|,
name|data
argument_list|,
name|usage
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|usage
condition|)
block|{
case|case
name|GL_STREAM_DRAW
case|:
case|case
name|GL_STATIC_DRAW
case|:
case|case
name|GL_DYNAMIC_DRAW
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
name|buffer
operator|=
name|context
operator|->
name|getArrayBuffer
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
name|buffer
operator|=
name|context
operator|->
name|getElementArrayBuffer
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|buffer
operator|->
name|bufferData
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|usage
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBufferSubData
name|void
name|__stdcall
name|glBufferSubData
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|data
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLintptr offset = %d, GLsizeiptr size = %d, const GLvoid* data = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|data
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|offset
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
name|buffer
operator|=
name|context
operator|->
name|getArrayBuffer
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
name|buffer
operator|=
name|context
operator|->
name|getElementArrayBuffer
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|size
operator|+
name|offset
operator|>
name|buffer
operator|->
name|size
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|buffer
operator|->
name|bufferSubData
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glCheckFramebufferStatus
name|GLenum
name|__stdcall
name|glCheckFramebufferStatus
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X)"
argument_list|,
name|target
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|target
operator|!=
name|GL_FRAMEBUFFER
operator|&&
name|target
operator|!=
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|&&
name|target
operator|!=
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
name|framebuffer
operator|=
name|context
operator|->
name|getReadFramebuffer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|framebuffer
operator|=
name|context
operator|->
name|getDrawFramebuffer
argument_list|()
expr_stmt|;
block|}
return|return
name|framebuffer
operator|->
name|completeness
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|function|glClear
name|void
name|__stdcall
name|glClear
parameter_list|(
name|GLbitfield
name|mask
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLbitfield mask = %X)"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|clear
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glClearColor
name|void
name|__stdcall
name|glClearColor
parameter_list|(
name|GLclampf
name|red
parameter_list|,
name|GLclampf
name|green
parameter_list|,
name|GLclampf
name|blue
parameter_list|,
name|GLclampf
name|alpha
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLclampf red = %f, GLclampf green = %f, GLclampf blue = %f, GLclampf alpha = %f)"
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setClearColor
argument_list|(
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glClearDepthf
name|void
name|__stdcall
name|glClearDepthf
parameter_list|(
name|GLclampf
name|depth
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLclampf depth = %f)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setClearDepth
argument_list|(
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glClearStencil
name|void
name|__stdcall
name|glClearStencil
parameter_list|(
name|GLint
name|s
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint s = %d)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setClearStencil
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glColorMask
name|void
name|__stdcall
name|glColorMask
parameter_list|(
name|GLboolean
name|red
parameter_list|,
name|GLboolean
name|green
parameter_list|,
name|GLboolean
name|blue
parameter_list|,
name|GLboolean
name|alpha
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLboolean red = %d, GLboolean green = %d, GLboolean blue = %d, GLboolean alpha = %d)"
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setColorMask
argument_list|(
name|red
operator|==
name|GL_TRUE
argument_list|,
name|green
operator|==
name|GL_TRUE
argument_list|,
name|blue
operator|==
name|GL_TRUE
argument_list|,
name|alpha
operator|==
name|GL_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glCompileShader
name|void
name|__stdcall
name|glCompileShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d)"
argument_list|,
name|shader
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getProgram
argument_list|(
name|shader
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
name|shaderObject
operator|->
name|compile
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glCompressedTexImage2D
name|void
name|__stdcall
name|glCompressedTexImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|data
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLint level = %d, GLenum internalformat = 0x%X, GLsizei width = %d, "
literal|"GLsizei height = %d, GLint border = %d, GLsizei imageSize = %d, const GLvoid* data = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|border
argument_list|,
name|imageSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|validImageSize
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
operator|||
name|border
operator|!=
literal|0
operator|||
name|imageSize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|border
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|!=
literal|1
operator|&&
name|width
operator|!=
literal|2
operator|&&
name|width
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|height
operator|!=
literal|1
operator|&&
name|height
operator|!=
literal|2
operator|&&
name|height
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|context
operator|->
name|getMaximumTextureLevel
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
if|if
condition|(
name|width
operator|>
operator|(
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
operator|>>
name|level
operator|)
operator|||
name|height
operator|>
operator|(
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
operator|>>
name|level
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
if|if
condition|(
name|width
operator|!=
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|>
operator|(
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
operator|>>
name|level
operator|)
operator|||
name|height
operator|>
operator|(
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
operator|>>
name|level
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
comment|// in this case, it's as though the internal format switch failed
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
comment|// in this case, it's as though the internal format switch failed
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
comment|// in this case, it's as though the internal format switch failed
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|imageSize
operator|!=
name|gl
operator|::
name|ComputeCompressedSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|internalformat
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texture
operator|->
name|setCompressedImage
argument_list|(
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|imageSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texture
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
name|texture
operator|->
name|setCompressedImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|imageSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glCompressedTexSubImage2D
name|void
name|__stdcall
name|glCompressedTexSubImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLsizei
name|imageSize
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|data
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, "
literal|"GLsizei width = %d, GLsizei height = %d, GLenum format = 0x%X, "
literal|"GLsizei imageSize = %d, const GLvoid* data = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|gl
operator|::
name|IsInternalTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|xoffset
operator|<
literal|0
operator|||
name|yoffset
operator|<
literal|0
operator|||
operator|!
name|validImageSize
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
operator|||
name|imageSize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
operator|||
name|data
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|context
operator|->
name|getMaximumTextureLevel
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
comment|// in this case, it's as though the internal format switch failed
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
comment|// in this case, it's as though the internal format switch failed
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
comment|// in this case, it's as though the internal format switch failed
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|imageSize
operator|!=
name|gl
operator|::
name|ComputeCompressedSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|xoffset
operator|%
literal|4
operator|!=
literal|0
operator|||
name|yoffset
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
comment|// we wait to check the offsets until this point, because the multiple-of-four restriction
comment|// does not exist unless DXT textures are supported.
block|}
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
name|validateSubImageParams2D
argument_list|(
literal|true
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|GL_NONE
argument_list|,
name|texture
argument_list|)
condition|)
block|{
name|texture
operator|->
name|subImageCompressed
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texture
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|validateSubImageParamsCube
argument_list|(
literal|true
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|GL_NONE
argument_list|,
name|texture
argument_list|)
condition|)
block|{
name|texture
operator|->
name|subImageCompressed
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|imageSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glCopyTexImage2D
name|void
name|__stdcall
name|glCopyTexImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLint level = %d, GLenum internalformat = 0x%X, "
literal|"GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d, GLint border = %d)"
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|border
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|validImageSize
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|border
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|context
operator|->
name|getMaximumTextureLevel
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
if|if
condition|(
name|width
operator|>
operator|(
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
operator|>>
name|level
operator|)
operator|||
name|height
operator|>
operator|(
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
operator|>>
name|level
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
if|if
condition|(
name|width
operator|!=
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|>
operator|(
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
operator|>>
name|level
operator|)
operator|||
name|height
operator|>
operator|(
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
operator|>>
name|level
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getReadFramebufferHandle
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Renderbuffer
modifier|*
name|source
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|GLenum
name|colorbufferFormat
init|=
name|source
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
comment|// [OpenGL ES 2.0.24] table 3.9
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_ALPHA
case|:
if|if
condition|(
name|colorbufferFormat
operator|!=
name|GL_ALPHA8_EXT
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA4
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB5_A1
operator|&&
name|colorbufferFormat
operator|!=
name|GL_BGRA8_EXT
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA8_OES
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_LUMINANCE
case|:
case|case
name|GL_RGB
case|:
if|if
condition|(
name|colorbufferFormat
operator|!=
name|GL_RGB565
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB8_OES
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA4
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB5_A1
operator|&&
name|colorbufferFormat
operator|!=
name|GL_BGRA8_EXT
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA8_OES
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_LUMINANCE_ALPHA
case|:
case|case
name|GL_RGBA
case|:
if|if
condition|(
name|colorbufferFormat
operator|!=
name|GL_RGBA4
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB5_A1
operator|&&
name|colorbufferFormat
operator|!=
name|GL_BGRA8_EXT
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA8_OES
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
if|if
condition|(
name|context
operator|->
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
if|if
condition|(
name|context
operator|->
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
if|if
condition|(
name|context
operator|->
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_DEPTH_COMPONENT
case|:
case|case
name|GL_DEPTH_COMPONENT16
case|:
case|case
name|GL_DEPTH_COMPONENT32_OES
case|:
case|case
name|GL_DEPTH_STENCIL_OES
case|:
case|case
name|GL_DEPTH24_STENCIL8_OES
case|:
if|if
condition|(
name|context
operator|->
name|supportsDepthTextures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texture
operator|->
name|copyImage
argument_list|(
name|level
argument_list|,
name|internalformat
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texture
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texture
operator|->
name|copyImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glCopyTexSubImage2D
name|void
name|__stdcall
name|glCopyTexSubImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, "
literal|"GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d)"
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|gl
operator|::
name|IsInternalTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|xoffset
operator|<
literal|0
operator|||
name|yoffset
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|xoffset
operator|<
name|width
operator|||
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|yoffset
operator|<
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|context
operator|->
name|getMaximumTextureLevel
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getReadFramebufferHandle
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Renderbuffer
modifier|*
name|source
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|GLenum
name|colorbufferFormat
init|=
name|source
operator|->
name|getInternalFormat
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Texture
modifier|*
name|texture
init|=
name|NULL
decl_stmt|;
name|GLenum
name|textureFormat
init|=
name|GL_RGBA
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|tex2d
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validateSubImageParams2D
argument_list|(
literal|false
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|level
argument_list|,
name|GL_NONE
argument_list|,
name|GL_NONE
argument_list|,
name|tex2d
argument_list|)
condition|)
block|{
return|return;
comment|// error already registered by validateSubImageParams
block|}
name|textureFormat
operator|=
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|tex2d
operator|->
name|getInternalFormat
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|texture
operator|=
name|tex2d
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texcube
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validateSubImageParamsCube
argument_list|(
literal|false
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|GL_NONE
argument_list|,
name|GL_NONE
argument_list|,
name|texcube
argument_list|)
condition|)
block|{
return|return;
comment|// error already registered by validateSubImageParams
block|}
name|textureFormat
operator|=
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|texcube
operator|->
name|getInternalFormat
argument_list|(
name|target
argument_list|,
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|texture
operator|=
name|texcube
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// [OpenGL ES 2.0.24] table 3.9
switch|switch
condition|(
name|textureFormat
condition|)
block|{
case|case
name|GL_ALPHA
case|:
if|if
condition|(
name|colorbufferFormat
operator|!=
name|GL_ALPHA8_EXT
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA4
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB5_A1
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA8_OES
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_LUMINANCE
case|:
case|case
name|GL_RGB
case|:
if|if
condition|(
name|colorbufferFormat
operator|!=
name|GL_RGB565
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB8_OES
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA4
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB5_A1
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA8_OES
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_LUMINANCE_ALPHA
case|:
case|case
name|GL_RGBA
case|:
if|if
condition|(
name|colorbufferFormat
operator|!=
name|GL_RGBA4
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGB5_A1
operator|&&
name|colorbufferFormat
operator|!=
name|GL_RGBA8_OES
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
case|case
name|GL_DEPTH_COMPONENT
case|:
case|case
name|GL_DEPTH_STENCIL_OES
case|:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texture
operator|->
name|copySubImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glCreateProgram
name|GLuint
name|__stdcall
name|glCreateProgram
parameter_list|(
name|void
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
return|return
name|context
operator|->
name|createProgram
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|function|glCreateShader
name|GLuint
name|__stdcall
name|glCreateShader
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum type = 0x%X)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_FRAGMENT_SHADER
case|:
case|case
name|GL_VERTEX_SHADER
case|:
return|return
name|context
operator|->
name|createShader
argument_list|(
name|type
argument_list|)
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|function|glCullFace
name|void
name|__stdcall
name|glCullFace
parameter_list|(
name|GLenum
name|mode
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum mode = 0x%X)"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_FRONT
case|:
case|case
name|GL_BACK
case|:
case|case
name|GL_FRONT_AND_BACK
case|:
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setCullMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteBuffers
name|void
name|__stdcall
name|glDeleteBuffers
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|buffers
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, const GLuint* buffers = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|buffers
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|->
name|deleteBuffer
argument_list|(
name|buffers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteFencesNV
name|void
name|__stdcall
name|glDeleteFencesNV
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|fences
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, const GLuint* fences = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|fences
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|->
name|deleteFence
argument_list|(
name|fences
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteFramebuffers
name|void
name|__stdcall
name|glDeleteFramebuffers
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|framebuffers
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, const GLuint* framebuffers = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|framebuffers
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|framebuffers
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|deleteFramebuffer
argument_list|(
name|framebuffers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteProgram
name|void
name|__stdcall
name|glDeleteProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d)"
argument_list|,
name|program
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|program
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
name|context
operator|->
name|deleteProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteQueriesEXT
name|void
name|__stdcall
name|glDeleteQueriesEXT
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|ids
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, const GLuint *ids = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|ids
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|->
name|deleteQuery
argument_list|(
name|ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteRenderbuffers
name|void
name|__stdcall
name|glDeleteRenderbuffers
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|renderbuffers
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, const GLuint* renderbuffers = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|renderbuffers
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|->
name|deleteRenderbuffer
argument_list|(
name|renderbuffers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteShader
name|void
name|__stdcall
name|glDeleteShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d)"
argument_list|,
name|shader
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|shader
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getProgram
argument_list|(
name|shader
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
name|context
operator|->
name|deleteShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDeleteTextures
name|void
name|__stdcall
name|glDeleteTextures
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|textures
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, const GLuint* textures = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|textures
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|textures
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|context
operator|->
name|deleteTexture
argument_list|(
name|textures
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDepthFunc
name|void
name|__stdcall
name|glDepthFunc
parameter_list|(
name|GLenum
name|func
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum func = 0x%X)"
argument_list|,
name|func
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|GL_NEVER
case|:
case|case
name|GL_ALWAYS
case|:
case|case
name|GL_LESS
case|:
case|case
name|GL_LEQUAL
case|:
case|case
name|GL_EQUAL
case|:
case|case
name|GL_GREATER
case|:
case|case
name|GL_GEQUAL
case|:
case|case
name|GL_NOTEQUAL
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setDepthFunc
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDepthMask
name|void
name|__stdcall
name|glDepthMask
parameter_list|(
name|GLboolean
name|flag
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLboolean flag = %d)"
argument_list|,
name|flag
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setDepthMask
argument_list|(
name|flag
operator|!=
name|GL_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDepthRangef
name|void
name|__stdcall
name|glDepthRangef
parameter_list|(
name|GLclampf
name|zNear
parameter_list|,
name|GLclampf
name|zFar
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLclampf zNear = %f, GLclampf zFar = %f)"
argument_list|,
name|zNear
argument_list|,
name|zFar
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setDepthRange
argument_list|(
name|zNear
argument_list|,
name|zFar
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDetachShader
name|void
name|__stdcall
name|glDetachShader
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLuint
name|shader
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLuint shader = %d)"
argument_list|,
name|program
argument_list|,
name|shader
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderByProgramHandle
decl_stmt|;
name|shaderByProgramHandle
operator|=
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shaderByProgramHandle
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programByShaderHandle
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programByShaderHandle
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|programObject
operator|->
name|detachShader
argument_list|(
name|shaderObject
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDisable
name|void
name|__stdcall
name|glDisable
parameter_list|(
name|GLenum
name|cap
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum cap = 0x%X)"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
name|context
operator|->
name|setCullFace
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
name|context
operator|->
name|setPolygonOffsetFill
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
name|context
operator|->
name|setSampleAlphaToCoverage
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE
case|:
name|context
operator|->
name|setSampleCoverage
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_TEST
case|:
name|context
operator|->
name|setScissorTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_TEST
case|:
name|context
operator|->
name|setStencilTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_TEST
case|:
name|context
operator|->
name|setDepthTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BLEND
case|:
name|context
operator|->
name|setBlend
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_DITHER
case|:
name|context
operator|->
name|setDither
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDisableVertexAttribArray
name|void
name|__stdcall
name|glDisableVertexAttribArray
parameter_list|(
name|GLuint
name|index
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setEnableVertexAttribArray
argument_list|(
name|index
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDrawArrays
name|void
name|__stdcall
name|glDrawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum mode = 0x%X, GLint first = %d, GLsizei count = %d)"
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|first
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|drawArrays
argument_list|(
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDrawArraysInstancedANGLE
name|void
name|__stdcall
name|glDrawArraysInstancedANGLE
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum mode = 0x%X, GLint first = %d, GLsizei count = %d, GLsizei primcount = %d)"
argument_list|,
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|first
operator|<
literal|0
operator|||
name|primcount
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|primcount
operator|>
literal|0
condition|)
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|drawArrays
argument_list|(
name|mode
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|primcount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDrawElements
name|void
name|__stdcall
name|glDrawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum mode = 0x%X, GLsizei count = %d, GLenum type = 0x%X, const GLvoid* indices = 0x%0.8p)"
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT
case|:
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supports32bitIndices
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|context
operator|->
name|drawElements
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDrawElementsInstancedANGLE
name|void
name|__stdcall
name|glDrawElementsInstancedANGLE
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|primcount
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum mode = 0x%X, GLsizei count = %d, GLenum type = 0x%X, const GLvoid* indices = 0x%0.8p, GLsizei primcount = %d)"
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|primcount
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|primcount
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|primcount
operator|>
literal|0
condition|)
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT
case|:
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supports32bitIndices
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|context
operator|->
name|drawElements
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|primcount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glEnable
name|void
name|__stdcall
name|glEnable
parameter_list|(
name|GLenum
name|cap
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum cap = 0x%X)"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
name|context
operator|->
name|setCullFace
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
name|context
operator|->
name|setPolygonOffsetFill
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
name|context
operator|->
name|setSampleAlphaToCoverage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE
case|:
name|context
operator|->
name|setSampleCoverage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_TEST
case|:
name|context
operator|->
name|setScissorTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_TEST
case|:
name|context
operator|->
name|setStencilTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_TEST
case|:
name|context
operator|->
name|setDepthTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_BLEND
case|:
name|context
operator|->
name|setBlend
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_DITHER
case|:
name|context
operator|->
name|setDither
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glEnableVertexAttribArray
name|void
name|__stdcall
name|glEnableVertexAttribArray
parameter_list|(
name|GLuint
name|index
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setEnableVertexAttribArray
argument_list|(
name|index
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glEndQueryEXT
name|void
name|__stdcall
name|glEndQueryEXT
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"GLenum target = 0x%X)"
argument_list|,
name|target
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|endQuery
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glFinishFenceNV
name|void
name|__stdcall
name|glFinishFenceNV
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint fence = %d)"
argument_list|,
name|fence
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Fence
modifier|*
name|fenceObject
init|=
name|context
operator|->
name|getFence
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|fenceObject
operator|->
name|finishFence
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glFinish
name|void
name|__stdcall
name|glFinish
parameter_list|(
name|void
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|sync
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glFlush
name|void
name|__stdcall
name|glFlush
parameter_list|(
name|void
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|sync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glFramebufferRenderbuffer
name|void
name|__stdcall
name|glFramebufferRenderbuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|renderbuffertarget
parameter_list|,
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum attachment = 0x%X, GLenum renderbuffertarget = 0x%X, "
literal|"GLuint renderbuffer = %d)"
argument_list|,
name|target
argument_list|,
name|attachment
argument_list|,
name|renderbuffertarget
argument_list|,
name|renderbuffer
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|target
operator|!=
name|GL_FRAMEBUFFER
operator|&&
name|target
operator|!=
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|&&
name|target
operator|!=
name|GL_READ_FRAMEBUFFER_ANGLE
operator|)
operator|||
operator|(
name|renderbuffertarget
operator|!=
name|GL_RENDERBUFFER
operator|&&
name|renderbuffer
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|NULL
decl_stmt|;
name|GLuint
name|framebufferHandle
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
name|framebuffer
operator|=
name|context
operator|->
name|getReadFramebuffer
argument_list|()
expr_stmt|;
name|framebufferHandle
operator|=
name|context
operator|->
name|getReadFramebufferHandle
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|framebuffer
operator|=
name|context
operator|->
name|getDrawFramebuffer
argument_list|()
expr_stmt|;
name|framebufferHandle
operator|=
name|context
operator|->
name|getDrawFramebufferHandle
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|framebuffer
operator|||
operator|(
name|framebufferHandle
operator|==
literal|0
operator|&&
name|renderbuffer
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0_EXT
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15_EXT
condition|)
block|{
specifier|const
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getMaximumRenderTargets
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|framebuffer
operator|->
name|setColorbuffer
argument_list|(
name|colorAttachment
argument_list|,
name|GL_RENDERBUFFER
argument_list|,
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
name|framebuffer
operator|->
name|setDepthbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|renderbuffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_ATTACHMENT
case|:
name|framebuffer
operator|->
name|setStencilbuffer
argument_list|(
name|GL_RENDERBUFFER
argument_list|,
name|renderbuffer
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glFramebufferTexture2D
name|void
name|__stdcall
name|glFramebufferTexture2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|textarget
parameter_list|,
name|GLuint
name|texture
parameter_list|,
name|GLint
name|level
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum attachment = 0x%X, GLenum textarget = 0x%X, "
literal|"GLuint texture = %d, GLint level = %d)"
argument_list|,
name|target
argument_list|,
name|attachment
argument_list|,
name|textarget
argument_list|,
name|texture
argument_list|,
name|level
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|target
operator|!=
name|GL_FRAMEBUFFER
operator|&&
name|target
operator|!=
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|&&
name|target
operator|!=
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0_EXT
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15_EXT
condition|)
block|{
specifier|const
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getMaximumRenderTargets
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
case|case
name|GL_STENCIL_ATTACHMENT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|texture
operator|==
literal|0
condition|)
block|{
name|textarget
operator|=
name|GL_NONE
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|Texture
modifier|*
name|tex
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
switch|switch
condition|(
name|textarget
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
block|{
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Texture2D
modifier|*
name|tex2d
init|=
cast|static_cast
argument_list|<
name|gl
operator|::
name|Texture2D
operator|*
argument_list|>
argument_list|(
name|tex
argument_list|)
decl_stmt|;
if|if
condition|(
name|tex2d
operator|->
name|isCompressed
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
block|}
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
block|{
if|if
condition|(
name|tex
operator|->
name|getTarget
argument_list|()
operator|!=
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texcube
init|=
cast|static_cast
argument_list|<
name|gl
operator|::
name|TextureCubeMap
operator|*
argument_list|>
argument_list|(
name|tex
argument_list|)
decl_stmt|;
if|if
condition|(
name|texcube
operator|->
name|isCompressed
argument_list|(
name|textarget
argument_list|,
name|level
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
block|}
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|NULL
decl_stmt|;
name|GLuint
name|framebufferHandle
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
name|framebuffer
operator|=
name|context
operator|->
name|getReadFramebuffer
argument_list|()
expr_stmt|;
name|framebufferHandle
operator|=
name|context
operator|->
name|getReadFramebufferHandle
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|framebuffer
operator|=
name|context
operator|->
name|getDrawFramebuffer
argument_list|()
expr_stmt|;
name|framebufferHandle
operator|=
name|context
operator|->
name|getDrawFramebufferHandle
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|framebufferHandle
operator|==
literal|0
operator|||
operator|!
name|framebuffer
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0_EXT
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15_EXT
condition|)
block|{
specifier|const
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getMaximumRenderTargets
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|framebuffer
operator|->
name|setColorbuffer
argument_list|(
name|colorAttachment
argument_list|,
name|textarget
argument_list|,
name|texture
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
name|framebuffer
operator|->
name|setDepthbuffer
argument_list|(
name|textarget
argument_list|,
name|texture
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_ATTACHMENT
case|:
name|framebuffer
operator|->
name|setStencilbuffer
argument_list|(
name|textarget
argument_list|,
name|texture
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glFrontFace
name|void
name|__stdcall
name|glFrontFace
parameter_list|(
name|GLenum
name|mode
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum mode = 0x%X)"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_CW
case|:
case|case
name|GL_CCW
case|:
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setFrontFace
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGenBuffers
name|void
name|__stdcall
name|glGenBuffers
parameter_list|(
name|GLsizei
name|n
parameter_list|,
name|GLuint
modifier|*
name|buffers
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, GLuint* buffers = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|buffers
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buffers
index|[
name|i
index|]
operator|=
name|context
operator|->
name|createBuffer
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGenerateMipmap
name|void
name|__stdcall
name|glGenerateMipmap
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X)"
argument_list|,
name|target
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|tex2d
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
name|tex2d
operator|->
name|isCompressed
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|tex2d
operator|->
name|isDepth
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|tex2d
operator|->
name|generateMipmaps
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texcube
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|texcube
operator|->
name|isCompressed
argument_list|(
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texcube
operator|->
name|generateMipmaps
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGenFencesNV
name|void
name|__stdcall
name|glGenFencesNV
parameter_list|(
name|GLsizei
name|n
parameter_list|,
name|GLuint
modifier|*
name|fences
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, GLuint* fences = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|fences
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fences
index|[
name|i
index|]
operator|=
name|context
operator|->
name|createFence
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGenFramebuffers
name|void
name|__stdcall
name|glGenFramebuffers
parameter_list|(
name|GLsizei
name|n
parameter_list|,
name|GLuint
modifier|*
name|framebuffers
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, GLuint* framebuffers = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|framebuffers
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|framebuffers
index|[
name|i
index|]
operator|=
name|context
operator|->
name|createFramebuffer
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGenQueriesEXT
name|void
name|__stdcall
name|glGenQueriesEXT
parameter_list|(
name|GLsizei
name|n
parameter_list|,
name|GLuint
modifier|*
name|ids
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, GLuint* ids = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|ids
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ids
index|[
name|i
index|]
operator|=
name|context
operator|->
name|createQuery
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGenRenderbuffers
name|void
name|__stdcall
name|glGenRenderbuffers
parameter_list|(
name|GLsizei
name|n
parameter_list|,
name|GLuint
modifier|*
name|renderbuffers
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, GLuint* renderbuffers = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|renderbuffers
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|renderbuffers
index|[
name|i
index|]
operator|=
name|context
operator|->
name|createRenderbuffer
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGenTextures
name|void
name|__stdcall
name|glGenTextures
parameter_list|(
name|GLsizei
name|n
parameter_list|,
name|GLuint
modifier|*
name|textures
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, GLuint* textures =  0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|textures
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|textures
index|[
name|i
index|]
operator|=
name|context
operator|->
name|createTexture
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetActiveAttrib
name|void
name|__stdcall
name|glGetActiveAttrib
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLuint index = %d, GLsizei bufsize = %d, GLsizei *length = 0x%0.8p, "
literal|"GLint *size = 0x%0.8p, GLenum *type = %0.8p, GLchar *name = %0.8p)"
argument_list|,
name|program
argument_list|,
name|index
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufsize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|index
operator|>=
operator|(
name|GLuint
operator|)
name|programObject
operator|->
name|getActiveAttributeCount
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|programObject
operator|->
name|getActiveAttribute
argument_list|(
name|index
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetActiveUniform
name|void
name|__stdcall
name|glGetActiveUniform
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLint
modifier|*
name|size
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLuint index = %d, GLsizei bufsize = %d, "
literal|"GLsizei* length = 0x%0.8p, GLint* size = 0x%0.8p, GLenum* type = 0x%0.8p, GLchar* name = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|index
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufsize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|index
operator|>=
operator|(
name|GLuint
operator|)
name|programObject
operator|->
name|getActiveUniformCount
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|programObject
operator|->
name|getActiveUniform
argument_list|(
name|index
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetAttachedShaders
name|void
name|__stdcall
name|glGetAttachedShaders
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLsizei
name|maxcount
parameter_list|,
name|GLsizei
modifier|*
name|count
parameter_list|,
name|GLuint
modifier|*
name|shaders
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLsizei maxcount = %d, GLsizei* count = 0x%0.8p, GLuint* shaders = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|maxcount
argument_list|,
name|count
argument_list|,
name|shaders
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|maxcount
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
return|return
name|programObject
operator|->
name|getAttachedShaders
argument_list|(
name|maxcount
argument_list|,
name|count
argument_list|,
name|shaders
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetAttribLocation
name|int
name|__stdcall
name|glGetAttribLocation
parameter_list|(
name|GLuint
name|program
parameter_list|,
specifier|const
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, const GLchar* name = %s)"
argument_list|,
name|program
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
operator|||
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
return|return
name|programBinary
operator|->
name|getAttributeLocation
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|glGetBooleanv
name|void
name|__stdcall
name|glGetBooleanv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLboolean
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum pname = 0x%X, GLboolean* params = 0x%0.8p)"
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|context
operator|->
name|getBooleanv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
operator|)
condition|)
block|{
name|GLenum
name|nativeType
decl_stmt|;
name|unsigned
name|int
name|numParams
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|getQueryParameterInfo
argument_list|(
name|pname
argument_list|,
operator|&
name|nativeType
argument_list|,
operator|&
name|numParams
argument_list|)
condition|)
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
return|return;
comment|// it is known that the pname is valid, but there are no parameters to return
if|if
condition|(
name|nativeType
operator|==
name|GL_FLOAT
condition|)
block|{
name|GLfloat
modifier|*
name|floatParams
init|=
name|NULL
decl_stmt|;
name|floatParams
operator|=
operator|new
name|GLfloat
index|[
name|numParams
index|]
expr_stmt|;
name|context
operator|->
name|getFloatv
argument_list|(
name|pname
argument_list|,
name|floatParams
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|floatParams
index|[
name|i
index|]
operator|==
literal|0.0f
condition|)
name|params
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
else|else
name|params
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
operator|delete
index|[]
name|floatParams
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nativeType
operator|==
name|GL_INT
condition|)
block|{
name|GLint
modifier|*
name|intParams
init|=
name|NULL
decl_stmt|;
name|intParams
operator|=
operator|new
name|GLint
index|[
name|numParams
index|]
expr_stmt|;
name|context
operator|->
name|getIntegerv
argument_list|(
name|pname
argument_list|,
name|intParams
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|intParams
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|params
index|[
name|i
index|]
operator|=
name|GL_FALSE
expr_stmt|;
else|else
name|params
index|[
name|i
index|]
operator|=
name|GL_TRUE
expr_stmt|;
block|}
operator|delete
index|[]
name|intParams
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetBufferParameteriv
name|void
name|__stdcall
name|glGetBufferParameteriv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|buffer
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ARRAY_BUFFER
case|:
name|buffer
operator|=
name|context
operator|->
name|getArrayBuffer
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ELEMENT_ARRAY_BUFFER
case|:
name|buffer
operator|=
name|context
operator|->
name|getElementArrayBuffer
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
comment|// A null buffer means that "0" is bound to the requested buffer target
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_BUFFER_USAGE
case|:
operator|*
name|params
operator|=
name|buffer
operator|->
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_BUFFER_SIZE
case|:
operator|*
name|params
operator|=
name|buffer
operator|->
name|size
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetError
name|GLenum
name|__stdcall
name|glGetError
parameter_list|(
name|void
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
return|return
name|context
operator|->
name|getError
argument_list|()
return|;
block|}
return|return
name|GL_NO_ERROR
return|;
block|}
DECL|function|glGetFenceivNV
name|void
name|__stdcall
name|glGetFenceivNV
parameter_list|(
name|GLuint
name|fence
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint fence = %d, GLenum pname = 0x%X, GLint *params = 0x%0.8p)"
argument_list|,
name|fence
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Fence
modifier|*
name|fenceObject
init|=
name|context
operator|->
name|getFence
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|fenceObject
operator|->
name|getFenceiv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetFloatv
name|void
name|__stdcall
name|glGetFloatv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum pname = 0x%X, GLfloat* params = 0x%0.8p)"
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|context
operator|->
name|getFloatv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
operator|)
condition|)
block|{
name|GLenum
name|nativeType
decl_stmt|;
name|unsigned
name|int
name|numParams
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|getQueryParameterInfo
argument_list|(
name|pname
argument_list|,
operator|&
name|nativeType
argument_list|,
operator|&
name|numParams
argument_list|)
condition|)
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
return|return;
comment|// it is known that the pname is valid, but that there are no parameters to return.
if|if
condition|(
name|nativeType
operator|==
name|GL_BOOL
condition|)
block|{
name|GLboolean
modifier|*
name|boolParams
init|=
name|NULL
decl_stmt|;
name|boolParams
operator|=
operator|new
name|GLboolean
index|[
name|numParams
index|]
expr_stmt|;
name|context
operator|->
name|getBooleanv
argument_list|(
name|pname
argument_list|,
name|boolParams
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|boolParams
index|[
name|i
index|]
operator|==
name|GL_FALSE
condition|)
name|params
index|[
name|i
index|]
operator|=
literal|0.0f
expr_stmt|;
else|else
name|params
index|[
name|i
index|]
operator|=
literal|1.0f
expr_stmt|;
block|}
operator|delete
index|[]
name|boolParams
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nativeType
operator|==
name|GL_INT
condition|)
block|{
name|GLint
modifier|*
name|intParams
init|=
name|NULL
decl_stmt|;
name|intParams
operator|=
operator|new
name|GLint
index|[
name|numParams
index|]
expr_stmt|;
name|context
operator|->
name|getIntegerv
argument_list|(
name|pname
argument_list|,
name|intParams
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
operator|(
name|GLfloat
operator|)
name|intParams
index|[
name|i
index|]
expr_stmt|;
block|}
operator|delete
index|[]
name|intParams
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetFramebufferAttachmentParameteriv
name|void
name|__stdcall
name|glGetFramebufferAttachmentParameteriv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|attachment
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum attachment = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|attachment
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|GL_FRAMEBUFFER
operator|&&
name|target
operator|!=
name|GL_DRAW_FRAMEBUFFER_ANGLE
operator|&&
name|target
operator|!=
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|GL_READ_FRAMEBUFFER_ANGLE
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getReadFramebufferHandle
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|framebuffer
operator|=
name|context
operator|->
name|getReadFramebuffer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|->
name|getDrawFramebufferHandle
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|framebuffer
operator|=
name|context
operator|->
name|getDrawFramebuffer
argument_list|()
expr_stmt|;
block|}
name|GLenum
name|attachmentType
decl_stmt|;
name|GLuint
name|attachmentHandle
decl_stmt|;
if|if
condition|(
name|attachment
operator|>=
name|GL_COLOR_ATTACHMENT0_EXT
operator|&&
name|attachment
operator|<=
name|GL_COLOR_ATTACHMENT15_EXT
condition|)
block|{
specifier|const
name|unsigned
name|int
name|colorAttachment
init|=
operator|(
name|attachment
operator|-
name|GL_COLOR_ATTACHMENT0_EXT
operator|)
decl_stmt|;
if|if
condition|(
name|colorAttachment
operator|>=
name|context
operator|->
name|getMaximumRenderTargets
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|attachmentType
operator|=
name|framebuffer
operator|->
name|getColorbufferType
argument_list|(
name|colorAttachment
argument_list|)
expr_stmt|;
name|attachmentHandle
operator|=
name|framebuffer
operator|->
name|getColorbufferHandle
argument_list|(
name|colorAttachment
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|attachment
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
name|attachmentType
operator|=
name|framebuffer
operator|->
name|getDepthbufferType
argument_list|()
expr_stmt|;
name|attachmentHandle
operator|=
name|framebuffer
operator|->
name|getDepthbufferHandle
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_ATTACHMENT
case|:
name|attachmentType
operator|=
name|framebuffer
operator|->
name|getStencilbufferType
argument_list|()
expr_stmt|;
name|attachmentHandle
operator|=
name|framebuffer
operator|->
name|getStencilbufferHandle
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
name|GLenum
name|attachmentObjectType
decl_stmt|;
comment|// Type category
if|if
condition|(
name|attachmentType
operator|==
name|GL_NONE
operator|||
name|attachmentType
operator|==
name|GL_RENDERBUFFER
condition|)
block|{
name|attachmentObjectType
operator|=
name|attachmentType
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsInternalTextureTarget
argument_list|(
name|attachmentType
argument_list|)
condition|)
block|{
name|attachmentObjectType
operator|=
name|GL_TEXTURE
expr_stmt|;
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
case|:
operator|*
name|params
operator|=
name|attachmentObjectType
expr_stmt|;
break|break;
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
case|:
if|if
condition|(
name|attachmentObjectType
operator|==
name|GL_RENDERBUFFER
operator|||
name|attachmentObjectType
operator|==
name|GL_TEXTURE
condition|)
block|{
operator|*
name|params
operator|=
name|attachmentHandle
expr_stmt|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
case|:
if|if
condition|(
name|attachmentObjectType
operator|==
name|GL_TEXTURE
condition|)
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
comment|// FramebufferTexture2D will not allow level to be set to anything else in GL ES 2.0
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
case|:
if|if
condition|(
name|attachmentObjectType
operator|==
name|GL_TEXTURE
condition|)
block|{
if|if
condition|(
name|gl
operator|::
name|IsCubemapTextureTarget
argument_list|(
name|attachmentType
argument_list|)
condition|)
block|{
operator|*
name|params
operator|=
name|attachmentType
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetGraphicsResetStatusEXT
name|GLenum
name|__stdcall
name|glGetGraphicsResetStatusEXT
parameter_list|(
name|void
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
return|return
name|context
operator|->
name|getResetStatus
argument_list|()
return|;
block|}
return|return
name|GL_NO_ERROR
return|;
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|GL_OUT_OF_MEMORY
return|;
block|}
block|}
DECL|function|glGetIntegerv
name|void
name|__stdcall
name|glGetIntegerv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum pname = 0x%X, GLint* params = 0x%0.8p)"
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|context
operator|->
name|getIntegerv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
operator|)
condition|)
block|{
name|GLenum
name|nativeType
decl_stmt|;
name|unsigned
name|int
name|numParams
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|getQueryParameterInfo
argument_list|(
name|pname
argument_list|,
operator|&
name|nativeType
argument_list|,
operator|&
name|numParams
argument_list|)
condition|)
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
return|return;
comment|// it is known that pname is valid, but there are no parameters to return
if|if
condition|(
name|nativeType
operator|==
name|GL_BOOL
condition|)
block|{
name|GLboolean
modifier|*
name|boolParams
init|=
name|NULL
decl_stmt|;
name|boolParams
operator|=
operator|new
name|GLboolean
index|[
name|numParams
index|]
expr_stmt|;
name|context
operator|->
name|getBooleanv
argument_list|(
name|pname
argument_list|,
name|boolParams
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|boolParams
index|[
name|i
index|]
operator|==
name|GL_FALSE
condition|)
name|params
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|params
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
operator|delete
index|[]
name|boolParams
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nativeType
operator|==
name|GL_FLOAT
condition|)
block|{
name|GLfloat
modifier|*
name|floatParams
init|=
name|NULL
decl_stmt|;
name|floatParams
operator|=
operator|new
name|GLfloat
index|[
name|numParams
index|]
expr_stmt|;
name|context
operator|->
name|getFloatv
argument_list|(
name|pname
argument_list|,
name|floatParams
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParams
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pname
operator|==
name|GL_DEPTH_RANGE
operator|||
name|pname
operator|==
name|GL_COLOR_CLEAR_VALUE
operator|||
name|pname
operator|==
name|GL_DEPTH_CLEAR_VALUE
operator|||
name|pname
operator|==
name|GL_BLEND_COLOR
condition|)
block|{
name|params
index|[
name|i
index|]
operator|=
call|(
name|GLint
call|)
argument_list|(
operator|(
call|(
name|GLfloat
call|)
argument_list|(
literal|0xFFFFFFFF
argument_list|)
operator|*
name|floatParams
index|[
name|i
index|]
operator|-
literal|1.0f
operator|)
operator|/
literal|2.0f
argument_list|)
expr_stmt|;
block|}
else|else
name|params
index|[
name|i
index|]
operator|=
call|(
name|GLint
call|)
argument_list|(
name|floatParams
index|[
name|i
index|]
operator|>
literal|0.0f
condition|?
name|floor
argument_list|(
name|floatParams
index|[
name|i
index|]
operator|+
literal|0.5
argument_list|)
else|:
name|ceil
argument_list|(
name|floatParams
index|[
name|i
index|]
operator|-
literal|0.5
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|delete
index|[]
name|floatParams
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetProgramiv
name|void
name|__stdcall
name|glGetProgramiv
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLenum pname = %d, GLint* params = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_DELETE_STATUS
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|isFlaggedForDeletion
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_LINK_STATUS
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|isLinked
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_VALIDATE_STATUS
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|isValidated
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_INFO_LOG_LENGTH
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|getInfoLogLength
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_ATTACHED_SHADERS
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|getAttachedShadersCount
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_ACTIVE_ATTRIBUTES
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|getActiveAttributeCount
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_ACTIVE_ATTRIBUTE_MAX_LENGTH
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|getActiveAttributeMaxLength
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_ACTIVE_UNIFORMS
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|getActiveUniformCount
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_ACTIVE_UNIFORM_MAX_LENGTH
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|getActiveUniformMaxLength
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_PROGRAM_BINARY_LENGTH_OES
case|:
operator|*
name|params
operator|=
name|programObject
operator|->
name|getProgramBinaryLength
argument_list|()
expr_stmt|;
return|return;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetProgramInfoLog
name|void
name|__stdcall
name|glGetProgramInfoLog
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|infolog
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* infolog = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|infolog
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufsize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|programObject
operator|->
name|getInfoLog
argument_list|(
name|bufsize
argument_list|,
name|length
argument_list|,
name|infolog
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetQueryivEXT
name|void
name|__stdcall
name|glGetQueryivEXT
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"GLenum target = 0x%X, GLenum pname = 0x%X, GLint *params = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_CURRENT_QUERY_EXT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|params
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|getActiveQuery
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetQueryObjectuivEXT
name|void
name|__stdcall
name|glGetQueryObjectuivEXT
parameter_list|(
name|GLuint
name|id
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLuint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint id = %d, GLenum pname = 0x%X, GLuint *params = 0x%0.8p)"
argument_list|,
name|id
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_QUERY_RESULT_EXT
case|:
case|case
name|GL_QUERY_RESULT_AVAILABLE_EXT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|false
argument_list|,
name|GL_NONE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|queryObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getActiveQuery
argument_list|(
name|queryObject
operator|->
name|getType
argument_list|()
argument_list|)
operator|==
name|id
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_QUERY_RESULT_EXT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|queryObject
operator|->
name|getResult
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_QUERY_RESULT_AVAILABLE_EXT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|queryObject
operator|->
name|isResultAvailable
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetRenderbufferParameteriv
name|void
name|__stdcall
name|glGetRenderbufferParameteriv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|GL_RENDERBUFFER
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getRenderbufferHandle
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|context
operator|->
name|getRenderbuffer
argument_list|(
name|context
operator|->
name|getRenderbufferHandle
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_RENDERBUFFER_WIDTH
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getWidth
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_HEIGHT
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getHeight
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_INTERNAL_FORMAT
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getInternalFormat
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_RED_SIZE
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getRedSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_GREEN_SIZE
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getGreenSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_BLUE_SIZE
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getBlueSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_ALPHA_SIZE
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getAlphaSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_DEPTH_SIZE
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getDepthSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_STENCIL_SIZE
case|:
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getStencilSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_SAMPLES_ANGLE
case|:
if|if
condition|(
name|context
operator|->
name|getMaxSupportedSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
operator|*
name|params
operator|=
name|renderbuffer
operator|->
name|getSamples
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetShaderiv
name|void
name|__stdcall
name|glGetShaderiv
parameter_list|(
name|GLuint
name|shader
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d, GLenum pname = %d, GLint* params = 0x%0.8p)"
argument_list|,
name|shader
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SHADER_TYPE
case|:
operator|*
name|params
operator|=
name|shaderObject
operator|->
name|getType
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_DELETE_STATUS
case|:
operator|*
name|params
operator|=
name|shaderObject
operator|->
name|isFlaggedForDeletion
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_COMPILE_STATUS
case|:
operator|*
name|params
operator|=
name|shaderObject
operator|->
name|isCompiled
argument_list|()
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
expr_stmt|;
return|return;
case|case
name|GL_INFO_LOG_LENGTH
case|:
operator|*
name|params
operator|=
name|shaderObject
operator|->
name|getInfoLogLength
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_SHADER_SOURCE_LENGTH
case|:
operator|*
name|params
operator|=
name|shaderObject
operator|->
name|getSourceLength
argument_list|()
expr_stmt|;
return|return;
case|case
name|GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE
case|:
operator|*
name|params
operator|=
name|shaderObject
operator|->
name|getTranslatedSourceLength
argument_list|()
expr_stmt|;
return|return;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetShaderInfoLog
name|void
name|__stdcall
name|glGetShaderInfoLog
parameter_list|(
name|GLuint
name|shader
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|infolog
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* infolog = 0x%0.8p)"
argument_list|,
name|shader
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|infolog
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufsize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|shaderObject
operator|->
name|getInfoLog
argument_list|(
name|bufsize
argument_list|,
name|length
argument_list|,
name|infolog
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetShaderPrecisionFormat
name|void
name|__stdcall
name|glGetShaderPrecisionFormat
parameter_list|(
name|GLenum
name|shadertype
parameter_list|,
name|GLenum
name|precisiontype
parameter_list|,
name|GLint
modifier|*
name|range
parameter_list|,
name|GLint
modifier|*
name|precision
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum shadertype = 0x%X, GLenum precisiontype = 0x%X, GLint* range = 0x%0.8p, GLint* precision = 0x%0.8p)"
argument_list|,
name|shadertype
argument_list|,
name|precisiontype
argument_list|,
name|range
argument_list|,
name|precision
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|shadertype
condition|)
block|{
case|case
name|GL_VERTEX_SHADER
case|:
case|case
name|GL_FRAGMENT_SHADER
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|precisiontype
condition|)
block|{
case|case
name|GL_LOW_FLOAT
case|:
case|case
name|GL_MEDIUM_FLOAT
case|:
case|case
name|GL_HIGH_FLOAT
case|:
comment|// Assume IEEE 754 precision
name|range
index|[
literal|0
index|]
operator|=
literal|127
expr_stmt|;
name|range
index|[
literal|1
index|]
operator|=
literal|127
expr_stmt|;
operator|*
name|precision
operator|=
literal|23
expr_stmt|;
break|break;
case|case
name|GL_LOW_INT
case|:
case|case
name|GL_MEDIUM_INT
case|:
case|case
name|GL_HIGH_INT
case|:
comment|// Some (most) hardware only supports single-precision floating-point numbers,
comment|// which can accurately represent integers up to +/-16777216
name|range
index|[
literal|0
index|]
operator|=
literal|24
expr_stmt|;
name|range
index|[
literal|1
index|]
operator|=
literal|24
expr_stmt|;
operator|*
name|precision
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetShaderSource
name|void
name|__stdcall
name|glGetShaderSource
parameter_list|(
name|GLuint
name|shader
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|source
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* source = 0x%0.8p)"
argument_list|,
name|shader
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|source
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufsize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|shaderObject
operator|->
name|getSource
argument_list|(
name|bufsize
argument_list|,
name|length
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetTranslatedShaderSourceANGLE
name|void
name|__stdcall
name|glGetTranslatedShaderSourceANGLE
parameter_list|(
name|GLuint
name|shader
parameter_list|,
name|GLsizei
name|bufsize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLchar
modifier|*
name|source
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* source = 0x%0.8p)"
argument_list|,
name|shader
argument_list|,
name|bufsize
argument_list|,
name|length
argument_list|,
name|source
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufsize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|shaderObject
operator|->
name|getTranslatedSource
argument_list|(
name|bufsize
argument_list|,
name|length
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetString
specifier|const
name|GLubyte
modifier|*
name|__stdcall
name|glGetString
parameter_list|(
name|GLenum
name|name
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum name = 0x%X)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|GL_VENDOR
case|:
return|return
operator|(
name|GLubyte
operator|*
operator|)
literal|"Google Inc."
return|;
case|case
name|GL_RENDERER
case|:
return|return
operator|(
name|GLubyte
operator|*
operator|)
operator|(
operator|(
name|context
operator|!=
name|NULL
operator|)
condition|?
name|context
operator|->
name|getRendererString
argument_list|()
else|:
literal|"ANGLE"
operator|)
return|;
case|case
name|GL_VERSION
case|:
return|return
operator|(
name|GLubyte
operator|*
operator|)
literal|"OpenGL ES 2.0 (ANGLE "
name|VERSION_STRING
literal|")"
return|;
case|case
name|GL_SHADING_LANGUAGE_VERSION
case|:
return|return
operator|(
name|GLubyte
operator|*
operator|)
literal|"OpenGL ES GLSL ES 1.00 (ANGLE "
name|VERSION_STRING
literal|")"
return|;
case|case
name|GL_EXTENSIONS
case|:
return|return
operator|(
name|GLubyte
operator|*
operator|)
operator|(
operator|(
name|context
operator|!=
name|NULL
operator|)
condition|?
name|context
operator|->
name|getExtensionString
argument_list|()
else|:
literal|""
operator|)
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
operator|(
name|GLubyte
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
operator|(
name|GLubyte
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
block|}
DECL|function|glGetTexParameterfv
name|void
name|__stdcall
name|glGetTexParameterfv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum pname = 0x%X, GLfloat* params = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|texture
operator|=
name|context
operator|->
name|getTexture2D
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
name|texture
operator|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|texture
operator|->
name|getMagFilter
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|texture
operator|->
name|getMinFilter
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|texture
operator|->
name|getWrapS
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|texture
operator|->
name|getWrapT
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_IMMUTABLE_FORMAT_EXT
case|:
operator|*
name|params
operator|=
call|(
name|GLfloat
call|)
argument_list|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_USAGE_ANGLE
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|texture
operator|->
name|getUsage
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|texture
operator|->
name|getMaxAnisotropy
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetTexParameteriv
name|void
name|__stdcall
name|glGetTexParameteriv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|texture
operator|=
name|context
operator|->
name|getTexture2D
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
name|texture
operator|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
operator|*
name|params
operator|=
name|texture
operator|->
name|getMagFilter
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
operator|*
name|params
operator|=
name|texture
operator|->
name|getMinFilter
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
operator|*
name|params
operator|=
name|texture
operator|->
name|getWrapS
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
operator|*
name|params
operator|=
name|texture
operator|->
name|getWrapT
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_IMMUTABLE_FORMAT_EXT
case|:
operator|*
name|params
operator|=
name|texture
operator|->
name|isImmutable
argument_list|()
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_USAGE_ANGLE
case|:
operator|*
name|params
operator|=
name|texture
operator|->
name|getUsage
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
operator|*
name|params
operator|=
operator|(
name|GLint
operator|)
name|texture
operator|->
name|getMaxAnisotropy
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetnUniformfvEXT
name|void
name|__stdcall
name|glGetnUniformfvEXT
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLint location = %d, GLsizei bufSize = %d, GLfloat* params = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|bufSize
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufSize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|program
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|||
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|getUniformfv
argument_list|(
name|location
argument_list|,
operator|&
name|bufSize
argument_list|,
name|params
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetUniformfv
name|void
name|__stdcall
name|glGetUniformfv
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLint location = %d, GLfloat* params = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|program
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|||
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|getUniformfv
argument_list|(
name|location
argument_list|,
name|NULL
argument_list|,
name|params
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetnUniformivEXT
name|void
name|__stdcall
name|glGetnUniformivEXT
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLint location = %d, GLsizei bufSize = %d, GLint* params = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|bufSize
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|bufSize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|program
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|||
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|getUniformiv
argument_list|(
name|location
argument_list|,
operator|&
name|bufSize
argument_list|,
name|params
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetUniformiv
name|void
name|__stdcall
name|glGetUniformiv
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLint
name|location
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, GLint location = %d, GLint* params = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|location
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|program
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|||
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|getUniformiv
argument_list|(
name|location
argument_list|,
name|NULL
argument_list|,
name|params
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetUniformLocation
name|int
name|__stdcall
name|glGetUniformLocation
parameter_list|(
name|GLuint
name|program
parameter_list|,
specifier|const
name|GLchar
modifier|*
name|name
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d, const GLchar* name = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"gl_"
argument_list|)
operator|==
name|name
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
operator|||
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
return|return
name|programBinary
operator|->
name|getUniformLocation
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|glGetVertexAttribfv
name|void
name|__stdcall
name|glGetVertexAttribfv
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLenum pname = 0x%X, GLfloat* params = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attribState
init|=
name|context
operator|->
name|getVertexAttribState
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_VERTEX_ATTRIB_ARRAY_ENABLED
case|:
operator|*
name|params
operator|=
call|(
name|GLfloat
call|)
argument_list|(
name|attribState
operator|.
name|mArrayEnabled
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_SIZE
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|attribState
operator|.
name|mSize
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_STRIDE
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|attribState
operator|.
name|mStride
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_TYPE
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|attribState
operator|.
name|mType
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
case|:
operator|*
name|params
operator|=
call|(
name|GLfloat
call|)
argument_list|(
name|attribState
operator|.
name|mNormalized
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|attribState
operator|.
name|mBoundBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_CURRENT_VERTEX_ATTRIB
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
index|]
operator|=
name|attribState
operator|.
name|mCurrentValue
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE
case|:
operator|*
name|params
operator|=
operator|(
name|GLfloat
operator|)
name|attribState
operator|.
name|mDivisor
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetVertexAttribiv
name|void
name|__stdcall
name|glGetVertexAttribiv
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLenum pname = 0x%X, GLint* params = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|attribState
init|=
name|context
operator|->
name|getVertexAttribState
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_VERTEX_ATTRIB_ARRAY_ENABLED
case|:
operator|*
name|params
operator|=
operator|(
name|attribState
operator|.
name|mArrayEnabled
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
operator|)
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_SIZE
case|:
operator|*
name|params
operator|=
name|attribState
operator|.
name|mSize
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_STRIDE
case|:
operator|*
name|params
operator|=
name|attribState
operator|.
name|mStride
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_TYPE
case|:
operator|*
name|params
operator|=
name|attribState
operator|.
name|mType
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_NORMALIZED
case|:
operator|*
name|params
operator|=
operator|(
name|attribState
operator|.
name|mNormalized
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
operator|)
expr_stmt|;
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|attribState
operator|.
name|mBoundBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_CURRENT_VERTEX_ATTRIB
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|float
name|currentValue
init|=
name|attribState
operator|.
name|mCurrentValue
index|[
name|i
index|]
decl_stmt|;
name|params
index|[
name|i
index|]
operator|=
call|(
name|GLint
call|)
argument_list|(
name|currentValue
operator|>
literal|0.0f
condition|?
name|floor
argument_list|(
name|currentValue
operator|+
literal|0.5f
argument_list|)
else|:
name|ceil
argument_list|(
name|currentValue
operator|-
literal|0.5f
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE
case|:
operator|*
name|params
operator|=
operator|(
name|GLint
operator|)
name|attribState
operator|.
name|mDivisor
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetVertexAttribPointerv
name|void
name|__stdcall
name|glGetVertexAttribPointerv
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLvoid
modifier|*
modifier|*
name|pointer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLenum pname = 0x%X, GLvoid** pointer = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|pname
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|pname
operator|!=
name|GL_VERTEX_ATTRIB_ARRAY_POINTER
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
operator|*
name|pointer
operator|=
cast|const_cast
argument_list|<
name|GLvoid
operator|*
argument_list|>
argument_list|(
name|context
operator|->
name|getVertexAttribPointer
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glHint
name|void
name|__stdcall
name|glHint
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|mode
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum mode = 0x%X)"
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|GL_FASTEST
case|:
case|case
name|GL_NICEST
case|:
case|case
name|GL_DONT_CARE
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
if|if
condition|(
name|context
condition|)
name|context
operator|->
name|setGenerateMipmapHint
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
if|if
condition|(
name|context
condition|)
name|context
operator|->
name|setFragmentShaderDerivativeHint
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glIsBuffer
name|GLboolean
name|__stdcall
name|glIsBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint buffer = %d)"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|buffer
condition|)
block|{
name|gl
operator|::
name|Buffer
modifier|*
name|bufferObject
init|=
name|context
operator|->
name|getBuffer
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufferObject
condition|)
block|{
return|return
name|GL_TRUE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glIsEnabled
name|GLboolean
name|__stdcall
name|glIsEnabled
parameter_list|(
name|GLenum
name|cap
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum cap = 0x%X)"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|cap
condition|)
block|{
case|case
name|GL_CULL_FACE
case|:
return|return
name|context
operator|->
name|isCullFaceEnabled
argument_list|()
return|;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
return|return
name|context
operator|->
name|isPolygonOffsetFillEnabled
argument_list|()
return|;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
return|return
name|context
operator|->
name|isSampleAlphaToCoverageEnabled
argument_list|()
return|;
case|case
name|GL_SAMPLE_COVERAGE
case|:
return|return
name|context
operator|->
name|isSampleCoverageEnabled
argument_list|()
return|;
case|case
name|GL_SCISSOR_TEST
case|:
return|return
name|context
operator|->
name|isScissorTestEnabled
argument_list|()
return|;
case|case
name|GL_STENCIL_TEST
case|:
return|return
name|context
operator|->
name|isStencilTestEnabled
argument_list|()
return|;
case|case
name|GL_DEPTH_TEST
case|:
return|return
name|context
operator|->
name|isDepthTestEnabled
argument_list|()
return|;
case|case
name|GL_BLEND
case|:
return|return
name|context
operator|->
name|isBlendEnabled
argument_list|()
return|;
case|case
name|GL_DITHER
case|:
return|return
name|context
operator|->
name|isDitherEnabled
argument_list|()
return|;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|glIsFenceNV
name|GLboolean
name|__stdcall
name|glIsFenceNV
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint fence = %d)"
argument_list|,
name|fence
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Fence
modifier|*
name|fenceObject
init|=
name|context
operator|->
name|getFence
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|==
name|NULL
condition|)
block|{
return|return
name|GL_FALSE
return|;
block|}
return|return
name|fenceObject
operator|->
name|isFence
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glIsFramebuffer
name|GLboolean
name|__stdcall
name|glIsFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint framebuffer = %d)"
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|framebuffer
condition|)
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|context
operator|->
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebufferObject
condition|)
block|{
return|return
name|GL_TRUE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glIsProgram
name|GLboolean
name|__stdcall
name|glIsProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d)"
argument_list|,
name|program
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|program
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|programObject
condition|)
block|{
return|return
name|GL_TRUE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glIsQueryEXT
name|GLboolean
name|__stdcall
name|glIsQueryEXT
parameter_list|(
name|GLuint
name|id
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint id = %d)"
argument_list|,
name|id
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
return|return
name|GL_FALSE
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Query
modifier|*
name|queryObject
init|=
name|context
operator|->
name|getQuery
argument_list|(
name|id
argument_list|,
literal|false
argument_list|,
name|GL_NONE
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
condition|)
block|{
return|return
name|GL_TRUE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glIsRenderbuffer
name|GLboolean
name|__stdcall
name|glIsRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint renderbuffer = %d)"
argument_list|,
name|renderbuffer
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|renderbuffer
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|context
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderbufferObject
condition|)
block|{
return|return
name|GL_TRUE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glIsShader
name|GLboolean
name|__stdcall
name|glIsShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d)"
argument_list|,
name|shader
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|shader
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
name|shaderObject
condition|)
block|{
return|return
name|GL_TRUE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glIsTexture
name|GLboolean
name|__stdcall
name|glIsTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint texture = %d)"
argument_list|,
name|texture
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|texture
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|textureObject
init|=
name|context
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
decl_stmt|;
if|if
condition|(
name|textureObject
condition|)
block|{
return|return
name|GL_TRUE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
name|GL_FALSE
argument_list|)
return|;
block|}
return|return
name|GL_FALSE
return|;
block|}
DECL|function|glLineWidth
name|void
name|__stdcall
name|glLineWidth
parameter_list|(
name|GLfloat
name|width
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLfloat width = %f)"
argument_list|,
name|width
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|width
operator|<=
literal|0.0f
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setLineWidth
argument_list|(
name|width
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glLinkProgram
name|void
name|__stdcall
name|glLinkProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d)"
argument_list|,
name|program
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
name|context
operator|->
name|linkProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glPixelStorei
name|void
name|__stdcall
name|glPixelStorei
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum pname = 0x%X, GLint param = %d)"
argument_list|,
name|pname
argument_list|,
name|param
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_UNPACK_ALIGNMENT
case|:
if|if
condition|(
name|param
operator|!=
literal|1
operator|&&
name|param
operator|!=
literal|2
operator|&&
name|param
operator|!=
literal|4
operator|&&
name|param
operator|!=
literal|8
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|context
operator|->
name|setUnpackAlignment
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_PACK_ALIGNMENT
case|:
if|if
condition|(
name|param
operator|!=
literal|1
operator|&&
name|param
operator|!=
literal|2
operator|&&
name|param
operator|!=
literal|4
operator|&&
name|param
operator|!=
literal|8
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|context
operator|->
name|setPackAlignment
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
name|context
operator|->
name|setPackReverseRowOrder
argument_list|(
name|param
operator|!=
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glPolygonOffset
name|void
name|__stdcall
name|glPolygonOffset
parameter_list|(
name|GLfloat
name|factor
parameter_list|,
name|GLfloat
name|units
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLfloat factor = %f, GLfloat units = %f)"
argument_list|,
name|factor
argument_list|,
name|units
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setPolygonOffsetParams
argument_list|(
name|factor
argument_list|,
name|units
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glReadnPixelsEXT
name|void
name|__stdcall
name|glReadnPixelsEXT
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLvoid
modifier|*
name|data
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d, "
literal|"GLenum format = 0x%X, GLenum type = 0x%X, GLsizei bufSize = 0x%d, GLvoid *data = 0x%0.8p)"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|bufSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|bufSize
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLenum
name|currentFormat
decl_stmt|,
name|currentType
decl_stmt|;
comment|// Failure in getCurrentReadFormatType indicates that no color attachment is currently bound,
comment|// and attempting to read back if that's the case is an error. The error will be registered
comment|// by getCurrentReadFormat.
if|if
condition|(
operator|!
name|context
operator|->
name|getCurrentReadFormatType
argument_list|(
operator|&
name|currentFormat
argument_list|,
operator|&
name|currentType
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|currentFormat
operator|==
name|format
operator|&&
name|currentType
operator|==
name|type
operator|)
operator|&&
operator|!
name|validReadFormatType
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|context
operator|->
name|readPixels
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
operator|&
name|bufSize
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glReadPixels
name|void
name|__stdcall
name|glReadPixels
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d, "
literal|"GLenum format = 0x%X, GLenum type = 0x%X, GLvoid* pixels = 0x%0.8p)"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLenum
name|currentFormat
decl_stmt|,
name|currentType
decl_stmt|;
comment|// Failure in getCurrentReadFormatType indicates that no color attachment is currently bound,
comment|// and attempting to read back if that's the case is an error. The error will be registered
comment|// by getCurrentReadFormat.
if|if
condition|(
operator|!
name|context
operator|->
name|getCurrentReadFormatType
argument_list|(
operator|&
name|currentFormat
argument_list|,
operator|&
name|currentType
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|currentFormat
operator|==
name|format
operator|&&
name|currentType
operator|==
name|type
operator|)
operator|&&
operator|!
name|validReadFormatType
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|context
operator|->
name|readPixels
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glReleaseShaderCompiler
name|void
name|__stdcall
name|glReleaseShaderCompiler
parameter_list|(
name|void
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Shader
operator|::
name|releaseCompiler
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glRenderbufferStorageMultisampleANGLE
name|void
name|__stdcall
name|glRenderbufferStorageMultisampleANGLE
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|samples
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLsizei samples = %d, GLenum internalformat = 0x%X, GLsizei width = %d, GLsizei height = %d)"
argument_list|,
name|target
argument_list|,
name|samples
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_RENDERBUFFER
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|gl
operator|::
name|IsColorRenderable
argument_list|(
name|internalformat
argument_list|)
operator|&&
operator|!
name|gl
operator|::
name|IsDepthRenderable
argument_list|(
name|internalformat
argument_list|)
operator|&&
operator|!
name|gl
operator|::
name|IsStencilRenderable
argument_list|(
name|internalformat
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
operator|||
name|samples
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|width
operator|>
name|context
operator|->
name|getMaximumRenderbufferDimension
argument_list|()
operator|||
name|height
operator|>
name|context
operator|->
name|getMaximumRenderbufferDimension
argument_list|()
operator|||
name|samples
operator|>
name|context
operator|->
name|getMaxSupportedSamples
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|GLuint
name|handle
init|=
name|context
operator|->
name|getRenderbufferHandle
argument_list|()
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_DEPTH_COMPONENT16
case|:
case|case
name|GL_RGBA4
case|:
case|case
name|GL_RGB5_A1
case|:
case|case
name|GL_RGB565
case|:
case|case
name|GL_RGB8_OES
case|:
case|case
name|GL_RGBA8_OES
case|:
case|case
name|GL_BGRA8_EXT
case|:
case|case
name|GL_STENCIL_INDEX8
case|:
case|case
name|GL_DEPTH24_STENCIL8_OES
case|:
name|context
operator|->
name|setRenderbufferStorage
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|internalformat
argument_list|,
name|samples
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glRenderbufferStorage
name|void
name|__stdcall
name|glRenderbufferStorage
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|glRenderbufferStorageMultisampleANGLE
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
DECL|function|glSampleCoverage
name|void
name|__stdcall
name|glSampleCoverage
parameter_list|(
name|GLclampf
name|value
parameter_list|,
name|GLboolean
name|invert
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLclampf value = %f, GLboolean invert = %d)"
argument_list|,
name|value
argument_list|,
name|invert
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setSampleCoverageParams
argument_list|(
name|gl
operator|::
name|clamp01
argument_list|(
name|value
argument_list|)
argument_list|,
name|invert
operator|==
name|GL_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glSetFenceNV
name|void
name|__stdcall
name|glSetFenceNV
parameter_list|(
name|GLuint
name|fence
parameter_list|,
name|GLenum
name|condition
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint fence = %d, GLenum condition = 0x%X)"
argument_list|,
name|fence
argument_list|,
name|condition
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|condition
operator|!=
name|GL_ALL_COMPLETED_NV
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Fence
modifier|*
name|fenceObject
init|=
name|context
operator|->
name|getFence
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|fenceObject
operator|->
name|setFence
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glScissor
name|void
name|__stdcall
name|glScissor
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d)"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setScissorParams
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glShaderBinary
name|void
name|__stdcall
name|glShaderBinary
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLuint
modifier|*
name|shaders
parameter_list|,
name|GLenum
name|binaryformat
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|binary
parameter_list|,
name|GLsizei
name|length
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLsizei n = %d, const GLuint* shaders = 0x%0.8p, GLenum binaryformat = 0x%X, "
literal|"const GLvoid* binary = 0x%0.8p, GLsizei length = %d)"
argument_list|,
name|n
argument_list|,
name|shaders
argument_list|,
name|binaryformat
argument_list|,
name|binary
argument_list|,
name|length
argument_list|)
expr_stmt|;
try|try
block|{
comment|// No binary shader formats are supported.
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glShaderSource
name|void
name|__stdcall
name|glShaderSource
parameter_list|(
name|GLuint
name|shader
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLchar
modifier|*
modifier|*
name|string
parameter_list|,
specifier|const
name|GLint
modifier|*
name|length
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint shader = %d, GLsizei count = %d, const GLchar** string = 0x%0.8p, const GLint* length = 0x%0.8p)"
argument_list|,
name|shader
argument_list|,
name|count
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Shader
modifier|*
name|shaderObject
init|=
name|context
operator|->
name|getShader
argument_list|(
name|shader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shaderObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getProgram
argument_list|(
name|shader
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
name|shaderObject
operator|->
name|setSource
argument_list|(
name|count
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glStencilFunc
name|void
name|__stdcall
name|glStencilFunc
parameter_list|(
name|GLenum
name|func
parameter_list|,
name|GLint
name|ref
parameter_list|,
name|GLuint
name|mask
parameter_list|)
block|{
name|glStencilFuncSeparate
argument_list|(
name|GL_FRONT_AND_BACK
argument_list|,
name|func
argument_list|,
name|ref
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
DECL|function|glStencilFuncSeparate
name|void
name|__stdcall
name|glStencilFuncSeparate
parameter_list|(
name|GLenum
name|face
parameter_list|,
name|GLenum
name|func
parameter_list|,
name|GLint
name|ref
parameter_list|,
name|GLuint
name|mask
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum face = 0x%X, GLenum func = 0x%X, GLint ref = %d, GLuint mask = %d)"
argument_list|,
name|face
argument_list|,
name|func
argument_list|,
name|ref
argument_list|,
name|mask
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|face
condition|)
block|{
case|case
name|GL_FRONT
case|:
case|case
name|GL_BACK
case|:
case|case
name|GL_FRONT_AND_BACK
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|GL_NEVER
case|:
case|case
name|GL_ALWAYS
case|:
case|case
name|GL_LESS
case|:
case|case
name|GL_LEQUAL
case|:
case|case
name|GL_EQUAL
case|:
case|case
name|GL_GEQUAL
case|:
case|case
name|GL_GREATER
case|:
case|case
name|GL_NOTEQUAL
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|face
operator|==
name|GL_FRONT
operator|||
name|face
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
name|context
operator|->
name|setStencilParams
argument_list|(
name|func
argument_list|,
name|ref
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|face
operator|==
name|GL_BACK
operator|||
name|face
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
name|context
operator|->
name|setStencilBackParams
argument_list|(
name|func
argument_list|,
name|ref
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glStencilMask
name|void
name|__stdcall
name|glStencilMask
parameter_list|(
name|GLuint
name|mask
parameter_list|)
block|{
name|glStencilMaskSeparate
argument_list|(
name|GL_FRONT_AND_BACK
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
DECL|function|glStencilMaskSeparate
name|void
name|__stdcall
name|glStencilMaskSeparate
parameter_list|(
name|GLenum
name|face
parameter_list|,
name|GLuint
name|mask
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum face = 0x%X, GLuint mask = %d)"
argument_list|,
name|face
argument_list|,
name|mask
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|face
condition|)
block|{
case|case
name|GL_FRONT
case|:
case|case
name|GL_BACK
case|:
case|case
name|GL_FRONT_AND_BACK
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|face
operator|==
name|GL_FRONT
operator|||
name|face
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
name|context
operator|->
name|setStencilWritemask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|face
operator|==
name|GL_BACK
operator|||
name|face
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
name|context
operator|->
name|setStencilBackWritemask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glStencilOp
name|void
name|__stdcall
name|glStencilOp
parameter_list|(
name|GLenum
name|fail
parameter_list|,
name|GLenum
name|zfail
parameter_list|,
name|GLenum
name|zpass
parameter_list|)
block|{
name|glStencilOpSeparate
argument_list|(
name|GL_FRONT_AND_BACK
argument_list|,
name|fail
argument_list|,
name|zfail
argument_list|,
name|zpass
argument_list|)
expr_stmt|;
block|}
DECL|function|glStencilOpSeparate
name|void
name|__stdcall
name|glStencilOpSeparate
parameter_list|(
name|GLenum
name|face
parameter_list|,
name|GLenum
name|fail
parameter_list|,
name|GLenum
name|zfail
parameter_list|,
name|GLenum
name|zpass
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum face = 0x%X, GLenum fail = 0x%X, GLenum zfail = 0x%X, GLenum zpas = 0x%Xs)"
argument_list|,
name|face
argument_list|,
name|fail
argument_list|,
name|zfail
argument_list|,
name|zpass
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|face
condition|)
block|{
case|case
name|GL_FRONT
case|:
case|case
name|GL_BACK
case|:
case|case
name|GL_FRONT_AND_BACK
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|fail
condition|)
block|{
case|case
name|GL_ZERO
case|:
case|case
name|GL_KEEP
case|:
case|case
name|GL_REPLACE
case|:
case|case
name|GL_INCR
case|:
case|case
name|GL_DECR
case|:
case|case
name|GL_INVERT
case|:
case|case
name|GL_INCR_WRAP
case|:
case|case
name|GL_DECR_WRAP
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|zfail
condition|)
block|{
case|case
name|GL_ZERO
case|:
case|case
name|GL_KEEP
case|:
case|case
name|GL_REPLACE
case|:
case|case
name|GL_INCR
case|:
case|case
name|GL_DECR
case|:
case|case
name|GL_INVERT
case|:
case|case
name|GL_INCR_WRAP
case|:
case|case
name|GL_DECR_WRAP
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|zpass
condition|)
block|{
case|case
name|GL_ZERO
case|:
case|case
name|GL_KEEP
case|:
case|case
name|GL_REPLACE
case|:
case|case
name|GL_INCR
case|:
case|case
name|GL_DECR
case|:
case|case
name|GL_INVERT
case|:
case|case
name|GL_INCR_WRAP
case|:
case|case
name|GL_DECR_WRAP
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|face
operator|==
name|GL_FRONT
operator|||
name|face
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
name|context
operator|->
name|setStencilOperations
argument_list|(
name|fail
argument_list|,
name|zfail
argument_list|,
name|zpass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|face
operator|==
name|GL_BACK
operator|||
name|face
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
name|context
operator|->
name|setStencilBackOperations
argument_list|(
name|fail
argument_list|,
name|zfail
argument_list|,
name|zpass
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glTestFenceNV
name|GLboolean
name|__stdcall
name|glTestFenceNV
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint fence = %d)"
argument_list|,
name|fence
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Fence
modifier|*
name|fenceObject
init|=
name|context
operator|->
name|getFence
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|==
name|NULL
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
name|GL_TRUE
argument_list|)
return|;
block|}
return|return
name|fenceObject
operator|->
name|testFence
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
expr_stmt|;
block|}
return|return
name|GL_TRUE
return|;
block|}
DECL|function|glTexImage2D
name|void
name|__stdcall
name|glTexImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLint
name|border
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLint level = %d, GLint internalformat = %d, GLsizei width = %d, GLsizei height = %d, "
literal|"GLint border = %d, GLenum format = 0x%X, GLenum type = 0x%X, const GLvoid* pixels =  0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|border
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|validImageSize
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|internalformat
operator|!=
name|GLint
argument_list|(
name|format
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// validate<type> by itself (used as secondary key below)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT_5_6_5
case|:
case|case
name|GL_UNSIGNED_SHORT_4_4_4_4
case|:
case|case
name|GL_UNSIGNED_SHORT_5_5_5_1
case|:
case|case
name|GL_UNSIGNED_SHORT
case|:
case|case
name|GL_UNSIGNED_INT
case|:
case|case
name|GL_UNSIGNED_INT_24_8_OES
case|:
case|case
name|GL_HALF_FLOAT_OES
case|:
case|case
name|GL_FLOAT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
comment|// validate<format> +<type> combinations
comment|// - invalid<format> -> sets INVALID_ENUM
comment|// - invalid<format>+<type> combination -> sets INVALID_OPERATION
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_ALPHA
case|:
case|case
name|GL_LUMINANCE
case|:
case|case
name|GL_LUMINANCE_ALPHA
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_FLOAT
case|:
case|case
name|GL_HALF_FLOAT_OES
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_RGB
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT_5_6_5
case|:
case|case
name|GL_FLOAT
case|:
case|case
name|GL_HALF_FLOAT_OES
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_RGBA
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_UNSIGNED_SHORT_4_4_4_4
case|:
case|case
name|GL_UNSIGNED_SHORT_5_5_5_1
case|:
case|case
name|GL_FLOAT
case|:
case|case
name|GL_HALF_FLOAT_OES
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_BGRA_EXT
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
comment|// error cases for compressed textures are handled below
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
break|break;
case|case
name|GL_DEPTH_COMPONENT
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_SHORT
case|:
case|case
name|GL_UNSIGNED_INT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_DEPTH_STENCIL_OES
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_INT_24_8_OES
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|border
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|context
operator|->
name|getMaximumTextureLevel
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
if|if
condition|(
name|width
operator|>
operator|(
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
operator|>>
name|level
operator|)
operator|||
name|height
operator|>
operator|(
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
operator|>>
name|level
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
if|if
condition|(
name|width
operator|!=
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|>
operator|(
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
operator|>>
name|level
operator|)
operator|||
name|height
operator|>
operator|(
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
operator|>>
name|level
operator|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
if|if
condition|(
name|context
operator|->
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
if|if
condition|(
name|context
operator|->
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
if|if
condition|(
name|context
operator|->
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_DEPTH_COMPONENT
case|:
case|case
name|GL_DEPTH_STENCIL_OES
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDepthTextures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// OES_depth_texture supports loading depth data and multiple levels,
comment|// but ANGLE_depth_texture does not
if|if
condition|(
name|pixels
operator|!=
name|NULL
operator|||
name|level
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|GL_FLOAT
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|supportsFloat32Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|GL_HALF_FLOAT_OES
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|supportsFloat16Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texture
operator|->
name|setImage
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texture
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_X
case|:
name|texture
operator|->
name|setImagePosX
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_X
case|:
name|texture
operator|->
name|setImageNegX
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Y
case|:
name|texture
operator|->
name|setImagePosY
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
case|:
name|texture
operator|->
name|setImageNegY
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_POSITIVE_Z
case|:
name|texture
operator|->
name|setImagePosZ
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
case|:
name|texture
operator|->
name|setImageNegZ
argument_list|(
name|level
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glTexParameterf
name|void
name|__stdcall
name|glTexParameterf
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLfloat
name|param
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum pname = 0x%X, GLint param = %f)"
argument_list|,
name|target
argument_list|,
name|pname
argument_list|,
name|param
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|texture
operator|=
name|context
operator|->
name|getTexture2D
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
name|texture
operator|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_S
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setWrapS
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setWrapT
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setMinFilter
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setMagFilter
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_USAGE_ANGLE
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setUsage
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|texture
operator|->
name|setMaxAnisotropy
argument_list|(
operator|(
name|float
operator|)
name|param
argument_list|,
name|context
operator|->
name|getTextureMaxAnisotropy
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glTexParameterfv
name|void
name|__stdcall
name|glTexParameterfv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
name|glTexParameterf
argument_list|(
name|target
argument_list|,
name|pname
argument_list|,
operator|(
name|GLfloat
operator|)
operator|*
name|params
argument_list|)
expr_stmt|;
block|}
DECL|function|glTexParameteri
name|void
name|__stdcall
name|glTexParameteri
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLenum pname = 0x%X, GLint param = %d)"
argument_list|,
name|target
argument_list|,
name|pname
argument_list|,
name|param
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Texture
modifier|*
name|texture
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
name|texture
operator|=
name|context
operator|->
name|getTexture2D
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
name|texture
operator|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_WRAP_S
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setWrapS
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setWrapT
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setMinFilter
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setMagFilter
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_USAGE_ANGLE
case|:
if|if
condition|(
operator|!
name|texture
operator|->
name|setUsage
argument_list|(
operator|(
name|GLenum
operator|)
name|param
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|texture
operator|->
name|setMaxAnisotropy
argument_list|(
operator|(
name|float
operator|)
name|param
argument_list|,
name|context
operator|->
name|getTextureMaxAnisotropy
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glTexParameteriv
name|void
name|__stdcall
name|glTexParameteriv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
name|pname
parameter_list|,
specifier|const
name|GLint
modifier|*
name|params
parameter_list|)
block|{
name|glTexParameteri
argument_list|(
name|target
argument_list|,
name|pname
argument_list|,
operator|*
name|params
argument_list|)
expr_stmt|;
block|}
DECL|function|glTexStorage2DEXT
name|void
name|__stdcall
name|glTexStorage2DEXT
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|levels
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLsizei levels = %d, GLenum internalformat = 0x%X, GLsizei width = %d, GLsizei height = %d)"
argument_list|,
name|target
argument_list|,
name|levels
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
operator|&&
name|target
operator|!=
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|1
operator|||
name|height
operator|<
literal|1
operator|||
name|levels
operator|<
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_CUBE_MAP
operator|&&
name|width
operator|!=
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|levels
operator|!=
literal|1
operator|&&
name|levels
operator|!=
name|gl
operator|::
name|log2
argument_list|(
name|std
operator|::
name|max
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|+
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|GLenum
name|format
init|=
name|gl
operator|::
name|ExtractFormat
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
name|GLenum
name|type
init|=
name|gl
operator|::
name|ExtractType
argument_list|(
name|internalformat
argument_list|)
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|GL_NONE
operator|||
name|type
operator|==
name|GL_NONE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
if|if
condition|(
name|width
operator|>
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
operator|||
name|height
operator|>
name|context
operator|->
name|getMaximumTextureDimension
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
if|if
condition|(
name|width
operator|>
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
operator|||
name|height
operator|>
name|context
operator|->
name|getMaximumCubeTextureDimension
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|levels
operator|!=
literal|1
operator|&&
operator|!
name|context
operator|->
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|width
argument_list|)
operator|||
operator|!
name|gl
operator|::
name|isPow2
argument_list|(
name|height
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
switch|switch
condition|(
name|internalformat
condition|)
block|{
case|case
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
case|:
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_RGBA32F_EXT
case|:
case|case
name|GL_RGB32F_EXT
case|:
case|case
name|GL_ALPHA32F_EXT
case|:
case|case
name|GL_LUMINANCE32F_EXT
case|:
case|case
name|GL_LUMINANCE_ALPHA32F_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsFloat32Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_RGBA16F_EXT
case|:
case|case
name|GL_RGB16F_EXT
case|:
case|case
name|GL_ALPHA16F_EXT
case|:
case|case
name|GL_LUMINANCE16F_EXT
case|:
case|case
name|GL_LUMINANCE_ALPHA16F_EXT
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsFloat16Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
break|break;
case|case
name|GL_DEPTH_COMPONENT16
case|:
case|case
name|GL_DEPTH_COMPONENT32_OES
case|:
case|case
name|GL_DEPTH24_STENCIL8_OES
case|:
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDepthTextures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// ANGLE_depth_texture only supports 1-level textures
if|if
condition|(
name|levels
operator|!=
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
operator|||
name|texture
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texture
operator|->
name|storage
argument_list|(
name|levels
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_CUBE_MAP
condition|)
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texture
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|texture
operator|||
name|texture
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|texture
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|texture
operator|->
name|storage
argument_list|(
name|levels
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glTexSubImage2D
name|void
name|__stdcall
name|glTexSubImage2D
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLint
name|xoffset
parameter_list|,
name|GLint
name|yoffset
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, "
literal|"GLsizei width = %d, GLsizei height = %d, GLenum format = 0x%X, GLenum type = 0x%X, "
literal|"const GLvoid* pixels = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|gl
operator|::
name|IsInternalTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|xoffset
operator|<
literal|0
operator|||
name|yoffset
operator|<
literal|0
operator|||
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|xoffset
operator|<
name|width
operator|||
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLsizei
argument_list|>
operator|::
name|max
argument_list|()
operator|-
name|yoffset
operator|<
name|height
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|checkTextureFormatType
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
condition|)
block|{
return|return;
comment|// error is set by helper function
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|context
operator|->
name|getMaximumTextureLevel
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|format
operator|==
name|GL_FLOAT
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|supportsFloat32Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|GL_HALF_FLOAT_OES
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|supportsFloat16Textures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsDepthTexture
argument_list|(
name|format
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|supportsDepthTextures
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|GL_TEXTURE_2D
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// OES_depth_texture supports loading depth data, but ANGLE_depth_texture does not
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
operator|||
name|pixels
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|target
operator|==
name|GL_TEXTURE_2D
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|texture
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
name|validateSubImageParams2D
argument_list|(
literal|false
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|texture
argument_list|)
condition|)
block|{
name|texture
operator|->
name|subImage
argument_list|(
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gl
operator|::
name|IsCubemapTextureTarget
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|gl
operator|::
name|TextureCubeMap
modifier|*
name|texture
init|=
name|context
operator|->
name|getTextureCubeMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|validateSubImageParamsCube
argument_list|(
literal|false
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|texture
argument_list|)
condition|)
block|{
name|texture
operator|->
name|subImage
argument_list|(
name|target
argument_list|,
name|level
argument_list|,
name|xoffset
argument_list|,
name|yoffset
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|context
operator|->
name|getUnpackAlignment
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform1f
name|void
name|__stdcall
name|glUniform1f
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|)
block|{
name|glUniform1fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform1fv
name|void
name|__stdcall
name|glUniform1fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform1fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform1i
name|void
name|__stdcall
name|glUniform1i
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
name|x
parameter_list|)
block|{
name|glUniform1iv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform1iv
name|void
name|__stdcall
name|glUniform1iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform1iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform2f
name|void
name|__stdcall
name|glUniform2f
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|)
block|{
name|GLfloat
name|xy
index|[
literal|2
index|]
init|=
block|{
name|x
block|,
name|y
block|}
decl_stmt|;
name|glUniform2fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
operator|&
name|xy
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform2fv
name|void
name|__stdcall
name|glUniform2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform2i
name|void
name|__stdcall
name|glUniform2i
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|)
block|{
name|GLint
name|xy
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|}
decl_stmt|;
name|glUniform2iv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|(
name|GLint
operator|*
operator|)
operator|&
name|xy
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform2iv
name|void
name|__stdcall
name|glUniform2iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform2iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform3f
name|void
name|__stdcall
name|glUniform3f
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|)
block|{
name|GLfloat
name|xyz
index|[
literal|3
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|}
decl_stmt|;
name|glUniform3fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
operator|&
name|xyz
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform3fv
name|void
name|__stdcall
name|glUniform3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform3i
name|void
name|__stdcall
name|glUniform3i
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLint
name|z
parameter_list|)
block|{
name|GLint
name|xyz
index|[
literal|3
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|}
decl_stmt|;
name|glUniform3iv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|(
name|GLint
operator|*
operator|)
operator|&
name|xyz
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform3iv
name|void
name|__stdcall
name|glUniform3iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform3iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform4f
name|void
name|__stdcall
name|glUniform4f
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|,
name|GLfloat
name|w
parameter_list|)
block|{
name|GLfloat
name|xyzw
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|,
name|w
block|}
decl_stmt|;
name|glUniform4fv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|(
name|GLfloat
operator|*
operator|)
operator|&
name|xyzw
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform4fv
name|void
name|__stdcall
name|glUniform4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniform4i
name|void
name|__stdcall
name|glUniform4i
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLint
name|z
parameter_list|,
name|GLint
name|w
parameter_list|)
block|{
name|GLint
name|xyzw
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|,
name|w
block|}
decl_stmt|;
name|glUniform4iv
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
operator|(
name|GLint
operator|*
operator|)
operator|&
name|xyzw
argument_list|)
expr_stmt|;
block|}
DECL|function|glUniform4iv
name|void
name|__stdcall
name|glUniform4iv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
specifier|const
name|GLint
modifier|*
name|v
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniform4iv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|v
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniformMatrix2fv
name|void
name|__stdcall
name|glUniformMatrix2fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, GLboolean transpose = %d, const GLfloat* value = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|transpose
operator|!=
name|GL_FALSE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniformMatrix2fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|value
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniformMatrix3fv
name|void
name|__stdcall
name|glUniformMatrix3fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, GLboolean transpose = %d, const GLfloat* value = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|transpose
operator|!=
name|GL_FALSE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniformMatrix3fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|value
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUniformMatrix4fv
name|void
name|__stdcall
name|glUniformMatrix4fv
parameter_list|(
name|GLint
name|location
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLboolean
name|transpose
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|value
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint location = %d, GLsizei count = %d, GLboolean transpose = %d, const GLfloat* value = 0x%0.8p)"
argument_list|,
name|location
argument_list|,
name|count
argument_list|,
name|transpose
argument_list|,
name|value
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|transpose
operator|!=
name|GL_FALSE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|location
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|context
operator|->
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|setUniformMatrix4fv
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|value
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glUseProgram
name|void
name|__stdcall
name|glUseProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d)"
argument_list|,
name|program
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|&&
name|program
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|program
operator|!=
literal|0
operator|&&
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|context
operator|->
name|useProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glValidateProgram
name|void
name|__stdcall
name|glValidateProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint program = %d)"
argument_list|,
name|program
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getShader
argument_list|(
name|program
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
block|}
name|programObject
operator|->
name|validate
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib1f
name|void
name|__stdcall
name|glVertexAttrib1f
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLfloat
name|x
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLfloat x = %f)"
argument_list|,
name|index
argument_list|,
name|x
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLfloat
name|vals
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib1fv
name|void
name|__stdcall
name|glVertexAttrib1fv
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, const GLfloat* values = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|values
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLfloat
name|vals
index|[
literal|4
index|]
init|=
block|{
name|values
index|[
literal|0
index|]
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib2f
name|void
name|__stdcall
name|glVertexAttrib2f
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLfloat x = %f, GLfloat y = %f)"
argument_list|,
name|index
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLfloat
name|vals
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib2fv
name|void
name|__stdcall
name|glVertexAttrib2fv
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, const GLfloat* values = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|values
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLfloat
name|vals
index|[
literal|4
index|]
init|=
block|{
name|values
index|[
literal|0
index|]
block|,
name|values
index|[
literal|1
index|]
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib3f
name|void
name|__stdcall
name|glVertexAttrib3f
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLfloat x = %f, GLfloat y = %f, GLfloat z = %f)"
argument_list|,
name|index
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLfloat
name|vals
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|,
literal|1
block|}
decl_stmt|;
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib3fv
name|void
name|__stdcall
name|glVertexAttrib3fv
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, const GLfloat* values = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|values
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLfloat
name|vals
index|[
literal|4
index|]
init|=
block|{
name|values
index|[
literal|0
index|]
block|,
name|values
index|[
literal|1
index|]
block|,
name|values
index|[
literal|2
index|]
block|,
literal|1
block|}
decl_stmt|;
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib4f
name|void
name|__stdcall
name|glVertexAttrib4f
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLfloat
name|x
parameter_list|,
name|GLfloat
name|y
parameter_list|,
name|GLfloat
name|z
parameter_list|,
name|GLfloat
name|w
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLfloat x = %f, GLfloat y = %f, GLfloat z = %f, GLfloat w = %f)"
argument_list|,
name|index
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|w
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|GLfloat
name|vals
index|[
literal|4
index|]
init|=
block|{
name|x
block|,
name|y
block|,
name|z
block|,
name|w
block|}
decl_stmt|;
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttrib4fv
name|void
name|__stdcall
name|glVertexAttrib4fv
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, const GLfloat* values = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|values
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setVertexAttrib
argument_list|(
name|index
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttribDivisorANGLE
name|void
name|__stdcall
name|glVertexAttribDivisorANGLE
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLuint
name|divisor
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLuint divisor = %d)"
argument_list|,
name|index
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setVertexAttribDivisor
argument_list|(
name|index
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glVertexAttribPointer
name|void
name|__stdcall
name|glVertexAttribPointer
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLint
name|size
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLboolean
name|normalized
parameter_list|,
name|GLsizei
name|stride
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|ptr
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLuint index = %d, GLint size = %d, GLenum type = 0x%X, "
literal|"GLboolean normalized = %d, GLsizei stride = %d, const GLvoid* ptr = 0x%0.8p)"
argument_list|,
name|index
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|normalized
argument_list|,
name|stride
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|>=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|size
argument_list|<
literal|1
operator|||
name|size
argument_list|>
literal|4
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_BYTE
case|:
case|case
name|GL_UNSIGNED_BYTE
case|:
case|case
name|GL_SHORT
case|:
case|case
name|GL_UNSIGNED_SHORT
case|:
case|case
name|GL_FIXED
case|:
case|case
name|GL_FLOAT
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
name|stride
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setVertexAttribState
argument_list|(
name|index
argument_list|,
name|context
operator|->
name|getArrayBuffer
argument_list|()
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
operator|(
name|normalized
operator|==
name|GL_TRUE
operator|)
argument_list|,
name|stride
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glViewport
name|void
name|__stdcall
name|glViewport
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d)"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|width
operator|<
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|context
operator|->
name|setViewportParams
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glBlitFramebufferANGLE
name|void
name|__stdcall
name|glBlitFramebufferANGLE
parameter_list|(
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLint srcX0 = %d, GLint srcY0 = %d, GLint srcX1 = %d, GLint srcY1 = %d, "
literal|"GLint dstX0 = %d, GLint dstY0 = %d, GLint dstX1 = %d, GLint dstY1 = %d, "
literal|"GLbitfield mask = 0x%X, GLenum filter = 0x%X)"
argument_list|,
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
argument_list|,
name|srcX1
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
argument_list|,
name|dstY1
argument_list|,
name|mask
argument_list|,
name|filter
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|GL_NEAREST
case|:
break|break;
default|default:
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
operator|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|srcX1
operator|-
name|srcX0
operator|!=
name|dstX1
operator|-
name|dstX0
operator|||
name|srcY1
operator|-
name|srcY0
operator|!=
name|dstY1
operator|-
name|dstY0
condition|)
block|{
name|ERR
argument_list|(
literal|"Scaling and flipping in BlitFramebufferANGLE not supported by this implementation"
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|getReadFramebufferHandle
argument_list|()
operator|==
name|context
operator|->
name|getDrawFramebufferHandle
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Blits with the same source and destination framebuffer are not supported by this implementation."
argument_list|)
expr_stmt|;
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|context
operator|->
name|blitFramebuffer
argument_list|(
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
argument_list|,
name|srcY1
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
argument_list|,
name|dstY1
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glTexImage3DOES
name|void
name|__stdcall
name|glTexImage3DOES
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLint
name|level
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLsizei
name|depth
parameter_list|,
name|GLint
name|border
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|pixels
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum target = 0x%X, GLint level = %d, GLenum internalformat = 0x%X, "
literal|"GLsizei width = %d, GLsizei height = %d, GLsizei depth = %d, GLint border = %d, "
literal|"GLenum format = 0x%X, GLenum type = 0x%x, const GLvoid* pixels = 0x%0.8p)"
argument_list|,
name|target
argument_list|,
name|level
argument_list|,
name|internalformat
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|depth
argument_list|,
name|border
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
try|try
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetProgramBinaryOES
name|void
name|__stdcall
name|glGetProgramBinaryOES
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLsizei
modifier|*
name|length
parameter_list|,
name|GLenum
modifier|*
name|binaryFormat
parameter_list|,
name|void
modifier|*
name|binary
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum program = 0x%X, bufSize = %d, length = 0x%0.8p, binaryFormat = 0x%0.8p, binary = 0x%0.8p)"
argument_list|,
name|program
argument_list|,
name|bufSize
argument_list|,
name|length
argument_list|,
name|binaryFormat
argument_list|,
name|binary
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
operator|||
operator|!
name|programObject
operator|->
name|isLinked
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|gl
operator|::
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|programBinary
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|programBinary
operator|->
name|save
argument_list|(
name|binary
argument_list|,
name|bufSize
argument_list|,
name|length
argument_list|)
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
operator|*
name|binaryFormat
operator|=
name|GL_PROGRAM_BINARY_ANGLE
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glProgramBinaryOES
name|void
name|__stdcall
name|glProgramBinaryOES
parameter_list|(
name|GLuint
name|program
parameter_list|,
name|GLenum
name|binaryFormat
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLint
name|length
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum program = 0x%X, binaryFormat = 0x%x, binary = 0x%0.8p, length = %d)"
argument_list|,
name|program
argument_list|,
name|binaryFormat
argument_list|,
name|binary
argument_list|,
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|binaryFormat
operator|!=
name|GL_PROGRAM_BINARY_ANGLE
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
block|}
name|gl
operator|::
name|Program
modifier|*
name|programObject
init|=
name|context
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|programObject
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|context
operator|->
name|setProgramBinary
argument_list|(
name|program
argument_list|,
name|binary
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glDrawBuffersEXT
name|void
name|__stdcall
name|glDrawBuffersEXT
parameter_list|(
name|GLsizei
name|n
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|bufs
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(GLenum n = %d, bufs = 0x%0.8p)"
argument_list|,
name|n
argument_list|,
name|bufs
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|n
argument_list|<
literal|0
operator|||
operator|(
name|unsigned
name|int
operator|)
name|n
argument_list|>
name|context
operator|->
name|getMaximumRenderTargets
argument_list|()
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|->
name|getDrawFramebufferHandle
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|bufs
index|[
literal|0
index|]
operator|!=
name|GL_NONE
operator|&&
name|bufs
index|[
literal|0
index|]
operator|!=
name|GL_BACK
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|n
condition|;
name|colorAttachment
operator|++
control|)
block|{
specifier|const
name|GLenum
name|attachment
init|=
name|GL_COLOR_ATTACHMENT0_EXT
operator|+
name|colorAttachment
decl_stmt|;
if|if
condition|(
name|bufs
index|[
name|colorAttachment
index|]
operator|!=
name|GL_NONE
operator|&&
name|bufs
index|[
name|colorAttachment
index|]
operator|!=
name|attachment
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
block|}
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|context
operator|->
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|colorAttachment
init|=
literal|0
init|;
name|colorAttachment
operator|<
name|n
condition|;
name|colorAttachment
operator|++
control|)
block|{
name|framebuffer
operator|->
name|setDrawBufferState
argument_list|(
name|colorAttachment
argument_list|,
name|bufs
index|[
name|colorAttachment
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|colorAttachment
init|=
name|n
init|;
name|colorAttachment
operator|<
operator|(
name|int
operator|)
name|context
operator|->
name|getMaximumRenderTargets
argument_list|()
condition|;
name|colorAttachment
operator|++
control|)
block|{
name|framebuffer
operator|->
name|setDrawBufferState
argument_list|(
name|colorAttachment
argument_list|,
name|GL_NONE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|glGetProcAddress
name|__eglMustCastToProperFunctionPointerType
name|__stdcall
name|glGetProcAddress
parameter_list|(
specifier|const
name|char
modifier|*
name|procname
parameter_list|)
block|{
struct|struct
name|Extension
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|__eglMustCastToProperFunctionPointerType
name|address
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|Extension
name|glExtensions
index|[]
init|=
block|{
block|{
literal|"glTexImage3DOES"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glTexImage3DOES
block|}
block|,
block|{
literal|"glBlitFramebufferANGLE"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glBlitFramebufferANGLE
block|}
block|,
block|{
literal|"glRenderbufferStorageMultisampleANGLE"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glRenderbufferStorageMultisampleANGLE
block|}
block|,
block|{
literal|"glDeleteFencesNV"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glDeleteFencesNV
block|}
block|,
block|{
literal|"glGenFencesNV"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGenFencesNV
block|}
block|,
block|{
literal|"glIsFenceNV"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glIsFenceNV
block|}
block|,
block|{
literal|"glTestFenceNV"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glTestFenceNV
block|}
block|,
block|{
literal|"glGetFenceivNV"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetFenceivNV
block|}
block|,
block|{
literal|"glFinishFenceNV"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glFinishFenceNV
block|}
block|,
block|{
literal|"glSetFenceNV"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glSetFenceNV
block|}
block|,
block|{
literal|"glGetTranslatedShaderSourceANGLE"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetTranslatedShaderSourceANGLE
block|}
block|,
block|{
literal|"glTexStorage2DEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glTexStorage2DEXT
block|}
block|,
block|{
literal|"glGetGraphicsResetStatusEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetGraphicsResetStatusEXT
block|}
block|,
block|{
literal|"glReadnPixelsEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glReadnPixelsEXT
block|}
block|,
block|{
literal|"glGetnUniformfvEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetnUniformfvEXT
block|}
block|,
block|{
literal|"glGetnUniformivEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetnUniformivEXT
block|}
block|,
block|{
literal|"glGenQueriesEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGenQueriesEXT
block|}
block|,
block|{
literal|"glDeleteQueriesEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glDeleteQueriesEXT
block|}
block|,
block|{
literal|"glIsQueryEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glIsQueryEXT
block|}
block|,
block|{
literal|"glBeginQueryEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glBeginQueryEXT
block|}
block|,
block|{
literal|"glEndQueryEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glEndQueryEXT
block|}
block|,
block|{
literal|"glGetQueryivEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetQueryivEXT
block|}
block|,
block|{
literal|"glGetQueryObjectuivEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetQueryObjectuivEXT
block|}
block|,
block|{
literal|"glDrawBuffersEXT"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glDrawBuffersEXT
block|}
block|,
block|{
literal|"glVertexAttribDivisorANGLE"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glVertexAttribDivisorANGLE
block|}
block|,
block|{
literal|"glDrawArraysInstancedANGLE"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glDrawArraysInstancedANGLE
block|}
block|,
block|{
literal|"glDrawElementsInstancedANGLE"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glDrawElementsInstancedANGLE
block|}
block|,
block|{
literal|"glGetProgramBinaryOES"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glGetProgramBinaryOES
block|}
block|,
block|{
literal|"glProgramBinaryOES"
block|,
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glProgramBinaryOES
block|}
block|,    }
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|ext
init|=
literal|0
init|;
name|ext
operator|<
name|ArraySize
argument_list|(
name|glExtensions
argument_list|)
condition|;
name|ext
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|procname
argument_list|,
name|glExtensions
index|[
name|ext
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|__eglMustCastToProperFunctionPointerType
operator|)
name|glExtensions
index|[
name|ext
index|]
operator|.
name|address
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
comment|// Non-public functions used by EGL
DECL|function|glBindTexImage
name|bool
name|__stdcall
name|glBindTexImage
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|EVENT
argument_list|(
literal|"(egl::Surface* surface = 0x%0.8p)"
argument_list|,
name|surface
argument_list|)
expr_stmt|;
try|try
block|{
name|gl
operator|::
name|Context
modifier|*
name|context
init|=
name|gl
operator|::
name|getNonLostContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|gl
operator|::
name|Texture2D
modifier|*
name|textureObject
init|=
name|context
operator|->
name|getTexture2D
argument_list|()
decl_stmt|;
if|if
condition|(
name|textureObject
operator|->
name|isImmutable
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|textureObject
condition|)
block|{
name|textureObject
operator|->
name|bindTexImage
argument_list|(
name|surface
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|std
operator|::
name|bad_alloc
modifier|&
parameter_list|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_extern
end_unit
