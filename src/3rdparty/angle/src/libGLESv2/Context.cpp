begin_unit
begin_include
include|#
directive|include
file|"precompiled.h"
end_include
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2014 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Context.cpp: Implements the gl::Context class, managing all GL state and performing
end_comment
begin_comment
comment|// rendering operations. It is the GLES2 specific implementation of EGLContext.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"common/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/formatutils.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Fence.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/FramebufferAttachment.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Query.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/d3d/IndexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/RenderTarget.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/renderer/Renderer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/VertexArray.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Sampler.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/validationES.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/TransformFeedback.h"
end_include
begin_include
include|#
directive|include
file|"libEGL/Surface.h"
end_include
begin_undef
DECL|macro|near
undef|#
directive|undef
name|near
end_undef
begin_undef
DECL|macro|far
undef|#
directive|undef
name|far
end_undef
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|Context
name|Context
operator|::
name|Context
parameter_list|(
name|int
name|clientVersion
parameter_list|,
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
member_init_list|:
name|mRenderer
argument_list|(
name|renderer
argument_list|)
block|{
name|ASSERT
argument_list|(
name|robustAccess
operator|==
literal|false
argument_list|)
expr_stmt|;
comment|// Unimplemented
name|initCaps
argument_list|(
name|clientVersion
argument_list|)
expr_stmt|;
name|mClientVersion
operator|=
name|clientVersion
expr_stmt|;
name|mFenceNVHandleAllocator
operator|.
name|setBaseHandle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shareContext
operator|!=
name|NULL
condition|)
block|{
name|mResourceManager
operator|=
name|shareContext
operator|->
name|mResourceManager
expr_stmt|;
name|mResourceManager
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mResourceManager
operator|=
operator|new
name|ResourceManager
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
block|}
comment|// [OpenGL ES 2.0.24] section 3.7 page 83:
comment|// In the initial state, TEXTURE_2D and TEXTURE_CUBE_MAP have twodimensional
comment|// and cube map texture state vectors respectively associated with them.
comment|// In order that access to these initial textures not be lost, they are treated as texture
comment|// objects all of whose names are 0.
name|mTexture2DZero
operator|.
name|set
argument_list|(
operator|new
name|Texture2D
argument_list|(
name|mRenderer
operator|->
name|createTexture2D
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mTextureCubeMapZero
operator|.
name|set
argument_list|(
operator|new
name|TextureCubeMap
argument_list|(
name|mRenderer
operator|->
name|createTextureCube
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mTexture3DZero
operator|.
name|set
argument_list|(
operator|new
name|Texture3D
argument_list|(
name|mRenderer
operator|->
name|createTexture3D
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mTexture2DArrayZero
operator|.
name|set
argument_list|(
operator|new
name|Texture2DArray
argument_list|(
name|mRenderer
operator|->
name|createTexture2DArray
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bindVertexArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindElementArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindTextureCubeMap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindTexture2D
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindRenderbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindGenericUniformBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_COMBINED_SHADER_UNIFORM_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|bindIndexedUniformBuffer
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bindGenericTransformFeedbackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|bindIndexedTransformFeedbackBuffer
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bindCopyReadBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindCopyWriteBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindPixelPackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindPixelUnpackBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// [OpenGL ES 3.0.2] section 2.14.1 pg 85:
comment|// In the initial state, a default transform feedback object is bound and treated as
comment|// a transform feedback object with a name of zero. That object is bound any time
comment|// BindTransformFeedback is called with id of zero
name|mTransformFeedbackZero
operator|.
name|set
argument_list|(
operator|new
name|TransformFeedback
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bindTransformFeedback
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mInvalidEnum
operator|=
literal|false
expr_stmt|;
name|mInvalidValue
operator|=
literal|false
expr_stmt|;
name|mInvalidOperation
operator|=
literal|false
expr_stmt|;
name|mOutOfMemory
operator|=
literal|false
expr_stmt|;
name|mInvalidFramebufferOperation
operator|=
literal|false
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|false
expr_stmt|;
name|mContextLost
operator|=
literal|false
expr_stmt|;
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
name|mResetStrategy
operator|=
operator|(
name|notifyResets
condition|?
name|GL_LOSE_CONTEXT_ON_RESET_EXT
else|:
name|GL_NO_RESET_NOTIFICATION_EXT
operator|)
expr_stmt|;
name|mRobustAccess
operator|=
name|robustAccess
expr_stmt|;
name|mNumCompressedTextureFormats
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|function|~Context
name|Context
operator|::
name|~
name|Context
parameter_list|()
block|{
name|GLuint
name|currentProgram
init|=
name|mState
operator|.
name|getCurrentProgramId
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentProgram
operator|!=
literal|0
condition|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|currentProgram
argument_list|)
decl_stmt|;
if|if
condition|(
name|programObject
condition|)
block|{
name|programObject
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|currentProgram
operator|=
literal|0
expr_stmt|;
block|}
name|mState
operator|.
name|setCurrentProgram
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mFramebufferMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteFramebuffer
argument_list|(
name|mFramebufferMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mFenceNVMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteFenceNV
argument_list|(
name|mFenceNVMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mQueryMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteQuery
argument_list|(
name|mQueryMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mVertexArrayMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteVertexArray
argument_list|(
name|mVertexArrayMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
name|mTransformFeedbackZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mTransformFeedbackMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteTransformFeedback
argument_list|(
name|mTransformFeedbackMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|type
init|=
literal|0
init|;
name|type
operator|<
name|TEXTURE_TYPE_COUNT
condition|;
name|type
operator|++
control|)
block|{
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mTexture2DZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mTextureCubeMapZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mTexture3DZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mTexture2DArrayZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mResourceManager
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|makeCurrent
name|void
name|Context
operator|::
name|makeCurrent
parameter_list|(
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mHasBeenCurrent
condition|)
block|{
name|mMajorShaderModel
operator|=
name|mRenderer
operator|->
name|getMajorShaderModel
argument_list|()
expr_stmt|;
name|mSupportsVertexTexture
operator|=
name|mRenderer
operator|->
name|getVertexTextureSupport
argument_list|()
expr_stmt|;
name|mNumCompressedTextureFormats
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mExtensions
operator|.
name|textureCompressionDXT1
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|mExtensions
operator|.
name|textureCompressionDXT3
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mExtensions
operator|.
name|textureCompressionDXT5
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|1
expr_stmt|;
block|}
name|initRendererString
argument_list|()
expr_stmt|;
name|initExtensionStrings
argument_list|()
expr_stmt|;
name|mState
operator|.
name|setViewportParams
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setScissorParams
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|surface
operator|->
name|getWidth
argument_list|()
argument_list|,
name|surface
operator|->
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|true
expr_stmt|;
block|}
comment|// Wrap the existing swapchain resources into GL objects and assign them to the '0' names
name|rx
operator|::
name|SwapChain
modifier|*
name|swapchain
init|=
name|surface
operator|->
name|getSwapChain
argument_list|()
decl_stmt|;
name|Colorbuffer
modifier|*
name|colorbufferZero
init|=
operator|new
name|Colorbuffer
argument_list|(
name|mRenderer
argument_list|,
name|swapchain
argument_list|)
decl_stmt|;
name|DepthStencilbuffer
modifier|*
name|depthStencilbufferZero
init|=
operator|new
name|DepthStencilbuffer
argument_list|(
name|mRenderer
argument_list|,
name|swapchain
argument_list|)
decl_stmt|;
name|Framebuffer
modifier|*
name|framebufferZero
init|=
operator|new
name|DefaultFramebuffer
argument_list|(
name|mRenderer
argument_list|,
name|colorbufferZero
argument_list|,
name|depthStencilbufferZero
argument_list|)
decl_stmt|;
name|setFramebufferZero
argument_list|(
name|framebufferZero
argument_list|)
expr_stmt|;
comment|// Store the current client version in the renderer
name|mRenderer
operator|->
name|setCurrentClientVersion
argument_list|(
name|mClientVersion
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: this function should not assume that this context is current!
DECL|function|markContextLost
name|void
name|Context
operator|::
name|markContextLost
parameter_list|()
block|{
if|if
condition|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
condition|)
name|mResetStatus
operator|=
name|GL_UNKNOWN_CONTEXT_RESET_EXT
expr_stmt|;
name|mContextLost
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|isContextLost
name|bool
name|Context
operator|::
name|isContextLost
parameter_list|()
block|{
return|return
name|mContextLost
return|;
block|}
DECL|function|createBuffer
name|GLuint
name|Context
operator|::
name|createBuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createBuffer
argument_list|()
return|;
block|}
DECL|function|createProgram
name|GLuint
name|Context
operator|::
name|createProgram
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createProgram
argument_list|()
return|;
block|}
DECL|function|createShader
name|GLuint
name|Context
operator|::
name|createShader
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|createShader
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|createTexture
name|GLuint
name|Context
operator|::
name|createTexture
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createTexture
argument_list|()
return|;
block|}
DECL|function|createRenderbuffer
name|GLuint
name|Context
operator|::
name|createRenderbuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createRenderbuffer
argument_list|()
return|;
block|}
DECL|function|createFenceSync
name|GLsync
name|Context
operator|::
name|createFenceSync
parameter_list|(
name|GLenum
name|condition
parameter_list|)
block|{
name|GLuint
name|handle
init|=
name|mResourceManager
operator|->
name|createFenceSync
argument_list|()
decl_stmt|;
name|gl
operator|::
name|FenceSync
modifier|*
name|fenceSync
init|=
name|mResourceManager
operator|->
name|getFenceSync
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|fenceSync
argument_list|)
expr_stmt|;
name|fenceSync
operator|->
name|set
argument_list|(
name|condition
argument_list|)
expr_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
name|GLsync
argument_list|>
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|createVertexArray
name|GLuint
name|Context
operator|::
name|createVertexArray
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mVertexArrayHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
comment|// Although the spec states VAO state is not initialized until the object is bound,
comment|// we create it immediately. The resulting behaviour is transparent to the application,
comment|// since it's not currently possible to access the state until the object is bound.
name|VertexArray
modifier|*
name|vertexArray
init|=
operator|new
name|VertexArray
argument_list|(
name|mRenderer
operator|->
name|createVertexArray
argument_list|()
argument_list|,
name|handle
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
name|mVertexArrayMap
index|[
name|handle
index|]
operator|=
name|vertexArray
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|createSampler
name|GLuint
name|Context
operator|::
name|createSampler
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createSampler
argument_list|()
return|;
block|}
DECL|function|createTransformFeedback
name|GLuint
name|Context
operator|::
name|createTransformFeedback
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mTransformFeedbackAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|TransformFeedback
modifier|*
name|transformFeedback
init|=
operator|new
name|TransformFeedback
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|transformFeedback
operator|->
name|addRef
argument_list|()
expr_stmt|;
name|mTransformFeedbackMap
index|[
name|handle
index|]
operator|=
name|transformFeedback
expr_stmt|;
return|return
name|handle
return|;
block|}
comment|// Returns an unused framebuffer name
DECL|function|createFramebuffer
name|GLuint
name|Context
operator|::
name|createFramebuffer
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFramebufferHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFramebufferMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|createFenceNV
name|GLuint
name|Context
operator|::
name|createFenceNV
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFenceNVHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFenceNVMap
index|[
name|handle
index|]
operator|=
operator|new
name|FenceNV
argument_list|(
name|mRenderer
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
comment|// Returns an unused query name
DECL|function|createQuery
name|GLuint
name|Context
operator|::
name|createQuery
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mQueryHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mQueryMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|deleteBuffer
name|void
name|Context
operator|::
name|deleteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteShader
name|void
name|Context
operator|::
name|deleteShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteProgram
name|void
name|Context
operator|::
name|deleteProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTexture
name|void
name|Context
operator|::
name|deleteTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
condition|)
block|{
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteRenderbuffer
name|void
name|Context
operator|::
name|deleteRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteFenceSync
name|void
name|Context
operator|::
name|deleteFenceSync
parameter_list|(
name|GLsync
name|fenceSync
parameter_list|)
block|{
comment|// The spec specifies the underlying Fence object is not deleted until all current
comment|// wait commands finish. However, since the name becomes invalid, we cannot query the fence,
comment|// and since our API is currently designed for being called from a single thread, we can delete
comment|// the fence immediately.
name|mResourceManager
operator|->
name|deleteFenceSync
argument_list|(
cast|reinterpret_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|fenceSync
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteVertexArray
name|void
name|Context
operator|::
name|deleteVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
name|auto
name|vertexArrayObject
init|=
name|mVertexArrayMap
operator|.
name|find
argument_list|(
name|vertexArray
argument_list|)
decl_stmt|;
if|if
condition|(
name|vertexArrayObject
operator|!=
name|mVertexArrayMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachVertexArray
argument_list|(
name|vertexArray
argument_list|)
expr_stmt|;
name|mVertexArrayHandleAllocator
operator|.
name|release
argument_list|(
name|vertexArrayObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|vertexArrayObject
operator|->
name|second
expr_stmt|;
name|mVertexArrayMap
operator|.
name|erase
argument_list|(
name|vertexArrayObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteSampler
name|void
name|Context
operator|::
name|deleteSampler
parameter_list|(
name|GLuint
name|sampler
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getSampler
argument_list|(
name|sampler
argument_list|)
condition|)
block|{
name|detachSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTransformFeedback
name|void
name|Context
operator|::
name|deleteTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|TransformFeedbackMap
operator|::
name|const_iterator
name|iter
init|=
name|mTransformFeedbackMap
operator|.
name|find
argument_list|(
name|transformFeedback
argument_list|)
decl_stmt|;
if|if
condition|(
name|iter
operator|!=
name|mTransformFeedbackMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
name|mTransformFeedbackAllocator
operator|.
name|release
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
name|iter
operator|->
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
name|mTransformFeedbackMap
operator|.
name|erase
argument_list|(
name|iter
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFramebuffer
name|void
name|Context
operator|::
name|deleteFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
name|FramebufferMap
operator|::
name|iterator
name|framebufferObject
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebufferObject
operator|!=
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
name|mFramebufferHandleAllocator
operator|.
name|release
argument_list|(
name|framebufferObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|framebufferObject
operator|->
name|second
expr_stmt|;
name|mFramebufferMap
operator|.
name|erase
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFenceNV
name|void
name|Context
operator|::
name|deleteFenceNV
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|FenceNVMap
operator|::
name|iterator
name|fenceObject
init|=
name|mFenceNVMap
operator|.
name|find
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|!=
name|mFenceNVMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mFenceNVHandleAllocator
operator|.
name|release
argument_list|(
name|fenceObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|fenceObject
operator|->
name|second
expr_stmt|;
name|mFenceNVMap
operator|.
name|erase
argument_list|(
name|fenceObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteQuery
name|void
name|Context
operator|::
name|deleteQuery
parameter_list|(
name|GLuint
name|query
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|queryObject
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|!=
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mQueryHandleAllocator
operator|.
name|release
argument_list|(
name|queryObject
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryObject
operator|->
name|second
condition|)
block|{
name|queryObject
operator|->
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mQueryMap
operator|.
name|erase
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getBuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getShader
name|Shader
modifier|*
name|Context
operator|::
name|getShader
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getShader
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getProgram
name|Program
modifier|*
name|Context
operator|::
name|getProgram
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTexture
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|Context
operator|::
name|getRenderbuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getFenceSync
name|FenceSync
modifier|*
name|Context
operator|::
name|getFenceSync
parameter_list|(
name|GLsync
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getFenceSync
argument_list|(
cast|reinterpret_cast
argument_list|<
name|GLuint
argument_list|>
argument_list|(
name|handle
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getVertexArray
name|VertexArray
modifier|*
name|Context
operator|::
name|getVertexArray
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
name|auto
name|vertexArray
init|=
name|mVertexArrayMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|vertexArray
operator|==
name|mVertexArrayMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|vertexArray
operator|->
name|second
return|;
block|}
block|}
DECL|function|getSampler
name|Sampler
modifier|*
name|Context
operator|::
name|getSampler
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|getSampler
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTransformFeedback
name|TransformFeedback
modifier|*
name|Context
operator|::
name|getTransformFeedback
parameter_list|(
name|GLuint
name|handle
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
block|{
return|return
name|mTransformFeedbackZero
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
name|TransformFeedbackMap
operator|::
name|const_iterator
name|iter
init|=
name|mTransformFeedbackMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
return|return
operator|(
name|iter
operator|!=
name|mTransformFeedbackMap
operator|.
name|end
argument_list|()
operator|)
condition|?
name|iter
operator|->
name|second
else|:
name|NULL
return|;
block|}
block|}
DECL|function|isSampler
name|bool
name|Context
operator|::
name|isSampler
parameter_list|(
name|GLuint
name|samplerName
parameter_list|)
specifier|const
block|{
return|return
name|mResourceManager
operator|->
name|isSampler
argument_list|(
name|samplerName
argument_list|)
return|;
block|}
DECL|function|bindArrayBuffer
name|void
name|Context
operator|::
name|bindArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setArrayBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindElementArrayBuffer
name|void
name|Context
operator|::
name|bindElementArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|getVertexArray
argument_list|()
operator|->
name|setElementArrayBuffer
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexture2D
name|void
name|Context
operator|::
name|bindTexture2D
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_2D
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerTexture
argument_list|(
name|TEXTURE_2D
argument_list|,
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTextureCubeMap
name|void
name|Context
operator|::
name|bindTextureCubeMap
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_CUBE
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerTexture
argument_list|(
name|TEXTURE_CUBE
argument_list|,
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexture3D
name|void
name|Context
operator|::
name|bindTexture3D
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_3D
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerTexture
argument_list|(
name|TEXTURE_3D
argument_list|,
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexture2DArray
name|void
name|Context
operator|::
name|bindTexture2DArray
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_2D_ARRAY
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerTexture
argument_list|(
name|TEXTURE_2D_ARRAY
argument_list|,
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindReadFramebuffer
name|void
name|Context
operator|::
name|bindReadFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|(
name|mRenderer
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|setReadFramebufferBinding
argument_list|(
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindDrawFramebuffer
name|void
name|Context
operator|::
name|bindDrawFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|(
name|mRenderer
argument_list|,
name|framebuffer
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|setDrawFramebufferBinding
argument_list|(
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindRenderbuffer
name|void
name|Context
operator|::
name|bindRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkRenderbufferAllocation
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setRenderbufferBinding
argument_list|(
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindVertexArray
name|void
name|Context
operator|::
name|bindVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getVertexArray
argument_list|(
name|vertexArray
argument_list|)
condition|)
block|{
name|VertexArray
modifier|*
name|vertexArrayObject
init|=
operator|new
name|VertexArray
argument_list|(
name|mRenderer
operator|->
name|createVertexArray
argument_list|()
argument_list|,
name|vertexArray
argument_list|,
name|MAX_VERTEX_ATTRIBS
argument_list|)
decl_stmt|;
name|mVertexArrayMap
index|[
name|vertexArray
index|]
operator|=
name|vertexArrayObject
expr_stmt|;
block|}
name|mState
operator|.
name|setVertexArrayBinding
argument_list|(
name|getVertexArray
argument_list|(
name|vertexArray
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindSampler
name|void
name|Context
operator|::
name|bindSampler
parameter_list|(
name|GLuint
name|textureUnit
parameter_list|,
name|GLuint
name|sampler
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|textureUnit
operator|<
name|IMPLEMENTATION_MAX_COMBINED_TEXTURE_IMAGE_UNITS
argument_list|)
expr_stmt|;
comment|// TODO: Update for backend-determined array size
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setSamplerBinding
argument_list|(
name|textureUnit
argument_list|,
name|getSampler
argument_list|(
name|sampler
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindGenericUniformBuffer
name|void
name|Context
operator|::
name|bindGenericUniformBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setGenericUniformBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindIndexedUniformBuffer
name|void
name|Context
operator|::
name|bindIndexedUniformBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setIndexedUniformBufferBinding
argument_list|(
name|index
argument_list|,
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|bindGenericTransformFeedbackBuffer
name|void
name|Context
operator|::
name|bindGenericTransformFeedbackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setGenericTransformFeedbackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindIndexedTransformFeedbackBuffer
name|void
name|Context
operator|::
name|bindIndexedTransformFeedbackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLintptr
name|offset
parameter_list|,
name|GLsizeiptr
name|size
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setIndexedTransformFeedbackBufferBinding
argument_list|(
name|index
argument_list|,
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
DECL|function|bindCopyReadBuffer
name|void
name|Context
operator|::
name|bindCopyReadBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setCopyReadBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindCopyWriteBuffer
name|void
name|Context
operator|::
name|bindCopyWriteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setCopyWriteBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindPixelPackBuffer
name|void
name|Context
operator|::
name|bindPixelPackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setPixelPackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindPixelUnpackBuffer
name|void
name|Context
operator|::
name|bindPixelUnpackBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|setPixelUnpackBufferBinding
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|useProgram
name|void
name|Context
operator|::
name|useProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|GLuint
name|priorProgramId
init|=
name|mState
operator|.
name|getCurrentProgramId
argument_list|()
decl_stmt|;
name|Program
modifier|*
name|priorProgram
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|priorProgramId
argument_list|)
decl_stmt|;
if|if
condition|(
name|priorProgramId
operator|!=
name|program
condition|)
block|{
name|mState
operator|.
name|setCurrentProgram
argument_list|(
name|program
argument_list|,
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorProgram
condition|)
block|{
name|priorProgram
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|linkProgram
name|void
name|Context
operator|::
name|linkProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|linked
init|=
name|programObject
operator|->
name|link
argument_list|()
decl_stmt|;
comment|// if the current program was relinked successfully we
comment|// need to install the new executables
if|if
condition|(
name|linked
operator|&&
name|program
operator|==
name|mState
operator|.
name|getCurrentProgramId
argument_list|()
condition|)
block|{
name|mState
operator|.
name|setCurrentProgramBinary
argument_list|(
name|programObject
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setProgramBinary
name|void
name|Context
operator|::
name|setProgramBinary
parameter_list|(
name|GLuint
name|program
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLint
name|length
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|loaded
init|=
name|programObject
operator|->
name|setProgramBinary
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
comment|// if the current program was reloaded successfully we
comment|// need to install the new executables
if|if
condition|(
name|loaded
operator|&&
name|program
operator|==
name|mState
operator|.
name|getCurrentProgramId
argument_list|()
condition|)
block|{
name|mState
operator|.
name|setCurrentProgramBinary
argument_list|(
name|programObject
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|bindTransformFeedback
name|void
name|Context
operator|::
name|bindTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|mState
operator|.
name|setTransformFeedbackBinding
argument_list|(
name|getTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|beginQuery
name|void
name|Context
operator|::
name|beginQuery
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|query
parameter_list|)
block|{
name|Query
modifier|*
name|queryObject
init|=
name|getQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
comment|// set query as active for specified target
name|mState
operator|.
name|setActiveQuery
argument_list|(
name|target
argument_list|,
name|queryObject
argument_list|)
expr_stmt|;
comment|// begin query
name|queryObject
operator|->
name|begin
argument_list|()
expr_stmt|;
block|}
DECL|function|endQuery
name|void
name|Context
operator|::
name|endQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|Query
modifier|*
name|queryObject
init|=
name|mState
operator|.
name|getActiveQuery
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
name|queryObject
operator|->
name|end
argument_list|()
expr_stmt|;
name|mState
operator|.
name|setActiveQuery
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
DECL|function|setFramebufferZero
name|void
name|Context
operator|::
name|setFramebufferZero
parameter_list|(
name|Framebuffer
modifier|*
name|buffer
parameter_list|)
block|{
comment|// First, check to see if the old default framebuffer
comment|// was set for draw or read framebuffer, and change
comment|// the bindings to point to the new one before deleting it.
if|if
condition|(
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mState
operator|.
name|setDrawFramebufferBinding
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mState
operator|.
name|setReadFramebufferBinding
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
operator|delete
name|mFramebufferMap
index|[
literal|0
index|]
expr_stmt|;
name|mFramebufferMap
index|[
literal|0
index|]
operator|=
name|buffer
expr_stmt|;
block|}
DECL|function|setRenderbufferStorage
name|void
name|Context
operator|::
name|setRenderbufferStorage
parameter_list|(
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|internalformat
parameter_list|,
name|GLsizei
name|samples
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|getTextureCaps
argument_list|()
operator|.
name|get
argument_list|(
name|internalformat
argument_list|)
operator|.
name|renderable
argument_list|)
expr_stmt|;
name|RenderbufferStorage
modifier|*
name|renderbuffer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GetDepthBits
argument_list|(
name|internalformat
argument_list|)
operator|>
literal|0
operator|&&
name|GetStencilBits
argument_list|(
name|internalformat
argument_list|)
operator|>
literal|0
condition|)
block|{
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|DepthStencilbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|samples
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GetDepthBits
argument_list|(
name|internalformat
argument_list|)
operator|>
literal|0
condition|)
block|{
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|Depthbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|samples
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GetStencilBits
argument_list|(
name|internalformat
argument_list|)
operator|>
literal|0
condition|)
block|{
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|Stencilbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|samples
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renderbuffer
operator|=
operator|new
name|gl
operator|::
name|Colorbuffer
argument_list|(
name|mRenderer
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|internalformat
argument_list|,
name|samples
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|getCurrentRenderbuffer
argument_list|()
operator|->
name|setStorage
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getFramebuffer
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
specifier|const
block|{
name|FramebufferMap
operator|::
name|const_iterator
name|framebuffer
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|==
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|framebuffer
operator|->
name|second
return|;
block|}
block|}
DECL|function|getFenceNV
name|FenceNV
modifier|*
name|Context
operator|::
name|getFenceNV
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
block|{
name|FenceNVMap
operator|::
name|iterator
name|fence
init|=
name|mFenceNVMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|mFenceNVMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|fence
operator|->
name|second
return|;
block|}
block|}
DECL|function|getQuery
name|Query
modifier|*
name|Context
operator|::
name|getQuery
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|,
name|bool
name|create
parameter_list|,
name|GLenum
name|type
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|query
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|==
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|query
operator|->
name|second
operator|&&
name|create
condition|)
block|{
name|query
operator|->
name|second
operator|=
operator|new
name|Query
argument_list|(
name|mRenderer
argument_list|,
name|type
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|query
operator|->
name|second
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
return|return
name|query
operator|->
name|second
return|;
block|}
block|}
DECL|function|getTargetTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTargetTexture
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|ValidTextureTarget
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TEXTURE_2D
case|:
return|return
name|getTexture2D
argument_list|()
return|;
case|case
name|GL_TEXTURE_CUBE_MAP
case|:
return|return
name|getTextureCubeMap
argument_list|()
return|;
case|case
name|GL_TEXTURE_3D
case|:
return|return
name|getTexture3D
argument_list|()
return|;
case|case
name|GL_TEXTURE_2D_ARRAY
case|:
return|return
name|getTexture2DArray
argument_list|()
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
DECL|function|getTexture2D
name|Texture2D
modifier|*
name|Context
operator|::
name|getTexture2D
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|Texture2D
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|getActiveSampler
argument_list|()
argument_list|,
name|TEXTURE_2D
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getTextureCubeMap
name|TextureCubeMap
modifier|*
name|Context
operator|::
name|getTextureCubeMap
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|TextureCubeMap
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|getActiveSampler
argument_list|()
argument_list|,
name|TEXTURE_CUBE
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getTexture3D
name|Texture3D
modifier|*
name|Context
operator|::
name|getTexture3D
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|Texture3D
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|getActiveSampler
argument_list|()
argument_list|,
name|TEXTURE_3D
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getTexture2DArray
name|Texture2DArray
modifier|*
name|Context
operator|::
name|getTexture2DArray
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|Texture2DArray
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|getActiveSampler
argument_list|()
argument_list|,
name|TEXTURE_2D_ARRAY
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getSamplerTexture
name|Texture
modifier|*
name|Context
operator|::
name|getSamplerTexture
parameter_list|(
name|unsigned
name|int
name|sampler
parameter_list|,
name|TextureType
name|type
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mState
operator|.
name|getSamplerTextureId
argument_list|(
name|sampler
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
case|case
name|TEXTURE_2D
case|:
return|return
name|mTexture2DZero
operator|.
name|get
argument_list|()
return|;
case|case
name|TEXTURE_CUBE
case|:
return|return
name|mTextureCubeMapZero
operator|.
name|get
argument_list|()
return|;
case|case
name|TEXTURE_3D
case|:
return|return
name|mTexture3DZero
operator|.
name|get
argument_list|()
return|;
case|case
name|TEXTURE_2D_ARRAY
case|:
return|return
name|mTexture2DArrayZero
operator|.
name|get
argument_list|()
return|;
block|}
block|}
else|else
block|{
return|return
name|mState
operator|.
name|getSamplerTexture
argument_list|(
name|sampler
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
DECL|function|getBooleanv
name|void
name|Context
operator|::
name|getBooleanv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLboolean
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SHADER_COMPILER
case|:
operator|*
name|params
operator|=
name|GL_TRUE
expr_stmt|;
break|break;
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
operator|*
name|params
operator|=
name|mRobustAccess
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getBooleanv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getFloatv
name|void
name|Context
operator|::
name|getFloatv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|minAliasedLineWidth
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxAliasedLineWidth
expr_stmt|;
break|break;
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|minAliasedPointSize
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxAliasedPointSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
name|ASSERT
argument_list|(
name|mExtensions
operator|.
name|textureFilterAnisotropic
argument_list|)
expr_stmt|;
operator|*
name|params
operator|=
name|mExtensions
operator|.
name|maxTextureAnisotropy
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getFloatv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getIntegerv
name|void
name|Context
operator|::
name|getIntegerv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
operator|*
name|params
operator|=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_VECTORS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVaryingVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVaryingVectors
argument_list|()
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxFragmentUniformVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxFragmentUniformVectors
argument_list|()
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxRenderbufferSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxColorAttachments
expr_stmt|;
break|break;
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxDrawBuffers
expr_stmt|;
break|break;
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
operator|*
name|params
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
comment|/* no shader binary formats are supported */
break|break;
comment|//case GL_FRAMEBUFFER_BINDING:                    // now equivalent to GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_SUBPIXEL_BITS
case|:
operator|*
name|params
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|max2DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxCubeMapTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_3D_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|max3DTextureSize
expr_stmt|;
break|break;
case|case
name|GL_MAX_ARRAY_TEXTURE_LAYERS
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxArrayTextureLayers
expr_stmt|;
break|break;
case|case
name|GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|getUniformBufferOffsetAlignment
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_UNIFORM_BUFFER_BINDINGS
case|:
operator|*
name|params
operator|=
name|getMaximumCombinedUniformBufferBindings
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxVertexShaderUniformBuffers
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxFragmentShaderUniformBuffers
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_UNIFORM_BLOCKS
case|:
operator|*
name|params
operator|=
name|getMaximumCombinedUniformBufferBindings
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAJOR_VERSION
case|:
operator|*
name|params
operator|=
name|mClientVersion
expr_stmt|;
break|break;
case|case
name|GL_MINOR_VERSION
case|:
operator|*
name|params
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_MAX_ELEMENTS_INDICES
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxRecommendedElementsIndices
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_ELEMENTS_VERTICES
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxRecommendedElementsVertices
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxTransformFeedbackInterleavedComponents
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxTransformFeedbackBuffers
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
case|:
operator|*
name|params
operator|=
name|mRenderer
operator|->
name|getMaxTransformFeedbackSeparateComponents
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mNumCompressedTextureFormats
expr_stmt|;
break|break;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|getMaxSupportedSamples
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
block|{
name|GLenum
name|internalFormat
decl_stmt|,
name|format
decl_stmt|,
name|type
decl_stmt|;
name|getCurrentReadFormatType
argument_list|(
operator|&
name|internalFormat
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pname
operator|==
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
condition|)
operator|*
name|params
operator|=
name|format
expr_stmt|;
else|else
operator|*
name|params
operator|=
name|type
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
name|params
index|[
literal|0
index|]
operator|=
name|mCaps
operator|.
name|maxViewportWidth
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mCaps
operator|.
name|maxViewportHeight
expr_stmt|;
block|}
break|break;
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
if|if
condition|(
name|mExtensions
operator|.
name|textureCompressionDXT1
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
expr_stmt|;
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
expr_stmt|;
block|}
if|if
condition|(
name|mExtensions
operator|.
name|textureCompressionDXT3
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
expr_stmt|;
block|}
if|if
condition|(
name|mExtensions
operator|.
name|textureCompressionDXT5
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
operator|*
name|params
operator|=
name|mResetStrategy
expr_stmt|;
break|break;
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
operator|*
name|params
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
operator|*
name|params
operator|=
name|GL_PROGRAM_BINARY_ANGLE
expr_stmt|;
break|break;
case|case
name|GL_NUM_EXTENSIONS
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|mExtensionStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mState
operator|.
name|getIntegerv
argument_list|(
name|pname
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getInteger64v
name|void
name|Context
operator|::
name|getInteger64v
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint64
modifier|*
name|params
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_ELEMENT_INDEX
case|:
operator|*
name|params
operator|=
name|mCaps
operator|.
name|maxElementIndex
expr_stmt|;
break|break;
case|case
name|GL_MAX_UNIFORM_BLOCK_SIZE
case|:
operator|*
name|params
operator|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|mRenderer
operator|->
name|getMaxUniformBufferSize
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
case|:
block|{
name|GLint64
name|uniformBufferComponents
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|mRenderer
operator|->
name|getMaxVertexShaderUniformBuffers
argument_list|()
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|mRenderer
operator|->
name|getMaxUniformBufferSize
argument_list|()
operator|/
literal|4
argument_list|)
decl_stmt|;
name|GLint64
name|defaultBufferComponents
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
operator|*
literal|4
argument_list|)
decl_stmt|;
operator|*
name|params
operator|=
name|uniformBufferComponents
operator|+
name|defaultBufferComponents
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
case|:
block|{
name|GLint64
name|uniformBufferComponents
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|mRenderer
operator|->
name|getMaxFragmentShaderUniformBuffers
argument_list|()
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|mRenderer
operator|->
name|getMaxUniformBufferSize
argument_list|()
operator|/
literal|4
argument_list|)
decl_stmt|;
name|GLint64
name|defaultBufferComponents
init|=
cast|static_cast
argument_list|<
name|GLint64
argument_list|>
argument_list|(
name|mRenderer
operator|->
name|getMaxVertexUniformVectors
argument_list|()
operator|*
literal|4
argument_list|)
decl_stmt|;
operator|*
name|params
operator|=
name|uniformBufferComponents
operator|+
name|defaultBufferComponents
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_SERVER_WAIT_TIMEOUT
case|:
comment|// We do not wait for server fence objects internally, so report a max timeout of zero.
operator|*
name|params
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getIndexedIntegerv
name|bool
name|Context
operator|::
name|getIndexedIntegerv
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint
modifier|*
name|data
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
comment|// Indexed integer queries all refer to current state, so this function is a
comment|// mere passthrough.
return|return
name|mState
operator|.
name|getIndexedIntegerv
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
return|;
block|}
DECL|function|getIndexedInteger64v
name|bool
name|Context
operator|::
name|getIndexedInteger64v
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|index
parameter_list|,
name|GLint64
modifier|*
name|data
parameter_list|)
block|{
comment|// Queries about context capabilities and maximums are answered by Context.
comment|// Queries about current GL state values are answered by State.
comment|// Indexed integer queries all refer to current state, so this function is a
comment|// mere passthrough.
return|return
name|mState
operator|.
name|getIndexedInteger64v
argument_list|(
name|target
argument_list|,
name|index
argument_list|,
name|data
argument_list|)
return|;
block|}
DECL|function|getQueryParameterInfo
name|bool
name|Context
operator|::
name|getQueryParameterInfo
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|pname
operator|>=
name|GL_DRAW_BUFFER0_EXT
operator|&&
name|pname
operator|<=
name|GL_DRAW_BUFFER15_EXT
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Please note: the query type returned for DEPTH_CLEAR_VALUE in this implementation
comment|// is FLOAT rather than INT, as would be suggested by the GL ES 2.0 spec. This is due
comment|// to the fact that it is stored internally as a float, and so would require conversion
comment|// if returned from Context::getIntegerv. Since this conversion is already implemented
comment|// in the case that one calls glGetIntegerv to retrieve a float-typed state variable, we
comment|// place DEPTH_CLEAR_VALUE with the floats. This should make no difference to the calling
comment|// application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
name|mNumCompressedTextureFormats
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_VARYING_VECTORS
case|:
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
case|case
name|GL_MAX_COLOR_ATTACHMENTS_EXT
case|:
case|case
name|GL_MAX_DRAW_BUFFERS_EXT
case|:
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
comment|//case GL_FRAMEBUFFER_BINDING: // equivalent to DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|:
case|case
name|GL_READ_FRAMEBUFFER_BINDING_ANGLE
case|:
case|case
name|GL_RENDERBUFFER_BINDING
case|:
case|case
name|GL_CURRENT_PROGRAM
case|:
case|case
name|GL_PACK_ALIGNMENT
case|:
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
case|case
name|GL_UNPACK_ALIGNMENT
case|:
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
case|case
name|GL_DEPTH_BITS
case|:
case|case
name|GL_STENCIL_BITS
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CULL_FACE_MODE
case|:
case|case
name|GL_FRONT_FACE
case|:
case|case
name|GL_ACTIVE_TEXTURE
case|:
case|case
name|GL_STENCIL_FUNC
case|:
case|case
name|GL_STENCIL_VALUE_MASK
case|:
case|case
name|GL_STENCIL_REF
case|:
case|case
name|GL_STENCIL_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
case|case
name|GL_STENCIL_BACK_FUNC
case|:
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
case|case
name|GL_STENCIL_BACK_REF
case|:
case|case
name|GL_STENCIL_BACK_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
case|case
name|GL_DEPTH_FUNC
case|:
case|case
name|GL_BLEND_SRC_RGB
case|:
case|case
name|GL_BLEND_SRC_ALPHA
case|:
case|case
name|GL_BLEND_DST_RGB
case|:
case|case
name|GL_BLEND_DST_ALPHA
case|:
case|case
name|GL_BLEND_EQUATION_RGB
case|:
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
case|case
name|GL_STENCIL_WRITEMASK
case|:
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
case|case
name|GL_SUBPIXEL_BITS
case|:
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
block|{
if|if
condition|(
name|mExtensions
operator|.
name|framebufferMultisample
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|GL_PIXEL_PACK_BUFFER_BINDING
case|:
case|case
name|GL_PIXEL_UNPACK_BUFFER_BINDING
case|:
block|{
if|if
condition|(
name|mExtensions
operator|.
name|pixelBufferObject
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_VIEWPORT
case|:
case|case
name|GL_SCISSOR_BOX
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_SHADER_COMPILER
case|:
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
case|case
name|GL_DEPTH_WRITEMASK
case|:
case|case
name|GL_CULL_FACE
case|:
comment|// CULL_FACE through DITHER are natural to IsEnabled,
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
comment|// but can be retrieved through the Get{Type}v queries.
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
comment|// For this purpose, they are treated here as bool-natural
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_COLOR_WRITEMASK
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
case|case
name|GL_LINE_WIDTH
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
case|case
name|GL_DEPTH_RANGE
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
case|case
name|GL_BLEND_COLOR
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|mExtensions
operator|.
name|maxTextureAnisotropy
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|mClientVersion
operator|<
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check for ES3.0+ parameter names
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_UNIFORM_BUFFER_BINDINGS
case|:
case|case
name|GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
case|:
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BINDING
case|:
case|case
name|GL_COPY_READ_BUFFER_BINDING
case|:
case|case
name|GL_COPY_WRITE_BUFFER_BINDING
case|:
case|case
name|GL_TEXTURE_BINDING_3D
case|:
case|case
name|GL_TEXTURE_BINDING_2D_ARRAY
case|:
case|case
name|GL_MAX_3D_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_ARRAY_TEXTURE_LAYERS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_COMBINED_UNIFORM_BLOCKS
case|:
case|case
name|GL_MAX_VARYING_COMPONENTS
case|:
case|case
name|GL_VERTEX_ARRAY_BINDING
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
case|:
case|case
name|GL_NUM_EXTENSIONS
case|:
case|case
name|GL_MAJOR_VERSION
case|:
case|case
name|GL_MINOR_VERSION
case|:
case|case
name|GL_MAX_ELEMENTS_INDICES
case|:
case|case
name|GL_MAX_ELEMENTS_VERTICES
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
case|:
case|case
name|GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_MAX_ELEMENT_INDEX
case|:
case|case
name|GL_MAX_UNIFORM_BLOCK_SIZE
case|:
case|case
name|GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
case|:
case|case
name|GL_MAX_SERVER_WAIT_TIMEOUT
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT_64_ANGLEX
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_ACTIVE
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_PAUSED
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|getIndexedQueryParameterInfo
name|bool
name|Context
operator|::
name|getIndexedQueryParameterInfo
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
if|if
condition|(
name|mClientVersion
operator|<
literal|3
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
case|:
case|case
name|GL_UNIFORM_BUFFER_BINDING
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|true
return|;
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_START
case|:
case|case
name|GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
case|:
case|case
name|GL_UNIFORM_BUFFER_START
case|:
case|case
name|GL_UNIFORM_BUFFER_SIZE
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT_64_ANGLEX
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Applies the render target surface, depth stencil surface, viewport rectangle and
comment|// scissor rectangle to the renderer
DECL|function|applyRenderTarget
name|bool
name|Context
operator|::
name|applyRenderTarget
parameter_list|(
name|GLenum
name|drawMode
parameter_list|,
name|bool
name|ignoreViewport
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebufferObject
operator|&&
name|framebufferObject
operator|->
name|completeness
argument_list|()
operator|==
name|GL_FRAMEBUFFER_COMPLETE
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|applyRenderTarget
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
name|float
name|nearZ
decl_stmt|,
name|farZ
decl_stmt|;
name|mState
operator|.
name|getDepthRange
argument_list|(
operator|&
name|nearZ
argument_list|,
operator|&
name|farZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|setViewport
argument_list|(
name|mState
operator|.
name|getViewport
argument_list|()
argument_list|,
name|nearZ
argument_list|,
name|farZ
argument_list|,
name|drawMode
argument_list|,
name|mState
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|frontFace
argument_list|,
name|ignoreViewport
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|mRenderer
operator|->
name|setScissorRectangle
argument_list|(
name|mState
operator|.
name|getScissor
argument_list|()
argument_list|,
name|mState
operator|.
name|isScissorTestEnabled
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Applies the fixed-function state (culling, depth test, alpha blending, stenciling, etc) to the Direct3D 9 device
DECL|function|applyState
name|void
name|Context
operator|::
name|applyState
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|int
name|samples
init|=
name|framebufferObject
operator|->
name|getSamples
argument_list|()
decl_stmt|;
name|RasterizerState
name|rasterizer
init|=
name|mState
operator|.
name|getRasterizerState
argument_list|()
decl_stmt|;
name|rasterizer
operator|.
name|pointDrawMode
operator|=
operator|(
name|drawMode
operator|==
name|GL_POINTS
operator|)
expr_stmt|;
name|rasterizer
operator|.
name|multiSample
operator|=
operator|(
name|samples
operator|!=
literal|0
operator|)
expr_stmt|;
name|mRenderer
operator|->
name|setRasterizerState
argument_list|(
name|rasterizer
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|isSampleCoverageEnabled
argument_list|()
condition|)
block|{
name|GLclampf
name|coverageValue
decl_stmt|;
name|bool
name|coverageInvert
init|=
literal|false
decl_stmt|;
name|mState
operator|.
name|getSampleCoverageParams
argument_list|(
operator|&
name|coverageValue
argument_list|,
operator|&
name|coverageInvert
argument_list|)
expr_stmt|;
if|if
condition|(
name|coverageValue
operator|!=
literal|0
condition|)
block|{
name|float
name|threshold
init|=
literal|0.5f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samples
condition|;
operator|++
name|i
control|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|coverageValue
operator|>=
name|threshold
condition|)
block|{
name|threshold
operator|+=
literal|1.0f
expr_stmt|;
name|mask
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|coverageInvert
condition|)
block|{
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|mask
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
name|mRenderer
operator|->
name|setBlendState
argument_list|(
name|framebufferObject
argument_list|,
name|mState
operator|.
name|getBlendState
argument_list|()
argument_list|,
name|mState
operator|.
name|getBlendColor
argument_list|()
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|setDepthStencilState
argument_list|(
name|mState
operator|.
name|getDepthStencilState
argument_list|()
argument_list|,
name|mState
operator|.
name|getStencilRef
argument_list|()
argument_list|,
name|mState
operator|.
name|getStencilBackRef
argument_list|()
argument_list|,
name|rasterizer
operator|.
name|frontFace
operator|==
name|GL_CCW
argument_list|)
expr_stmt|;
block|}
comment|// Applies the shaders and shader constants to the Direct3D 9 device
DECL|function|applyShaders
name|void
name|Context
operator|::
name|applyShaders
parameter_list|(
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
name|bool
name|transformFeedbackActive
parameter_list|)
block|{
specifier|const
name|VertexAttribute
modifier|*
name|vertexAttributes
init|=
name|mState
operator|.
name|getVertexArray
argument_list|()
operator|->
name|getVertexAttributes
argument_list|()
decl_stmt|;
name|VertexFormat
name|inputLayout
index|[
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|VertexFormat
operator|::
name|GetInputLayout
argument_list|(
name|inputLayout
argument_list|,
name|programBinary
argument_list|,
name|vertexAttributes
argument_list|,
name|mState
operator|.
name|getVertexAttribCurrentValues
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|Framebuffer
modifier|*
name|fbo
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|mRenderer
operator|->
name|applyShaders
argument_list|(
name|programBinary
argument_list|,
name|inputLayout
argument_list|,
name|fbo
argument_list|,
name|mState
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|rasterizerDiscard
argument_list|,
name|transformFeedbackActive
argument_list|)
expr_stmt|;
name|programBinary
operator|->
name|applyUniforms
argument_list|()
expr_stmt|;
block|}
DECL|function|getCurrentTexturesAndSamplerStates
name|size_t
name|Context
operator|::
name|getCurrentTexturesAndSamplerStates
parameter_list|(
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
name|SamplerType
name|type
parameter_list|,
name|Texture
modifier|*
modifier|*
name|outTextures
parameter_list|,
name|TextureType
modifier|*
name|outTextureTypes
parameter_list|,
name|SamplerState
modifier|*
name|outSamplers
parameter_list|)
block|{
name|size_t
name|samplerRange
init|=
name|programBinary
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|samplerRange
condition|;
name|i
operator|++
control|)
block|{
name|outTextureTypes
index|[
name|i
index|]
operator|=
name|programBinary
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|GLint
name|textureUnit
init|=
name|programBinary
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// OpenGL texture image unit index
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|outTextures
index|[
name|i
index|]
operator|=
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|outTextureTypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|outTextures
index|[
name|i
index|]
operator|->
name|getSamplerStateWithNativeOffset
argument_list|(
operator|&
name|outSamplers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|mState
operator|.
name|getSampler
argument_list|(
name|textureUnit
argument_list|)
decl_stmt|;
if|if
condition|(
name|samplerObject
condition|)
block|{
name|samplerObject
operator|->
name|getState
argument_list|(
operator|&
name|outSamplers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|outTextures
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|samplerRange
return|;
block|}
DECL|function|generateSwizzles
name|void
name|Context
operator|::
name|generateSwizzles
parameter_list|(
name|Texture
modifier|*
name|textures
index|[]
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|textures
index|[
name|i
index|]
operator|&&
name|textures
index|[
name|i
index|]
operator|->
name|getSamplerState
argument_list|()
operator|.
name|swizzleRequired
argument_list|()
condition|)
block|{
name|mRenderer
operator|->
name|generateSwizzle
argument_list|(
name|textures
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// For each Direct3D sampler of either the pixel or vertex stage,
comment|// looks up the corresponding OpenGL texture image unit and texture type,
comment|// and sets the texture and its addressing/filtering state (or NULL when inactive).
DECL|function|applyTextures
name|void
name|Context
operator|::
name|applyTextures
parameter_list|(
name|SamplerType
name|shaderType
parameter_list|,
name|Texture
modifier|*
name|textures
index|[]
parameter_list|,
name|TextureType
modifier|*
name|textureTypes
parameter_list|,
name|SamplerState
modifier|*
name|samplers
parameter_list|,
name|size_t
name|textureCount
parameter_list|,
specifier|const
name|FramebufferTextureSerialArray
modifier|&
name|framebufferSerials
parameter_list|,
name|size_t
name|framebufferSerialCount
parameter_list|)
block|{
comment|// Range of Direct3D samplers of given sampler type
name|size_t
name|samplerCount
init|=
operator|(
name|shaderType
operator|==
name|SAMPLER_PIXEL
operator|)
condition|?
name|MAX_TEXTURE_IMAGE_UNITS
else|:
name|mRenderer
operator|->
name|getMaxVertexTextureImageUnits
argument_list|()
decl_stmt|;
for|for
control|(
name|size_t
name|samplerIndex
init|=
literal|0
init|;
name|samplerIndex
operator|<
name|textureCount
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|Texture
modifier|*
name|texture
init|=
name|textures
index|[
name|samplerIndex
index|]
decl_stmt|;
specifier|const
name|SamplerState
modifier|&
name|sampler
init|=
name|samplers
index|[
name|samplerIndex
index|]
decl_stmt|;
name|TextureType
name|textureType
init|=
name|textureTypes
index|[
name|samplerIndex
index|]
decl_stmt|;
if|if
condition|(
name|texture
condition|)
block|{
comment|// TODO: std::binary_search may become unavailable using older versions of GCC
if|if
condition|(
name|texture
operator|->
name|isSamplerComplete
argument_list|(
name|sampler
argument_list|)
operator|&&
operator|!
name|std
operator|::
name|binary_search
argument_list|(
name|framebufferSerials
operator|.
name|begin
argument_list|()
argument_list|,
name|framebufferSerials
operator|.
name|begin
argument_list|()
operator|+
name|framebufferSerialCount
argument_list|,
name|texture
operator|->
name|getTextureSerial
argument_list|()
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|setSamplerState
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|sampler
argument_list|)
expr_stmt|;
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|texture
argument_list|)
expr_stmt|;
name|texture
operator|->
name|resetDirty
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Texture
modifier|*
name|incompleteTexture
init|=
name|getIncompleteTexture
argument_list|(
name|textureType
argument_list|)
decl_stmt|;
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|incompleteTexture
argument_list|)
expr_stmt|;
name|incompleteTexture
operator|->
name|resetDirty
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|size_t
name|samplerIndex
init|=
name|textureCount
init|;
name|samplerIndex
operator|<
name|samplerCount
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|mRenderer
operator|->
name|setTexture
argument_list|(
name|shaderType
argument_list|,
name|samplerIndex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|applyUniformBuffers
name|bool
name|Context
operator|::
name|applyUniformBuffers
parameter_list|()
block|{
name|Program
modifier|*
name|programObject
init|=
name|getProgram
argument_list|(
name|mState
operator|.
name|getCurrentProgramId
argument_list|()
argument_list|)
decl_stmt|;
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|programObject
operator|->
name|getProgramBinary
argument_list|()
decl_stmt|;
name|std
operator|::
name|vector
argument_list|<
name|gl
operator|::
name|Buffer
operator|*
argument_list|>
name|boundBuffers
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|uniformBlockIndex
init|=
literal|0
init|;
name|uniformBlockIndex
operator|<
name|programBinary
operator|->
name|getActiveUniformBlockCount
argument_list|()
condition|;
name|uniformBlockIndex
operator|++
control|)
block|{
name|GLuint
name|blockBinding
init|=
name|programObject
operator|->
name|getUniformBlockBinding
argument_list|(
name|uniformBlockIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|getIndexedUniformBuffer
argument_list|(
name|blockBinding
argument_list|)
operator|->
name|id
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// undefined behaviour
return|return
literal|false
return|;
block|}
else|else
block|{
name|Buffer
modifier|*
name|uniformBuffer
init|=
name|mState
operator|.
name|getIndexedUniformBuffer
argument_list|(
name|blockBinding
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|uniformBuffer
argument_list|)
expr_stmt|;
name|boundBuffers
operator|.
name|push_back
argument_list|(
name|uniformBuffer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|programBinary
operator|->
name|applyUniformBuffers
argument_list|(
name|boundBuffers
argument_list|)
return|;
block|}
DECL|function|applyTransformFeedbackBuffers
name|bool
name|Context
operator|::
name|applyTransformFeedbackBuffers
parameter_list|()
block|{
name|TransformFeedback
modifier|*
name|curTransformFeedback
init|=
name|mState
operator|.
name|getCurrentTransformFeedback
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTransformFeedback
operator|&&
name|curTransformFeedback
operator|->
name|isStarted
argument_list|()
operator|&&
operator|!
name|curTransformFeedback
operator|->
name|isPaused
argument_list|()
condition|)
block|{
name|Buffer
modifier|*
name|transformFeedbackBuffers
index|[
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
index|]
decl_stmt|;
name|GLintptr
name|transformFeedbackOffsets
index|[
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|transformFeedbackBuffers
index|[
name|i
index|]
operator|=
name|mState
operator|.
name|getIndexedTransformFeedbackBuffer
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|transformFeedbackOffsets
index|[
name|i
index|]
operator|=
name|mState
operator|.
name|getIndexedTransformFeedbackBufferOffset
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|mRenderer
operator|->
name|applyTransformFeedbackBuffers
argument_list|(
name|transformFeedbackBuffers
argument_list|,
name|transformFeedbackOffsets
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|function|markTransformFeedbackUsage
name|void
name|Context
operator|::
name|markTransformFeedbackUsage
parameter_list|()
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|Buffer
modifier|*
name|buffer
init|=
name|mState
operator|.
name|getIndexedTransformFeedbackBuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|buffer
operator|->
name|markTransformFeedbackUsage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|clear
name|void
name|Context
operator|::
name|clear
parameter_list|(
name|GLbitfield
name|mask
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|isRasterizerDiscardEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|ClearParameters
name|clearParams
init|=
name|mState
operator|.
name|getClearParameters
argument_list|(
name|mask
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
condition|)
comment|// Clips the clear to the scissor rectangle but not the viewport
block|{
return|return;
block|}
name|mRenderer
operator|->
name|clear
argument_list|(
name|clearParams
argument_list|,
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|clearBufferfv
name|void
name|Context
operator|::
name|clearBufferfv
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|int
name|drawbuffer
parameter_list|,
specifier|const
name|float
modifier|*
name|values
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|isRasterizerDiscardEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// glClearBufferfv can be called to clear the color buffer or depth buffer
name|ClearParameters
name|clearParams
init|=
name|mState
operator|.
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorFClearValue
operator|=
name|ColorF
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_FLOAT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_DEPTH
condition|)
block|{
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|values
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
condition|)
comment|// Clips the clear to the scissor rectangle but not the viewport
block|{
return|return;
block|}
name|mRenderer
operator|->
name|clear
argument_list|(
name|clearParams
argument_list|,
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|clearBufferuiv
name|void
name|Context
operator|::
name|clearBufferuiv
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|int
name|drawbuffer
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|*
name|values
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|isRasterizerDiscardEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// glClearBufferuv can only be called to clear a color buffer
name|ClearParameters
name|clearParams
init|=
name|mState
operator|.
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorUIClearValue
operator|=
name|ColorUI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_UNSIGNED_INT
expr_stmt|;
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
condition|)
comment|// Clips the clear to the scissor rectangle but not the viewport
block|{
return|return;
block|}
name|mRenderer
operator|->
name|clear
argument_list|(
name|clearParams
argument_list|,
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|clearBufferiv
name|void
name|Context
operator|::
name|clearBufferiv
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|int
name|drawbuffer
parameter_list|,
specifier|const
name|int
modifier|*
name|values
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|isRasterizerDiscardEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// glClearBufferfv can be called to clear the color buffer or stencil buffer
name|ClearParameters
name|clearParams
init|=
name|mState
operator|.
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
name|GL_COLOR
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|clearParams
operator|.
name|clearColor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|clearParams
operator|.
name|clearColor
index|[
name|i
index|]
operator|=
operator|(
name|drawbuffer
operator|==
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
block|}
name|clearParams
operator|.
name|colorIClearValue
operator|=
name|ColorI
argument_list|(
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|clearParams
operator|.
name|colorClearType
operator|=
name|GL_INT
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|==
name|GL_STENCIL
condition|)
block|{
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|values
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
condition|)
comment|// Clips the clear to the scissor rectangle but not the viewport
block|{
return|return;
block|}
name|mRenderer
operator|->
name|clear
argument_list|(
name|clearParams
argument_list|,
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|clearBufferfi
name|void
name|Context
operator|::
name|clearBufferfi
parameter_list|(
name|GLenum
name|buffer
parameter_list|,
name|int
name|drawbuffer
parameter_list|,
name|float
name|depth
parameter_list|,
name|int
name|stencil
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|isRasterizerDiscardEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// glClearBufferfi can only be called to clear a depth stencil buffer
name|ClearParameters
name|clearParams
init|=
name|mState
operator|.
name|getClearParameters
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|clearParams
operator|.
name|clearDepth
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|depthClearValue
operator|=
name|depth
expr_stmt|;
name|clearParams
operator|.
name|clearStencil
operator|=
literal|true
expr_stmt|;
name|clearParams
operator|.
name|stencilClearValue
operator|=
name|stencil
expr_stmt|;
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|GL_TRIANGLES
argument_list|,
literal|true
argument_list|)
condition|)
comment|// Clips the clear to the scissor rectangle but not the viewport
block|{
return|return;
block|}
name|mRenderer
operator|->
name|clear
argument_list|(
name|clearParams
argument_list|,
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|readPixels
name|void
name|Context
operator|::
name|readPixels
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|bool
name|isSized
init|=
name|IsSizedInternalFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|GLenum
name|sizedInternalFormat
init|=
operator|(
name|isSized
condition|?
name|format
else|:
name|GetSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
operator|)
decl_stmt|;
name|GLuint
name|outputPitch
init|=
name|GetRowPitch
argument_list|(
name|sizedInternalFormat
argument_list|,
name|type
argument_list|,
name|width
argument_list|,
name|mState
operator|.
name|getPackAlignment
argument_list|()
argument_list|)
decl_stmt|;
name|mRenderer
operator|->
name|readPixels
argument_list|(
name|framebuffer
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|format
argument_list|,
name|type
argument_list|,
name|outputPitch
argument_list|,
name|mState
operator|.
name|getPackState
argument_list|()
argument_list|,
name|pixels
argument_list|)
expr_stmt|;
block|}
DECL|function|drawArrays
name|void
name|Context
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mState
operator|.
name|getCurrentProgramId
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|mState
operator|.
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|programBinary
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|Texture
modifier|*
name|vsTextures
index|[
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|TextureType
name|vsTextureTypes
index|[
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|SamplerState
name|vsSamplers
index|[
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|size_t
name|vsTextureCount
init|=
name|getCurrentTexturesAndSamplerStates
argument_list|(
name|programBinary
argument_list|,
name|SAMPLER_VERTEX
argument_list|,
name|vsTextures
argument_list|,
name|vsTextureTypes
argument_list|,
name|vsSamplers
argument_list|)
decl_stmt|;
name|Texture
modifier|*
name|psTextures
index|[
name|MAX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|TextureType
name|psTextureTypes
index|[
name|MAX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|SamplerState
name|psSamplers
index|[
name|MAX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|size_t
name|psTextureCount
init|=
name|getCurrentTexturesAndSamplerStates
argument_list|(
name|programBinary
argument_list|,
name|SAMPLER_PIXEL
argument_list|,
name|psTextures
argument_list|,
name|psTextureTypes
argument_list|,
name|psSamplers
argument_list|)
decl_stmt|;
name|generateSwizzles
argument_list|(
name|vsTextures
argument_list|,
name|vsTextureCount
argument_list|)
expr_stmt|;
name|generateSwizzles
argument_list|(
name|psTextures
argument_list|,
name|psTextureCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|mode
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|applyState
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|GLenum
name|err
init|=
name|mRenderer
operator|->
name|applyVertexBuffer
argument_list|(
name|programBinary
argument_list|,
name|mState
operator|.
name|getVertexArray
argument_list|()
operator|->
name|getVertexAttributes
argument_list|()
argument_list|,
name|mState
operator|.
name|getVertexAttribCurrentValues
argument_list|()
argument_list|,
name|first
argument_list|,
name|count
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|bool
name|transformFeedbackActive
init|=
name|applyTransformFeedbackBuffers
argument_list|()
decl_stmt|;
name|applyShaders
argument_list|(
name|programBinary
argument_list|,
name|transformFeedbackActive
argument_list|)
expr_stmt|;
name|FramebufferTextureSerialArray
name|frameBufferSerials
decl_stmt|;
name|size_t
name|framebufferSerialCount
init|=
name|getBoundFramebufferTextureSerials
argument_list|(
operator|&
name|frameBufferSerials
argument_list|)
decl_stmt|;
name|applyTextures
argument_list|(
name|SAMPLER_VERTEX
argument_list|,
name|vsTextures
argument_list|,
name|vsTextureTypes
argument_list|,
name|vsSamplers
argument_list|,
name|vsTextureCount
argument_list|,
name|frameBufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
expr_stmt|;
name|applyTextures
argument_list|(
name|SAMPLER_PIXEL
argument_list|,
name|psTextures
argument_list|,
name|psTextureTypes
argument_list|,
name|psSamplers
argument_list|,
name|psTextureCount
argument_list|,
name|frameBufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|applyUniformBuffers
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|drawArrays
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|instances
argument_list|,
name|transformFeedbackActive
argument_list|)
expr_stmt|;
if|if
condition|(
name|transformFeedbackActive
condition|)
block|{
name|markTransformFeedbackUsage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|drawElements
name|void
name|Context
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mState
operator|.
name|getCurrentProgramId
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|mState
operator|.
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|programBinary
operator|->
name|updateSamplerMapping
argument_list|()
expr_stmt|;
name|Texture
modifier|*
name|vsTextures
index|[
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|TextureType
name|vsTextureTypes
index|[
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|SamplerState
name|vsSamplers
index|[
name|IMPLEMENTATION_MAX_VERTEX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|size_t
name|vsTextureCount
init|=
name|getCurrentTexturesAndSamplerStates
argument_list|(
name|programBinary
argument_list|,
name|SAMPLER_VERTEX
argument_list|,
name|vsTextures
argument_list|,
name|vsTextureTypes
argument_list|,
name|vsSamplers
argument_list|)
decl_stmt|;
name|Texture
modifier|*
name|psTextures
index|[
name|MAX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|TextureType
name|psTextureTypes
index|[
name|MAX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|SamplerState
name|psSamplers
index|[
name|MAX_TEXTURE_IMAGE_UNITS
index|]
decl_stmt|;
name|size_t
name|psTextureCount
init|=
name|getCurrentTexturesAndSamplerStates
argument_list|(
name|programBinary
argument_list|,
name|SAMPLER_PIXEL
argument_list|,
name|psTextures
argument_list|,
name|psTextureTypes
argument_list|,
name|psSamplers
argument_list|)
decl_stmt|;
name|generateSwizzles
argument_list|(
name|vsTextures
argument_list|,
name|vsTextureCount
argument_list|)
expr_stmt|;
name|generateSwizzles
argument_list|(
name|psTextures
argument_list|,
name|psTextureCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mRenderer
operator|->
name|applyPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
name|mode
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|applyState
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|VertexArray
modifier|*
name|vao
init|=
name|mState
operator|.
name|getVertexArray
argument_list|()
decl_stmt|;
name|rx
operator|::
name|TranslatedIndexData
name|indexInfo
decl_stmt|;
name|GLenum
name|err
init|=
name|mRenderer
operator|->
name|applyIndexBuffer
argument_list|(
name|indices
argument_list|,
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
argument_list|,
name|count
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|indexInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|GLsizei
name|vertexCount
init|=
name|indexInfo
operator|.
name|maxIndex
operator|-
name|indexInfo
operator|.
name|minIndex
operator|+
literal|1
decl_stmt|;
name|err
operator|=
name|mRenderer
operator|->
name|applyVertexBuffer
argument_list|(
name|programBinary
argument_list|,
name|vao
operator|->
name|getVertexAttributes
argument_list|()
argument_list|,
name|mState
operator|.
name|getVertexAttribCurrentValues
argument_list|()
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|vertexCount
argument_list|,
name|instances
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|gl
operator|::
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|bool
name|transformFeedbackActive
init|=
name|applyTransformFeedbackBuffers
argument_list|()
decl_stmt|;
comment|// Transform feedback is not allowed for DrawElements, this error should have been caught at the API validation
comment|// layer.
name|ASSERT
argument_list|(
operator|!
name|transformFeedbackActive
argument_list|)
expr_stmt|;
name|applyShaders
argument_list|(
name|programBinary
argument_list|,
name|transformFeedbackActive
argument_list|)
expr_stmt|;
name|FramebufferTextureSerialArray
name|frameBufferSerials
decl_stmt|;
name|size_t
name|framebufferSerialCount
init|=
name|getBoundFramebufferTextureSerials
argument_list|(
operator|&
name|frameBufferSerials
argument_list|)
decl_stmt|;
name|applyTextures
argument_list|(
name|SAMPLER_VERTEX
argument_list|,
name|vsTextures
argument_list|,
name|vsTextureTypes
argument_list|,
name|vsSamplers
argument_list|,
name|vsTextureCount
argument_list|,
name|frameBufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
expr_stmt|;
name|applyTextures
argument_list|(
name|SAMPLER_PIXEL
argument_list|,
name|psTextures
argument_list|,
name|psTextureTypes
argument_list|,
name|psSamplers
argument_list|,
name|psTextureCount
argument_list|,
name|frameBufferSerials
argument_list|,
name|framebufferSerialCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|applyUniformBuffers
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|mRenderer
operator|->
name|drawElements
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|vao
operator|->
name|getElementArrayBuffer
argument_list|()
argument_list|,
name|indexInfo
argument_list|,
name|instances
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Implements glFlush when block is false, glFinish when block is true
DECL|function|sync
name|void
name|Context
operator|::
name|sync
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
name|mRenderer
operator|->
name|sync
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|function|recordInvalidEnum
name|void
name|Context
operator|::
name|recordInvalidEnum
parameter_list|()
block|{
name|mInvalidEnum
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidValue
name|void
name|Context
operator|::
name|recordInvalidValue
parameter_list|()
block|{
name|mInvalidValue
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidOperation
name|void
name|Context
operator|::
name|recordInvalidOperation
parameter_list|()
block|{
name|mInvalidOperation
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordOutOfMemory
name|void
name|Context
operator|::
name|recordOutOfMemory
parameter_list|()
block|{
name|mOutOfMemory
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidFramebufferOperation
name|void
name|Context
operator|::
name|recordInvalidFramebufferOperation
parameter_list|()
block|{
name|mInvalidFramebufferOperation
operator|=
literal|true
expr_stmt|;
block|}
comment|// Get one of the recorded errors and clear its flag, if any.
comment|// [OpenGL ES 2.0.24] section 2.5 page 13.
DECL|function|getError
name|GLenum
name|Context
operator|::
name|getError
parameter_list|()
block|{
if|if
condition|(
name|mInvalidEnum
condition|)
block|{
name|mInvalidEnum
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_ENUM
return|;
block|}
if|if
condition|(
name|mInvalidValue
condition|)
block|{
name|mInvalidValue
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_VALUE
return|;
block|}
if|if
condition|(
name|mInvalidOperation
condition|)
block|{
name|mInvalidOperation
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_OPERATION
return|;
block|}
if|if
condition|(
name|mOutOfMemory
condition|)
block|{
name|mOutOfMemory
operator|=
literal|false
expr_stmt|;
return|return
name|GL_OUT_OF_MEMORY
return|;
block|}
if|if
condition|(
name|mInvalidFramebufferOperation
condition|)
block|{
name|mInvalidFramebufferOperation
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_FRAMEBUFFER_OPERATION
return|;
block|}
return|return
name|GL_NO_ERROR
return|;
block|}
DECL|function|getResetStatus
name|GLenum
name|Context
operator|::
name|getResetStatus
parameter_list|()
block|{
if|if
condition|(
name|mResetStatus
operator|==
name|GL_NO_ERROR
operator|&&
operator|!
name|mContextLost
condition|)
block|{
comment|// mResetStatus will be set by the markContextLost callback
comment|// in the case a notification is sent
name|mRenderer
operator|->
name|testDeviceLost
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|GLenum
name|status
init|=
name|mResetStatus
decl_stmt|;
if|if
condition|(
name|mResetStatus
operator|!=
name|GL_NO_ERROR
condition|)
block|{
name|ASSERT
argument_list|(
name|mContextLost
argument_list|)
expr_stmt|;
if|if
condition|(
name|mRenderer
operator|->
name|testDeviceResettable
argument_list|()
condition|)
block|{
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
DECL|function|isResetNotificationEnabled
name|bool
name|Context
operator|::
name|isResetNotificationEnabled
parameter_list|()
block|{
return|return
operator|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
operator|)
return|;
block|}
DECL|function|getClientVersion
name|int
name|Context
operator|::
name|getClientVersion
parameter_list|()
specifier|const
block|{
return|return
name|mClientVersion
return|;
block|}
DECL|function|getCaps
specifier|const
name|Caps
modifier|&
name|Context
operator|::
name|getCaps
parameter_list|()
specifier|const
block|{
return|return
name|mCaps
return|;
block|}
DECL|function|getTextureCaps
specifier|const
name|TextureCapsMap
modifier|&
name|Context
operator|::
name|getTextureCaps
parameter_list|()
specifier|const
block|{
return|return
name|mTextureCaps
return|;
block|}
DECL|function|getExtensions
specifier|const
name|Extensions
modifier|&
name|Context
operator|::
name|getExtensions
parameter_list|()
specifier|const
block|{
return|return
name|mExtensions
return|;
block|}
DECL|function|getMajorShaderModel
name|int
name|Context
operator|::
name|getMajorShaderModel
parameter_list|()
specifier|const
block|{
return|return
name|mMajorShaderModel
return|;
block|}
DECL|function|getMaximumCombinedTextureImageUnits
name|unsigned
name|int
name|Context
operator|::
name|getMaximumCombinedTextureImageUnits
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxCombinedTextureImageUnits
argument_list|()
return|;
block|}
DECL|function|getMaximumCombinedUniformBufferBindings
name|unsigned
name|int
name|Context
operator|::
name|getMaximumCombinedUniformBufferBindings
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxVertexShaderUniformBuffers
argument_list|()
operator|+
name|mRenderer
operator|->
name|getMaxFragmentShaderUniformBuffers
argument_list|()
return|;
block|}
DECL|function|getMaxSupportedSamples
name|int
name|Context
operator|::
name|getMaxSupportedSamples
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxSupportedSamples
argument_list|()
return|;
block|}
DECL|function|getMaxSupportedFormatSamples
name|GLsizei
name|Context
operator|::
name|getMaxSupportedFormatSamples
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxSupportedFormatSamples
argument_list|(
name|internalFormat
argument_list|)
return|;
block|}
DECL|function|getNumSampleCounts
name|GLsizei
name|Context
operator|::
name|getNumSampleCounts
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|)
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getNumSampleCounts
argument_list|(
name|internalFormat
argument_list|)
return|;
block|}
DECL|function|getSampleCounts
name|void
name|Context
operator|::
name|getSampleCounts
parameter_list|(
name|GLenum
name|internalFormat
parameter_list|,
name|GLsizei
name|bufSize
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
specifier|const
block|{
name|mRenderer
operator|->
name|getSampleCounts
argument_list|(
name|internalFormat
argument_list|,
name|bufSize
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
DECL|function|getMaxTransformFeedbackBufferBindings
name|unsigned
name|int
name|Context
operator|::
name|getMaxTransformFeedbackBufferBindings
parameter_list|()
specifier|const
block|{
return|return
name|mRenderer
operator|->
name|getMaxTransformFeedbackBuffers
argument_list|()
return|;
block|}
DECL|function|getUniformBufferOffsetAlignment
name|GLintptr
name|Context
operator|::
name|getUniformBufferOffsetAlignment
parameter_list|()
specifier|const
block|{
comment|// setting a large alignment forces uniform buffers to bind with zero offset
return|return
cast|static_cast
argument_list|<
name|GLintptr
argument_list|>
argument_list|(
name|std
operator|::
name|numeric_limits
argument_list|<
name|GLint
argument_list|>
operator|::
name|max
argument_list|()
argument_list|)
return|;
block|}
DECL|function|getCurrentReadFormatType
name|void
name|Context
operator|::
name|getCurrentReadFormatType
parameter_list|(
name|GLenum
modifier|*
name|internalFormat
parameter_list|,
name|GLenum
modifier|*
name|format
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|framebuffer
operator|&&
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|==
name|GL_FRAMEBUFFER_COMPLETE
argument_list|)
expr_stmt|;
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|framebuffer
operator|->
name|getReadColorbuffer
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|attachment
argument_list|)
expr_stmt|;
operator|*
name|internalFormat
operator|=
name|attachment
operator|->
name|getActualFormat
argument_list|()
expr_stmt|;
operator|*
name|format
operator|=
name|gl
operator|::
name|GetFormat
argument_list|(
name|attachment
operator|->
name|getActualFormat
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|gl
operator|::
name|GetType
argument_list|(
name|attachment
operator|->
name|getActualFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|detachTexture
name|void
name|Context
operator|::
name|detachTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
comment|// Simple pass-through to State's detachTexture method, as textures do not require
comment|// allocation map management either here or in the resource manager at detach time.
comment|// Zero textures are held by the Context, and we don't attempt to request them from
comment|// the State.
name|mState
operator|.
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|detachBuffer
name|void
name|Context
operator|::
name|detachBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
comment|// Buffer detachment is handled by Context, because the buffer must also be
comment|// attached from any VAOs in existence, and Context holds the VAO map.
comment|// [OpenGL ES 2.0.24] section 2.9 page 22:
comment|// If a buffer object is deleted while it is bound, all bindings to that object in the current context
comment|// (i.e. in the thread that called Delete-Buffers) are reset to zero.
name|mState
operator|.
name|removeArrayBufferBinding
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|// mark as freed among the vertex array objects
for|for
control|(
name|auto
name|vaoIt
init|=
name|mVertexArrayMap
operator|.
name|begin
argument_list|()
init|;
name|vaoIt
operator|!=
name|mVertexArrayMap
operator|.
name|end
argument_list|()
condition|;
name|vaoIt
operator|++
control|)
block|{
name|vaoIt
operator|->
name|second
operator|->
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachFramebuffer
name|void
name|Context
operator|::
name|detachFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
comment|// Framebuffer detachment is handled by Context, because 0 is a valid
comment|// Framebuffer object, and a pointer to it must be passed from Context
comment|// to State at binding time.
comment|// [OpenGL ES 2.0.24] section 4.4 page 107:
comment|// If a framebuffer that is currently bound to the target FRAMEBUFFER is deleted, it is as though
comment|// BindFramebuffer had been executed with the target of FRAMEBUFFER and framebuffer of zero.
if|if
condition|(
name|mState
operator|.
name|removeReadFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|removeDrawFramebufferBinding
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachRenderbuffer
name|void
name|Context
operator|::
name|detachRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mState
operator|.
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|detachVertexArray
name|void
name|Context
operator|::
name|detachVertexArray
parameter_list|(
name|GLuint
name|vertexArray
parameter_list|)
block|{
comment|// Vertex array detachment is handled by Context, because 0 is a valid
comment|// VAO, and a pointer to it must be passed from Context to State at
comment|// binding time.
comment|// [OpenGL ES 3.0.2] section 2.10 page 43:
comment|// If a vertex array object that is currently bound is deleted, the binding
comment|// for that object reverts to zero and the default vertex array becomes current.
if|if
condition|(
name|mState
operator|.
name|removeVertexArrayBinding
argument_list|(
name|vertexArray
argument_list|)
condition|)
block|{
name|bindVertexArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachTransformFeedback
name|void
name|Context
operator|::
name|detachTransformFeedback
parameter_list|(
name|GLuint
name|transformFeedback
parameter_list|)
block|{
name|mState
operator|.
name|detachTransformFeedback
argument_list|(
name|transformFeedback
argument_list|)
expr_stmt|;
block|}
DECL|function|detachSampler
name|void
name|Context
operator|::
name|detachSampler
parameter_list|(
name|GLuint
name|sampler
parameter_list|)
block|{
name|mState
operator|.
name|detachSampler
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
block|}
DECL|function|getIncompleteTexture
name|Texture
modifier|*
name|Context
operator|::
name|getIncompleteTexture
parameter_list|(
name|TextureType
name|type
parameter_list|)
block|{
name|Texture
modifier|*
name|t
init|=
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
specifier|const
name|GLubyte
name|color
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|}
decl_stmt|;
specifier|const
name|PixelUnpackState
name|incompleteUnpackState
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// default falls through to TEXTURE_2D
case|case
name|TEXTURE_2D
case|:
block|{
name|Texture2D
modifier|*
name|incomplete2d
init|=
operator|new
name|Texture2D
argument_list|(
name|mRenderer
operator|->
name|createTexture2D
argument_list|()
argument_list|,
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete2d
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete2d
expr_stmt|;
block|}
break|break;
case|case
name|TEXTURE_CUBE
case|:
block|{
name|TextureCubeMap
modifier|*
name|incompleteCube
init|=
operator|new
name|TextureCubeMap
argument_list|(
name|mRenderer
operator|->
name|createTextureCube
argument_list|()
argument_list|,
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incompleteCube
operator|->
name|setImagePosX
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegX
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImagePosY
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegY
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImagePosZ
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegZ
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incompleteCube
expr_stmt|;
block|}
break|break;
case|case
name|TEXTURE_3D
case|:
block|{
name|Texture3D
modifier|*
name|incomplete3d
init|=
operator|new
name|Texture3D
argument_list|(
name|mRenderer
operator|->
name|createTexture3D
argument_list|()
argument_list|,
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete3d
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete3d
expr_stmt|;
block|}
break|break;
case|case
name|TEXTURE_2D_ARRAY
case|:
block|{
name|Texture2DArray
modifier|*
name|incomplete2darray
init|=
operator|new
name|Texture2DArray
argument_list|(
name|mRenderer
operator|->
name|createTexture2DArray
argument_list|()
argument_list|,
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete2darray
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
name|incompleteUnpackState
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete2darray
expr_stmt|;
block|}
break|break;
block|}
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
DECL|function|skipDraw
name|bool
name|Context
operator|::
name|skipDraw
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
if|if
condition|(
name|drawMode
operator|==
name|GL_POINTS
condition|)
block|{
comment|// ProgramBinary assumes non-point rendering if gl_PointSize isn't written,
comment|// which affects varying interpolation. Since the value of gl_PointSize is
comment|// undefined when not written, just skip drawing to avoid unexpected results.
if|if
condition|(
operator|!
name|mState
operator|.
name|getCurrentProgramBinary
argument_list|()
operator|->
name|usesPointSize
argument_list|()
condition|)
block|{
comment|// This is stictly speaking not an error, but developers should be
comment|// notified of risking undefined behavior.
name|ERR
argument_list|(
literal|"Point rendering without writing to gl_PointSize."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IsTriangleMode
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|cullFace
operator|&&
name|mState
operator|.
name|getRasterizerState
argument_list|()
operator|.
name|cullMode
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|setVertexAttribDivisor
name|void
name|Context
operator|::
name|setVertexAttribDivisor
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLuint
name|divisor
parameter_list|)
block|{
name|mState
operator|.
name|getVertexArray
argument_list|()
operator|->
name|setVertexAttribDivisor
argument_list|(
name|index
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
block|}
DECL|function|samplerParameteri
name|void
name|Context
operator|::
name|samplerParameteri
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLint
name|param
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
name|samplerObject
operator|->
name|setMinFilter
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
name|samplerObject
operator|->
name|setMagFilter
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
name|samplerObject
operator|->
name|setWrapS
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
name|samplerObject
operator|->
name|setWrapT
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_R
case|:
name|samplerObject
operator|->
name|setWrapR
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
name|samplerObject
operator|->
name|setMinLod
argument_list|(
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
name|samplerObject
operator|->
name|setMaxLod
argument_list|(
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
name|samplerObject
operator|->
name|setComparisonMode
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
name|samplerObject
operator|->
name|setComparisonFunc
argument_list|(
cast|static_cast
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|samplerParameterf
name|void
name|Context
operator|::
name|samplerParameterf
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|,
name|GLfloat
name|param
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
name|samplerObject
operator|->
name|setMinFilter
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
name|samplerObject
operator|->
name|setMagFilter
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_S
case|:
name|samplerObject
operator|->
name|setWrapS
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_T
case|:
name|samplerObject
operator|->
name|setWrapT
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_WRAP_R
case|:
name|samplerObject
operator|->
name|setWrapR
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
name|samplerObject
operator|->
name|setMinLod
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
name|samplerObject
operator|->
name|setMaxLod
argument_list|(
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
name|samplerObject
operator|->
name|setComparisonMode
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
name|samplerObject
operator|->
name|setComparisonFunc
argument_list|(
name|uiround
argument_list|<
name|GLenum
argument_list|>
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
DECL|function|getSamplerParameteri
name|GLint
name|Context
operator|::
name|getSamplerParameteri
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMagFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_S
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapS
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_T
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapT
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_R
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapR
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
return|return
name|uiround
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinLod
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
return|return
name|uiround
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMaxLod
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonMode
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
cast|static_cast
argument_list|<
name|GLint
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonFunc
argument_list|()
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|getSamplerParameterf
name|GLfloat
name|Context
operator|::
name|getSamplerParameterf
parameter_list|(
name|GLuint
name|sampler
parameter_list|,
name|GLenum
name|pname
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkSamplerAllocation
argument_list|(
name|sampler
argument_list|)
expr_stmt|;
name|Sampler
modifier|*
name|samplerObject
init|=
name|getSampler
argument_list|(
name|sampler
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|samplerObject
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_TEXTURE_MIN_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMinFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MAG_FILTER
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getMagFilter
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_S
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapS
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_T
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapT
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_WRAP_R
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getWrapR
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_MIN_LOD
case|:
return|return
name|samplerObject
operator|->
name|getMinLod
argument_list|()
return|;
case|case
name|GL_TEXTURE_MAX_LOD
case|:
return|return
name|samplerObject
operator|->
name|getMaxLod
argument_list|()
return|;
case|case
name|GL_TEXTURE_COMPARE_MODE
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonMode
argument_list|()
argument_list|)
return|;
case|case
name|GL_TEXTURE_COMPARE_FUNC
case|:
return|return
cast|static_cast
argument_list|<
name|GLfloat
argument_list|>
argument_list|(
name|samplerObject
operator|->
name|getComparisonFunc
argument_list|()
argument_list|)
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|function|initRendererString
name|void
name|Context
operator|::
name|initRendererString
parameter_list|()
block|{
name|std
operator|::
name|ostringstream
name|rendererString
decl_stmt|;
name|rendererString
operator|<<
literal|"ANGLE ("
expr_stmt|;
name|rendererString
operator|<<
name|mRenderer
operator|->
name|getRendererDescription
argument_list|()
expr_stmt|;
name|rendererString
operator|<<
literal|")"
expr_stmt|;
name|mRendererString
operator|=
name|MakeStaticString
argument_list|(
name|rendererString
operator|.
name|str
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|function|getRendererString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getRendererString
parameter_list|()
specifier|const
block|{
return|return
name|mRendererString
return|;
block|}
DECL|function|initExtensionStrings
name|void
name|Context
operator|::
name|initExtensionStrings
parameter_list|()
block|{
name|mExtensionStrings
operator|=
name|mExtensions
operator|.
name|getStrings
argument_list|()
expr_stmt|;
name|std
operator|::
name|ostringstream
name|combinedStringStream
decl_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|mExtensionStrings
operator|.
name|begin
argument_list|()
argument_list|,
name|mExtensionStrings
operator|.
name|end
argument_list|()
argument_list|,
name|std
operator|::
name|ostream_iterator
argument_list|<
name|std
operator|::
name|string
argument_list|>
argument_list|(
name|combinedStringStream
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|mExtensionString
operator|=
name|combinedStringStream
operator|.
name|str
argument_list|()
expr_stmt|;
block|}
DECL|function|getExtensionString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getExtensionString
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionString
return|;
block|}
DECL|function|getExtensionString
specifier|const
name|std
operator|::
name|string
modifier|&
name|Context
operator|::
name|getExtensionString
parameter_list|(
name|size_t
name|idx
parameter_list|)
specifier|const
block|{
return|return
name|mExtensionStrings
index|[
name|idx
index|]
return|;
block|}
DECL|function|getExtensionStringCount
name|size_t
name|Context
operator|::
name|getExtensionStringCount
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionStrings
operator|.
name|size
argument_list|()
return|;
block|}
DECL|function|getBoundFramebufferTextureSerials
name|size_t
name|Context
operator|::
name|getBoundFramebufferTextureSerials
parameter_list|(
name|FramebufferTextureSerialArray
modifier|*
name|outSerialArray
parameter_list|)
block|{
name|size_t
name|serialCount
init|=
literal|0
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IMPLEMENTATION_MAX_DRAW_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
operator|&&
name|attachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
operator|(
operator|*
name|outSerialArray
operator|)
index|[
name|serialCount
operator|++
index|]
operator|=
name|attachment
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
block|}
block|}
name|FramebufferAttachment
modifier|*
name|depthStencilAttachment
init|=
name|drawFramebuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthStencilAttachment
operator|&&
name|depthStencilAttachment
operator|->
name|isTexture
argument_list|()
condition|)
block|{
operator|(
operator|*
name|outSerialArray
operator|)
index|[
name|serialCount
operator|++
index|]
operator|=
name|depthStencilAttachment
operator|->
name|getTextureSerial
argument_list|()
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|outSerialArray
operator|->
name|begin
argument_list|()
argument_list|,
name|outSerialArray
operator|->
name|begin
argument_list|()
operator|+
name|serialCount
argument_list|)
expr_stmt|;
return|return
name|serialCount
return|;
block|}
DECL|function|blitFramebuffer
name|void
name|Context
operator|::
name|blitFramebuffer
parameter_list|(
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|,
name|GLenum
name|filter
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|bool
name|blitRenderTarget
init|=
literal|false
decl_stmt|;
name|bool
name|blitDepth
init|=
literal|false
decl_stmt|;
name|bool
name|blitStencil
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
operator|)
operator|&&
name|readFramebuffer
operator|->
name|getReadColorbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getFirstColorbuffer
argument_list|()
condition|)
block|{
name|blitRenderTarget
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
operator|)
operator|&&
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
condition|)
block|{
name|blitStencil
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
operator|)
operator|&&
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
condition|)
block|{
name|blitDepth
operator|=
literal|true
expr_stmt|;
block|}
name|gl
operator|::
name|Rectangle
name|srcRect
argument_list|(
name|srcX0
argument_list|,
name|srcY0
argument_list|,
name|srcX1
operator|-
name|srcX0
argument_list|,
name|srcY1
operator|-
name|srcY0
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Rectangle
name|dstRect
argument_list|(
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstX1
operator|-
name|dstX0
argument_list|,
name|dstY1
operator|-
name|dstY0
argument_list|)
decl_stmt|;
if|if
condition|(
name|blitRenderTarget
operator|||
name|blitDepth
operator|||
name|blitStencil
condition|)
block|{
specifier|const
name|gl
operator|::
name|Rectangle
modifier|*
name|scissor
init|=
name|mState
operator|.
name|isScissorTestEnabled
argument_list|()
condition|?
operator|&
name|mState
operator|.
name|getScissor
argument_list|()
else|:
name|NULL
decl_stmt|;
name|mRenderer
operator|->
name|blitRect
argument_list|(
name|readFramebuffer
argument_list|,
name|srcRect
argument_list|,
name|drawFramebuffer
argument_list|,
name|dstRect
argument_list|,
name|scissor
argument_list|,
name|blitRenderTarget
argument_list|,
name|blitDepth
argument_list|,
name|blitStencil
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|invalidateFrameBuffer
name|void
name|Context
operator|::
name|invalidateFrameBuffer
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLsizei
name|numAttachments
parameter_list|,
specifier|const
name|GLenum
modifier|*
name|attachments
parameter_list|,
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|frameBuffer
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_FRAMEBUFFER
case|:
case|case
name|GL_DRAW_FRAMEBUFFER
case|:
name|frameBuffer
operator|=
name|mState
operator|.
name|getDrawFramebuffer
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_READ_FRAMEBUFFER
case|:
name|frameBuffer
operator|=
name|mState
operator|.
name|getReadFramebuffer
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|frameBuffer
operator|&&
name|frameBuffer
operator|->
name|completeness
argument_list|()
operator|==
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numAttachments
condition|;
operator|++
name|i
control|)
block|{
name|rx
operator|::
name|RenderTarget
modifier|*
name|renderTarget
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|attachments
index|[
name|i
index|]
operator|>=
name|GL_COLOR_ATTACHMENT0
operator|&&
name|attachments
index|[
name|i
index|]
operator|<=
name|GL_COLOR_ATTACHMENT15
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|frameBuffer
operator|->
name|getColorbuffer
argument_list|(
name|attachments
index|[
name|i
index|]
operator|-
name|GL_COLOR_ATTACHMENT0
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
condition|)
block|{
name|renderTarget
operator|=
name|attachment
operator|->
name|getRenderTarget
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|attachments
index|[
name|i
index|]
operator|==
name|GL_COLOR
condition|)
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|frameBuffer
operator|->
name|getColorbuffer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|attachment
condition|)
block|{
name|renderTarget
operator|=
name|attachment
operator|->
name|getRenderTarget
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|gl
operator|::
name|FramebufferAttachment
modifier|*
name|attachment
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|attachments
index|[
name|i
index|]
condition|)
block|{
case|case
name|GL_DEPTH_ATTACHMENT
case|:
case|case
name|GL_DEPTH
case|:
name|attachment
operator|=
name|frameBuffer
operator|->
name|getDepthbuffer
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_ATTACHMENT
case|:
case|case
name|GL_STENCIL
case|:
name|attachment
operator|=
name|frameBuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_STENCIL_ATTACHMENT
case|:
name|attachment
operator|=
name|frameBuffer
operator|->
name|getDepthOrStencilbuffer
argument_list|()
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|attachment
condition|)
block|{
name|renderTarget
operator|=
name|attachment
operator|->
name|getDepthStencil
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|renderTarget
condition|)
block|{
name|renderTarget
operator|->
name|invalidate
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|hasMappedBuffer
name|bool
name|Context
operator|::
name|hasMappedBuffer
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|target
operator|==
name|GL_ARRAY_BUFFER
condition|)
block|{
for|for
control|(
name|unsigned
name|int
name|attribIndex
init|=
literal|0
init|;
name|attribIndex
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribIndex
operator|++
control|)
block|{
specifier|const
name|gl
operator|::
name|VertexAttribute
modifier|&
name|vertexAttrib
init|=
name|mState
operator|.
name|getVertexAttribState
argument_list|(
name|attribIndex
argument_list|)
decl_stmt|;
name|gl
operator|::
name|Buffer
modifier|*
name|boundBuffer
init|=
name|vertexAttrib
operator|.
name|buffer
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|vertexAttrib
operator|.
name|enabled
operator|&&
name|boundBuffer
operator|&&
name|boundBuffer
operator|->
name|isMapped
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|GL_ELEMENT_ARRAY_BUFFER
condition|)
block|{
name|Buffer
modifier|*
name|elementBuffer
init|=
name|mState
operator|.
name|getTargetBuffer
argument_list|(
name|target
argument_list|)
decl_stmt|;
return|return
operator|(
name|elementBuffer
operator|&&
name|elementBuffer
operator|->
name|isMapped
argument_list|()
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|GL_TRANSFORM_FEEDBACK_BUFFER
condition|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
else|else
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|function|initCaps
name|void
name|Context
operator|::
name|initCaps
parameter_list|(
name|GLuint
name|clientVersion
parameter_list|)
block|{
name|mCaps
operator|=
name|mRenderer
operator|->
name|getRendererCaps
argument_list|()
expr_stmt|;
name|mExtensions
operator|=
name|mRenderer
operator|->
name|getRendererExtensions
argument_list|()
expr_stmt|;
if|if
condition|(
name|clientVersion
operator|<
literal|3
condition|)
block|{
comment|// Disable ES3+ extensions
name|mExtensions
operator|.
name|colorBufferFloat
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|clientVersion
operator|>
literal|2
condition|)
block|{
comment|// FIXME(geofflang): Don't support EXT_sRGB in non-ES2 contexts
comment|//mExtensions.sRGB = false;
block|}
specifier|const
name|TextureCapsMap
modifier|&
name|rendererFormats
init|=
name|mRenderer
operator|->
name|getRendererTextureCaps
argument_list|()
decl_stmt|;
for|for
control|(
name|TextureCapsMap
operator|::
name|const_iterator
name|i
init|=
name|rendererFormats
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|rendererFormats
operator|.
name|end
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|GLenum
name|format
init|=
name|i
operator|->
name|first
decl_stmt|;
name|TextureCaps
name|formatCaps
init|=
name|i
operator|->
name|second
decl_stmt|;
if|if
condition|(
name|formatCaps
operator|.
name|texturable
operator|&&
name|IsValidInternalFormat
argument_list|(
name|format
argument_list|,
name|mExtensions
argument_list|,
name|clientVersion
argument_list|)
condition|)
block|{
comment|// Update the format caps based on the client version and extensions
name|formatCaps
operator|.
name|renderable
operator|=
name|IsRenderingSupported
argument_list|(
name|format
argument_list|,
name|mExtensions
argument_list|,
name|clientVersion
argument_list|)
expr_stmt|;
name|formatCaps
operator|.
name|filterable
operator|=
name|IsFilteringSupported
argument_list|(
name|format
argument_list|,
name|mExtensions
argument_list|,
name|clientVersion
argument_list|)
expr_stmt|;
name|mTextureCaps
operator|.
name|insert
argument_list|(
name|format
argument_list|,
name|formatCaps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_namespace
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|glCreateContext
name|gl
operator|::
name|Context
modifier|*
name|glCreateContext
parameter_list|(
name|int
name|clientVersion
parameter_list|,
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|rx
operator|::
name|Renderer
modifier|*
name|renderer
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
block|{
return|return
operator|new
name|gl
operator|::
name|Context
argument_list|(
name|clientVersion
argument_list|,
name|shareContext
argument_list|,
name|renderer
argument_list|,
name|notifyResets
argument_list|,
name|robustAccess
argument_list|)
return|;
block|}
DECL|function|glDestroyContext
name|void
name|glDestroyContext
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
operator|delete
name|context
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|gl
operator|::
name|getContext
argument_list|()
condition|)
block|{
name|gl
operator|::
name|makeCurrent
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|glMakeCurrent
name|void
name|glMakeCurrent
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|gl
operator|::
name|makeCurrent
argument_list|(
name|context
argument_list|,
name|display
argument_list|,
name|surface
argument_list|)
expr_stmt|;
block|}
DECL|function|glGetCurrentContext
name|gl
operator|::
name|Context
modifier|*
name|glGetCurrentContext
parameter_list|()
block|{
return|return
name|gl
operator|::
name|getContext
argument_list|()
return|;
block|}
block|}
end_extern
end_unit
