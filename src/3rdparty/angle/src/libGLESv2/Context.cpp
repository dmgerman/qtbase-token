begin_unit
begin_comment
comment|//
end_comment
begin_comment
comment|// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
end_comment
begin_comment
comment|// Use of this source code is governed by a BSD-style license that can be
end_comment
begin_comment
comment|// found in the LICENSE file.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Context.cpp: Implements the gl::Context class, managing all GL state and performing
end_comment
begin_comment
comment|// rendering operations. It is the GLES2 specific implementation of EGLContext.
end_comment
begin_include
include|#
directive|include
file|"libGLESv2/Context.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|"libEGL/Display.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/main.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/mathutil.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/utilities.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Blit.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ResourceManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Buffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Fence.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Framebuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Program.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/ProgramBinary.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Query.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Renderbuffer.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Shader.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/Texture.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/VertexDataManager.h"
end_include
begin_include
include|#
directive|include
file|"libGLESv2/IndexDataManager.h"
end_include
begin_undef
DECL|macro|near
undef|#
directive|undef
name|near
end_undef
begin_undef
DECL|macro|far
undef|#
directive|undef
name|far
end_undef
begin_namespace
DECL|namespace|gl
namespace|namespace
name|gl
block|{
DECL|function|Context
name|Context
operator|::
name|Context
parameter_list|(
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|config
parameter_list|,
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
member_init_list|:
name|mConfig
argument_list|(
name|config
argument_list|)
block|{
name|ASSERT
argument_list|(
name|robustAccess
operator|==
literal|false
argument_list|)
expr_stmt|;
comment|// Unimplemented
name|mDisplay
operator|=
name|NULL
expr_stmt|;
name|mDevice
operator|=
name|NULL
expr_stmt|;
name|mFenceHandleAllocator
operator|.
name|setBaseHandle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setClearColor
argument_list|(
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|mState
operator|.
name|depthClearValue
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|stencilClearValue
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|cullFace
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|cullMode
operator|=
name|GL_BACK
expr_stmt|;
name|mState
operator|.
name|frontFace
operator|=
name|GL_CCW
expr_stmt|;
name|mState
operator|.
name|depthTest
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|depthFunc
operator|=
name|GL_LESS
expr_stmt|;
name|mState
operator|.
name|blend
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|sourceBlendRGB
operator|=
name|GL_ONE
expr_stmt|;
name|mState
operator|.
name|sourceBlendAlpha
operator|=
name|GL_ONE
expr_stmt|;
name|mState
operator|.
name|destBlendRGB
operator|=
name|GL_ZERO
expr_stmt|;
name|mState
operator|.
name|destBlendAlpha
operator|=
name|GL_ZERO
expr_stmt|;
name|mState
operator|.
name|blendEquationRGB
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mState
operator|.
name|blendEquationAlpha
operator|=
name|GL_FUNC_ADD
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|red
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|green
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|alpha
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|stencilTest
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|stencilFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|mState
operator|.
name|stencilRef
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|stencilMask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|stencilWritemask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|stencilBackFunc
operator|=
name|GL_ALWAYS
expr_stmt|;
name|mState
operator|.
name|stencilBackRef
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|stencilBackMask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|stencilBackWritemask
operator|=
operator|-
literal|1
expr_stmt|;
name|mState
operator|.
name|stencilFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|stencilPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|stencilPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|stencilBackFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|stencilBackPassDepthFail
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|stencilBackPassDepthPass
operator|=
name|GL_KEEP
expr_stmt|;
name|mState
operator|.
name|polygonOffsetFill
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|polygonOffsetFactor
operator|=
literal|0.0f
expr_stmt|;
name|mState
operator|.
name|polygonOffsetUnits
operator|=
literal|0.0f
expr_stmt|;
name|mState
operator|.
name|sampleAlphaToCoverage
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|sampleCoverage
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|sampleCoverageValue
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|sampleCoverageInvert
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|scissorTest
operator|=
literal|false
expr_stmt|;
name|mState
operator|.
name|dither
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|generateMipmapHint
operator|=
name|GL_DONT_CARE
expr_stmt|;
name|mState
operator|.
name|fragmentShaderDerivativeHint
operator|=
name|GL_DONT_CARE
expr_stmt|;
name|mState
operator|.
name|lineWidth
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|viewportX
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewportY
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewportWidth
operator|=
name|config
operator|->
name|mDisplayMode
operator|.
name|Width
expr_stmt|;
name|mState
operator|.
name|viewportHeight
operator|=
name|config
operator|->
name|mDisplayMode
operator|.
name|Height
expr_stmt|;
name|mState
operator|.
name|zNear
operator|=
literal|0.0f
expr_stmt|;
name|mState
operator|.
name|zFar
operator|=
literal|1.0f
expr_stmt|;
name|mState
operator|.
name|scissorX
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissorY
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissorWidth
operator|=
name|config
operator|->
name|mDisplayMode
operator|.
name|Width
expr_stmt|;
name|mState
operator|.
name|scissorHeight
operator|=
name|config
operator|->
name|mDisplayMode
operator|.
name|Height
expr_stmt|;
name|mState
operator|.
name|colorMaskRed
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|colorMaskGreen
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|colorMaskBlue
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|colorMaskAlpha
operator|=
literal|true
expr_stmt|;
name|mState
operator|.
name|depthMask
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|shareContext
operator|!=
name|NULL
condition|)
block|{
name|mResourceManager
operator|=
name|shareContext
operator|->
name|mResourceManager
expr_stmt|;
name|mResourceManager
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mResourceManager
operator|=
operator|new
name|ResourceManager
argument_list|()
expr_stmt|;
block|}
comment|// [OpenGL ES 2.0.24] section 3.7 page 83:
comment|// In the initial state, TEXTURE_2D and TEXTURE_CUBE_MAP have twodimensional
comment|// and cube map texture state vectors respectively associated with them.
comment|// In order that access to these initial textures not be lost, they are treated as texture
comment|// objects all of whose names are 0.
name|mTexture2DZero
operator|.
name|set
argument_list|(
operator|new
name|Texture2D
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mTextureCubeMapZero
operator|.
name|set
argument_list|(
operator|new
name|TextureCubeMap
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mState
operator|.
name|activeSampler
operator|=
literal|0
expr_stmt|;
name|bindArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindElementArrayBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindTextureCubeMap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindTexture2D
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bindRenderbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mState
operator|.
name|currentProgram
operator|=
literal|0
expr_stmt|;
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mState
operator|.
name|packAlignment
operator|=
literal|4
expr_stmt|;
name|mState
operator|.
name|unpackAlignment
operator|=
literal|4
expr_stmt|;
name|mState
operator|.
name|packReverseRowOrder
operator|=
literal|false
expr_stmt|;
name|mVertexDataManager
operator|=
name|NULL
expr_stmt|;
name|mIndexDataManager
operator|=
name|NULL
expr_stmt|;
name|mBlit
operator|=
name|NULL
expr_stmt|;
name|mLineLoopIB
operator|=
name|NULL
expr_stmt|;
name|mInvalidEnum
operator|=
literal|false
expr_stmt|;
name|mInvalidValue
operator|=
literal|false
expr_stmt|;
name|mInvalidOperation
operator|=
literal|false
expr_stmt|;
name|mOutOfMemory
operator|=
literal|false
expr_stmt|;
name|mInvalidFramebufferOperation
operator|=
literal|false
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|false
expr_stmt|;
name|mContextLost
operator|=
literal|false
expr_stmt|;
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
name|mResetStrategy
operator|=
operator|(
name|notifyResets
condition|?
name|GL_LOSE_CONTEXT_ON_RESET_EXT
else|:
name|GL_NO_RESET_NOTIFICATION_EXT
operator|)
expr_stmt|;
name|mRobustAccess
operator|=
name|robustAccess
expr_stmt|;
name|mSupportsDXT1Textures
operator|=
literal|false
expr_stmt|;
name|mSupportsDXT3Textures
operator|=
literal|false
expr_stmt|;
name|mSupportsDXT5Textures
operator|=
literal|false
expr_stmt|;
name|mSupportsEventQueries
operator|=
literal|false
expr_stmt|;
name|mSupportsOcclusionQueries
operator|=
literal|false
expr_stmt|;
name|mNumCompressedTextureFormats
operator|=
literal|0
expr_stmt|;
name|mMaxSupportedSamples
operator|=
literal|0
expr_stmt|;
name|mMaskedClearSavedState
operator|=
name|NULL
expr_stmt|;
name|markAllStateDirty
argument_list|()
expr_stmt|;
block|}
DECL|function|~Context
name|Context
operator|::
name|~
name|Context
parameter_list|()
block|{
if|if
condition|(
name|mState
operator|.
name|currentProgram
operator|!=
literal|0
condition|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|mState
operator|.
name|currentProgram
argument_list|)
decl_stmt|;
if|if
condition|(
name|programObject
condition|)
block|{
name|programObject
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mState
operator|.
name|currentProgram
operator|=
literal|0
expr_stmt|;
block|}
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mFramebufferMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteFramebuffer
argument_list|(
name|mFramebufferMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mFenceMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteFence
argument_list|(
name|mFenceMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mQueryMap
operator|.
name|empty
argument_list|()
condition|)
block|{
name|deleteQuery
argument_list|(
name|mQueryMap
operator|.
name|begin
argument_list|()
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mMultiSampleSupport
operator|.
name|empty
argument_list|()
condition|)
block|{
operator|delete
index|[]
name|mMultiSampleSupport
operator|.
name|begin
argument_list|()
operator|->
name|second
expr_stmt|;
name|mMultiSampleSupport
operator|.
name|erase
argument_list|(
name|mMultiSampleSupport
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|type
init|=
literal|0
init|;
name|type
operator|<
name|TEXTURE_TYPE_COUNT
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|int
name|sampler
init|=
literal|0
init|;
name|sampler
operator|<
name|MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF
condition|;
name|sampler
operator|++
control|)
block|{
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|type
init|=
literal|0
init|;
name|type
operator|<
name|TEXTURE_TYPE_COUNT
condition|;
name|type
operator|++
control|)
block|{
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|i
index|]
operator|.
name|mBoundBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QUERY_TYPE_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|mState
operator|.
name|activeQuery
index|[
name|i
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mState
operator|.
name|arrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mState
operator|.
name|renderbuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mTexture2DZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mTextureCubeMapZero
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|delete
name|mVertexDataManager
expr_stmt|;
operator|delete
name|mIndexDataManager
expr_stmt|;
operator|delete
name|mBlit
expr_stmt|;
operator|delete
name|mLineLoopIB
expr_stmt|;
if|if
condition|(
name|mMaskedClearSavedState
condition|)
block|{
name|mMaskedClearSavedState
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|makeCurrent
name|void
name|Context
operator|::
name|makeCurrent
parameter_list|(
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|mDisplay
operator|=
name|display
expr_stmt|;
name|mDevice
operator|=
name|mDisplay
operator|->
name|getDevice
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|mHasBeenCurrent
condition|)
block|{
name|mDeviceCaps
operator|=
name|mDisplay
operator|->
name|getDeviceCaps
argument_list|()
expr_stmt|;
name|mVertexDataManager
operator|=
operator|new
name|VertexDataManager
argument_list|(
name|this
argument_list|,
name|mDevice
argument_list|)
expr_stmt|;
name|mIndexDataManager
operator|=
operator|new
name|IndexDataManager
argument_list|(
name|this
argument_list|,
name|mDevice
argument_list|)
expr_stmt|;
name|mBlit
operator|=
operator|new
name|Blit
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mSupportsShaderModel3
operator|=
name|mDeviceCaps
operator|.
name|PixelShaderVersion
operator|>=
name|D3DPS_VERSION
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mMaximumPointSize
operator|=
name|mDeviceCaps
operator|.
name|MaxPointSize
expr_stmt|;
name|mSupportsVertexTexture
operator|=
name|mDisplay
operator|->
name|getVertexTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsNonPower2Texture
operator|=
name|mDisplay
operator|->
name|getNonPower2TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsInstancing
operator|=
name|mDisplay
operator|->
name|getInstancingSupport
argument_list|()
expr_stmt|;
name|mMaxTextureDimension
operator|=
name|std
operator|::
name|min
argument_list|(
name|std
operator|::
name|min
argument_list|(
operator|(
name|int
operator|)
name|mDeviceCaps
operator|.
name|MaxTextureWidth
argument_list|,
operator|(
name|int
operator|)
name|mDeviceCaps
operator|.
name|MaxTextureHeight
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|gl
operator|::
name|IMPLEMENTATION_MAX_TEXTURE_SIZE
argument_list|)
expr_stmt|;
name|mMaxCubeTextureDimension
operator|=
name|std
operator|::
name|min
argument_list|(
name|mMaxTextureDimension
argument_list|,
operator|(
name|int
operator|)
name|gl
operator|::
name|IMPLEMENTATION_MAX_CUBE_MAP_TEXTURE_SIZE
argument_list|)
expr_stmt|;
name|mMaxRenderbufferDimension
operator|=
name|mMaxTextureDimension
expr_stmt|;
name|mMaxTextureLevel
operator|=
name|log2
argument_list|(
name|mMaxTextureDimension
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mMaxTextureAnisotropy
operator|=
name|mDisplay
operator|->
name|getTextureFilterAnisotropySupport
argument_list|()
expr_stmt|;
name|TRACE
argument_list|(
literal|"MaxTextureDimension=%d, MaxCubeTextureDimension=%d, MaxRenderbufferDimension=%d, MaxTextureLevel=%d, MaxTextureAnisotropy=%f"
argument_list|,
name|mMaxTextureDimension
argument_list|,
name|mMaxCubeTextureDimension
argument_list|,
name|mMaxRenderbufferDimension
argument_list|,
name|mMaxTextureLevel
argument_list|,
name|mMaxTextureAnisotropy
argument_list|)
expr_stmt|;
specifier|const
name|D3DFORMAT
name|renderBufferFormats
index|[]
init|=
block|{
name|D3DFMT_A8R8G8B8
block|,
name|D3DFMT_X8R8G8B8
block|,
name|D3DFMT_R5G6B5
block|,
name|D3DFMT_D24S8
block|}
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|renderBufferFormats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|D3DFORMAT
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|bool
modifier|*
name|multisampleArray
init|=
operator|new
name|bool
index|[
name|D3DMULTISAMPLE_16_SAMPLES
operator|+
literal|1
index|]
decl_stmt|;
name|mDisplay
operator|->
name|getMultiSampleSupport
argument_list|(
name|renderBufferFormats
index|[
name|i
index|]
argument_list|,
name|multisampleArray
argument_list|)
expr_stmt|;
name|mMultiSampleSupport
index|[
name|renderBufferFormats
index|[
name|i
index|]
index|]
operator|=
name|multisampleArray
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|D3DMULTISAMPLE_16_SAMPLES
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
name|multisampleArray
index|[
name|j
index|]
operator|&&
name|j
operator|!=
name|D3DMULTISAMPLE_NONMASKABLE
operator|&&
name|j
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
name|mMaxSupportedSamples
operator|=
name|max
expr_stmt|;
name|mSupportsEventQueries
operator|=
name|mDisplay
operator|->
name|getEventQuerySupport
argument_list|()
expr_stmt|;
name|mSupportsOcclusionQueries
operator|=
name|mDisplay
operator|->
name|getOcclusionQuerySupport
argument_list|()
expr_stmt|;
name|mSupportsDXT1Textures
operator|=
name|mDisplay
operator|->
name|getDXT1TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsDXT3Textures
operator|=
name|mDisplay
operator|->
name|getDXT3TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsDXT5Textures
operator|=
name|mDisplay
operator|->
name|getDXT5TextureSupport
argument_list|()
expr_stmt|;
name|mSupportsFloat32Textures
operator|=
name|mDisplay
operator|->
name|getFloat32TextureSupport
argument_list|(
operator|&
name|mSupportsFloat32LinearFilter
argument_list|,
operator|&
name|mSupportsFloat32RenderableTextures
argument_list|)
expr_stmt|;
name|mSupportsFloat16Textures
operator|=
name|mDisplay
operator|->
name|getFloat16TextureSupport
argument_list|(
operator|&
name|mSupportsFloat16LinearFilter
argument_list|,
operator|&
name|mSupportsFloat16RenderableTextures
argument_list|)
expr_stmt|;
name|mSupportsLuminanceTextures
operator|=
name|mDisplay
operator|->
name|getLuminanceTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsLuminanceAlphaTextures
operator|=
name|mDisplay
operator|->
name|getLuminanceAlphaTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsDepthTextures
operator|=
name|mDisplay
operator|->
name|getDepthTextureSupport
argument_list|()
expr_stmt|;
name|mSupportsTextureFilterAnisotropy
operator|=
name|mMaxTextureAnisotropy
operator|>=
literal|2.0f
expr_stmt|;
name|mSupports32bitIndices
operator|=
name|mDeviceCaps
operator|.
name|MaxVertexIndex
operator|>=
operator|(
literal|1
operator|<<
literal|16
operator|)
expr_stmt|;
name|mNumCompressedTextureFormats
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
name|mNumCompressedTextureFormats
operator|+=
literal|1
expr_stmt|;
block|}
name|initExtensionString
argument_list|()
expr_stmt|;
name|initRendererString
argument_list|()
expr_stmt|;
name|mState
operator|.
name|viewportX
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewportY
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|viewportWidth
operator|=
name|surface
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|mState
operator|.
name|viewportHeight
operator|=
name|surface
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|mState
operator|.
name|scissorX
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissorY
operator|=
literal|0
expr_stmt|;
name|mState
operator|.
name|scissorWidth
operator|=
name|surface
operator|->
name|getWidth
argument_list|()
expr_stmt|;
name|mState
operator|.
name|scissorHeight
operator|=
name|surface
operator|->
name|getHeight
argument_list|()
expr_stmt|;
name|mHasBeenCurrent
operator|=
literal|true
expr_stmt|;
block|}
comment|// Wrap the existing Direct3D 9 resources into GL objects and assign them to the '0' names
name|IDirect3DSurface9
modifier|*
name|defaultRenderTarget
init|=
name|surface
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|depthStencil
init|=
name|surface
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
name|Colorbuffer
modifier|*
name|colorbufferZero
init|=
operator|new
name|Colorbuffer
argument_list|(
name|defaultRenderTarget
argument_list|)
decl_stmt|;
name|DepthStencilbuffer
modifier|*
name|depthStencilbufferZero
init|=
operator|new
name|DepthStencilbuffer
argument_list|(
name|depthStencil
argument_list|)
decl_stmt|;
name|Framebuffer
modifier|*
name|framebufferZero
init|=
operator|new
name|DefaultFramebuffer
argument_list|(
name|colorbufferZero
argument_list|,
name|depthStencilbufferZero
argument_list|)
decl_stmt|;
name|setFramebufferZero
argument_list|(
name|framebufferZero
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultRenderTarget
condition|)
block|{
name|defaultRenderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|depthStencil
condition|)
block|{
name|depthStencil
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
comment|// Reset pixel shader to null to work around a bug that only happens with Intel GPUs.
comment|// http://crbug.com/110343
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|markAllStateDirty
argument_list|()
expr_stmt|;
block|}
comment|// This function will set all of the state-related dirty flags, so that all state is set during next pre-draw.
DECL|function|markAllStateDirty
name|void
name|Context
operator|::
name|markAllStateDirty
parameter_list|()
block|{
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|MAX_TEXTURE_IMAGE_UNITS
condition|;
name|t
operator|++
control|)
block|{
name|mAppliedTextureSerialPS
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF
condition|;
name|t
operator|++
control|)
block|{
name|mAppliedTextureSerialVS
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mAppliedProgramBinarySerial
operator|=
literal|0
expr_stmt|;
name|mAppliedRenderTargetSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedDepthbufferSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
literal|0
expr_stmt|;
name|mAppliedIBSerial
operator|=
literal|0
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|false
expr_stmt|;
name|mViewportInitialized
operator|=
literal|false
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|false
expr_stmt|;
name|mVertexDeclarationCache
operator|.
name|markStateDirty
argument_list|()
expr_stmt|;
name|mClearStateDirty
operator|=
literal|true
expr_stmt|;
name|mCullStateDirty
operator|=
literal|true
expr_stmt|;
name|mDepthStateDirty
operator|=
literal|true
expr_stmt|;
name|mMaskStateDirty
operator|=
literal|true
expr_stmt|;
name|mBlendStateDirty
operator|=
literal|true
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
name|mPolygonOffsetStateDirty
operator|=
literal|true
expr_stmt|;
name|mScissorStateDirty
operator|=
literal|true
expr_stmt|;
name|mSampleStateDirty
operator|=
literal|true
expr_stmt|;
name|mDitherStateDirty
operator|=
literal|true
expr_stmt|;
name|mFrontFaceDirty
operator|=
literal|true
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|markDxUniformsDirty
name|void
name|Context
operator|::
name|markDxUniformsDirty
parameter_list|()
block|{
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|markContextLost
name|void
name|Context
operator|::
name|markContextLost
parameter_list|()
block|{
if|if
condition|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
condition|)
name|mResetStatus
operator|=
name|GL_UNKNOWN_CONTEXT_RESET_EXT
expr_stmt|;
name|mContextLost
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|isContextLost
name|bool
name|Context
operator|::
name|isContextLost
parameter_list|()
block|{
return|return
name|mContextLost
return|;
block|}
DECL|function|setClearColor
name|void
name|Context
operator|::
name|setClearColor
parameter_list|(
name|float
name|red
parameter_list|,
name|float
name|green
parameter_list|,
name|float
name|blue
parameter_list|,
name|float
name|alpha
parameter_list|)
block|{
name|mState
operator|.
name|colorClearValue
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|mState
operator|.
name|colorClearValue
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|mState
operator|.
name|colorClearValue
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|mState
operator|.
name|colorClearValue
operator|.
name|alpha
operator|=
name|alpha
expr_stmt|;
block|}
DECL|function|setClearDepth
name|void
name|Context
operator|::
name|setClearDepth
parameter_list|(
name|float
name|depth
parameter_list|)
block|{
name|mState
operator|.
name|depthClearValue
operator|=
name|depth
expr_stmt|;
block|}
DECL|function|setClearStencil
name|void
name|Context
operator|::
name|setClearStencil
parameter_list|(
name|int
name|stencil
parameter_list|)
block|{
name|mState
operator|.
name|stencilClearValue
operator|=
name|stencil
expr_stmt|;
block|}
DECL|function|setCullFace
name|void
name|Context
operator|::
name|setCullFace
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|cullFace
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|cullFace
operator|=
name|enabled
expr_stmt|;
name|mCullStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isCullFaceEnabled
name|bool
name|Context
operator|::
name|isCullFaceEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|cullFace
return|;
block|}
DECL|function|setCullMode
name|void
name|Context
operator|::
name|setCullMode
parameter_list|(
name|GLenum
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|cullMode
operator|!=
name|mode
condition|)
block|{
name|mState
operator|.
name|cullMode
operator|=
name|mode
expr_stmt|;
name|mCullStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setFrontFace
name|void
name|Context
operator|::
name|setFrontFace
parameter_list|(
name|GLenum
name|front
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|frontFace
operator|!=
name|front
condition|)
block|{
name|mState
operator|.
name|frontFace
operator|=
name|front
expr_stmt|;
name|mFrontFaceDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setDepthTest
name|void
name|Context
operator|::
name|setDepthTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|depthTest
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|depthTest
operator|=
name|enabled
expr_stmt|;
name|mDepthStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isDepthTestEnabled
name|bool
name|Context
operator|::
name|isDepthTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|depthTest
return|;
block|}
DECL|function|setDepthFunc
name|void
name|Context
operator|::
name|setDepthFunc
parameter_list|(
name|GLenum
name|depthFunc
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|depthFunc
operator|!=
name|depthFunc
condition|)
block|{
name|mState
operator|.
name|depthFunc
operator|=
name|depthFunc
expr_stmt|;
name|mDepthStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setDepthRange
name|void
name|Context
operator|::
name|setDepthRange
parameter_list|(
name|float
name|zNear
parameter_list|,
name|float
name|zFar
parameter_list|)
block|{
name|mState
operator|.
name|zNear
operator|=
name|zNear
expr_stmt|;
name|mState
operator|.
name|zFar
operator|=
name|zFar
expr_stmt|;
block|}
DECL|function|setBlend
name|void
name|Context
operator|::
name|setBlend
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|blend
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|blend
operator|=
name|enabled
expr_stmt|;
name|mBlendStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isBlendEnabled
name|bool
name|Context
operator|::
name|isBlendEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|blend
return|;
block|}
DECL|function|setBlendFactors
name|void
name|Context
operator|::
name|setBlendFactors
parameter_list|(
name|GLenum
name|sourceRGB
parameter_list|,
name|GLenum
name|destRGB
parameter_list|,
name|GLenum
name|sourceAlpha
parameter_list|,
name|GLenum
name|destAlpha
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|sourceBlendRGB
operator|!=
name|sourceRGB
operator|||
name|mState
operator|.
name|sourceBlendAlpha
operator|!=
name|sourceAlpha
operator|||
name|mState
operator|.
name|destBlendRGB
operator|!=
name|destRGB
operator|||
name|mState
operator|.
name|destBlendAlpha
operator|!=
name|destAlpha
condition|)
block|{
name|mState
operator|.
name|sourceBlendRGB
operator|=
name|sourceRGB
expr_stmt|;
name|mState
operator|.
name|destBlendRGB
operator|=
name|destRGB
expr_stmt|;
name|mState
operator|.
name|sourceBlendAlpha
operator|=
name|sourceAlpha
expr_stmt|;
name|mState
operator|.
name|destBlendAlpha
operator|=
name|destAlpha
expr_stmt|;
name|mBlendStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setBlendColor
name|void
name|Context
operator|::
name|setBlendColor
parameter_list|(
name|float
name|red
parameter_list|,
name|float
name|green
parameter_list|,
name|float
name|blue
parameter_list|,
name|float
name|alpha
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|blendColor
operator|.
name|red
operator|!=
name|red
operator|||
name|mState
operator|.
name|blendColor
operator|.
name|green
operator|!=
name|green
operator|||
name|mState
operator|.
name|blendColor
operator|.
name|blue
operator|!=
name|blue
operator|||
name|mState
operator|.
name|blendColor
operator|.
name|alpha
operator|!=
name|alpha
condition|)
block|{
name|mState
operator|.
name|blendColor
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|mState
operator|.
name|blendColor
operator|.
name|alpha
operator|=
name|alpha
expr_stmt|;
name|mBlendStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setBlendEquation
name|void
name|Context
operator|::
name|setBlendEquation
parameter_list|(
name|GLenum
name|rgbEquation
parameter_list|,
name|GLenum
name|alphaEquation
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|blendEquationRGB
operator|!=
name|rgbEquation
operator|||
name|mState
operator|.
name|blendEquationAlpha
operator|!=
name|alphaEquation
condition|)
block|{
name|mState
operator|.
name|blendEquationRGB
operator|=
name|rgbEquation
expr_stmt|;
name|mState
operator|.
name|blendEquationAlpha
operator|=
name|alphaEquation
expr_stmt|;
name|mBlendStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setStencilTest
name|void
name|Context
operator|::
name|setStencilTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilTest
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|stencilTest
operator|=
name|enabled
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isStencilTestEnabled
name|bool
name|Context
operator|::
name|isStencilTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|stencilTest
return|;
block|}
DECL|function|setStencilParams
name|void
name|Context
operator|::
name|setStencilParams
parameter_list|(
name|GLenum
name|stencilFunc
parameter_list|,
name|GLint
name|stencilRef
parameter_list|,
name|GLuint
name|stencilMask
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilFunc
operator|!=
name|stencilFunc
operator|||
name|mState
operator|.
name|stencilRef
operator|!=
name|stencilRef
operator|||
name|mState
operator|.
name|stencilMask
operator|!=
name|stencilMask
condition|)
block|{
name|mState
operator|.
name|stencilFunc
operator|=
name|stencilFunc
expr_stmt|;
name|mState
operator|.
name|stencilRef
operator|=
operator|(
name|stencilRef
operator|>
literal|0
operator|)
condition|?
name|stencilRef
else|:
literal|0
expr_stmt|;
name|mState
operator|.
name|stencilMask
operator|=
name|stencilMask
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setStencilBackParams
name|void
name|Context
operator|::
name|setStencilBackParams
parameter_list|(
name|GLenum
name|stencilBackFunc
parameter_list|,
name|GLint
name|stencilBackRef
parameter_list|,
name|GLuint
name|stencilBackMask
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilBackFunc
operator|!=
name|stencilBackFunc
operator|||
name|mState
operator|.
name|stencilBackRef
operator|!=
name|stencilBackRef
operator|||
name|mState
operator|.
name|stencilBackMask
operator|!=
name|stencilBackMask
condition|)
block|{
name|mState
operator|.
name|stencilBackFunc
operator|=
name|stencilBackFunc
expr_stmt|;
name|mState
operator|.
name|stencilBackRef
operator|=
operator|(
name|stencilBackRef
operator|>
literal|0
operator|)
condition|?
name|stencilBackRef
else|:
literal|0
expr_stmt|;
name|mState
operator|.
name|stencilBackMask
operator|=
name|stencilBackMask
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setStencilWritemask
name|void
name|Context
operator|::
name|setStencilWritemask
parameter_list|(
name|GLuint
name|stencilWritemask
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilWritemask
operator|!=
name|stencilWritemask
condition|)
block|{
name|mState
operator|.
name|stencilWritemask
operator|=
name|stencilWritemask
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setStencilBackWritemask
name|void
name|Context
operator|::
name|setStencilBackWritemask
parameter_list|(
name|GLuint
name|stencilBackWritemask
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilBackWritemask
operator|!=
name|stencilBackWritemask
condition|)
block|{
name|mState
operator|.
name|stencilBackWritemask
operator|=
name|stencilBackWritemask
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setStencilOperations
name|void
name|Context
operator|::
name|setStencilOperations
parameter_list|(
name|GLenum
name|stencilFail
parameter_list|,
name|GLenum
name|stencilPassDepthFail
parameter_list|,
name|GLenum
name|stencilPassDepthPass
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilFail
operator|!=
name|stencilFail
operator|||
name|mState
operator|.
name|stencilPassDepthFail
operator|!=
name|stencilPassDepthFail
operator|||
name|mState
operator|.
name|stencilPassDepthPass
operator|!=
name|stencilPassDepthPass
condition|)
block|{
name|mState
operator|.
name|stencilFail
operator|=
name|stencilFail
expr_stmt|;
name|mState
operator|.
name|stencilPassDepthFail
operator|=
name|stencilPassDepthFail
expr_stmt|;
name|mState
operator|.
name|stencilPassDepthPass
operator|=
name|stencilPassDepthPass
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setStencilBackOperations
name|void
name|Context
operator|::
name|setStencilBackOperations
parameter_list|(
name|GLenum
name|stencilBackFail
parameter_list|,
name|GLenum
name|stencilBackPassDepthFail
parameter_list|,
name|GLenum
name|stencilBackPassDepthPass
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilBackFail
operator|!=
name|stencilBackFail
operator|||
name|mState
operator|.
name|stencilBackPassDepthFail
operator|!=
name|stencilBackPassDepthFail
operator|||
name|mState
operator|.
name|stencilBackPassDepthPass
operator|!=
name|stencilBackPassDepthPass
condition|)
block|{
name|mState
operator|.
name|stencilBackFail
operator|=
name|stencilBackFail
expr_stmt|;
name|mState
operator|.
name|stencilBackPassDepthFail
operator|=
name|stencilBackPassDepthFail
expr_stmt|;
name|mState
operator|.
name|stencilBackPassDepthPass
operator|=
name|stencilBackPassDepthPass
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setPolygonOffsetFill
name|void
name|Context
operator|::
name|setPolygonOffsetFill
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|polygonOffsetFill
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|polygonOffsetFill
operator|=
name|enabled
expr_stmt|;
name|mPolygonOffsetStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isPolygonOffsetFillEnabled
name|bool
name|Context
operator|::
name|isPolygonOffsetFillEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|polygonOffsetFill
return|;
block|}
DECL|function|setPolygonOffsetParams
name|void
name|Context
operator|::
name|setPolygonOffsetParams
parameter_list|(
name|GLfloat
name|factor
parameter_list|,
name|GLfloat
name|units
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|polygonOffsetFactor
operator|!=
name|factor
operator|||
name|mState
operator|.
name|polygonOffsetUnits
operator|!=
name|units
condition|)
block|{
name|mState
operator|.
name|polygonOffsetFactor
operator|=
name|factor
expr_stmt|;
name|mState
operator|.
name|polygonOffsetUnits
operator|=
name|units
expr_stmt|;
name|mPolygonOffsetStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setSampleAlphaToCoverage
name|void
name|Context
operator|::
name|setSampleAlphaToCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|sampleAlphaToCoverage
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|sampleAlphaToCoverage
operator|=
name|enabled
expr_stmt|;
name|mSampleStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isSampleAlphaToCoverageEnabled
name|bool
name|Context
operator|::
name|isSampleAlphaToCoverageEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|sampleAlphaToCoverage
return|;
block|}
DECL|function|setSampleCoverage
name|void
name|Context
operator|::
name|setSampleCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|sampleCoverage
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|sampleCoverage
operator|=
name|enabled
expr_stmt|;
name|mSampleStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isSampleCoverageEnabled
name|bool
name|Context
operator|::
name|isSampleCoverageEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|sampleCoverage
return|;
block|}
DECL|function|setSampleCoverageParams
name|void
name|Context
operator|::
name|setSampleCoverageParams
parameter_list|(
name|GLclampf
name|value
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|sampleCoverageValue
operator|!=
name|value
operator|||
name|mState
operator|.
name|sampleCoverageInvert
operator|!=
name|invert
condition|)
block|{
name|mState
operator|.
name|sampleCoverageValue
operator|=
name|value
expr_stmt|;
name|mState
operator|.
name|sampleCoverageInvert
operator|=
name|invert
expr_stmt|;
name|mSampleStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setScissorTest
name|void
name|Context
operator|::
name|setScissorTest
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|scissorTest
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|scissorTest
operator|=
name|enabled
expr_stmt|;
name|mScissorStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isScissorTestEnabled
name|bool
name|Context
operator|::
name|isScissorTestEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|scissorTest
return|;
block|}
DECL|function|setDither
name|void
name|Context
operator|::
name|setDither
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|dither
operator|!=
name|enabled
condition|)
block|{
name|mState
operator|.
name|dither
operator|=
name|enabled
expr_stmt|;
name|mDitherStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|isDitherEnabled
name|bool
name|Context
operator|::
name|isDitherEnabled
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|dither
return|;
block|}
DECL|function|setLineWidth
name|void
name|Context
operator|::
name|setLineWidth
parameter_list|(
name|GLfloat
name|width
parameter_list|)
block|{
name|mState
operator|.
name|lineWidth
operator|=
name|width
expr_stmt|;
block|}
DECL|function|setGenerateMipmapHint
name|void
name|Context
operator|::
name|setGenerateMipmapHint
parameter_list|(
name|GLenum
name|hint
parameter_list|)
block|{
name|mState
operator|.
name|generateMipmapHint
operator|=
name|hint
expr_stmt|;
block|}
DECL|function|setFragmentShaderDerivativeHint
name|void
name|Context
operator|::
name|setFragmentShaderDerivativeHint
parameter_list|(
name|GLenum
name|hint
parameter_list|)
block|{
name|mState
operator|.
name|fragmentShaderDerivativeHint
operator|=
name|hint
expr_stmt|;
comment|// TODO: Propagate the hint to shader translator so we can write
comment|// ddx, ddx_coarse, or ddx_fine depending on the hint.
comment|// Ignore for now. It is valid for implementations to ignore hint.
block|}
DECL|function|setViewportParams
name|void
name|Context
operator|::
name|setViewportParams
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
name|mState
operator|.
name|viewportX
operator|=
name|x
expr_stmt|;
name|mState
operator|.
name|viewportY
operator|=
name|y
expr_stmt|;
name|mState
operator|.
name|viewportWidth
operator|=
name|width
expr_stmt|;
name|mState
operator|.
name|viewportHeight
operator|=
name|height
expr_stmt|;
block|}
DECL|function|setScissorParams
name|void
name|Context
operator|::
name|setScissorParams
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|scissorX
operator|!=
name|x
operator|||
name|mState
operator|.
name|scissorY
operator|!=
name|y
operator|||
name|mState
operator|.
name|scissorWidth
operator|!=
name|width
operator|||
name|mState
operator|.
name|scissorHeight
operator|!=
name|height
condition|)
block|{
name|mState
operator|.
name|scissorX
operator|=
name|x
expr_stmt|;
name|mState
operator|.
name|scissorY
operator|=
name|y
expr_stmt|;
name|mState
operator|.
name|scissorWidth
operator|=
name|width
expr_stmt|;
name|mState
operator|.
name|scissorHeight
operator|=
name|height
expr_stmt|;
name|mScissorStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setColorMask
name|void
name|Context
operator|::
name|setColorMask
parameter_list|(
name|bool
name|red
parameter_list|,
name|bool
name|green
parameter_list|,
name|bool
name|blue
parameter_list|,
name|bool
name|alpha
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|colorMaskRed
operator|!=
name|red
operator|||
name|mState
operator|.
name|colorMaskGreen
operator|!=
name|green
operator|||
name|mState
operator|.
name|colorMaskBlue
operator|!=
name|blue
operator|||
name|mState
operator|.
name|colorMaskAlpha
operator|!=
name|alpha
condition|)
block|{
name|mState
operator|.
name|colorMaskRed
operator|=
name|red
expr_stmt|;
name|mState
operator|.
name|colorMaskGreen
operator|=
name|green
expr_stmt|;
name|mState
operator|.
name|colorMaskBlue
operator|=
name|blue
expr_stmt|;
name|mState
operator|.
name|colorMaskAlpha
operator|=
name|alpha
expr_stmt|;
name|mMaskStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setDepthMask
name|void
name|Context
operator|::
name|setDepthMask
parameter_list|(
name|bool
name|mask
parameter_list|)
block|{
if|if
condition|(
name|mState
operator|.
name|depthMask
operator|!=
name|mask
condition|)
block|{
name|mState
operator|.
name|depthMask
operator|=
name|mask
expr_stmt|;
name|mMaskStateDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setActiveSampler
name|void
name|Context
operator|::
name|setActiveSampler
parameter_list|(
name|unsigned
name|int
name|active
parameter_list|)
block|{
name|mState
operator|.
name|activeSampler
operator|=
name|active
expr_stmt|;
block|}
DECL|function|getReadFramebufferHandle
name|GLuint
name|Context
operator|::
name|getReadFramebufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|readFramebuffer
return|;
block|}
DECL|function|getDrawFramebufferHandle
name|GLuint
name|Context
operator|::
name|getDrawFramebufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|drawFramebuffer
return|;
block|}
DECL|function|getRenderbufferHandle
name|GLuint
name|Context
operator|::
name|getRenderbufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|renderbuffer
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getArrayBufferHandle
name|GLuint
name|Context
operator|::
name|getArrayBufferHandle
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|arrayBuffer
operator|.
name|id
argument_list|()
return|;
block|}
DECL|function|getActiveQuery
name|GLuint
name|Context
operator|::
name|getActiveQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
specifier|const
block|{
name|Query
modifier|*
name|queryObject
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
name|queryObject
operator|=
name|mState
operator|.
name|activeQuery
index|[
name|QUERY_ANY_SAMPLES_PASSED
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
name|queryObject
operator|=
name|mState
operator|.
name|activeQuery
index|[
name|QUERY_ANY_SAMPLES_PASSED_CONSERVATIVE
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryObject
condition|)
block|{
return|return
name|queryObject
operator|->
name|id
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|function|setEnableVertexAttribArray
name|void
name|Context
operator|::
name|setEnableVertexAttribArray
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mArrayEnabled
operator|=
name|enabled
expr_stmt|;
block|}
DECL|function|getVertexAttribState
specifier|const
name|VertexAttribute
modifier|&
name|Context
operator|::
name|getVertexAttribState
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|)
block|{
return|return
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
return|;
block|}
DECL|function|setVertexAttribState
name|void
name|Context
operator|::
name|setVertexAttribState
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|,
name|Buffer
modifier|*
name|boundBuffer
parameter_list|,
name|GLint
name|size
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|bool
name|normalized
parameter_list|,
name|GLsizei
name|stride
parameter_list|,
specifier|const
name|void
modifier|*
name|pointer
parameter_list|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mBoundBuffer
operator|.
name|set
argument_list|(
name|boundBuffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mSize
operator|=
name|size
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mType
operator|=
name|type
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mNormalized
operator|=
name|normalized
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mStride
operator|=
name|stride
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mPointer
operator|=
name|pointer
expr_stmt|;
block|}
DECL|function|getVertexAttribPointer
specifier|const
name|void
modifier|*
name|Context
operator|::
name|getVertexAttribPointer
parameter_list|(
name|unsigned
name|int
name|attribNum
parameter_list|)
specifier|const
block|{
return|return
name|mState
operator|.
name|vertexAttribute
index|[
name|attribNum
index|]
operator|.
name|mPointer
return|;
block|}
DECL|function|getVertexAttributes
specifier|const
name|VertexAttributeArray
modifier|&
name|Context
operator|::
name|getVertexAttributes
parameter_list|()
block|{
return|return
name|mState
operator|.
name|vertexAttribute
return|;
block|}
DECL|function|setPackAlignment
name|void
name|Context
operator|::
name|setPackAlignment
parameter_list|(
name|GLint
name|alignment
parameter_list|)
block|{
name|mState
operator|.
name|packAlignment
operator|=
name|alignment
expr_stmt|;
block|}
DECL|function|getPackAlignment
name|GLint
name|Context
operator|::
name|getPackAlignment
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|packAlignment
return|;
block|}
DECL|function|setUnpackAlignment
name|void
name|Context
operator|::
name|setUnpackAlignment
parameter_list|(
name|GLint
name|alignment
parameter_list|)
block|{
name|mState
operator|.
name|unpackAlignment
operator|=
name|alignment
expr_stmt|;
block|}
DECL|function|getUnpackAlignment
name|GLint
name|Context
operator|::
name|getUnpackAlignment
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|unpackAlignment
return|;
block|}
DECL|function|setPackReverseRowOrder
name|void
name|Context
operator|::
name|setPackReverseRowOrder
parameter_list|(
name|bool
name|reverseRowOrder
parameter_list|)
block|{
name|mState
operator|.
name|packReverseRowOrder
operator|=
name|reverseRowOrder
expr_stmt|;
block|}
DECL|function|getPackReverseRowOrder
name|bool
name|Context
operator|::
name|getPackReverseRowOrder
parameter_list|()
specifier|const
block|{
return|return
name|mState
operator|.
name|packReverseRowOrder
return|;
block|}
DECL|function|createBuffer
name|GLuint
name|Context
operator|::
name|createBuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createBuffer
argument_list|()
return|;
block|}
DECL|function|createProgram
name|GLuint
name|Context
operator|::
name|createProgram
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createProgram
argument_list|()
return|;
block|}
DECL|function|createShader
name|GLuint
name|Context
operator|::
name|createShader
parameter_list|(
name|GLenum
name|type
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|createShader
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|function|createTexture
name|GLuint
name|Context
operator|::
name|createTexture
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createTexture
argument_list|()
return|;
block|}
DECL|function|createRenderbuffer
name|GLuint
name|Context
operator|::
name|createRenderbuffer
parameter_list|()
block|{
return|return
name|mResourceManager
operator|->
name|createRenderbuffer
argument_list|()
return|;
block|}
comment|// Returns an unused framebuffer name
DECL|function|createFramebuffer
name|GLuint
name|Context
operator|::
name|createFramebuffer
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFramebufferHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFramebufferMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|createFence
name|GLuint
name|Context
operator|::
name|createFence
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mFenceHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mFenceMap
index|[
name|handle
index|]
operator|=
operator|new
name|Fence
argument_list|(
name|mDisplay
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
comment|// Returns an unused query name
DECL|function|createQuery
name|GLuint
name|Context
operator|::
name|createQuery
parameter_list|()
block|{
name|GLuint
name|handle
init|=
name|mQueryHandleAllocator
operator|.
name|allocate
argument_list|()
decl_stmt|;
name|mQueryMap
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|handle
return|;
block|}
DECL|function|deleteBuffer
name|void
name|Context
operator|::
name|deleteBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|detachBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteShader
name|void
name|Context
operator|::
name|deleteShader
parameter_list|(
name|GLuint
name|shader
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteShader
argument_list|(
name|shader
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteProgram
name|void
name|Context
operator|::
name|deleteProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|mResourceManager
operator|->
name|deleteProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteTexture
name|void
name|Context
operator|::
name|deleteTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|texture
argument_list|)
condition|)
block|{
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteRenderbuffer
name|void
name|Context
operator|::
name|deleteRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
if|if
condition|(
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
condition|)
block|{
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
name|mResourceManager
operator|->
name|deleteRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|deleteFramebuffer
name|void
name|Context
operator|::
name|deleteFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
name|FramebufferMap
operator|::
name|iterator
name|framebufferObject
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|framebuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebufferObject
operator|!=
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|detachFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
name|mFramebufferHandleAllocator
operator|.
name|release
argument_list|(
name|framebufferObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|framebufferObject
operator|->
name|second
expr_stmt|;
name|mFramebufferMap
operator|.
name|erase
argument_list|(
name|framebufferObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteFence
name|void
name|Context
operator|::
name|deleteFence
parameter_list|(
name|GLuint
name|fence
parameter_list|)
block|{
name|FenceMap
operator|::
name|iterator
name|fenceObject
init|=
name|mFenceMap
operator|.
name|find
argument_list|(
name|fence
argument_list|)
decl_stmt|;
if|if
condition|(
name|fenceObject
operator|!=
name|mFenceMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mFenceHandleAllocator
operator|.
name|release
argument_list|(
name|fenceObject
operator|->
name|first
argument_list|)
expr_stmt|;
operator|delete
name|fenceObject
operator|->
name|second
expr_stmt|;
name|mFenceMap
operator|.
name|erase
argument_list|(
name|fenceObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|deleteQuery
name|void
name|Context
operator|::
name|deleteQuery
parameter_list|(
name|GLuint
name|query
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|queryObject
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryObject
operator|!=
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|mQueryHandleAllocator
operator|.
name|release
argument_list|(
name|queryObject
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryObject
operator|->
name|second
condition|)
block|{
name|queryObject
operator|->
name|second
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
name|mQueryMap
operator|.
name|erase
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getBuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getBuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getShader
name|Shader
modifier|*
name|Context
operator|::
name|getShader
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getShader
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getProgram
name|Program
modifier|*
name|Context
operator|::
name|getProgram
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getTexture
name|Texture
modifier|*
name|Context
operator|::
name|getTexture
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getTexture
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getRenderbuffer
name|Renderbuffer
modifier|*
name|Context
operator|::
name|getRenderbuffer
parameter_list|(
name|GLuint
name|handle
parameter_list|)
block|{
return|return
name|mResourceManager
operator|->
name|getRenderbuffer
argument_list|(
name|handle
argument_list|)
return|;
block|}
DECL|function|getReadFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getReadFramebuffer
parameter_list|()
block|{
return|return
name|getFramebuffer
argument_list|(
name|mState
operator|.
name|readFramebuffer
argument_list|)
return|;
block|}
DECL|function|getDrawFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getDrawFramebuffer
parameter_list|()
block|{
return|return
name|mBoundDrawFramebuffer
return|;
block|}
DECL|function|bindArrayBuffer
name|void
name|Context
operator|::
name|bindArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|arrayBuffer
operator|.
name|set
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindElementArrayBuffer
name|void
name|Context
operator|::
name|bindElementArrayBuffer
parameter_list|(
name|unsigned
name|int
name|buffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkBufferAllocation
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|set
argument_list|(
name|getBuffer
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTexture2D
name|void
name|Context
operator|::
name|bindTexture2D
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_2D
argument_list|)
expr_stmt|;
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_2D
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|set
argument_list|(
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindTextureCubeMap
name|void
name|Context
operator|::
name|bindTextureCubeMap
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkTextureAllocation
argument_list|(
name|texture
argument_list|,
name|TEXTURE_CUBE
argument_list|)
expr_stmt|;
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_CUBE
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|set
argument_list|(
name|getTexture
argument_list|(
name|texture
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|bindReadFramebuffer
name|void
name|Context
operator|::
name|bindReadFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|()
expr_stmt|;
block|}
name|mState
operator|.
name|readFramebuffer
operator|=
name|framebuffer
expr_stmt|;
block|}
DECL|function|bindDrawFramebuffer
name|void
name|Context
operator|::
name|bindDrawFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
condition|)
block|{
name|mFramebufferMap
index|[
name|framebuffer
index|]
operator|=
operator|new
name|Framebuffer
argument_list|()
expr_stmt|;
block|}
name|mState
operator|.
name|drawFramebuffer
operator|=
name|framebuffer
expr_stmt|;
name|mBoundDrawFramebuffer
operator|=
name|getFramebuffer
argument_list|(
name|framebuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|bindRenderbuffer
name|void
name|Context
operator|::
name|bindRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
name|mResourceManager
operator|->
name|checkRenderbufferAllocation
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
name|mState
operator|.
name|renderbuffer
operator|.
name|set
argument_list|(
name|getRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|useProgram
name|void
name|Context
operator|::
name|useProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|GLuint
name|priorProgram
init|=
name|mState
operator|.
name|currentProgram
decl_stmt|;
name|mState
operator|.
name|currentProgram
operator|=
name|program
expr_stmt|;
comment|// Must switch before trying to delete, otherwise it only gets flagged.
if|if
condition|(
name|priorProgram
operator|!=
name|program
condition|)
block|{
name|Program
modifier|*
name|newProgram
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|Program
modifier|*
name|oldProgram
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|priorProgram
argument_list|)
decl_stmt|;
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|newProgram
condition|)
block|{
name|newProgram
operator|->
name|addRef
argument_list|()
expr_stmt|;
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|newProgram
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldProgram
condition|)
block|{
name|oldProgram
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|linkProgram
name|void
name|Context
operator|::
name|linkProgram
parameter_list|(
name|GLuint
name|program
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|linked
init|=
name|programObject
operator|->
name|link
argument_list|()
decl_stmt|;
comment|// if the current program was relinked successfully we
comment|// need to install the new executables
if|if
condition|(
name|linked
operator|&&
name|program
operator|==
name|mState
operator|.
name|currentProgram
condition|)
block|{
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|programObject
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|setProgramBinary
name|void
name|Context
operator|::
name|setProgramBinary
parameter_list|(
name|GLuint
name|program
parameter_list|,
specifier|const
name|void
modifier|*
name|binary
parameter_list|,
name|GLint
name|length
parameter_list|)
block|{
name|Program
modifier|*
name|programObject
init|=
name|mResourceManager
operator|->
name|getProgram
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|bool
name|loaded
init|=
name|programObject
operator|->
name|setProgramBinary
argument_list|(
name|binary
argument_list|,
name|length
argument_list|)
decl_stmt|;
comment|// if the current program was reloaded successfully we
comment|// need to install the new executables
if|if
condition|(
name|loaded
operator|&&
name|program
operator|==
name|mState
operator|.
name|currentProgram
condition|)
block|{
name|mCurrentProgramBinary
operator|.
name|set
argument_list|(
name|programObject
operator|->
name|getProgramBinary
argument_list|()
argument_list|)
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|beginQuery
name|void
name|Context
operator|::
name|beginQuery
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|query
parameter_list|)
block|{
comment|// From EXT_occlusion_query_boolean: If BeginQueryEXT is called with an<id>
comment|// of zero, if the active query object name for<target> is non-zero (for the
comment|// targets ANY_SAMPLES_PASSED_EXT and ANY_SAMPLES_PASSED_CONSERVATIVE_EXT, if
comment|// the active query for either target is non-zero), if<id> is the name of an
comment|// existing query object whose type does not match<target>, or if<id> is the
comment|// active query object name for any query type, the error INVALID_OPERATION is
comment|// generated.
comment|// Ensure no other queries are active
comment|// NOTE: If other queries than occlusion are supported, we will need to check
comment|// separately that:
comment|//    a) The query ID passed is not the current active query for any target/type
comment|//    b) There are no active queries for the requested target (and in the case
comment|//       of GL_ANY_SAMPLES_PASSED_EXT and GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT,
comment|//       no query may be active for either if glBeginQuery targets either.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QUERY_TYPE_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mState
operator|.
name|activeQuery
index|[
name|i
index|]
operator|.
name|get
argument_list|()
operator|!=
name|NULL
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
name|QueryType
name|qType
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED
expr_stmt|;
break|break;
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED_CONSERVATIVE
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|getQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
name|target
argument_list|)
decl_stmt|;
comment|// check that name was obtained with glGenQueries
if|if
condition|(
operator|!
name|queryObject
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// check for type mismatch
if|if
condition|(
name|queryObject
operator|->
name|getType
argument_list|()
operator|!=
name|target
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// set query as active for specified target
name|mState
operator|.
name|activeQuery
index|[
name|qType
index|]
operator|.
name|set
argument_list|(
name|queryObject
argument_list|)
expr_stmt|;
comment|// begin query
name|queryObject
operator|->
name|begin
argument_list|()
expr_stmt|;
block|}
DECL|function|endQuery
name|void
name|Context
operator|::
name|endQuery
parameter_list|(
name|GLenum
name|target
parameter_list|)
block|{
name|QueryType
name|qType
decl_stmt|;
switch|switch
condition|(
name|target
condition|)
block|{
case|case
name|GL_ANY_SAMPLES_PASSED_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED
expr_stmt|;
break|break;
case|case
name|GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT
case|:
name|qType
operator|=
name|QUERY_ANY_SAMPLES_PASSED_CONSERVATIVE
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
name|Query
modifier|*
name|queryObject
init|=
name|mState
operator|.
name|activeQuery
index|[
name|qType
index|]
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryObject
operator|==
name|NULL
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|queryObject
operator|->
name|end
argument_list|()
expr_stmt|;
name|mState
operator|.
name|activeQuery
index|[
name|qType
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
DECL|function|setFramebufferZero
name|void
name|Context
operator|::
name|setFramebufferZero
parameter_list|(
name|Framebuffer
modifier|*
name|buffer
parameter_list|)
block|{
operator|delete
name|mFramebufferMap
index|[
literal|0
index|]
expr_stmt|;
name|mFramebufferMap
index|[
literal|0
index|]
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|mState
operator|.
name|drawFramebuffer
operator|==
literal|0
condition|)
block|{
name|mBoundDrawFramebuffer
operator|=
name|buffer
expr_stmt|;
block|}
block|}
DECL|function|setRenderbufferStorage
name|void
name|Context
operator|::
name|setRenderbufferStorage
parameter_list|(
name|RenderbufferStorage
modifier|*
name|renderbuffer
parameter_list|)
block|{
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|mState
operator|.
name|renderbuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|renderbufferObject
operator|->
name|setStorage
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
DECL|function|getFramebuffer
name|Framebuffer
modifier|*
name|Context
operator|::
name|getFramebuffer
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
block|{
name|FramebufferMap
operator|::
name|iterator
name|framebuffer
init|=
name|mFramebufferMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|==
name|mFramebufferMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|framebuffer
operator|->
name|second
return|;
block|}
block|}
DECL|function|getFence
name|Fence
modifier|*
name|Context
operator|::
name|getFence
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|)
block|{
name|FenceMap
operator|::
name|iterator
name|fence
init|=
name|mFenceMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|mFenceMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|fence
operator|->
name|second
return|;
block|}
block|}
DECL|function|getQuery
name|Query
modifier|*
name|Context
operator|::
name|getQuery
parameter_list|(
name|unsigned
name|int
name|handle
parameter_list|,
name|bool
name|create
parameter_list|,
name|GLenum
name|type
parameter_list|)
block|{
name|QueryMap
operator|::
name|iterator
name|query
init|=
name|mQueryMap
operator|.
name|find
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|==
name|mQueryMap
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|query
operator|->
name|second
operator|&&
name|create
condition|)
block|{
name|query
operator|->
name|second
operator|=
operator|new
name|Query
argument_list|(
name|handle
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|query
operator|->
name|second
operator|->
name|addRef
argument_list|()
expr_stmt|;
block|}
return|return
name|query
operator|->
name|second
return|;
block|}
block|}
DECL|function|getArrayBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getArrayBuffer
parameter_list|()
block|{
return|return
name|mState
operator|.
name|arrayBuffer
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getElementArrayBuffer
name|Buffer
modifier|*
name|Context
operator|::
name|getElementArrayBuffer
parameter_list|()
block|{
return|return
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getCurrentProgramBinary
name|ProgramBinary
modifier|*
name|Context
operator|::
name|getCurrentProgramBinary
parameter_list|()
block|{
return|return
name|mCurrentProgramBinary
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getTexture2D
name|Texture2D
modifier|*
name|Context
operator|::
name|getTexture2D
parameter_list|()
block|{
return|return
cast|static_cast
argument_list|<
name|Texture2D
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|activeSampler
argument_list|,
name|TEXTURE_2D
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getTextureCubeMap
name|TextureCubeMap
modifier|*
name|Context
operator|::
name|getTextureCubeMap
parameter_list|()
block|{
return|return
cast|static_cast
argument_list|<
name|TextureCubeMap
operator|*
argument_list|>
argument_list|(
name|getSamplerTexture
argument_list|(
name|mState
operator|.
name|activeSampler
argument_list|,
name|TEXTURE_CUBE
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getSamplerTexture
name|Texture
modifier|*
name|Context
operator|::
name|getSamplerTexture
parameter_list|(
name|unsigned
name|int
name|sampler
parameter_list|,
name|TextureType
name|type
parameter_list|)
block|{
name|GLuint
name|texid
init|=
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
name|texid
operator|==
literal|0
condition|)
comment|// Special case: 0 refers to different initial textures based on the target
block|{
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
case|case
name|TEXTURE_2D
case|:
return|return
name|mTexture2DZero
operator|.
name|get
argument_list|()
return|;
case|case
name|TEXTURE_CUBE
case|:
return|return
name|mTextureCubeMapZero
operator|.
name|get
argument_list|()
return|;
block|}
block|}
return|return
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|get
argument_list|()
return|;
block|}
DECL|function|getBooleanv
name|bool
name|Context
operator|::
name|getBooleanv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLboolean
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SHADER_COMPILER
case|:
operator|*
name|params
operator|=
name|GL_TRUE
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sampleCoverageInvert
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_WRITEMASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthMask
expr_stmt|;
break|break;
case|case
name|GL_COLOR_WRITEMASK
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|colorMaskRed
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|colorMaskGreen
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|colorMaskBlue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|colorMaskAlpha
expr_stmt|;
break|break;
case|case
name|GL_CULL_FACE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|cullFace
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|polygonOffsetFill
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sampleAlphaToCoverage
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sampleCoverage
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_TEST
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|scissorTest
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_TEST
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilTest
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_TEST
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthTest
expr_stmt|;
break|break;
case|case
name|GL_BLEND
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blend
expr_stmt|;
break|break;
case|case
name|GL_DITHER
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|dither
expr_stmt|;
break|break;
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
operator|*
name|params
operator|=
name|mRobustAccess
condition|?
name|GL_TRUE
else|:
name|GL_FALSE
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getFloatv
name|bool
name|Context
operator|::
name|getFloatv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLfloat
modifier|*
name|params
parameter_list|)
block|{
comment|// Please note: DEPTH_CLEAR_VALUE is included in our internal getFloatv implementation
comment|// because it is stored as a float, despite the fact that the GL ES 2.0 spec names
comment|// GetIntegerv as its native query function. As it would require conversion in any
comment|// case, this should make no difference to the calling application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_LINE_WIDTH
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|lineWidth
expr_stmt|;
break|break;
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sampleCoverageValue
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthClearValue
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|polygonOffsetFactor
expr_stmt|;
break|break;
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|polygonOffsetUnits
expr_stmt|;
break|break;
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|gl
operator|::
name|ALIASED_LINE_WIDTH_RANGE_MIN
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|gl
operator|::
name|ALIASED_LINE_WIDTH_RANGE_MAX
expr_stmt|;
break|break;
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|gl
operator|::
name|ALIASED_POINT_SIZE_RANGE_MIN
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|getMaximumPointSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_RANGE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|zNear
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|zFar
expr_stmt|;
break|break;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|red
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|green
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|blue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|colorClearValue
operator|.
name|alpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_COLOR
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|red
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|green
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|blue
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|blendColor
operator|.
name|alpha
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|params
operator|=
name|mMaxTextureAnisotropy
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getIntegerv
name|bool
name|Context
operator|::
name|getIntegerv
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLint
modifier|*
name|params
parameter_list|)
block|{
comment|// Please note: DEPTH_CLEAR_VALUE is not included in our internal getIntegerv implementation
comment|// because it is stored as a float, despite the fact that the GL ES 2.0 spec names
comment|// GetIntegerv as its native query function. As it would require conversion in any
comment|// case, this should make no difference to the calling application. You may find it in
comment|// Context::getFloatv.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
operator|*
name|params
operator|=
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|gl
operator|::
name|MAX_VERTEX_UNIFORM_VECTORS
expr_stmt|;
break|break;
case|case
name|GL_MAX_VARYING_VECTORS
case|:
operator|*
name|params
operator|=
name|getMaximumVaryingVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|getMaximumCombinedTextureImageUnits
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|getMaximumVertexTextureImageUnits
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
operator|*
name|params
operator|=
name|gl
operator|::
name|MAX_TEXTURE_IMAGE_UNITS
expr_stmt|;
break|break;
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
operator|*
name|params
operator|=
name|getMaximumFragmentUniformVectors
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
operator|*
name|params
operator|=
name|getMaximumRenderbufferDimension
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
operator|*
name|params
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
comment|/* no shader binary formats are supported */
break|break;
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|arrayBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
comment|//case GL_FRAMEBUFFER_BINDING:            // now equivalent to GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|case
name|GL_DRAW_FRAMEBUFFER_BINDING_ANGLE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|drawFramebuffer
expr_stmt|;
break|break;
case|case
name|GL_READ_FRAMEBUFFER_BINDING_ANGLE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|readFramebuffer
expr_stmt|;
break|break;
case|case
name|GL_RENDERBUFFER_BINDING
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|renderbuffer
operator|.
name|id
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_CURRENT_PROGRAM
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|currentProgram
expr_stmt|;
break|break;
case|case
name|GL_PACK_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|packAlignment
expr_stmt|;
break|break;
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|packReverseRowOrder
expr_stmt|;
break|break;
case|case
name|GL_UNPACK_ALIGNMENT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|unpackAlignment
expr_stmt|;
break|break;
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|generateMipmapHint
expr_stmt|;
break|break;
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|fragmentShaderDerivativeHint
expr_stmt|;
break|break;
case|case
name|GL_ACTIVE_TEXTURE
case|:
operator|*
name|params
operator|=
operator|(
name|mState
operator|.
name|activeSampler
operator|+
name|GL_TEXTURE0
operator|)
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_FUNC
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilFunc
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_REF
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilRef
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_VALUE_MASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilMask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_FUNC
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackFunc
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_REF
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackRef
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackMask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilPassDepthFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilPassDepthPass
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackPassDepthFail
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackPassDepthPass
expr_stmt|;
break|break;
case|case
name|GL_DEPTH_FUNC
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|depthFunc
expr_stmt|;
break|break;
case|case
name|GL_BLEND_SRC_RGB
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sourceBlendRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_SRC_ALPHA
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|sourceBlendAlpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_DST_RGB
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|destBlendRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_DST_ALPHA
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|destBlendAlpha
expr_stmt|;
break|break;
case|case
name|GL_BLEND_EQUATION_RGB
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blendEquationRGB
expr_stmt|;
break|break;
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|blendEquationAlpha
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_WRITEMASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilWritemask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilBackWritemask
expr_stmt|;
break|break;
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|stencilClearValue
expr_stmt|;
break|break;
case|case
name|GL_SUBPIXEL_BITS
case|:
operator|*
name|params
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|getMaximumTextureDimension
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
operator|*
name|params
operator|=
name|getMaximumCubeTextureDimension
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mNumCompressedTextureFormats
expr_stmt|;
break|break;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
block|{
name|GLsizei
name|maxSamples
init|=
name|getMaxSupportedSamples
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxSamples
operator|!=
literal|0
condition|)
block|{
operator|*
name|params
operator|=
name|maxSamples
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|==
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_SAMPLE_BUFFERS
case|:
if|if
condition|(
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
operator|*
name|params
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GL_SAMPLES
case|:
operator|*
name|params
operator|=
name|framebuffer
operator|->
name|getSamples
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
block|{
name|GLenum
name|format
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|getCurrentReadFormatType
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|pname
operator|==
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
condition|)
operator|*
name|params
operator|=
name|format
expr_stmt|;
else|else
operator|*
name|params
operator|=
name|type
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
name|int
name|maxDimension
init|=
name|std
operator|::
name|max
argument_list|(
name|getMaximumRenderbufferDimension
argument_list|()
argument_list|,
name|getMaximumTextureDimension
argument_list|()
argument_list|)
decl_stmt|;
name|params
index|[
literal|0
index|]
operator|=
name|maxDimension
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|maxDimension
expr_stmt|;
block|}
break|break;
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
if|if
condition|(
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGB_S3TC_DXT1_EXT
expr_stmt|;
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
operator|*
name|params
operator|++
operator|=
name|GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_VIEWPORT
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|viewportX
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|viewportY
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|viewportWidth
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|viewportHeight
expr_stmt|;
break|break;
case|case
name|GL_SCISSOR_BOX
case|:
name|params
index|[
literal|0
index|]
operator|=
name|mState
operator|.
name|scissorX
expr_stmt|;
name|params
index|[
literal|1
index|]
operator|=
name|mState
operator|.
name|scissorY
expr_stmt|;
name|params
index|[
literal|2
index|]
operator|=
name|mState
operator|.
name|scissorWidth
expr_stmt|;
name|params
index|[
literal|3
index|]
operator|=
name|mState
operator|.
name|scissorHeight
expr_stmt|;
break|break;
case|case
name|GL_CULL_FACE_MODE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|cullMode
expr_stmt|;
break|break;
case|case
name|GL_FRONT_FACE
case|:
operator|*
name|params
operator|=
name|mState
operator|.
name|frontFace
expr_stmt|;
break|break;
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|colorbuffer
init|=
name|framebuffer
operator|->
name|getColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|colorbuffer
condition|)
block|{
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_RED_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getRedSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_GREEN_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getGreenSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_BLUE_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getBlueSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|GL_ALPHA_BITS
case|:
operator|*
name|params
operator|=
name|colorbuffer
operator|->
name|getAlphaSize
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_DEPTH_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|depthbuffer
init|=
name|framebuffer
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthbuffer
condition|)
block|{
operator|*
name|params
operator|=
name|depthbuffer
operator|->
name|getDepthSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_STENCIL_BITS
case|:
block|{
name|gl
operator|::
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|gl
operator|::
name|Renderbuffer
modifier|*
name|stencilbuffer
init|=
name|framebuffer
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|stencilbuffer
condition|)
block|{
operator|*
name|params
operator|=
name|stencilbuffer
operator|->
name|getStencilSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|params
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GL_TEXTURE_BINDING_2D
case|:
block|{
if|if
condition|(
name|mState
operator|.
name|activeSampler
argument_list|<
literal|0
operator|||
name|mState
operator|.
name|activeSampler
argument_list|>
name|getMaximumCombinedTextureImageUnits
argument_list|()
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|params
operator|=
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_2D
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
block|{
if|if
condition|(
name|mState
operator|.
name|activeSampler
argument_list|<
literal|0
operator|||
name|mState
operator|.
name|activeSampler
argument_list|>
name|getMaximumCombinedTextureImageUnits
argument_list|()
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|params
operator|=
name|mState
operator|.
name|samplerTexture
index|[
name|TEXTURE_CUBE
index|]
index|[
name|mState
operator|.
name|activeSampler
index|]
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
operator|*
name|params
operator|=
name|mResetStrategy
expr_stmt|;
break|break;
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
operator|*
name|params
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
operator|*
name|params
operator|=
name|GL_PROGRAM_BINARY_ANGLE
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|getQueryParameterInfo
name|bool
name|Context
operator|::
name|getQueryParameterInfo
parameter_list|(
name|GLenum
name|pname
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|,
name|unsigned
name|int
modifier|*
name|numParams
parameter_list|)
block|{
comment|// Please note: the query type returned for DEPTH_CLEAR_VALUE in this implementation
comment|// is FLOAT rather than INT, as would be suggested by the GL ES 2.0 spec. This is due
comment|// to the fact that it is stored internally as a float, and so would require conversion
comment|// if returned from Context::getIntegerv. Since this conversion is already implemented
comment|// in the case that one calls glGetIntegerv to retrieve a float-typed state variable, we
comment|// place DEPTH_CLEAR_VALUE with the floats. This should make no difference to the calling
comment|// application.
switch|switch
condition|(
name|pname
condition|)
block|{
case|case
name|GL_COMPRESSED_TEXTURE_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
name|mNumCompressedTextureFormats
expr_stmt|;
block|}
break|break;
case|case
name|GL_SHADER_BINARY_FORMATS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_VERTEX_ATTRIBS
case|:
case|case
name|GL_MAX_VERTEX_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_VARYING_VECTORS
case|:
case|case
name|GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_TEXTURE_IMAGE_UNITS
case|:
case|case
name|GL_MAX_FRAGMENT_UNIFORM_VECTORS
case|:
case|case
name|GL_MAX_RENDERBUFFER_SIZE
case|:
case|case
name|GL_NUM_SHADER_BINARY_FORMATS
case|:
case|case
name|GL_NUM_COMPRESSED_TEXTURE_FORMATS
case|:
case|case
name|GL_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_FRAMEBUFFER_BINDING
case|:
case|case
name|GL_RENDERBUFFER_BINDING
case|:
case|case
name|GL_CURRENT_PROGRAM
case|:
case|case
name|GL_PACK_ALIGNMENT
case|:
case|case
name|GL_PACK_REVERSE_ROW_ORDER_ANGLE
case|:
case|case
name|GL_UNPACK_ALIGNMENT
case|:
case|case
name|GL_GENERATE_MIPMAP_HINT
case|:
case|case
name|GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
case|:
case|case
name|GL_RED_BITS
case|:
case|case
name|GL_GREEN_BITS
case|:
case|case
name|GL_BLUE_BITS
case|:
case|case
name|GL_ALPHA_BITS
case|:
case|case
name|GL_DEPTH_BITS
case|:
case|case
name|GL_STENCIL_BITS
case|:
case|case
name|GL_ELEMENT_ARRAY_BUFFER_BINDING
case|:
case|case
name|GL_CULL_FACE_MODE
case|:
case|case
name|GL_FRONT_FACE
case|:
case|case
name|GL_ACTIVE_TEXTURE
case|:
case|case
name|GL_STENCIL_FUNC
case|:
case|case
name|GL_STENCIL_VALUE_MASK
case|:
case|case
name|GL_STENCIL_REF
case|:
case|case
name|GL_STENCIL_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_PASS_DEPTH_PASS
case|:
case|case
name|GL_STENCIL_BACK_FUNC
case|:
case|case
name|GL_STENCIL_BACK_VALUE_MASK
case|:
case|case
name|GL_STENCIL_BACK_REF
case|:
case|case
name|GL_STENCIL_BACK_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_FAIL
case|:
case|case
name|GL_STENCIL_BACK_PASS_DEPTH_PASS
case|:
case|case
name|GL_DEPTH_FUNC
case|:
case|case
name|GL_BLEND_SRC_RGB
case|:
case|case
name|GL_BLEND_SRC_ALPHA
case|:
case|case
name|GL_BLEND_DST_RGB
case|:
case|case
name|GL_BLEND_DST_ALPHA
case|:
case|case
name|GL_BLEND_EQUATION_RGB
case|:
case|case
name|GL_BLEND_EQUATION_ALPHA
case|:
case|case
name|GL_STENCIL_WRITEMASK
case|:
case|case
name|GL_STENCIL_BACK_WRITEMASK
case|:
case|case
name|GL_STENCIL_CLEAR_VALUE
case|:
case|case
name|GL_SUBPIXEL_BITS
case|:
case|case
name|GL_MAX_TEXTURE_SIZE
case|:
case|case
name|GL_MAX_CUBE_MAP_TEXTURE_SIZE
case|:
case|case
name|GL_SAMPLE_BUFFERS
case|:
case|case
name|GL_SAMPLES
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_TYPE
case|:
case|case
name|GL_IMPLEMENTATION_COLOR_READ_FORMAT
case|:
case|case
name|GL_TEXTURE_BINDING_2D
case|:
case|case
name|GL_TEXTURE_BINDING_CUBE_MAP
case|:
case|case
name|GL_RESET_NOTIFICATION_STRATEGY_EXT
case|:
case|case
name|GL_NUM_PROGRAM_BINARY_FORMATS_OES
case|:
case|case
name|GL_PROGRAM_BINARY_FORMATS_OES
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_SAMPLES_ANGLE
case|:
block|{
if|if
condition|(
name|getMaxSupportedSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|GL_MAX_VIEWPORT_DIMS
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|GL_VIEWPORT
case|:
case|case
name|GL_SCISSOR_BOX
case|:
block|{
operator|*
name|type
operator|=
name|GL_INT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|GL_SHADER_COMPILER
case|:
case|case
name|GL_SAMPLE_COVERAGE_INVERT
case|:
case|case
name|GL_DEPTH_WRITEMASK
case|:
case|case
name|GL_CULL_FACE
case|:
comment|// CULL_FACE through DITHER are natural to IsEnabled,
case|case
name|GL_POLYGON_OFFSET_FILL
case|:
comment|// but can be retrieved through the Get{Type}v queries.
case|case
name|GL_SAMPLE_ALPHA_TO_COVERAGE
case|:
comment|// For this purpose, they are treated here as bool-natural
case|case
name|GL_SAMPLE_COVERAGE
case|:
case|case
name|GL_SCISSOR_TEST
case|:
case|case
name|GL_STENCIL_TEST
case|:
case|case
name|GL_DEPTH_TEST
case|:
case|case
name|GL_BLEND
case|:
case|case
name|GL_DITHER
case|:
case|case
name|GL_CONTEXT_ROBUST_ACCESS_EXT
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|GL_COLOR_WRITEMASK
case|:
block|{
operator|*
name|type
operator|=
name|GL_BOOL
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|GL_POLYGON_OFFSET_FACTOR
case|:
case|case
name|GL_POLYGON_OFFSET_UNITS
case|:
case|case
name|GL_SAMPLE_COVERAGE_VALUE
case|:
case|case
name|GL_DEPTH_CLEAR_VALUE
case|:
case|case
name|GL_LINE_WIDTH
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|GL_ALIASED_LINE_WIDTH_RANGE
case|:
case|case
name|GL_ALIASED_POINT_SIZE_RANGE
case|:
case|case
name|GL_DEPTH_RANGE
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|GL_COLOR_CLEAR_VALUE
case|:
case|case
name|GL_BLEND_COLOR
case|:
block|{
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
case|:
if|if
condition|(
operator|!
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|GL_FLOAT
expr_stmt|;
operator|*
name|numParams
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Applies the render target surface, depth stencil surface, viewport rectangle and
comment|// scissor rectangle to the Direct3D 9 device
DECL|function|applyRenderTarget
name|bool
name|Context
operator|::
name|applyRenderTarget
parameter_list|(
name|bool
name|ignoreViewport
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebufferObject
operator|||
name|framebufferObject
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// if there is no color attachment we must synthesize a NULL colorattachment
comment|// to keep the D3D runtime happy.  This should only be possible if depth texturing.
name|Renderbuffer
modifier|*
name|renderbufferObject
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|framebufferObject
operator|->
name|getColorbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|renderbufferObject
operator|=
name|framebufferObject
operator|->
name|getColorbuffer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|renderbufferObject
operator|=
name|framebufferObject
operator|->
name|getNullColorbuffer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|renderbufferObject
condition|)
block|{
name|ERR
argument_list|(
literal|"unable to locate renderbuffer for FBO."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|bool
name|renderTargetChanged
init|=
literal|false
decl_stmt|;
name|unsigned
name|int
name|renderTargetSerial
init|=
name|renderbufferObject
operator|->
name|getSerial
argument_list|()
decl_stmt|;
if|if
condition|(
name|renderTargetSerial
operator|!=
name|mAppliedRenderTargetSerial
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|renderbufferObject
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
name|ERR
argument_list|(
literal|"render target pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// Context must be lost
block|}
name|mDevice
operator|->
name|SetRenderTarget
argument_list|(
literal|0
argument_list|,
name|renderTarget
argument_list|)
expr_stmt|;
name|mAppliedRenderTargetSerial
operator|=
name|renderTargetSerial
expr_stmt|;
name|mScissorStateDirty
operator|=
literal|true
expr_stmt|;
comment|// Scissor area must be clamped to render target's size-- this is different for different render targets.
name|renderTargetChanged
operator|=
literal|true
expr_stmt|;
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
name|IDirect3DSurface9
modifier|*
name|depthStencil
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|depthbufferSerial
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|stencilbufferSerial
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|framebufferObject
operator|->
name|getDepthbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|Renderbuffer
modifier|*
name|depthbuffer
init|=
name|framebufferObject
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
name|depthStencil
operator|=
name|depthbuffer
operator|->
name|getDepthStencil
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|depthbufferSerial
operator|=
name|depthbuffer
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|framebufferObject
operator|->
name|getStencilbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|Renderbuffer
modifier|*
name|stencilbuffer
init|=
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
name|depthStencil
operator|=
name|stencilbuffer
operator|->
name|getDepthStencil
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|stencilbufferSerial
operator|=
name|stencilbuffer
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|depthbufferSerial
operator|!=
name|mAppliedDepthbufferSerial
operator|||
name|stencilbufferSerial
operator|!=
name|mAppliedStencilbufferSerial
operator|||
operator|!
name|mDepthStencilInitialized
condition|)
block|{
name|mDevice
operator|->
name|SetDepthStencilSurface
argument_list|(
name|depthStencil
argument_list|)
expr_stmt|;
name|mAppliedDepthbufferSerial
operator|=
name|depthbufferSerial
expr_stmt|;
name|mAppliedStencilbufferSerial
operator|=
name|stencilbufferSerial
expr_stmt|;
name|mDepthStencilInitialized
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|depthStencil
condition|)
block|{
name|depthStencil
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mRenderTargetDescInitialized
operator|||
name|renderTargetChanged
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|renderbufferObject
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
return|return
literal|false
return|;
comment|// Context must be lost
block|}
name|renderTarget
operator|->
name|GetDesc
argument_list|(
operator|&
name|mRenderTargetDesc
argument_list|)
expr_stmt|;
name|mRenderTargetDescInitialized
operator|=
literal|true
expr_stmt|;
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
name|D3DVIEWPORT9
name|viewport
decl_stmt|;
name|float
name|zNear
init|=
name|clamp01
argument_list|(
name|mState
operator|.
name|zNear
argument_list|)
decl_stmt|;
name|float
name|zFar
init|=
name|clamp01
argument_list|(
name|mState
operator|.
name|zFar
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignoreViewport
condition|)
block|{
name|viewport
operator|.
name|X
operator|=
literal|0
expr_stmt|;
name|viewport
operator|.
name|Y
operator|=
literal|0
expr_stmt|;
name|viewport
operator|.
name|Width
operator|=
name|mRenderTargetDesc
operator|.
name|Width
expr_stmt|;
name|viewport
operator|.
name|Height
operator|=
name|mRenderTargetDesc
operator|.
name|Height
expr_stmt|;
name|viewport
operator|.
name|MinZ
operator|=
literal|0.0f
expr_stmt|;
name|viewport
operator|.
name|MaxZ
operator|=
literal|1.0f
expr_stmt|;
block|}
else|else
block|{
name|viewport
operator|.
name|X
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|viewportX
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|.
name|Y
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|viewportY
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|.
name|Width
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|viewportWidth
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Width
argument_list|)
operator|-
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|viewport
operator|.
name|X
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|.
name|Height
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|viewportHeight
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Height
argument_list|)
operator|-
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|viewport
operator|.
name|Y
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|.
name|MinZ
operator|=
name|zNear
expr_stmt|;
name|viewport
operator|.
name|MaxZ
operator|=
name|zFar
expr_stmt|;
block|}
if|if
condition|(
name|viewport
operator|.
name|Width
operator|<=
literal|0
operator|||
name|viewport
operator|.
name|Height
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
comment|// Nothing to render
block|}
if|if
condition|(
name|renderTargetChanged
operator|||
operator|!
name|mViewportInitialized
operator|||
name|memcmp
argument_list|(
operator|&
name|viewport
argument_list|,
operator|&
name|mSetViewport
argument_list|,
sizeof|sizeof
name|mSetViewport
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetViewport
argument_list|(
operator|&
name|viewport
argument_list|)
expr_stmt|;
name|mSetViewport
operator|=
name|viewport
expr_stmt|;
name|mViewportInitialized
operator|=
literal|true
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mScissorStateDirty
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|scissorTest
condition|)
block|{
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|scissorX
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|scissorY
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|scissorX
operator|+
name|mState
operator|.
name|scissorWidth
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|clamp
argument_list|(
name|mState
operator|.
name|scissorY
operator|+
name|mState
operator|.
name|scissorHeight
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|mRenderTargetDesc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetScissorRect
argument_list|(
operator|&
name|rect
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SCISSORTESTENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SCISSORTESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mScissorStateDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|currentProgram
operator|&&
name|mDxUniformsDirty
condition|)
block|{
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|GLint
name|halfPixelSize
init|=
name|programBinary
operator|->
name|getDxHalfPixelSizeLocation
argument_list|()
decl_stmt|;
name|GLfloat
name|xy
index|[
literal|2
index|]
init|=
block|{
literal|1.0f
operator|/
name|viewport
operator|.
name|Width
block|,
operator|-
literal|1.0f
operator|/
name|viewport
operator|.
name|Height
block|}
decl_stmt|;
name|programBinary
operator|->
name|setUniform2fv
argument_list|(
name|halfPixelSize
argument_list|,
literal|1
argument_list|,
name|xy
argument_list|)
expr_stmt|;
comment|// These values are used for computing gl_FragCoord in Program::linkVaryings().
name|GLint
name|coord
init|=
name|programBinary
operator|->
name|getDxCoordLocation
argument_list|()
decl_stmt|;
name|GLfloat
name|whxy
index|[
literal|4
index|]
init|=
block|{
name|mState
operator|.
name|viewportWidth
operator|/
literal|2.0f
block|,
name|mState
operator|.
name|viewportHeight
operator|/
literal|2.0f
block|,
operator|(
name|float
operator|)
name|mState
operator|.
name|viewportX
operator|+
name|mState
operator|.
name|viewportWidth
operator|/
literal|2.0f
block|,
operator|(
name|float
operator|)
name|mState
operator|.
name|viewportY
operator|+
name|mState
operator|.
name|viewportHeight
operator|/
literal|2.0f
block|}
decl_stmt|;
name|programBinary
operator|->
name|setUniform4fv
argument_list|(
name|coord
argument_list|,
literal|1
argument_list|,
name|whxy
argument_list|)
expr_stmt|;
name|GLint
name|depth
init|=
name|programBinary
operator|->
name|getDxDepthLocation
argument_list|()
decl_stmt|;
name|GLfloat
name|dz
index|[
literal|2
index|]
init|=
block|{
operator|(
name|zFar
operator|-
name|zNear
operator|)
operator|/
literal|2.0f
block|,
operator|(
name|zNear
operator|+
name|zFar
operator|)
operator|/
literal|2.0f
block|}
decl_stmt|;
name|programBinary
operator|->
name|setUniform2fv
argument_list|(
name|depth
argument_list|,
literal|1
argument_list|,
name|dz
argument_list|)
expr_stmt|;
name|GLint
name|depthRange
init|=
name|programBinary
operator|->
name|getDxDepthRangeLocation
argument_list|()
decl_stmt|;
name|GLfloat
name|nearFarDiff
index|[
literal|3
index|]
init|=
block|{
name|zNear
block|,
name|zFar
block|,
name|zFar
operator|-
name|zNear
block|}
decl_stmt|;
name|programBinary
operator|->
name|setUniform3fv
argument_list|(
name|depthRange
argument_list|,
literal|1
argument_list|,
name|nearFarDiff
argument_list|)
expr_stmt|;
name|mDxUniformsDirty
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// Applies the fixed-function state (culling, depth test, alpha blending, stenciling, etc) to the Direct3D 9 device
DECL|function|applyState
name|void
name|Context
operator|::
name|applyState
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
name|GLint
name|frontCCW
init|=
name|programBinary
operator|->
name|getDxFrontCCWLocation
argument_list|()
decl_stmt|;
name|GLint
name|ccw
init|=
operator|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
operator|)
decl_stmt|;
name|programBinary
operator|->
name|setUniform1iv
argument_list|(
name|frontCCW
argument_list|,
literal|1
argument_list|,
operator|&
name|ccw
argument_list|)
expr_stmt|;
name|GLint
name|pointsOrLines
init|=
name|programBinary
operator|->
name|getDxPointsOrLinesLocation
argument_list|()
decl_stmt|;
name|GLint
name|alwaysFront
init|=
operator|!
name|isTriangleMode
argument_list|(
name|drawMode
argument_list|)
decl_stmt|;
name|programBinary
operator|->
name|setUniform1iv
argument_list|(
name|pointsOrLines
argument_list|,
literal|1
argument_list|,
operator|&
name|alwaysFront
argument_list|)
expr_stmt|;
name|D3DADAPTER_IDENTIFIER9
modifier|*
name|identifier
init|=
name|mDisplay
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
name|bool
name|zeroColorMaskAllowed
init|=
name|identifier
operator|->
name|VendorId
operator|!=
literal|0x1002
decl_stmt|;
comment|// Apparently some ATI cards have a bug where a draw with a zero color
comment|// write mask can cause later draws to have incorrect results. Instead,
comment|// set a nonzero color write mask but modify the blend state so that no
comment|// drawing is done.
comment|// http://code.google.com/p/angleproject/issues/detail?id=169
if|if
condition|(
name|mCullStateDirty
operator|||
name|mFrontFaceDirty
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|cullFace
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|es2dx
operator|::
name|ConvertCullMode
argument_list|(
name|mState
operator|.
name|cullMode
argument_list|,
name|mState
operator|.
name|frontFace
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
block|}
name|mCullStateDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mDepthStateDirty
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|depthTest
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|D3DZB_TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|es2dx
operator|::
name|ConvertComparison
argument_list|(
name|mState
operator|.
name|depthFunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|D3DZB_FALSE
argument_list|)
expr_stmt|;
block|}
name|mDepthStateDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zeroColorMaskAllowed
operator|&&
operator|(
name|mMaskStateDirty
operator|||
name|mBlendStateDirty
operator|)
condition|)
block|{
name|mBlendStateDirty
operator|=
literal|true
expr_stmt|;
name|mMaskStateDirty
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mBlendStateDirty
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|blend
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|mState
operator|.
name|sourceBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
operator|&&
name|mState
operator|.
name|destBlendRGB
operator|!=
name|GL_CONSTANT_ALPHA
operator|&&
name|mState
operator|.
name|destBlendRGB
operator|!=
name|GL_ONE_MINUS_CONSTANT_ALPHA
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDFACTOR
argument_list|,
name|es2dx
operator|::
name|ConvertColor
argument_list|(
name|mState
operator|.
name|blendColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDFACTOR
argument_list|,
name|D3DCOLOR_RGBA
argument_list|(
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|,
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|,
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|,
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|blendColor
operator|.
name|alpha
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SRCBLEND
argument_list|,
name|es2dx
operator|::
name|ConvertBlendFunc
argument_list|(
name|mState
operator|.
name|sourceBlendRGB
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DESTBLEND
argument_list|,
name|es2dx
operator|::
name|ConvertBlendFunc
argument_list|(
name|mState
operator|.
name|destBlendRGB
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDOP
argument_list|,
name|es2dx
operator|::
name|ConvertBlendOp
argument_list|(
name|mState
operator|.
name|blendEquationRGB
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mState
operator|.
name|sourceBlendRGB
operator|!=
name|mState
operator|.
name|sourceBlendAlpha
operator|||
name|mState
operator|.
name|destBlendRGB
operator|!=
name|mState
operator|.
name|destBlendAlpha
operator|||
name|mState
operator|.
name|blendEquationRGB
operator|!=
name|mState
operator|.
name|blendEquationAlpha
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SRCBLENDALPHA
argument_list|,
name|es2dx
operator|::
name|ConvertBlendFunc
argument_list|(
name|mState
operator|.
name|sourceBlendAlpha
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DESTBLENDALPHA
argument_list|,
name|es2dx
operator|::
name|ConvertBlendFunc
argument_list|(
name|mState
operator|.
name|destBlendAlpha
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDOPALPHA
argument_list|,
name|es2dx
operator|::
name|ConvertBlendOp
argument_list|(
name|mState
operator|.
name|blendEquationAlpha
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mBlendStateDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mStencilStateDirty
operator|||
name|mFrontFaceDirty
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|stencilTest
operator|&&
name|framebufferObject
operator|->
name|hasStencil
argument_list|()
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TWOSIDEDSTENCILMODE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|// FIXME: Unsupported by D3D9
specifier|const
name|D3DRENDERSTATETYPE
name|D3DRS_CCW_STENCILREF
init|=
name|D3DRS_STENCILREF
decl_stmt|;
specifier|const
name|D3DRENDERSTATETYPE
name|D3DRS_CCW_STENCILMASK
init|=
name|D3DRS_STENCILMASK
decl_stmt|;
specifier|const
name|D3DRENDERSTATETYPE
name|D3DRS_CCW_STENCILWRITEMASK
init|=
name|D3DRS_STENCILWRITEMASK
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|stencilWritemask
operator|!=
name|mState
operator|.
name|stencilBackWritemask
operator|||
name|mState
operator|.
name|stencilRef
operator|!=
name|mState
operator|.
name|stencilBackRef
operator|||
name|mState
operator|.
name|stencilMask
operator|!=
name|mState
operator|.
name|stencilBackMask
condition|)
block|{
name|ERR
argument_list|(
literal|"Separate front/back stencil writemasks, reference values, or stencil mask values are invalid under WebGL."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
comment|// get the maximum size of the stencil ref
name|gl
operator|::
name|Renderbuffer
modifier|*
name|stencilbuffer
init|=
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
decl_stmt|;
name|GLuint
name|maxStencil
init|=
operator|(
literal|1
operator|<<
name|stencilbuffer
operator|->
name|getStencilSize
argument_list|()
operator|)
operator|-
literal|1
decl_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|?
name|D3DRS_STENCILWRITEMASK
else|:
name|D3DRS_CCW_STENCILWRITEMASK
argument_list|,
name|mState
operator|.
name|stencilWritemask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|?
name|D3DRS_STENCILFUNC
else|:
name|D3DRS_CCW_STENCILFUNC
argument_list|,
name|es2dx
operator|::
name|ConvertComparison
argument_list|(
name|mState
operator|.
name|stencilFunc
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|?
name|D3DRS_STENCILREF
else|:
name|D3DRS_CCW_STENCILREF
argument_list|,
operator|(
name|mState
operator|.
name|stencilRef
operator|<
operator|(
name|GLint
operator|)
name|maxStencil
operator|)
condition|?
name|mState
operator|.
name|stencilRef
else|:
name|maxStencil
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|?
name|D3DRS_STENCILMASK
else|:
name|D3DRS_CCW_STENCILMASK
argument_list|,
name|mState
operator|.
name|stencilMask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|?
name|D3DRS_STENCILFAIL
else|:
name|D3DRS_CCW_STENCILFAIL
argument_list|,
name|es2dx
operator|::
name|ConvertStencilOp
argument_list|(
name|mState
operator|.
name|stencilFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|?
name|D3DRS_STENCILZFAIL
else|:
name|D3DRS_CCW_STENCILZFAIL
argument_list|,
name|es2dx
operator|::
name|ConvertStencilOp
argument_list|(
name|mState
operator|.
name|stencilPassDepthFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CCW
condition|?
name|D3DRS_STENCILPASS
else|:
name|D3DRS_CCW_STENCILPASS
argument_list|,
name|es2dx
operator|::
name|ConvertStencilOp
argument_list|(
name|mState
operator|.
name|stencilPassDepthPass
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CW
condition|?
name|D3DRS_STENCILWRITEMASK
else|:
name|D3DRS_CCW_STENCILWRITEMASK
argument_list|,
name|mState
operator|.
name|stencilBackWritemask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CW
condition|?
name|D3DRS_STENCILFUNC
else|:
name|D3DRS_CCW_STENCILFUNC
argument_list|,
name|es2dx
operator|::
name|ConvertComparison
argument_list|(
name|mState
operator|.
name|stencilBackFunc
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CW
condition|?
name|D3DRS_STENCILREF
else|:
name|D3DRS_CCW_STENCILREF
argument_list|,
operator|(
name|mState
operator|.
name|stencilBackRef
operator|<
operator|(
name|GLint
operator|)
name|maxStencil
operator|)
condition|?
name|mState
operator|.
name|stencilBackRef
else|:
name|maxStencil
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CW
condition|?
name|D3DRS_STENCILMASK
else|:
name|D3DRS_CCW_STENCILMASK
argument_list|,
name|mState
operator|.
name|stencilBackMask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CW
condition|?
name|D3DRS_STENCILFAIL
else|:
name|D3DRS_CCW_STENCILFAIL
argument_list|,
name|es2dx
operator|::
name|ConvertStencilOp
argument_list|(
name|mState
operator|.
name|stencilBackFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CW
condition|?
name|D3DRS_STENCILZFAIL
else|:
name|D3DRS_CCW_STENCILZFAIL
argument_list|,
name|es2dx
operator|::
name|ConvertStencilOp
argument_list|(
name|mState
operator|.
name|stencilBackPassDepthFail
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|mState
operator|.
name|frontFace
operator|==
name|GL_CW
condition|?
name|D3DRS_STENCILPASS
else|:
name|D3DRS_CCW_STENCILPASS
argument_list|,
name|es2dx
operator|::
name|ConvertStencilOp
argument_list|(
name|mState
operator|.
name|stencilBackPassDepthPass
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mStencilStateDirty
operator|=
literal|false
expr_stmt|;
name|mFrontFaceDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mMaskStateDirty
condition|)
block|{
name|int
name|colorMask
init|=
name|es2dx
operator|::
name|ConvertColorMask
argument_list|(
name|mState
operator|.
name|colorMaskRed
argument_list|,
name|mState
operator|.
name|colorMaskGreen
argument_list|,
name|mState
operator|.
name|colorMaskBlue
argument_list|,
name|mState
operator|.
name|colorMaskAlpha
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorMask
operator|==
literal|0
operator|&&
operator|!
name|zeroColorMaskAllowed
condition|)
block|{
comment|// Enable green channel, but set blending so nothing will be drawn.
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|D3DCOLORWRITEENABLE_GREEN
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SRCBLEND
argument_list|,
name|D3DBLEND_ZERO
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DESTBLEND
argument_list|,
name|D3DBLEND_ONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_BLENDOP
argument_list|,
name|D3DBLENDOP_ADD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|colorMask
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|mState
operator|.
name|depthMask
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
name|mMaskStateDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mPolygonOffsetStateDirty
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|polygonOffsetFill
condition|)
block|{
name|gl
operator|::
name|Renderbuffer
modifier|*
name|depthbuffer
init|=
name|framebufferObject
operator|->
name|getDepthbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|depthbuffer
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SLOPESCALEDEPTHBIAS
argument_list|,
operator|*
operator|(
operator|(
name|DWORD
operator|*
operator|)
operator|&
name|mState
operator|.
name|polygonOffsetFactor
operator|)
argument_list|)
expr_stmt|;
name|float
name|depthBias
init|=
name|ldexp
argument_list|(
name|mState
operator|.
name|polygonOffsetUnits
argument_list|,
operator|-
call|(
name|int
call|)
argument_list|(
name|depthbuffer
operator|->
name|getDepthSize
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DEPTHBIAS
argument_list|,
operator|*
operator|(
operator|(
name|DWORD
operator|*
operator|)
operator|&
name|depthBias
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SLOPESCALEDEPTHBIAS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DEPTHBIAS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mPolygonOffsetStateDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mSampleStateDirty
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|sampleAlphaToCoverage
condition|)
block|{
name|FIXME
argument_list|(
literal|"Sample alpha to coverage is unimplemented."
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEANTIALIAS
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mState
operator|.
name|sampleCoverage
condition|)
block|{
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|sampleCoverageValue
operator|!=
literal|0
condition|)
block|{
name|float
name|threshold
init|=
literal|0.5f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|framebufferObject
operator|->
name|getSamples
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|mState
operator|.
name|sampleCoverageValue
operator|>=
name|threshold
condition|)
block|{
name|threshold
operator|+=
literal|1.0f
expr_stmt|;
name|mask
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mState
operator|.
name|sampleCoverageInvert
condition|)
block|{
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
name|mSampleStateDirty
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|mDitherStateDirty
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_DITHERENABLE
argument_list|,
name|mState
operator|.
name|dither
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
name|mDitherStateDirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|function|applyVertexBuffer
name|GLenum
name|Context
operator|::
name|applyVertexBuffer
parameter_list|(
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
name|GLsizei
modifier|*
name|repeatDraw
parameter_list|)
block|{
name|TranslatedAttribute
name|attributes
index|[
name|MAX_VERTEX_ATTRIBS
index|]
decl_stmt|;
name|GLenum
name|err
init|=
name|mVertexDataManager
operator|->
name|prepareVertexData
argument_list|(
name|first
argument_list|,
name|count
argument_list|,
name|attributes
argument_list|,
name|instances
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|err
return|;
block|}
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
return|return
name|mVertexDeclarationCache
operator|.
name|applyDeclaration
argument_list|(
name|mDevice
argument_list|,
name|attributes
argument_list|,
name|programBinary
argument_list|,
name|instances
argument_list|,
name|repeatDraw
argument_list|)
return|;
block|}
comment|// Applies the indices and element array bindings to the Direct3D 9 device
DECL|function|applyIndexBuffer
name|GLenum
name|Context
operator|::
name|applyIndexBuffer
parameter_list|(
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|mode
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|TranslatedIndexData
modifier|*
name|indexInfo
parameter_list|)
block|{
name|GLenum
name|err
init|=
name|mIndexDataManager
operator|->
name|prepareIndexData
argument_list|(
name|type
argument_list|,
name|count
argument_list|,
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|get
argument_list|()
argument_list|,
name|indices
argument_list|,
name|indexInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|GL_NO_ERROR
condition|)
block|{
if|if
condition|(
name|indexInfo
operator|->
name|serial
operator|!=
name|mAppliedIBSerial
condition|)
block|{
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|indexInfo
operator|->
name|indexBuffer
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|indexInfo
operator|->
name|serial
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
comment|// Applies the shaders and shader constants to the Direct3D 9 device
DECL|function|applyShaders
name|void
name|Context
operator|::
name|applyShaders
parameter_list|()
block|{
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
if|if
condition|(
name|programBinary
operator|->
name|getSerial
argument_list|()
operator|!=
name|mAppliedProgramBinarySerial
condition|)
block|{
name|IDirect3DVertexShader9
modifier|*
name|vertexShader
init|=
name|programBinary
operator|->
name|getVertexShader
argument_list|()
decl_stmt|;
name|IDirect3DPixelShader9
modifier|*
name|pixelShader
init|=
name|programBinary
operator|->
name|getPixelShader
argument_list|()
decl_stmt|;
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|pixelShader
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|vertexShader
argument_list|)
expr_stmt|;
name|programBinary
operator|->
name|dirtyAllUniforms
argument_list|()
expr_stmt|;
name|mAppliedProgramBinarySerial
operator|=
name|programBinary
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
name|programBinary
operator|->
name|applyUniforms
argument_list|()
expr_stmt|;
block|}
comment|// Applies the textures and sampler states to the Direct3D 9 device
DECL|function|applyTextures
name|void
name|Context
operator|::
name|applyTextures
parameter_list|()
block|{
name|applyTextures
argument_list|(
name|SAMPLER_PIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mSupportsVertexTexture
condition|)
block|{
name|applyTextures
argument_list|(
name|SAMPLER_VERTEX
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For each Direct3D 9 sampler of either the pixel or vertex stage,
comment|// looks up the corresponding OpenGL texture image unit and texture type,
comment|// and sets the texture and its addressing/filtering state (or NULL when inactive).
DECL|function|applyTextures
name|void
name|Context
operator|::
name|applyTextures
parameter_list|(
name|SamplerType
name|type
parameter_list|)
block|{
name|ProgramBinary
modifier|*
name|programBinary
init|=
name|getCurrentProgramBinary
argument_list|()
decl_stmt|;
name|int
name|samplerCount
init|=
operator|(
name|type
operator|==
name|SAMPLER_PIXEL
operator|)
condition|?
name|MAX_TEXTURE_IMAGE_UNITS
else|:
name|MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF
decl_stmt|;
comment|// Range of Direct3D 9 samplers of given sampler type
name|unsigned
name|int
modifier|*
name|appliedTextureSerial
init|=
operator|(
name|type
operator|==
name|SAMPLER_PIXEL
operator|)
condition|?
name|mAppliedTextureSerialPS
else|:
name|mAppliedTextureSerialVS
decl_stmt|;
name|int
name|d3dSamplerOffset
init|=
operator|(
name|type
operator|==
name|SAMPLER_PIXEL
operator|)
condition|?
literal|0
else|:
name|D3DVERTEXTEXTURESAMPLER0
decl_stmt|;
name|int
name|samplerRange
init|=
name|programBinary
operator|->
name|getUsedSamplerRange
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|samplerIndex
init|=
literal|0
init|;
name|samplerIndex
operator|<
name|samplerRange
condition|;
name|samplerIndex
operator|++
control|)
block|{
name|int
name|textureUnit
init|=
name|programBinary
operator|->
name|getSamplerMapping
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|)
decl_stmt|;
comment|// OpenGL texture image unit index
name|int
name|d3dSampler
init|=
name|samplerIndex
operator|+
name|d3dSamplerOffset
decl_stmt|;
if|if
condition|(
name|textureUnit
operator|!=
operator|-
literal|1
condition|)
block|{
name|TextureType
name|textureType
init|=
name|programBinary
operator|->
name|getSamplerTextureType
argument_list|(
name|type
argument_list|,
name|samplerIndex
argument_list|)
decl_stmt|;
name|Texture
modifier|*
name|texture
init|=
name|getSamplerTexture
argument_list|(
name|textureUnit
argument_list|,
name|textureType
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|texSerial
init|=
name|texture
operator|->
name|getTextureSerial
argument_list|()
decl_stmt|;
if|if
condition|(
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|!=
name|texSerial
operator|||
name|texture
operator|->
name|hasDirtyParameters
argument_list|()
operator|||
name|texture
operator|->
name|hasDirtyImages
argument_list|()
condition|)
block|{
name|IDirect3DBaseTexture9
modifier|*
name|d3dTexture
init|=
name|texture
operator|->
name|getTexture
argument_list|()
decl_stmt|;
if|if
condition|(
name|d3dTexture
condition|)
block|{
if|if
condition|(
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|!=
name|texSerial
operator|||
name|texture
operator|->
name|hasDirtyParameters
argument_list|()
condition|)
block|{
name|GLenum
name|wrapS
init|=
name|texture
operator|->
name|getWrapS
argument_list|()
decl_stmt|;
name|GLenum
name|wrapT
init|=
name|texture
operator|->
name|getWrapT
argument_list|()
decl_stmt|;
name|GLenum
name|minFilter
init|=
name|texture
operator|->
name|getMinFilter
argument_list|()
decl_stmt|;
name|GLenum
name|magFilter
init|=
name|texture
operator|->
name|getMagFilter
argument_list|()
decl_stmt|;
name|float
name|maxAnisotropy
init|=
name|texture
operator|->
name|getMaxAnisotropy
argument_list|()
decl_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_ADDRESSU
argument_list|,
name|es2dx
operator|::
name|ConvertTextureWrap
argument_list|(
name|wrapS
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_ADDRESSV
argument_list|,
name|es2dx
operator|::
name|ConvertTextureWrap
argument_list|(
name|wrapT
argument_list|)
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAGFILTER
argument_list|,
name|es2dx
operator|::
name|ConvertMagFilter
argument_list|(
name|magFilter
argument_list|,
name|maxAnisotropy
argument_list|)
argument_list|)
expr_stmt|;
name|D3DTEXTUREFILTERTYPE
name|d3dMinFilter
decl_stmt|,
name|d3dMipFilter
decl_stmt|;
name|es2dx
operator|::
name|ConvertMinFilter
argument_list|(
name|minFilter
argument_list|,
operator|&
name|d3dMinFilter
argument_list|,
operator|&
name|d3dMipFilter
argument_list|,
name|maxAnisotropy
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MINFILTER
argument_list|,
name|d3dMinFilter
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MIPFILTER
argument_list|,
name|d3dMipFilter
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAXMIPLEVEL
argument_list|,
name|texture
operator|->
name|getLodOffset
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
name|mDevice
operator|->
name|SetSamplerState
argument_list|(
name|d3dSampler
argument_list|,
name|D3DSAMP_MAXANISOTROPY
argument_list|,
operator|(
name|DWORD
operator|)
name|maxAnisotropy
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|!=
name|texSerial
operator|||
name|texture
operator|->
name|hasDirtyImages
argument_list|()
condition|)
block|{
name|mDevice
operator|->
name|SetTexture
argument_list|(
name|d3dSampler
argument_list|,
name|d3dTexture
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mDevice
operator|->
name|SetTexture
argument_list|(
name|d3dSampler
argument_list|,
name|getIncompleteTexture
argument_list|(
name|textureType
argument_list|)
operator|->
name|getTexture
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|=
name|texSerial
expr_stmt|;
name|texture
operator|->
name|resetDirty
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|!=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetTexture
argument_list|(
name|d3dSampler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|samplerIndex
init|=
name|samplerRange
init|;
name|samplerIndex
operator|<
name|samplerCount
condition|;
name|samplerIndex
operator|++
control|)
block|{
if|if
condition|(
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|!=
literal|0
condition|)
block|{
name|mDevice
operator|->
name|SetTexture
argument_list|(
name|samplerIndex
operator|+
name|d3dSamplerOffset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|appliedTextureSerial
index|[
name|samplerIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
DECL|function|readPixels
name|void
name|Context
operator|::
name|readPixels
parameter_list|(
name|GLint
name|x
parameter_list|,
name|GLint
name|y
parameter_list|,
name|GLsizei
name|width
parameter_list|,
name|GLsizei
name|height
parameter_list|,
name|GLenum
name|format
parameter_list|,
name|GLenum
name|type
parameter_list|,
name|GLsizei
modifier|*
name|bufSize
parameter_list|,
name|void
modifier|*
name|pixels
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|getReadFramebufferHandle
argument_list|()
operator|!=
literal|0
operator|&&
name|framebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|GLsizei
name|outputPitch
init|=
name|ComputePitch
argument_list|(
name|width
argument_list|,
name|ConvertSizedInternalFormat
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
argument_list|,
name|mState
operator|.
name|packAlignment
argument_list|)
decl_stmt|;
comment|// sized query sanity check
if|if
condition|(
name|bufSize
condition|)
block|{
name|int
name|requiredSize
init|=
name|outputPitch
operator|*
name|height
decl_stmt|;
if|if
condition|(
name|requiredSize
operator|>
operator|*
name|bufSize
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
name|IDirect3DSurface9
modifier|*
name|renderTarget
init|=
name|framebuffer
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderTarget
condition|)
block|{
return|return;
comment|// Context must be lost, return silently
block|}
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|renderTarget
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|.
name|MultiSampleType
operator|!=
name|D3DMULTISAMPLE_NONE
condition|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME: Requires resolve using StretchRect into non-multisampled render target
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
name|HRESULT
name|result
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|systemSurface
init|=
name|NULL
decl_stmt|;
name|bool
name|directToPixels
init|=
operator|!
name|getPackReverseRowOrder
argument_list|()
operator|&&
name|getPackAlignment
argument_list|()
operator|<=
literal|4
operator|&&
name|mDisplay
operator|->
name|isD3d9ExDevice
argument_list|()
operator|&&
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
operator|&&
name|UINT
argument_list|(
name|width
argument_list|)
operator|==
name|desc
operator|.
name|Width
operator|&&
name|UINT
argument_list|(
name|height
argument_list|)
operator|==
name|desc
operator|.
name|Height
operator|&&
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A8R8G8B8
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_BYTE
decl_stmt|;
if|if
condition|(
name|directToPixels
condition|)
block|{
comment|// Use the pixels ptr as a shared handle to write directly into client's memory
name|result
operator|=
name|mDevice
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|systemSurface
argument_list|,
operator|&
name|pixels
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// Try again without the shared handle
name|directToPixels
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|directToPixels
condition|)
block|{
name|result
operator|=
name|mDevice
operator|->
name|CreateOffscreenPlainSurface
argument_list|(
name|desc
operator|.
name|Width
argument_list|,
name|desc
operator|.
name|Height
argument_list|,
name|desc
operator|.
name|Format
argument_list|,
name|D3DPOOL_SYSTEMMEM
argument_list|,
operator|&
name|systemSurface
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|result
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|result
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
name|result
operator|=
name|mDevice
operator|->
name|GetRenderTargetData
argument_list|(
name|renderTarget
argument_list|,
name|systemSurface
argument_list|)
expr_stmt|;
name|renderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
name|renderTarget
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
comment|// It turns out that D3D will sometimes produce more error
comment|// codes than those documented.
if|if
condition|(
name|checkDeviceLost
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
else|else
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|directToPixels
condition|)
block|{
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return;
block|}
name|RECT
name|rect
decl_stmt|;
name|rect
operator|.
name|left
operator|=
name|clamp
argument_list|(
name|x
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|top
operator|=
name|clamp
argument_list|(
name|y
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|right
operator|=
name|clamp
argument_list|(
name|x
operator|+
name|width
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Width
argument_list|)
argument_list|)
expr_stmt|;
name|rect
operator|.
name|bottom
operator|=
name|clamp
argument_list|(
name|y
operator|+
name|height
argument_list|,
literal|0L
argument_list|,
cast|static_cast
argument_list|<
name|LONG
argument_list|>
argument_list|(
name|desc
operator|.
name|Height
argument_list|)
argument_list|)
expr_stmt|;
name|D3DLOCKED_RECT
name|lock
decl_stmt|;
name|result
operator|=
name|systemSurface
operator|->
name|LockRect
argument_list|(
operator|&
name|lock
argument_list|,
operator|&
name|rect
argument_list|,
name|D3DLOCK_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|UNREACHABLE
argument_list|()
expr_stmt|;
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
return|return;
comment|// No sensible error to generate
block|}
name|unsigned
name|char
modifier|*
name|dest
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pixels
decl_stmt|;
name|unsigned
name|short
modifier|*
name|dest16
init|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|pixels
decl_stmt|;
name|unsigned
name|char
modifier|*
name|source
decl_stmt|;
name|int
name|inputPitch
decl_stmt|;
if|if
condition|(
name|getPackReverseRowOrder
argument_list|()
condition|)
block|{
name|source
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lock
operator|.
name|pBits
operator|)
operator|+
name|lock
operator|.
name|Pitch
operator|*
operator|(
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
operator|-
literal|1
operator|)
expr_stmt|;
name|inputPitch
operator|=
operator|-
name|lock
operator|.
name|Pitch
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lock
operator|.
name|pBits
expr_stmt|;
name|inputPitch
operator|=
name|lock
operator|.
name|Pitch
expr_stmt|;
block|}
name|unsigned
name|int
name|fastPixelSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A8R8G8B8
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_BYTE
condition|)
block|{
name|fastPixelSize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A4R4G4B4
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT
operator|)
operator|||
operator|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A1R5G5B5
operator|&&
name|format
operator|==
name|GL_BGRA_EXT
operator|&&
name|type
operator|==
name|GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT
operator|)
condition|)
block|{
name|fastPixelSize
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A16B16G16R16F
operator|&&
name|format
operator|==
name|GL_RGBA
operator|&&
name|type
operator|==
name|GL_HALF_FLOAT_OES
condition|)
block|{
name|fastPixelSize
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|.
name|Format
operator|==
name|D3DFMT_A32B32G32R32F
operator|&&
name|format
operator|==
name|GL_RGBA
operator|&&
name|type
operator|==
name|GL_FLOAT
condition|)
block|{
name|fastPixelSize
operator|=
literal|16
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rect
operator|.
name|bottom
operator|-
name|rect
operator|.
name|top
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fastPixelSize
operator|!=
literal|0
condition|)
block|{
comment|// Fast path for formats which require no translation:
comment|// D3DFMT_A8R8G8B8 to BGRA/UNSIGNED_BYTE
comment|// D3DFMT_A4R4G4B4 to BGRA/UNSIGNED_SHORT_4_4_4_4_REV_EXT
comment|// D3DFMT_A1R5G5B5 to BGRA/UNSIGNED_SHORT_1_5_5_5_REV_EXT
comment|// D3DFMT_A16B16G16R16F to RGBA/HALF_FLOAT_OES
comment|// D3DFMT_A32B32G32R32F to RGBA/FLOAT
comment|//
comment|// Note that buffers with no alpha go through the slow path below.
name|memcpy
argument_list|(
name|dest
operator|+
name|j
operator|*
name|outputPitch
argument_list|,
name|source
operator|+
name|j
operator|*
name|inputPitch
argument_list|,
operator|(
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
operator|)
operator|*
name|fastPixelSize
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rect
operator|.
name|right
operator|-
name|rect
operator|.
name|left
condition|;
name|i
operator|++
control|)
block|{
name|float
name|r
decl_stmt|;
name|float
name|g
decl_stmt|;
name|float
name|b
decl_stmt|;
name|float
name|a
decl_stmt|;
switch|switch
condition|(
name|desc
operator|.
name|Format
condition|)
block|{
case|case
name|D3DFMT_R5G6B5
case|:
block|{
name|unsigned
name|short
name|rgb
init|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|2
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
literal|1.0f
expr_stmt|;
name|b
operator|=
operator|(
name|rgb
operator|&
literal|0x001F
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x001F
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|rgb
operator|&
literal|0x07E0
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x07E0
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|rgb
operator|&
literal|0xF800
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xF800
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A1R5G5B5
case|:
block|{
name|unsigned
name|short
name|argb
init|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|2
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
operator|(
name|argb
operator|&
literal|0x8000
operator|)
condition|?
literal|1.0f
else|:
literal|0.0f
expr_stmt|;
name|b
operator|=
operator|(
name|argb
operator|&
literal|0x001F
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x001F
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|argb
operator|&
literal|0x03E0
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x03E0
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|argb
operator|&
literal|0x7C00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x7C00
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A8R8G8B8
case|:
block|{
name|unsigned
name|int
name|argb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
operator|(
name|argb
operator|&
literal|0xFF000000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xFF000000
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|argb
operator|&
literal|0x000000FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000000FF
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|argb
operator|&
literal|0x0000FF00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x0000FF00
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|argb
operator|&
literal|0x00FF0000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x00FF0000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_X8R8G8B8
case|:
block|{
name|unsigned
name|int
name|xrgb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
literal|1.0f
expr_stmt|;
name|b
operator|=
operator|(
name|xrgb
operator|&
literal|0x000000FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000000FF
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|xrgb
operator|&
literal|0x0000FF00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x0000FF00
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|xrgb
operator|&
literal|0x00FF0000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x00FF0000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A2R10G10B10
case|:
block|{
name|unsigned
name|int
name|argb
init|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|source
operator|+
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
decl_stmt|;
name|a
operator|=
operator|(
name|argb
operator|&
literal|0xC0000000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0xC0000000
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|argb
operator|&
literal|0x000003FF
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000003FF
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|argb
operator|&
literal|0x000FFC00
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x000FFC00
operator|)
expr_stmt|;
name|r
operator|=
operator|(
name|argb
operator|&
literal|0x3FF00000
operator|)
operator|*
operator|(
literal|1.0f
operator|/
literal|0x3FF00000
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A32B32G32R32F
case|:
block|{
comment|// float formats in D3D are stored rgba, rather than the other way round
name|r
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|0
operator|)
expr_stmt|;
name|g
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|b
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|2
operator|)
expr_stmt|;
name|a
operator|=
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
operator|(
name|source
operator|+
literal|16
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|D3DFMT_A16B16G16R16F
case|:
block|{
comment|// float formats in D3D are stored rgba, rather than the other way round
name|r
operator|=
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|0
operator|)
argument_list|)
expr_stmt|;
name|g
operator|=
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|float16ToFloat32
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|source
operator|+
literal|8
operator|*
name|i
operator|+
name|j
operator|*
name|inputPitch
operator|)
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
comment|// FIXME
name|UNREACHABLE
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|GL_RGBA
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|a
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_BGRA_EXT
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_BYTE
case|:
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|4
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|a
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT
case|:
comment|// According to the desktop GL spec in the "Transfer of Pixel Rectangles" section
comment|// this type is packed as follows:
comment|//   15   14   13   12   11   10    9    8    7    6    5    4    3    2    1    0
comment|//  --------------------------------------------------------------------------------
comment|// |       4th         |        3rd         |        2nd        |   1st component   |
comment|//  --------------------------------------------------------------------------------
comment|// in the case of BGRA_EXT, B is the first component, G the second, and so forth.
name|dest16
index|[
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|a
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|12
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|4
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|15
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT
case|:
comment|// According to the desktop GL spec in the "Transfer of Pixel Rectangles" section
comment|// this type is packed as follows:
comment|//   15   14   13   12   11   10    9    8    7    6    5    4    3    2    1    0
comment|//  --------------------------------------------------------------------------------
comment|// | 4th |          3rd           |           2nd          |      1st component     |
comment|//  --------------------------------------------------------------------------------
comment|// in the case of BGRA_EXT, B is the first component, G the second, and so forth.
name|dest16
index|[
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|a
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|15
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|10
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GL_RGB
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_UNSIGNED_SHORT_5_6_5
case|:
name|dest16
index|[
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|/
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|0
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|63
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|5
operator|)
operator||
operator|(
call|(
name|unsigned
name|short
call|)
argument_list|(
literal|31
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
operator|<<
literal|11
operator|)
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
name|dest
index|[
literal|3
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|r
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|3
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|g
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
name|dest
index|[
literal|3
operator|*
name|i
operator|+
name|j
operator|*
name|outputPitch
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|255
operator|*
name|b
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|systemSurface
operator|->
name|UnlockRect
argument_list|()
expr_stmt|;
name|systemSurface
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
DECL|function|clear
name|void
name|Context
operator|::
name|clear
parameter_list|(
name|GLbitfield
name|mask
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebufferObject
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebufferObject
operator|||
name|framebufferObject
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
name|DWORD
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
name|mask
operator|&=
operator|~
name|GL_COLOR_BUFFER_BIT
expr_stmt|;
if|if
condition|(
name|framebufferObject
operator|->
name|getColorbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|flags
operator||=
name|D3DCLEAR_TARGET
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
name|mask
operator|&=
operator|~
name|GL_DEPTH_BUFFER_BIT
expr_stmt|;
if|if
condition|(
name|mState
operator|.
name|depthMask
operator|&&
name|framebufferObject
operator|->
name|getDepthbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|flags
operator||=
name|D3DCLEAR_ZBUFFER
expr_stmt|;
block|}
block|}
name|GLuint
name|stencilUnmasked
init|=
literal|0x0
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
name|mask
operator|&=
operator|~
name|GL_STENCIL_BUFFER_BIT
expr_stmt|;
if|if
condition|(
name|framebufferObject
operator|->
name|getStencilbufferType
argument_list|()
operator|!=
name|GL_NONE
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|depthStencil
init|=
name|framebufferObject
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|depthStencil
condition|)
block|{
name|ERR
argument_list|(
literal|"Depth stencil pointer unexpectedly null."
argument_list|)
expr_stmt|;
return|return;
block|}
name|D3DSURFACE_DESC
name|desc
decl_stmt|;
name|depthStencil
operator|->
name|GetDesc
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|depthStencil
operator|->
name|Release
argument_list|()
expr_stmt|;
name|unsigned
name|int
name|stencilSize
init|=
name|dx2es
operator|::
name|GetStencilSize
argument_list|(
name|desc
operator|.
name|Format
argument_list|)
decl_stmt|;
name|stencilUnmasked
operator|=
operator|(
literal|0x1
operator|<<
name|stencilSize
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|stencilUnmasked
operator|!=
literal|0x0
condition|)
block|{
name|flags
operator||=
name|D3DCLEAR_STENCIL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_VALUE
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
literal|true
argument_list|)
condition|)
comment|// Clips the clear to the scissor rectangle but not the viewport
block|{
return|return;
block|}
name|D3DCOLOR
name|color
init|=
name|D3DCOLOR_ARGB
argument_list|(
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|colorClearValue
operator|.
name|alpha
argument_list|)
argument_list|,
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|colorClearValue
operator|.
name|red
argument_list|)
argument_list|,
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|colorClearValue
operator|.
name|green
argument_list|)
argument_list|,
name|unorm
argument_list|<
literal|8
argument_list|>
argument_list|(
name|mState
operator|.
name|colorClearValue
operator|.
name|blue
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|depth
init|=
name|clamp01
argument_list|(
name|mState
operator|.
name|depthClearValue
argument_list|)
decl_stmt|;
name|int
name|stencil
init|=
name|mState
operator|.
name|stencilClearValue
operator|&
literal|0x000000FF
decl_stmt|;
name|bool
name|alphaUnmasked
init|=
operator|(
name|dx2es
operator|::
name|GetAlphaSize
argument_list|(
name|mRenderTargetDesc
operator|.
name|Format
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|mState
operator|.
name|colorMaskAlpha
decl_stmt|;
specifier|const
name|bool
name|needMaskedStencilClear
init|=
operator|(
name|flags
operator|&
name|D3DCLEAR_STENCIL
operator|)
operator|&&
operator|(
name|mState
operator|.
name|stencilWritemask
operator|&
name|stencilUnmasked
operator|)
operator|!=
name|stencilUnmasked
decl_stmt|;
specifier|const
name|bool
name|needMaskedColorClear
init|=
operator|(
name|flags
operator|&
name|D3DCLEAR_TARGET
operator|)
operator|&&
operator|!
operator|(
name|mState
operator|.
name|colorMaskRed
operator|&&
name|mState
operator|.
name|colorMaskGreen
operator|&&
name|mState
operator|.
name|colorMaskBlue
operator|&&
name|alphaUnmasked
operator|)
decl_stmt|;
if|if
condition|(
name|needMaskedColorClear
operator|||
name|needMaskedStencilClear
condition|)
block|{
comment|// State which is altered in all paths from this point to the clear call is saved.
comment|// State which is altered in only some paths will be flagged dirty in the case that
comment|//  that path is taken.
name|HRESULT
name|hr
decl_stmt|;
if|if
condition|(
name|mMaskedClearSavedState
operator|==
name|NULL
condition|)
block|{
name|hr
operator|=
name|mDevice
operator|->
name|BeginStateBlock
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
operator|||
name|hr
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|hr
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_FILLMODE
argument_list|,
name|D3DFILL_SOLID
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHATESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CLIPPLANEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetFVF
argument_list|(
name|D3DFVF_XYZRHW
operator||
name|D3DFVF_DIFFUSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetStreamSource
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLORARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAOP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TEXTUREFACTOR
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|SetStreamSourceFreq
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hr
operator|=
name|mDevice
operator|->
name|EndStateBlock
argument_list|(
operator|&
name|mMaskedClearSavedState
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
operator|||
name|hr
operator|==
name|D3DERR_OUTOFVIDEOMEMORY
operator|||
name|hr
operator|==
name|E_OUTOFMEMORY
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mMaskedClearSavedState
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mMaskedClearSavedState
operator|!=
name|NULL
condition|)
block|{
name|hr
operator|=
name|mMaskedClearSavedState
operator|->
name|Capture
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CULLMODE
argument_list|,
name|D3DCULL_NONE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_FILLMODE
argument_list|,
name|D3DFILL_SOLID
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHATESTENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ALPHABLENDENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_CLIPPLANEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|D3DCLEAR_TARGET
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
name|es2dx
operator|::
name|ConvertColorMask
argument_list|(
name|mState
operator|.
name|colorMaskRed
argument_list|,
name|mState
operator|.
name|colorMaskGreen
argument_list|,
name|mState
operator|.
name|colorMaskBlue
argument_list|,
name|mState
operator|.
name|colorMaskAlpha
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_COLORWRITEENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stencilUnmasked
operator|!=
literal|0x0
operator|&&
operator|(
name|flags
operator|&
name|D3DCLEAR_STENCIL
operator|)
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TWOSIDEDSTENCILMODE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILFUNC
argument_list|,
name|D3DCMP_ALWAYS
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILREF
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILWRITEMASK
argument_list|,
name|mState
operator|.
name|stencilWritemask
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILFAIL
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILZFAIL
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILPASS
argument_list|,
name|D3DSTENCILOP_REPLACE
argument_list|)
expr_stmt|;
name|mStencilStateDirty
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_STENCILENABLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mDevice
operator|->
name|SetPixelShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetVertexShader
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetFVF
argument_list|(
name|D3DFVF_XYZRHW
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_SEPARATEALPHABLENDENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLOROP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_COLORARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAOP
argument_list|,
name|D3DTOP_SELECTARG1
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetTextureStageState
argument_list|(
literal|0
argument_list|,
name|D3DTSS_ALPHAARG1
argument_list|,
name|D3DTA_TFACTOR
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_TEXTUREFACTOR
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_MULTISAMPLEMASK
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|SetStreamSourceFreq
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|float
name|quad
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
comment|// A quadrilateral covering the target, aligned to match the edges
name|quad
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|Height
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|Width
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|Height
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|2
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|mRenderTargetDesc
operator|.
name|Width
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|0.5f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|2
index|]
operator|=
literal|0.0f
expr_stmt|;
name|quad
index|[
literal|3
index|]
index|[
literal|3
index|]
operator|=
literal|1.0f
expr_stmt|;
name|mDisplay
operator|->
name|startScene
argument_list|()
expr_stmt|;
name|mDevice
operator|->
name|DrawPrimitiveUP
argument_list|(
name|D3DPT_TRIANGLESTRIP
argument_list|,
literal|2
argument_list|,
name|quad
argument_list|,
sizeof|sizeof
argument_list|(
name|float
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|D3DCLEAR_ZBUFFER
condition|)
block|{
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|SetRenderState
argument_list|(
name|D3DRS_ZWRITEENABLE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mDevice
operator|->
name|Clear
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|D3DCLEAR_ZBUFFER
argument_list|,
name|color
argument_list|,
name|depth
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mMaskedClearSavedState
operator|!=
name|NULL
condition|)
block|{
name|mMaskedClearSavedState
operator|->
name|Apply
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
condition|)
block|{
name|mDevice
operator|->
name|Clear
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|color
argument_list|,
name|depth
argument_list|,
name|stencil
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|drawArrays
name|void
name|Context
operator|::
name|drawArrays
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLint
name|first
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mState
operator|.
name|currentProgram
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|D3DPRIMITIVETYPE
name|primitiveType
decl_stmt|;
name|int
name|primitiveCount
decl_stmt|;
if|if
condition|(
operator|!
name|es2dx
operator|::
name|ConvertPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
operator|&
name|primitiveType
argument_list|,
operator|&
name|primitiveCount
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
if|if
condition|(
name|primitiveCount
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|applyState
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|GLsizei
name|repeatDraw
init|=
literal|1
decl_stmt|;
name|GLenum
name|err
init|=
name|applyVertexBuffer
argument_list|(
name|first
argument_list|,
name|count
argument_list|,
name|instances
argument_list|,
operator|&
name|repeatDraw
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|applyShaders
argument_list|()
expr_stmt|;
name|applyTextures
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getCurrentProgramBinary
argument_list|()
operator|->
name|validateSamplers
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|mDisplay
operator|->
name|startScene
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|GL_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
name|StaticIndexBuffer
modifier|*
name|countingIB
init|=
name|mIndexDataManager
operator|->
name|getCountingIndices
argument_list|(
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|countingIB
condition|)
block|{
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|countingIB
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|countingIB
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|countingIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|repeatDraw
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|primitiveType
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
name|primitiveCount
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Could not create a counting index buffer for glDrawArraysInstanced."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
else|else
comment|// Regular case
block|{
name|mDevice
operator|->
name|DrawPrimitive
argument_list|(
name|primitiveType
argument_list|,
literal|0
argument_list|,
name|primitiveCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|drawElements
name|void
name|Context
operator|::
name|drawElements
parameter_list|(
name|GLenum
name|mode
parameter_list|,
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|GLsizei
name|instances
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mState
operator|.
name|currentProgram
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|indices
operator|&&
operator|!
name|mState
operator|.
name|elementArrayBuffer
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|D3DPRIMITIVETYPE
name|primitiveType
decl_stmt|;
name|int
name|primitiveCount
decl_stmt|;
if|if
condition|(
operator|!
name|es2dx
operator|::
name|ConvertPrimitiveType
argument_list|(
name|mode
argument_list|,
name|count
argument_list|,
operator|&
name|primitiveType
argument_list|,
operator|&
name|primitiveCount
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|GL_INVALID_ENUM
argument_list|)
return|;
if|if
condition|(
name|primitiveCount
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|applyRenderTarget
argument_list|(
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|applyState
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|TranslatedIndexData
name|indexInfo
decl_stmt|;
name|GLenum
name|err
init|=
name|applyIndexBuffer
argument_list|(
name|indices
argument_list|,
name|count
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|indexInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|GLsizei
name|vertexCount
init|=
name|indexInfo
operator|.
name|maxIndex
operator|-
name|indexInfo
operator|.
name|minIndex
operator|+
literal|1
decl_stmt|;
name|GLsizei
name|repeatDraw
init|=
literal|1
decl_stmt|;
name|err
operator|=
name|applyVertexBuffer
argument_list|(
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|vertexCount
argument_list|,
name|instances
argument_list|,
operator|&
name|repeatDraw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|GL_NO_ERROR
condition|)
block|{
return|return
name|error
argument_list|(
name|err
argument_list|)
return|;
block|}
name|applyShaders
argument_list|()
expr_stmt|;
name|applyTextures
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getCurrentProgramBinary
argument_list|()
operator|->
name|validateSamplers
argument_list|(
literal|false
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|skipDraw
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|mDisplay
operator|->
name|startScene
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GL_LINE_LOOP
condition|)
block|{
name|drawLineLoop
argument_list|(
name|count
argument_list|,
name|type
argument_list|,
name|indices
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|repeatDraw
condition|;
name|i
operator|++
control|)
block|{
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|primitiveType
argument_list|,
operator|-
operator|(
name|INT
operator|)
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|indexInfo
operator|.
name|minIndex
argument_list|,
name|vertexCount
argument_list|,
name|indexInfo
operator|.
name|startIndex
argument_list|,
name|primitiveCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Implements glFlush when block is false, glFinish when block is true
DECL|function|sync
name|void
name|Context
operator|::
name|sync
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
name|mDisplay
operator|->
name|sync
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|function|drawLineLoop
name|void
name|Context
operator|::
name|drawLineLoop
parameter_list|(
name|GLsizei
name|count
parameter_list|,
name|GLenum
name|type
parameter_list|,
specifier|const
name|GLvoid
modifier|*
name|indices
parameter_list|,
name|int
name|minIndex
parameter_list|)
block|{
comment|// Get the raw indices for an indexed draw
if|if
condition|(
name|type
operator|!=
name|GL_NONE
operator|&&
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|get
argument_list|()
condition|)
block|{
name|Buffer
modifier|*
name|indexBuffer
init|=
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|intptr_t
name|offset
init|=
cast|reinterpret_cast
argument_list|<
name|intptr_t
argument_list|>
argument_list|(
name|indices
argument_list|)
decl_stmt|;
name|indices
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indexBuffer
operator|->
name|data
argument_list|()
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
name|UINT
name|startIndex
init|=
literal|0
decl_stmt|;
name|bool
name|succeeded
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|supports32bitIndices
argument_list|()
condition|)
block|{
specifier|const
name|int
name|spaceNeeded
init|=
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBuffer
argument_list|(
name|mDevice
argument_list|,
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|D3DFMT_INDEX32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|->
name|reserveSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_INT
argument_list|)
expr_stmt|;
name|UINT
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
modifier|*
name|data
init|=
cast|static_cast
argument_list|<
name|unsigned
name|int
operator|*
argument_list|>
argument_list|(
name|mLineLoopIB
operator|->
name|map
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|offset
argument_list|)
argument_list|)
decl_stmt|;
name|startIndex
operator|=
name|offset
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|mLineLoopIB
operator|->
name|unmap
argument_list|()
expr_stmt|;
name|succeeded
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|int
name|spaceNeeded
init|=
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|=
operator|new
name|StreamingIndexBuffer
argument_list|(
name|mDevice
argument_list|,
name|INITIAL_INDEX_BUFFER_SIZE
argument_list|,
name|D3DFMT_INDEX16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mLineLoopIB
condition|)
block|{
name|mLineLoopIB
operator|->
name|reserveSpace
argument_list|(
name|spaceNeeded
argument_list|,
name|GL_UNSIGNED_SHORT
argument_list|)
expr_stmt|;
name|UINT
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
modifier|*
name|data
init|=
cast|static_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|mLineLoopIB
operator|->
name|map
argument_list|(
name|spaceNeeded
argument_list|,
operator|&
name|offset
argument_list|)
argument_list|)
decl_stmt|;
name|startIndex
operator|=
name|offset
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GL_NONE
case|:
comment|// Non-indexed draw
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_BYTE
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLubyte
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_SHORT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLushort
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|GL_UNSIGNED_INT
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|data
index|[
name|count
index|]
operator|=
cast|static_cast
argument_list|<
specifier|const
name|GLuint
operator|*
argument_list|>
argument_list|(
name|indices
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
name|mLineLoopIB
operator|->
name|unmap
argument_list|()
expr_stmt|;
name|succeeded
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|succeeded
condition|)
block|{
if|if
condition|(
name|mAppliedIBSerial
operator|!=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
condition|)
block|{
name|mDevice
operator|->
name|SetIndices
argument_list|(
name|mLineLoopIB
operator|->
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|mAppliedIBSerial
operator|=
name|mLineLoopIB
operator|->
name|getSerial
argument_list|()
expr_stmt|;
block|}
name|mDevice
operator|->
name|DrawIndexedPrimitive
argument_list|(
name|D3DPT_LINESTRIP
argument_list|,
operator|-
name|minIndex
argument_list|,
name|minIndex
argument_list|,
name|count
argument_list|,
name|startIndex
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ERR
argument_list|(
literal|"Could not create a looping index buffer for GL_LINE_LOOP."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_OUT_OF_MEMORY
argument_list|)
return|;
block|}
block|}
DECL|function|recordInvalidEnum
name|void
name|Context
operator|::
name|recordInvalidEnum
parameter_list|()
block|{
name|mInvalidEnum
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidValue
name|void
name|Context
operator|::
name|recordInvalidValue
parameter_list|()
block|{
name|mInvalidValue
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidOperation
name|void
name|Context
operator|::
name|recordInvalidOperation
parameter_list|()
block|{
name|mInvalidOperation
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordOutOfMemory
name|void
name|Context
operator|::
name|recordOutOfMemory
parameter_list|()
block|{
name|mOutOfMemory
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|recordInvalidFramebufferOperation
name|void
name|Context
operator|::
name|recordInvalidFramebufferOperation
parameter_list|()
block|{
name|mInvalidFramebufferOperation
operator|=
literal|true
expr_stmt|;
block|}
comment|// Get one of the recorded errors and clear its flag, if any.
comment|// [OpenGL ES 2.0.24] section 2.5 page 13.
DECL|function|getError
name|GLenum
name|Context
operator|::
name|getError
parameter_list|()
block|{
if|if
condition|(
name|mInvalidEnum
condition|)
block|{
name|mInvalidEnum
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_ENUM
return|;
block|}
if|if
condition|(
name|mInvalidValue
condition|)
block|{
name|mInvalidValue
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_VALUE
return|;
block|}
if|if
condition|(
name|mInvalidOperation
condition|)
block|{
name|mInvalidOperation
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_OPERATION
return|;
block|}
if|if
condition|(
name|mOutOfMemory
condition|)
block|{
name|mOutOfMemory
operator|=
literal|false
expr_stmt|;
return|return
name|GL_OUT_OF_MEMORY
return|;
block|}
if|if
condition|(
name|mInvalidFramebufferOperation
condition|)
block|{
name|mInvalidFramebufferOperation
operator|=
literal|false
expr_stmt|;
return|return
name|GL_INVALID_FRAMEBUFFER_OPERATION
return|;
block|}
return|return
name|GL_NO_ERROR
return|;
block|}
DECL|function|getResetStatus
name|GLenum
name|Context
operator|::
name|getResetStatus
parameter_list|()
block|{
if|if
condition|(
name|mResetStatus
operator|==
name|GL_NO_ERROR
condition|)
block|{
name|bool
name|lost
init|=
name|mDisplay
operator|->
name|testDeviceLost
argument_list|()
decl_stmt|;
if|if
condition|(
name|lost
condition|)
block|{
name|mDisplay
operator|->
name|notifyDeviceLost
argument_list|()
expr_stmt|;
comment|// Sets mResetStatus
block|}
block|}
name|GLenum
name|status
init|=
name|mResetStatus
decl_stmt|;
if|if
condition|(
name|mResetStatus
operator|!=
name|GL_NO_ERROR
condition|)
block|{
if|if
condition|(
name|mDisplay
operator|->
name|testDeviceResettable
argument_list|()
condition|)
block|{
name|mResetStatus
operator|=
name|GL_NO_ERROR
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
DECL|function|isResetNotificationEnabled
name|bool
name|Context
operator|::
name|isResetNotificationEnabled
parameter_list|()
block|{
return|return
operator|(
name|mResetStrategy
operator|==
name|GL_LOSE_CONTEXT_ON_RESET_EXT
operator|)
return|;
block|}
DECL|function|supportsShaderModel3
name|bool
name|Context
operator|::
name|supportsShaderModel3
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsShaderModel3
return|;
block|}
DECL|function|getMaximumPointSize
name|float
name|Context
operator|::
name|getMaximumPointSize
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsShaderModel3
condition|?
name|mMaximumPointSize
else|:
name|ALIASED_POINT_SIZE_RANGE_MAX_SM2
return|;
block|}
DECL|function|getMaximumVaryingVectors
name|int
name|Context
operator|::
name|getMaximumVaryingVectors
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsShaderModel3
condition|?
name|MAX_VARYING_VECTORS_SM3
else|:
name|MAX_VARYING_VECTORS_SM2
return|;
block|}
DECL|function|getMaximumVertexTextureImageUnits
name|unsigned
name|int
name|Context
operator|::
name|getMaximumVertexTextureImageUnits
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsVertexTexture
condition|?
name|MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF
else|:
literal|0
return|;
block|}
DECL|function|getMaximumCombinedTextureImageUnits
name|unsigned
name|int
name|Context
operator|::
name|getMaximumCombinedTextureImageUnits
parameter_list|()
specifier|const
block|{
return|return
name|MAX_TEXTURE_IMAGE_UNITS
operator|+
name|getMaximumVertexTextureImageUnits
argument_list|()
return|;
block|}
DECL|function|getMaximumFragmentUniformVectors
name|int
name|Context
operator|::
name|getMaximumFragmentUniformVectors
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsShaderModel3
condition|?
name|MAX_FRAGMENT_UNIFORM_VECTORS_SM3
else|:
name|MAX_FRAGMENT_UNIFORM_VECTORS_SM2
return|;
block|}
DECL|function|getMaxSupportedSamples
name|int
name|Context
operator|::
name|getMaxSupportedSamples
parameter_list|()
specifier|const
block|{
return|return
name|mMaxSupportedSamples
return|;
block|}
DECL|function|getNearestSupportedSamples
name|int
name|Context
operator|::
name|getNearestSupportedSamples
parameter_list|(
name|D3DFORMAT
name|format
parameter_list|,
name|int
name|requested
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|requested
operator|==
literal|0
condition|)
block|{
return|return
name|requested
return|;
block|}
name|std
operator|::
name|map
argument_list|<
name|D3DFORMAT
argument_list|,
name|bool
modifier|*
argument_list|>
operator|::
name|const_iterator
name|itr
init|=
name|mMultiSampleSupport
operator|.
name|find
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|itr
operator|==
name|mMultiSampleSupport
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|int
name|i
init|=
name|requested
init|;
name|i
operator|<=
name|D3DMULTISAMPLE_16_SAMPLES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|itr
operator|->
name|second
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|D3DMULTISAMPLE_NONMASKABLE
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|supportsEventQueries
name|bool
name|Context
operator|::
name|supportsEventQueries
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsEventQueries
return|;
block|}
DECL|function|supportsOcclusionQueries
name|bool
name|Context
operator|::
name|supportsOcclusionQueries
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsOcclusionQueries
return|;
block|}
DECL|function|supportsDXT1Textures
name|bool
name|Context
operator|::
name|supportsDXT1Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDXT1Textures
return|;
block|}
DECL|function|supportsDXT3Textures
name|bool
name|Context
operator|::
name|supportsDXT3Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDXT3Textures
return|;
block|}
DECL|function|supportsDXT5Textures
name|bool
name|Context
operator|::
name|supportsDXT5Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDXT5Textures
return|;
block|}
DECL|function|supportsFloat32Textures
name|bool
name|Context
operator|::
name|supportsFloat32Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat32Textures
return|;
block|}
DECL|function|supportsFloat32LinearFilter
name|bool
name|Context
operator|::
name|supportsFloat32LinearFilter
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat32LinearFilter
return|;
block|}
DECL|function|supportsFloat32RenderableTextures
name|bool
name|Context
operator|::
name|supportsFloat32RenderableTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat32RenderableTextures
return|;
block|}
DECL|function|supportsFloat16Textures
name|bool
name|Context
operator|::
name|supportsFloat16Textures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat16Textures
return|;
block|}
DECL|function|supportsFloat16LinearFilter
name|bool
name|Context
operator|::
name|supportsFloat16LinearFilter
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat16LinearFilter
return|;
block|}
DECL|function|supportsFloat16RenderableTextures
name|bool
name|Context
operator|::
name|supportsFloat16RenderableTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsFloat16RenderableTextures
return|;
block|}
DECL|function|getMaximumRenderbufferDimension
name|int
name|Context
operator|::
name|getMaximumRenderbufferDimension
parameter_list|()
specifier|const
block|{
return|return
name|mMaxRenderbufferDimension
return|;
block|}
DECL|function|getMaximumTextureDimension
name|int
name|Context
operator|::
name|getMaximumTextureDimension
parameter_list|()
specifier|const
block|{
return|return
name|mMaxTextureDimension
return|;
block|}
DECL|function|getMaximumCubeTextureDimension
name|int
name|Context
operator|::
name|getMaximumCubeTextureDimension
parameter_list|()
specifier|const
block|{
return|return
name|mMaxCubeTextureDimension
return|;
block|}
DECL|function|getMaximumTextureLevel
name|int
name|Context
operator|::
name|getMaximumTextureLevel
parameter_list|()
specifier|const
block|{
return|return
name|mMaxTextureLevel
return|;
block|}
DECL|function|supportsLuminanceTextures
name|bool
name|Context
operator|::
name|supportsLuminanceTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsLuminanceTextures
return|;
block|}
DECL|function|supportsLuminanceAlphaTextures
name|bool
name|Context
operator|::
name|supportsLuminanceAlphaTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsLuminanceAlphaTextures
return|;
block|}
DECL|function|supportsDepthTextures
name|bool
name|Context
operator|::
name|supportsDepthTextures
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsDepthTextures
return|;
block|}
DECL|function|supports32bitIndices
name|bool
name|Context
operator|::
name|supports32bitIndices
parameter_list|()
specifier|const
block|{
return|return
name|mSupports32bitIndices
return|;
block|}
DECL|function|supportsNonPower2Texture
name|bool
name|Context
operator|::
name|supportsNonPower2Texture
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsNonPower2Texture
return|;
block|}
DECL|function|supportsInstancing
name|bool
name|Context
operator|::
name|supportsInstancing
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsInstancing
return|;
block|}
DECL|function|supportsTextureFilterAnisotropy
name|bool
name|Context
operator|::
name|supportsTextureFilterAnisotropy
parameter_list|()
specifier|const
block|{
return|return
name|mSupportsTextureFilterAnisotropy
return|;
block|}
DECL|function|getTextureMaxAnisotropy
name|float
name|Context
operator|::
name|getTextureMaxAnisotropy
parameter_list|()
specifier|const
block|{
return|return
name|mMaxTextureAnisotropy
return|;
block|}
DECL|function|getCurrentReadFormatType
name|bool
name|Context
operator|::
name|getCurrentReadFormatType
parameter_list|(
name|GLenum
modifier|*
name|format
parameter_list|,
name|GLenum
modifier|*
name|type
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|framebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|framebuffer
operator|||
name|framebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|Renderbuffer
modifier|*
name|renderbuffer
init|=
name|framebuffer
operator|->
name|getColorbuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|renderbuffer
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|dx2es
operator|::
name|ConvertReadBufferFormat
argument_list|(
name|renderbuffer
operator|->
name|getD3DFormat
argument_list|()
argument_list|,
name|format
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|function|detachBuffer
name|void
name|Context
operator|::
name|detachBuffer
parameter_list|(
name|GLuint
name|buffer
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 2.9 page 22:
comment|// If a buffer object is deleted while it is bound, all bindings to that object in the current context
comment|// (i.e. in the thread that called Delete-Buffers) are reset to zero.
if|if
condition|(
name|mState
operator|.
name|arrayBuffer
operator|.
name|id
argument_list|()
operator|==
name|buffer
condition|)
block|{
name|mState
operator|.
name|arrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|id
argument_list|()
operator|==
name|buffer
condition|)
block|{
name|mState
operator|.
name|elementArrayBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|attribute
init|=
literal|0
init|;
name|attribute
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|attribute
operator|++
control|)
block|{
if|if
condition|(
name|mState
operator|.
name|vertexAttribute
index|[
name|attribute
index|]
operator|.
name|mBoundBuffer
operator|.
name|id
argument_list|()
operator|==
name|buffer
condition|)
block|{
name|mState
operator|.
name|vertexAttribute
index|[
name|attribute
index|]
operator|.
name|mBoundBuffer
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|detachTexture
name|void
name|Context
operator|::
name|detachTexture
parameter_list|(
name|GLuint
name|texture
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 3.8 page 84:
comment|// If a texture object is deleted, it is as if all texture units which are bound to that texture object are
comment|// rebound to texture object zero
for|for
control|(
name|int
name|type
init|=
literal|0
init|;
name|type
operator|<
name|TEXTURE_TYPE_COUNT
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|int
name|sampler
init|=
literal|0
init|;
name|sampler
operator|<
name|MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF
condition|;
name|sampler
operator|++
control|)
block|{
if|if
condition|(
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|id
argument_list|()
operator|==
name|texture
condition|)
block|{
name|mState
operator|.
name|samplerTexture
index|[
name|type
index|]
index|[
name|sampler
index|]
operator|.
name|set
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// [OpenGL ES 2.0.24] section 4.4 page 112:
comment|// If a texture object is deleted while its image is attached to the currently bound framebuffer, then it is
comment|// as if FramebufferTexture2D had been called, with a texture of 0, for each attachment point to which this
comment|// image was attached in the currently bound framebuffer.
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readFramebuffer
condition|)
block|{
name|readFramebuffer
operator|->
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|&&
name|drawFramebuffer
operator|!=
name|readFramebuffer
condition|)
block|{
name|drawFramebuffer
operator|->
name|detachTexture
argument_list|(
name|texture
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachFramebuffer
name|void
name|Context
operator|::
name|detachFramebuffer
parameter_list|(
name|GLuint
name|framebuffer
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 4.4 page 107:
comment|// If a framebuffer that is currently bound to the target FRAMEBUFFER is deleted, it is as though
comment|// BindFramebuffer had been executed with the target of FRAMEBUFFER and framebuffer of zero.
if|if
condition|(
name|mState
operator|.
name|readFramebuffer
operator|==
name|framebuffer
condition|)
block|{
name|bindReadFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mState
operator|.
name|drawFramebuffer
operator|==
name|framebuffer
condition|)
block|{
name|bindDrawFramebuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|detachRenderbuffer
name|void
name|Context
operator|::
name|detachRenderbuffer
parameter_list|(
name|GLuint
name|renderbuffer
parameter_list|)
block|{
comment|// [OpenGL ES 2.0.24] section 4.4 page 109:
comment|// If a renderbuffer that is currently bound to RENDERBUFFER is deleted, it is as though BindRenderbuffer
comment|// had been executed with the target RENDERBUFFER and name of zero.
if|if
condition|(
name|mState
operator|.
name|renderbuffer
operator|.
name|id
argument_list|()
operator|==
name|renderbuffer
condition|)
block|{
name|bindRenderbuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// [OpenGL ES 2.0.24] section 4.4 page 111:
comment|// If a renderbuffer object is deleted while its image is attached to the currently bound framebuffer,
comment|// then it is as if FramebufferRenderbuffer had been called, with a renderbuffer of 0, for each attachment
comment|// point to which this image was attached in the currently bound framebuffer.
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|readFramebuffer
condition|)
block|{
name|readFramebuffer
operator|->
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|&&
name|drawFramebuffer
operator|!=
name|readFramebuffer
condition|)
block|{
name|drawFramebuffer
operator|->
name|detachRenderbuffer
argument_list|(
name|renderbuffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getIncompleteTexture
name|Texture
modifier|*
name|Context
operator|::
name|getIncompleteTexture
parameter_list|(
name|TextureType
name|type
parameter_list|)
block|{
name|Texture
modifier|*
name|t
init|=
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
specifier|static
specifier|const
name|GLubyte
name|color
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|255
block|}
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
comment|// default falls through to TEXTURE_2D
case|case
name|TEXTURE_2D
case|:
block|{
name|Texture2D
modifier|*
name|incomplete2d
init|=
operator|new
name|Texture2D
argument_list|(
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incomplete2d
operator|->
name|setImage
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incomplete2d
expr_stmt|;
block|}
break|break;
case|case
name|TEXTURE_CUBE
case|:
block|{
name|TextureCubeMap
modifier|*
name|incompleteCube
init|=
operator|new
name|TextureCubeMap
argument_list|(
name|Texture
operator|::
name|INCOMPLETE_TEXTURE_ID
argument_list|)
decl_stmt|;
name|incompleteCube
operator|->
name|setImagePosX
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegX
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImagePosY
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegY
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImagePosZ
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|incompleteCube
operator|->
name|setImageNegZ
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|GL_RGBA
argument_list|,
name|GL_UNSIGNED_BYTE
argument_list|,
literal|1
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|t
operator|=
name|incompleteCube
expr_stmt|;
block|}
break|break;
block|}
name|mIncompleteTextures
index|[
name|type
index|]
operator|.
name|set
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
DECL|function|skipDraw
name|bool
name|Context
operator|::
name|skipDraw
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
if|if
condition|(
name|drawMode
operator|==
name|GL_POINTS
condition|)
block|{
comment|// ProgramBinary assumes non-point rendering if gl_PointSize isn't written,
comment|// which affects varying interpolation. Since the value of gl_PointSize is
comment|// undefined when not written, just skip drawing to avoid unexpected results.
if|if
condition|(
operator|!
name|getCurrentProgramBinary
argument_list|()
operator|->
name|usesPointSize
argument_list|()
condition|)
block|{
comment|// This is stictly speaking not an error, but developers should be
comment|// notified of risking undefined behavior.
name|ERR
argument_list|(
literal|"Point rendering without writing to gl_PointSize."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|isTriangleMode
argument_list|(
name|drawMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mState
operator|.
name|cullFace
operator|&&
name|mState
operator|.
name|cullMode
operator|==
name|GL_FRONT_AND_BACK
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|function|isTriangleMode
name|bool
name|Context
operator|::
name|isTriangleMode
parameter_list|(
name|GLenum
name|drawMode
parameter_list|)
block|{
switch|switch
condition|(
name|drawMode
condition|)
block|{
case|case
name|GL_TRIANGLES
case|:
case|case
name|GL_TRIANGLE_FAN
case|:
case|case
name|GL_TRIANGLE_STRIP
case|:
return|return
literal|true
return|;
case|case
name|GL_POINTS
case|:
case|case
name|GL_LINES
case|:
case|case
name|GL_LINE_LOOP
case|:
case|case
name|GL_LINE_STRIP
case|:
return|return
literal|false
return|;
default|default:
name|UNREACHABLE
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|setVertexAttrib
name|void
name|Context
operator|::
name|setVertexAttrib
parameter_list|(
name|GLuint
name|index
parameter_list|,
specifier|const
name|GLfloat
modifier|*
name|values
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|0
index|]
operator|=
name|values
index|[
literal|0
index|]
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|1
index|]
operator|=
name|values
index|[
literal|1
index|]
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|2
index|]
operator|=
name|values
index|[
literal|2
index|]
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mCurrentValue
index|[
literal|3
index|]
operator|=
name|values
index|[
literal|3
index|]
expr_stmt|;
name|mVertexDataManager
operator|->
name|dirtyCurrentValue
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
DECL|function|setVertexAttribDivisor
name|void
name|Context
operator|::
name|setVertexAttribDivisor
parameter_list|(
name|GLuint
name|index
parameter_list|,
name|GLuint
name|divisor
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|index
operator|<
name|gl
operator|::
name|MAX_VERTEX_ATTRIBS
argument_list|)
expr_stmt|;
name|mState
operator|.
name|vertexAttribute
index|[
name|index
index|]
operator|.
name|mDivisor
operator|=
name|divisor
expr_stmt|;
block|}
comment|// keep list sorted in following order
comment|// OES extensions
comment|// EXT extensions
comment|// Vendor extensions
DECL|function|initExtensionString
name|void
name|Context
operator|::
name|initExtensionString
parameter_list|()
block|{
name|mExtensionString
operator|=
literal|""
expr_stmt|;
comment|// OES extensions
if|if
condition|(
name|supports32bitIndices
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_OES_element_index_uint "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"GL_OES_packed_depth_stencil "
expr_stmt|;
name|mExtensionString
operator|+=
literal|"GL_OES_get_program_binary "
expr_stmt|;
name|mExtensionString
operator|+=
literal|"GL_OES_rgb8_rgba8 "
expr_stmt|;
name|mExtensionString
operator|+=
literal|"GL_OES_standard_derivatives "
expr_stmt|;
if|if
condition|(
name|supportsFloat16Textures
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_OES_texture_half_float "
expr_stmt|;
block|}
if|if
condition|(
name|supportsFloat16LinearFilter
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_OES_texture_half_float_linear "
expr_stmt|;
block|}
if|if
condition|(
name|supportsFloat32Textures
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_OES_texture_float "
expr_stmt|;
block|}
if|if
condition|(
name|supportsFloat32LinearFilter
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_OES_texture_float_linear "
expr_stmt|;
block|}
if|if
condition|(
name|supportsNonPower2Texture
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_OES_texture_npot "
expr_stmt|;
block|}
comment|// Multi-vendor (EXT) extensions
if|if
condition|(
name|supportsOcclusionQueries
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_EXT_occlusion_query_boolean "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"GL_EXT_read_format_bgra "
expr_stmt|;
name|mExtensionString
operator|+=
literal|"GL_EXT_robustness "
expr_stmt|;
if|if
condition|(
name|supportsDXT1Textures
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_EXT_texture_compression_dxt1 "
expr_stmt|;
block|}
if|if
condition|(
name|supportsTextureFilterAnisotropy
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_EXT_texture_filter_anisotropic "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"GL_EXT_texture_format_BGRA8888 "
expr_stmt|;
name|mExtensionString
operator|+=
literal|"GL_EXT_texture_storage "
expr_stmt|;
comment|// ANGLE-specific extensions
if|if
condition|(
name|supportsDepthTextures
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_ANGLE_depth_texture "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"GL_ANGLE_framebuffer_blit "
expr_stmt|;
if|if
condition|(
name|getMaxSupportedSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_ANGLE_framebuffer_multisample "
expr_stmt|;
block|}
if|if
condition|(
name|supportsInstancing
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_ANGLE_instanced_arrays "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"GL_ANGLE_pack_reverse_row_order "
expr_stmt|;
if|if
condition|(
name|supportsDXT3Textures
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_ANGLE_texture_compression_dxt3 "
expr_stmt|;
block|}
if|if
condition|(
name|supportsDXT5Textures
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_ANGLE_texture_compression_dxt5 "
expr_stmt|;
block|}
name|mExtensionString
operator|+=
literal|"GL_ANGLE_texture_usage "
expr_stmt|;
name|mExtensionString
operator|+=
literal|"GL_ANGLE_translated_shader_source "
expr_stmt|;
comment|// Other vendor-specific extensions
if|if
condition|(
name|supportsEventQueries
argument_list|()
condition|)
block|{
name|mExtensionString
operator|+=
literal|"GL_NV_fence "
expr_stmt|;
block|}
name|std
operator|::
name|string
operator|::
name|size_type
name|end
init|=
name|mExtensionString
operator|.
name|find_last_not_of
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|std
operator|::
name|string
operator|::
name|npos
condition|)
block|{
name|mExtensionString
operator|.
name|resize
argument_list|(
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|getExtensionString
specifier|const
name|char
modifier|*
name|Context
operator|::
name|getExtensionString
parameter_list|()
specifier|const
block|{
return|return
name|mExtensionString
operator|.
name|c_str
argument_list|()
return|;
block|}
DECL|function|initRendererString
name|void
name|Context
operator|::
name|initRendererString
parameter_list|()
block|{
name|D3DADAPTER_IDENTIFIER9
modifier|*
name|identifier
init|=
name|mDisplay
operator|->
name|getAdapterIdentifier
argument_list|()
decl_stmt|;
name|mRendererString
operator|=
literal|"ANGLE ("
expr_stmt|;
name|mRendererString
operator|+=
name|identifier
operator|->
name|Description
expr_stmt|;
name|mRendererString
operator|+=
literal|")"
expr_stmt|;
block|}
DECL|function|getRendererString
specifier|const
name|char
modifier|*
name|Context
operator|::
name|getRendererString
parameter_list|()
specifier|const
block|{
return|return
name|mRendererString
operator|.
name|c_str
argument_list|()
return|;
block|}
DECL|function|blitFramebuffer
name|void
name|Context
operator|::
name|blitFramebuffer
parameter_list|(
name|GLint
name|srcX0
parameter_list|,
name|GLint
name|srcY0
parameter_list|,
name|GLint
name|srcX1
parameter_list|,
name|GLint
name|srcY1
parameter_list|,
name|GLint
name|dstX0
parameter_list|,
name|GLint
name|dstY0
parameter_list|,
name|GLint
name|dstX1
parameter_list|,
name|GLint
name|dstY1
parameter_list|,
name|GLbitfield
name|mask
parameter_list|)
block|{
name|Framebuffer
modifier|*
name|readFramebuffer
init|=
name|getReadFramebuffer
argument_list|()
decl_stmt|;
name|Framebuffer
modifier|*
name|drawFramebuffer
init|=
name|getDrawFramebuffer
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|readFramebuffer
operator|||
name|readFramebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
operator|||
operator|!
name|drawFramebuffer
operator|||
name|drawFramebuffer
operator|->
name|completeness
argument_list|()
operator|!=
name|GL_FRAMEBUFFER_COMPLETE
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_FRAMEBUFFER_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|drawFramebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|int
name|readBufferWidth
init|=
name|readFramebuffer
operator|->
name|getColorbuffer
argument_list|()
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|readBufferHeight
init|=
name|readFramebuffer
operator|->
name|getColorbuffer
argument_list|()
operator|->
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|drawBufferWidth
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|()
operator|->
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|drawBufferHeight
init|=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|()
operator|->
name|getHeight
argument_list|()
decl_stmt|;
name|RECT
name|sourceRect
decl_stmt|;
name|RECT
name|destRect
decl_stmt|;
if|if
condition|(
name|srcX0
operator|<
name|srcX1
condition|)
block|{
name|sourceRect
operator|.
name|left
operator|=
name|srcX0
expr_stmt|;
name|sourceRect
operator|.
name|right
operator|=
name|srcX1
expr_stmt|;
name|destRect
operator|.
name|left
operator|=
name|dstX0
expr_stmt|;
name|destRect
operator|.
name|right
operator|=
name|dstX1
expr_stmt|;
block|}
else|else
block|{
name|sourceRect
operator|.
name|left
operator|=
name|srcX1
expr_stmt|;
name|destRect
operator|.
name|left
operator|=
name|dstX1
expr_stmt|;
name|sourceRect
operator|.
name|right
operator|=
name|srcX0
expr_stmt|;
name|destRect
operator|.
name|right
operator|=
name|dstX0
expr_stmt|;
block|}
if|if
condition|(
name|srcY0
operator|<
name|srcY1
condition|)
block|{
name|sourceRect
operator|.
name|bottom
operator|=
name|srcY1
expr_stmt|;
name|destRect
operator|.
name|bottom
operator|=
name|dstY1
expr_stmt|;
name|sourceRect
operator|.
name|top
operator|=
name|srcY0
expr_stmt|;
name|destRect
operator|.
name|top
operator|=
name|dstY0
expr_stmt|;
block|}
else|else
block|{
name|sourceRect
operator|.
name|bottom
operator|=
name|srcY0
expr_stmt|;
name|destRect
operator|.
name|bottom
operator|=
name|dstY0
expr_stmt|;
name|sourceRect
operator|.
name|top
operator|=
name|srcY1
expr_stmt|;
name|destRect
operator|.
name|top
operator|=
name|dstY1
expr_stmt|;
block|}
name|RECT
name|sourceScissoredRect
init|=
name|sourceRect
decl_stmt|;
name|RECT
name|destScissoredRect
init|=
name|destRect
decl_stmt|;
if|if
condition|(
name|mState
operator|.
name|scissorTest
condition|)
block|{
comment|// Only write to parts of the destination framebuffer which pass the scissor test
comment|// Please note: the destRect is now in D3D-style coordinates, so the *top* of the
comment|// rect will be checked against scissorY, rather than the bottom.
if|if
condition|(
name|destRect
operator|.
name|left
operator|<
name|mState
operator|.
name|scissorX
condition|)
block|{
name|int
name|xDiff
init|=
name|mState
operator|.
name|scissorX
operator|-
name|destRect
operator|.
name|left
decl_stmt|;
name|destScissoredRect
operator|.
name|left
operator|=
name|mState
operator|.
name|scissorX
expr_stmt|;
name|sourceScissoredRect
operator|.
name|left
operator|+=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destRect
operator|.
name|right
operator|>
name|mState
operator|.
name|scissorX
operator|+
name|mState
operator|.
name|scissorWidth
condition|)
block|{
name|int
name|xDiff
init|=
name|destRect
operator|.
name|right
operator|-
operator|(
name|mState
operator|.
name|scissorX
operator|+
name|mState
operator|.
name|scissorWidth
operator|)
decl_stmt|;
name|destScissoredRect
operator|.
name|right
operator|=
name|mState
operator|.
name|scissorX
operator|+
name|mState
operator|.
name|scissorWidth
expr_stmt|;
name|sourceScissoredRect
operator|.
name|right
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destRect
operator|.
name|top
operator|<
name|mState
operator|.
name|scissorY
condition|)
block|{
name|int
name|yDiff
init|=
name|mState
operator|.
name|scissorY
operator|-
name|destRect
operator|.
name|top
decl_stmt|;
name|destScissoredRect
operator|.
name|top
operator|=
name|mState
operator|.
name|scissorY
expr_stmt|;
name|sourceScissoredRect
operator|.
name|top
operator|+=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|destRect
operator|.
name|bottom
operator|>
name|mState
operator|.
name|scissorY
operator|+
name|mState
operator|.
name|scissorHeight
condition|)
block|{
name|int
name|yDiff
init|=
name|destRect
operator|.
name|bottom
operator|-
operator|(
name|mState
operator|.
name|scissorY
operator|+
name|mState
operator|.
name|scissorHeight
operator|)
decl_stmt|;
name|destScissoredRect
operator|.
name|bottom
operator|=
name|mState
operator|.
name|scissorY
operator|+
name|mState
operator|.
name|scissorHeight
expr_stmt|;
name|sourceScissoredRect
operator|.
name|bottom
operator|-=
name|yDiff
expr_stmt|;
block|}
block|}
name|bool
name|blitRenderTarget
init|=
literal|false
decl_stmt|;
name|bool
name|blitDepthStencil
init|=
literal|false
decl_stmt|;
name|RECT
name|sourceTrimmedRect
init|=
name|sourceScissoredRect
decl_stmt|;
name|RECT
name|destTrimmedRect
init|=
name|destScissoredRect
decl_stmt|;
comment|// The source& destination rectangles also may need to be trimmed if they fall out of the bounds of
comment|// the actual draw and read surfaces.
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|left
operator|<
literal|0
condition|)
block|{
name|int
name|xDiff
init|=
literal|0
operator|-
name|sourceTrimmedRect
operator|.
name|left
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|destTrimmedRect
operator|.
name|left
operator|+=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|right
operator|>
name|readBufferWidth
condition|)
block|{
name|int
name|xDiff
init|=
name|sourceTrimmedRect
operator|.
name|right
operator|-
name|readBufferWidth
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|right
operator|=
name|readBufferWidth
expr_stmt|;
name|destTrimmedRect
operator|.
name|right
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|top
operator|<
literal|0
condition|)
block|{
name|int
name|yDiff
init|=
literal|0
operator|-
name|sourceTrimmedRect
operator|.
name|top
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|destTrimmedRect
operator|.
name|top
operator|+=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|bottom
operator|>
name|readBufferHeight
condition|)
block|{
name|int
name|yDiff
init|=
name|sourceTrimmedRect
operator|.
name|bottom
operator|-
name|readBufferHeight
decl_stmt|;
name|sourceTrimmedRect
operator|.
name|bottom
operator|=
name|readBufferHeight
expr_stmt|;
name|destTrimmedRect
operator|.
name|bottom
operator|-=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|left
operator|<
literal|0
condition|)
block|{
name|int
name|xDiff
init|=
literal|0
operator|-
name|destTrimmedRect
operator|.
name|left
decl_stmt|;
name|destTrimmedRect
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|left
operator|+=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|right
operator|>
name|drawBufferWidth
condition|)
block|{
name|int
name|xDiff
init|=
name|destTrimmedRect
operator|.
name|right
operator|-
name|drawBufferWidth
decl_stmt|;
name|destTrimmedRect
operator|.
name|right
operator|=
name|drawBufferWidth
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|right
operator|-=
name|xDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|top
operator|<
literal|0
condition|)
block|{
name|int
name|yDiff
init|=
literal|0
operator|-
name|destTrimmedRect
operator|.
name|top
decl_stmt|;
name|destTrimmedRect
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|top
operator|+=
name|yDiff
expr_stmt|;
block|}
if|if
condition|(
name|destTrimmedRect
operator|.
name|bottom
operator|>
name|drawBufferHeight
condition|)
block|{
name|int
name|yDiff
init|=
name|destTrimmedRect
operator|.
name|bottom
operator|-
name|drawBufferHeight
decl_stmt|;
name|destTrimmedRect
operator|.
name|bottom
operator|=
name|drawBufferHeight
expr_stmt|;
name|sourceTrimmedRect
operator|.
name|bottom
operator|-=
name|yDiff
expr_stmt|;
block|}
name|bool
name|partialBufferCopy
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|sourceTrimmedRect
operator|.
name|bottom
operator|-
name|sourceTrimmedRect
operator|.
name|top
operator|<
name|readBufferHeight
operator|||
name|sourceTrimmedRect
operator|.
name|right
operator|-
name|sourceTrimmedRect
operator|.
name|left
operator|<
name|readBufferWidth
operator|||
name|destTrimmedRect
operator|.
name|bottom
operator|-
name|destTrimmedRect
operator|.
name|top
operator|<
name|drawBufferHeight
operator|||
name|destTrimmedRect
operator|.
name|right
operator|-
name|destTrimmedRect
operator|.
name|left
operator|<
name|drawBufferWidth
operator|||
name|sourceTrimmedRect
operator|.
name|top
operator|!=
literal|0
operator|||
name|destTrimmedRect
operator|.
name|top
operator|!=
literal|0
operator|||
name|sourceTrimmedRect
operator|.
name|left
operator|!=
literal|0
operator|||
name|destTrimmedRect
operator|.
name|left
operator|!=
literal|0
condition|)
block|{
name|partialBufferCopy
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|GL_COLOR_BUFFER_BIT
condition|)
block|{
specifier|const
name|bool
name|validReadType
init|=
name|readFramebuffer
operator|->
name|getColorbufferType
argument_list|()
operator|==
name|GL_TEXTURE_2D
operator|||
name|readFramebuffer
operator|->
name|getColorbufferType
argument_list|()
operator|==
name|GL_RENDERBUFFER
decl_stmt|;
specifier|const
name|bool
name|validDrawType
init|=
name|drawFramebuffer
operator|->
name|getColorbufferType
argument_list|()
operator|==
name|GL_TEXTURE_2D
operator|||
name|drawFramebuffer
operator|->
name|getColorbufferType
argument_list|()
operator|==
name|GL_RENDERBUFFER
decl_stmt|;
if|if
condition|(
operator|!
name|validReadType
operator|||
operator|!
name|validDrawType
operator|||
name|readFramebuffer
operator|->
name|getColorbuffer
argument_list|()
operator|->
name|getD3DFormat
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getColorbuffer
argument_list|()
operator|->
name|getD3DFormat
argument_list|()
condition|)
block|{
name|ERR
argument_list|(
literal|"Color buffer format conversion in BlitFramebufferANGLE not supported by this implementation"
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
if|if
condition|(
name|partialBufferCopy
operator|&&
name|readFramebuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|blitRenderTarget
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|GL_DEPTH_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
operator|)
condition|)
block|{
name|Renderbuffer
modifier|*
name|readDSBuffer
init|=
name|NULL
decl_stmt|;
name|Renderbuffer
modifier|*
name|drawDSBuffer
init|=
name|NULL
decl_stmt|;
comment|// We support OES_packed_depth_stencil, and do not support a separately attached depth and stencil buffer, so if we have
comment|// both a depth and stencil buffer, it will be the same buffer.
if|if
condition|(
name|mask
operator|&
name|GL_DEPTH_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getDepthbufferType
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getDepthbufferType
argument_list|()
operator|||
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|->
name|getD3DFormat
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
operator|->
name|getD3DFormat
argument_list|()
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|blitDepthStencil
operator|=
literal|true
expr_stmt|;
name|readDSBuffer
operator|=
name|readFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
expr_stmt|;
name|drawDSBuffer
operator|=
name|drawFramebuffer
operator|->
name|getDepthbuffer
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|GL_STENCIL_BUFFER_BIT
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|&&
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
condition|)
block|{
if|if
condition|(
name|readFramebuffer
operator|->
name|getStencilbufferType
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getStencilbufferType
argument_list|()
operator|||
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getD3DFormat
argument_list|()
operator|!=
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
operator|->
name|getD3DFormat
argument_list|()
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
name|blitDepthStencil
operator|=
literal|true
expr_stmt|;
name|readDSBuffer
operator|=
name|readFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
name|drawDSBuffer
operator|=
name|drawFramebuffer
operator|->
name|getStencilbuffer
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|partialBufferCopy
condition|)
block|{
name|ERR
argument_list|(
literal|"Only whole-buffer depth and stencil blits are supported by this implementation."
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
comment|// only whole-buffer copies are permitted
block|}
if|if
condition|(
operator|(
name|drawDSBuffer
operator|&&
name|drawDSBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
name|readDSBuffer
operator|&&
name|readDSBuffer
operator|->
name|getSamples
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
name|GL_INVALID_OPERATION
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|blitRenderTarget
operator|||
name|blitDepthStencil
condition|)
block|{
name|mDisplay
operator|->
name|endScene
argument_list|()
expr_stmt|;
if|if
condition|(
name|blitRenderTarget
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|readRenderTarget
init|=
name|readFramebuffer
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|drawRenderTarget
init|=
name|drawFramebuffer
operator|->
name|getRenderTarget
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|StretchRect
argument_list|(
name|readRenderTarget
argument_list|,
operator|&
name|sourceTrimmedRect
argument_list|,
name|drawRenderTarget
argument_list|,
operator|&
name|destTrimmedRect
argument_list|,
name|D3DTEXF_NONE
argument_list|)
decl_stmt|;
name|readRenderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
name|drawRenderTarget
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"BlitFramebufferANGLE failed: StretchRect returned %x."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|blitDepthStencil
condition|)
block|{
name|IDirect3DSurface9
modifier|*
name|readDepthStencil
init|=
name|readFramebuffer
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
name|IDirect3DSurface9
modifier|*
name|drawDepthStencil
init|=
name|drawFramebuffer
operator|->
name|getDepthStencil
argument_list|()
decl_stmt|;
name|HRESULT
name|result
init|=
name|mDevice
operator|->
name|StretchRect
argument_list|(
name|readDepthStencil
argument_list|,
name|NULL
argument_list|,
name|drawDepthStencil
argument_list|,
name|NULL
argument_list|,
name|D3DTEXF_NONE
argument_list|)
decl_stmt|;
name|readDepthStencil
operator|->
name|Release
argument_list|()
expr_stmt|;
name|drawDepthStencil
operator|->
name|Release
argument_list|()
expr_stmt|;
if|if
condition|(
name|FAILED
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"BlitFramebufferANGLE failed: StretchRect returned %x."
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
DECL|function|VertexDeclarationCache
name|VertexDeclarationCache
operator|::
name|VertexDeclarationCache
parameter_list|()
member_init_list|:
name|mMaxLru
argument_list|(
literal|0
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_VERTEX_DECL_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|mVertexDeclCache
index|[
name|i
index|]
operator|.
name|vertexDeclaration
operator|=
name|NULL
expr_stmt|;
name|mVertexDeclCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|function|~VertexDeclarationCache
name|VertexDeclarationCache
operator|::
name|~
name|VertexDeclarationCache
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_VERTEX_DECL_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mVertexDeclCache
index|[
name|i
index|]
operator|.
name|vertexDeclaration
condition|)
block|{
name|mVertexDeclCache
index|[
name|i
index|]
operator|.
name|vertexDeclaration
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|applyDeclaration
name|GLenum
name|VertexDeclarationCache
operator|::
name|applyDeclaration
parameter_list|(
name|IDirect3DDevice9
modifier|*
name|device
parameter_list|,
name|TranslatedAttribute
name|attributes
index|[]
parameter_list|,
name|ProgramBinary
modifier|*
name|programBinary
parameter_list|,
name|GLsizei
name|instances
parameter_list|,
name|GLsizei
modifier|*
name|repeatDraw
parameter_list|)
block|{
operator|*
name|repeatDraw
operator|=
literal|1
expr_stmt|;
name|int
name|indexedAttribute
init|=
name|MAX_VERTEX_ATTRIBS
decl_stmt|;
name|int
name|instancedAttribute
init|=
name|MAX_VERTEX_ATTRIBS
decl_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
comment|// Find an indexed attribute to be mapped to D3D stream 0
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|attributes
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
if|if
condition|(
name|indexedAttribute
operator|==
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
if|if
condition|(
name|attributes
index|[
name|i
index|]
operator|.
name|divisor
operator|==
literal|0
condition|)
block|{
name|indexedAttribute
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|instancedAttribute
operator|==
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
if|if
condition|(
name|attributes
index|[
name|i
index|]
operator|.
name|divisor
operator|!=
literal|0
condition|)
block|{
name|instancedAttribute
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
break|break;
comment|// Found both an indexed and instanced attribute
block|}
block|}
if|if
condition|(
name|indexedAttribute
operator|==
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
return|return
name|GL_INVALID_OPERATION
return|;
block|}
block|}
name|D3DVERTEXELEMENT9
name|elements
index|[
name|MAX_VERTEX_ATTRIBS
operator|+
literal|1
index|]
decl_stmt|;
name|D3DVERTEXELEMENT9
modifier|*
name|element
init|=
operator|&
name|elements
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|attributes
index|[
name|i
index|]
operator|.
name|active
condition|)
block|{
name|int
name|stream
init|=
name|i
decl_stmt|;
if|if
condition|(
name|instances
operator|>
literal|0
condition|)
block|{
comment|// Due to a bug on ATI cards we can't enable instancing when none of the attributes are instanced.
if|if
condition|(
name|instancedAttribute
operator|==
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
operator|*
name|repeatDraw
operator|=
name|instances
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
name|indexedAttribute
condition|)
block|{
name|stream
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|stream
operator|=
name|indexedAttribute
expr_stmt|;
block|}
name|UINT
name|frequency
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|attributes
index|[
name|i
index|]
operator|.
name|divisor
operator|==
literal|0
condition|)
block|{
name|frequency
operator|=
name|D3DSTREAMSOURCE_INDEXEDDATA
operator||
name|instances
expr_stmt|;
block|}
else|else
block|{
name|frequency
operator|=
name|D3DSTREAMSOURCE_INSTANCEDATA
operator||
name|attributes
index|[
name|i
index|]
operator|.
name|divisor
expr_stmt|;
block|}
name|device
operator|->
name|SetStreamSourceFreq
argument_list|(
name|stream
argument_list|,
name|frequency
argument_list|)
expr_stmt|;
name|mInstancingEnabled
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mAppliedVBs
index|[
name|stream
index|]
operator|.
name|serial
operator|!=
name|attributes
index|[
name|i
index|]
operator|.
name|serial
operator|||
name|mAppliedVBs
index|[
name|stream
index|]
operator|.
name|stride
operator|!=
name|attributes
index|[
name|i
index|]
operator|.
name|stride
operator|||
name|mAppliedVBs
index|[
name|stream
index|]
operator|.
name|offset
operator|!=
name|attributes
index|[
name|i
index|]
operator|.
name|offset
condition|)
block|{
name|device
operator|->
name|SetStreamSource
argument_list|(
name|stream
argument_list|,
name|attributes
index|[
name|i
index|]
operator|.
name|vertexBuffer
argument_list|,
name|attributes
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|attributes
index|[
name|i
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
name|mAppliedVBs
index|[
name|stream
index|]
operator|.
name|serial
operator|=
name|attributes
index|[
name|i
index|]
operator|.
name|serial
expr_stmt|;
name|mAppliedVBs
index|[
name|stream
index|]
operator|.
name|stride
operator|=
name|attributes
index|[
name|i
index|]
operator|.
name|stride
expr_stmt|;
name|mAppliedVBs
index|[
name|stream
index|]
operator|.
name|offset
operator|=
name|attributes
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
block|}
name|element
operator|->
name|Stream
operator|=
name|stream
expr_stmt|;
name|element
operator|->
name|Offset
operator|=
literal|0
expr_stmt|;
name|element
operator|->
name|Type
operator|=
name|attributes
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|element
operator|->
name|Method
operator|=
name|D3DDECLMETHOD_DEFAULT
expr_stmt|;
name|element
operator|->
name|Usage
operator|=
name|D3DDECLUSAGE_TEXCOORD
expr_stmt|;
name|element
operator|->
name|UsageIndex
operator|=
name|programBinary
operator|->
name|getSemanticIndex
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|element
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|instances
operator|==
literal|0
operator|||
name|instancedAttribute
operator|==
name|MAX_VERTEX_ATTRIBS
condition|)
block|{
if|if
condition|(
name|mInstancingEnabled
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|device
operator|->
name|SetStreamSourceFreq
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mInstancingEnabled
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|static
specifier|const
name|D3DVERTEXELEMENT9
name|end
init|=
name|D3DDECL_END
argument_list|()
decl_stmt|;
operator|*
operator|(
name|element
operator|++
operator|)
operator|=
name|end
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_VERTEX_DECL_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|VertexDeclCacheEntry
modifier|*
name|entry
init|=
operator|&
name|mVertexDeclCache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|entry
operator|->
name|cachedElements
argument_list|,
name|elements
argument_list|,
operator|(
name|element
operator|-
name|elements
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|D3DVERTEXELEMENT9
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|entry
operator|->
name|vertexDeclaration
condition|)
block|{
name|entry
operator|->
name|lruCount
operator|=
operator|++
name|mMaxLru
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|vertexDeclaration
operator|!=
name|mLastSetVDecl
condition|)
block|{
name|device
operator|->
name|SetVertexDeclaration
argument_list|(
name|entry
operator|->
name|vertexDeclaration
argument_list|)
expr_stmt|;
name|mLastSetVDecl
operator|=
name|entry
operator|->
name|vertexDeclaration
expr_stmt|;
block|}
return|return
name|GL_NO_ERROR
return|;
block|}
block|}
name|VertexDeclCacheEntry
modifier|*
name|lastCache
init|=
name|mVertexDeclCache
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_VERTEX_DECL_CACHE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mVertexDeclCache
index|[
name|i
index|]
operator|.
name|lruCount
operator|<
name|lastCache
operator|->
name|lruCount
condition|)
block|{
name|lastCache
operator|=
operator|&
name|mVertexDeclCache
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lastCache
operator|->
name|vertexDeclaration
operator|!=
name|NULL
condition|)
block|{
name|lastCache
operator|->
name|vertexDeclaration
operator|->
name|Release
argument_list|()
expr_stmt|;
name|lastCache
operator|->
name|vertexDeclaration
operator|=
name|NULL
expr_stmt|;
comment|// mLastSetVDecl is set to the replacement, so we don't have to worry
comment|// about it.
block|}
name|memcpy
argument_list|(
name|lastCache
operator|->
name|cachedElements
argument_list|,
name|elements
argument_list|,
operator|(
name|element
operator|-
name|elements
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|D3DVERTEXELEMENT9
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|->
name|CreateVertexDeclaration
argument_list|(
name|elements
argument_list|,
operator|&
name|lastCache
operator|->
name|vertexDeclaration
argument_list|)
expr_stmt|;
name|device
operator|->
name|SetVertexDeclaration
argument_list|(
name|lastCache
operator|->
name|vertexDeclaration
argument_list|)
expr_stmt|;
name|mLastSetVDecl
operator|=
name|lastCache
operator|->
name|vertexDeclaration
expr_stmt|;
name|lastCache
operator|->
name|lruCount
operator|=
operator|++
name|mMaxLru
expr_stmt|;
return|return
name|GL_NO_ERROR
return|;
block|}
DECL|function|markStateDirty
name|void
name|VertexDeclarationCache
operator|::
name|markStateDirty
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VERTEX_ATTRIBS
condition|;
name|i
operator|++
control|)
block|{
name|mAppliedVBs
index|[
name|i
index|]
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
block|}
name|mLastSetVDecl
operator|=
name|NULL
expr_stmt|;
name|mInstancingEnabled
operator|=
literal|true
expr_stmt|;
comment|// Forces it to be disabled when not used
block|}
block|}
end_namespace
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|glCreateContext
name|gl
operator|::
name|Context
modifier|*
name|glCreateContext
parameter_list|(
specifier|const
name|egl
operator|::
name|Config
modifier|*
name|config
parameter_list|,
specifier|const
name|gl
operator|::
name|Context
modifier|*
name|shareContext
parameter_list|,
name|bool
name|notifyResets
parameter_list|,
name|bool
name|robustAccess
parameter_list|)
block|{
return|return
operator|new
name|gl
operator|::
name|Context
argument_list|(
name|config
argument_list|,
name|shareContext
argument_list|,
name|notifyResets
argument_list|,
name|robustAccess
argument_list|)
return|;
block|}
DECL|function|glDestroyContext
name|void
name|glDestroyContext
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|)
block|{
operator|delete
name|context
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|gl
operator|::
name|getContext
argument_list|()
condition|)
block|{
name|gl
operator|::
name|makeCurrent
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|glMakeCurrent
name|void
name|glMakeCurrent
parameter_list|(
name|gl
operator|::
name|Context
modifier|*
name|context
parameter_list|,
name|egl
operator|::
name|Display
modifier|*
name|display
parameter_list|,
name|egl
operator|::
name|Surface
modifier|*
name|surface
parameter_list|)
block|{
name|gl
operator|::
name|makeCurrent
argument_list|(
name|context
argument_list|,
name|display
argument_list|,
name|surface
argument_list|)
expr_stmt|;
block|}
DECL|function|glGetCurrentContext
name|gl
operator|::
name|Context
modifier|*
name|glGetCurrentContext
parameter_list|()
block|{
return|return
name|gl
operator|::
name|getContext
argument_list|()
return|;
block|}
block|}
end_extern
end_unit
